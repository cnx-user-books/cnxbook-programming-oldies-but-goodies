<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Simple Animation with the Java 3D API</h2>
<i>Learn how to use the RotationInterpolator and Alpha classes of the Java 3D API, along 
with other necessary classes, to write simple animation programs. Also 
learn the rationale by which those classes are used to write animation programs.</i>
<p><b>Published:</b>&nbsp; October 23, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1544</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Acknowledgement">Acknowledgement</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Download">Download</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#FF0000"><b>Third in a series of lessons</b></font></p>
<p>This is the third lesson in a series of lessons designed to start with Java 3D 
basics and work up to the general complexity of the program that I explained in 
the earlier lesson titled &quot;Understanding Lighting in the Java 3D API&quot; <i>
(see <a href="#Resources">Resources</a>).</i></p>
<p>The first lesson in this series was titled &quot;Back to Basics in the 
Java 3D API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; The 
previous lesson was titled &quot;Digging a Little Deeper into the Java 3D API.&quot;&nbsp; 
This lesson is titled &quot;Simple Animation with the Java 3D API.&quot;&nbsp; My current 
plan is for future lessons to deal with the detailed behavior of an <b>Alpha</b> 
time-base object, user and object interaction as well as 
advanced animation and textures.</p>
<p><font color="#FF0000"><b>What you will learn</b></font></p>
<p>In this lesson, I will teach you how to use the <b>RotationInterpolator</b> 
and <b>Alpha</b> classes of the Java 3D API, along 
with other necessary classes, to write a 
simple animation program.&nbsp; I will also explain the rationale by 
which those classes are used to write animation 
programs.</p>
<p><b><font color="#ff0000">Compiling and running Java 3D programs</font></b></p>
<p>In order to compile and run programs using the Java 3D API, you will need to 
download and install the Java 3D API software.&nbsp; As of the date of this writing, 
version 1.5.0 is available for <a href="#Download">download</a>.</p>
<p>In addition, you will need to <a href="#Download">download</a> 
and install either <b>Microsoft DirectX</b> or <b>OpenGL</b>.&nbsp; All of the sample 
programs in this series of tutorials were developed and tested using Microsoft 
DirectX.&nbsp; They were not tested using OpenGL.</p>
<h3><a name="Acknowledgement">Acknowledgement</a></h3>
<p>Much of what I will be teaching you about the use of the Java 3D API was 
learned by studying the tutorial by Dennis J Bouvier <i>(see
<a href="#Resources">Resources</a>)</i> along with other online 
material, some of which is also listed in <a href="#Resources">
Resources</a>.</p>
<p>You can view the Bouvier tutorial online.&nbsp; You can also
<a href="#Download">download</a> the Bouvier tutorial as a set of PDF files 
along with the source code for the example programs in his tutorial.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Bouvier's recipe for animation in Java 
	3D.</li>
	<li><a href="#Figure_2">Figure 2</a>. Four screen shots from the running 
	animation program.</li>
	<li><a href="#Figure_3">Figure 3</a>. A screen shot from the original 
	program.</li>
	<li><a href="#Figure_4">Figure 4</a>. New location for the white sphere.</li>
	<li><a href="#Figure_5">Figure 5</a>. Class/subclass hierarchy for the 
	Interpolator class.</li>
	<li><a href="#Figure_6">Figure 6</a>. One of two RotationInterpolator 
	constructors.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. The beginning of the program named 
	Java3D005.</li>
	<li><a href="#Listing_2">Listing 2</a>. Create the small white sphere in a 
	different location.</li>
	<li><a href="#Listing_3">Listing 3</a>. More code with no changes.</li>
	<li><a href="#Listing_4">Listing 4</a>. Code with an expanded purpose.</li>
	<li><a href="#Listing_5">Listing 5</a>. Some modified code.</li>
	<li><a href="#Listing_6">Listing 6</a>. Beginning of the code that 
	implements the animation.</li>
	<li><a href="#Listing_7">Listing 7</a>. Create an Alpha object.</li>
	<li><a href="#Listing_8">Listing 8</a>. Create a RotationInterpolator 
	object.</li>
	<li><a href="#Listing_9">Listing 9</a>. Specify the active animation region.</li>
	<li><a href="#Listing_10">Listing 10</a>. Construct the entire BranchGroup 
	object.</li>
	<li><a href="#Listing_11">Listing 11</a>. Wrap it up.</li>
	<li><a href="#Listing_12">Listing 12</a>. Program listing for the program 
	named Java3D005.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#FF0000"><b>The need to understand animation</b></font></p>
<p>It seems that one of the first things that programming students want to do 
these days is to write game programs.&nbsp; Modern game programs almost always 
involve animation.&nbsp; Therefore, before a student can write a game program, 
that student must understand animation <i>(in addition to many other important 
programming concepts)</i>.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="What_is_animation">What is animation</a></b><br />
  According to Bouvier, <i>&quot;The distinction between animation and interaction is 
	whether the behavior is activated in response to the passing of time or in 
	response to user activities...&quot;</i>&nbsp; By this, he means that animation 
	behavior is in response to the passage of time whereas interactive behavior 
	is in response to user activities.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Animation versus interactive behavior</b></font></p>
<p>In reality, most modern game programs involve both
animation and interaction <i>(see the <a href="#What_is_animation">sidebar</a>)</i>.&nbsp; This lesson 
will deal with animation.&nbsp; Interactive behavior using the Java 3D API will 
be reserved for a future lesson.</p>
<p><font color="#FF0000"><b>Simple versus advanced animation</b></font></p>
<p>Animation can involve some very complex programming concepts.&nbsp; 
Fortunately, simple animation is relatively easy to achieve using the Java 3D API 
once you understand the required structure.&nbsp; 
This lesson will concentrate on simple animation for the purpose of exposing the 
underlying capabilities of Java 3D in this regard.&nbsp; Advanced 
animation behavior will be reserved for a future lesson.</p>
<p><font color="#FF0000"><b>Bouvier's recipe for animation in Java 3D</b></font></p>
<p>Although it's not the only way to create animation, one way to create animation in Java 3D is 
through the use an <b>Interpolator</b> object.&nbsp; <i>(That is the approach that will 
be used in this lesson.)</i>&nbsp; Bouvier's recipe for using an <b>Interpolator</b> 
to create animation consists of the five steps shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Bouvier's recipe for animation in Java 3D.</b><table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <ol>
		<li>Create a target TransformGroup<ul>
			<li>Set the ALLOW_TRANSFORM_WRITE capability</li>
		</ul>
		</li>
		<li>Create an Alpha object<ul>
			<li>Specify the time parameters for the alpha</li>
		</ul>
		</li>
		<li>Create the interpolator object<ul>
			<li>Have it reference the Alpha and TransformGroup objects</li>
			<li>Customize the behavior parameters</li>
		</ul>
		</li>
		<li>Specify a scheduling region<ul>
			<li>Set the scheduling region for the behavior</li>
		</ul>
		</li>
		<li>Make the behavior a child of the TransformGroup </li>
		</ol>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Most of the terminology in Figure 1 will probably mean very little to you at 
this point.&nbsp; However, by the end of this lesson, you should be able to 
understand the meaning of each of the steps in Figure 1.&nbsp; When you 
have finished studying this lesson, you should understand the rudiments of 
creating Java 3D programs that exhibit animation behavior.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain a program named <b>Java3D005</b>.&nbsp; 
The purpose of this program is to create a simple animation that will 
animate the virtual universe that was developed in the previous lesson in the 
program named <b>Java3D004</b>.</p>
<p><font color="#FF0000"><b>Four screen shots</b></font></p>
<p>Figure 2 shows four screen shots that were taken while the program was 
running.&nbsp; The top two images were taken while one version of the program was running.&nbsp; The bottom two images were taken while 
a different version of the program was 
running.</p>


<p><b><a name="Figure_2">Figure 2</a>. Four screen shots from the running animation program.</b>
<table border="0" bgcolor="#ffffff">
	<tr>
		<td><img border="0" src="java1544a01.jpg" width="236" height="236"></td>
		<td><img border="0" src="java1544a04.jpg" width="236" height="236"></td>
	</tr>
		<tr>
		<td><img border="0" src="java1544a02.jpg" width="236" height="236"></td>
		<td><img border="0" src="java1544a03.jpg" width="236" height="236"></td>
	</tr>
</table>
</p>


<p><font color="#FF0000"><b>A screen shot from the original program</b></font></p>
<p>Figure 3 shows a screen shot from the original version of the program named
<b>Java3D004</b>.&nbsp; This is the virtual universe that was modified slightly 
and animated in this new program.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. A screen shot from the original program.</b><table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1544b01.jpg" width="234" height="233"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>
<a name="The_location_of_the_white_sphere_was_changed">The location of the white 
sphere was changed</a></b></font></p>
<p>You will note in Figure 3 that the white sphere is down, to the left of, and in 
front of the yellow sphere.&nbsp; The location of the white sphere was changed 
in the animated version of the universe in this program.&nbsp; The change causes the white sphere to be in the horizontal 
plane defined by the X and Z axes.&nbsp; This makes it relatively easy to animate the white 
sphere so as to make it appear to be in a 
synchronous circular orbit around the yellow sphere.</p>
<p>Figure 4 shows the beginning <i>(and ending)</i> location for the white sphere in this animation 
program.&nbsp; <i>(Compare Figure 4 with Figure 3 to see the difference.)</i></p>
<p>
 <b><a name="Figure_4">Figure 4</a>. New location for the white sphere. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1544a05.jpg" width="236" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two versions of the program</b></font></p>
<p>Two different versions of this version are presented and explained in this 
lesson.&nbsp; In the primary version, the universe was animated by causing 
the yellow sphere to slowly rotate on its vertical axis through one 
complete revolution.&nbsp; The yellow sphere carries the small white sphere along with it 
just as though the white sphere is orbiting the yellow sphere in a synchronous 
circular orbit.&nbsp; The small green sphere does not rotate with the yellow sphere, but 
maintains its original position.&nbsp; The point light source also maintains its 
original position.</p>
<p><font color="#FF0000"><b>Screen shots from the first version</b></font></p>
<p>The top two images in Figure 2 show two screen shots taken from this version 
of the program while it was running.&nbsp; The image on the top left shows the 
universe just before the white sphere disappeared behind the yellow sphere, 
moving from right to left behind the yellow sphere.&nbsp; The image on the top 
right shows the universe just as the white sphere was emerging from behind the 
yellow sphere on the left.</p>
<p><font color="#FF0000"><b>Facets or divisions on the yellow sphere</b></font></p>
<p>I purposely used a small value for the number of divisions <i>(facets)</i> 
for the yellow sphere to cause it to have an uneven surface.&nbsp; This makes it 
possible to see that the yellow sphere is actually rotating around its vertical 
axis by observing the movement of the highlights emitted by the facets on the 
surface of the yellow sphere.&nbsp; Otherwise, the fact that the yellow sphere 
is rotating would not be visible because the surface of the sphere would be the 
same all over, containing no identifying features.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="Switching_between_the_versions">Switching between the versions</a></b><br />
  The ability to switch between the two different versions of the program is 
	accomplished by using comments to enable and disable a couple of statements.&nbsp; 
	The program contains instructions explaining how to do this.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The second version</b></font></p>
<p>The second version of the program <i>(see the
<a href="#Switching_between_the_versions">sidebar</a>)</i> causes the light source to also rotate around the vertical axis in 3D space in 
synchronism with the rotation of the yellow sphere.&nbsp; This produces a very different 
animation effect, which causes shadows to move across surfaces of the spheres.</p>
<p><font color="#FF0000"><b>The original position of the light source</b></font></p>
<p>The bottom two images in Figure 2 show screen shots from this version of the 
program while it is running.&nbsp; The original <i>(and final)</i> position of 
the light source is above the center of, to the right of, and in front of the 
yellow sphere <i>(sort of over the viewer's right shoulder)</i>.&nbsp; This 
location is indicated by the illumination of the yellow sphere in the top two 
images in Figure 2.</p>
<p><font color="#FF0000"><b>Two screen shots from the running program</b></font></p>
<p>The bottom left image in Figure 2 shows the point in time where the white 
sphere and the light source were moving around the right side of the yellow 
sphere <i>(moving from front to back at this point)</i>.&nbsp; Thus, the right 
sides of all three spheres are illuminated.&nbsp; The light source leads the 
white sphere by about 30 degrees, causing only a small portion of the white 
sphere to be illuminated <i>(from the viewpoint of the viewer)</i> in this image.</p>
<p>The bottom right image shows the point in time where the white sphere and the 
light source were just emerging from behind the yellow sphere on it's left 
side <i>(moving from back to front at this point)</i>, causing the left side of 
all three spheres to be illuminated.&nbsp; </p>
<p><font color="#FF0000"><b>Testing</b></font></p>
<p>This program was tested using Java SE 6, and 
Java 3D 1.5.0 running under Windows XP.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<font color="#FF0000"><b>The program named Java3D005</b></font><p>Much of the 
code in this program is very similar to, or identical to code that I presented 
and explained in the previous lesson titled &quot;Digging a Little Deeper into the 
Java 3D API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; Therefore, I 
won't repeat those explanations.&nbsp; Rather, I will simply make note of the 
fact that the code is similar to code explained in earlier lessons.</p>
<p>I will present and explain this program in fragments.&nbsp; A complete 
listing of the program is presented in Listing 12 near the end of the lesson.&nbsp; 
The first code fragment is shown in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. The beginning of the program named 
Java3D005. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//This is the top-level driver class for this program.
// This program could be written without the use of this
// driver class.  However, I decided to keep it intact
// for future expansions that require a user input GUI.
public class Java3D005 extends Frame{
  public static void main(String[] args){
    Java3D005 thisObj = new Java3D005();
  }//end main
  //----------------------------------------------------//
  
  public Java3D005(){//constructor
    setTitle("Copyright 2007, R.G.Baldwin");
    add(new Label("You can build a GUI here."));
    setBounds(236,0,235,75);
    setVisible(true);
    
    //Instantiate the object in which the Java 3D
    // universe will be displayed.
    TheScene theScene = new TheScene();

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class, from which the object in which
  // the Java 3D universe will be displayed is
  // instantiated.
  class TheScene extends Frame{
    
    TheScene(){//constructor
    
      //Create a Canvas3D object to be used for rendering
      // the Java 3D universe.  Place it in the CENTER of
      // the Frame.
      Canvas3D canvas3D = new Canvas3D(
              SimpleUniverse.getPreferredConfiguration());
      add(BorderLayout.CENTER,canvas3D);
    
      //Construct the objects that will be displayed in
      // the scene
      
      //Create and set properties for the large yellow
      // sphere.
      //Begin by describing the appearance of the surface
      // of the large sphere.  Make the color of the large
      // sphere yellow.
      Material yellowSphMaterial = new Material();
      yellowSphMaterial.setDiffuseColor(1.0f,1.0f,0.0f);
      Appearance yellowSphAppearance = new Appearance();
      yellowSphAppearance.setMaterial(yellowSphMaterial);

      //Now instantiate the large yellow sphere with 9
      // divisions.  Set the radius to 0.5. The reason for
      // setting GENERATE_NORMALS is unclear at this time.
      Sphere yellowSph = new Sphere(
                               0.5f,
                               Primitive.GENERATE_NORMALS,
                               9,
                               yellowSphAppearance);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>With the exception of the need for some additional import directives, this 
program begins exactly like the program in the previous lesson.&nbsp; You can 
view the complete list of import directives in Listing 12</p>
<p><font color="#FF0000">
<b>Create the small white sphere in a different location</b></font></p>
<p>The code in Listing 2 creates the small white sphere, but places it in a
<a href="#The_location_of_the_white_sphere_was_changed">different</a> location
<i>(as explained earlier)</i> than was the case in the original program.&nbsp; 
The coordinate value that produced the change in location is highlighted in 
boldface in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Create the small white sphere in a 
different location. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Now create a small white sphere with 50 divisions.
      Material whiteSphMaterial = new Material();
      whiteSphMaterial.setDiffuseColor(1.0f,1.0f,1.0f);
      Appearance whiteSphAppearance = new Appearance();
      whiteSphAppearance.setMaterial(whiteSphMaterial);
      Sphere whiteSph = new Sphere(
                               0.10f,
                               Primitive.GENERATE_NORMALS,
                               50,
                               whiteSphAppearance);
      
      //Translate the location of the white sphere to make
      // it closer to the viewer than the yellow sphere at
      // the origin. 
      Transform3D whiteTransform = new Transform3D();
      //The following is a modification to the original
      // virtual universe that causes the white sphere to
      // be in the horizontal plane.  This causes the
      // white sphere to later be animated so as to appear
      // to be in a synchronous orbit around the yellow
      // sphere.
      whiteTransform.setTranslation(
                          new Vector3f(-0.5f,<b>-0.0f</b>,0.5f));
      TransformGroup whiteTransformGroup = 
                                     new TransformGroup();
      whiteTransformGroup.setTransform(whiteTransform);
      whiteTransformGroup.addChild(whiteSph);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>More code with no changes</b></font></p>
<p>The code is Listing 3 is the same as the code in the original program.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. More code with no changes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Now create a small green sphere located up to the
      // right and behind the yellow sphere.
      Material greenSphMaterial = new Material();
      greenSphMaterial.setDiffuseColor(0.0f,1.0f,0.0f);
      Appearance greenSphAppearance = new Appearance();
      greenSphAppearance.setMaterial(greenSphMaterial);
      Sphere greenSph = new Sphere(
                               0.10f,
                               Primitive.GENERATE_NORMALS,
                               50,
                               greenSphAppearance);
      Transform3D greenTransform = new Transform3D();
      greenTransform.setTranslation(
                           new Vector3f(0.5f,0.5f,-0.5f));
      TransformGroup greenTransformGroup = 
                                     new TransformGroup();
      greenTransformGroup.setTransform(greenTransform);
      greenTransformGroup.addChild(greenSph);


      //Add a white point light, in front of, to the
      // right of, and above the yellow sphere.
      Color3f pointLightColor = 
                              new Color3f(1.0f,1.0f,1.0f);
      Point3f pointLightPosition = 
                              new Point3f(1.0f,1.0f,2.0f);
      Point3f pointLightAttenuation = 
                              new Point3f(1.0f,0.0f,0.0f);
      
      PointLight pointLight = new PointLight(
                                   pointLightColor,
                                   pointLightPosition,
                                   pointLightAttenuation);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Code with an expanded purpose</b></font></p>
<p>The code in Listing 4 is the same as corresponding code in the earlier 
program.&nbsp; However, the purpose of this code has been expanded.&nbsp; In 
particular, in this program, the <b>BoundingSphere</b> object is not only used to 
determine which objects to illuminate, it is also used to determine which 
objects to animate.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Code with an expanded purpose. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Create a BoundingSphere object and use it to
      // determine which objects to light.  Also use it
      // later to determine which objects to animate.
      BoundingSphere boundingSphere = 
         new BoundingSphere(new Point3d(0.0,0.0,0.0),1.0);
      pointLight.setInfluencingBounds(boundingSphere);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Some modified code</b></font></p>
<p>Listing 5 shows some code that was modified by deleting statements from the 
original code.&nbsp; The explanation for this change is highlighted in boldface 
comments in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Some modified code. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Create an empty Java 3D universe and associate it 
      // with the Canvas3D object in the CENTER of the
      // frame.
      SimpleUniverse simpleUniverse = 
                             new SimpleUniverse(canvas3D);
      
      //Create and populate a BranchGroup object.
      BranchGroup branchGroup = new BranchGroup();
<b>      //Add objects to the branchGroup.  Note that the
      // yellow and white spheres are no longer added to
      // the branchGroup object, but rather are later
      // added to a group that causes them to be animated.
</b>      branchGroup.addChild(greenTransformGroup);
      //If you disable the following statement and enable
      // a statement later that adds the pointLight to
      // the rotationXform, you will see a very different
      // effect.  This will cause the light source to
      // rotate with the yellow sphere causing the shadows
      // to move across the spheres.
      branchGroup.addChild(pointLight);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the code that implements the animation</b></font></p>
<p>Listing 6 contains two new statements that begin the implementation of the animation.&nbsp; 
These two statements accomplish the first step in Bouvier's recipe in Figure 1.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Beginning of the code that implements the 
animation. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //THE CODE THAT IMPLEMENTS THE ANIMATION BEGINS HERE

      TransformGroup rotationXform = new TransformGroup();
      rotationXform.setCapability(
                    TransformGroup.ALLOW_TRANSFORM_WRITE);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 6&nbsp;creates a transform group that will be populated with the yellow sphere and the white sphere transform group. 
All objects or groups of objects belonging to this new group will be animated by 
subsequent code.</p>
<p><font color="#FF0000"><b>Setting the ALLOW_TRANSFORM_WRITE capability</b></font></p>
<p>As I understand it, by default, once an object or a group of objects is 
placed in a transform group, those objects cannot be accessed for modification.&nbsp;
<i>(Actually, it may be more correct to say that the behavior of the transform 
cannot be modified.)</i>&nbsp; However, there are a number of capabilities that 
can be set on a transform group by calling the <b>setCapability</b> method on 
the group object.&nbsp; Listing 6 sets the <b>ALLOW_TRANSFORM_WRITE</b> 
capability on the new transform making it possible to modify the behavior of the 
transform over time in order to produce the animated behavior.</p>
<p><font color="#FF0000">
<b>Create an Alpha object</b></font></p>
<p>Listing 7 creates an <b>Alpha</b> object that will be used to cause the objects in the 
<b>rotationXform</b> group
<i>(see Listing 6)</i> to complete one <i>animation cycle</i> in 20 seconds <i>(20,000 
milliseconds)</i>.&nbsp; This satisfies step 2 in Bouvier's recipe shown in Figure 
1.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Create an Alpha object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Alpha rotationAlpha = new Alpha(1,20000);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b><a name="What_is_an_Alpha_object">What is an Alpha object</a>?</b></font></p>
<p>According to Sun, </p>
<blockquote>
	<p><i>&quot;The alpha NodeComponent object provides common methods for converting 
	a time value into an alpha value (a value in the range 0 to 1). The Alpha 
	object is effectively a function of time that generates alpha values in the 
	range [0,1] when sampled: f(t) = [0,1]. A primary use of the Alpha object is 
	to provide alpha values for Interpolator behaviors. The function f(t) and 
	the characteristics of the Alpha object are determined by user-definable 
	parameters&quot;</i></p>
</blockquote>
<p>Stated more simply, an <b>Alpha</b> object provides a time base that can be 
used by an <b>Interpolator</b> object in the process of producing the 
intermediate views of the universe that are needed during an animation of the 
universe.</p>
<p><font color="#FF0000"><b>Four overloaded constructors</b></font></p>
<p>There are four different overloaded constructors for the <b>Alpha</b> class, 
with the most complex constructor requiring the following ten parameters:</p>
<ol>
	<li><b>loopCount</b> - number of times to run this alpha; a value of -1 
	specifies that the alpha loops indefinitely.</li>
	<li><b>mode</b> - indicates whether the increasing alpha parameters or the 
	decreasing alpha parameters or both are active.</li>
	<li><b>triggerTime</b> - time in milliseconds since the start time that this 
	object first triggers</li>
	<li><b>phaseDelayDuration</b> - number of milliseconds to wait after 
	triggerTime before actually starting this alpha</li>
	<li><b>increasingAlphaDuration</b> - period of time during which alpha goes 
	from zero to one</li>
	<li><b>increasingAlphaRampDuration</b> - period of time during which the 
	alpha step size increases at the beginning of the increasingAlphaDuration 
	and, correspondingly, decreases at the end of the increasingAlphaDuration. 
	This value is clamped to half of increasingAlphaDuration. NOTE: a value of 
	zero means that the alpha step size remains constant during the entire 
	increasingAlphaDuration.</li>
	<li><b>alphaAtOneDuration</b> - period of time that alpha stays at one</li>
	<li><b>decreasingAlphaDuration</b> - period of time during which alpha goes 
	from one to zero</li>
	<li><b>decreasingAlphaRampDuration</b> - period of time during which the 
	alpha step size increases at the beginning of the decreasingAlphaDuration 
	and, correspondingly, decreases at the end of the decreasingAlphaDuration. 
	This value is clamped to half of decreasingAlphaDuration. NOTE: a value of 
	zero means that the alpha step size remains constant during the entire 
	decreasingAlphaDuration. </li>
	<li><b>alphaAtZeroDuration</b> - period of time that alpha stays at zero</li>
</ol>
<p>&nbsp;</p>
<p><font color="#FF0000"><b>A simpler constructor was used</b></font></p>
<p>Listing 7 uses a simpler constructor than that indicated above.&nbsp; 
According to Sun, the constructor used in Listing 7 <i>&quot;takes only the loopCount 
and increasingAlphaDuration as parameters and assigns the default values to all 
of the other parameters.&quot;</i></p>
<p>The first parameter in Listing 7 specifies that the animation will continue 
through only one animation cycle.&nbsp; <i>(The concept of an animation cycle 
will be explained later.)</i></p>
<p>The second parameter in Listing 7 specifies that the single animation cycle 
will be executed from start to finish over a time period of 20,000 milliseconds 
<i>(20 seconds)</i>.&nbsp; As a result, twenty seconds are required for the white 
sphere to make one complete revolution around the yellow sphere and return to 
its original starting position as shown in Figure 4.</p>
<p><font color="#FF0000">
<b>Create a RotationInterpolator object</b></font></p>
<p>Listing 8 creates a <b>RotationInterpolator</b> object that will cause the objects in the
<b>rotationXform</b> group to rotate 360 degrees about the vertical axis <i>(one 
animation cycle)</i> in the time specified for one cycle by the <b>rotationAlpha</b> object
<i>(20 seconds)</i>.&nbsp; 
This satisfies step 3 in Bouvier's recipe shown in Figure 1.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Create a RotationInterpolator object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      RotationInterpolator rotator = 
                           new RotationInterpolator(
                             rotationAlpha,rotationXform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>What is a RotationInterpolator object?</b></font></p>
<p>Note that Bouvier's recipe in Figure 1 simply specifies the creation of an <i>
interpolator</i> object, not necessarily a <b>RotationInterpolator</b> object.&nbsp;
<b>RotationInterpolator</b> is an indirect subclass of the <b>Interpolator</b> 
class.</p>
<p><font color="#FF0000">
 <b>Class/subclass hierarchy for the Interpolator class</b></font></p>
<p>As of Java 3D version 1.5.0, the class/subclass hierarchy for the <b>
Interpolator</b> class includes the seventeen different classes shown in Figure 
5.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Class/subclass hierarchy for the 
	Interpolator class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <ul>
		<li>Interpolator (abstract)<ul>
			<li>ColorInterpolator</li>
			<li>SwitchValueInterpolator</li>
			<li>TransformInterpolator (abstract)<ul>
				<li>KBSplinePathInterpolator<ul>
					<li>KBRotPosScaleSplinePathInterpolator</li>
				</ul>
				</li>
				<li>PathInterpolator<ul>
					<li>PositionPathInterpolator</li>
					<li>RotationPathInterpolator</li>
					<li>RotPosPathInterpolator</li>
					<li>RotPosScalePathInterpolator</li>
				</ul>
				</li>
				<li>PositionInterpolator</li>
				<li><b>RotationInterpolator</b></li>
				<li>ScaleInterpolator</li>
				<li>TCBSplinePathInterpolator<ul>
					<li>RotPosScaleTCBSplinePathInterpolator</li>
				</ul>
				</li>
			</ul>
			</li>
			<li>TransparencyInterpolator</li>
		</ul>
		</li>
		</ul>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Many different animation possibilities</b></font></p>
<p>Presumably, step 3 of Bouvier's recipe could be satisfied using most of the 
classes shown in Figure 5 to instantiate an object.&nbsp; <i>(If I counted correctly, only two of 
the classes shown in Figure 5 are abstract.)</i>&nbsp; The large number of 
non-abstract classes and the names of the classes in Figure 5 indicate that many 
different animation possibilities are available using an <b>Interpolator</b> 
object instantiated from one of the subclasses of the <b>Interpolator</b> class.</p>
<p><font color="#FF0000"><b>The RotationInterpolator class</b></font></p>
<p>For this program and this lesson, we are interested only in the <b>
RotationInterpolator</b> class.&nbsp; <i>(I will explore the use of some of the 
other interpolator classes in a future lesson on advanced animation using the Java 3D API.)</i></p>
<p>Sun describes the <b>
RotationInterpolator</b> class as follows:</p>
<blockquote>
	<p><i>&quot;Rotation interpolator behavior. This class defines a behavior that 
	modifies the rotational component of its target TransformGroup by linearly 
	interpolating between a pair of specified angles (using the value generated 
	by the specified Alpha object). The interpolated angle is used to generate a 
	rotation transform about the local Y-axis of this interpolator.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b><a name="How_does_this_work">How does this work</a>?</b></font></p>
<p>While I can't tell you exactly how this process works behind the scenes, I 
can tell you how it appears to work from a functional viewpoint.</p>
<p>During each animation cycle, the<b> Alpha</b> object generates a value that 
increases from a value of 0.0 to a value of 1.0 according to the parameter 
values used in the construction of the <b>Alpha</b> object.</p>
<p><font color="#FF0000"><b>Get the alpha value at uniform intervals</b></font></p>
<p>There is a clock that fires events at uniform intervals.&nbsp; Each time an 
event is fired, the <b>Interpolator</b> object gets the alpha value <i>(between 
0.0 and 1.0)</i> from the <b>Alpha</b> object.&nbsp; My guess is that the <b>
Interpolator</b> object calls the <b>value</b> method of the <b>Alpha</b> object 
which has the following behavior to get the alpha value:</p>
<blockquote>
	<p><i>&quot;This method returns a value between 0.0 and 1.0 inclusive, based on 
	the current time and the time-to-alpha parameters established for this 
	alpha...&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Used to establish percentage of completion</b></font></p>
<p>The <b>Interpolator</b> object uses each successive alpha value as a fraction 
or percentage of 1.0 to determine the percentage of completion of one animation 
cycle that should have transpired at that point in time.&nbsp; That information 
is used to transform the initial state of the universe into a new state that 
reflects the appropriate percentage completion of the animation cycle.&nbsp; 
This new state is rendered on the screen.</p>
<p>In order to create complex Java 3D animations, you need to understand the 
detailed behavior of an Alpha object for the different combinations and values 
of parameters passed to the constructor.&nbsp; I will explain that detailed 
behavior in a future lesson </p>
<p><font color="#FF0000"><b>Tricking the viewer</b></font></p>
<p>The series of renderings showing successive intermediate states of the 
universe tricks the viewer into seeing the change in position, orientation, 
color, transparency, etc., as a <i>(hopefully)</i> smooth transition from the 
initial state to the final state.</p>
<p><font color="#FF0000"><b>The visual quality of the animation</b></font></p>
<p>The extent to which the transition appears to be smooth will depend on many 
factors, including the computational and rendering speed of the computer.&nbsp; 
For example, on my relatively slow laptop computer, the transition produced by 
this program has a couple of obvious pauses causing the animation quality to be 
less than ideal.</p>
<p><font color="#FF0000">
 <b>One of two RotationInterpolator constructors</b></font></p>
<p>The <b>RotationInterpolator</b> class provides two overloaded constructors.&nbsp; 
Listing 8 uses the simpler of the two, which is described in Figure 6.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. One of two RotationInterpolator 
	constructors. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <h3>RotationInterpolator</h3>
		<pre>public <b>RotationInterpolator</b>(Alpha&nbsp;alpha,
                            TransformGroup&nbsp;target)</pre>
		<dl>
			<dd>Constructs a trivial rotation interpolator with a specified 
			target, a default axisOfTranform set to identity, a minimum angle 
			of 0.0f, and a maximum angle of 2*pi radians. 
			<p>&nbsp;<dl>
				<dt><b>Parameters:</b> </dt>
				<dd><code>alpha</code> - The alpha object for this Interpolator
				</dd>
				<dd><code>target</code> - The target for this rotation 
				Interpolator</dd>
			</dl>
			</dd>
		</dl>
&nbsp;</td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>An animation cycle</b></font></p>
<p>Finally we have the information that we need to understand what constitutes 
an <i>&quot;animation cycle.&quot;</i>&nbsp; When this interpolator is used to animate a 
target transform group of objects, the target will be rotated from a minimum 
angle of 0.0 degrees to a maximum angle of 2*pi radians <i>(360 degrees or one 
revolution)</i>.&nbsp; This is one <i>animation cycle</i> as produced by this 
interpolator<i>.</i></p>
<blockquote>
	<p><i>(Other <b>Interpolator</b> objects are likely to have different 
	animation cycles.&nbsp; For example, the animation cycle for a <b>
	ColorInterpolator</b> object is not likely to be based on angles.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The interpolator and alpha objects work together</b></font></p>
<p>With the interpolator and the alpha object working together as described
<a href="#How_does_this_work">earlier</a>, this one 
revolution of target rotation will take place, over the elapsed time specified 
in the construction of the alpha object <i>(20 seconds in this program)</i>.</p>
<p>As we learned <a href="#What_is_an_Alpha_object">earlier</a>, the various 
constructor parameters for the <b>Alpha</b> object determine how this will be 
accomplished:</p>
<ul>
	<li>As a function of time</li>
	<li>The number of repetitions</li>
	<li>The elapsed 
execution time for one animation cycle, etc.</li>
</ul>
<p>For the simple constructor used in 
this program <i>(see Listing 7)</i> the first parameter specifies the number of 
repetitions and the second parameter specifies the elapsed execution time for 
one animation cycle.</p>
<p>For this program <i>(again see Listing 7)</i>, the parameters specify 
that a single animation cycle will be executed over an elapsed time of 20 
seconds.&nbsp; This causes the yellow and white spheres shown in Figure 2 to 
rotate one revolution around the Y-axis over a period of 20 seconds.</p>
<p><font color="#FF0000">
<b>Specify the active animation region</b></font></p>
<p>Apparently for reasons of computational efficiency, it is necessary to 
specify a region in 3D space to which the animation behavior will be applied.&nbsp; 
Presumably, any objects belonging to the target group that fall inside that 
region will be animated and objects belonging to the target group that fall 
outside that region will be ignored insofar as animation is concerned.</p>
<p>Listing 9 calls the <b>setSchedulingBounds</b> method on the <b>
RotationInterpolator</b> object to establish that region.&nbsp; </p>
<p>
<b><a name="Listing_9">Listing 9</a>. Specify the active animation region. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      rotator.setSchedulingBounds(boundingSphere);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The setSchedulingBounds method</b></font></p>
<p>The <b>setSchedulingBounds</b> method requires an incoming parameter of type
<b>Bounds</b>.&nbsp; The abstract <b>Bounds</b> class has the following three 
subclasses:</p>
<ul>
	<li>BoundingBox</li>
	<li>BoundingPolytope</li>
	<li>BoundingSphere</li>
</ul>
<p>An object of any of these three classes will satisfy the parameter type 
requirement.&nbsp; This program uses an object of the <b>BoundingSphere</b> 
class that defines a spherical bounding region, which is defined by a center 
point and a radius.&nbsp; In fact, this program uses the same <b>BoundingSphere</b> 
object for this purpose that is also used to specify which objects will be 
illuminated by the point light source <i>(see Listing 4)</i>.</p>
<p>The statement in Listing 9 satisfies step 4 in Bouvier's recipe shown in 
Figure 1.</p>
<p><font color="#FF0000">
<b>Construct the entire BranchGroup object</b></font></p>
<p>Listing 10 constructs the entire <b>BranchGroup</b> object by adding objects 
as children of other objects in the correct hierarchy.&nbsp; This satisfies step 
5 in Bouvier's recipe.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Construct the entire BranchGroup object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Add the objects to the group that controls
      // the animation.
      rotationXform.addChild(rotator);
      rotationXform.addChild(yellowSph);
      rotationXform.addChild(whiteTransformGroup);
      //Disable the earlier statement that adds the
      // pointLight to the branchGroup and enable the
      // following statement to get a very different
      // effect
      //rotationXform.addChild(pointLight);
      
      //Add the group that will be animated to the main
      // branch of the scene graph.
      branchGroup.addChild(rotationXform);
      
      
      //THE CODE THAT IMPLEMENTS THE ANIMATION ENDS HERE</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Wrap it up</b></font></p>
<p>Listing 10 also signals the end of the code that has anything to do 
specifically with animation in this program.</p>
<p>The remaining program code is shown in Listing 11.</p>

<p>
<b><a name="Listing_11">Listing 11</a>. Wrap it up. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Specify the apparent location of the viewer's eye.
      simpleUniverse.getViewingPlatform().
                             setNominalViewingTransform();

      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(branchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
      
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//
    
  }//end inner class TheScene

}//end class Java3D005</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 11 is the same as the code that I explained in the 
previous lesson.&nbsp; I won't repeat that explanation here.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 12 into your text editor, 
compile it, and execute it.&nbsp; Experiment with it, making changes, and observing 
the results of your changes.</p>
<p>Don't forget that Listing 12 contains two versions of the same program.&nbsp; 
As written, the program should produce the animated screen output shown by the 
top two images in Figure 2.&nbsp; For this version, the light source maintains 
its original position while the yellow and white spheres rotate about the 
vertical axis in 3D space.</p>
<p>If you make the changes indicated by the comments in the program, it should 
produce the animated screen output shown by the bottom two images in Figure 2.&nbsp; 
For this version, the light source also rotates about the vertical axis in 3D 
space in synchronism with the rotation of the yellow sphere.</p>
<p>In both versions, the green sphere is unaffected by the animation and 
maintains its original position.&nbsp; Of course, the shadows on that sphere 
change as the light source rotates around the vertical axis in the second 
version of the program.</p>
<p>Remember, you will need to download and install the Java 3D API plus either 
Microsoft DirectX or OpenGL to compile and execute these programs.&nbsp; See
<a href="#Download">Downloads</a> for links to the web sites from 
which this material can be downloaded. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you how to use the <b>RotationInterpolator</b> and
<b>Alpha</b> classes of the Java 3D API, along 
with other necessary classes, to write a simple 
animation program.&nbsp; I also explained the rationale by which 
those classes are used to write animation 
programs.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, I will explain the detailed behavior of an <b>Alpha</b> 
time-base object.&nbsp; The topics for future lessons include interactive Java 3D programs, advanced animation, and surfaces.</p>
<h2 align="center"><a name="Download">Download</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/developer/onlineTraining/java3d/javaa3d.zip">
	Getting Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by 
	Dennis J Bouvier</li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/collateral/examples.zip">
	Source code</a> for example programs from the Bouvier tutorial above</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Version 1.5.0</a> of the Java 3D API</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Implementation documentation</a> for version 1.5.0 of the Java 3D API</li>
	<li>
	<a href="http://www.gamesforwindows.com/en-US/AboutGFW/Pages/DirectX10.aspx">
	Microsoft DirectX10</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/java-media/3D/">Main page</a> for 
	the Java 3D API</li>
	<li>Java 3D <a href="http://wiki.java.net/bin/view/Javadesktop/Java3DFAQ">
	FAQ</a></li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/reference/api/index.html">
	Online documentation</a> for Java 3D version 1.3 <i>(see
	<a href="#Download">Download</a> for v1.5.0 documentation)</i></li>
	<li><a href="http://java.sun.com/developer/onlineTraining/java3d/">Getting 
	Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by Dennis J 
	Bouvier</li>
	<li>
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/javax/media/j3d/doc-files/intro.html">
	Introduction to the Java 3D API</a> with links to other tutorial information</li>
	<li>Various Java 3D <a href="http://www.java3d.org/">resources</a></li>
	<li>Another Java 3D <a href="http://www.java3d.org/tutorial.html">tutorial</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/626051">306</a> 
	Java 2D Graphics, Simple Affine Transforms&nbsp; </li>
	<li><a href="http://www.developer.com/java/other/article.php/3622246">1540</a> 
	Understanding Lighting in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3701536">1541</a> Back to Basics in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3704116">1542</a> Digging a Little Deeper into the Java 3D API</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program discussed in this lesson is presented in 
Listing 12 below.
<p>
<b><a name="Listing_12">Listing 12</a>. Program listing for the program named 
Java3D005. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Java3D005.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to create a simple 
animation program that will animate the virtual universe 
that was developed in Java3D004.

The location of the white sphere was modified relative to
the original virtual universe.  The modification causes 
the white sphere to be in the horizontal plane.  This 
causes the white sphere to later be animated so as to 
appear to be in a synchronous orbit around the yellow
sphere.

The universe was animated by causing the yellow sphere to
slowly rotate on its vertical axis through one complete
revolution.  The yellow sphere carries the small white 
sphere along with it just as though the white sphere is 
orbiting the yellow sphee in a synchronous circular orbit.
 
The small green sphere does not rotate with the yellow 
sphere, but maintains its original position.

In addition, comments are provided to show how to cause
the light source to also rotate around the vertical axis
in 3D space in synchronism with the rotation of the yellow
sphere.  This produces a very different effect causing 
shadows to move across the spheres.

Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.geometry.Sphere;
import com.sun.j3d.utils.geometry.Primitive;
import javax.media.j3d.Appearance;
import javax.media.j3d.Material;
import javax.media.j3d.PointLight;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.Alpha;
import javax.media.j3d.RotationInterpolator;
import javax.vecmath.Vector3f;
import javax.vecmath.Point3f;
import javax.vecmath.Point3d;
import javax.vecmath.Color3f;
import java.awt.Frame;
import java.awt.Label;
import java.awt.BorderLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;


//This is the top-level driver class for this program.
// This program could be written without the use of this
// driver class.  However, I decided to keep it intact
// for future expansions that require a user input GUI.
public class Java3D005 extends Frame{
  public static void main(String[] args){
    Java3D005 thisObj = new Java3D005();
  }//end main
  //----------------------------------------------------//
  
  public Java3D005(){//constructor
    setTitle("Copyright 2007, R.G.Baldwin");
    add(new Label("You can build a GUI here."));
    setBounds(236,0,235,75);
    setVisible(true);
    
    //Instantiate the object in which the Java 3D
    // universe will be displayed.
    TheScene theScene = new TheScene();

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class, from which the object in which
  // the Java 3D universe will be displayed is
  // instantiated.
  class TheScene extends Frame{
    
    TheScene(){//constructor
    
      //Create a Canvas3D object to be used for rendering
      // the Java 3D universe.  Place it in the CENTER of
      // the Frame.
      Canvas3D canvas3D = new Canvas3D(
              SimpleUniverse.getPreferredConfiguration());
      add(BorderLayout.CENTER,canvas3D);
    
      //Construct the objects that will be displayed in
      // the scene
      
      //Create and set properties for the large yellow
      // sphere.
      //Begin by describing the appearance of the surface
      // of the large sphere.  Make the color of the large
      // sphere yellow.
      Material yellowSphMaterial = new Material();
      yellowSphMaterial.setDiffuseColor(1.0f,1.0f,0.0f);
      Appearance yellowSphAppearance = new Appearance();
      yellowSphAppearance.setMaterial(yellowSphMaterial);

      //Now instantiate the large yellow sphere with 9
      // divisions.  Set the radius to 0.5. The reason for
      // setting GENERATE_NORMALS is unclear at this time.
      Sphere yellowSph = new Sphere(
                               0.5f,
                               Primitive.GENERATE_NORMALS,
                               9,
                               yellowSphAppearance);
      
      //Now create a small white sphere with 50 divisions.
      Material whiteSphMaterial = new Material();
      whiteSphMaterial.setDiffuseColor(1.0f,1.0f,1.0f);
      Appearance whiteSphAppearance = new Appearance();
      whiteSphAppearance.setMaterial(whiteSphMaterial);
      Sphere whiteSph = new Sphere(
                               0.10f,
                               Primitive.GENERATE_NORMALS,
                               50,
                               whiteSphAppearance);
      
      //Translate the location of the white sphere to make
      // it closer to the viewer than the yellow sphere at
      // the origin. 
      Transform3D whiteTransform = new Transform3D();
      //The following is a modification to the original
      // virtual universe that causes the white sphere to
      // be in the horizontal plane.  This causes the
      // white sphere to later be animated so as to appear
      // to be in a synchronous orbit around the yellow
      // sphere.
      whiteTransform.setTranslation(
                          new Vector3f(-0.5f,-0.0f,0.5f));
      TransformGroup whiteTransformGroup = 
                                     new TransformGroup();
      whiteTransformGroup.setTransform(whiteTransform);
      whiteTransformGroup.addChild(whiteSph);
      
      
      //Now create a small green sphere located up to the
      // right and behind the yellow sphere.
      Material greenSphMaterial = new Material();
      greenSphMaterial.setDiffuseColor(0.0f,1.0f,0.0f);
      Appearance greenSphAppearance = new Appearance();
      greenSphAppearance.setMaterial(greenSphMaterial);
      Sphere greenSph = new Sphere(
                               0.10f,
                               Primitive.GENERATE_NORMALS,
                               50,
                               greenSphAppearance);
      Transform3D greenTransform = new Transform3D();
      greenTransform.setTranslation(
                           new Vector3f(0.5f,0.5f,-0.5f));
      TransformGroup greenTransformGroup = 
                                     new TransformGroup();
      greenTransformGroup.setTransform(greenTransform);
      greenTransformGroup.addChild(greenSph);


      //Add a white point light, in front of, to the
      // right of, and above the yellow sphere.
      Color3f pointLightColor = 
                              new Color3f(1.0f,1.0f,1.0f);
      Point3f pointLightPosition = 
                              new Point3f(1.0f,1.0f,2.0f);
      Point3f pointLightAttenuation = 
                              new Point3f(1.0f,0.0f,0.0f);
      
      PointLight pointLight = new PointLight(
                                   pointLightColor,
                                   pointLightPosition,
                                   pointLightAttenuation);
      
      //Create a BoundingSphere object and use it to
      // determine which objects to light.  Also use it
      // later to determine which objects to animate.
      BoundingSphere boundingSphere = 
         new BoundingSphere(new Point3d(0.0,0.0,0.0),1.0);
      pointLight.setInfluencingBounds(boundingSphere);
      
  
      //Create an empty Java 3D universe and associate it 
      // with the Canvas3D object in the CENTER of the
      // frame.
      SimpleUniverse simpleUniverse = 
                             new SimpleUniverse(canvas3D);
      
      //Create and populate a BranchGroup object.
      BranchGroup branchGroup = new BranchGroup();
      //Add objects to the branchGroup.  Note that the
      // yellow and white spheres are no longer added to
      // the branchGroup object, but rather are later
      // added to a group that causes them to be animated.
      branchGroup.addChild(greenTransformGroup);
      //If you disable the following statement and enable
      // a statement later that adds the pointLight to
      // the rotationXform, you will see a very different
      // effect.  This will cause the light source to
      // rotate with the yellow sphere causing the shadows
      // to move across the spheres.
      branchGroup.addChild(pointLight);
      
      
      //THE CODE THAT IMPLEMENTS THE ANIMATION BEGINS HERE
            
      //Create a transform group that will be populated
      // with the yellow sphere and the white sphere
      // transform group. Objects or groups of objects
      // belonging to this group will be animated.
      TransformGroup rotationXform = new TransformGroup();
      rotationXform.setCapability(
                    TransformGroup.ALLOW_TRANSFORM_WRITE);
      
      //Create an Alpha object that will be used to cause
      // the objects in the rotationXform group to
      // complete one animation cycle in 20 seconds.
      Alpha rotationAlpha = new Alpha(1,20000);
      
      //Create an Interpolator object that will cause the
      // objects in the rotationXform group to rotate 360
      // degrees about the vertical axis in the time
      // specified for one cycle by the rotationAlpha
      // object.
      RotationInterpolator rotator = 
                           new RotationInterpolator(
                             rotationAlpha,rotationXform);
      
      //Specify a region in 3D space containing the
      // objects or groups of objects that will be
      // animated.
      rotator.setSchedulingBounds(boundingSphere);
      
      //Add the objects to the group that controls
      // the animation.
      rotationXform.addChild(rotator);
      rotationXform.addChild(yellowSph);
      rotationXform.addChild(whiteTransformGroup);
      //Disable the earlier statement that adds the
      // pointLight to the branchGroup and enable the
      // following statement to get a very different
      // effect
      //rotationXform.addChild(pointLight);
      
      //Add the group that will be animated to the main
      // branch of the scene graph.
      branchGroup.addChild(rotationXform);
      
      
      //THE CODE THAT IMPLEMENTS THE ANIMATION ENDS HERE

      
      //Specify the apparent location of the viewer's eye.
      simpleUniverse.getViewingPlatform().
                             setNominalViewingTransform();

      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(branchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
      
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//
    
  }//end inner class TheScene

}//end class Java3D005</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java &quot;java 3D&quot; SimpleUniverse ColorCube BranchGroup canvas 
setNominalViewingTransform getPreferredConfiguration SimpleUniverse Sphere 
Primitive Appearance Material PointLight BranchGroup Canvas3D Transform3D 
TransformGroup BoundingSphere Vector3f Point3f Point3d Color3f 
ALLOW_TRANSFORM_WRITE Alpha Interpolator RotationInterpolator </p>
<p>-end- </p>
</body>
</html>
