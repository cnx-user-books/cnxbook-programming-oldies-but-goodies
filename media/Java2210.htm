<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Java JAXP, Transforming XML to XHTML<br>
</h2>
<p style="font-style: italic;">Baldwin shows you how to use XSLT to
transform an XML
document into an XHTML document.&nbsp; He also shows you how to
write Java code to perform the same transformation.
</p>
<p><b>Published:</b>&nbsp; August 24, 2004<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2210</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li><a
 href="file:///C:/Baldwin/AA-School/JavaAdv/notes/Java2210.htm#Some_Details_Regarding_XHTML">Some
Details Regarding
XHTML</a></li>
  <li><a href="#Some_Details_Regarding_XSLT">Some Details Regarding XSLT</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <ul>
    <li><a href="#The_XSLT_Transformation">The XSLT Transformation</a></li>
    <li><a href="#The_Java_Code_Transformation">The Java Code
Transformation</a><br>
    </li>
  </ul>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p>In the previous lesson entitled <a
 href="http://www.developer.com/java/other/article.php/3361261">Java
JAXP, Writing Java Code to Emulate an XSLT Transformation</a>, I showed
you how <span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);">to
write a Java program that mimics an XSLT transformation for converting
an XML file into a text file.</span></span><span
 style="color: rgb(0, 0, 0);">&nbsp; I also showed that once you have a
library of Java
methods that
emulate XSLT elements, it is no more difficult to
write a Java program to transform an XML document than it is to
write an XSL stylesheet to transform the same document.</span></p>
In this lesson, I will show you how to use XSLT to transform an XML
document into an XHTML document.&nbsp; I will also show you how to
write Java code that performs the same transformation.<br>
<p>This lesson is one in a series designed to teach you how to use JAXP
and Sun's Java Web Services Developer
Pack
<i>(JWSDP).</i></p>
The first lesson in the series was entitled <a
 href="http://www.developer.com/java/other/article.php/3099751">Java
API for XML Processing (JAXP), Getting Started</a>.&nbsp;
As mentioned above, the
previous lesson was entitled&nbsp;<a
 href="http://www.developer.com/java/other/article.php/3361261">Java
JAXP, Writing Java Code to Emulate an XSLT Transformation</a>.<br>
<p><font color="#ff0000"><b>JAXP, XML, XSL, XSLT, W3C, and XHTML, a
Review</b></font><br>
</p>
<p><a href="http://java.sun.com/xml/jaxp/">JAXP</a> is an
API designed
to help you write programs for creating and processing XML
documents. It is a critical part of Sun's Java Web Services Developer
Pack
<i>(JWSDP).</i><br>
</p>
<a href="http://www.w3.org/XML/">XML</a> is an acronym for the&nbsp;e<b>X</b>tensible
<b>M</b>arkup <b>L</b>anguage.&nbsp;
I will assume that you already
understand
XML, and will teach you how to use JAXP to write programs for
creating and processing XML documents.<br>
<br>
<a href="http://www.w3.org/TR/xsl/">XSL</a> is an acronym for <span
 style="font-style: italic;">Extensible Stylesheet language.</span>&nbsp;
<a href="http://www.w3.org/TR/xslt">XSLT</a> is an acronym for <span
 style="font-style: italic;">XSL Transformations.</span>
<p> </p>
<center> </center>
The numerous uses of XSLT include the following:<br>
<ul>
  <li>Transforming non-XML documents into XML documents.</li>
  <li>Transforming XML documents into other XML documents.</li>
  <li>Transforming XML documents into non-XML documents.</li>
</ul>
<span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">This
lesson explains a Java program
that transforms an XML document into an XHTML document.<br>
<br>
An <a href="http://www.w3.org/TR/xhtml1/">XHTML</a> document is an XML
document that provides a rigorous alternative to the use of an <a
 href="http://www.w3.org/MarkUp/">HTML</a> document.&nbsp; According to
the <a href="http://www.w3.org/">W3C</a>, XHTML 1.0 is a <span
 style="font-style: italic;">"Reformulation of HTML 4 in XML 1.0."</span><br>
<br>
</span></span><b><font color="#ff0000">Viewing tip</font></b>
<p> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different listings and figures while
you are reading about them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b></p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java and XML tutorials.&nbsp; You will find those
lessons
published at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
As of the date of this writing, Gamelan doesn't maintain a
consolidated index of my tutorial lessons, and sometimes
they are difficult to locate there.&nbsp; You will find a consolidated
index at <font color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#ff0000"><b>A tree structure in memory</b></font><br>
</p>
<p>A DOM parser can be used to
create a tree structure in memory that represents an XML
document.&nbsp; In Java, that tree structure is encapsulated in an
object of the interface type <b>Document</b>. <br>
</p>
<p><font color="#ff0000"><b>Many operations are possible</b></font><br>
</p>
<p>Given an object of type <b>Document</b> <span
 style="font-style: italic;">(often called a DOM tree),</span> there
are many
methods that
can be invoked on the object to perform a variety of operations.</p>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">Two ways to
transform an XML document</span><br>
</p>
<p>There are at least two ways to transform the contents of an XML
document into another document:<br>
</p>
<ul>
  <li>By writing Java code to manipulate the DOM tree and perform the
transformation.</li>
  <li>By using XSLT to perform the transformation.</li>
</ul>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">A skeleton
library of Java methods</span><br>
</p>
<p>This is one of several lessons that show you
how to write the skeleton of a Java library containing methods that
emulate the most common XSLT elements.&nbsp; Once you have the library,
writing Java code to transform XML documents consists mainly of writing
a short driver program to access those methods.&nbsp; Given the proper
library of methods, it is no more difficult to write a
Java program to perform the transformation than it is to write
an
XSLT stylesheet.<br>
</p>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">Library is
not my primary purpose</span><br>
</p>
<p>However, my primary purpose in these lessons is not to provide such
a library, but rather is to help you understand how to use a DOM
tree to create, modify, and manipulate XML documents.&nbsp; By
comparing Java code that manipulates a DOM tree with similar XSLT
operations, you will have an opportunity to learn a little about XSLT
in the process of learning how to manipulate a DOM tree using Java code.<br>
</p>
<h2 style="text-align: center;"><a name="Some_Details_Regarding_XHTML"></a>Some
Details Regarding XHTML<br>
</h2>
<p><span style="color: rgb(255, 0, 0); font-weight: bold;">
XHTML documents, a special case</span><br>
<br>
An XHTML document is an XML document.&nbsp; It is a rigorous
alternative to an HTML document.&nbsp; <br>
</p>
<p>One of
the interesting
uses of XSLT is the transformation of XML documents into
XHTML documents.&nbsp; This
makes it possible to render the information contained in an XML
document using an XHTML-compatible Web browser.<br>
</p>
<p><b><font color="#ff0000">Where does the transformation take place?</font></b>
</p>
<p>When transforming an XML document for rendering
with an XHTML browser, the transformation can take place anywhere
between the
source of the XML document and the browser. </p>
<p><b><font color="#ff0000">Transforming on the server</font></b>
</p>
<p>For example, a transformation program can be written in Java and run
on a web
server as a
servlet, or it can be written as a JavaBeans component and accessed
from a <i>scriptlet</i> in JavaServer pages (JSP).<br>
</p>
<p><b><font color="#ff0000">Transforming at the browser</font></b> </p>
<p>The transformation can also be performed by the browser.&nbsp; For
example, Microsoft IE 6.0 and XSLT can be used for this
purpose.<br>
</p>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">Will
transform XML into XHTML</span><br>
</p>
<p>This and the next several lessons will illustrate parallel Java code
and XSLT transformations to transform XML documents into XHTML
documents.&nbsp; The sample programs will illustrate various aspects of
the manipulation of a DOM tree using Java code.<br>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Requirements
for XHTML documents</span><br>
<p>According to <a href="http://www.fbeedle.com/57-0.html">Web Design
&amp; Development Using XHTML</a> by Griffin, Morales, and Finnegan, an
XHTML document differs from an HTML document in the following ways:<br>
</p>
<ul>
  <li>XHTML documents must be well-formed.</li>
  <li>Element and attribute names must be in lower case.</li>
  <li>Non-empty elements require end tags.</li>
  <li>Attribute values must always be quoted.</li>
  <li>XHTML documents have no attribute minimization.</li>
  <li>XHTML documents end empty elements.</li>
  <li>XHTML documents use elements with id and name attributes.</li>
  <li>XHTML documents use Document Type Declarations</li>
  <li>XHTML documents use XML namespaces.</li>
</ul>
Although it is not a requirement, an XHTML document often has an XML
declaration at the beginning to identify the document as an XML
document.
<h2 style="text-align: center;"><a name="Some_Details_Regarding_XSLT"></a>Some
Details Regarding XSLT</h2>
<p>Previous lessons in this series have provided quite a bit of
detailed information regarding the operation of XSLT.&nbsp; Therefore,
this discussion will be brief.<br>
</p>
<p>Assume that an XML document has been parsed to produce a DOM
tree
in memory that represents the XML document.<br>
</p>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">Execute
template rules</span><br>
</p>
<p>An XSLT processor starts examining the DOM tree at its root
node.&nbsp; It
obtains instructions from the XSLT stylesheet telling it how to
navigate the
tree, and how to treat each node that it encounters along the way.<br>
</p>
As each node is encountered, the processor searches the stylesheet
looking for a template rule that governs how to treat nodes of that
type.&nbsp;&nbsp;If the
processor finds
a template rule that matches the node type, it performs the operations
indicated by the template rule.&nbsp; Otherwise, it
executes a built-in template rule appropriate to that node.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Literal text in
template rules</span><br>
<p>If the template rule being applied
contains literal text, that literal text is used to
create text in the output.<br>
</p>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">Traversal of
the DOM tree</span><br>
</p>
There are at least two XSLT elements that can be used to
traverse the children of a context node:<br>
<ul>
  <li>xsl:apply-templates<br>
  </li>
  <li>xsl:for-each<br>
  </li>
</ul>
<p><span style="font-weight: bold; color: rgb(255, 0, 0);">The
xsl:apply-templates element</span><br>
</p>
<p>The <span style="font-weight: bold;">xsl:apply-templates</span>
element was discussed in detail in previous lessons.<br>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
xsl:for-each element</span><br>
<p>The <span style="font-weight: bold;">xsl:for-each</span> element
executes an iterative
examination of all child nodes of the context node that
match a required <span style="font-weight: bold;">select</span><span
 style="font-style: italic;"> </span>attribute.&nbsp; As each child
node is examined, it is processed using XSLT elements that form the
content of the <span style="font-weight: bold;">xsl:for-each</span>
element in the template rule.<br>
</p>
<p>This lesson will include examples that use the <span
 style="font-weight: bold;">xsl:for-each</span> element in addition to
the <span style="font-weight: bold;">xsl:apply-templates</span>
element.&nbsp; The lesson will also explain a Java method that emulates
the <span style="font-weight: bold;">xsl:for-each</span> element.<br>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Enough talk,
let's
see some code</span>
<p>I will begin by discussing the XML file named <span
 style="font-weight: bold;">Dom03.xml</span> <span
 style="font-style: italic;">(shown in Listing 24 near the end of the
lesson)</span> along with
the XSL
stylesheet file named <span style="font-weight: bold;">Dom03.xsl</span>
<span style="font-style: italic;">(shown in Listing 25).</span><br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A Java program
named Dom03</span>
<br>
</p>
<p>After explaining the transformation produced by applying this
stylesheet to this XML document, I will explain the transformation
produced by processing the XML file with a Java program named <span
 style="font-weight: bold;">Dom03</span> <span
 style="font-style: italic;">(shown in Listing 23) </span>that mimics
the behavior of the XSLT transformation.<br>
</p>
<center>
<h2><a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The XML
file named Dom03.xml</span><br>
<br>
The XML file shown in Listing 24 is relatively straightforward.&nbsp; A
tree view of the XML file is shown in Figure 1.&nbsp; <span
 style="font-style: italic;">(This XML file is both well-formed and
valid.)</span><br>
<span style="font-style: italic;"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>#document DOCUMENT_NODE<br>  A DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  A ELEMENT_NODE<br>    Q ELEMENT_NODE<br>      #text A Big Header<br>    B ELEMENT_NODE<br>      C ELEMENT_NODE<br>        #text Text block 1.<br>      R ELEMENT_NODE<br>        #text A Mid Header<br>      C ELEMENT_NODE<br>        #text Text block 2.<br>      #comment COMMENT_NODE<br>      processor PROCESSING_INSTRUCTION_NODE<br>      S ELEMENT_NODE<br>        #text A Small Header<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text Text block 3.<br>      S ELEMENT_NODE<br>        #text Another Small Header<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text Text block 4.<br>        T ELEMENT_NODE<br>          #text A Smallest Header<br>        B ELEMENT_NODE<br>          C ELEMENT_NODE<br>            #text Text block 5.<br>          D ELEMENT_NODE<br>            E ELEMENT_NODE<br>              #text First list item in E<br>              G ELEMENT_NODE<br>                #text Nested G text element<br>            F ELEMENT_NODE<br>              #text First list item in F<br>            E ELEMENT_NODE<br>              #text Second list item in E<br>            F ELEMENT_NODE<br>              #text Second list item in F<br>            E ELEMENT_NODE<br>              #text Third list item in E<br>            F ELEMENT_NODE<br>              #text Third list item in F<br>          C ELEMENT_NODE<br>            #text Text block 6.<br>        C ELEMENT_NODE<br>          #text Text block 7.<br>      R ELEMENT_NODE<br>        #text Another Mid Header<br>      C ELEMENT_NODE<br>        #text Text block 8.<br>    B ELEMENT_NODE<br>      R ELEMENT_NODE<br>        #text Another Mid Header in Another B<br>      C ELEMENT_NODE<br>        #text Text block 9.<br></pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(This
tree view of the XML file was
produced using a program named DomTree02, which was discussed in an
earlier lesson.<br>
<br>
Note that in order to make the tree view more
meaningful, I manually removed extraneous line breaks and text nodes
associated with those line breaks.&nbsp; The extraneous
line breaks in Figure 1 were caused by extraneous line breaks in the
XML file.&nbsp; The extraneous line breaks in the XML file were placed
there for cosmetic reasons and to force it to fit into this narrow
publication format.)</span><br>
</div>
<br>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">Content of the XML
document</span><br>
<br>
The structure and content of the XML document was primarily designed to
illustrate various transformation concepts that I intend to explain in
this lesson.&nbsp; However, to some extent, I designed the structure
and
content keeping in mind the ultimate rendering of the XHTML file that
will be produced by transforming the XML file into an XHTML file.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The rendered
XHTML file</span><br>
<br>
At this point, I'm going to jump ahead and show you what the final
XHTML file
looks like when rendered using Netscape Navigator v7.1.&nbsp; The
rendering of the XHTML file is shown in Figure 2.&nbsp; <span
 style="font-style: italic;"><br>
<br>
</span></span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(You may find it useful to compare the
rendering in Figure 2 with the XML file structure and content in Figure
1.&nbsp; You should be able to identify text nodes in Figure 1 that
match up with rendered text in Figure 2.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
</span>
<div style="text-align: center;"><span style="color: rgb(0, 0, 0);"><img
 src="java2210a.gif" title="" alt="Rendered XHTML file"
 style="width: 368px; height: 731px;"></span><br>
<br>
<span style="color: rgb(0, 0, 0);">Figure 2 Rendered XHTML file</span><br>
</div>
<h3 style="text-align: center;"><span style="color: rgb(0, 0, 0);"><a
 name="The_XSLT_Transformation"></a>The XSLT Transformation</span></h3>
<span style="color: rgb(0, 0, 0);">
<span style="font-weight: bold; color: rgb(255, 0, 0);">The XSL
stylesheet file named Dom03.xsl</span><br>
<br>
Recall that an XSL stylesheet is itself an XML file, and can therefore
be represented as a tree.&nbsp; Figure 3 presents an
abbreviated tree view of the stylesheet shown in Listing 25.&nbsp; I
colored each of the template rules in this view with alternating
colors of red and blue to make them easier to identify.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(As is often the
case with XSL stylesheets, this stylesheet file is well-formed but it
is not
valid.)</span></span><br>
</div>
<span style="font-style: italic;"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><span style="font-weight: bold; color: rgb(255, 0, 0);">NOTE:  IT WAS NECESSARY TO MANUALLY ENTER SOME</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">LINE BREAKS IN THIS PRESENTATION TO FORCE IT TO</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">FIT INTO THIS NARROW PUBLICATION FORMAT.</span><br><br>#document DOCUMENT_NODE<br>  xsl:stylesheet ELEMENT_NODE<br>      Attribute: version=1.0<br>      Attribute: xmlns:xsl=http://www.w3.org/1999<br>                                   /XSL/Transform<br><span
 style="color: rgb(0, 153, 0);">    xsl:output ELEMENT_NODE</span><br
 style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        Attribute: method=xml</span><br
 style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        Attribute: doctype-public=-//W3C//DTD </span><br
 style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">                       XHTML 1.0 Transitional//EN</span><br
 style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        Attribute: doctype-system=http://www.w3.</span><br
 style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        org/TR/xhtml1/DTD/xhtml1-transitional.dtd</span><br><br><span
 style="color: rgb(255, 0, 0);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        Attribute: match=/</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">      html ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        head ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">          meta ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: http-equiv=content-type</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: content=text/html; </span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">                                    charset=UTF-8</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">          title ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">            #text Generated XHTML file</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        body ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">           table ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: border=2</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: cellspacing=0</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: cellpadding=0</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: width=330</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: bgcolor=#FFFF00</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">            tr ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              td ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">                xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(51, 51, 255);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        Attribute: match=B</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(255, 0, 0);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        Attribute: match=C</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">      p ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(51, 51, 255);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        Attribute: match=D</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      #text List of items in E</span><br
 style="color: rgb(51, 51, 255);"><br style="color: rgb(51, 51, 255);"><span
 style="color: rgb(51, 51, 255);">      ul ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        xsl:for-each ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            Attribute: select=E</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">          li ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            xsl:apply-templates ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      #text List of items in F</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      ol ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        xsl:for-each ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            Attribute: select=F</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">          li ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(255, 0, 0);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        Attribute: match=G</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">      b ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">         xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(51, 51, 255);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        Attribute: match=Q</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      h1 ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(255, 0, 0);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        Attribute: match=R</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">      h2 ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(51, 51, 255);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        Attribute: match=S</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      h3 ELEMENT_NODE</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        xsl:apply-templates ELEMENT_NODE</span><br><br><span
 style="color: rgb(255, 0, 0);">    xsl:template ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        Attribute: match=T</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">      h4 ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        xsl:apply-templates ELEMENT_NODE</span><br></pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">Why abbreviated?</span><br>
<br>
The reason that I refer to this as
an abbreviated tree view is because I manually deleted comment nodes
and
extraneous text nodes in order to emphasize the important elements in
the stylesheet.<br>
<span style="font-style: italic;"><br>
</span></span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(Extraneous text nodes occur as a result
of inserting line breaks in the original XSL document for cosmetic
purposes.<br>
<br>
Note that I also manually entered several line breaks near the
beginning to force the material to fit into
this narrow
publication format.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The root element</span><br>
<br>
The root node of all XML documents is the document node.&nbsp; In
addition to the root node, there is also a root element, and it is
important not to confuse the two.<br>
<br>
As you can see from Figure 3, the root element in the XSL document is
of type <span style="font-weight: bold;">xsl:stylesheet</span>.&nbsp;
The root element has two attributes, each of which is standard for XSL
stylesheets.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(Note that I manually entered a line break
in the second attribute of the <span style="font-weight: bold;">xsl:stylesheet</span>
node to force it to fit into this narrow publication format.&nbsp; </span></span><span
 style="color: rgb(0, 0, 0);"><span style="font-style: italic;">I also
manually entered line breaks into two of the attributes of the <span
 style="font-weight: bold;">xsl:output</span> element node to force
them
to fit into this narrow publication format.</span></span><span
 style="color: rgb(0, 0, 0);"><span style="font-style: italic;">)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
</span><span style="color: rgb(0, 0, 0);">The first attribute provides
the XSLT
version.</span><span style="color: rgb(0, 0, 0);">
The second attribute points to the XSLT namespace URI, which you can
read about in the <a href="http://www.w3.org/TR/xslt">W3C
Recommendation</a>.</span><br>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Children of the
root element node</span><br>
<br>
The root element node <span style="font-style: italic;">(xsl:stylesheet)</span>
in </span><span style="color: rgb(0, 0, 0);">Figure
3 </span><span style="color: rgb(0, 0, 0);">has ten child
nodes, nine of which </span>are template rules.&nbsp; <span
 style="font-style: italic;">(The green child node is not a template
rule.&nbsp; I will discuss it in detail later.)</span>&nbsp; I colored
the template rules in alternating colors of red and blue to make them
easier to identify
visually.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The template
rules</span><br>
<br>
Each of the nine template rules has a match
pattern.&nbsp; The nine match patterns in the order that they appear in
Figure 3 are as follows:<br>
<ol>
  <li>match=/ <span style="font-style: italic;">(root node)</span></li>
  <li>match=B <span style="font-style: italic;">(matches element
node named B)</span></li>
  <li>match=C <span style="font-style: italic;">(matches element
node named C)</span></li>
  <li>match=D<span style="font-style: italic;"> (matches element
node named D)</span></li>
  <li>match=G <span style="font-style: italic;">(matches
element node named G)</span></li>
  <li>match=Q <span style="font-style: italic;">(matches
element node named Q)</span></li>
  <li>match=R <span style="font-style: italic;">(matches
element node named R)</span></li>
  <li>match=S <span style="font-style: italic;">(matches
element node named S)</span></li>
  <li>match=T <span style="font-style: italic;">(matches
element node named T)</span></li>
</ol>
<ul>
</ul>
I will discuss each of the nine template rules later, but before doing
that
I will show you the raw XHTML output produced
by this XSLT transformation.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that the Java program discussed later produces essentially the same
output as the XSLT transformation.)</span><br>
</div>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
The output from
the transformation</span><br>
<br>
The result of performing an XSLT transformation <span
 style="font-style: italic;">(by applying the XSL
stylesheet shown in Listing 25 to the XML file shown in Listing 24)</span>
is
shown in Figure 4.&nbsp; This is the raw XHTML code that
was rendered in Figure 2.<br>
<br>
I will explain the operations in the XSLT transformation that produced
most of the text in Figure 4. <br>
<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">
</span></span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td style="background-color: rgb(255, 204, 204);">
      <pre style="background-color: rgb(153, 255, 153);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">NOTE THAT IT WAS NECESSARY FOR ME TO MANUALLY</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">INSERT LINE BREAKS IN SEVERAL OF THE LONG LINES</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">IN THIS MATERIAL TO FORCE IT TO FIT INTO THIS</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">NARROW PUBLICATION FORMAT.  I ALSO MANUALLY</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">INSERTED LINE BREAKS AT CRITICAL POINTS TO</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">MAKE IT EASIER TO INTERPRET THE MATERIAL </span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">VISUALLY.</span><br><br>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 <br>     Transitional//EN" "http://www.w3.org/TR/<br>     xhtml1/DTD/xhtml1-transitional.dtd"&gt;<br>&lt;html xmlns="http://www.w3.org/1999/xhtml" <br>     xml:lang="en" lang="en"&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv="content-type" <br>     content="text/html; charset=UTF-8"/&gt;<br>&lt;title&gt;Generated XHTML file&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;table border="2" cellspacing="0" cellpadding="0"<br>      width="330" bgcolor="#FFFF00"&gt;&lt;tr&gt;&lt;td&gt;<br>&lt;h1&gt;<br>A Big Header<br>&lt;/h1&gt;<br>&lt;p&gt;<br>Text block 1.<br>&lt;/p&gt;<br>&lt;h2&gt;<br>A Mid Header<br>&lt;/h2&gt;<br>&lt;p&gt;<br>Text block 2.<br>&lt;/p&gt;<br>&lt;h3&gt;<br>A Small Header<br>&lt;/h3&gt;<br>&lt;p&gt;<br>Text block 3.<br>&lt;/p&gt;<br>&lt;h3&gt;<br>Another Small Header<br>&lt;/h3&gt;<br>&lt;p&gt;<br>Text block 4.<br>&lt;/p&gt;<br>&lt;h4&gt;<br>A Smallest Header<br>&lt;/h4&gt;<br>&lt;p&gt;<br>Text block 5.<br>&lt;/p&gt;<br>List of items in E<br>&lt;ul&gt;<br>&lt;li&gt;<br>First list item in E<br>&lt;b&gt;<br>Nested G text element<br>&lt;/b&gt;<br>&lt;/li&gt;<br>&lt;li&gt;<br>Second list item in E<br>&lt;/li&gt;<br>&lt;li&gt;<br>Third list item in E<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>List of items in F<br>&lt;ol&gt;<br>&lt;li&gt;<br>First list item in F<br>&lt;/li&gt;<br>&lt;li&gt;<br>Second list item in F<br>&lt;/li&gt;<br>&lt;li&gt;<br>Third list item in F<br>&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;p&gt;<br>Text block 6.<br>&lt;/p&gt;<br>&lt;p&gt;<br>Text block 7.<br>&lt;/p&gt;<br>&lt;h2&gt;<br>Another Mid Header<br>&lt;/h2&gt;<br>&lt;p&gt;<br>Text block 8.<br>&lt;/p&gt;<br>&lt;h2&gt;<br>Another Mid Header in Another B<br>&lt;/h2&gt;<br>&lt;p&gt;<br>Text block 9.<br>&lt;/p&gt;<br>&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<br>&lt;/body&gt;&lt;/html&gt;<br><br><span
 style="font-weight: bold;">Figure 4</span><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that I manually deleted a couple of extraneous line breaks from
the output shown in Figure 4.&nbsp; It was also necessary for me to
manually insert line breaks in several of the long lines to force the
material to fit in this narrow publication format.&nbsp; I also
manually inserted line breaks at certain critical points to make it
easier to interpret the material visually.</span><span
 style="font-style: italic;">)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Can sometimes
get confusing</span><br>
<br>
I will caution you up front that this discussion can become
confusing but I will do everything that I can to minimize the
confusion.&nbsp; The problem is that the discussion will be mixing
tags, attributes and elements from the XML file with tags, attributes,
and
elements from the stylesheet file and the XHTML file.&nbsp; With so
many tags, attributes, and elements being discussed, it is sometimes
difficult to keep
them separated in your mind.<br>
<br>
In particular, in order to cause the output to be a valid XHTML
document, it is necessary to manually insert XHTML tags, attributes,
and elements in the XSL template rules, which themselves involve XML
tags, attributes, and elements.<br>
<br>
I will make heavy use of color in an attempt to minimize the confusion.<br>
<br>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">The first line of
text</span><br>
<br>
The first line of text in the output shown in Figure 4
is an XML declaration
that is produced automatically by the XSLT transformer available with
JAXP.&nbsp; As I mentioned earlier, such a declaration is not
required, but is highly recommended by most authors.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The xsl:output
element</span><br>
<br>
Before getting into the template rules in Figure 3, I need to explain
the <span style="font-weight: bold;">xsl:output</span> element shown
in green in Figure 3 and reproduced in Figure 5 below for convenient
viewing.</span><br>
<span style="font-style: italic; color: rgb(0, 0, 0);"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:output ELEMENT_NODE<br>        Attribute: method=xml<br>        Attribute: doctype-public=-//W3C//DTD <br>                       XHTML 1.0 Transitional//EN<br>        Attribute: doctype-system=http://www.w3.<br>        org/TR/xhtml1/DTD/xhtml1-transitional.dtd</pre>
      <pre><b>Figure 5</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The XSL
stylesheet version</span><br>
<br>
Listing 1 shows the XSL code that corresponds to the tree view of the
stylesheet element shown in Figure 5.</span><span
 style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:output method="xml" <br>doctype-public="-//W3C//DTD <br>                      XHTML 1.0 Transitional//EN"<br>doctype-system="http://www.w3.<br>    org/TR/xhtml1/DTD/xhtml1-transitional.dtd" /&gt;<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(As on several previous occasions, I need
to remind you that it was necessary for me to manually insert line
breaks in Listing 1 to cause the material to fit in this narrow
publication format.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
Literal text passes
through to the output</span><br>
<br>
As you learned in the previous lesson, any literal text that you
include in your XSL stylesheet will be passed through to the
output.&nbsp; As you will see later, I will cause the output to contain
much of the required XHTML text simply by including that XHTML text as
literal text in the stylesheet.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The stylesheet
is an XML document</span><br>
<br>
It is important to remember, however, that the XSL stylesheet is itself
an XML document, and you cannot include any literal text that would
cause a parser
to reject it as an XML document.&nbsp; You also cannot do anything that
will cause the XSLT processor to reject it as a stylesheet.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">XHTML document
requires a specific DTD reference</span><br>
<br>
One of the things that is required in the XHTML output is the DTD
reference
shown in Figure 6.<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
</span></span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td style="background-color: rgb(255, 204, 204);">
      <pre style="background-color: rgb(153, 255, 153);">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 <br>     Transitional//EN" "http://www.w3.org/TR/<br>     xhtml1/DTD/xhtml1-transitional.dtd"&gt;<br><br><span
 style="font-weight: bold;">Figure 6</span><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(The
material in Figure 6 was extracted from Figure 4 and reproduced here
for convenient viewing.&nbsp; This is one of three alternative DTDs
that can be used with an XHTML document.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
Correct DTD for
XHTML but not for stylesheet</span><br>
<br>
The DTD reference in Figure 6 is a correct DTD reference for an XHTML
document, but it is not a correct DTD reference for an XSL
stylesheet.&nbsp; <span style="font-style: italic;">(In fact,
stylesheets don't require a DTD and often don't have one.)</span><br>
<br>
If you simply include the text from Figure 6 as literal text in the
stylesheet, <span style="font-style: italic;">(in hopes that it will
pass through to the output),</span> the XSLT processor will interpret
it as a DTD reference for the stylesheet, and will attempt to validate
the stylesheet against that reference.&nbsp; The stylesheet will then
be declared invalid and the transformation effort will fail.<br>
<br>
Therefore, you must find a way to cause this DTD reference to end up in
the XHTML document without confusing the XSLT transformation process.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Two ways to
accomplish that</span><br>
<br>
I know of two ways to accomplish that objective.&nbsp; One way is to
include the text from Figure 6 in a CDATA section in the
stylesheet.&nbsp; This
raises some other issues, but it can be made to work.<br>
<br>
The easier way is to use the <span style="font-weight: bold;">xsl:output</span>
element shown in Listing 1 to cause the DTD reference to be written
into the output without confusing the parser or the XSLT processor. <br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The xsl:output
element</span><br>
<br>
</span>Here is a partial quotation from <a
 href="http://www.oreilly.com/catalog/xmlnut/">XML In A Nutshell</a>, <span
 style="font-style: italic;">(which I highly recommend),</span> by
Elliotte Rusty Harold and
W. Scott Means.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">"The
top-level xsl:output element helps determine the exact formatting of
the XML document produced when the result tree is stored in a file,
written onto a stream, or otherwise serialized into a sequence of
bytes."</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Ten optional
attributes</span><br>
<br>
To make a long story short, this element has ten optional attributes
that are used by the XSLT processor to determine the formatting of the
output.&nbsp; The XSLT element shown in Listing 1 specifies values for
three of those optional attributes:<br>
<ol>
  <li>method</li>
  <li>doctype-public</li>
  <li>doctype-system</li>
</ol>
<ul>
</ul>
The default value for <span style="font-weight: bold;">method </span>is
<span style="font-style: italic;">xml</span>, so I could have omitted
this attribute from my stylesheet with no problems.&nbsp; When the
value of this attribute is <span style="font-style: italic;">xml,</span>
<span style="font-style: italic;">(which is the case in Listing 1),</span>
that instructs the processor to produce a well-formed XML document.<br>
<br>
The <span style="font-weight: bold;">doctype-public</span> attribute
sets the public identifier used in the document type declaration.<br>
<br>
The <span style="font-weight: bold;">doctype-system</span> attribute
sets the system identifier used in the document type declaration.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The required
XHTML DTD</span><br>
<br>
There are three allowable DTDs that can be used for an XHTML document:<br>
<ul>
  <li>Strict</li>
  <li>Transitional</li>
  <li>Frameset</li>
</ul>
I'm not going to get into the differences between these three
DTDs in this lesson.&nbsp; Suffice it to say that I elected to use the
transitional
DTD for this example because it is somewhat easier to use than the
other two.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
transitional DTD</span><br>
<br>
Here is what the W3C has to say about the DTD for <a
 href="http://www.w3.org/TR/xhtml1/dtds.html">XHTML 1.0 Transitional</a>:<br>
<br>
<div style="margin-left: 40px;">This DTD module is identified by the
following PUBLIC and SYSTEM identifiers:<br>
<br>
PUBLIC<br>
"-//W3C//DTD XHTML 1.0 Transitional//EN"<br>
SYSTEM<br>
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"<br>
</div>
<br>
As you can see, these values match the <span style="font-weight: bold;">doctype-public</span>
and <span style="font-weight: bold;">doctype-system</span> attribute
values&nbsp; in Listing 1, and result in the correct output for the
XHTML DTD in Figure 6.<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);"><br>
The first
template rule</span><br>
<span style="color: rgb(0, 0, 0);"><br>
The first template rule <span style="font-style: italic;">(extracted
from Figure 3 and given a different color scheme)</span> is shown in
tree view in Figure 7.&nbsp; This
template rule contains an XPath expression that matches the document
root <span style="font-style: italic;">(note the forward slash).</span></span><br>
<span style="font-style: italic; color: rgb(0, 0, 0);"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:template ELEMENT_NODE<br>        Attribute: match=/<br><span
 style="color: rgb(255, 0, 0);">      html ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        head ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">          meta ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: http-equiv=content-type</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: content=text/html; </span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">                                    charset=UTF-8</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">          title ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">            #text Generated XHTML file</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">        body ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">           table ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: border=2</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: cellspacing=0</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: cellpadding=0</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: width=330</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              Attribute: bgcolor=#FFFF00</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">            tr ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">              td ELEMENT_NODE</span><br
 style="color: rgb(255, 0, 0);">                xsl:apply-templates ELEMENT_NODE</pre>
      <pre><b>Figure 7</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="font-weight: bold; color: rgb(255, 0, 0);"><br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">The template rule in
XSL format</span><br>
<br>
Listing
2 shows the same template rule in
XSL format, <span style="font-style: italic;">(extracted from Listing
25).</span></span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:template match="/"&gt;<br><span
 style="color: rgb(255, 0, 0);">&lt;html&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;head&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;meta http-equiv="content-type" </span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">content="text/html; charset=UTF-8"/&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;title&gt;Generated XHTML file&lt;/title&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;/head&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;body&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;table border="2" cellspacing="0" </span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">    cellpadding="0" width="330" </span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">    bgcolor="#FFFF00" &gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;tr&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;td&gt;</span><br>&lt;xsl:apply-templates/&gt;<br><span
 style="color: rgb(255, 0, 0);">&lt;/td&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;/tr&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;/table&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;/body&gt;</span><br
 style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&lt;/html&gt;</span><br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that according to most of the books that I have read, the following
namespace attribute should be used on the html
tag.&nbsp; However, something about it causes problems with the JAXP
transformer so
I left it off.&nbsp; The resulting XHTML file is still valid according
to the <a href="http://validator.w3.org/file-upload.html">W3C Markup
Validation Service</a> even without the namespace attribute.</span><br
 style="font-style: italic;">
</div>
<div style="margin-left: 40px;"><br style="font-style: italic;">
<span style="font-style: italic;">xmlns="http://www.w3.org/1999/xhtml"</span><br
 style="font-style: italic;">
<span style="font-style: italic;">xml:lang="en" lang="en")</span></div>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
The literal text is shown in red</span><br>
<br>
From my viewpoint as the author of the stylesheet, everything that is
colored red in Listing 2 is simply literal text that I want to pass
through to the output so that it will become part of the raw XHTML text.<br>
<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">The template rule
must be well-formed</span></span><br>
<span style="color: rgb(0, 0, 0);"><br>
However, as you can see from Figure 7, the XML parser considers all of
this material to be well-formed <span style="font-style: italic;">(but
not valid)</span> XML element nodes, attribute nodes, and text
nodes.&nbsp; Were I to make a change to any of the red literal text
that would corrupt the well-formed nature of the XML code in Listing 2,
the
stylesheet could not be used to control an XSLT transformation.&nbsp;
While a stylesheet is not required to be valid, it is required to be
well-formed.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Must be very
careful when including markup in stylesheet</span><br>
<br>
Therefore, you must be very careful when you include literal markup
text in the stylesheet for whatever purpose.&nbsp; Any markup that you
include in the stylesheet must result in the stylesheet being
well-formed.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(This was not a problem with the inclusion
of literal text in the stylesheet in the previous lesson, because the
literal text didn't contain markup characters.&nbsp; As a result, the
literal text was interpreted simply as text nodes in the
stylesheet.&nbsp; As you can see from Figure 7, however, the literal
markup text that was included in this stylesheet was interpreted by the
parser as element nodes, attributes and text nodes.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A very simple
template rule.</span><br>
<br>
At first blush, this template rule appears to be very long and very
complex.&nbsp; However, as you can see from Listing 2, once you isolate
out all of the literal XHTML text that's included in the template rule,
the actual XSLT template rule is very simple.&nbsp; This rule simply
passes a lot of literal markup text through to the output and causes
templates
to be applied to all children of the root <span
 style="font-style: italic;">(document)</span> node.&nbsp; <span
 style="font-style: italic;">(You learned what it means to apply
templates in
the previous lesson.)</span><br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The XHTML tags</span><br>
<br>
If you are familiar with XHTML syntax, you will recognize that the
literal text shown in red in Listing 2 begins with typical XHTML tags
such as &lt;html&gt;, &lt;head&gt;,&nbsp; and &lt;body&gt;.&nbsp; These
tags are required for an XHTML document.&nbsp; This text is sent to the
output before any processing of the DOM tree is performed.<br>
<br>
Then the literal text creates an XHTML table with a yellow
background.&nbsp; The start tags for the table are sent to the output
before the <span style="font-weight: bold;">xsl:apply-templates</span>
element is executed.<br>
<br>
All of the output produced by executing the <span
 style="font-weight: bold;">xsl:apply-templates</span> element is
inserted into a single data &lt;td&gt; cell in the table.<br>
<br>
Finally, when the <span style="font-weight: bold;">xsl:apply-templates</span>
element returns, the end tags for the table and the end tags for the
document are sent to the output.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The raw XHTML
output</span><br>
<br>
Figure 8 shows a condensed version of the raw XHTML output.&nbsp; The
XHTML output shown in red in Figure 8 matches the literal text shown in
red in the template rule of Listing 2.<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
</span></span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td style="background-color: rgb(255, 204, 204);">
      <pre style="background-color: rgb(153, 255, 153);"><span
 style="color: rgb(51, 51, 255);">NOTE THAT IT WAS NECESSARY FOR ME TO MANUALLY</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">INSERT LINE BREAKS IN SEVERAL OF THE LONG LINES</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">IN THIS MATERIAL TO FORCE IT TO FIT INTO THIS</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">NARROW PUBLICATION FORMAT.</span><br><br>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 <br>     Transitional//EN" "http://www.w3.org/TR/<br>     xhtml1/DTD/xhtml1-transitional.dtd"&gt;<br><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;html&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;head&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;meta http-equiv="content-type" </span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">     content="text/html; charset=UTF-8"/&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;title&gt;Generated XHTML file&lt;/title&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;/head&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;body&gt;</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">&lt;table border="2" cellspacing="0" cellpadding="0"</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">      width="330" bgcolor="#FFFF00"&gt;&lt;tr&gt;&lt;td&gt;</span><br><br>...HTML CODE DELETED FOR BREVITY...<br><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/body&gt;&lt;/html&gt;</span><br><br><span
 style="font-weight: bold;">Figure 8</span><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The effect of
xsl:apply-templates</span><br>
<br>
Referring once again to Listing 2, we see that this template rule
causes templates to be applied to all child nodes of
the root or document node.&nbsp; A root node can have only one child
node, which is the root element node.&nbsp; Referring back to Figure 1,
we see that the root element node is named <span
 style="font-weight: bold;">A</span>.<br>
<br>
Now referring back to the tree view of the stylesheet in Figure 3 <span
 style="font-style: italic;">(and also the list of match patterns
presented earlier),</span> we see that the stylesheet doesn't contain a
template rule that matches an element named <span
 style="font-weight: bold;">A</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Important to
understand built-in behavior</span><br>
<br>
If the processor encounters a node for which there is no matching
template rule, it executes a built-in template rule for that
type of node.&nbsp; This is where it becomes important to understand
the behavior of the built-in template rules, which I explained in the
earlier lesson entitled <a
 href="http://www.developer.com/java/other/article.php/3313341">Java
JAXP, Implementing Default XSLT Behavior in Java</a>.<br>
<br>
The behavior of the built-in template rule for element nodes is to
apply templates to all child nodes of the element node.&nbsp;
Therefore, in this case, the processor will apply templates to all
child nodes of the root element node named <span
 style="font-weight: bold;">A</span>.<br>
<br>
Referring back to Figure 1, we see that the root element node has three
child nodes, which occur in the following order:&nbsp; Q, B, and
B.&nbsp;
Therefore, the first node that will be processed is the node named Q.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A template rule
that matches Q</span><br>
<br>
Figure 9 and Listing 3 show a template rule that matches an element
named <span style="font-weight: bold;">Q</span>.<br>
</span><span style="font-style: italic; color: rgb(0, 0, 0);"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:template ELEMENT_NODE<br>        Attribute: match=Q<br>      h1 ELEMENT_NODE<br>        xsl:apply-templates ELEMENT_NODE</pre>
      <pre><b>Figure 9</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
The tree view of the template rule is shown in Figure 9.&nbsp; The XSL
stylesheet code is shown in Listing 3.</span><br>
<span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:template match="Q"&gt;<br>&lt;h1&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/h1&gt;<br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">&nbsp;A level 1
header in the output</span><span style="color: rgb(0, 0, 0);"><br>
<br>
This template rule sends the start and end tags for a level 1 XHTML
header to the output, and inserts something between those tags by
applying templates to all child nodes of the element node named <span
 style="font-weight: bold;">Q</span>.<br>
<br>
Referring back to the element node named <span
 style="font-weight: bold;">Q</span> in Figure 1, we see that it has
only one child node, and that node is a text node.&nbsp; Executing the <span
 style="font-weight: bold;">xsl:apply-templates</span> element on a
text node causes the built in version of the template rule to be
applied.&nbsp; The built-in version gets the value of the text node and
sends it to the output.&nbsp; This produces the raw XHTML output shown
in Figure 10.<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
</span></span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td style="background-color: rgb(255, 204, 204);">
      <pre style="background-color: rgb(153, 255, 153);">&lt;h1&gt;<br>A Big Header<br>&lt;/h1&gt;<br><br><span
 style="font-weight: bold;">Figure 10</span><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
You should be able to easily identify the header from Figure 10 in the
first line of the rendered output in Figure 2.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A template rule
that matches B</span></span><br>
<span style="color: rgb(0, 0, 0);"><br>
That takes care of processing the root element node's child named <span
 style="font-weight: bold;">Q</span>.&nbsp; The next child to be
processed is a child node named <span style="font-weight: bold;">B</span>.<br>
<br>
A template rule that matches an element node named <span
 style="font-weight: bold;">B</span> is shown in Figure 11 and Listing
4.</span><br>
<span style="font-style: italic;"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:template ELEMENT_NODE<br>        Attribute: match=B<br>      xsl:apply-templates ELEMENT_NODE</pre>
      <pre><b>Figure 11</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
As before, the tree view is shown in Figure 11 and the stylesheet code
is shown in Listing 4.</span><span style="color: rgb(0, 0, 0);"><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:template match="B"&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">This template rule is very
simple.&nbsp; It simply causes templates to be applied to all child
nodes of the element node named <span style="font-weight: bold;">B</span>.&nbsp;
Referring back to Figure 1, we see that the first child node named <span
 style="font-weight: bold;">B</span> has several child nodes, which
occur in the following order:&nbsp; C, R, C, S, B, S, B, R, C.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">An abbreviated
DOM tree</span><br>
<br>
Don't worry, I'm not going to discuss them all.&nbsp; In fact, I'm
going to ignore many of those nodes and their descendants, and
concentrate on the abbreviated portion of the DOM tree shown in Figure
12.&nbsp; I am going to concentrate on this portion because it uses
XSLT templates not previously discussed in this lesson or in my earlier
lessons.&nbsp; </span><br>
<span style="font-style: italic;"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>    B ELEMENT_NODE<br>      ...<br>      B ELEMENT_NODE<br>        ...<br>        B ELEMENT_NODE<br>          ...<br>          D ELEMENT_NODE<br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">            E ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">              #text First list item in E</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">              G ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">                #text Nested G text element</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">            F ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(51, 51, 255);"><span
 style="font-weight: bold; color: rgb(51, 51, 255);">              #text First list item in F</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">            E ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">              #text Second list item in E</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">            F ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(51, 51, 255);"><span
 style="font-weight: bold; color: rgb(51, 51, 255);">              #text Second list item in F</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">            E ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">              #text Third list item in E</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">            F ELEMENT_NODE</span><br
 style="font-weight: bold; color: rgb(51, 51, 255);"><span
 style="font-weight: bold; color: rgb(51, 51, 255);">              #text Third list item in F</span></pre>
      <pre><b>Figure 12</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
To help you keep your bearings, the first node named <span
 style="font-weight: bold;">B</span> in Figure 12 is the first node
named <span style="font-weight: bold;">B</span> belonging to the root
element node named <span style="font-weight: bold;">A</span> in Figure
1.&nbsp; That
node named <span style="font-weight: bold;">B</span> will be the
starting point for the following discussion.&nbsp; Nodes have
been manually removed from Figure 12 at each point where you see an
ellipses (...).&nbsp; I will ignore those nodes.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Traversing down
the DOM tree</span><br>
</span><span style="color: rgb(0, 0, 0);"><br>
As you saw in the template rule that matches <span
 style="font-weight: bold;">B</span> in Figure 4, each time the
processor encounters an element node named <span
 style="font-weight: bold;">B</span>, templates are applied to all
child nodes of that node and no other action is required.&nbsp;
Therefore, we can immediately skip down to a discussion of the element
node named <span style="font-weight: bold;">D</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A template rule
that matches D</span><br>
<br>
Figure 13 shows a tree view of the template rule that matches <span
 style="font-weight: bold;">D</span>. <br>
</span><span style="font-style: italic; color: rgb(0, 0, 0);"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:template ELEMENT_NODE<br>        Attribute: match=D<br>      <span
 style="font-weight: bold; color: rgb(255, 0, 0);">#text List of items in E</span><br><br>      <span
 style="font-weight: bold; color: rgb(255, 0, 0);">ul ELEMENT_NODE</span><br>        xsl:for-each ELEMENT_NODE<br>            Attribute: select=E<br>          <span
 style="font-weight: bold; color: rgb(255, 0, 0);">li ELEMENT_NODE</span><br>            xsl:apply-templates ELEMENT_NODE<br>      <span
 style="font-weight: bold; color: rgb(255, 0, 0);">#text List of items in F</span><br>      <span
 style="font-weight: bold; color: rgb(255, 0, 0);">ol ELEMENT_NODE</span><br>        xsl:for-each ELEMENT_NODE<br>            Attribute: select=F<br>          <span
 style="font-weight: bold; color: rgb(255, 0, 0);">li ELEMENT_NODE</span><br>            xsl:apply-templates ELEMENT_NODE</pre>
      <pre><b>Figure 13</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
The stylesheet code for the template rule that matches <span
 style="font-weight: bold;">D</span> is shown in Listing 5.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:template match="D"&gt;<span
 style="font-weight: bold; color: rgb(255, 0, 0);">List of items in E</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ul&gt;</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;!-- loop --&gt;</span><br>&lt;xsl:for-each select="E"&gt;<br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br>&lt;xsl:apply-templates /&gt; <br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br>&lt;/xsl:for-each&gt;<br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;!-- End loop --&gt;</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ul&gt;List of items in F</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ol&gt;</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;!-- loop --&gt;</span><br>&lt;xsl:for-each select="F"&gt;<br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br>&lt;xsl:apply-templates /&gt; <br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br>&lt;/xsl:for-each&gt;<br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;!-- End loop --&gt;</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ol&gt;</span><br><br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">In an attempt to separate the text
and markup that controls the transformation process from the text and
markup destined to become part of the XHTML document, I colored the
latter red in Figure 13 and Listing 5.&nbsp; I also colored the XML
comments blue in Listing 5 to make them easy to ignore.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A simpler
version</span><br>
<br>
In an attempt to make it even easier to understand the behavior of this
template rule, I have reproduced it in Listing 6 with all literal text
and all comments removed.&nbsp; I also added indentation to help with
the visual aspect of the XSL code.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>NOTE:  LITERAL TEXT AND COMMENTS WERE MANUALLY<br>REMOVED FROM THIS TEMPLATE RULE FOR DISCUSSION<br>PURPOSES.<br><br>&lt;xsl:template match="D"&gt;<br>  &lt;xsl:for-each select="E"&gt;<br>    &lt;xsl:apply-templates /&gt; <br>  &lt;/xsl:for-each&gt;<br><br>  &lt;xsl:for-each select="F"&gt;<br>    &lt;xsl:apply-templates /&gt; <br>  &lt;/xsl:for-each&gt;<br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">First consider the behavior of the
top half of the template rule in Listing 6.&nbsp; This rule is invoked
whenever the processor encounters an element node named <span
 style="font-weight: bold;">D</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">&lt;xsl:for-each
select="E"&gt;</span><br>
<br>
The processor identifies all child nodes of <span
 style="font-weight: bold;">D</span> whose name is <span
 style="font-weight: bold;">E</span> and processes them in the order in
which they occur.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(It is also possible to process the child
nodes in sorted order using a more complex implementation, but that
isn't being done here.&nbsp; That will be the topic for a future
lesson.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">&lt;xsl:apply-templates&gt;</span><br>
<br>
The processing that is applied to each child node named <span
 style="font-weight: bold;">E</span> depends on the elements that
follow the <span style="font-weight: bold;">xsl:for-each</span>
element in the template rule.&nbsp; In this case, the processor is
instructed to apply templates to all child nodes of each node named <span
 style="font-weight: bold;">E</span>.<br>
<br>
Referring back to Figure 12, you will see that the node named <span
 style="font-weight: bold;">D</span> has three child nodes named <span
 style="font-weight: bold;">E</span> and three child nodes named <span
 style="font-weight: bold;">F</span>.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(I colored the child nodes named <span
 style="font-weight: bold;">E</span> and <span
 style="font-weight: bold;">F</span>, and their descendants, in
alternating colors of red and blue to make them easier to identify
visually.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
One of the child nodes named <span style="font-weight: bold;">E</span>
has a child node named <span style="font-weight: bold;">G</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">No matching
template rules for E or F</span><br>
<br>
Referring back to the tree view of the stylesheet in Figure 3, you can
see that there are no matching template rules for nodes named <span
 style="font-weight: bold;">E</span> or <span
 style="font-weight: bold;">F</span>.&nbsp; However, there is a
matching template rule for nodes named <span style="font-weight: bold;">G</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Apply built-in
template rule to node E</span><br>
<br>
When the processor encounters the first node named <span
 style="font-weight: bold;">E</span>, it will apply the built-in
template rule for element nodes.&nbsp; That will cause it to apply
templates to all child nodes of the node named <span
 style="font-weight: bold;">E</span>.&nbsp; The first child node that
it will encounter will be a text node containing the following text:<br>
</span>
<pre style="font-weight: bold;"><span style="color: rgb(0, 0, 0);">First list item in E</span></pre>
<span style="color: rgb(0, 0, 0);">This text will be sent to the
output.<br>
<br>
Then it will encounter the node named <span style="font-weight: bold;">G</span>
and apply the matching template rule to that node.&nbsp; The tree view
of that template rule is shown in Figure 14.</span><br>
<span style="font-style: italic; color: rgb(0, 0, 0);"><br>
</span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre style="color: rgb(0, 0, 0);">    xsl:template ELEMENT_NODE<br>        Attribute: match=G<br>      <span
 style="font-weight: bold; color: rgb(255, 0, 0);">b ELEMENT_NODE</span><br>         xsl:apply-templates ELEMENT_NODE</pre>
      <pre><b>Figure 14</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
The stylesheet code for the template rule that matches <span
 style="font-weight: bold;">G</span> is shown in Listing 7.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;xsl:template match="G"&gt;<br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;b&gt;</span><br>&lt;xsl:apply-templates /&gt;<br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;/b&gt;</span> <br>&lt;/xsl:template&gt;<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">This template rule applies templates
to all child nodes of <span style="font-weight: bold;">G</span>, and
surrounds the output produced by that operation with the XHTML start
and end tags to cause that material to be displayed as bold.<br>
<br>
Referring back to Figure 12, we see that the node named <span
 style="font-weight: bold;">G</span> has only one child node.&nbsp; It
is a text node containing the following text:<br>
</span>
<pre><span style="color: rgb(0, 0, 0);"><span style="font-weight: bold;">Nested G text element</span></span></pre>
<span style="color: rgb(0, 0, 0);">That text will be sent to the output
next, surrounded by XHTML bold tags, <span style="font-weight: bold;">&lt;b&gt;...&lt;/b&gt;</span>.<br>
<br>
That completes the processing of the first child of <span
 style="font-weight: bold;">D</span> named <span
 style="font-weight: bold;">E</span>.<br>
<br>
Note in Figure 12 that the next child node of <span
 style="font-weight: bold;">D</span> is a node named <span
 style="font-weight: bold;">F</span>.&nbsp; However, we are discussing
the behavior of that portion of the template rule shown in Figure 6
that is using the <span style="font-weight: bold;">xsl:for-each</span>
element to iterate on nodes named <span style="font-weight: bold;">E</span>.&nbsp;
Therefore, the processor will skip over the node named <span
 style="font-weight: bold;">F</span> and process the next node named <span
 style="font-weight: bold;">E</span>.<br>
<br>
This is a simple node that has only one child node and it is a text
node containing the following text:<br>
</span>
<pre><span style="color: rgb(0, 0, 0);"><span style="font-weight: bold;">Second list item in E</span></span></pre>
<span style="color: rgb(0, 0, 0);">This text will be the next thing to
be sent to the output.<br>
<br>
The node named D has one more child node named E, and it has a single
child node, which is a text node.&nbsp; The text node contains the
following text:<br>
</span>
<pre style="font-weight: bold;"><span style="color: rgb(0, 0, 0);">Third list item in E</span></pre>
<span style="color: rgb(0, 0, 0);">When that text is sent to the
output, the execution of the top half of the template rule shown in
Figure 6 will be complete.&nbsp; Then the processor will execute the
bottom half of the template rule in Figure 6.&nbsp; The bottom half is
identical to the top half except that it iterates on child nodes named <span
 style="font-weight: bold;">F</span>, so I won't discuss it in detail.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Let's look at
the XHTML output</span><br>
<br>
Before moving along, let's take a look at the raw XHTML produced by the
template rule shown in Listing 5.&nbsp; That XHTML output is shown in
Listing 15.<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
</span></span>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td style="background-color: rgb(255, 204, 204);">
      <pre style="background-color: rgb(153, 255, 153);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">List of items in E</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ul&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br><span
 style="font-weight: bold;">First list item in E</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;b&gt;</span><br><span
 style="font-weight: bold;">Nested G text element</span><br><span
 style="font-weight: bold; color: rgb(51, 51, 255);">&lt;/b&gt;</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br><span
 style="font-weight: bold;">Second list item in E</span><br><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(0, 0, 0);">Third list item in E</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ul&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">List of items in F</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ol&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(0, 0, 0);">First list item in F</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(0, 0, 0);">Second list item in F</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(0, 0, 0);">Third list item in F</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span><br
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ol&gt;</span><br><br><span
 style="font-weight: bold;">Figure 15</span><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Black text
originates in XML document</span><br>
<br>
The black text in Listing 15 originated in the XML file shown in Figure
12.&nbsp; You should be able to match the seven lines of black text in
Figure 15 to the corresponding text in Figure 12.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Red and blue
text originates in stylesheet</span><br>
<br>
The red text in Listing 15 originated in the stylesheet template rule
shown in Listing 5.&nbsp; This literal text is also shown in red in
Listing 5.<br>
<br>
The blue text in Listing 15 originated in the template rule shown in
Listing 7.&nbsp; This text is also shown in blue in Listing 7.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">How does it
render?</span><br>
<br>
If you go back and examine Figure 2, which shows the XHTML as rendered
by the Netscape Navigator browser, you should be able to identify the
output in Figure 2 produced by the raw XHTML text in Figure 15.&nbsp; <span
 style="font-style: italic;">(It occurs between the lines that read <span
 style="font-weight: bold;">Text block 5</span> and <span
 style="font-weight: bold;">Text block 6</span>.)</span><br>
<br>
As you can see, the template rule shown in Figure 5 used an <span
 style="font-weight: bold;">xsl:for-each</span> element <br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">To iterate on child nodes
named <span style="font-weight: bold;">E</span>,</span></li>
  <li><span style="color: rgb(0, 0, 0);">To extract the text values of
those nodes and their descendants, and</span></li>
  <li><span style="color: rgb(0, 0, 0);">To embed those values in XHTML
elements to cause the values to be rendered as an <span
 style="font-style: italic;">unordered </span>list.</span></li>
</ul>
<span style="color: rgb(0, 0, 0);">The value of a child node of one of
the <span style="font-weight: bold;">E</span> nodes was also caused to
be rendered in bold.<br>
<br>
Then the template rule used an <span style="font-weight: bold;">xsl:for-each</span>
element <br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">To iterate on child nodes
named <span style="font-weight: bold;">F</span>,</span></li>
  <li><span style="color: rgb(0, 0, 0);">To extract text values from
those nodes, and</span></li>
  <li><span style="color: rgb(0, 0, 0);">To embed those values in XHTML
elements to cause the values to be rendered an <span
 style="font-style: italic;">ordered </span>list.</span></li>
</ul>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">New XSLT material
has been covered</span><br>
<br>
I could go on for hours discussing the interaction of this stylesheet
with
the XML file in the transformation process.&nbsp; However, a review of
the tree view of the
stylesheet in Figure 3 reveals that the behavior of the remaining
template rules has either been covered in this lesson or in a previous
lesson.&nbsp; Therefore, I will terminate this discussion of the XSLT
transformation at this point and discuss a Java program that mimics the
behavior of this XSLT transformation.</span><br>
<h3 style="text-align: center;"><span style="color: rgb(0, 0, 0);"><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><a
 name="The_Java_Code_Transformation"></a>The
Java Code Transformation</span></span></span></h3>
<span style="color: rgb(0, 0, 0);">At this point, I will change
direction and
concentrate on Java code instead of XSLT elements.&nbsp; The
following paragraphs describe a Java program named <span
 style="font-weight: bold;">Dom03</span>, which emulates the XSLT
transformation described above.&nbsp; This program transforms an XML
file into an XHTML file using a combination of recursive and iterative
processing.&nbsp; Along the way, it creates and populates an XHTML
table.<br>
<br>
This program defines a new method named <span
 style="font-weight: bold;">forEach</span> that mimics the behavior of
the <span style="font-weight: bold;">xsl:for-each</span> element
described above.&nbsp; In addition, this program adds code to the <span
 style="font-weight: bold;">processDocumentNode</span> and <span
 style="font-weight: bold;">processNode
</span>methods to emulate the template rules in the XSL file named <span
 style="font-weight: bold;">Dom03.xsl</span>.<br>
<br>
Also, as was the case in the previous lessons, this program implements
six built-in template rules
for an XML processor.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Instructions
for creating a custom template rule</span><br>
<br>
To create a custom template rule for this program: <br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">Go to the <span
 style="font-weight: bold;">processNode </span>method.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Identify the node type.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Change the conditional clause
in the <span style="font-weight: bold;">if </span>statement to
implement the required match.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Write code in the body of the <span
 style="font-weight: bold;">if </span>statement to implement the
custom rule.</span></li>
</ul>
<span style="color: rgb(0, 0, 0);">If the modified conditional clause
evaluates to true, the custom rule will be executed.&nbsp; If </span><span
 style="color: rgb(0, 0, 0);">the modified conditional clause evaluates
to </span><span style="color: rgb(0, 0, 0);">false, the default rule
will be executed.&nbsp; You will see examples of several custom
template rules
in this program.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Behavior of the
program</span><br>
<br>
This program compares the transformation of a specified XML file into a
result file, using two different approaches:<br>
</span>
<ol>
  <li><span style="color: rgb(0, 0, 0);">An XSLT style sheet and
transformation, as discussed above.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Program code that emulates the
behavior of the XSLT transformation.</span></li>
</ol>
<span style="color: rgb(0, 0, 0);">In particular, this program
illustrates Java code that emulates the XSLT templates in the file
named <span style="font-weight: bold;">Dom03.xsl</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Both output
files are valid</span><br>
<br>
The program produces two output files, one from the XSLT
transformation,
and one from executing the Java code.&nbsp; Both files validate as
XHTML transitional at the W3C validation service, </span><br>
<a href="http://validator.w3.org/file-upload.html">http://validator.w3.org/file-upload.html</a>.<br>
<br>
Both also validate as HTML files at <br>
<a href="http://www.htmlhelp.com/tools/validator/upload.html">http://www.htmlhelp.com/tools/validator/upload.html</a>.<br>
<br>
Finally, both files validate using the program named <span
 style="font-weight: bold;">DomTree02</span>, which means that they
validate as XML under JAXP.<br>
<span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Usage
instructions</span><br>
<br>
The program requires three command line arguments in the following
order:<br>
</span>
<ol>
  <li><span style="color: rgb(0, 0, 0);">The name of the input XML file
- must be <span style="font-weight: bold;">Dom03.xml</span>.</span></li>
  <li><span style="color: rgb(0, 0, 0);">The name of the output file to
be produced by the XSLT transformation.</span></li>
  <li><span style="color: rgb(0, 0, 0);">The name of the output file to
be produced by the program code that emulates the XSLT transformation.</span></li>
</ol>
<span style="color: rgb(0, 0, 0);">The name of the XSL stylesheet file
is extracted from the processing instruction in the XML file, but you
could easily modify the program to obtain the name of that file from a
command-line argument.<br>
<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">Order of execution</span></span><span
 style="color: rgb(0, 0, 0);"><br>
<br>
The program begins by executing code to transform the incoming XML file
in a way that mimics the XSLT Transformation.&nbsp; Along the way, it
saves the processing instructions containing the ID of the stylesheet
file for use by the XSLT transformation process later.&nbsp; Otherwise,
the code that
performs the XSLT transformation would have to search the DOM
tree for the XSL stylesheet file.<br>
<br>
Then the program uses the XSLT style sheet to transform the XML file
into a result file by performing an XSLT transformation under program
control.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Errors,
exceptions, and testing</span><br>
<br>
No effort was made to provide meaningful information about errors and
exceptions.<br>
<br>
The program was tested using SDK 1.4.2 under WinXP. <br>
<br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">Will discuss in
fragments</span></span><br>
<span style="color: rgb(0, 0, 0);"><br>
I will discuss this program in fragments.&nbsp; A complete listing of
the program is shown in Listing 23 near the end of the lesson.<br>
<br>
Much of the code in this program is very similar to, or identical to
code that I discussed in previous lessons.&nbsp; I will discuss that
repetitious code only briefly, if at all.<br>
</span><span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The main method</span><br>
<br>
</span><span style="color: rgb(0, 0, 0);">Listing 8 shows an
abbreviated version of the beginning of the class named <span
 style="font-weight: bold;">Dom03</span> and the ending of the <span
 style="font-weight: bold;">main</span> method.</span><span
 style="color: rgb(0, 0, 0);"><br>
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class Dom03{<br>    //Code deleted for brevity<br><br>      //In main method<br>      //Process the DOM tree<br>      thisObj.<span
 style="font-weight: bold;">processDocumentNode</span>(document);<br><br>      //Perform XSLT transformation<br>      thisObj.<span
 style="font-weight: bold;">doXslTransform</span>(<br>                     document,argv[1],procInstr);<br><br>    //Exception handling code deleted for brevity<br>  }// end main()<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">The code in this portion of the
program is identical to code that I discussed in detail in previous
lessons, so I won't discuss it further.&nbsp; I included it here
solely to establish the context for discussion of code that is to
follow.&nbsp; <br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Behavior of
this code</span><br>
<br>
Briefly, the code in the <span style="font-weight: bold;">main</span>
method does the following:<br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">Performs all the steps
necessary to parse the input XML file, producing an object of type <span
 style="font-weight: bold;">Document</span> whose reference is saved in
a reference variable named <span style="font-weight: bold;">document</span>.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Instantiates an object of the <span
 style="font-weight: bold;">Dom03</span> class and saves its
reference in a reference variable named <span
 style="font-weight: bold;">thisObj</span>.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Invokes the method named <span
 style="font-weight: bold;">processDocumentNode</span> on <span
 style="font-weight: bold;">thisObj</span> to transform the
DOM tree to an output file using program code to perform the
transformation.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Invokes the method named <span
 style="font-weight: bold;">doXslTransform</span> on <span
 style="font-weight: bold;">thisObj</span> to perform an XSLT
transformation using an XSL stylesheet. <br>
    </span></li>
</ul>
<span style="color: rgb(0, 0, 0);">The methods named <span
 style="font-weight: bold;">processDocumentNode</span> and <span
 style="font-weight: bold;">doXslTransform</span> are methods of my own
design.</span><br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
processDocumentNode method</span><br>
<br>
The beginning of the <span style="font-weight: bold;">processDocumentNode</span>
method is shown in Listing 9.&nbsp; This version of the method is much
longer than versions discussed in previous lessons.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void processDocumentNode(Node node){<br>    //Create the beginning of the XHTML document<br>    out.println("&lt;?xml version=\"1.0\" "<br>                       + "encoding=\"UTF-8\"?&gt;");<br>    out.println(<br>          "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD "<br>             + "XHTML 1.0 Transitional//EN\" "<br>             + "\"http://www.w3.org/TR/xhtml1/"<br>             + "DTD/xhtml1-transitional.dtd\"&gt;");<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
However, even though this version is much longer, there is nothing in
the method that should be a stretch for capable Java programmers.&nbsp;
All of the new code in this method is in the form of print statements
to cause appropriate XHTML text to appear in the output.<br>
<br>
<font color="#ff0000"><b>Produces all required output text</b></font><br>
<br>
This method is used to produce any text required in the output at
the document level, such as the XML declaration for an XML
document, or the DTD reference for an XHTML document.&nbsp; As you can
see from Listing 9, the code in this method does both.<br>
<br>
The code in Listing 9 writes an XML declaration, and then writes XHTML
text into the output that matches text produced by the green <span
 style="font-weight: bold;">xsl:output</span> element in Figure
3.&nbsp; I have already discussed the need for the XHTML DTD in the
XHTML file, so I won't discuss it further here.<br>
<br>
<font color="#ff0000"><b>The start tag for the html root element</b></font><br>
<br>
The code in Listing 10 writes the start tag for the <span
 style="font-weight: bold;">html</span> root element of the XHTML
document.&nbsp; Then it writes the XML namespace attribute in the
output.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(The
stylesheet shown in Figure 3 doesn't write an XML namespace attribute
for reasons that I explained earlier.)</span><br>
</div>
<span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    out.println("&lt;html xmlns=\"http://www.w3."<br>             + "org/1999/xhtml\" xml:lang=\"en\""<br>             + " lang=\"en\"&gt;");<br>    out.println("&lt;head&gt;");<br>    out.println(<br>            "&lt;meta http-equiv=\"content-type\" "<br>               + "content=\"text/html; charset="<br>                            + "UTF-8\"/&gt;");<br>    out.println("&lt;title&gt;Generated XHTML file"<br>                                   + "&lt;/title&gt;");<br>    out.println("&lt;/head&gt;");<br>    out.println("&lt;body&gt;");<br>    //Output similar to the above applies to<br>    // most XHTML documents.<br><br>    //Now set up an XHTML table.  This is<br>    // peculiar to this particular example.<br>    out.println("&lt;table border=\"2\" " +<br>                         "cellspacing=\"0\" " +<br>                         "cellpadding=\"0\" " +<br>                         "width=\"330\" " +<br>                         "bgcolor=\"#FFFF00\"&gt;" +<br>                         "&lt;tr&gt;&lt;td&gt;");<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">Following this, the code in Listing
10 writes the same XHTML text in the output that is written by the
first red template rule in Figure 3.<br>
<br>
<font color="#ff0000"><b>Invoke the processNode method</b></font><br>
<br>
Then the code in Listing 11 invokes the <span
 style="font-weight: bold;">processNode</span> method to trigger a
recursive process that processes the entire DOM tree.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    <span style="font-weight: bold;">processNode(node);</span><br><br>    //Finish the XHTML table.  This output is<br>    // peculiar to this particular example.<br>    out.println("&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;");<br><br>    //Now finish the output document and flush<br>    // the output buffer.  This would apply to<br>    // most XHTML documents.<br>    out.println("&lt;/body&gt;&lt;/html&gt;");<br>    out.flush();<br>  }//end processDocumentNode<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">When the <span
 style="font-weight: bold;">processNode</span> method returns, the code
in Listing 11 writes XHTML text into the output consisting of end tags
for the table, the body, and the document.&nbsp; That completes the
production of the XHTML document, so the code in Listing 11 flushes the
output buffer to assure that everything is written into the file.<br>
<br>
<font color="#ff0000"><b>Invoke the doXslTransform method</b></font></span><br>
<span style="color: rgb(0, 0, 0);"><br>
Then the <span style="font-weight: bold;">processDocumentNode</span>
method terminates and returns control to the <span
 style="font-weight: bold;">main</span> method in Listing 8.&nbsp; At
that point, the <span style="font-weight: bold;">doXslTransform</span>
method is invoked to perform an XSLT transformation on the XML file
using the stylesheet discussed earlier in this lesson.<br>
<br>
Quite a lot of code was added to the </span><span
 style="color: rgb(0, 0, 0);"><span style="font-weight: bold;">processDocumentNode
</span></span><span style="color: rgb(0, 0, 0);">method, but as
mentioned earlier, all of that code was added simply to write XHTML
text into the output at the document level.&nbsp; All of the changes to
the program that were significant from a programming viewpoint were
either included in the <span style="font-weight: bold;">processNode </span>method,
or were part of a new method named <span style="font-weight: bold;">forEach</span>.</span><br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Invoke the
processNode method</span><br>
<br>
Despite the name that I chose to give to the <span
 style="font-weight: bold;">processDocumentNode</span> method, it
doesn't actually process the document node directly.&nbsp; Rather after
sending any required text to the output, it invokes the
method named <span style="font-weight: bold;">processNode</span> <span
 style="font-style: italic;">(see Listing 11)</span> to
actually process the document node.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that the <span style="font-weight: bold;">Document</span> object's
reference is passed to the method named <span
 style="font-weight: bold;">processNode</span> in Listing 11.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The processNode
method</span><br>
<br>
As you have learned in previous lessons, there are seven possible types
of nodes in an XML document:<br>
<ol>
  <li>root or document node</li>
  <li>element node</li>
  <li>attribute node</li>
  <li>text node</li>
  <li>comment node</li>
  <li>processing instruction node</li>
  <li>namespace node<br>
  </li>
</ol>
The <span style="font-weight: bold;">processNode</span> method handles
the first six types and ignores namespace nodes.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Apparently
it is not possible to handle namespace nodes in a Java program because
there is no constant in the </span><span
 style="font-weight: bold; font-style: italic;">Node </span><span
 style="font-style: italic;">class that can be used to identify
namespace nodes.&nbsp; This will become clear as we examine the
code in the <span style="font-weight: bold;">processNode</span>
method.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Get and save
the node type</span><br>
<br>
The <span style="font-weight: bold;">processNode</span> method in this
program contains quite a few changes relative to the programs that I
discussed in previous lessons.&nbsp; Therefore, I will discuss the <span
 style="font-weight: bold;">processNode</span> method in detail.<br>
<br>
Code that you write in this method <span style="font-style: italic;">(and
in the <span style="font-weight: bold;">processDocumentNode</span>
method discussed above) </span>is somewhat analogous to writing an XSL
stylesheet to be used in an XSLT transformation. <br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Test for a
valid node, and get its type</span><br style="font-style: italic;">
<br>
The beginning of the <span style="font-weight: bold;">processNode</span>
method is shown in Listing 12.&nbsp; The method receives an
incoming parameter of type <span style="font-weight: bold;">Node</span>,
which can represent any of the seven types of nodes in the above list.<br>
<br>
As you can see in Listing 12, if the parameter doesn't point to an
actual object, the method quietly
returns, as opposed to throwing a <span style="font-weight: bold;">NullPointerException</span>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void processNode(Node node){<br><br>    try{<br>      if (node == null){<br>        System.err.println(<br>                  "Nothing to do, node is null");<br>        return;<br>      }//end if<br><br>      //Get the actual type of the node<br>      int type = node.<span
 style="font-weight: bold;">getNodeType</span>();<span
 style="font-weight: bold;"><br></span><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The final statement in Listing 12 invokes the <span
 style="font-weight: bold;">getNodeType</span> method to get and save
the type of the node whose reference was received as an incoming
parameter.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Process the node</span><br>
<br>
Each time the <span style="font-weight: bold;">processNode</span>
method is invoked, it receives a <span style="font-weight: bold;">Node</span>
object's reference as an incoming parameter.&nbsp; The code in Listing
12 determines the type of the incoming node.&nbsp; Listing 13 shows the
beginning of a <span style="font-weight: bold;">switch</span>
statement that is used to initiate the processing of each incoming node
based on its type.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      <span style="font-weight: bold;">switch </span>(type){<br>        case <span
 style="font-weight: bold;">Node.DOCUMENT_NODE:</span>{<br>          if(false){<br>            //unreachable in this program<br>          }else{//invoke default behavior<br>            defElOrRtNodeTemp(node);<br>          }//end else<br>          break;<br>        }//end case DOCUMENT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The <span style="font-weight: bold;">switch</span> statement has six
cases to handle six types of nodes, plus a default case to ignore
namespace nodes.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
DOCUMENT_NODE case</span><br>
<br>
The code in Listing 13 will be executed whenever the incoming method
parameter points to a document node.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that this will happen only once during the processing of a DOM
tree.&nbsp; The first node processed will always be the document node,
and there is only one document node in a DOM tree.)</span><br>
</div>
<br>
This code is identical to code that I have discussed in previous
lessons, so I won't discuss it further.&nbsp; I included it here solely
to help you get oriented as to the overall control structure of the <span
 style="font-weight: bold;">processNode</span> method.<br>
<br>
I do want to point out, however, that when the <span
 style="font-weight: bold;">processNode </span>method is invoked on a
document node, the code in Listing 13 causes a method named <span
 style="font-weight: bold;">defElOrRtNodeTemp </span>to be
invoked.&nbsp; This method emulates the behavior of a built-in template
rule, which in this case causes templates to be applied to all child
nodes of the document node.<br>
<span style="font-weight: bold;"><br>
</span><span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">Creating custom
template rules</span><br>
<br>
Although this lesson does not create a custom template rule for
document nodes, the process for creating a
custom template rule is as follows:<br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">Go to this method named <span
 style="font-weight: bold;">processNode</span>.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Identify the case for the node
type in the <span style="font-weight: bold;">switch</span> statement.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Change the conditional clause
in the <span style="font-weight: bold;">if</span> statement for that
case to
implement a match for a particular node of that type.</span></li>
  <li><span style="color: rgb(0, 0, 0);">Write code in the body of the <span
 style="font-weight: bold;">if</span> statement to implement the custom
template rule.</span></li>
</ul>
<span style="color: rgb(0, 0, 0);">If the modified conditional clause
evaluates to true, the custom template rule will be executed.&nbsp; If
it evaluates to false, the
default rule will be executed.<br>
</span><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
ELEMENT_NODE case</span><br>
<br>
Most of the changes to this program <span style="font-style: italic;">(as
compared to programs discussed in previous lessons)</span> consist of
changes to the code that
processes element nodes in the <span style="font-weight: bold;">switch</span>
statement.&nbsp; The code for element node case is rather long, so I
will
discuss it in fragments.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(A
new method named <span style="font-weight: bold;">forEach</span> was
also added to the program.&nbsp; I will discuss that method in detail
later.)</span><br>
</div>
<span style="font-weight: bold; color: rgb(255, 0, 0);"><br>
A match for
element nodes named B</span><br>
<br>
The beginning of the case for element nodes is shown in Listing 14.<span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        case Node.ELEMENT_NODE:{<br><br>          if(node.getNodeName() == "B"){<br>            applyTemplates(node,null);<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">Note the similarity of the code in
Listing 14 and the XSLT template rule shown in Listing 4.&nbsp; When
the node being is processed is an element node whose name is <span
 style="font-weight: bold;">B</span>, the code in Listing 14 invokes
the <span style="font-weight: bold;">applyTemplates</span> method to
cause templates to be applied to all child nodes of the node named <span
 style="font-weight: bold;">B</span>.<br>
<br>
I discussed the <span style="font-weight: bold;">applyTemplates</span>
method in earlier lessons, and won't repeat that discussion here.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A match for
element nodes named C</span><br>
<br>
</span><span style="color: rgb(0, 0, 0);">Listing 15 shows code that
matches element nodes named <span style="font-weight: bold;">C</span>.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else if(node.getNodeName() == "C"){<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;p&gt;</span>");<br>            applyTemplates(node,null);<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/p&gt;</span>");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">This code applies templates to all
child nodes of the node named <span style="font-weight: bold;">C</span>,
and wraps the output produced by that operation in an XHTML paragraph
element, <span style="font-weight: bold;">&lt;p&gt;...&lt;/p&gt;</span>.<br>
<br>
Compare the code in Listing 15 with the second red XSLT template rule
in Figure 3.<br>
</span><span style="color: rgb(0, 0, 0);"><br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A match for
element nodes named D</span><br>
<br>
Listing 16 shows code that matches element nodes named <span
 style="font-weight: bold;">D</span>.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else if(node.getNodeName() == "D"){<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">List of items in E</span>");<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ul&gt;</span>");<br>            <span
 style="font-weight: bold;">forEach</span>(node,"E");<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ul&gt;</span>");<br><br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">List of items in F</span>");<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;ol&gt;</span>");<br>            <span
 style="font-weight: bold;">forEach</span>(node,"F");<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/ol&gt;</span>");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">I'll start my discussion of the code
in Listing 16 by comparing it with the template rule shown in Listing
5.&nbsp; The behavior of this code is the same as the behavior of the
template rule in Listing 5.&nbsp; However, the execution structure is
slightly different.<br>
<br>
The code in Listing 16 begins by sending some text followed by the
start tag for an unordered list to the output.&nbsp; Then it invokes
the <span style="font-weight: bold;">forEach</span> method, passing
the context node and the name of the child node named <span
 style="font-weight: bold;">E</span> as parameters.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The forEach
method</span><br>
<br>
The entire <span style="font-weight: bold;">forEach</span> method is
shown in Listing 17.</span><span style="color: rgb(0, 0, 0);">&nbsp;
This method, in conjunction with the <span style="font-weight: bold;">processNode</span>
method, emulates the behavior of an <span style="font-weight: bold;">xsl:for-each</span>
XSLT element.</span><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private void forEach(Node node,String select){<br>    NodeList children = node.getChildNodes();<br>    if (children != null){<br>      int len = children.getLength();<br>      //Iterate on NodeList of child nodes,<br>      // processing nodes that match the select.<br><br>      for (int i = 0; i &lt; len; i++){<br>        if(children.item(i).getNodeName().<br>                                 equals(select)){<br>          //Make a recursive call from within<br>          // this iterative template rule.<br>          <span
 style="font-weight: bold;">processNode</span>(children.item(i));<br>        }//end if<br>      }//end for loop<br>    }//end if<br>  }//end forEach<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">If you have been studying the
previous lessons in this series, the structure of the method should be
familiar to you.<br>
<br>
<font color="#ff0000"><b>The structure of the forEach method</b></font><br>
<br>
The method receives two parameters:<br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">A reference to a particular
node of type <span style="font-weight: bold;">Node</span>.</span></li>
  <li><span style="color: rgb(0, 0, 0);">The name of a node that should
be a child node of the node.</span></li>
</ul>
<span style="color: rgb(0, 0, 0);">The purpose of the method is to
access each child node that matches the name, in the order in which
they appear in the DOM tree, and to apply a particular operation to
each of those nodes.<br>
<br>
</span>
<div style="margin-left: 40px;"><span style="color: rgb(0, 0, 0);"><span
 style="font-style: italic;">(A future lesson will show you how to
access the nodes in sorted order.)</span></span><br>
</div>
<span style="color: rgb(0, 0, 0);"><br>
<font color="#ff0000"><b>Get and iterate on a list of child nodes</b></font><br>
<br>
The code in Listing 17 starts by getting a list of all the child nodes
of the node referenced by the first incoming parameter.<br>
<br>
Then it iterates on the list, identifying those nodes whose names match
the second incoming parameter.&nbsp; When it finds a match, it makes a
recursive call to the <span style="font-weight: bold;">processNode</span>
method where the operation to be applied to that node is defined.<br>
<br>
When it has processed all the nodes in the list, it returns void to the
code shown in Listing 16.<br>
<br>
<font color="#ff0000"><b>Process all child nodes named E</b></font><br>
<br>
The first time this method is called in Listing 16, it is instructed to
identify and perform an operation on all the child nodes named <span
 style="font-weight: bold;">E</span>.&nbsp; When the <span
 style="font-weight: bold;">forEach</span> method calls the <span
 style="font-weight: bold;">processNode</span> method, passing an <span
 style="font-weight: bold;">E</span> node's reference as a parameter,
the code shown in Listing 18 is executed.&nbsp; <span
 style="font-style: italic;">(Note that this is part of the element
node case in the <span style="font-weight: bold;">switch</span>
statement belonging to the <span style="font-weight: bold;">processNode</span>
method.)</span></span><span style="color: rgb(0, 0, 0);"><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else if(node.getNodeName() == "E"){<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span>");<br>            applyTemplates(node,null);<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span>");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">Note that I could have put the code
in Listing 18 inside the <span style="font-weight: bold;">forEach</span>
method.&nbsp; However, I elected to do it the way that I did to make
the <span style="font-weight: bold;">forEach</span> method more
general, and confine all the code for custom template rules to the <span
 style="font-weight: bold;">processDocumentNode</span> and <span
 style="font-weight: bold;">processNode</span> methods.<br>
<br>
As you can see, the code in Listing 18 causes templates to be applied
to all child nodes of the node named <span style="font-weight: bold;">E</span>,
and causes the output produced by that operation to be surrounded by
the start and end tags for an XHTML list item, <span
 style="font-weight: bold;">&lt;li&gt;...&lt;li&gt;</span>.<br>
<br>
<font color="#ff0000"><b>Finished with nodes named E</b></font><br>
<br>
That completes the operation necessary to emulate the template rule in
Listing 5 for nodes named <span style="font-weight: bold;">E</span>,
and completes the top half of the code being executed in Listing 16.<br>
<br>
<font color="#ff0000"><b>Process all child nodes named F</b></font><br>
<br>
The bottom half of the code in Listing 16 does essentially the same
thing, except that it iterates on child nodes named <span
 style="font-weight: bold;">F</span> and wraps the results in the XHTML
tags for an ordered list, <span style="font-weight: bold;">&lt;ol&gt;..&lt;/ol&gt;</span>.<br>
<br>
In this case, the <span style="font-weight: bold;">forEach</span>
method will isolate nodes named <span style="font-weight: bold;">F</span>
and pass them recursively to the <span style="font-weight: bold;">processNode</span>
method.&nbsp; <br>
<br>
At that point, the code in Listing 19 will be executed with exactly the
same behavior as the code in Listing 18, except that it is applied to
nodes named <span style="font-weight: bold;">F</span> instead of nodes
named <span style="font-weight: bold;">E</span>.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else if(node.getNodeName() == "F"){<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;li&gt;</span>");<br>            applyTemplates(node,null);<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/li&gt;</span>");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);">A match for element
nodes named G</span><br>
<br>
Listing 20 shows custom code that applies to nodes named <span
 style="font-weight: bold;">G</span>.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else if(node.getNodeName() == "G"){<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;b&gt;</span>");<br>            applyTemplates(node,null);<br>            out.println("<span
 style="font-weight: bold; color: rgb(255, 0, 0);">&lt;/b&gt;</span>");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">This code applies templates to the
child nodes of nodes named <span style="font-weight: bold;">G</span>,
and wraps the output from that operation in the XHTML tags for bold, <span
 style="font-weight: bold;">&lt;b&gt;...&lt;/b&gt;</span>.<br>
<br>
Compare this code to the template rule shown in Listing 7.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A match for
elements Q, R, S, and T</span><br>
<br>
Listing 21 shows custom code that applies to nodes named <span
 style="font-weight: bold;">Q</span>, <span style="font-weight: bold;">R</span>,
<span style="font-weight: bold;">S</span>, and <span
 style="font-weight: bold;">T</span>.</span><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          //Create four levels of XHTML headers<br>          else if(node.getNodeName() == "Q"){<br>            out.println("&lt;h1&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h1&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "R"){<br>            out.println("&lt;h2&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h2&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "S"){<br>            out.println("&lt;h3&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h3&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "T"){<br>            out.println("&lt;h4&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h4&gt;");<br>          }//end if<br><br><b><font
 face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);"><font color="#ff0000"><b>Similar
blocks of code</b></font><br>
<br>
The four blocks of code are very
similar.&nbsp; Each block of code applies templates to the matching
node type, and surrounds the output from that operation with the XHTML
tags for a header, such as <span style="font-weight: bold;">&lt;h1&gt;...&lt;/h1&gt;</span>.&nbsp;
However, the size of the header differs from one to the next.<br>
<br>
Compare the block of code in Listing 21 that matches <span
 style="font-weight: bold;">Q</span> with the template rule in Listing
3.&nbsp; Compare all four of the code blocks to the last four template
rules in Figure 3.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Processing
nodes with no match</span><br>
<br>
This XML document contains several nodes for which there is no matching
template in the stylesheet and no matching code block in this program,
including the root element node named <span style="font-weight: bold;">A</span>.<br>
<br>
Whenever the XSLT processor encounters an element node for which there
is no matching template rule, it executes a built-in rule for element
nodes.<br>
<br>
When this program encounters an element node for which there is no
matching code block in the element node case of the <span
 style="font-weight: bold;">switch</span> statement, it executes the
code shown in Listing 22.</span><span style="color: rgb(0, 0, 0);"><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><br>
</span></span></span><span style="color: rgb(0, 0, 0);">
</span>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          else{//invoke default behavior<br>            defElOrRtNodeTemp(node);<br>          }//end else<br>          break;<br>        }//end case ELEMENT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="color: rgb(0, 0, 0);">As you can see, the code in Listing
22 invokes the method named <span style="font-weight: bold;">defElOrRtNoteTemp</span>,
passing the unmatched node as a parameter.&nbsp; This is a method that
mimics the built-in behavior of the XSLT processor.&nbsp; I discussed
it in detail in an earlier lesson, and won't repeat that discussion
here.<br>
</span><span style="font-weight: bold;"><br>
</span><span style="font-weight: bold; color: rgb(255, 0, 0);">The
remainder
of the processNode method</span><br>
<span style="color: rgb(0, 0, 0);"><br>
That completes the discussion of the case for elements nodes in the <span
 style="font-weight: bold;">switch</span> statement of the <span
 style="font-weight: bold;">processNode</span> method.&nbsp; That
leaves the following cases not yet discussed:<br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">Text nodes</span></li>
  <li><span style="color: rgb(0, 0, 0);">Attribute nodes</span></li>
  <li><span style="color: rgb(0, 0, 0);">Comment nodes</span></li>
  <li><span style="color: rgb(0, 0, 0);">Processing instruction nodes</span></li>
  <li><span style="color: rgb(0, 0, 0);">Namespace nodes (default case)<br>
    </span></li>
</ul>
<span style="color: rgb(0, 0, 0);"><font color="#ff0000"><b>No new code
for these nodes</b></font><br>
<br>
However, there is no new code in the
cases for these nodes in comparison with the code discussed in previous
lessons.&nbsp; Therefore, I won't repeat that discussion in this lesson.<br>
<br>
That completes the discussion of the <span style="font-weight: bold;">processNode</span>
method, and leaves the following methods not yet discussed:<br>
</span>
<ul>
  <li><span style="color: rgb(0, 0, 0);">main</span></li>
  <li><span style="color: rgb(0, 0, 0);">defTextOrArrrTemp</span></li>
  <li>defElOrRtNodeTemp</li>
  <li>defComOrProcInstrTemp</li>
  <li>applyTemplates</li>
  <li>valueOf</li>
  <li>doXslTransform</li>
</ul>
However, these methods are identical to methods having the same name
that I discussed in detail in earlier lessons.&nbsp; I won't repeat
that discussion in this lesson.<br>
<span style="color: rgb(0, 0, 0);"><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 0, 0);"><br>
The
program output</span><span style="font-weight: bold;"><br>
<br>
</span></span></span><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);">The output produced by this program is
essentially the same as the XSLT transform output discussed in the
early part of the lesson.&nbsp; The output shown in rendered form in
Figure 2, and in raw XHTML form in Figure 4 represents the output
of both the program and the XSLT transform.</span></span></span><br>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the Java code, XML file, and XSL file from
the listings near the end of this lesson.&nbsp; Compile and execute the
program.&nbsp; Experiment with the files, making changes, and observing
the
results
of your
changes.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
In this lesson, I showed you how to use XSLT to transform an XML
document into an XHTML document.&nbsp; I also showed you how to
write Java code to perform the same transformation.
<ul>
</ul>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>The next several lessons in this series will illustrate parallel
Java code
and XSLT transformations to transform XML documents into XHTML
documents.&nbsp; The sample programs will illustrate various aspects of
the manipulation of a DOM tree using Java code.
</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the various files discussed in this lesson are
contained in the listings that follow.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Dom03.java<br>Copyright 2003 R.G.Baldwin<br><br>Ths program transforms an XML file into an XHTML<br>file using a combination of recursive and<br>iterative processing.<br><br>New material added to this lesson includes a<br>method that emulates an xsl:for-each template<br>rule.<br><br>This program compares the transformation of an<br>XML file to an XHTML file using two different<br>approaches:<br><br>1. An XSLT style sheet<br>2. Program code that emulates the behavior of the<br>   XSL transformation.<br><br>Two XHTML files are produced, one by the XSL<br>transformation and one by the program code.<br><br>Both output files validate as XHTML at<br>http://validator.w3.org/file-upload.html<br><br>Both also validate as HTML at<br>http://www.htmlhelp.com/tools/validator/<br>upload.html<br><br>Both also validate using the program named<br>DomTree02.java,which means that they validate as<br>XML under JAXP.<br><br>The program requires three command line<br>parameters in the following order:<br>1, The name of the input XML file - must be<br>   Dom03.xml<br>2. The name of the XHTML output file to be<br>   produced by the XSL transformation.<br>3. The name of the XHTML output file to be<br>   produced by the program code that emulates<br>   the XSL transformation.<br><br>This program implements all six built-in default<br>template rules for an XML processor.  In<br>addition, it implements several other<br>template rules that are required to support<br>the built in rules, such as xsl:value-of and<br>xsl:for-each.<br><br>The program creates several custom template<br>rules.<br><br>To create a custom temtlate rule:<br>1.  Go to the processNode method.<br>2.  Identify the node type.<br>3.  Change the conditional clause in the if<br>    statement to implement the match.<br>4.  Write code in the body of the if statement to<br>    implement the custom rule.<br><br>If the modified conditional clause evaluates to<br>true, the custom rule will be executed.  If<br>false,the default rule will be executed.<br><br>In particular, this program illustrates Java code<br>that emulates the XSLT templates in the file<br>named Dom03.xsl.<br><br>The name of the XSL stylesheet file is extracted<br>from the processing instruction in the XML file.<br><br>The program begins by executing code to transform<br>the incoming XML file in a way that mimics the<br>XSL Transformation.  Along the way, it saves the<br>processing instructions containing the ID of the<br>stylesheet file for use by the XSLT process<br>later.  Otherwise, the code that performs the<br>XSL transformation later would have to search the<br>DOM tree for the XSL stylesheet file.<br><br>Then the program uses the XSLT style sheet to<br>transform the XML file into a result file.<br><br>This is not a general purpose program. This<br>program, and the XSLT file named Dom03.xsl<br>are specifically designed to transform the<br>contents of the file named Dom03.xml into an<br>XHTML file.<br><br>No effort was made to provide meaningful<br>information about errors and exceptions.<br><br>Tested with SDK 1.4.2 under WinXP.<br>************************************************/<br><br>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br><br>import org.w3c.dom.*;<br><br>import javax.xml.transform.Transformer;<br>import javax.xml.transform.TransformerFactory;<br>import javax.xml.transform.dom.DOMSource;<br>import javax.xml.transform.stream.*;<br><br>import java.util.*;<br>import java.io.*;<br><br>public class Dom03{<br><br>  PrintWriter out;//output stream<br>  //Save processing instruction nodes here<br>  static Vector procInstr = new Vector();<br><br>  public static void main(String argv[]){<br>    if (argv.length != 3){<br>      System.err.println(<br>        "usage: java Dom03 "<br>        + "xmlFileIn "<br>        + "xformFileOut "<br>        + "codeFileOut");<br>      System.exit(0);<br>    }//end if<br><br>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects<br>      ///<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object.  Change<br>      // the following parameter to false for a<br>      // non-validating parser.<br>      ///<br>      factory.setValidating(true);<br>      factory.setNamespaceAware(false);<br>      //The following statement causes the parser<br>      // to ignore cosmetic whitespace between<br>      // elements.<br>      ///<br>      factory.<br>       setIgnoringElementContentWhitespace(true);<br><br>      //Get a DocumentBuilder (parser) object<br>      ///<br>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      ///<br>      Document document = builder.parse(<br>                              new File(argv[0]));<br><br>      //Instantiate an object of this class<br>      ///<br>      Dom03 thisObj = new Dom03();<br><br>      //TRANSFORMATION THROUGH PROGRAM CODE<br>      //Use program code to transform the<br>      // DOM tree into an output file.<br>      //<br>      //Get an output stream for the output<br>      // produced by the program code.  This<br>      // stream object is used by several<br>      // methods, so it was instantiated at this<br>      // point and saved as an instance variable<br>      // of the object.<br>      ///<br>      thisObj.out = new PrintWriter(<br>                  new FileOutputStream(argv[2]));<br><br>      //Process the DOM tree, beginning with the<br>      // Document node to produce the output.<br>      // Invocation of processDocumentNode starts<br>      // a recursive process that processes the<br>      // entire DOM tree.<br>      ///<br>      thisObj.processDocumentNode(document);<br><br><br>      //XSLT TRANSFORMATION<br>      //Use XSLT to transform the DOM tree into<br>      // an output file.  Note that the success<br>      // of this method call depends on the<br>      // stylesheet processing instruction having<br>      // been saved while the transformation was<br>      // being performed using program code<br>      // above.  Otherwise, it would be necessary<br>      // to include the code in this method to<br>      // search the DOM tree for the stylesheet<br>      // processing instruction. All processing<br>      // instructions are saved in a Vector<br>      // object, which is passed as the third<br>      // parameter to this method.<br>      ///<br>      thisObj.doXslTransform(<br>                     document,argv[1],procInstr);<br><br>    }catch(Exception e){<br>      //Note that no effort was made to provide<br>      // meaningful results in the event of an<br>      // exception or error.<br>      ///<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }// end main()<br>  //-------------------------------------------//<br><br>  //This method is used to produce any text<br>  // required in the output at the document<br>  // level, such as the XML declaration for an<br>  // XML document.<br>  void processDocumentNode(Node node){<br>    //Create the beginning of the XHTML document<br>    out.println("&lt;?xml version=\"1.0\" "<br>                       + "encoding=\"UTF-8\"?&gt;");<br>    out.println(<br>          "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD "<br>             + "XHTML 1.0 Transitional//EN\" "<br>             + "\"http://www.w3.org/TR/xhtml1/"<br>             + "DTD/xhtml1-transitional.dtd\"&gt;");<br>    out.println("&lt;html xmlns=\"http://www.w3."<br>             + "org/1999/xhtml\" xml:lang=\"en\""<br>             + " lang=\"en\"&gt;");<br>    out.println("&lt;head&gt;");<br>    out.println(<br>            "&lt;meta http-equiv=\"content-type\" "<br>               + "content=\"text/html; charset="<br>                            + "UTF-8\"/&gt;");<br>    out.println("&lt;title&gt;Generated XHTML file"<br>                                   + "&lt;/title&gt;");<br>    out.println("&lt;/head&gt;");<br>    out.println("&lt;body&gt;");<br>    //Output similar to the above applies to<br>    // most XHTML documents.<br><br>    //Now set up an XHTML table.  This is<br>    // peculiar to this particular example.<br>    out.println("&lt;table border=\"2\" " +<br>                         "cellspacing=\"0\" " +<br>                         "cellpadding=\"0\" " +<br>                         "width=\"330\" " +<br>                         "bgcolor=\"#FFFF00\"&gt;" +<br>                         "&lt;tr&gt;&lt;td&gt;");<br><br>    //Go process the root (document) node. This<br>    // method call triggers a recursive process<br>    // that processes the entire DOM tree.<br>    processNode(node);<br><br>    //Finish the XHTML table.  This output is<br>    // peculiar to this particular example.<br>    out.println("&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;");<br><br>    //Now finish the output document and flush<br>    // the output buffer.  This would apply to<br>    // most XHTML documents.<br>    out.println("&lt;/body&gt;&lt;/html&gt;");<br>    out.flush();<br>  }//end processDocumentNode<br>  //-------------------------------------------//<br><br>  //There are seven kinds of nodes:<br>  // root or document<br>  // element<br>  // attribute<br>  // text<br>  // comment<br>  // processing instruction<br>  // namespace<br>  //<br>  //This method handles the first six.<br>  // Apparently it is not possible to handle<br>  // namespace nodes in Java because there is<br>  // no constant in the Node class to identify<br>  // namespace nodes<br>  ///<br>  void processNode(Node node){<br><br>    try{<br>      if (node == null){<br>        System.err.println(<br>                  "Nothing to do, node is null");<br>        return;<br>      }//end if<br><br>      //Process the incoming node based on its<br>      // type.<br>      ///<br>      int type = node.getNodeType();<br><br>      //To define an overriding template rule,<br>      // insert the matching condition in the<br>      // conditional clause of the if statement,<br>      // and provide code to implement the rule<br>      // in the body of the if statement.  If the<br>      // conditional clause evaluates to true,<br>      // the default rule for that element type<br>      // will not be processed.<br>      ///<br>      switch (type){<br>        case Node.TEXT_NODE:{<br>          if(true){<br>            out.println(node.getNodeValue());<br>          }else{//invoke default behavior<br>            //This won't be reached in this<br>            // example, but I will leave it<br>            // here as a reminder of the<br>            // default behavior.<br>            out.print(defTextOrAttrTemp(node));<br>          }//end else<br>          break;<br>        }//end case Node.TEXT_NODE<br><br>        case Node.ATTRIBUTE_NODE:{<br>          if(false){<br>            //Change conditional and write<br>            // overriding handler here<br>            ///<br>          }else{//invoke default behavior<br>            out.print(defTextOrAttrTemp(node));<br>          }//end else<br>          break;<br>        }//end case Node.ATTRIBUTE_NODE<br><br>        case Node.ELEMENT_NODE:{<br>          if(node.getNodeName() == "B"){<br>            //Process all XML child nodes<br>            // recursively<br>            applyTemplates(node,null);<br>          }//end if<br><br>          else if(node.getNodeName() == "C"){<br>            //Begin XHTML paragraph element<br>            out.println("&lt;p&gt;");<br>            //Process all XML child nodes<br>            // recursively<br>            applyTemplates(node,null);<br>            //End XHTML paragraph element<br>            out.println("&lt;/p&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "D"){<br>            //First process the child nodes<br>            // named E.<br>            out.println("List of items in E");<br>            //Begin XHTML unordered list<br>            out.println("&lt;ul&gt;");<br>            //Iteratively put text from E<br>            // elements and their children into<br>            // the list.<br>            forEach(node,"E");<br>            //End XHTML unordered list<br>            out.println("&lt;/ul&gt;");<br><br>            //Now process the child nodes<br>            // named F.<br>            out.println("List of items in F");<br>            //Begin XHTML ordered list<br>            out.println("&lt;ol&gt;");<br>            //Iteratively put text from F<br>            // elements and their children in the<br>            // list.<br>            forEach(node,"F");<br>            //End XHTML ordered list<br>            out.println("&lt;/ol&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "G"){<br>            //Display children as XHTML bold<br>            out.println("&lt;b&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/b&gt;");<br>          }//end if<br><br>          //Create four levels of XHTML headers<br>          else if(node.getNodeName() == "Q"){<br>            out.println("&lt;h1&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h1&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "R"){<br>            out.println("&lt;h2&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h2&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "S"){<br>            out.println("&lt;h3&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h3&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "T"){<br>            out.println("&lt;h4&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/h4&gt;");<br>          }//end if<br><br>          //The following rules for E and F<br>          // are invoked as a result of the<br>          // behavior of the forEach method. The<br>          // code could have been placed inside<br>          // the forEach method.  However, I<br>          // elected to put it here in an attempt<br>          // to confine all of the custom code<br>          // to the methods named processNode and<br>          // processDocumentNode.<br>          else if(node.getNodeName() == "E"){<br>            //Create an XHTML list item<br>            // containing information from child<br>            // nodes.<br>            out.println("&lt;li&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/li&gt;");<br>          }//end if<br><br>          else if(node.getNodeName() == "F"){<br>            //Create an XHTML list item<br>            // containing information from child<br>            // nodes.<br>            out.println("&lt;li&gt;");<br>            applyTemplates(node,null);<br>            out.println("&lt;/li&gt;");<br>          }//end if<br><br>          else{//invoke default behavior<br>            defElOrRtNodeTemp(node);<br>          }//end else<br>          break;<br>        }//end case ELEMENT_NODE<br><br>        case Node.DOCUMENT_NODE:{<br>          if(false){<br>            //Change conditional and write<br>            // overriding handler here<br>            ///<br>          }else{//invoke default behavior<br>            defElOrRtNodeTemp(node);<br>          }//end else<br>          break;<br>        }//end case DOCUMENT_NODE<br><br>        case Node.COMMENT_NODE:{<br>          if(false){<br>            //Change conditional and write<br>            // overriding handler here<br>            ///<br>          }else{//invoke default behavior<br>            defComOrProcInstrTemp(node);<br>          }//end else<br>          break;<br>        }//end case COMMENT_NODE<br><br>        case Node.PROCESSING_INSTRUCTION_NODE:{<br>          if(false){<br>            //Change conditional and write<br>            // overriding handler here<br>          }else{//invoke default behavior<br>            //First save proc instr for later<br>            // use.<br>            procInstr.add(node);<br>            //Now invoke default behavior.<br>            defComOrProcInstrTemp(node);<br>          }//end else<br>          break;<br>        }//end case PROCESSING_INSTRUCTION_NODE<br><br>        default:{<br>          //Ignore all other node types.<br>        }//end default<br><br>      }//end switch<br><br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }//end processNode(Node)<br>  //-------------------------------------------//<br><br>  //This method emulates the following default<br>  // template rule:<br>  //  &lt;xsl:template match="text()|@*"&gt;<br>  //   &lt;xsl:value-of select="."/&gt;<br>  //  &lt;/xsl:template&gt;<br>  ///<br>  String defTextOrAttrTemp(Node node)<br>                                throws Exception{<br>    int nodeType = node.getNodeType();<br>    if((nodeType == Node.ATTRIBUTE_NODE)<br>                || (nodeType == Node.TEXT_NODE)){<br>      //Get and return the value of the context<br>      // node.<br>      ///<br>      return valueOf(node,".");<br>    }else{<br>      throw new Exception(<br>         "Bad call to defaultTextOrAttr method");<br>    }//end else<br>  }//end defaultTextOrAttr<br>  //-------------------------------------------//<br><br>  //This method emulates the following default<br>  // template rule:<br>  //  &lt;xsl:template match="*|/"&gt;<br>  //   &lt;xsl:apply-templates/&gt;<br>  //  &lt;/xsl:template&gt;<br>  ///<br>  void defElOrRtNodeTemp(Node node)<br>                                throws Exception{<br>    int nodeType = node.getNodeType();<br>    if((nodeType == Node.ELEMENT_NODE) ||<br>               (nodeType == Node.DOCUMENT_NODE)){<br>      //Note that the following is a recursive<br>      // method call.<br>      ///<br>      applyTemplates(node,null);<br>    }else{<br>      throw new Exception(<br>                "Bad call to defElOrRtNodeTemp");<br>    }//end else<br>  }//end defElOrRtNodeTemp<br>  //-------------------------------------------//<br><br>  //This method emulates the following default<br>  // template rule:<br>  // &lt;xsl:template<br>  //   match="processing-instruction()|comment()"<br>  ///<br>  String defComOrProcInstrTemp(Node node)<br>                                throws Exception{<br>    int nodeType = node.getNodeType();<br>    if((nodeType == Node.COMMENT_NODE) ||<br>            (nodeType ==<br>              Node.PROCESSING_INSTRUCTION_NODE)){<br>      //According to page Nutshell pg 148, the<br>      // default rule for comments and processing<br>      // instructions doesn't output anything<br>      // into the result tree.<br>      ///<br>      return "";//empty string<br>    }else{<br>      throw new Exception("Bad call to " +<br>            "defalutCommentOrProcInstrTemplate");<br>    }//end else<br>  }//end defComOrProcInstrTemp<br>  //-------------------------------------------//<br><br>  //See Nutshell, pg 148 for an explanation as to<br>  // why it is not possible to write a Java<br>  // method that emulates the default namespace<br>  // template.<br>  ///<br>  void defaultNamespaceTemplate(Node node)<br>                                throws Exception{<br>    throw new Exception("See Nutshell pg 148" +<br>              "regarding default behavior for " +<br>              "namespace template.");<br>  }//end defaultNamespaceTemplate<br>  //-------------------------------------------//<br><br>  //Simulates an XSLT apply-templates rule.<br>  //  &lt;xsl:apply-templates<br>  //    optional select = "..."<br>  //    optional mode = "..."<br>  //   &gt;<br>  //Note that the mode attribute is not supported<br>  // in this version.<br>  //If the select parameter is null, all child<br>  // nodes are processed.<br>  void applyTemplates(Node node,String select){<br>    NodeList children = node.getChildNodes();<br>    if (children != null){<br>      int len = children.getLength();<br>      //Iterate on NodeList of child nodes.<br>      for (int i = 0; i &lt; len; i++){<br>        if((select == null) ||<br>              (select.equals(children.item(i).<br>                                getNodeName()))){<br>          //Note that the following is a<br>          // recursive method call.<br>          ///<br>          processNode(children.item(i));<br>        }//end if<br>      }//end for loop<br>    }//end if children != null<br><br>  }//end applyTemplates<br>  //-------------------------------------------//<br><br>  //This method simulates an XSLT<br>  //   &lt;xsl:value-of select="???"/&gt;<br>  // The general form of the method call is<br>  //   valueOf(Node theNode,String select)<br>  //<br>  //The method recognizes three forms of call:<br>  //  valueOf(Node theNode,String "@attrName")<br>  //  valueOf(Node theNode,String ".")<br>  //  valueOf(Node theNode,String "nodeName")<br>  //<br>  //In the first form, the method returns the<br>  // text value of the named attribute of<br>  // theNode.  An attribute is specified by a<br>  // select value that begins with @.  If the<br>  // attribte doesn't exist, the method returns<br>  // an empty string.<br>  //<br>  //In the second form, the method returns the<br>  // concatenated text values of descendants of<br>  // the context node.<br>  //<br>  //In the third form, the method returns the<br>  // concatenated text values of all descendants<br>  // of a specified child node of the context<br>  // node.  If the context node has more than one<br>  // child node with the specified name, only the<br>  // first one found is processed.  The others<br>  // are ignored.<br>  //<br>  //The method does not support the following,<br>  // which are standard features of xsl:value-of:<br>  //   disable-output-escaping<br>  //   processing instruction nodes<br>  //   comment nodes<br>  //   namespace nodes<br>  ///<br><br>  public String valueOf(Node node,String select){<br><br>    if(select != null<br>                     &amp;&amp; select.charAt(0) == '@'){<br>      //This is a request for the value of an<br>      // attribute. Returns empty string if the<br>      // attribute doesn't exist on the element.<br>      String attrName = select.substring(1);<br>      NamedNodeMap attrList =<br>                            node.getAttributes();<br>      Node attrNode = attrList.getNamedItem(<br>                                       attrName);<br>      if(attrNode != null){<br>        return attrNode.getNodeValue();<br>      }else{<br>        return "";//empty string<br>      }//end else<br>    }//end if on @<br><br>    else if(select != null<br>                          &amp;&amp; select.equals(".")){<br>      //This is a request to process the context<br>      // node<br>      int nodeType = node.getNodeType();<br>      if(nodeType == Node.ELEMENT_NODE){<br>        //Process the context node as an element<br>        // node.  Return the concatenated text<br>        // values of all descendants of the<br>        // context node.<br>        NodeList childNodes =<br>                            node.getChildNodes();<br>        int listLen = childNodes.getLength();<br>        String nodeTextValue = "";//result<br><br>        for(int j = 0; j &lt; listLen; j++){<br>          nodeTextValue +=<br>               valueOf(childNodes.item(j),".");<br>        }//end for loop<br>        return nodeTextValue;<br>      }else if(nodeType == Node.TEXT_NODE){<br>        //Process the context node as a text<br>        // node.  Simply get and return its<br>        // value.<br>        return node.getNodeValue();<br>      }else{<br>        //ignore all other context node types<br>      }//end else<br>    }//end if for context node<br><br>    else if(select != null){<br>      //Process a child node whose name is<br>      // specified by the value of the incoming<br>      // parameter named select.  Get and return<br>      // the concatenated text values of all<br>      // descendants of the specified child node.<br>      //This process assumes that there is only<br>      // one child node with the specified name<br>      // and processes the first one that it<br>      // finds.<br>      NodeList children = node.getChildNodes();<br>      int len = children.getLength();<br>      for (int i = 0; i &lt; len; i++){<br>        //Trap the specified child node<br>        if(children.item(i).getNodeName().<br>                                 equals(select)){<br>          //Make a recursive call and let<br>          // existing code do the work.<br>          return valueOf(children.item(i),".");<br>          //The above return statement causes any<br>          // additional child nodes having the<br>          // same name to be ignored.<br>        }//end if getNodeName == select<br>      }//end for loop on all child nodes<br>    }//end else if(select != null)<br>    //Will reach here only if value of select<br>    // is null.<br>    ///<br>    return "";//empty string<br>  }//end method valueOf<br>  //-------------------------------------------//<br><br>  //This method simulates an XSLT for-each<br>  // template rule<br>  private void forEach(Node node,String select){<br>    NodeList children = node.getChildNodes();<br>    if (children != null){<br>      int len = children.getLength();<br>      //Iterate on NodeList of child nodes,<br>      // processing nodes that match the select.<br><br>      for (int i = 0; i &lt; len; i++){<br>        if(children.item(i).getNodeName().<br>                                 equals(select)){<br>          //Make a recursive call from within<br>          // this iterative template rule.<br>          processNode(children.item(i));<br>        }//end if<br>      }//end for loop<br>    }//end if<br>  }//end forEach<br>  //-------------------------------------------//<br><br>  //This method uses an incoming XSLT stylesheet<br>  // file to transform an incoming Document<br>  // object into an output file.  Note that the<br>  // successful invocation of this method depends<br>  // on the processing instruction containing the<br>  // stylesheet having been saved in a Vector<br>  // object that is received as an incoming<br>  // parameter.  Otherwise, this method would<br>  // have to search the DOM for the stylesheet<br>  // processing instruction.<br>  ///<br>  void doXslTransform(Document document,<br>                      String outFile,<br>                      Vector procInstr)<br>                                throws Exception{<br>    try{<br>      //Get stylesheet ID from proc instr.<br>      ProcessingInstruction pi = null;<br>      boolean piFlag = false;<br>      int size = procInstr.size();<br>      //Search for a stylesheet in the Vector<br>      // containing processing instruction nodes.<br>      ///<br>      for(int i = 0; i &lt; size; i++){<br>        pi = (ProcessingInstruction)procInstr.<br>                                          get(i);<br>        if(pi.getTarget().startsWith(<br>               "xml-stylesheet") &amp;&amp; pi.getData().<br>                startsWith("type=\"text/xsl\"")){<br>          //Looks like a good stylesheet.<br>          ///<br>          piFlag = true;<br>          break;<br>        }//end if<br>      }//end for loop<br>      if(piFlag == false){//still false?<br>        throw new Exception(<br>                          "No valid stylesheet");<br>      }//end if<br>      //Get the stylesheet file reference<br>      ///<br>      String xslFile = pi.getData().<br>                  substring(pi.getData().indexOf(<br>                                     "href=")+6);<br>      //Eliminate the quotation mark at the end<br>      ///<br>      xslFile = xslFile.substring(<br>                           0,xslFile.length()-1);<br><br>      //Get a TransformerFactory object<br>      ///<br>      TransformerFactory xformFactory =<br>                TransformerFactory.newInstance();<br>      //Get an XSL Transformer object based on<br>      // the XSL file discovered above.<br>      ///<br>      Transformer transformer =<br>                     xformFactory.newTransformer(<br>                         new StreamSource(<br>                             new File(xslFile)));<br>      //Get a DOMSource object that represents<br>      // the DOM tree.<br>      ///<br>      DOMSource source = new DOMSource(document);<br><br>      //Get an output stream for the output<br>      // file.<br>      ///<br>      PrintWriter xformStream = new PrintWriter(<br>                  new FileOutputStream(outFile));<br><br>      //Get a StreamResult object that points to<br>      // the output file.  Then transform the DOM<br>      // sending text to the output file.<br>      ///<br>      StreamResult xformResult =<br>                   new StreamResult(xformStream);<br><br>      //Do the transform<br>      ///<br>      transformer.transform(source,xformResult);<br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }//end doXslTransform<br><br>}// class Dom03<br><br><b><font
 face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
</p>
<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre><span style="color: rgb(255, 0, 0); font-weight: bold;">NOTE:  IT WAS NECESSARY TO MANUALLY ENTER SOME</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">LINE BREAKS INTO THIS DOCUMENT TO FORCE IT TO</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">FIT INTO THE NARROW PUBLICATION FORMAT.</span><br><br>&lt;?xml version="1.0"?&gt;<br><br>&lt;!-- File Dom03.xml<br>Copyright 2003 R. G. Baldwin<br>Illustrates recursive and <br>iterative transformation using <br>templates and for-each.--&gt;<br><br>&lt;!DOCTYPE A [<br>&lt;!ELEMENT A (Q,B,B)*&gt;<br>&lt;!ELEMENT B (B | C | D | R | S | T)*&gt;<br>&lt;!ELEMENT C (#PCDATA)&gt;<br>&lt;!ELEMENT D (E | F)*&gt;<br>&lt;!ELEMENT E (#PCDATA | G)*&gt;<br>&lt;!ELEMENT F (#PCDATA)&gt;<br>&lt;!ELEMENT G (#PCDATA)&gt;<br>&lt;!ELEMENT Q (#PCDATA)&gt;<br>&lt;!ELEMENT R (#PCDATA)&gt;<br>&lt;!ELEMENT S (#PCDATA)&gt;<br>&lt;!ELEMENT T (#PCDATA)&gt;<br>]&gt;<br><br>&lt;?xml-stylesheet type="text/xsl" <br>                               href="Dom03.xsl"?&gt;<br><br>&lt;A&gt;<br>&lt;Q&gt;A Big Header&lt;/Q&gt;<br><br>&lt;B&gt;<br>&lt;C&gt;Text block 1.&lt;/C&gt;<br><br>&lt;R&gt;A Mid Header&lt;/R&gt;<br><br>&lt;C&gt;Text block 2.&lt;/C&gt;<br><br>&lt;!--Following PI should be ignored by both<br>the XSLT and the coded processor.--&gt;<br>&lt;?processor ProcInstr="Dummy"?&gt;<br><br>&lt;S&gt;A Small Header&lt;/S&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 3.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;S&gt;Another Small Header&lt;/S&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 4.&lt;/C&gt;<br><br>&lt;T&gt;A Smallest Header&lt;/T&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 5.&lt;/C&gt;<br><br>&lt;D&gt;<br>&lt;E&gt;First list item in E<br>&lt;G&gt;Nested G text element&lt;/G&gt;<br>&lt;/E&gt;<br>&lt;F&gt;First list item in F&lt;/F&gt;<br>&lt;E&gt;Second list item in E&lt;/E&gt;<br>&lt;F&gt;Second list item in F&lt;/F&gt;<br>&lt;E&gt;Third list item in E&lt;/E&gt;<br>&lt;F&gt;Third list item in F&lt;/F&gt;<br>&lt;/D&gt;<br><br>&lt;C&gt;Text block 6.&lt;/C&gt;<br>&lt;/B&gt;<br>&lt;C&gt;Text block 7.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;R&gt;Another Mid Header&lt;/R&gt;<br>&lt;C&gt;Text block 8.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;B&gt;<br>&lt;R&gt;Another Mid Header in Another B&lt;/R&gt;<br>&lt;C&gt;Text block 9.&lt;/C&gt;<br>&lt;/B&gt;<br>&lt;/A&gt;<br><br><b><font
 face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre><span style="color: rgb(255, 0, 0); font-weight: bold;">NOTE:  IT WAS NECESSARY TO MANUALLY ENTER SOME</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">LINE BREAKS INTO THIS DOCUMENT TO FORCE IT TO</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">FIT INTO THE NARROW PUBLICATION FORMAT.</span><br><br>&lt;?xml version='1.0'?&gt;<br><br>&lt;!-- File Dom03.xsl<br>Copyright 2003 R. G. Baldwin<br>Illustrates recursive and <br>iterative transformation using <br>templates and for-each.--&gt;<br><br>&lt;xsl:stylesheet <br>version="1.0"  <br>xmlns:xsl="http://www.w3.org/1999<br>                                /XSL/Transform" &gt;<br><br>&lt;xsl:output method="xml" <br>doctype-public="-//W3C//DTD <br>                      XHTML 1.0 Transitional//EN"<br>doctype-system="http://www.w3.<br>    org/TR/xhtml1/DTD/xhtml1-transitional.dtd" /&gt;<br><br>&lt;!--Match the root of the DOM tree--&gt;<br>&lt;xsl:template match="/"&gt;<br><br>&lt;!--Note, would like to see the following <br>attribute on the html tag, but it causes <br>problems with the JAXP transformer.<br>xmlns="http://www.w3.org/1999/xhtml"<br>xml:lang="en" lang="en"&gt;<br>--&gt;<br><br>&lt;html&gt;<br><br>&lt;head&gt;<br>&lt;meta http-equiv="content-type" <br>content="text/html; charset=UTF-8"/&gt;<br>&lt;title&gt;Generated XHTML file&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>&lt;table border="2" cellspacing="0" <br>    cellpadding="0" width="330" <br>    bgcolor="#FFFF00" &gt;<br>&lt;tr&gt;<br>&lt;td&gt;<br>&lt;!--Process children of DOM root--&gt;<br>&lt;xsl:apply-templates/&gt;<br>&lt;/td&gt;<br>&lt;/tr&gt;<br>&lt;/table&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br><br>&lt;/xsl:template&gt;<br>&lt;!-- End root match template --&gt;<br><br>&lt;xsl:template match="B"&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/xsl:template&gt;<br>&lt;!-- End B match template --&gt;<br><br>&lt;xsl:template match="C"&gt;<br>&lt;p&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/p&gt;<br>&lt;/xsl:template&gt;<br>&lt;!-- End C match template --&gt;<br><br>&lt;xsl:template match="D"&gt;List of items in E<br>&lt;ul&gt;<br>&lt;!-- loop --&gt;<br>&lt;xsl:for-each select="E"&gt;<br>&lt;li&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/li&gt;<br>&lt;/xsl:for-each&gt;<br>&lt;!-- End loop --&gt;<br>&lt;/ul&gt;List of items in F<br>&lt;ol&gt;<br>&lt;!-- loop --&gt;<br>&lt;xsl:for-each select="F"&gt;<br>&lt;li&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/li&gt;<br>&lt;/xsl:for-each&gt;<br>&lt;!-- End loop --&gt;<br>&lt;/ol&gt;<br><br>&lt;/xsl:template&gt;<br>&lt;!-- End D match template --&gt;<br><br>&lt;xsl:template match="G"&gt;<br>&lt;b&gt;<br>&lt;xsl:apply-templates /&gt;<br>&lt;/b&gt; <br>&lt;/xsl:template&gt;<br>&lt;!-- End G match template --&gt;<br><br>&lt;!-- Header templates follow --&gt;<br>&lt;xsl:template match="Q"&gt;<br>&lt;h1&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/h1&gt;<br>&lt;/xsl:template&gt;<br>&lt;!-- End Q match template --&gt;<br><br>&lt;xsl:template match="R"&gt;<br>&lt;h2&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/h2&gt;<br>&lt;/xsl:template&gt;<br>&lt;!-- End R match template --&gt;<br><br>&lt;xsl:template match="S"&gt;<br>&lt;h3&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/h3&gt;<br>&lt;/xsl:template&gt;<br>&lt;!-- End S match template --&gt;<br><br>&lt;xsl:template match="T"&gt;<br>&lt;h4&gt;<br>&lt;xsl:apply-templates /&gt; <br>&lt;/h4&gt;<br>&lt;/xsl:template&gt;<br>&lt;!-- End T match template --&gt;<br><br>&lt;/xsl:stylesheet&gt;<br><br><br><b><font
 face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<br>
<p> </p>
<p>
</p>
<p> </p>
<hr width="100%" size="2">
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and XML. In addition to the many platform and/or language independent
benefits of Java and C# applications, he believes that a combination of
Java, C#, and XML will become the primary driving force in the delivery
of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects, and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com/">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology to real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- <br>
</p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
