<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Using the Java 2D BandCombineOp Filter Class to Process 
Images</h2>
<i>Learn how to write programs that extract Raster objects from an image 
and then use the BandCombineOp image-filtering class of the Java 2D API 
for a variety of image-processing purposes.</i><p><b>Published:</b>&nbsp; July 
3, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 458</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#General%20Background%20Information">General
Background Information</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listing</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p><font color="#ff0000"><b>Part of a series</b></font></p>
<p>In an earlier lesson entitled &quot;A Framework for Experimenting with Java 2D 
Image-Processing Filters&quot; <i>(see <a href="#References">References</a>)</i>, I taught you how to write a framework program that 
makes it easy to use the image-filtering classes of the Java 2D API to process the pixels in an 
image and to display the processed image.</p>
<p>At the close of that lesson, I told you that future lessons would teach you 
how to use the following image-filtering classes from the Java 2D
<a name="FilterClassList">API</a>:</p>
<ul>
	<li><b>LookupOp</b></li>
	<li><b>AffineTransformOp</b> </li>
	<li><b>BandCombineOp</b> </li>
	<li><b>ConvolveOp</b> </li>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b> </li>
</ul>
<p>In several previous lessons listed in the <a href="#References">References</a> 
section, I taught you how to use the <b>LookupOp</b> and the <b>
AffineTransformOp</b> image-filtering classes.</p>
<p>In this lesson, I will teach you how to use the <b>BandCombineOp</b> 
image-filtering class to perform a variety of filtering operations on images.&nbsp; I will 
also teach you how to extract and filter <b>Raster</b> objects from images.&nbsp;
<i>(The use of <b>Raster</b> objects is completely new to this lesson.)</i></p>
<p>I will teach you how to use the remaining classes from the above
<a href="#FilterClassList">list</a> in future lessons.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate 
browser window.&nbsp; That will make it easier for you to scroll back and forth among 
the different listings and figures while you are reading about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <font color="#000000">
<a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>I also recommend that you pay particular attention to the lessons listed in 
the <a href="Java454.htm#References">References</a> section of this document.
</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General Background Information</a></font></h2>
<p><font color="#ff0000"><b>Constructing images</b></font></p>
<p>Before getting into the programming details, it may be useful for you to 
review the concept of how images are constructed, stored, transported, and 
rendered in Java <i>(and in most modern computer environments for that matter).</i></p>
<p>I provided a great deal of information on those topics in the earlier lesson 
entitled
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
Processing Image Pixels using Java, Getting Started</a>.&nbsp; Therefore, I won't 
repeat that information here.&nbsp; Rather, I will simply refer you back to the
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
earlier lesson</a>.</p>
<p><font color="#ff0000"><b>The framework program named ImgMod05</b></font></p>
<p>It will also be useful for you to understand the behavior of the framework 
program named <b>ImgMod05</b>.&nbsp; Therefore, I strongly recommend that you study 
the earlier lesson entitled &quot;A Framework for Experimenting with Java 2D 
Image-Processing Filters&quot; <i>(see <a href="#References">References</a>)</i>.</p>
<p>However, if you don't have the time to do that, you should take a look at the 
earlier lesson entitled &quot;Using the Java 2D LookupOp Filter Class to Process 
Images&quot; <i>(see <a href="#References">References</a>)</i>, in which I summarized the behavior of the framework program named <b>
ImgMod05</b>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain an image-processing program named
<b>ImgMod41</b> that is compatible with the framework program named <b>ImgMod05</b>.</p>
<p><font color="#FF0000"><b>The program GUI</b></font></p>
<p>The program GUI is shown in <a name="Figure_1" href="#Figure_1">Figure 1</a>.</p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458a01.jpg" width="469" height="601"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In addition to providing instructions to the user, this GUI allows the user to specify the location and 
dimensions of a rectangular area within the original image, from which a <b>Raster</b> 
object will be extracted.&nbsp; The GUI also allows the user to specify the 
values in a 3x4 image-processing matrix having three rows and four columns that 
is used to process the raster using the <b>BandCombineOp</b> image-filtering 
class.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Buffered v.s. Raster objects.</b><br />
  I have illustrated the filtering of BufferedImage objects in 
	several previous lessons listed in the <a href="#References">References</a> 
	section.&nbsp; I will have more to say about Raster objects later in 
	this lesson.&nbsp; For now, suffice it to say that by converting the 
	BufferedImage object to a Raster object, it is possible to 
	operate on smaller rectangular areas of the image that are extracted from 
	within the body of the entire image.</td></tr></table>
</td>
</tr>
</table>

<font color="#ff0000"><b>BufferedImage objects versus 
<a name="Raster_objects">Raster objects</a></b></font></p>
<p>As I mentioned earlier, the use of <b>Raster</b> objects is completely new to 
this lesson.</p>
<p>Unlike some of the other image-filtering classes in the Java 2D API that can 
operate either on <b>BufferedImage</b> objects or on <b>Raster</b> objects, the
<b>BandCombineOp</b> filter can operate only on <b>Raster</b> objects.</p>
<p><font color="#ff0000"><b>Image-filtering <a name="methodology">methodology</a></b></font></p>
<p>For the <b>BandCombineOp </b>class, the red, green, and blue values of each 
pixel are treated as a column matrix.&nbsp; A 1 is appended onto the end of each 
column matrix producing a set of four-element column matrices that represents 
all of the pixels in the input <b>Raster</b> object.&nbsp; <i>(Each pixel is 
represented by a four-element column matrix.)</i></p>
<p>Each pixel in the output <b>Raster</b> is produced by multiplying a 
user-specified 3x4 image-processing matrix by the 4x1 column matrix that represents 
the corresponding pixel in the input <b>Raster</b>.&nbsp; The same 3x4 processing 
matrix is applied to every input pixel.&nbsp; <i>(An example of the values in 
such a 3x4 image-processing 
matrix is shown in the bottom of <a href="#Figure_1">Figure 1</a>.)</i></p>
<p>This makes it possible to cause the intensity or shade of each of the three 
colors <i>(red, green, and blue)</i> in each pixel of the output <b>Raster</b> 
to be a function of the combined intensities of all three colors of the 
corresponding pixel in the input <b>Raster</b>, <i>(plus a constant that is 
equal to the rightmost value in the corresponding row of the image-processing matrix)</i>.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Interesting visual effects.</b><br />
  On the other hand, allowing the overflow to occur can lead to some 
	interesting visual effects, as illustrated in <a href="#Figure_10">Figure 10</a>.</td></tr></table>
</td>
</tr>
</table>

<font color="#ff0000"><b>Potential arithmetic overflow</b></font></p>
<p>It is unclear in the documentation what happens to the output color value if 
the value resulting from the matrix multiplication and the addition of the 
constant falls outside the range from 0 to 255.&nbsp; However, observation of the 
results indicates that rather than clipping the value to force it to be within 
the range from 0 to 255, the value is allowed to overflow and become corrupt.&nbsp;
<i>(See <a href="#Figure_6">Figure 6</a>.)</i> 
Therefore, care must be exercised to avoid such overflow when setting the 
multiplicative values in the processing matrix.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Limited knowledge of art.</b><br />
  Given my limited knowledge of art, I will simply have to take the author's word 
on this.</td></tr></table>
</td>
</tr>
</table>

<font color="#ff0000"><b>A variety of interesting effects</b></font></p>
<p>This processing approach can lead to a variety of interesting effects.&nbsp; One
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
author</a> says that this class can be used to create
<a href="http://www.angelfire.com/co/artgeometry/">cubist-style</a> images <i>
(see <a href="#Figure_10">Figure 10</a>)</i>.</p>
<p><font color="#ff0000"><b>Color inversion</b></font></p>
<p>As with some of the other image-filtering classes in the Java 2D API, the<b> 
BandCombineOp </b>class can easily be used to invert any or all of the colors in 
an image, producing an output such as that shown in the bottom panel of 
<a name="Figure_2" href="#Figure_2">Figure 
2</a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458b01.jpg" width="335" height="685"><br></pre>
      <pre><b><a href="#Figure_2">Figure 2</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>All three colors were inverted in <a href="#Figure_2">Figure 2</a>.&nbsp; In addition, <a href="#Figure_2">Figure 2</a> 
illustrates the extraction and processing of a <b>Raster</b> object that is 300 
pixels on each side.&nbsp; The raster was extracted from the original image such 
that the upper-left corner of the raster matches a pixel at a horizontal 
coordinate of 24 and a vertical coordinate of 30 in the original image.</p>
<p><font color="#FF0000"><b>The user input data</b></font></p>
<p>The user input data that was used to process this image is shown in 
<a name="Figure_3"><a href="#Figure_3">Figure 3</a></a>.</p>
<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458b02.jpg" width="465" height="229"><br></pre>
      <pre><b><a href="#Figure_3">Figure 3</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Figure_3">Figure 3</a> is a screen shot of the program GUI with the top portion cropped off 
to save space.</p>
<p><font color="#FF0000"><b>The RECTANGLE text fields</b></font></p>
<p>The values shown in the four RECTANGLE text fields in <a href="#Figure_3">Figure 3</a> specify the 
location and size of the extracted <b>Raster</b> object described above.</p>
<p><font color="#FF0000"><b>The MATRIX text fields</b></font></p>
<p>The values in the twelve MATRIX text fields cause the red, green, and blue 
color values for each output pixel to be 255 minus the color value for the 
corresponding input pixel.&nbsp; You have learned in earlier lessons that this 
is the arithmetic process that can be used to invert the colors in an image.</p>
<p><font color="#ff0000"><b>Conversion to gray</b></font></p>
<p><a href="#Figure_4">Figure 4</a> shows the result of causing the red, green, and blue color values of 
each output pixel to be the average of all three color values of the 
corresponding input pixel.&nbsp; When all three color values for a pixel have 
the same value, the rendered color of the pixel is some shade of gray ranging 
from black to <a name="Figure_4">white</a>.</p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458c01.jpg" width="335" height="715"><br></pre>
      <pre><b><a href="#Figure_4">Figure 4</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The user input data</b></font></p>
<p>The user input values used to produce the gray image in <a href="#Figure_4">Figure 4</a> are shown in the 
screen shot of the GUI in <a name="Figure_5"><a href="#Figure_5">Figure 5</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458c02.jpg" width="469" height="230"><br></pre>
      <pre><b><a href="#Figure_5">Figure 5</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In this case, each of the three color values in each output pixel is the sum of one 
third of the red, green, and blue color values for the corresponding input 
pixel.</p>
<p><font color="#ff0000"><b>Arithmetic overflow</b></font></p>
<p><a href="#Figure_6">Figure 6</a> shows the same thing as <a href="#Figure_4">Figure 4</a>, except that each input color value 
in <a href="#Figure_6">Figure 6</a> was multiplied by 0.5 <i>(instead of 0.33333)</i> before adding them 
together to produce the color values for the output <a name="Figure_6">pixel</a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458d01.jpg" width="335" height="715"><br></pre>
      <pre><b><a href="#Figure_6">Figure 6</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The user input data</b></font></p>
<p>The user input values that produced <a href="#Figure_6">Figure 6</a> are shown in <a name="Figure_7"><a href="#Figure_7">Figure 7</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458d02.jpg" width="468" height="229"><br></pre>
      <pre><b><a href="#Figure_7">Figure 7</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, this image-processing matrix caused the overall output image in <a href="#Figure_6">Figure 6</a> to be 
somewhat brighter than the output image in <a href="#Figure_4">Figure 4</a>.</p>
<p>As you can also see, this resulted in arithmetic overflow for those output 
color values that exceeded a value of 255.&nbsp; As a result, light gray areas in 
<a href="#Figure_4">Figure 4</a> became black or dark gray areas, often outlined with white, in <a href="#Figure_6">Figure 6</a>.</p>
<p><font color="#FF0000"><b>A gray negative</b></font></p>
<p>The image in <a href="#Figure_4">Figure 4</a> is very similar to an old black and white photograph.</p>
<p>If you use an image-processing matrix that causes each output pixel color 
value to be the average of the corresponding input pixel color values <i>(as in 
<a href="#Figure_4">Figure 4</a>)</i>, and also 
invert the colors in the output, the resulting image is very similar to the <i>
negative</i> film from an old black and white photograph.&nbsp; This is 
illustrated by the output image in <a href="#Figure_8">Figure 8</a>.&nbsp; Whereas <a href="#Figure_4">Figure 4</a> is the <i>
positive</i>, <a href="#Figure_8">Figure 8</a> is the <i><a name="Figure_8">negative</a></i>.</p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458f01.jpg" width="335" height="715"><br></pre>
      <pre><b><a href="#Figure_8">Figure 8</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The user input data</b></font></p>
<p><a href="#Figure_9">Figure 9</a> shows the image-processing matrix that was used to produce the 
output image in <a name="Figure_9"><a href="#Figure_8">Figure 8</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458f02.jpg" width="468" height="229"><br></pre>
      <pre><b><a href="#Figure_9">Figure 9</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you compare <a href="#Figure_8">Figure 8</a> with <a href="#Figure_4">Figure 4</a>, you should be able to easily see the 
difference between the <i>positive</i> version in <a href="#Figure_4">Figure 4</a> and the <i>negative</i> 
version in <a href="#Figure_8">Figure 8</a>.</p>

<p><font color="#FF0000"><b>Now for some computer-generated artwork</b></font></p>
<p>For whatever it is worth, if I interpreted the previously-referenced
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
article</a> correctly, the output shown in <a href="#Figure_10">Figure 10</a> is a <i>cubist-style</i> image.&nbsp; 
<i>(At 
least, it was produced using the same processing matrix as the one given in 
<a name="Figure_10">that</a>
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
article</a>.)</i></p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458e01.jpg" width="335" height="715"><br></pre>
      <pre><b><a href="#Figure_10">Figure 10</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The image-processing matrix</b></font></p>
<p>The image-processing matrix that produced the output image in <a href="#Figure_10">Figure 10</a> is 
shown in <a name="Figure_11"><a href="#Figure_11">Figure 11</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java458e02.jpg" width="469" height="227"><br></pre>
      <pre><b><a href="#Figure_11">Figure 11</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>However, as I mentioned earlier, given my limited knowledge of art, I will 
simply have to take the
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
author's</a> word that this is a <i>cubist-style</i> image.&nbsp; Whatever it is, it 
illustrates that it is possible to use the <b>BandCombineOp</b> class to produce 
some weird and interesting effects.</p>
<p>Now let's see some code.</p>

<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
<font color="#FF0000"><b>The program named ImgMod41</b></font><p>In this program, I will explain the behavior of a program named <b>
ImgMod41.&nbsp;
</b>A complete listing of the program is provided in <a href="#Listing_14">Listing 14</a> near the end of 
the lesson.</p>
<p><font color="#FF0000"><b>Purpose</b></font></p>
<p>The purpose of this program is to illustrate the use of the <b>BandCombineOp</b> 
image-filtering class of the Java 2D API.&nbsp; <i>(See general comments in the 
class named <b>ImgMod038</b> that I explained in the earlier lesson entitled 
&quot;Using the Java 2D LookupOp Filter Class to Process Images&quot;</i> <i>(see
<a href="#References">References</a>).&nbsp; Those 
comments apply to 
this program also.)</i></p>
<p><font color="#FF0000"><b>Compatible with ImgMod05</b></font></p>
<p>The program named <b>ImgMod41</b> is compatible with 
the use of the framework program named <b>ImgMod05</b>.&nbsp; In other words, <b>ImgMod41</b> 
can be run under the control of <b>ImgMod05</b>.</p>
<p>The framework 
program named <b>ImgMod05</b> displays the original and the filtered images as 
shown in the top and bottom panels of <a href="#Figure_2">Figure 2</a>.&nbsp; <b>ImgMod05</b> also writes the 
filtered image into an output file 
in JPEG format.&nbsp; The name of the output file is <b>junk.jpg</b> and it is 
written into the current directory.</p>
<p><font color="#FF0000"><b>Running the program</b></font></p>
<p>Enter the following at the command line to run this program:</p>
<p><pre><b>java ImgMod05 ImgMod41 ImageFileName</b></pre></p>
<p>If the program is unable to load the image file within ten seconds, it will 
abort with an error message.</p>
<p><font color="#FF0000"><b>A user-input GUI</b></font></p>
<p>Image processing programs that run under the control of <b>ImgMod05</b> may provide a GUI for user 
data input.&nbsp; This makes it possible for the user to modify the behavior of the image-processing method each time the <b>Replot</b> button is clicked.</p>
<p>The GUI 
that is provided by this program is shown in <a href="#Figure_1">Figure 1</a>.&nbsp; This program GUI 
provides:</p>
<ul>
	<li>User 
instructions.</li>
	<li><a name="rectangle">Text</a> fields used to specify the upper-left corner, the width, and 
the height of a rectangle that is used to extract a <b>Raster</b>.</li>
	<li><a name="MatrixValues">Text</a> fields used to specify the values in a 3x4 
	image-processing matrix having three rows and four columns.</li>
</ul>
<p><font color="#FF0000"><b>Operates only on Raster objects</b></font></p>
<p>As explained <a href="#Raster_objects">earlier</a>, the <b>BandCombineOp</b> filter can only 
operate on <b>Raster</b> objects.&nbsp; <i>(It cannot operate directly on <b>
BufferedImage</b> objects.)</i>&nbsp; The <a href="#rectangle">rectangle</a> 
described above is used to extract a rectangular <b>Raster</b> object from the original image.</p>
<p><font color="#FF0000"><b>Initialization</b></font></p>
<p>The rectangle values are initialized so 
that the rectangle is the same size as the image and overlays the entire image.&nbsp; In 
other words, the initial rectangle contains the complete image.</p>
<p>The <a href="#MatrixValues">matrix values</a> described above are 
initialized so as to simply pass the input image through to the output without 
modification.</p>
<p><font color="#ff0000"><b>Image-filtering methodology</b></font></p>
<p>I explained the image-filtering methodology involving the multiplication of 
matrices <a href="#methodology">earlier</a>.</p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>This program was tested 
using J2SE 5.0 under WinXP.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>I will explain this program in fragments.&nbsp; A complete listing of the 
program is provided in <a href="#Listing_14">Listing 14</a>.</p>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The class definition begins in <a name="Listing_1"><a href="#Listing_1">Listing 1</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod41 extends Frame implements ImgIntfc05{
  
  //Components used to construct the main panel.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel mainPanel = new Panel();//main control panel
  
  //Text fields for specifying the Rectangle object values.
  TextField rectXcoorField = new TextField("0");
  TextField rectYcoorField = new TextField("0");
  TextField rectWidthField = new TextField("0");
  TextField rectHeightField = new TextField("0");
  
  //Text fields for specifying the matrix values.
  //Top row
  TextField matrix00Field = new TextField("1.0");
  TextField matrix01Field = new TextField("0.0");
  TextField matrix02Field = new TextField("0.0");
  TextField matrix03Field = new TextField("0.0");

  //Middle row  
  TextField matrix10Field = new TextField("0.0");
  TextField matrix11Field = new TextField("1.0");
  TextField matrix12Field = new TextField("0.0");
  TextField matrix13Field = new TextField("0.0");
  
  //Bottom row
  TextField matrix20Field = new TextField("0.0");
  TextField matrix21Field = new TextField("0.0");
  TextField matrix22Field = new TextField("1.0");
  TextField matrix23Field = new TextField("0.0");
  
  //The following Label is used to notify of data entry
  // errors.
  String okMessage = "No data entry errors detected.";
  Label errorMsg = new Label(okMessage);<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_1">Listing 1</a> is straightforward and should not require further 
explanation beyond the embedded comments.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor is shown in its entirety in <a name="Listing_2"><a href="#Listing_2">Listing 2</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  ImgMod41(){//constructor
  
    constructMainPanel();
    add(mainPanel);

    setTitle("Copyright 2006, R.G.Baldwin");
    setBounds(555,0,470,600);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor<br><br><b><font face="Courier New,Courier"><a href="#Listing_2">Listing 2</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is the primary constructor.&nbsp; It calls another method to actually construct the main panel so as to separate the construction of the GUI into easily understandable units.</p>
<p><font color="#FF0000"><b>The method named constructMainPanel</b></font></p>
<p>The method named <b>constructMainPanel</b> is shown in its entirety in 
<a href="#Listing_3">Listing 3</a>.&nbsp;&nbsp;&nbsp; This method constructs the main GUI panel <i>
(shown in <a href="#Figure_1">Figure 1</a>)</i> containing all of the controls.&nbsp; This method is called from the primary 
constructor in <a name="Listing_3"><a href="#Listing_2">Listing 2</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructMainPanel(){
    mainPanel.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the panel.
    // This text appears in a disabled text area at the
    // top of the panel.
    String text ="COMBINING COLOR BAND DATA\n"
      + "This program illustrates the use of the "
      + "BandCombineOp filter class of the Java 2D "
      + "API.\n\n"
      + "Specify the coordinates of the upper-left corner "
      + "along with the width and the height of a "
      + "rectangle that either exactly overlays or fits "
      + "inside of the original image.  This rectangle is "
      + "used to extract a rectangular Raster with a "
      + "corresponding location and size from the "
      + "image.\n\n"
      + "Specify the twelve values in a 3x4 processing "
      + "matrix and then click the Replot button to "
      + "process the image.\n\n"
      + "The initial width and height values match the "
      + "size of the image.  Set the width value to 0 and "
      + "click the Replot button to recover the width and "
      + "height of the image.\n\n"
      + "The red, green, and blue values from each input "
      + "pixel plus a value of 1 is used to construct a "
      + "1x4 column matrix that represents each input "
      + "pixel.\n\n"
      + "Each output pixel is produced by multiplying the "
      + "1x4 column matrix representing each input pixel "
      + "by the 3x4 processing matrix.\n\n"
      + "Apparently output color values greater than 255 "
      + "or less than 0 simply result in corrupt values "
      + "in the output.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,22,1,
                                 TextArea.SCROLLBARS_NONE);
    mainPanel.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the Center
    // of the main panel.
    Panel controlPanel = new Panel();
    controlPanel.setLayout(new GridLayout(8,4));
    
    //Add a row of labels
    controlPanel.add(new Label("RECTANGLE"));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    
    //Add another row of labels
    controlPanel.add(new Label("X-Coordinate"));
    controlPanel.add(new Label("Y-Coordinate"));
    controlPanel.add(new Label("Width"));
    controlPanel.add(new Label("Height"));
    
    //Add the text fields for the rectangle
    controlPanel.add(rectXcoorField);
    controlPanel.add(rectYcoorField);
    controlPanel.add(rectWidthField);
    controlPanel.add(rectHeightField);
    
    //Add another row of labels
    controlPanel.add(new Label("MATRIX"));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    
    //Add another row of labels
    controlPanel.add(new Label("Red multiplier"));
    controlPanel.add(new Label("Green multiplier"));
    controlPanel.add(new Label("Blue multiplier"));
    controlPanel.add(new Label("Additive constant"));
    
    //Add top row of matix text fields
    controlPanel.add(matrix00Field);
    controlPanel.add(matrix01Field);
    controlPanel.add(matrix02Field);
    controlPanel.add(matrix03Field);
    
    //Add middle row of matrix text fields
    controlPanel.add(matrix10Field);
    controlPanel.add(matrix11Field);
    controlPanel.add(matrix12Field);
    controlPanel.add(matrix13Field);
    
    //Add bottom row of matrix text fields
    controlPanel.add(matrix20Field);
    controlPanel.add(matrix21Field);
    controlPanel.add(matrix22Field);
    controlPanel.add(matrix23Field);

    mainPanel.add(controlPanel,BorderLayout.CENTER);
    
    //Add the errorMsg
    mainPanel.add(errorMsg,BorderLayout.SOUTH);
    errorMsg.setBackground(Color.GREEN);
  }//end constructMainPanel<br><br><b><font face="Courier New,Courier"><a href="#Listing_3">Listing 3</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although somewhat long and tedious, the code in <a href="#Listing_3">Listing 3</a> is straightforward.&nbsp; 
If you use <a href="#Figure_1">Figure 1</a> as a guide, you should have no difficulty following the code 
in <a href="#Listing_3">Listing 3</a>.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The <b>processImg</b> method is shown in its entirety in <a href="#Listing_4">Listing 4</a>.&nbsp; 
This method must be defined to implement the <b>ImgIntfc05</b> interface, which 
is a requirement for compatibility with the framework program named <b>ImgMod05</b>.</p>
<p>The <b>processImg</b> method is called by the framework program named <b>ImgMod05</b>.&nbsp; 
Note that this method, in turn, calls the method named <b><a name="Listing_4">processMainPanel</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public BufferedImage processImg(BufferedImage theImage){
    
    BufferedImage outputImage = processMainPanel(theImage);

    return outputImage;
  }//end processImg<br><br><b><font face="Courier New,Courier"><a href="#Listing_4">Listing 4</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The method named processMainPanel</b></font></p>
<p>This method is really the heart of the image-processing program named <b>
ImgMod41</b>.&nbsp; The method begins in <a name="Listing_5"><a href="#Listing_5">Listing 5</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  BufferedImage processMainPanel(BufferedImage theImage){
    
    //Reset the error message to the default.
    errorMsg.setText(okMessage);
    errorMsg.setBackground(Color.GREEN);<br><br><b><font face="Courier New,Courier"><a href="#Listing_5">Listing 5</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method uses the <b>BandCombineOp</b> image-filtering class to process 
the image according to the rectangle and matrix values 
provided by the user via the program GUI shown in <a href="#Figure_1">Figure 1</a>.</p>
<p>The method is called from within the method named <b>processImg</b> in 
<a href="#Listing_4">Listing 4</a>.</p>
<p>The code in <a href="#Listing_5">Listing 5</a> initializes the error panel <i>
(shown in green in <a href="#Figure_1">Figure 1</a>)</i> 
to its default condition.</p>
<p><font color="#FF0000"><b>Initialize the rectangle location and size</b></font></p>
<p><a href="#Listing_6">Listing 6</a> initializes the contents of the text fields that specify the 
rectangle so as to include the entire image within the <a name="Listing_6">rectangle</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    if((rectWidthField.getText().equals("0")) 
               || (rectHeightField.getText().equals("0"))){
      rectWidthField.setText("" +theImage.getWidth());
      rectHeightField.setText("" + theImage.getHeight());
    }//end if<br><br><b><font face="Courier New,Courier"><a href="#Listing_6">Listing 6</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This initialization is performed only if either the width or height text 
fields contain a 0, which is the case at startup.&nbsp; These values can later 
be modified by the user.</p>
<blockquote>
	<p><i>(Also, for convenience, the user can later enter a 0 for 
the x-coordinate, the y-coordinate, and the width and then click the <b>Replot</b> to 
	reset the rectangle values to the original image size.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Get the contents of the rectangle fields</b></font></p>
<p><a href="#Listing_7">Listing 7</a> gets the contents of the rectangle fields, performing some tests to 
confirm that the values are <a name="Listing_7">valid</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    int rectXcoor,rectYcoor,rectWidth,rectHeight;
    try{
      rectXcoor = 
                Integer.parseInt(rectXcoorField.getText());
      rectYcoor = 
                Integer.parseInt(rectYcoorField.getText());
      rectWidth = 
                Integer.parseInt(rectWidthField.getText());
      rectHeight = 
               Integer.parseInt(rectHeightField.getText());
    }catch(java.lang.NumberFormatException e){
      //Bad data in the rectangle fields.  Process a 1x1
      // rectangle so that it will be obvious to the user
      // that there is a problem.
      rectXcoor = rectYcoor = rectWidth = rectHeight = 1;
      errorMsg.setText(
                      "Bad input data for the rectangle.");
      errorMsg.setBackground(Color.RED);
    }//end catch

    int imageWidth = theImage.getWidth();
    int imageHeight = theImage.getHeight();
    
    //Code to confirm that the rectangle falls inside the
    // image.
    if((rectXcoor &lt; 0)|| 
       (rectYcoor &lt; 0)|| 
       ((rectXcoor + rectWidth) &gt; imageWidth)|| 
       ((rectYcoor + rectHeight) &gt; imageHeight))
    {
      //The rectangle falls outside the image.  Process a
      // 1x1 rectangle so that it will be obvious to the
      // user that there is a problem.
      rectXcoor = rectYcoor = rectWidth = rectHeight = 1;
      errorMsg.setText(
                 "The rectangle falls outside the image.");
      errorMsg.setBackground(Color.RED);
    }//end if<br><br><b><font face="Courier New,Courier"><a href="#Listing_7">Listing 7</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If the data entered into the rectangle text fields cannot be parsed to 
produce values of type <b>int</b>, or the location and size of the rectangle is 
outside the bounds of the image, the green error panel at the bottom of <a href="#Figure_1">Figure 1</a> 
turns red and displays an error message.&nbsp; To correct the problem, simply 
enter valid data and click the <b>Replot</b> button again.</p>
<p><font color="#FF0000"><b>Get the image-processing matrix values</b></font></p>
<p><a href="#Listing_8">Listing 8</a> gets the values for the image-processing matrix from the twelve 
text fields at the bottom of <a href="#Figure_1" name="Listing_8">Figure 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    float matrix00,matrix01,matrix02,matrix03,matrix10,
          matrix11,matrix12,matrix13,matrix20,matrix21,
          matrix22,matrix23;
    try{
      matrix00 = Float.parseFloat(matrix00Field.getText());
      matrix01 = Float.parseFloat(matrix01Field.getText());
      matrix02 = Float.parseFloat(matrix02Field.getText());
      matrix03 = Float.parseFloat(matrix03Field.getText());
      matrix10 = Float.parseFloat(matrix10Field.getText());
      matrix11 = Float.parseFloat(matrix11Field.getText());
      matrix12 = Float.parseFloat(matrix12Field.getText());
      matrix13 = Float.parseFloat(matrix13Field.getText());
      matrix20 = Float.parseFloat(matrix20Field.getText());
      matrix21 = Float.parseFloat(matrix21Field.getText());
      matrix22 = Float.parseFloat(matrix22Field.getText());
      matrix23 = Float.parseFloat(matrix23Field.getText());
    }catch(java.lang.NumberFormatException e){
      //Bad input data for the matrix.  Cause the output
      // image to be black so that it will be obvious to
      // the user that there is a problem.
      matrix00 = matrix01 = matrix02 = matrix03 = 
      matrix10 = matrix11 = matrix12 = matrix13 = 
      matrix20 = matrix21 = matrix22 = matrix23 = 0.0f;
      errorMsg.setText("Bad input data for the matrix.");
      errorMsg.setBackground(Color.RED);
    }//end catch

    //Now populate the matrix
    float[][] matrix = 
                    {{matrix00,matrix01,matrix02,matrix03},
                     {matrix10,matrix11,matrix12,matrix13},
                     {matrix20,matrix21,matrix22,matrix23}
                    };<br><br><b><font face="Courier New,Courier"><a href="#Listing_8">Listing 8</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If the values entered by the user into the text fields can't be parsed to 
produce valid values of type <b>float</b>, the error panel in the bottom of 
<a href="#Figure_1">Figure 1</a> turns red and displays an error message.&nbsp; To correct the problem, 
simply correct the entry in the text field and click the <b>Replot</b> button.</p>
<p><font color="#FF0000"><b>Set up the matrix array</b></font></p>
<p>Once the values have been fetched from the text fields to produce values of 
type <b>float</b>, the code in <a href="#Listing_8">Listing 8</a> 
uses those values to create and populate a 2D array object, which will be used 
later in <a href="#Listing_10">Listing 10</a> to create the image-filtering object.</p>
<p><font color="#FF0000"><b>Get the image data in a Raster object</b></font></p>
<p><a href="#Listing_9">Listing 9</a> invokes the method named <b>getData</b> on the<b> BufferedImage</b> 
object containing the image to extract and save a rectangular set of pixel data 
that matches the location and size of the <a name="Listing_9">rectangle</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Raster inputRaster = theImage.<b>getData</b>(new Rectangle(
                rectXcoor,rectYcoor,rectWidth,rectHeight));<br><br><b><font face="Courier New,Courier"><a href="#Listing_9">Listing 9</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>According to Sun, the <b>getData</b> method <i>&quot;Returns the image as one 
large tile.&quot;</i>&nbsp; This <b>Raster</b> object will be used later in
<a href="#Listing_11">Listing 11</a> to create a 
destination raster for the filtered image.</p>
<p><font color="#FF0000"><b>Create the image-filtering object</b></font></p>
<p><a href="#Listing_10">Listing 10</a> instantiates a new image-filtering object of type <b>
<a name="Listing_10">BandCombineOp</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    BandCombineOp filterObj = 
                            new BandCombineOp(matrix,null);<br><br><b><font face="Courier New,Courier"><a href="#Listing_10">Listing 10</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first parameter to the constructor for the <b>BandCombineOp</b> class is 
the image-processing matrix created in <a href="#Listing_8">Listing 8</a>.</p>
<p>The second parameter allows for the use of rendering hints, but that 
capability is not used in this program.</p>
<p><font color="#FF0000"><b>Create a destination Raster object</b></font></p>
<p><a href="#Listing_11">Listing 11</a> invokes the <b>createCompatibleDestRaster</b> method on the filter 
object to create a zeroed destination <b>Raster</b> with the correct size and number of 
color <a name="Listing_11">bands</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    WritableRaster destinationRaster = 
         filterObj.createCompatibleDestRaster(inputRaster);<br><br><b><font face="Courier New,Courier"><a href="#Listing_11">Listing 11</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The createCompatibleDestRaster method</b></font></p>
<p>This method returns a reference to an object of type <b>WritableRaster</b>, 
which is a subclass of <b>Raster</b>.&nbsp; Part of what Sun has to say about 
the <b>WritableRaster</b> class is shown in <a name="Figure_12"><a href="#Figure_12">Figure 12</a></a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      This class extends <b>Raster</b> to provide pixel writing capabilities. 
		Refer to the class comment for <b>Raster</b> for descriptions of how a
		<b>Raster</b> stores pixels.
		<p>The constructors of this class are protected. To instantiate a <b>
		WritableRaster</b>, use one of the <b>createWritableRaster</b> factory 
		methods in the <b>Raster</b> class. <br></p>
      <pre><b><a href="#Figure_12">Figure 12</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Obviously, it is also possible to create a <b>WritableRaster</b> object by 
invoking the <b>createCompatibleDestRaster</b> method of the <b>BandCombineOp</b> 
class as was done in <a href="#Listing_11">Listing 11</a>.</p>
<p><font color="#FF0000"><b>Apply the filter to the image</b></font></p>
<p><a href="#Listing_12">Listing 12</a> applies the filter to the raster that contains the image and 
deposits the filtered image in the destination <a name="Listing_12">raster</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    filterObj.filter(inputRaster,destinationRaster);<br><br><b><font face="Courier New,Courier"><a href="#Listing_12">Listing 12</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Return the filtered image</b></font></p>
<p><a href="#Listing_13">Listing 13</a> converts the destination raster to a <b>BufferedImage</b> object and 
returns a reference to the <b>BufferedImage</b> <a name="Listing_13">object</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    return new BufferedImage(theImage.getColorModel(),
                             destinationRaster,
                             false,
                             null);

  }//end processMainPanel

}//end class ImgMod41<br><br><b><font face="Courier New,Courier"><a href="#Listing_13">Listing 13</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first parameter causes the <b>ColorModel</b> for the output image to be 
the same as the <b>ColorModel</b> for the input image.&nbsp; The second 
parameter is a reference to the <b>WritableRaster</b> object that contains the 
filtered image.</p>
<p>The third parameter indicates that the color values have not been 
pre-multiplied by the alpha values.&nbsp; The fourth parameter allows for the 
inclusion of some properties in a <b>Hashtable</b> object.&nbsp; <i>(I will 
leave it as an exercise for the reader to investigate and understand the 
meaning and purpose of the third and fourth parameters.)</i></p>
<p><font color="#FF0000"><b>End of the method and end of the program</b></font></p>
<p><a href="#Listing_13">Listing 13</a> also signals the end of the <b>processMainPanel</b> method and the 
end of the program named <b>ImgMod41</b>.<br>
</p>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code from <a href="#Listing_14">Listing 14</a> into your text
editor.&nbsp; Compile the code and execute it.&nbsp; Experiment with it, making
changes, and observing the results of your changes. </p>
<p>Remember, you will also need to compile the code for the framework program 
named <b>ImgMod05</b> and the interface named <b>ImgIntfc05</b>.&nbsp; You will find 
that source code in the earlier lesson entitled &quot;A Framework for 
Experimenting with Java 2D Image-Processing Filters&quot; <i>(see
<a href="#References">References</a>)</i>.</p>
<p>You will also need one or more JPEG, GIF, PNG, or BMP image files to 
experiment with.&nbsp; You should have no difficulty finding such files at a variety 
of locations on the web.&nbsp; I recommend that you stick with relatively small 
images so that both the original image and the processed image will fit in the 
vertical space on your screen in the format shown in <a href="#Figure_2">Figure 2</a>.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I provided and explained an image-processing program named <b>
ImgMod41</b> that is compatible with the framework program named <b>ImgMod05</b>.</p>
<p>The purpose of this program is to show you how to write such programs, and 
also to illustrate a variety of different uses for the <b>BandCombineOp</b> 
class of the Java 2D API.</p>
<p>I also showed you how to extract a <b>Raster</b> object from a <b>
BufferedImage</b>, how to filter the raster, and how to convert the filtered 
result back into a <b>BufferedImage.</b></p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons in this series will teach you how to use the following 
image-filtering classes from the Java 2D API: </p>
<ul>
	<li><b>ConvolveOp</b> </li>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b></li>
</ul>
<h2 align="center"><a name="References">References</a></h2>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight</li>
	<li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</li>
	<li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion</li>
	<li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java</li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1</li>
	<li><a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2</li>
	<li><a href="http://www.developer.com/java/other/article.php/3640776">416</a> 
	Processing Image Pixels, An Improved Image-Processing Framework in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3645761">450</a> 
	A Framework for Experimenting with Java 2D Image-Processing Filters</li>
	<li><a href="http://www.developer.com/java/other/article.php/3654171">452</a> 
	Using the Java 2D LookupOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3670696">454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3681466">456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listing</h2>
</center>
A complete listing of the program discussed in this lesson is shown in 
<a href="#Listing_14" name="Listing_14">Listing 14</a>. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod41.java
Copyright 2006, R.G.Baldwin

The purpose of this class is to illustrate the use of the 
BandCombineOp image-filtering class of the Java 2D API.

See general comments in the class named ImgMod038.

This class is compatible with the use of the framework
program named ImgMod05.

The framework program named ImgMod05 displays the original
and the modified images.  It also writes the modified image
into an output file in JPEG format.  The name of the output
file is junk.jpg and it is written into the current 
directory.

Image processing programs such as this one may provide a 
GUI for data input making it possible for the user to 
modify the behavior of the image processing method each 
time the Replot button is clicked.  Such a GUI is provided
for this program.

Enter the following at the command line to run this 
program:

java ImgMod05 ImgMod41 ImageFileName

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

This program creates a GUI containing:

User instructions
Text fields used to specify the upper-left corner, the
 width, and the height of a rectangle.
Text fields used to specify the values in a 3x4 processing
 matrix having three rows and four columns.

Unlike some of the other image-filtering classes in the 
Java 2D API that can operate either directly on 
BufferedImage objects or on Raster objects, the 
BandCombineOp filter can only operate on Raster objects.   

The rectangle is used to extract a rectangular Raster 
object from the original image.

The rectangle values are initialized so that the rectangle 
is the same size as the image and overlays the entire 
image.  In other words, the rectangle contains the complete
image.

The matrix values are initialized so as to simply pass the 
input image through to the output without modification..

The red, green, and blue values of each pixel are treated 
as a column matrix.  A 1 is appended onto the end of the 
column matrix producing a set of four-element column 
matrices that represents each pixel in the input Raster 
object.

Each pixel in the output Raster is produced by multiplying 
the 3x4 processing matrix by the 4x1 column matrix that 
represents the corresponding pixel in the input Raster.

This makes it possible to cause the intensity of each color
in each pixel of the output Raster to be a function of the 
intensities of all three colors of the corresponding pixel 
in the input Raster, plus a constant that is equal to the 
rightmost value in the corresponding row of the processing 
matrix.

It is unclear in the documentation what happens to the 
output color value if the value resulting from the matrix
multiplication falls outside the range from 0 to 255.  
However, observation of the results suggests that rather 
than clipping the value to be within the range from 0 to 
255, the value is allowed to become corrupt.Therefore, care
must be exercised to avoid such overflow when setting the 
multiplicative values in the processing matrix.

Tested using J2SE 5.0 under WinXP.
**********************************************************/

import java.awt.image.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class ImgMod41 extends Frame implements ImgIntfc05{
  
  //Components used to construct the main panel.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel mainPanel = new Panel();//main control panel
  
  //Text fields for specifying the Rectangle object values.
  TextField rectXcoorField = new TextField("0");
  TextField rectYcoorField = new TextField("0");
  TextField rectWidthField = new TextField("0");
  TextField rectHeightField = new TextField("0");
  
  //Text fields for specifying the matrix values.
  //Top row
  TextField matrix00Field = new TextField("1.0");
  TextField matrix01Field = new TextField("0.0");
  TextField matrix02Field = new TextField("0.0");
  TextField matrix03Field = new TextField("0.0");

  //Middle row  
  TextField matrix10Field = new TextField("0.0");
  TextField matrix11Field = new TextField("1.0");
  TextField matrix12Field = new TextField("0.0");
  TextField matrix13Field = new TextField("0.0");
  
  //Bottom row
  TextField matrix20Field = new TextField("0.0");
  TextField matrix21Field = new TextField("0.0");
  TextField matrix22Field = new TextField("1.0");
  TextField matrix23Field = new TextField("0.0");
  
  //The following Label is used to notify of data entry
  // errors.
  String okMessage = "No data entry errors detected.";
  Label errorMsg = new Label(okMessage);

  //-----------------------------------------------------//
  
  //This is the primary constructor.  It calls another
  // method to construct the main panel so as to separate
  // the construction of the GUI into easily
  // understandable units.
  ImgMod41(){//constructor
  
    constructMainPanel();
    add(mainPanel);

    setTitle("Copyright 2006, R.G.Baldwin");
    setBounds(555,0,470,600);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor
  //-----------------------------------------------------//
  
  //This method constructs the main panel containing all of
  // the controls.  This method is called from the primary
  // constructor.
  void constructMainPanel(){
    mainPanel.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the panel.
    // This text appears in a disabled text area at the
    // top of the panel.
    String text ="COMBINING COLOR BAND DATA\n"
      + "This program illustrates the use of the "
      + "BandCombineOp filter class of the Java 2D "
      + "API.\n\n"
      + "Specify the coordinates of the upper-left corner "
      + "along with the width and the height of a "
      + "rectangle that either exactly overlays or fits "
      + "inside of the original image.  This rectangle is "
      + "used to extract a rectangular Raster with a "
      + "corresponding location and size from the "
      + "image.\n\n"
      + "Specify the twelve values in a 3x4 processing "
      + "matrix and then click the Replot button to "
      + "process the image.\n\n"
      + "The initial width and height values match the "
      + "size of the image.  Set the width value to 0 and "
      + "click the Replot button to recover the width and "
      + "height of the image.\n\n"
      + "The red, green, and blue values from each input "
      + "pixel plus a value of 1 is used to construct a "
      + "1x4 column matrix that represents each input "
      + "pixel.\n\n"
      + "Each output pixel is produced by multiplying the "
      + "1x4 column matrix representing each input pixel "
      + "by the 3x4 processing matrix.\n\n"
      + "Apparently output color values greater than 255 "
      + "or less than 0 simply result in corrupt values "
      + "in the output.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,22,1,
                                 TextArea.SCROLLBARS_NONE);
    mainPanel.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the Center
    // of the main panel.
    Panel controlPanel = new Panel();
    controlPanel.setLayout(new GridLayout(8,4));
    
    //Add a row of labels
    controlPanel.add(new Label("RECTANGLE"));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    
    //Add another row of labels
    controlPanel.add(new Label("X-Coordinate"));
    controlPanel.add(new Label("Y-Coordinate"));
    controlPanel.add(new Label("Width"));
    controlPanel.add(new Label("Height"));
    
    //Add the text fields for the rectangle
    controlPanel.add(rectXcoorField);
    controlPanel.add(rectYcoorField);
    controlPanel.add(rectWidthField);
    controlPanel.add(rectHeightField);
    
    //Add another row of labels
    controlPanel.add(new Label("MATRIX"));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    controlPanel.add(new Label(""));
    
    //Add another row of labels
    controlPanel.add(new Label("Red multiplier"));
    controlPanel.add(new Label("Green multiplier"));
    controlPanel.add(new Label("Blue multiplier"));
    controlPanel.add(new Label("Additive constant"));
    
    //Add top row of matix text fields
    controlPanel.add(matrix00Field);
    controlPanel.add(matrix01Field);
    controlPanel.add(matrix02Field);
    controlPanel.add(matrix03Field);
    
    //Add middle row of matrix text fields
    controlPanel.add(matrix10Field);
    controlPanel.add(matrix11Field);
    controlPanel.add(matrix12Field);
    controlPanel.add(matrix13Field);
    
    //Add bottom row of matrix text fields
    controlPanel.add(matrix20Field);
    controlPanel.add(matrix21Field);
    controlPanel.add(matrix22Field);
    controlPanel.add(matrix23Field);

    mainPanel.add(controlPanel,BorderLayout.CENTER);
    
    //Add the errorMsg
    mainPanel.add(errorMsg,BorderLayout.SOUTH);
    errorMsg.setBackground(Color.GREEN);
  }//end constructMainPanel
  //-----------------------------------------------------//

  //This method processes the image according to the
  // rectangle and matrix values provided by the user.
  //This method uses the BandCombineOp image-filtering
  // class to process the image.  The method is called from
  // within the method named processImg, which is the
  // primary image processing method in this program.  The
  // method named processImg is called by the framework
  // program named ImgMod05.
  BufferedImage processMainPanel(BufferedImage theImage){
    
    //Reset the error message to the default.
    errorMsg.setText(okMessage);
    errorMsg.setBackground(Color.GREEN);
    
    //Initialize the contents of the text fields that
    // specify the rectangle so as to include the entire
    // image within the rectangle.  This initialization is
    // performed only if either the width or height text
    // fields contain a 0, which is the case at startup.
    // These values can later be modified by the user.
    // Also, the user can enter a 0 for the width and
    // click Replot to get back to the original image size.
    if((rectWidthField.getText().equals("0")) 
               || (rectHeightField.getText().equals("0"))){
      rectWidthField.setText("" +theImage.getWidth());
      rectHeightField.setText("" + theImage.getHeight());
    }//end if
    
    //Get the contents of the rectangle fields.
    int rectXcoor,rectYcoor,rectWidth,rectHeight;
    try{
      rectXcoor = 
                Integer.parseInt(rectXcoorField.getText());
      rectYcoor = 
                Integer.parseInt(rectYcoorField.getText());
      rectWidth = 
                Integer.parseInt(rectWidthField.getText());
      rectHeight = 
               Integer.parseInt(rectHeightField.getText());
    }catch(java.lang.NumberFormatException e){
      //Bad data in the rectangle fields.  Process a 1x1
      // rectangle so that it will be obvious to the user
      // that there is a problem.
      rectXcoor = rectYcoor = rectWidth = rectHeight = 1;
      errorMsg.setText(
                      "Bad input data for the rectangle.");
      errorMsg.setBackground(Color.RED);
    }//end catch
    
    int imageWidth = theImage.getWidth();
    int imageHeight = theImage.getHeight();
    
    //Code to confirm that the rectangle falls inside the
    // image.
    if((rectXcoor &lt; 0)|| 
       (rectYcoor &lt; 0)|| 
       ((rectXcoor + rectWidth) &gt; imageWidth)|| 
       ((rectYcoor + rectHeight) &gt; imageHeight))
    {
      //The rectangle falls outside the image.  Process a
      // 1x1 rectangle so that it will be obvious to the
      // user that there is a problem.
      rectXcoor = rectYcoor = rectWidth = rectHeight = 1;
      errorMsg.setText(
                 "The rectangle falls outside the image.");
      errorMsg.setBackground(Color.RED);
    }//end if

    //Get the data from the text fields for the matrix.
    float matrix00,matrix01,matrix02,matrix03,matrix10,
          matrix11,matrix12,matrix13,matrix20,matrix21,
          matrix22,matrix23;
    try{
      matrix00 = Float.parseFloat(matrix00Field.getText());
      matrix01 = Float.parseFloat(matrix01Field.getText());
      matrix02 = Float.parseFloat(matrix02Field.getText());
      matrix03 = Float.parseFloat(matrix03Field.getText());
      matrix10 = Float.parseFloat(matrix10Field.getText());
      matrix11 = Float.parseFloat(matrix11Field.getText());
      matrix12 = Float.parseFloat(matrix12Field.getText());
      matrix13 = Float.parseFloat(matrix13Field.getText());
      matrix20 = Float.parseFloat(matrix20Field.getText());
      matrix21 = Float.parseFloat(matrix21Field.getText());
      matrix22 = Float.parseFloat(matrix22Field.getText());
      matrix23 = Float.parseFloat(matrix23Field.getText());
    }catch(java.lang.NumberFormatException e){
      //Bad input data for the matrix.  Cause the output
      // image to be black so that it will be obvious to
      // the user that there is a problem.
      matrix00 = matrix01 = matrix02 = matrix03 = 
      matrix10 = matrix11 = matrix12 = matrix13 = 
      matrix20 = matrix21 = matrix22 = matrix23 = 0.0f;
      errorMsg.setText("Bad input data for the matrix.");
      errorMsg.setBackground(Color.RED);
    }//end catch
    
    //Now populate the matrix
    float[][] matrix = 
                    {{matrix00,matrix01,matrix02,matrix03},
                     {matrix10,matrix11,matrix12,matrix13},
                     {matrix20,matrix21,matrix22,matrix23}
                    };
                    
    //Note:  Unlike some of the other filters in the Java
    // 2D API that can operate either directly on 
    // BufferedImage objects or on Raster objects, the
    // BandCombineOp filter can only operate on Raster
    // objects.
    
    //Get the Raster object that contains the image data
    // inside the specified Rectangle object.
    Raster inputRaster = theImage.getData(new Rectangle(
                rectXcoor,rectYcoor,rectWidth,rectHeight));
    
    //Create the filter object.  The second parameter
    // allows for specification of rendering hints.
    BandCombineOp filterObj = 
                            new BandCombineOp(matrix,null);
    
    //Create a zeroed destination Raster with the correct
    // size and number of bands.
    WritableRaster destinationRaster = 
         filterObj.createCompatibleDestRaster(inputRaster);
    
    //Apply the filter
    filterObj.filter(inputRaster,destinationRaster);
    
    //Convert the destination raster to a BufferedImage and
    // return it.  The first parameter causes the
    // ColorModel for the output image to be the same as
    // the ColorModel for the input image.  The third
    // parameter indicates that the color values have not
    // been premultiplied by the alpha values.  The fourth
    // parameter allows for the inclusion of some
    // properties in a Hashtable object.
    return new BufferedImage(theImage.getColorModel(),
                             destinationRaster,
                             false,
                             null);

  }//end processMainPanel
  //-----------------------------------------------------//

  //The following method must be defined to implement the
  // ImgIntfc05 interface.  It is called by the framework
  // program named ImgMod05.
  public BufferedImage processImg(BufferedImage theImage){
    
    BufferedImage outputImage = processMainPanel(theImage);

    return outputImage;
  }//end processImg
}//end class ImgMod41<br><br><b><font face="Courier New,Courier"><a href="#Listing_14">Listing 14</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<hr align="center" size="3" width="100%">
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java 2D image pixel framework filter&nbsp;BandCombineOp </p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
