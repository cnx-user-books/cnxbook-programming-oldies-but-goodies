<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
<h2>Java JAXP, Exposing a DOM Tree<br>
</h2>
<p style="font-style: italic;">Baldwin shows you how to write a program
to display a DOM tree on the screen in a format that is much easier to
interpret than raw XML code.
</p>
<p><b>Published:</b>&nbsp; December 16, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2204</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p><font color="#ff0000"><b>What is JAXP?</b></font><br>
</p>
<p>As the name implies, the Java API for XML Processing (JAXP) is an
API designed
to help you write programs for processing XML documents.&nbsp; JAXP is
very important for many reasons, not the least of which is the
fact that it is a critical part of the Java Web Services Developer Pack
(JWSDP).&nbsp; As you are probably already aware, web services is
expected by many to be a very important aspect of the Internet of the
future<br>
</p>
<p>This is the third lesson in a series designed to initially help you
understand how to use JAXP,
and to eventually help you understand how to use the JWSDP.</p>
<p>The first lesson was entitled <a
 href="http://www.developer.com/java/other/article.php/3099751">Java
API for XML Processing (JAXP), Getting Started</a>.&nbsp; The
previous lesson was entitled <a
 href="http://www.developer.com/xml/article.php/3113351">Getting
Started with Java JAXP and XSL Transformations (XSLT)</a>.<br>
</p>
<p><font color="#ff0000"><b>What is XML?</b></font></p>
XML is an acronym for the&nbsp;e<b>X</b>tensible <b>M</b>arkup <b>L</b>anguage.&nbsp;
I will not attempt to teach XML in this series of
tutorial lessons.&nbsp; Rather, I will assume that you already
understand
XML, and I will teach you how to use JAXP to write programs for
creating and processing XML documents.<br>
<br>
I have published numerous tutorial lessons on XML at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>&nbsp;and <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a></font>.&nbsp;
You may find it useful to refer to those lessons.&nbsp; In addition, I
provided
a review of the salient aspects of XML in the first lesson in this
series.&nbsp; From time to time, I will also provide background
information regarding XML in the lessons in this series.<br>
<br>
<b><font color="#ff0000">Viewing tip</font></b>
<p> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different listings and figures while
you are reading about them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes
they are difficult to locate there.&nbsp; You will find a consolidated
index at <font color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#ff0000"><b>A tree structure in memory</b></font><br>
</p>
<p>A DOM parser can be used to
create a tree structure in memory that represents an XML
document.&nbsp; In Java, that tree structure is encapsulated in an
object of the interface type <b>Document</b>.&nbsp; <b>Document</b>
and its superinterface <b>Node</b> declare numerous methods that may
be used to navigate, extract information from, modify, and otherwise
manipulate the DOM tree.&nbsp; As
is always the case, classes that implement <b>Document</b> must
provide concrete definitions of those methods.<br>
</p>
<p><font color="#ff0000"><b>Many operations are possible</b></font><br>
</p>
<p>Given an object of type <b>Document</b>, there are many
methods that
can be invoked on the object to perform a variety of operations.&nbsp;
For example, it is possible to move nodes from one location in the tree
to another location in the tree, thus rearranging the structure of the
XML document represented by the <b>Document</b> object.&nbsp; It is
also possible to delete nodes, and to insert new nodes.&nbsp; It is
also possible
to
recursively traverse the tree, extracting information about the nodes
along
the way.<br>
</p>
<p><font color="#ff0000"><b>I showed you ...</b></font><br>
</p>
<p>In the previous lesson on Java JAXP, I began by providing a brief
review of XSL and XSL Transformations (XSLT).<br>
</p>
<p>Then I showed you how to create an identity <b>Transformer</b>
object, and how to use that object to:<br>
</p>
<ul>
  <li>Display a DOM tree structure on the screen in XML format.</li>
  <li>Write the contents of a DOM tree structure into an output XML
file.</li>
</ul>
Following that, I showed you how to write exception handlers that
provide meaningful information in the event of errors and exceptions,
with particular emphasis on parser errors and exceptions.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">I will show you
...</span><br>
<p>In this lesson, I will show you how to write a program to display a
DOM tree on the screen in a format that is much easier to interpret
than raw XML code.&nbsp; I will explain two different versions of the
program.&nbsp; One version will simply identify text nodes in the
output tree.&nbsp; The other will display the value of text nodes in
the output tree.&nbsp; The first version will ignore attributes in the
output tree.&nbsp; The second version will include attributes in the
output tree.<br>
</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
The first program that I will discuss, named <span
 style="font-weight: bold;">DomTree01</span>, analyzes a DOM tree that
represents an XML document, and produces an output on the screen
similar to the tree shown in Figure 1.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>#document DOCUMENT_NODE<br>  A DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  processor PROCESSING_INSTRUCTION_NODE<br>  A ELEMENT_NODE<br>    Q ELEMENT_NODE<br>      #text TEXT_NODE<br>    B ELEMENT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>        #cdata-section CDATA_SECTION_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>      S ELEMENT_NODE<br>        #text TEXT_NODE<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>      S ELEMENT_NODE<br>        #text TEXT_NODE<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>        T ELEMENT_NODE<br>          #text TEXT_NODE<br>        B ELEMENT_NODE<br>          C ELEMENT_NODE<br>            #text TEXT_NODE<br>          D ELEMENT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>              G ELEMENT_NODE<br>                #text TEXT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>          C ELEMENT_NODE<br>            #text TEXT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>    B ELEMENT_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE</pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
The physical tree structure shown in Figure 1 represents the
corresponding XML document as a visual tree.&nbsp; As I discuss the
various parts of the XML document, you should be able to correlate
those parts of the document to the tree structure shown in Figure 1.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The sample XML
file named DomTree01.xml</span><br>
<br>
The tree structure in Figure 1 corresponds to an XML file named <span
 style="font-weight: bold;">DomTree01.xml</span>.&nbsp; As is often the
case, I will discuss the XML files and the programs in fragments.&nbsp;
A complete listing of <span style="font-weight: bold;">DomTree01.xml</span>
is shown in Listing 21 near the end of the lesson.&nbsp; Listing 1
shows the beginning of the XML file<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br><br>&lt;!DOCTYPE A [<br>&lt;!ELEMENT A (Q,B,B)*&gt;<br>&lt;!ELEMENT B (B | C | D | R | S | T)*&gt;<br>&lt;!ELEMENT C (#PCDATA)&gt;<br>&lt;!ELEMENT D (E | F)*&gt;<br>&lt;!ELEMENT E (#PCDATA | G)*&gt;<br>&lt;!ELEMENT F (#PCDATA)&gt;<br>&lt;!ELEMENT G (#PCDATA)&gt;<br>&lt;!ELEMENT Q (#PCDATA)&gt;<br>&lt;!ELEMENT R (#PCDATA)&gt;<br>&lt;!ELEMENT S (#PCDATA)&gt;<br>&lt;!ELEMENT T (#PCDATA)&gt;<br>]&gt;<br><br>&lt;!-- File DomTree01.xml<br>Copyright 2003 R. G. Baldwin<br>Used to test the program named<br>DomTree01.java<br>--&gt;<br><br>&lt;?xml-stylesheet type="text/xsl" <br>href="Dom03.xsl"?&gt;<br><br>&lt;?processor ProcInstr="Dummy"?&gt;<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The structure
of the XML file named DomTree01.xml</span><br>
<br>
That portion of the XML file shown in Listing 1 consists of five
items that are represented by the following nodes in the DOM tree:<br>
<ul>
  <li>A Document node</li>
  <ul>
    <li>A Document-Type node</li>
    <li>A Comment node</li>
    <li>A Processing Instruction node representing a stylesheet</li>
    <li>A Processing Instruction node representing a dummy processing
instruction</li>
  </ul>
</ul>
The last four node types in the above list represent nodes that are
children of the Document node.&nbsp; The Document node is the root of
the entire DOM tree, and all other nodes in the DOM tree are children
of the Document node.<br>
<br>
The five items are separated by blank lines in Listing 1, so you
should be able to correlate them visually with the five nodes in the
above list.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that although it is tempting to believe that the Document node
correlates with the XML declaration in the first line of Listing 1, the
XML declaration is not required, and the DOM tree will be rooted in a
Document node, even in the absence of an XML declaration.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The DOM tree
exposed</span><br>
<br>
Figure 2 shows a reproduction of the first five lines from Figure
1.&nbsp; Each line in Figure 2 represents a node in the DOM tree.&nbsp;
You should be able to correlate each line in Figure 2 with one
of the nodes in the above list, and also with one of the items in
Listing 1 <span style="font-style: italic;">(except for the
DOCUMENT_NODE for which there is no explicit item in Listing 1).</span><br>
<br>
The indentation in Figure 2 indicates that the last four lines in
Figure 2 represent nodes that are children of the node represented by
the Document node in the first line.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>#document DOCUMENT_NODE<br>  A DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  processor PROCESSING_INSTRUCTION_NODE<br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The prolog of
the XML document</span><br>
<br>
Listing 1 shows the <span style="font-style: italic;">prolog</span>
for this XML document, which includes everything prior to the start tag
for the root element.&nbsp; Figure 2 shows the DOM nodes associated
with the prolog.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The root
element in the XML document</span><br>
<br>
Listing 2 shows the XML code for the root element and the six nodes
following the root-element node in the DOM tree.&nbsp;
The XML code in Listing 2 produces the following node types in the DOM
tree, with the parent-child relationships shown.<br>
<ul>
  <li>An Element node named A, which is the root element node<br>
  </li>
  <ul>
    <li>An Element node named Q</li>
    <ul>
      <li>A Text node</li>
    </ul>
    <li>An Element node named B</li>
    <ul>
      <li>An Element node named C</li>
      <ul>
        <li>A Text node</li>
        <li>A CDATA Section node</li>
      </ul>
    </ul>
  </ul>
</ul>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;A&gt;<br>&lt;Q&gt;A Big Header&lt;/Q&gt;<br><br>&lt;B&gt;<br>&lt;C&gt;Level 0.  This is the beginning of a B.  <br>This text is in the Introduction section.<br>&lt;![CDATA[This is CDATA &lt; &gt; " &amp;]]&gt;&lt;/C&gt;<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A is a child of
the document root node</span><br>
<br>
Referring back to Figure 1, you can see that the Element node named A
is a child of the Document node,
which forms the root of the DOM tree.&nbsp; The node for element A is
the
<span style="font-style: italic;">root element node</span> for the DOM
tree, <span style="font-style: italic;">(which is different from the
root node for the DOM tree).</span>&nbsp; All of the data stored in an
XML
document is stored in the root element node and its children.<br>
<br>
Figure 3 shows a reproduction of the next seven lines from Figure 1,
showing the tree structure and the parent-child relationships among the
nodes.&nbsp; The nodes shown in Figure 3 correspond to the XML code in
Listing 2.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>  A ELEMENT_NODE<br>    Q ELEMENT_NODE<br>      #text TEXT_NODE<br>    B ELEMENT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>        #cdata-section CDATA_SECTION_NODE<br></pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Easier to
interpret</span><br>
<br>
Unless you have a lot of practice reading XML code, you may have
concluded
by now that the representations of the DOM tree in Figures 2, and 3 are
much easier to get your mind around than the raw XML shown in Listings
1 and 2.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Node types seen
thus far</span><br>
<br>
So far, we have seen the following types of nodes:<br>
<ul>
  <li>Document node</li>
  <li>Document-Type node</li>
  <li>Comment node</li>
  <li>Processing Instruction node</li>
  <li>Element node</li>
  <li>Text node<br>
  </li>
  <li>CDATA Section node</li>
</ul>
It will be useful at this point to provide a brief explanation for each
of
these node
types.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The Document
node and the XML declaration</span><br>
<br>
According to XML in a Nutshell by Harold and Means, which I recommend
as an excellent book,<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">"XML
documents should, (but do not have to) begin with an XML
declaration.&nbsp; The XML declaration looks like a processing
instruction with the name xml and version, standalone, and encoding
attributes.&nbsp; Technically, it's not a processing instruction
though, just the XML declaration; nothing more, nothing less."</span><br>
</div>
<br>
As I mentioned earlier, every XML DOM tree is rooted in a Document
node, even in the absence of an XML declaration.&nbsp; Apparently, the
DOM
tree does not contain a node that represents the XML declaration, and
the XML document doesn't contain any specific text that represents the
Document node.<br>
<br>
Although the XML declaration is used for
information purposes by a validating XML parser, if it is possible to
recover the XML declaration from the DOM tree, I don't know how to do
that at this time.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Document-Type
node</span><br>
<br>
A valid XML document contains a reference to a <span
 style="font-style: italic;">Document Type Declaration (DTD)</span> to
which the document should be compared for validation purposes.&nbsp;
The DTD can also be included in the XML document prolog, as is the case
in Listing 1.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(The
DTD in Listing 1 begins with &lt;!DOCTYPE and ends with ]&gt;)</span><br>
</div>
<br>
According to XML in a Nutshell,<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">"DTDs
are written in a formal syntax that explains precisely which elements
and entities may appear where in the document and what the elements'
contents and attributes are."</span><br>
</div>
<br>
For example, the DTD in Listing 1 states that the element named A must
contain the elements named Q, B, and B, in that order.&nbsp; I'm not
going to try to explain the rules for writing DTDs.&nbsp; There are
numerous tutorials on the Web that you can refer to in this regard.<br>
<br>
The DTD in Listing 1 produced the Document-Type node in the tree in
Figure 2.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(In
certain situations, a schema can be used for validation in place of a
DTD.)</span><br>
</div>
<br style="font-weight: bold; color: rgb(255, 0, 0);">
<span style="font-weight: bold; color: rgb(255, 0, 0);">Comment node</span><br>
<br>
A comment in XML means pretty much the same thing as a comment in
Java.&nbsp; XML comments are generally ignored by XML processors.&nbsp;
They are intended primarily for human consumption.<br>
<br>
Listing 1 contains an XML comment with the file name and some other
information.&nbsp; This comment produced the Comment node in the tree
of Figure 2.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Processing
Instruction node</span><br>
<br>
XML processing instructions begin with &lt;? and end with ?&gt;.&nbsp;
Processing instructions are intended to provide instructions to
processing programs that may be called upon to process an XML document.<br>
<br>
Listing 1 contains two separate processing instructions.&nbsp; The two
processing instructions gave rise to the two Processing Instruction
nodes in the tree in Figure 2.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Element node</span><br>
<br>
As you learned in the previous two lessons, XML syntax includes
elements, consisting of start tags, end tags, optional content, and
optional attributes.<br>
<br>
Listing 2 contains all or part of several elements.&nbsp; The elements
gave rise to the Element nodes in Figure 3.&nbsp; The text content of
the elements gave rise to the Text nodes in Figure 3.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that the actual text in this XML document is not intended to have any
meaning other than to constitute text nodes in the DOM tree for
illustration purposes.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Text node<br>
<br>
</span><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 0, 0);">When you include text as part or all of
the content of an XML element, each chunk of text gives rise to a text
node in the DOM tree.&nbsp; Figure 3 shows two text nodes produced by
the text content of the elements in Listing 2.</span></span><span
 style="font-weight: bold; color: rgb(255, 0, 0);"><br>
<br>
CDATA Section
node</span><br>
<br>
XML recognizes two kinds of text data, PCDATA and CDATA.&nbsp; PCDATA
stands for parsed character data.&nbsp; CDATA stands for character data.<br>
<br>
The primary difference between the two is as follows.&nbsp; PCDATA
cannot contain
certain characters such as left angle brackets (&lt;) and ampersands
(&amp;).&nbsp; The reason is that a left angle bracket would confuse
the parser, causing it to believe that it had encountered the first
character in a start or end tag.&nbsp; Therefore, if these characters
appear in
PCDATA, they must be represented by entities, such as &amp;lt;.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A CDATA section</span><br>
<br>
When a block of text is declared to be of type CDATA, it is
ignored by the parser.&nbsp; Therefore, it can contain any
characters <span style="font-style: italic;">(with the possible
exception of ]]).</span>&nbsp; A block of CDATA always begins with
&lt;![CDATA[.&nbsp; The block always ends with ]]&gt;.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that the periods in the above sentences are not parts of the CDATA
beginning and ending syntax.)</span><br>
</div>
<br>
Listing 2 contains a block of CDATA, which gave rise to the CDATA
Section node in Figure 3.<br>
<br>
Note that the Element node named C in Figure 3 has two children.&nbsp;
One child is a text node.&nbsp; The other child is a CDATA
Section node.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">An interesting
case involving whitespace</span><br>
<br>
I'm not going to bore you by discussing the entire XML document in this
level of detail.&nbsp; By now, you should be able to compare the XML in
Listing 21 with the DOM tree represented by Figure 1, and understand
how the XML code relates to the DOM tree,.<br>
<br>
However, there is one tricky aspect involving <span
 style="font-style: italic;">whitespace</span> that deserve a little
more
explanation.&nbsp; The DOM tree nodes shown in Figure 4 represent the
XML code shown in Listing 3.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>              G ELEMENT_NODE<br>                #text TEXT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE</pre>
      <pre><b>Figure 4</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Too many text
nodes</span><br>
<br>
I have colored the obvious text in Listing 3 green for emphasis.&nbsp;
At
first glance, it would appear that there are too many Text nodes
showing in Figure 4 to correspond to the text shown in Listing 3.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;E&gt;<span
 style="font-weight: bold; color: rgb(0, 153, 0);">First list item in E</span><br>&lt;G&gt;<span
 style="font-weight: bold; color: rgb(0, 153, 0);">Nested G text element</span>&lt;/G&gt;<br>&lt;/E&gt;<br>&lt;F&gt;<span
 style="font-weight: bold; color: rgb(0, 153, 0);">First list item in F</span>&lt;/F&gt;<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Another
representation of the DOM tree</span><br>
<br>
Figure 5 shows another representation of the DOM tree, similar to
Figure
4, except that the actual text belonging to each Text node is shown in
Figure 5.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>            E ELEMENT_NODE<br>              #text First list item in E<br><br>              G ELEMENT_NODE<br>                #text Nested G text element<br>              #text<br><br>            F ELEMENT_NODE<br>              #text First list item in F<br></pre>
      <pre><b>Figure 5</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
Note the blank lines in Figure 5.&nbsp; This is caused by newline
characters in the actual XML code in Listing 3.&nbsp; In particular,
there are two Text nodes belonging to the element named E.&nbsp; One of
those Text nodes appears before
the element named G and the other appears after the element named
G.&nbsp; The Text
node after the element named G was caused by the newline character
immediately following the end tag for the element named G.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Element E may
contain PCDATA</span><br>
<br>
This happens because of one line in the DTD shown in Listing 1 and
repeated below for convenience.<br>
<pre>&lt;!ELEMENT E (#PCDATA | G)*&gt;</pre>
This DTD statement says that the content for an element named E may
contain Text nodes (#PCDATA) and/or elements named G in any number and
in
any order.&nbsp; Thus, simple newline characters inserted into the XML
to make it easier to read were interpreted as Text nodes.&nbsp; This
gave rise to what appears to be extra Text nodes in Figure 4.<br>
<br>
That's probably enough talk.&nbsp; It's time to see some Java code.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The program
named DomTree01</span><br>
<br>
With the preceding discussion as background, I will now discuss the
program named <span style="font-weight: bold;">DomTree01</span>,
which was used to process the file named <span
 style="font-weight: bold;">DomTree01.xml</span>
and to produce the Dom tree representation shown in Figure 1.&nbsp; As
usual, I
will discuss the program in fragments.&nbsp; A complete listing of the
program is shown in Listing 20 near the end of the lesson.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Purpose and
limitations of the program</span><br>
<br>
This program produces a text-based output on the screen that represents
the DOM tree structure for an XML file.&nbsp; Note that although the
code was written to support these node types, the program was not
actually tested for the following node types:<br>
<ul>
  <li>DOCUMENT_FRAGMENT_NODE</li>
  <li>ENTITY_NODE</li>
  <li>ENTITY_REFERENCE_NODE</li>
  <li>NOTATION_NODE</li>
</ul>
Note also that this program does not display attributes.&nbsp; That
will be accomplished in the sample program named <span
 style="font-weight: bold;">DomTree02</span> to be discussed later in
this lesson.<br>
<br>
Also note that for simplicity, no effort was made to cause the program
to produce meaningful output in the event of errors and exceptions.<br>
<br>
The program was tested using Sun's SDK 1.4.2 under WinXP.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Overall program
structure</span><br>
<br>
This program consists of a single class with a <span
 style="font-weight: bold;">main</span> method that runs as a Java
application.&nbsp; Listing 4 shows the beginning of the class
definition and the beginning of the <span style="font-weight: bold;">main</span>
method.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class DomTree01{<br><br>  int indent = -1;//Indentation level for display<br><br>  public static void <span
 style="font-weight: bold;">main</span>(String argv[]){<br>    if (argv.length != 2){<br>      System.err.println(<br>        "usage: java DomTree01 fileIn validate");<br>      System.err.println(<br>        "validate = n for no, y for yes");<br>      System.exit(0);<br>    }//end if<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 4 is straightforward:<br>
<ul>
  <li>It declares and
initializes an instance variable that is used later for control of
indentation in the output display.</li>
  <li>It also provides usage instructions if the user
starts the program with the wrong number of command-line arguments.</li>
</ul>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Running the
program</span><br>
<br>
Two command-line parameters are required.&nbsp; The first parameter is
the path and file name of the file containing the XML document to be
processed.&nbsp; The second command-line parameter is either "y" or "n"
specifying whether or not the parser should attempt to validate the XML
document.<br>
<br style="font-style: italic;">
<div style="margin-left: 40px;"><span style="font-style: italic;">(If
the program is instructed to validate the document,
a DTD (or schema) must be
provided either inline or as a reference in the XML document.)</span><br>
</div>
<br>
<font color="#ff0000"><b>Steps for creating a Document object</b></font><br>
<br>
As you learned in an earlier lesson, three steps
are required to create a <b>Document</b> object:<br>
<ol>
  <li>Create a <b>DocumentBuilderFactory </b>object</li>
  <li>Use the&nbsp;<b>DocumentBuilderFactory </b>object to create a <b>DocumentBuilder
    </b>object</li>
  <li>Use the <b>parse</b> method of the <b>DocumentBuilder </b>object
to create a <b>Document</b> object</li>
</ol>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Create a
DocumentBuilderFactory object</span><br>
<br>
The first step in the above list is accomplished by the code in Listing
5..<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object setting<br>      // validating true or false based on user<br>      // input.<br>      if(argv[1].equals("n")){<br>        factory.setValidating(false);<br>      }else{<br>        factory.setValidating(true);<br>      }//end if/else<br><br>      factory.setNamespaceAware(false);<br><br>      //Set to ignore cosmetic white space<br>      // between elements.<br>      factory.<br>       setIgnoringElementContentWhitespace(true);<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
There is very little in Listing 5 that wasn't discussed in detail in
earlier lessons.&nbsp; About the only thing that is new is the
invocation of the setter method at the end of Listing 5 to cause the
parser to ignore cosmetic whitespace in the XML document.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Cosmetic
whitespace consists of spaces, tabs, newlines, etc., inserted into the
XML document between elements to make the document easier to read.)</span><br>
</div>
<br>
This wasn't discussed in the previous lessons because it only works
with a validating parser.&nbsp; The parsers used in the two previous
lessons were not validating parsers.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Create a
Document object</span><span
 style="font-weight: bold; color: rgb(255, 0, 0);"></span><br>
<br>
The remaining two steps required to create a <span
 style="font-weight: bold;">Document</span> object are accomplished in
Listing 6.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Get a DocumentBuilder (parser) object<br>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      Document document = builder.parse(<br>                              new File(argv[0]));<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 6 was also discussed in detail in the two previous
lessons, so I won't discuss that code further here.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Process the
Document object</span><br>
<br>
Code that is new to this lesson begins in Listing 7.&nbsp; The code in
Listing 7 instantiates a new object of the program class and invokes
the <span style="font-weight: bold;">processNode</span> method on that
object, passing the <span style="font-weight: bold;">Document</span>
object's reference as a parameter.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Instantiate an object of this class<br>      DomTree01 thisObj = new DomTree01();<br><br>      <span
 style="font-weight: bold;">thisObj.processNode(document);</span><br><br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Listing 7 also contains a simple exception handler, which signals the
end of the <span style="font-weight: bold;">main</span> method.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The processNode
method</span><br>
<br>
The <span style="font-weight: bold;">processNode</span> method, which
begins in Listing 8, is used to recursively process the DOM tree,
identifying and displaying the tree structure along the way.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private void processNode(Node node){<br>    if (node == null){<br>      System.err.println(<br>                  "Nothing to do, node is null");<br>      return;<br>    }//end if<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Recall from an earlier lesson that the <span style="font-weight: bold;">Document</span>
interface extends the <span style="font-weight: bold;">Node</span>
interface, which provides a multiplicity of
methods that can be used to navigate and manipulate the DOM tree.&nbsp;
Therefore, a <span style="font-weight: bold;">Document</span> object
can be treated as
type <span style="font-weight: bold;">Node</span>.&nbsp; The required
type for the incoming
parameter to the <span style="font-weight: bold;">processNode</span>
method is type <span style="font-weight: bold;">Node</span>.<br>
<br>
The code in Listing 8 simply checks to confirm that the incoming
reference
does not have a value of null.&nbsp; If it does, the code in Listing 8
prints an error message and
returns.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Perform the
recursive processing on the incoming node</span><br>
<br>
The code in Listing 9 shows the beginning of what happens if the
incoming parameter is not null.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    indent++;<br><br>    String nodeName = node.getNodeName();<br>    int type = node.getNodeType();<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
As you will see later, the <span style="font-weight: bold;">processNode</span>
method will continue calling itself recursively until all of the nodes
in the DOM tree have been examined.&nbsp; Information about the tree
structure will be extracted and displayed as each node is
examined.&nbsp; When all of
the nodes in the DOM tree have been examined, the program will
terminate.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Indentation</span><br>
<br>
Recall the instance variable named <span style="font-weight: bold;">indent</span>
that was declared and initialized in Listing 4.&nbsp; Each time control
enters the <span style="font-weight: bold;">processNode</span> method <span
 style="font-style: italic;">(with a non-null <span
 style="font-weight: bold;">Node </span>parameter),</span> the
value of that instance variable is incremented.&nbsp; Each time control
exits the method <span style="font-style: italic;">(except for the
case of a null <span style="font-weight: bold;">Node </span>parameter),</span>
the value of that instance variable is
decremented.&nbsp; Therefore, at any point in time, the value of <span
 style="font-weight: bold;">indent</span> indicates the current depth <span
 style="font-style: italic;">(in the DOM tree)</span>
of the node that is being examined.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Get node name
and type</span><br>
<br>
The variable named <span style="font-weight: bold;">indent </span>is
incremented in Listing 9.&nbsp; Following this, two methods are called
on the incoming <span style="font-weight: bold;">Node</span> parameter
to get and save the name and the type of the node currently being
examined.<br>
<br>
Some types of nodes have generic names, such as <span
 style="font-weight: bold;">#text</span>.&nbsp; Other types of nodes
have actual names, which match element names in the XML document.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The doIndent
method</span><br>
<br>
At this point, I am going to skip ahead and show you a very simple
method named <span style="font-weight: bold;">doIndent</span>, <span
 style="font-style: italic;">(which actually appears near the end of
the program code in Listing 20).</span>&nbsp;
The code for this method is shown in Listing 10.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private void <span style="font-weight: bold;">doIndent</span>(){<br>    for(int cnt = 0; cnt &lt; indent; cnt++){<br>      System.out.print("  ");<br>    }//end for loop<br>  }//end doIndent<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The purpose of this method is to move the cursor to the right on the
screen to accomplish indentation in the display.&nbsp; Each time method
is called, it moves the cursor to the right by an amount equal to twice
the value of the variable named <span style="font-weight: bold;">indent</span>.&nbsp;
This produces two spaces for each level of indentation.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Display the
name of the node</span><br>
<br>
Returning to the discussion of the <span style="font-weight: bold;">processNode</span>
method, Listing 11 invokes the <span style="font-weight: bold;">doIndent</span>
method to produce the required indentation, and then displays the name
of the
current node, followed by a space.&nbsp; Note that the
cursor remains immediately to the right of the space and does not
advance to the
next line at this time.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    doIndent();<br><br>    System.out.print(nodeName + " ");<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Display the
type of the node on the same line</span><br>
<br>
Recall that the invocation of the <span style="font-weight: bold;">getNodeType</span>
method in Listing 9 returned a value of type <span
 style="font-weight: bold;">int</span>.&nbsp; The <span
 style="font-weight: bold;">Node</span> interface defines about a dozen
symbolic constants that correlate the type values to names such as <span
 style="font-weight: bold;">CDATA_SECTION_NODE</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A switch
statement</span><br>
<br>
Listing 12 shown the beginning of a <span style="font-weight: bold;">switch</span>
statement that uses the type value from Listing 9, along with the
constants from the <span style="font-weight: bold;">Node</span>
interface to display the alphanumeric node type to the right of the
node name that was displayed by the code in Listing 11.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    switch(type){<br>      case Node.CDATA_SECTION_NODE:{<br>        System.out.println("CDATA_SECTION_NODE");<br>        break;<br>      }//end case Node.CDATA_SECTION_NODE<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
When the alphanumeric node type is displayed, the cursor moves down to
the left-hand side of the next line.<br>
<br>
For example, the code in Listings 11 and 12 would produce output
similar to that shown in Figure 6 <span style="font-style: italic;">(the
indentation may be different for different XML documents).</span><br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>        #cdata-section CDATA_SECTION_NODE</pre>
      <pre><b>Figure 6</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The remainder
of the switch statement</span><br>
<br>
Listing 13 shows the remainder of the <span style="font-weight: bold;">switch</span>
statement.&nbsp; There is nothing special about the code in Listing
13.&nbsp; As each node is examined, the code in Listing 11 performs the
proper indentation and displays the name of the node.&nbsp; Then one of
the cases in the <span style="font-weight: bold;">switch</span>
statement is invoked to display the alphanumeric node type to the
right of the node name and to advance the display cursor to the next
line.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case Node.COMMENT_NODE:{<br>        System.out.println("COMMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_FRAGMENT_NODE:{<br>        System.out.println(<br>                       "DOCUMENT_FRAGMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_NODE:{<br>        System.out.println("DOCUMENT_NODE");<br>        break;<br>      }//end case Node.DOCUMENT_NODE<br><br>      case Node.DOCUMENT_TYPE_NODE:{<br>        System.out.println("DOCUMENT_TYPE_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ELEMENT_NODE:{<br>        System.out.println("ELEMENT_NODE");<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br>      case Node.ENTITY_NODE:{<br>        System.out.println("ENTITY_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ENTITY_REFERENCE_NODE:{<br>        System.out.println(<br>                        "ENTITY_REFERENCE_NODE");<br>        break;<br>      }//end case Node.ENTITY_REFERENCE_NODE<br><br>      case Node.NOTATION_NODE:{<br>        System.out.println("NOTATION_NODE");<br>        break;<br>      }//end case<br><br>      case Node.PROCESSING_INSTRUCTION_NODE:{<br>        System.out.println(<br>                  "PROCESSING_INSTRUCTION_NODE");<br>        break;<br>      }//end case<br><br>      //Handle text nodes<br>      case Node.TEXT_NODE:{<br>        System.out.println("TEXT_NODE");<br>        break;<br>      }//end case Node.TEXT_NODE<br><br>      default:{<br>        System.out.println("Unknown Node Type");<br>      }//end default case<br>    }//end switch<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Get and process
children of the current node</span><br>
<br>
Following the <span style="font-weight: bold;">switch</span>
statement, the code in Listing 14 invokes the <span
 style="font-weight: bold;">getChildNodes</span> method on the current
node to get a list of the nodes that are children of the current
node.&nbsp; That list is returned as an object of type <span
 style="font-weight: bold;">NodeList</span>.&nbsp; The <span
 style="font-weight: bold;">NodeList</span> object's
reference is stored in the reference variable named <span
 style="font-weight: bold;">children</span>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    NodeList children = node.getChildNodes();<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
A <span style="font-weight: bold;">NodeList</span> object provides an
ordered collection of nodes, and provides two methods for accessing the
items in the list:<br>
<ul>
  <li>A method named <span style="font-weight: bold;">getLength</span>
returns the number of
nodes in the list.</li>
  <li>A method named <span style="font-weight: bold;">item</span>
takes a parameter of type <span style="font-weight: bold;">int</span>,
and uses that parameter to
return the <span style="font-weight: bold;">Node</span> object's
reference that is stored at that index.</li>
</ul>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Make recursive
call to processNode method on each child node</span><br>
<br>
Provided that the <span style="font-weight: bold;">NodeList</span>
reference in the variable named <span style="font-weight: bold;">children</span>
is not null, the code in Listing 15 uses a <span
 style="font-weight: bold;">for</span> loop to process each node whose
reference is stored in the list.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if (children != null){<br>      int len = children.getLength();<br><br>      for (int i = 0; i &lt; len; i++){<br><br>      //Recursion !!!<br>     <span
 style="font-weight: bold;"> </span><span
 style="font-weight: bold; color: rgb(0, 0, 0);">processNode(children.item(i));</span><br><br>      }//end for loop<br>    }//end if children<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
This is where the recursive processing occurs.&nbsp; The boldface
statement in Listing 15, recursively invokes the <span
 style="font-weight: bold;">processNode</span> method once for each
item in the list, passing the item as a parameter to the <span
 style="font-weight: bold;">processNode</span> method.<br>
<br>
This causes the program to recursively examine every node in the DOM
tree, <span style="font-style: italic;">(except for attribute nodes)</span>
extracting and
displaying information about each node as it is examined.&nbsp; This
includes nodes in the prolog of the XML document as well as nodes in
the body of the XML document.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(The
issue of attribute nodes will be addressed in the next sample program.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Decrease
indentation level and terminate processNode method</span><br>
<br>
When all the invocations of the <span style="font-weight: bold;">processNode</span>
method finally return and the current instance of the <span
 style="font-weight: bold;">processNode</span> method terminates, it
decreases the value of the variable named <span
 style="font-weight: bold;">indent</span> prior to termination as shown
in Listing 16.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    indent--;<br><br>  }//end processNode(Node)<br>  //-------------------------------------------//<br><br>  // doIndent method goes here<br><br>}//end class DomTree01<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Listing 16 signals the end of the <span style="font-weight: bold;">processNode</span>
method, and the beginning of the method named <span
 style="font-weight: bold;">doIndent</span>, which was discussed
earlier.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Because
it was discussed earlier, the code for the <span
 style="font-weight: bold;">doIndent</span> method was not included in
Listing 16.)</span><br>
</div>
<br>
The end of the <span style="font-weight: bold;">doIndent</span> method
signals the end of the class and the end of the program named <span
 style="font-weight: bold;">DomTree01</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The program
named DomTree02</span><br>
<br>
The program named <span style="font-weight: bold;">DomTree02</span> is
an upgraded
version of <span style="font-weight: bold;">DomTree01</span>.&nbsp;
This program displays the actual text belonging to text nodes instead
of
simply showing the type of node as <span style="font-weight: bold;">TEXT_NODE</span>.<br>
<br>
<span style="font-weight: bold;">DomTree02</span> also displays
attribute names and values, which is not the
case with <span style="font-weight: bold;">DomTree01</span>.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Sample output
from DomTree02</span><br>
<br>
Figure 7 shows the output produced by using <span
 style="font-weight: bold;">DomTree02</span> to process the XML file
named <span style="font-weight: bold;">DomTree02.xml</span>.&nbsp; <span
 style="font-style: italic;">(You can view a listing of this XML file
in Listing 23
near the end of the lesson.)</span><br>
<br>
I colored the attributes red and the text green in Figure 7
to make them easy to spot.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
that some of the text consists of invisible newline characters, which
are impossible to color green.)</span><br style="font-style: italic;">
</div>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>#document DOCUMENT_NODE<br>  top DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  top ELEMENT_NODE<br>    #comment COMMENT_NODE<br>    theData ELEMENT_NODE<br><span
 style="color: rgb(255, 0, 0); font-weight: bold;">        Attribute: type=Programming</span><br
 style="color: rgb(255, 0, 0); font-weight: bold;"><span
 style="color: rgb(255, 0, 0); font-weight: bold;">        Attribute: test_attr=Testing</span><br>      title ELEMENT_NODE<br>        <span
 style="color: rgb(51, 204, 0);"><span style="color: rgb(0, 0, 0);">#text</span></span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> Java</span><br>      author ELEMENT_NODE<br>        <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> R.Baldwin</span><br>      price ELEMENT_NODE<br>        <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> $9.95</span><br>        uvw ELEMENT_NODE<br>          <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> abc-</span><br>          xyz ELEMENT_NODE<br>            <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> def-</span><br>          <span
 style="color: rgb(0, 0, 0);">#text</span><br><br>        uvw ELEMENT_NODE<br>          <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> ghi-</span><br
 style="font-weight: bold; color: rgb(51, 204, 0);"><span
 style="font-weight: bold; color: rgb(51, 204, 0);">        </span><span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> each</span><br><br>    theData ELEMENT_NODE<br>        <span
 style="font-weight: bold; color: rgb(255, 0, 0);">Attribute: type=Pets</span><br>      title ELEMENT_NODE<br>          <span
 style="font-weight: bold; color: rgb(255, 0, 0);">Attribute: another_test_attr=More Test</span><br>        <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> Dogs</span><br>      author ELEMENT_NODE<br>        <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> R.U.Barking</span><br>      price ELEMENT_NODE<br>        <span
 style="color: rgb(0, 0, 0);">#text</span><span
 style="font-weight: bold; color: rgb(51, 204, 0);"> $19.95</span></pre>
      <pre><b>Figure 7</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Displaying text
versus displaying node type</span><br>
<br>
Sometimes it can be very useful to display the actual text values in
the tree.&nbsp; At other times, the text is so voluminous that it
completely overwhelms the display making it difficult to pick out the
structure of the tree.&nbsp; In those cases, the version that simply
identifies the node as a text node is probably advantageous.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(A
good learning exercise would be for you to write a single program where
the user specifies whether the tree is to simply identify text nodes,
or is to display the actual
text value of each text node, by entering a parameter on the command
line.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Will discuss in
fragments</span><br>
<br>
I will discuss the program named <span style="font-weight: bold;">DomTree02</span>
in fragments.&nbsp; A complete listing of the program is shown in
Listing 22 near the end of the lesson.<br>
<br>
Large portions of this program are identical or very similar to the
code in the program named <span style="font-weight: bold;">DomTree01</span>,
discussed earlier in this lesson.&nbsp; Therefore, I won't repeat the
discussion of that code.&nbsp; Rather, I will restrict this discussion
to those parts of this program that differ from the earlier program.<br>
<br>
The <span style="font-weight: bold;">main</span> method in this
program is essentially the same as the <span style="font-weight: bold;">main</span>
method in the previous program, so I will skip a discussion of the <span
 style="font-weight: bold;">main</span> method.<br>
<br>
As before, the method named <span style="font-weight: bold;">processNode</span>
is used to recursively process the entire DOM tree, extracting and
displaying information about the nodes in the tree along the way.&nbsp;
The method named <span style="font-weight: bold;">processNode</span>
in this program is the same as in the previous program except for the
code in a couple of cases in the <span style="font-weight: bold;">switch</span>
statement.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">New features in
DomTree02</span><br>
<br>
Previously, the cases in the <span style="font-weight: bold;">switch</span>
statement were used to display the alphanumeric type of each node in
the tree.&nbsp; In this program, the case for <span
 style="font-weight: bold;">TEXT_NODE</span> is modified to cause
the actual text value of the text node to be displayed instead of the
type of the node.<br>
<br>
In addition, the case for <span style="font-weight: bold;">ELEMENT_NODE</span>
in this program is modified to get and display the names and
values of all attributes associated with elements.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The
ELEMENT_NODE case</span><br>
<br>
I will begin by explaining the changes to the <span
 style="font-weight: bold;">ELEMENT_NODE</span> case in the <span
 style="font-weight: bold;">switch</span> statement.&nbsp; Listing 17
shows the beginning of the <span style="font-weight: bold;">ELEMENT_NODE</span>
case.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private void <span style="font-weight: bold;">processNode</span>(Node node){<br>    <br>    //Code deleted for brevity<br><br>    <span
 style="font-weight: bold;">switch(type)</span>{<br><br>      //Case code deleted for brevity<br><br>      case Node.<span
 style="font-weight: bold;">ELEMENT_NODE</span>:{<br>        System.out.println("ELEMENT_NODE");<br>        //Get and display attributes if any<br>        <span
 style="font-weight: bold;">NamedNodeMap </span>attrList =<br>                            node.<span
 style="font-weight: bold;">getAttributes()</span>;<br>        int attrLen = 0;<br>        if(attrList != null){<br>          attrLen = attrList.<span
 style="font-weight: bold;">getLength()</span>;<br>        }//end if<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<span style="font-weight: bold; color: rgb(255, 0, 0);">A map of
attribute nodes</span><br>
<br>
There is a very important conceptual issue to deal with here.&nbsp;
Specifically, attribute nodes are not simply child nodes of element
nodes.&nbsp; In particular, all child nodes of an element node can be
obtained in a collection of type <span style="font-weight: bold;">NodeList</span>
by invoking the method named <span style="font-weight: bold;">getChildNodes</span>
on the element node. <br>
<br>
In order to get the attributes belonging to an element node, it is
necessary to invoke the method named <span style="font-weight: bold;">getAttributes</span>
on the element node.&nbsp; This method returns a reference to an object
of type
<span style="font-weight: bold;">NamedNodeMap</span> containing
<span style="font-style: italic;">unordered </span>references to the
attribute nodes.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">NamedNodeMap
versus NodeList</span><br>
<br>
A <span style="font-weight: bold;">NamedNodeMap</span> is a different
type of data structure than a <span style="font-weight: bold;">NodeList</span>.&nbsp;
<br>
<br>
A <span style="font-weight: bold;">NodeList</span> is an ordered
collection of references to <span style="font-weight: bold;">Node</span>
objects.&nbsp; Items in the list are accessed on the basis of an
ordinal index.&nbsp; They cannot be accessed on the basis of the name
of a node.&nbsp; The order of the items in the list matches the
ordering of the corresponding nodes in the DOM tree.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">NamedNodeMap
</span><br>
<br>
Sun describes objects of type <span style="font-weight: bold;">NamedNodeMap</span>
as<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">"collections
of nodes that can be accessed by name".</span><br>
</div>
<br>
Sun goes on to tell us,<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">"NamedNodeMaps
are not maintained in any particular order. Objects contained in an
object implementing NamedNodeMap may also be accessed by an ordinal
index, but this is simply to allow convenient enumeration of the
contents of a NamedNodeMap, and does not imply that the DOM specifies
an order to these Nodes."</span><br>
</div>
<br>
Therefore, references to objects representing attribute nodes can be
accessed
in a <span style="font-weight: bold;">NamedNodeMap</span> object
either on the basis of the attribute name, or on the basis of an
ordinal index.&nbsp; I will use an ordinal index in this program, as
shown in Listing 18.<br>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Get and display
name and value of attribute nodes</span><br>
<br>
Listing 18 shows the remaining code for the <span
 style="font-weight: bold;">ELEMENT_NODE</span> case in the <span
 style="font-weight: bold;">switch</span> statement.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        for(int i = 0; i &lt; attrLen; i++){<br>          Node attrNode = attrList.item(i);<br>          doIndent();<br>          System.out.println("    Attribute: "<br>                      + attrNode.getNodeName()<br>                      + "="<br>                      + attrNode.getNodeValue());<br>        }//end for loop<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Listing 18 uses a <span style="font-weight: bold;">for</span> loop to
iterate on the <span style="font-weight: bold;">NamedNodeMap</span>
object, getting a reference to each attribute node in sequence, and
using that
reference to get and display the name and value of the attribute
properly indented.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Note
in Listing 18 and Figure 7 that the attribute information was indented
an additional four spaces relative to the element node to visually
separate the attribute information from the child node of the
element.&nbsp; This was done solely for cosmetic purposes.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">The modified
TEXT_NODE case</span><br>
<br>
Listing 19 shows the modified <span style="font-weight: bold;">TEXT_NODE</span>
case in the <span style="font-weight: bold;">switch</span> statement,
and the end of the <span style="font-weight: bold;">switch</span>
statement.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Case code deleted for brevity<br><br>      case Node.<span
 style="font-weight: bold;">TEXT_NODE</span>:{<br>        System.out.println(node.<span
 style="font-weight: bold;">getNodeValue()</span>);<br>        break;<br>      }//end case Node.TEXT_NODE<br><br>      //default case code deleted for brevity<br><br>    }//end switch<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The version of this case in the program named <span
 style="font-weight: bold;">DomTree01</span> simply displayed the text <span
 style="font-weight: bold;">TEXT_NODE</span> each time the case was
invoked.<br>
<br>
This version invokes the method named <span style="font-weight: bold;">getNodeValue</span>
on the node and displays the <span style="font-weight: bold;">String</span>
that is returned by that method.&nbsp; This code produced the green
text values for the text nodes represented in Figure 7.<br>
<br>
<div style="margin-left: 40px;"><span style="font-style: italic;">(Recall
that the word <span style="font-weight: bold;">#text</span> in Figure
7 was displayed by code that invoked the <span
 style="font-weight: bold;">getNodeName</span> method prior to control
entering the <span style="font-weight: bold;">switch</span>
statement.&nbsp; This is the same in both programs.&nbsp; Only the red
and green text in Figure 7 is new.)</span><br>
</div>
<br>
<span style="font-weight: bold; color: rgb(255, 0, 0);">Beyond this
point, both programs are the same</span><br>
<br>
The remainder of this program is the same as <span
 style="font-weight: bold;">DomTree01</span>, and therefore, doesn't
merit further discussion.<br>
<center>
<h2><a name="Run the program"></a>Run the Programs</h2>
</center>
<p>I encourage you to copy the code and XML data from Listings 20
through 23 into your text editor.&nbsp; Compile and execute the
programs.&nbsp; Experiment with them, making changes, and observing the
results
of your
changes.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
In this lesson, I showed you how to write a program to display a
DOM tree on the screen in a format that is much easier to interpret
than raw XML code.&nbsp; I explained two different versions of the
program.&nbsp; One version simply identifies text nodes in the
output tree.&nbsp; The other version displays the value of text nodes
in
the output tree.&nbsp; Also, the first version ignores attributes in
the
output tree, while the second version includes attributes in the
output tree.
<ul>
</ul>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>In the next lesson, I will explain default XSLT behavior
and show you how to write Java code that mimics that behavior.&nbsp;
The resulting Java code will serve as a skeleton for more advanced
transformation programs.
</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the Java class and the XML documents discussed in
this lesson are shown in Listings 20 through 23 below.
<p></p>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File DomTree01.java<br>Copyright 2003 R.G.Baldwin<br><br>This program produces a text-based output on<br>the screen that represents the tree structure<br>of an XML file.<br><br>Not tested for DOCUMENT_FRAGMENT_NODE.<br>Not tested for ENTITY_NODE.<br>Not tested for ENTITY_REFERENCE_NODE.<br>Not tested for NOTATION_NODE.<br><br>The following output was produced by testing<br>this program with the XML file named<br>DomTree01.xml<br><br>#document DOCUMENT_NODE<br>  A DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  processor PROCESSING_INSTRUCTION_NODE<br>  A ELEMENT_NODE<br>    Q ELEMENT_NODE<br>      #text TEXT_NODE<br>    B ELEMENT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>        #cdata-section CDATA_SECTION_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>      S ELEMENT_NODE<br>        #text TEXT_NODE<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>      S ELEMENT_NODE<br>        #text TEXT_NODE<br>      B ELEMENT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>        T ELEMENT_NODE<br>          #text TEXT_NODE<br>        B ELEMENT_NODE<br>          C ELEMENT_NODE<br>            #text TEXT_NODE<br>          D ELEMENT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>              G ELEMENT_NODE<br>                #text TEXT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>            E ELEMENT_NODE<br>              #text TEXT_NODE<br>            F ELEMENT_NODE<br>              #text TEXT_NODE<br>          C ELEMENT_NODE<br>            #text TEXT_NODE<br>        C ELEMENT_NODE<br>          #text TEXT_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br>    B ELEMENT_NODE<br>      R ELEMENT_NODE<br>        #text TEXT_NODE<br>      C ELEMENT_NODE<br>        #text TEXT_NODE<br><br>Note.  No effort was made to provide meaningful<br>information about errors and exceptions.<br><br>Tested using SDK 1.4.2 under WinXP.<br>************************************************/<br><br>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br>import java.io.File;<br>import java.io.FileOutputStream;<br>import org.w3c.dom.*;<br><br>public class DomTree01{<br><br>  int indent = -1;//Indentation level for display<br><br>  public static void main(String argv[]){<br>    if (argv.length != 2){<br>      System.err.println(<br>        "usage: java DomTree01 fileIn validate");<br>      System.err.println(<br>        "validate = n for no, y for yes");<br>      System.exit(0);<br>    }//end if<br><br>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object setting<br>      // validating true or false based on user<br>      // input.<br>      if(argv[1].equals("n")){<br>        factory.setValidating(false);<br>      }else{<br>        factory.setValidating(true);<br>      }//end if/else<br><br>      factory.setNamespaceAware(false);<br>      //Set to ignore cosmetic white space<br>      // between elements.<br>      factory.<br>       setIgnoringElementContentWhitespace(true);<br><br>      //Get a DocumentBuilder (parser) object<br>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      Document document = builder.parse(<br>                              new File(argv[0]));<br><br>      //Instantiate an object of this class<br>      DomTree01 thisObj = new DomTree01();<br><br>      thisObj.processNode(document);<br><br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br>  //-------------------------------------------//<br><br>  //This method is used recursively to identify<br>  // and display node structure.<br>  private void processNode(Node node){<br>    if (node == null){<br>      System.err.println(<br>                  "Nothing to do, node is null");<br>      return;<br>    }//end if<br><br>    //Increase indentation level for display.<br>    indent++;<br>    //Get name and type of node.  Some types of<br>    // nodes have generic names, such as #text.<br>    // Other nodes have actual names.<br>    String nodeName = node.getNodeName();<br>    int type = node.getNodeType();<br><br>    //Indent to the correct level and display the<br>    // name of the node.<br>    doIndent();<br>    System.out.print(nodeName + " ");<br><br>    //Use the type to display the type of the<br>    // node on the same line following the name<br>    // of the node.<br>    switch(type){<br>      case Node.CDATA_SECTION_NODE:{<br>        System.out.println("CDATA_SECTION_NODE");<br>        break;<br>      }//end case Node.CDATA_SECTION_NODE<br><br>      case Node.COMMENT_NODE:{<br>        System.out.println("COMMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_FRAGMENT_NODE:{<br>        System.out.println(<br>                       "DOCUMENT_FRAGMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_NODE:{<br>        System.out.println("DOCUMENT_NODE");<br>        break;<br>      }//end case Node.DOCUMENT_NODE<br><br>      case Node.DOCUMENT_TYPE_NODE:{<br>        System.out.println("DOCUMENT_TYPE_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ELEMENT_NODE:{<br>        System.out.println("ELEMENT_NODE");<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br>      case Node.ENTITY_NODE:{<br>        System.out.println("ENTITY_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ENTITY_REFERENCE_NODE:{<br>        System.out.println(<br>                        "ENTITY_REFERENCE_NODE");<br>        break;<br>      }//end case Node.ENTITY_REFERENCE_NODE<br><br>      case Node.NOTATION_NODE:{<br>        System.out.println("NOTATION_NODE");<br>        break;<br>      }//end case<br><br>      case Node.PROCESSING_INSTRUCTION_NODE:{<br>        System.out.println(<br>                  "PROCESSING_INSTRUCTION_NODE");<br>        break;<br>      }//end case<br><br>      //Handle text nodes<br>      case Node.TEXT_NODE:{<br>        System.out.println("TEXT_NODE");<br>        break;<br>      }//end case Node.TEXT_NODE<br><br>      default:{<br>        System.out.println("Unknown Node Type");<br>      }//end default case<br>    }//end switch<br><br>    //This method is first called on the node<br>    // that represents the root node of the DOM<br>    // tree.  The following code recursively<br>    // processes the entire tree.<br>    NodeList children = node.getChildNodes();<br>    if (children != null){<br>      int len = children.getLength();<br>      //Iterate on NodeList of child nodes.<br>      for (int i = 0; i &lt; len; i++){<br>      //Process each of the nested elements<br>      // recursively.<br>      processNode(children.item(i));<br>      }//end for loop<br>    }//end if children<br><br>    //Decrease indentation level for display<br>    indent--;<br>  }//end processNode(Node)<br>  //-------------------------------------------//<br><br>  //This method displays two spaces for each<br>  // level of indentation.<br>  private void doIndent(){<br>    for(int cnt = 0; cnt &lt; indent; cnt++){<br>      System.out.print("  ");<br>    }//end for loop<br>  }//end doIndent<br><br>}//end class DomTree01<br><br><b><font
 face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<p>
</p>
<p> </p>
<br>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre><a href="file:///C:/jnk/DomTree01.xml"></a>&lt;?xml version="1.0"?&gt;<br><br>&lt;!DOCTYPE A [<br>&lt;!ELEMENT A (Q,B,B)*&gt;<br>&lt;!ELEMENT B (B | C | D | R | S | T)*&gt;<br>&lt;!ELEMENT C (#PCDATA)&gt;<br>&lt;!ELEMENT D (E | F)*&gt;<br>&lt;!ELEMENT E (#PCDATA | G)*&gt;<br>&lt;!ELEMENT F (#PCDATA)&gt;<br>&lt;!ELEMENT G (#PCDATA)&gt;<br>&lt;!ELEMENT Q (#PCDATA)&gt;<br>&lt;!ELEMENT R (#PCDATA)&gt;<br>&lt;!ELEMENT S (#PCDATA)&gt;<br>&lt;!ELEMENT T (#PCDATA)&gt;<br>]&gt;<br><br><br>&lt;!-- File DomTree01.xml<br>Copyright 2003 R. G. Baldwin<br>Used to test the program named<br>DomTree01.java<br>--&gt;<br><br>&lt;?xml-stylesheet type="text/xsl" <br>href="Dom03.xsl"?&gt;<br>&lt;?processor ProcInstr="Dummy"?&gt;<br><br>&lt;A&gt;<br>&lt;Q&gt;A Big Header&lt;/Q&gt;<br><br>&lt;B&gt;<br>&lt;C&gt;Level 0.  This is the beginning of a B.  <br>This text is in the Introduction section.<br>&lt;![CDATA[This is CDATA &lt; &gt; " &amp;]]&gt;&lt;/C&gt;<br><br>&lt;R&gt;A Mid Header&lt;/R&gt;<br><br>&lt;C&gt;Text block 1.&lt;/C&gt;<br><br>&lt;S&gt;A Small Header&lt;/S&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 2.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;S&gt;Another Small Header&lt;/S&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 3.&lt;/C&gt;<br><br>&lt;T&gt;A Smallest Header&lt;/T&gt;<br>&lt;B&gt;<br>&lt;C&gt;Text block 4.&lt;/C&gt;<br><br>&lt;D&gt;<br>&lt;E&gt;First list item in E<br>&lt;G&gt;Nested G text element&lt;/G&gt;<br>&lt;/E&gt;<br>&lt;F&gt;First list item in F&lt;/F&gt;<br>&lt;E&gt;Second list item in E&lt;/E&gt;<br>&lt;F&gt;Second list item in F&lt;/F&gt;<br>&lt;E&gt;Third list item in E&lt;/E&gt;<br>&lt;F&gt;Third list item in F&lt;/F&gt;<br>&lt;/D&gt;<br><br>&lt;C&gt;Text block 5.&lt;/C&gt;<br>&lt;/B&gt;<br>&lt;C&gt;Text block 6.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;R&gt;Another Mid Header&lt;/R&gt;<br>&lt;C&gt;Text block 7.&lt;/C&gt;<br>&lt;/B&gt;<br><br>&lt;B&gt;<br>&lt;R&gt;Another Mid Header in Another B&lt;/R&gt;<br>&lt;C&gt;Text block 8.&lt;/C&gt;<br>&lt;/B&gt;<br>&lt;/A&gt;<br><br><b><font
 face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<br>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File DomTree02.java<br>Copyright 2003 R.G.Baldwin<br><br>This program is an upgraded version of DomTree01.<br>This version shows the actual text belonging to<br>text nodes instead of simply showing the type<br>of node.<br><br>This version also displays attribute names and<br>values, which was not the case with DomTree01.<br><br>This program produces a text-based output on<br>the screen that represents the tree structure<br>of an XML file.<br><br>Not tested for DOCUMENT_FRAGMENT_NODE.<br>Not tested for ENTITY_NODE.<br>Not tested for ENTITY_REFERENCE_NODE.<br>Not tested for NOTATION_NODE.<br><br>The following output was produced by testing<br>this program with the XML file named<br>DomTree02.xml<br><br>#document DOCUMENT_NODE<br>  top DOCUMENT_TYPE_NODE<br>  #comment COMMENT_NODE<br>  xml-stylesheet PROCESSING_INSTRUCTION_NODE<br>  top ELEMENT_NODE<br>    #comment COMMENT_NODE<br>    theData ELEMENT_NODE<br>        Attribute: type=Programming<br>        Attribute: test_attr=Testing<br>      title ELEMENT_NODE<br>        #text Java<br>      author ELEMENT_NODE<br>        #text R.Baldwin<br>      price ELEMENT_NODE<br>        #text $9.95<br>        uvw ELEMENT_NODE<br>          #text abc-<br>          xyz ELEMENT_NODE<br>            #text def-<br>          #text<br><br>        uvw ELEMENT_NODE<br>          #text ghi-<br>        #text each<br><br>    theData ELEMENT_NODE<br>        Attribute: type=Pets<br>      title ELEMENT_NODE<br>          Attribute: another_test_attr=More Test<br>        #text Dogs<br>      author ELEMENT_NODE<br>        #text R.U.Barking<br>      price ELEMENT_NODE<br>        #text $19.95<br><br>Note.  No effort was made to provide meaningful<br>information about errors and exceptions.<br><br>Tested using SDK 1.4.2 under WinXP.<br>************************************************/<br><br>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br>import java.io.File;<br>import java.io.FileOutputStream;<br>import org.w3c.dom.*;<br><br>public class DomTree02{<br><br>  int indent = -1;//Indentation level for display<br><br>  public static void main(String argv[]){<br>    if (argv.length != 2){<br>      System.err.println(<br>        "usage: java DomTree02 fileIn validate");<br>      System.err.println(<br>        "validate = n for no, y for yes");<br>      System.exit(0);<br>    }//end if<br><br>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object setting<br>      // validating true or false based on user<br>      // input.<br>      if(argv[1].equals("n")){<br>        factory.setValidating(false);<br>      }else{<br>        factory.setValidating(true);<br>      }//end if/else<br><br>      factory.setNamespaceAware(false);<br>      //Set to ignore cosmetic white space<br>      // between elements.<br>      factory.<br>       setIgnoringElementContentWhitespace(true);<br><br>      //Get a DocumentBuilder (parser) object<br>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      Document document = builder.parse(<br>                              new File(argv[0]));<br><br>      //Instantiate an object of this class<br>      DomTree02 thisObj = new DomTree02();<br><br>      thisObj.processNode(document);<br><br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br>  //-------------------------------------------//<br><br>  //This method is used recursively to identify<br>  // and display node structure.<br>  private void processNode(Node node){<br>    if (node == null){<br>      System.err.println(<br>                  "Nothing to do, node is null");<br>      return;<br>    }//end if<br><br>    //Increase indentation level for display.<br>    indent++;<br>    //Get name and type of node.  Some types of<br>    // nodes have generic names, such as #text.<br>    // Other nodes have actual names.<br>    String nodeName = node.getNodeName();<br>    int type = node.getNodeType();<br><br>    //Indent to the correct level and display the<br>    // name of the node.<br>    doIndent();<br>    System.out.print(nodeName + " ");<br><br>    //Use the type to display the type of the<br>    // node on the same line following the name<br>    // of the node.<br>    switch(type){<br>      case Node.CDATA_SECTION_NODE:{<br>        System.out.println("CDATA_SECTION_NODE");<br>        break;<br>      }//end case Node.CDATA_SECTION_NODE<br><br>      case Node.COMMENT_NODE:{<br>        System.out.println("COMMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_FRAGMENT_NODE:{<br>        System.out.println(<br>                       "DOCUMENT_FRAGMENT_NODE");<br>        break;<br>      }//end case<br><br>      case Node.DOCUMENT_NODE:{<br>        System.out.println("DOCUMENT_NODE");<br>        break;<br>      }//end case Node.DOCUMENT_NODE<br><br>      case Node.DOCUMENT_TYPE_NODE:{<br>        System.out.println("DOCUMENT_TYPE_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ELEMENT_NODE:{<br>        System.out.println("ELEMENT_NODE");<br>        //Get and display attributes if any<br>        NamedNodeMap attrList =<br>                            node.getAttributes();<br>        int attrLen = 0;<br>        if(attrList != null){<br>          attrLen = attrList.getLength();<br>        }//end if<br><br>        for(int i = 0; i &lt; attrLen; i++){<br>          Node attrNode = attrList.item(i);<br>          doIndent();<br>          System.out.println("    Attribute: "<br>                      + attrNode.getNodeName()<br>                      + "="<br>                      + attrNode.getNodeValue());<br>        }//end for loop<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br>      case Node.ENTITY_NODE:{<br>        System.out.println("ENTITY_NODE");<br>        break;<br>      }//end case<br><br>      case Node.ENTITY_REFERENCE_NODE:{<br>        System.out.println(<br>                        "ENTITY_REFERENCE_NODE");<br>        break;<br>      }//end case Node.ENTITY_REFERENCE_NODE<br><br>      case Node.NOTATION_NODE:{<br>        System.out.println("NOTATION_NODE");<br>        break;<br>      }//end case<br><br>      case Node.PROCESSING_INSTRUCTION_NODE:{<br>        System.out.println(<br>                  "PROCESSING_INSTRUCTION_NODE");<br>        break;<br>      }//end case<br><br>      //Handle text nodes<br>      case Node.TEXT_NODE:{<br>        System.out.println(node.getNodeValue());<br>        break;<br>      }//end case Node.TEXT_NODE<br><br>      default:{<br>        System.out.println("Unknown Node Type");<br>      }//end default case<br>    }//end switch<br><br>    //This method is first called on the node<br>    // that represents the root node of the DOM<br>    // tree.  The following code recursively<br>    // processes the entire tree.<br>    NodeList children = node.getChildNodes();<br>    if (children != null){<br>      int len = children.getLength();<br>      //Iterate on NodeList of child nodes.<br>      for (int i = 0; i &lt; len; i++){<br>      //Process each of the nested elements<br>      // recursively.<br>      processNode(children.item(i));<br>      }//end for loop<br>    }//end if children<br><br>    //Decrease indentation level for display<br>    indent--;<br>  }//end processNode(Node)<br>  //-------------------------------------------//<br><br>  //This method displays two spaces for each<br>  // level of indentation.<br>  private void doIndent(){<br>    for(int cnt = 0; cnt &lt; indent; cnt++){<br>      System.out.print("  ");<br>    }//end for loop<br>  }//end doIndent<br><br>}//end class DomTree02<br><br><b><font
 face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<br>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br><br>&lt;!DOCTYPE top [<br>&lt;!ELEMENT top (theData)*&gt;<br>&lt;!ELEMENT theData (title,author,price)*&gt;<br>&lt;!ELEMENT title (#PCDATA)&gt;<br>&lt;!ELEMENT author (#PCDATA)&gt;<br>&lt;!ELEMENT price (#PCDATA | uvw)*&gt;<br>&lt;!ELEMENT uvw (#PCDATA | xyz)*&gt;<br>&lt;!ELEMENT xyz ANY&gt;<br>&lt;!ATTLIST theData type CDATA #REQUIRED&gt;<br>&lt;!ATTLIST theData test_attr CDATA #IMPLIED&gt;<br>&lt;!ATTLIST title another_test_attr CDATA #IMPLIED&gt;<br>]&gt;<br><br>&lt;!-- File DomTree02.xml<br>Copyright 2003 R. G. Baldwin<br>Each data element contains a type <br>attribute that is displayed in the<br>output tree display.--&gt;<br><br>&lt;?xml-stylesheet type="text/xsl" <br>href="Dom07.xsl"?&gt;<br><br>&lt;top&gt;<br><br>&lt;!--The following element is designed to<br>be complex, involving combination text<br>and element child nodes.  However, it is<br>not intended to make any sense in a real-world<br>sense--&gt;<br>&lt;theData type="Programming" test_attr="Testing"&gt;<br>&lt;title&gt;Java&lt;/title&gt;<br>&lt;author&gt;R.Baldwin&lt;/author&gt;<br>&lt;price&gt;$9.95&lt;uvw&gt;abc-&lt;xyz&gt;def-&lt;/xyz&gt;<br>&lt;/uvw&gt;&lt;uvw&gt;ghi-&lt;/uvw&gt;each<br>&lt;/price&gt;<br>&lt;/theData&gt;<br><br>&lt;theData type="Pets"&gt;<br>&lt;title another_test_attr="More Test"&gt;Dogs&lt;/title&gt;<br>&lt;author&gt;R.U.Barking&lt;/author&gt;<br>&lt;price&gt;$19.95&lt;/price&gt;<br>&lt;/theData&gt;<br><br>&lt;/top&gt;<br><br><b><font
 face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<br>
<p> </p>
<p>
</p>
<p> </p>
<hr width="100%" size="2">
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and XML. In addition to the many platform and/or language independent
benefits of Java and C# applications, he believes that a combination of
Java, C#, and XML will become the primary driving force in the delivery
of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects, and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com/">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology to real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
