<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2><font face="Arial, Helvetica" size="+1"><b>Processing Image Pixels, </b>An 
Improved Image-Processing Framework in Java</font></h2><i>Learn about a new 
image processing framework that provides the ability to perform two sequential 
processes on an image, to display the modified images resulting from each 
process</i>, <i>(in addition to the original 
image)</i>,<i> and to write the modified images into output files in JPEG 
format.</i><p><b>Published:</b>&nbsp; October 31, 2006<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 416</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
	<ul><li><a href="#The_Class_Named_ImgMod04">The Class Named ImgMod04</a></li>
		<li><a href="#The_Class_Named_ImgMod04a">The Class Named ImgMod04a</a></li>
		<li><a href="#The_Class_Named_ProgramTest">The Class Named ProgramTest</a></li></ul>
	<li><a href="#Run%20the%20program">Run the Program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's Next?</a></li>
	<li><a href="#References">References</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> In this lesson, you will Learn about a new image processing framework that 
provides the ability to perform two sequential processes on an image, to display 
the modified image resulting from each process, <i>(in addition to the original 
image),</i> and to write the modified images into output files in JPEG 
format.</p>
<p> <font color="#FF0000"><b>The earlier programs named ImgMod02 and ImgMod02a</b></font></p>
	<p> In the Fall of 2004, I published a tutorial lesson entitled
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>, which contained a program named 
<b>ImgMod02</b>.&nbsp; That program was designed to make it <i>&quot;easy to experiment with the modification of pixel data 
in an image and to display the modified version of the image along with the 
original version of the image.&quot;</i></p>
<p> A couple of months later in the lesson entitled
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a>, I published an 
updated version of the program.&nbsp; The updated version was named <b>ImgMod02a</b>.&nbsp; The purpose of that 
update was rather minor.&nbsp; Basically it improved the code that reads an 
input image file.</p>
	<p> <font color="#FF0000"><b>Many subsequent lessons</b></font></p>
<p> Since then, I have published about a dozen tutorial lessons on various image 
processing and digital signal processing <i>(DSP)</i> topics that make use of 
one or the other of those two programs.&nbsp; During the publication of those 
lessons, I have identified several features that I wished I had included in the 
original version.&nbsp; Therefore, it is time for a major new update.</p>
	<p> <font color="#FF0000"><b>The new program named ImgMod04</b></font></p>
	<p> This 
lesson will present a new program named <b>ImgMod04</b> that incorporates the 
following new features in the framework:</p>
<ul>
	<li>The ability to perform two sequential pixel-modification processes <i>(instead of just one)</i> 
	on an image and to display the modified image resulting from each process in 
	addition to displaying the original image.</li>
	<li>The ability to write two modified images into output files in 
	JPEG format.&nbsp; <i>(The names of the output files are <b>junk1.jpg</b> and 
	<b>junk2.jpg</b>.&nbsp; They are written into the current directory.)</i></li>
	<li>The elimination of several conversions back and forth between type <b>
	double</b> and type <b>int</b>.&nbsp; All computations can now be performed as 
	type <b>double</b>, and the data is maintained as type <b>double</b> from the initial 
	conversion from <b>int</b> to <b>double</b> to the point where the data is ready 
	to be displayed and written into a JPEG file.</li>
	<li>The <b>Replot</b> button <i>(see <a href="#Figure_1">Figure 1</a>)</i> was moved to the top of 
	the display <i>(see <a href="#Figure_2">Figure 2</a>)</i> to make it accessible when the display is 
	too long to fit on the screen. <i>(For purposes of viewing the display in that case, the frame can be moved up and down on the screen using 
	the right mouse button and the up and down arrow keys, but the lower portion 
	of the bottom display still gets chopped off.)</i></li>
</ul>
<p> <font color="#FF0000"><b>Differences between the two programs</b></font></p>
	<p> The most obvious differences between the two programs are illustrated by 
	differences between 
	<a href="#Figure_1">Figure 1</a> and <a href="#Figure_2">Figure 2</a>.&nbsp; <a href="#Figure_1">Figure 1</a> shows an output from the earlier 
	program named <b>ImgMod02a</b>.&nbsp; The two images in <a href="#Figure_1">Figure 1</a> were first 
	published in Figure 57 in the earlier lesson <a name="Figure_1">entitled</a>
	<a href="http://www.developer.com/java/ent/article.php/3590351">Processing 
	Image Pixels, Applying Image Convolution in Java</a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java416a03.jpg" width="310" height="476"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>An embossing filter</b></font></p>
<p>If you have studied the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier</a> lesson, you are aware that the bottom image in <a href="#Figure_1">Figure 1</a> was produced 
by applying a two-dimensional embossing convolution filter to the image of the 
starfish in the top of <a href="#Figure_1">Figure 1</a>.</p>
	<p><font color="#FF0000"><b>A hidden watermark example</b></font></p>
	<p><a href="#Figure_2">Figure 2</a> shows two output displays from the new program named <b>ImgMod04</b> 
	arranged side-by-side for comparison purposes.&nbsp; The primary display for
	<b>ImgMod04</b> contains three images plus a <b>Replot</b> button in a 
	vertical stack in a Java <b>Frame</b> object.</p>
<p>The six images contained in the two displays shown in 
	<a href="#Figure_2">Figure 2</a> <i>(along with some other images as well)</i> will be published 
	later in a future lesson on creating hidden <a name="Figure_2">watermarks</a>. </p>



<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td><img border="0" src="java416a01.jpg" width="164" height="464"></td>
		<td><img border="0" src="java416a02.jpg" width="164" height="464"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_2">Figure 2</a></b></pre></td>
	</tr>
</table>
<p><font color="#FF0000"><b>Brief description of Figure 2</b></font></p>
	<p>Briefly, the two input images shown in the top of the left and right 
	panels in <a href="#Figure_2">Figure 2</a> are the same.&nbsp; The middle image in the left panel 
	shows the result of performing a two-dimensional Discrete Cosine Transform
	<i>(2D-DCT)</i> on the input image.&nbsp; <i>(I explained the 2D-DCT in the 
	earlier lesson entitled 
	<a href="http://www.developer.com/java/data/article.php/3634156">Understanding the 2D Discrete Cosine Transform in Java</a>.)</i></p>
<p><font color="#FF0000"><b>Recovering the visual image</b></font></p>
	<p>The bottom image in the left panel of <a href="#Figure_2">Figure 2</a> shows the result of 
	performing an inverse 2D-DCT on the middle image for the purpose of 
	recovering the visual image from the spectral data.&nbsp; Ideally, this 
	image should be an exact match for the top image.</p>
	<p><font color="#FF0000"><b>Adding watermarks to the spectral data</b></font></p>
	<p>The middle image in the right panel of <a href="#Figure_2">Figure 2</a> shows the result of 
	performing a 2D-DCT on the input image and then adding three instances of a 
	watermark consisting of the characters <b>H2O</b>.</p>
<blockquote>
	<p><i>(You should be able to see the watermarks in the upper-left corner of 
	the middle image in the right panel of <a href="#Figure_2">Figure 2</a>.&nbsp; Obviously, they are not hidden in the spectral 
	data, but they are hidden in the recovered visual image discussed below.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The visual image with the hidden watermarks</b></font></p>
	<p>The bottom image in the right panel of <a href="#Figure_2">Figure 2</a> shows the result of performing 
	an inverse 2D-DCT on the middle image for the purpose of recovering the 
	visual image from the spectral data that includes the watermark.&nbsp; 
	Ideally, the bottom image should be an exact match for the top image.&nbsp; 
	Also, ideally, the bottom image on the right should be an exact match for 
	the bottom image on the left.&nbsp; A comparison of the two bottom images indicates the visual impact, if any, 
	that the addition of the hidden watermarks had on the visual image.</p>
	<p>I will explain digital watermarking in some detail in a future lesson.&nbsp; 
	In that lesson, I will show that the hidden watermark can be exposed <i>(for 
	the purpose of attempting to establish ownership of the image)</i> by 
	performing a forward 2D-DCT on the image containing the hidden watermark in 
	the bottom-right panel.&nbsp; <i>(I may perform some additional DSP 
	processes in addition to the 2D-DCT.)</i>&nbsp; I will use the JPEG file produced by the 
	program to show that.</p>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different listings and figures while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>I also recommend that you pay particular attention to the lessons listed in 
the <a href="#References">References</a> section of this document.</p>
	<p> <font color="#FF0000"><b>A new class named ImgMod04a</b></font></p>
	<p>While I was at it, I decided to go ahead and provide a class named <b>
	ImgMod04a</b> that contains all of the features of <b>ImgMod04</b> except 
	that it supports only one image processing method.</p>
<p>The most notable thing about this new class is that it replaces the earlier 
class named <b>ImgMod02a</b> with a class that writes the modified image into an 
output file in JPEG format.&nbsp; The name of the output file is <b>junk.jpg</b>.</p>
<p>I will have more to say about this class <a href="#The_Class_Named_ImgMod04a">
later</a>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#FF0000"><b>The program named ImgMod04</b></font></p>
<p>A complete listing of this program is provided in <a href="#Listing_28">Listing 28</a> near the end of 
the lesson.&nbsp; The purpose of this program is to make it easy to experiment with 
the modification of pixel data in an image and to display two different modified versions 
of the image along with the original image.</p>
<p><font color="#FF0000"><b>Program updates</b></font></p>
<p>This program is an update of the 
earlier program named <b>ImgMod02a</b>.&nbsp; This update provides the following new features:</p>
<ul>
	<li>The ability to perform two sequential pixel-modification processes <i>(instead of just one)</i> 
	on an image and to display the modified image resulting from each process in 
	addition to displaying the original image.</li>
	<li>The ability to write two modified images into output files in 
	JPEG format.&nbsp; <i>(The names of the output files are <b>junk1.jpg</b> and 
	<b>junk2.jpg</b>.&nbsp; They are written into the current directory.)</i></li>
	<li>The elimination of several conversions back and forth between type <b>
	double</b> and type <b>int</b>.&nbsp; All computations can now be performed as 
	type <b>double</b>, and the data is maintained as type <b>double</b> from the initial 
	conversion from <b>int</b> to <b>double</b> to the point where the data is ready 
	to be displayed and written into a JPEG file.</li>
	<li>The <b>Replot</b> button <i>(see <a href="#Figure_1">Figure 1</a>)</i> was moved to the top of 
	the display <i>(see <a href="#Figure_2">Figure 2</a>)</i> to make it accessible when the display is 
	too long to fit on the screen. <i>(For purposes of viewing the display in that case, the frame can be moved up and down on the screen using 
	the right mouse button and the up and down arrow keys, but the lower portion 
	of the bottom display still gets chopped off.)</i></li>
</ul>
<p><font color="#FF0000"><b>Input from an image file</b></font></p>
<p>The program reads the pixel 
data from an image file into a 3D array of type:</p>
<p><pre><b>double[row][column][depth]</b></pre></p>
<blockquote>
	<p><i>(If the program is unable to load the image file within ten seconds, it 
will abort with an error message.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Contents of the 3D array</b></font></p>
<p>The 
first two dimensions of the array correspond to the rows and columns of pixels in 
the image.&nbsp; The third dimension always has a value of 4 and contains the following 
values by index:</p>
<ul>
	<li>0 - alpha <i>(transparency)</i></li>
	<li>1 - red</li>
	<li>2 - green</li>
	<li>3 - blue</li>
</ul>
<p>Note that these values are stored as 
type <b>double</b> rather than as type <i>unsigned byte</i> which is the 
standard format of pixel data in 
the original image file.&nbsp; This type conversion eliminates many problems involving 
the requirement to perform unsigned arithmetic on unsigned byte data.</p>
<blockquote>
	<p><i>(Recall that Java doesn't support unsigned numeric data or unsigned arithmetic.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Image file types</b></font></p>
<p>The program 
supports <i>gif</i> and <i>jpg</i> input files and possibly some other file types as well.&nbsp; The 
output file is always a <i>jpg</i> file.</p>
<p><font color="#FF0000"><b>Operation</b></font></p>
<p>This program provides a framework 
that is designed to invoke another program to process the pixels extracted from an 
image.&nbsp; In other words, this program extracts the pixels and puts them in a format 
that is relatively easy to work with.&nbsp; A second program is invoked by the 
program named <b>ImgMod04</b> to actually 
process the pixels.</p>
<p>Thus, this program performs the following major tasks:</p>
<ul>
	<li>Reads the original image data from an input file.</li>
	<li>Provides the image data to a pair of processing methods initially and 
	again each time the <b>Replot</b> button is clicked.</li>
	<li>Displays the data returned by the two image processing methods along with the 
	original image data.</li>
	<li>Writes the image data that is displayed into output files in JPEG 
	format.</li>
</ul>
<p>Typical usage is as follows:</p>
<b><pre>java ImgMod04 <a name="ProcessingProgramName">ProcessingProgramName</a> <a name="ImageFileName">ImageFileName</a></pre></b></p>
<p><font color="#FF0000"><b>A built-in test program</b></font></p>
<p>For test and illustration purposes, the 
source code includes a class definition for an image processing program named <b>
<a href="#ProgramTest">ProgramTest</a></b>.</p>
<p>If the 
<b><a href="#ImageFileName">ImageFileName</a></b> is not specified on the command line 
as shown <a href="#ImageFileName">above</a>, the 
program will search for an image file in the current directory named 
<b>ImgMod04Test.jpg</b> and will process it using the processing program 
specified by <b><a href="#ProcessingProgramName">ProcessingProgramName</a></b>.</p>
<p>If both command-line <a href="#ProcessingProgramName">arguments</a> are omitted, the 
program will search for an image file in the current directory named <b>ImgMod04Test.jpg</b> and will process it using the built-in processing program named
<b><a href="#ProgramTest">ProgramTest</a></b>.</p>
<p>I will provide a complete description of <a href="#ProgramTest">ProgramTest</a> 
later in this lesson.</p>
<p><font color="#FF0000"><b>The input image file</b></font></p>
<p>The input image 
file must be provided by the user in all cases.&nbsp; However, it doesn't have to be in 
the current directory if a path to the file is specified on the command line.</p>
<p><font color="#FF0000"><b>Behavior at startup</b></font></p>
<p>When 
the program is started, the original image and two processed versions of the 
image are displayed in a frame with the original image above the two processed 
images as shown in either the left or right panel of <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>Behavior of the Replot button</b></font></p>
<p>A <b>Replot</b> button appears at the top of the frame. If the user clicks the 
<b>Replot</b> button, the two image processing methods are re-run using the 
original image as input to the first processing program, and using one of the 
array objects output 
from the first processing program as input to the second processing program.</p>
<p>The 
images are reprocessed and the newly processed versions of the images 
replace 
the old versions in the display.</p>
<p><font color="#FF0000"><b>A GUI for user input</b></font></p>
<p>The processing program may provide a GUI for user input making 
it possible for the user to modify the behavior of the image processing methods 
each time they are run.&nbsp; This capability is illustrated by the built-in processing program named 
<b><a href="#ProgramTest">ProgramTest</a></b>.</p>
<blockquote>
	<p><i>(The user input GUI for <a href="#ProgramTest">ProgramTest</a> is 
	shown in <a href="#Figure_3">Figure 3</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The ImgIntfc04 interface</b></font></p>
<p>The image processing program must 
implement the interface named <b>ImgIntfc04</b>.&nbsp; A complete listing of the 
interface is provided in <a href="#Listing_29">Listing 29</a>.&nbsp; That interface declares two image 
processing methods with the following signatures:</p>
<b><pre>ImgIntfc04Method01Output processImg01(double[][][] input);</pre></b> </p>
<b><pre>double[][][] processImg02(double[][][] input);</pre></b></p>
<p><font color="#FF0000"><b>The image processing method named processImg01</b></font></p>
<p>The first image processing method named <b>processImg01 </b> must return references to two3D array 
objects of type <b>double</b> encapsulated in an object of the class <b>ImgIntfc04Method01Output</b>.&nbsp;
<i>(This is simply a wrapper class designed to encapsulate the two references in 
a single returned object.)</i>&nbsp; The definition for the <b>ImgIntfc04Method01Output
</b>class is also provided in <a href="#Listing_29">Listing 29</a>.&nbsp; </p>
<p>The contents of the array referred to by 
one of the returned references are displayed as the middle image of the main 
display.&nbsp; <i>(See <a href="#Figure_2">Figure 2</a> for two examples of the main display.)</i>&nbsp; 
This image data is also written into an output file in JPEG format named <b>
junk1.jpg</b>.</p>
<p>The other reference returned from the method named <b>processImg01 </b> is passed as a parameter to the second 
processing method named <b>processImg02</b>.</p>
<p>Depending on the processing objectives, the two references may point to 
the same or to different array objects.&nbsp; In <a href="#Figure_2">Figure 2</a>, the two references 
pointed to different array objects.&nbsp; For the output from the built-in 
program named <b><a href="#ProgramTest">ProgramTest</a></b>, shown in <a href="#Figure_4">Figure 4</a>, 
the two references point to the same array object.</p>
<p><font color="#FF0000"><b>The image processing method named processImg02</b></font></p>
<p>The second image processing method that is declared in the interface named <b>
ImgIntfc04 </b>must return a 
reference to a single 3D array object of type <b>double</b>.&nbsp; The contents 
of this array object are 
displayed in the bottom image of the main 
display.&nbsp; <i>(Once again, see <a href="#Figure_2">Figure 2</a> for two examples of the main 
display.)&nbsp; </i>The contents of the array object returned by the method 
named <b>processImg02 </b>are also written into an output file in JPEG 
format named <b>junk2.jpg</b>.</p>
<p><font color="#FF0000"><b>No parameterized constructor</b></font></p>
<p>The image processing program cannot use a parameterized constructor.&nbsp; This 
is because an object of the class is instantiated by invoking the <b>newInstance</b> 
method of the class named <b>Class</b> on the name of the image processing program 
provided as a <b>String</b> on the <a href="#ProcessingProgramName">command line</a>.&nbsp; This approach to object instantiation 
does not support parameterized constructors.</p>
<p><font color="#FF0000"><b>No main method needed</b></font></p>
<p>If the image processing program has a 
<b>main</b> method, it will be ignored.</p>
<p><font color="#FF0000"><b>Programming guidelines</b></font></p>
<p>The image processing methods named <b>processImg01 </b>and<b> processImg02&nbsp;&nbsp;
</b>each receive a 3D array 
containing pixel data as type <b>double</b>.&nbsp; Each method should probably make a copy of the incoming array and modify the 
copy rather than modifying the original.&nbsp; Then the programs should return 
references to the modified copies of the 3D pixel arrays.</p>
<p>The two image processing methods <span lang="en-us"></span>are free to modify the values in the incoming arrays in any manner whatsoever 
before returning references to the modified arrays.&nbsp; Note however that native pixel 
data consists of four unsigned bytes.&nbsp; If the modification of the data 
produces negative values or positive values greater than 255, this should be dealt 
with before returning the modified data that is to be displayed and 
written into the output JPEG files.&nbsp; Otherwise, the results of displaying 
the modified data may not be as expected.</p>
<p><font color="#FF0000"><b>Two ways to deal with the issue</b></font></p>
<p>There are at least two ways to deal with this situation.&nbsp; One way is to 
simply clamp all negative values at zero and to clamp all values greater than 
255 at 255.&nbsp; The other way is to perform a further modification of the data 
so as to map the range from -x to +y into the range from 0 to 255.&nbsp; This 
amounts to changing the color distribution for the image, which may or may not 
be appropriate in a specific situation.&nbsp; The previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> explains many 
aspects of dealing with the color distribution of an image.</p>
<p>There is no single correct way to deal with the issue for all situations.</p>
<p><font color="#FF0000"><b>The built-in test class named <a name="ProgramTest">
ProgramTest</a></b></font></p>
<p>The purpose of this class is to provide a simple example of an image 
processing program that is compatible with the class named <b>ImgMod04</b> and the 
interface named <b>ImgIntfc04</b>.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor for the class displays a small frame on the screen with a 
single text field as shown in <a name="Figure_3"><a href="#Figure_3">Figure 3</a></a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java416a04.jpg" width="201" height="101"><br></pre>
      <pre><b><a href="#Figure_3">Figure 3</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of the text field is to allow the user to enter a value that 
represents the slope of a line.</p>
<p><font color="#FF0000"><b>Enter a slope and click Replot</b></font></p>
<p>In operation, the user types a new value into the 
text field and then clicks the <b>Replot</b> button shown at the top of the main image display frame 
in either the left panel or the right panel of <a href="#Figure_4">Figure 4</a>.&nbsp; This causes the 
slope of the line shown in the middle and bottom images to match the value in 
the text field and causes the images 
to be <a name="Figure_4">repainted</a>.</p>



<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td><img border="0" src="java416a05.jpg" width="164" height="464"></td>
		<td><img border="0" src="java416a06.jpg" width="164" height="464"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_4">Figure 4</a></b></pre></td>
	</tr>
</table>
<p>The 
user is not required to press the Enter key after typing the new value, but it 
doesn't do any harm to do so.</p>
<p>Negative slopes are not supported.&nbsp; An attempt to use 
a negative slope will cause the program to abort with an error.</p>
<p><font color="#FF0000"><b>The method named processImage01</b></font></p>
<p>The method named 
<b>processImage01</b> receives a 3D array of type <b>double</b> containing 
alpha, red, green, and blue values for the image shown at the top of either 
panel in <a href="#Figure_4">Figure 4</a>.</p>
<p><font color="#FF0000"><b>Draw a line on the image</b></font></p>
<p>The image that is received by the <b>processImg01</b> method is 
modified by the method to cause a white diagonal line to be drawn down and to 
the right from the upper left corner of the image.&nbsp; The slope of the line is 
controlled by the value in the text field.&nbsp; </p>
<blockquote>
	<p><i>(Because the positive vertical direction is down the screen instead of 
	up, the actual slope of the line that is drawn is the negative of what we 
	typically think of as the slope of a line.)</i></p>
</blockquote>
<p>Initially, the value in the text field is 1.0 
as shown in <a href="#Figure_3">Figure 3</a>, but the 
value can be modified by the user.</p>
<blockquote>
	<p><i>(If the characters in the text field cannot be 
converted to a numeric type <b>double</b>, the program will abort with an error.)</i></p>
</blockquote>
<p>The line shown in the middle and bottom images of the left panel of <a href="#Figure_4">Figure 4</a> 
has the initial slope of 1.0.&nbsp; The lines shown in the images in the right 
panel have a user-specified slope of 0.5.</p>
<p><font color="#FF0000"><b>Invert the colors in the image</b></font></p>
<p>After 
drawing the line, the <b>processImg01 </b>method inverts the colors in the image.&nbsp; This results in a 
black line on an image with inverted colors as shown by the middle images in 
the two panels of <a href="#Figure_4">Figure 4</a>.</p>
<p><font color="#FF0000"><b>Return references to two image arrays</b></font></p>
<p>The method named <b>processImg01</b> is 
required to return references to two 3D array objects of type <b>double</b>.&nbsp; 
The two references are 
encapsulated in an object of type <b>ImgIntfc04Method01Output</b>.</p>
<p>The version of the <b>processImg01</b> method in the built-in class named <b>
ProgramTest</b> returns two references to the same modified pixel array, but that is not necessary.&nbsp; The method 
can return references to two different 3D arrays of type <b>double</b> as is the 
case for the hidden watermark example shown in <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>Data to be displayed</b></font></p>
<p>The 
data in the 3D array that is to be displayed as the middle image is referenced by the value stored in the variable named
<b>objectA</b> of the returned object of type <b>ImgIntfc04Method01Output</b>.&nbsp; 
This data is displayed as the middle image by the code in the class named <b>ImgMod04</b>.</p>
<p><font color="#FF0000"><b>Data to be passed to the processImg02 method</b></font></p>
<p>The reference stored in 
the variable named <b>objectB</b> of the returned object is passed as a parameter to 
the method named <b>processImg02</b> by the code in the class named <b>ImgMod04</b>.</p>
<p>As mentioned above, in this 
version of the method, both references point to the same 3D array object, so the 
same reference is used to produce the middle image and also to be passed to the 
method named <b>processImg02</b>.</p>
<p><font color="#FF0000"><b>The method named processImage02</b></font></p>
<p>The 
method named <b>processImg02</b> receives an incoming 3D array of type <b>double</b> and returns one reference to a 3D array of type 
<b>double</b> 
containing pixel data.&nbsp; </p>
<blockquote>
	<p><i>(There is no requirement that the incoming array to the <b>
	processImage02</b> method contain pixel data.&nbsp; It can be any kind of 
	data so long as it is properly stored in a 3D array of type <b>double</b>.&nbsp; 
	In fact, for the hidden watermark case shown in <a href="#Figure_2">Figure 2</a>, the incoming data 
	to the <b>processImage02</b> method isn't pixel data at all.&nbsp; Rather, 
	it is data that describes the 2D wave-number spectrum of the image at the 
	top of <a href="#Figure_2">Figure 2</a> obtained by performing a 2D-DCT on the image.&nbsp; 
	Converting that spectral data of type <b>double</b> to eight-bit pixel data 
	before passing it to the method would seriously degrade the quality of the 
	spectral data.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Perform a color inversion</b></font></p>
<p>This version of the <b>processImg02</b> method simply performs a color inversion on 
the incoming data and returns a reference to the array of modified pixel data.&nbsp; This 
effectively reverses the color 
inversion performed earlier by the <b>processImg01</b> method, causing the bottom images 
in <a href="#Figure_4">Figure 4</a> to match the 
top images except that they have a white diagonal line drawn on them.</p>
<p><font color="#FF0000"><b>Drawing a new line</b></font></p>
<p>To cause a 
new line to be drawn, type a new slope value into the text field and click the 
<b>Replot</b> button at the top of the main image display frame.&nbsp; As 
mentioned above, the images in the right panel of <a href="#Figure_4">Figure 4</a> were produced with a 
user input slope of 0.5.</p>
<p><font color="#FF0000"><b>Must implement ImgIntfc04</b></font></p>
<p>The <b>ProgramTest</b> class extends 
<b>Frame</b> and implements <b>ImgIntfc04</b>.&nbsp; A compatible class is not required to extend the 
<b>Frame</b> class but it is required to implement the <b>ImgIntfc04</b> 
interface.&nbsp; This 
example extends <b>Frame</b> because it provides a GUI for user input.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
<h3><a name="The_Class_Named_ImgMod04">The Class Named ImgMod04</a></h3>
<p>As is my custom, 
I will discuss and explain the code in fragments.&nbsp; <a href="#Listing_1">Listing 1</a> shows the 
beginning of the class named <b><a name="Listing_1">ImgMod04</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod04 extends Frame{
  Image rawImg;//A reference to the raw image.
  int imgCols;//Number of horizontal pixels
  int imgRows;//Number of rows of pixels
  Image modImgA;//Reference to first modified image
  Image modImgC;//Reference to third modified image

  //Default image processing program.  This class will be
  // executed to process the image if the name of another
  // class is not entered on the command line.  Note that
  // the source code for this class file is included in
  // this source code file.
  static String theProcessingClass = "ProgramTest";

  //Default image file name.  This image file will be
  // processed if another file name is not entered on the
  // command line.  You must provide this file in the
  // current directory if it is going to be processed.
  static String theImgFile = "ImgMod04Test.jpg";

  MediaTracker tracker;
  Display display = new Display();//A Canvas object
  Button replotButton = new Button("Replot");

  //Reference to the image processing object.
  ImgIntfc04 imageProcessingObject;<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_1">Listing 1</a> is straightforward and shouldn't require any 
explanation beyond the comments embedded in the code.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method is shown in its entirety in <a name="Listing_2"><a href="#Listing_2">Listing 2</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    //Get names for the image processing class and the
    // image file to be processed.  Program supports gif
    // files and jpg files and possibly some other file
    // types as well.
    if(args.length == 0){
      //Use default processing class and default image
      // file.  Class and file names were specified above.
    }else if(args.length == 1){
      theProcessingClass = args[0];
      //Use default image file along with this class.
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and image file.
    System.out.println(
              "Processing program: " + theProcessingClass);
    System.out.println("Image file: " + theImgFile);

    //Instantiate an object of this class.
    ImgMod04 obj = new ImgMod04();
  }//end main<br><br><b><font face="Courier New,Courier"><a href="#Listing_2">Listing 2</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The comments in <a href="#Listing_2">Listing 2</a> should suffice to explain everything about the <b>
main</b> method.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor begins in <a name="Listing_3"><a href="#Listing_3">Listing 3</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public ImgMod04(){//constructor
    final double[][][] threeDPix = <b>getTheImage</b>();<br><br><b><font face="Courier New,Courier"><a href="#Listing_3">Listing 3</a></font></b></pre>
</tbody>
</table>
</p>
<p>The constructor begins by invoking the method named <b>getTheImage</b> to get an image from the specified image file.&nbsp; 
The image file can be in a different directory if the path was entered with the file name on the&nbsp;<a href="#ProcessingProgramName">command line</a>.</p>
<p>The local variable named <b>threeDPix</b> must be declared <b>final</b> because it is accessed from within an anonymous inner class.&nbsp; 
Once the reference is returned from the method named <b>getTheImage</b> and 
assigned to the variable, the contents of the variable cannot be changed for the 
duration of the program.</p>
<p>At this point, I will set the constructor aside discuss the 
method named <b>getTheImage</b>.</p>
<p><font color="#FF0000"><b>The method named getTheImage</b></font></p>
<p>The method named <b>getTheImage</b> reads an image from a specified image file and converts the pixel data into a 3D array of type
<b>double</b>.&nbsp; The name of the image file is specified by the contents of 
the <b>String</b> variable named <b>theImgFile</b> in <a href="#Listing_1">Listing 1</a>.&nbsp; The method named <b>getTheImage</b> 
is shown in its entirety in <a name="Listing_4"><a href="#Listing_4">Listing 4</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  double[][][] getTheImage(){
    rawImg = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImg,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if

    //Raw image has been loaded.  Get width and height of
    // the raw image.
    imgCols = rawImg.getWidth(this);
    imgRows = rawImg.getHeight(this);

    //Create a 1D array object to receive the pixel
    // representation of the image
    int[] oneDPix = new int[imgCols * imgRows];

    //Create an empty BufferedImage object
    BufferedImage buffImage = new BufferedImage(
                              imgCols,
                              imgRows,
                              BufferedImage.TYPE_INT_ARGB);

    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImg, 0, 0, null);

    //Convert the BufferedImage to numeric pixel
    // representation.
    DataBufferInt dataBufferInt =
                      (DataBufferInt)buffImage.getRaster().
                                           getDataBuffer();
    oneDPix = dataBufferInt.getData();

    //Convert the pixel byte data in the 1D array to
    // double data in a 3D array to make it easier to work
    // with the pixel data later.  Recall that pixel data
    // is unsigned byte data and Java does not support
    // unsigned arithmetic. Performing unsigned arithmetic
    // on byte data is particularly cumbersome.
    return convertTo3D(oneDPix,imgCols,imgRows);
  }//end getTheImage<br><br><b><font face="Courier New,Courier"><a href="#Listing_4">Listing 4</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I explained code very similar to the code in <a href="#Listing_4">Listing 4</a> in the earlier lesson 
entitled <a href="http://www.dickbaldwin.com/java/Java174.htm">The AWT Package, 
Graphics - Overview of Advanced Image Processing Capabilities</a> so I won't 
repeat that explanation here.</p>
<p><font color="#FF0000"><b>Convert to 3D double data</b></font></p>
<p><a href="#Listing_4">Listing 4</a> invokes the <b>convertTo3D</b> method to convert the pixel byte data in the 1D array 
of type <b>int</b> to a 3D array of type <b>double</b>.&nbsp; This was done to make it easier to work with the pixel data later.</p>
<blockquote>
	<p><i>(Recall that pixel data is unsigned byte data and Java does not support unsigned arithmetic. 
	Therefore, performing unsigned arithmetic on byte data in Java is particularly cumbersome.)</i></p>
</blockquote>
<p>You can view the method named <b>convertTo3D</b> in <a href="#Listing_28">Listing 28</a>.&nbsp; If you 
understand the use of bitwise operators, the code in the <b>convertTo3D</b> 
method shouldn't require further explanation.&nbsp; If not, you can learn a little 
about bitwise operators in the earlier lesson entitled
<a href="http://www.dickbaldwin.com/java/Java022.htm#bitwiseoperations">
Operators</a>.</p>
<p><font color="#FF0000"><b>Construct the display object</b></font></p>
<p>Returning now to the discussion of the constructor, the code in <a href="#Listing_5">Listing 5</a> performs several routine operations necessary to 
construct the display objects shown earlier in the panels <a name="Listing_5">of</a> <a href="#Figure_4">Figure 4</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.setTitle("Copyright 2006, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.NORTH);<br><br><b><font face="Courier New,Courier"><a href="#Listing_5">Listing 5</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the frame size</b></font></p>
<p><a href="#Listing_6">Listing 6</a> sets the frame size so that a small amount of yellow background will show on the right, between the images, and on the bottom when all three images are displayed, one above the 
other as shown by the images in the panels 
<a name="Listing_6">in</a> <a href="#Figure_4">Figure 4</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Make the frame visible so as to make it possible to
    // get insets and the height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and the height
    // of the button.
    int inTop = this.getInsets().top;
    int inLeft = this.getInsets().left;
    int buttonHeight = replotButton.getSize().height;
    
    this.setSize(2*inLeft+imgCols + 2,inTop
                           + buttonHeight + 3*imgRows + 9);<br><br><b><font face="Courier New,Courier"><a href="#Listing_6">Listing 6</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that it is necessary to make the frame visible before it is possible to 
get valid values for the insets and the height of the button.</p>
<p><font color="#FF0000"><b>Register ActionListener on the Replot button</b></font></p>
<p><a href="#Listing_7">Listing 7</a> begins the definition and instantiation of an anonymous inner class listener 
that is registered on the <b>Replot</b> <a name="Listing_7">button</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    replotButton.addActionListener(
      new ActionListener(){
        public void <b>actionPerformed</b>(ActionEvent e){
          ImgIntfc04Method01Output output = 
             imageProcessingObject.<b>processImg01</b>(threeDPix);<br><br><b><font face="Courier New,Courier"><a href="#Listing_7">Listing 7</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(If you don't know about anonymous inner classes, see my earlier 
	lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3300881">The 
	Essence of OOP using Java, Anonymous Classes</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The actionPerformed method</b></font></p>
<p>The <b>actionPerformed</b> method that begins in <a href="#Listing_7">Listing 7</a> is invoked when 
the user clicks the <b>Replot</b> button.&nbsp; It is also invoked at startup 
when this program posts an <b>ActionEvent</b> to the 
<a href="#Post_a_counterfeit_ActionEvent">system event queue</a> 
attributing the event to the <b>Replot</b> button.</p>
<p><a href="#Listing_7">Listing 7</a> passes a 3D array of pixel data to the first processing method 
named<b> processImg01</b>.&nbsp; This method returns references to two 3D arrays 
encapsulated in the variables named <b>outputA</b> and <b>outputB</b> in an 
object of type <b>ImgIntfc04Method01Output</b>.</p>
<p>The contents of the array referred to by <b>outputA</b> will be displayed as 
the middle image in the displays shown in <a href="#Figure_2">Figure 2</a> and <a href="#Figure_4">Figure 4</a>.&nbsp; The reference contained 
in <b>outputB</b> will be passed as a parameter to the second processing method 
named <b>processImg02</b>.&nbsp; The contents of the array referred to by <b>
outputA</b> will also be written into an output JPEG file named <b>junk1.jpg</b>.</p>
<p>The second processing method named <b>processImg02</b> returns a reference to 
a single 3D array of pixel data as type <b>double</b>.&nbsp; The contents of 
that array will be displayed as the bottom image in the displays shown in
<a href="#Figure_2">Figure 2</a> and <a href="#Figure_4">Figure 4</a>.&nbsp; The contents of that array will also be written into an output JPEG 
file named <b>junk2.jpg</b>.</p>
<p><font color="#FF0000"><b>Extract the array object references</b></font></p>
<p><a href="#Listing_8">Listing 8</a> extracts the references to the two 3D array objects of type <b>double</b> from the returned 
object of type <b><a name="Listing_8">ImgIntfc04Method01Output</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          double[][][] threeDPixModA = output.outputA;
          double[][][] threeDPixModB = output.outputB;<br><br><b><font face="Courier New,Courier"><a href="#Listing_8">Listing 8</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Pass object's reference to second processing method</b></font></p>
<p><a href="#Listing_9">Listing 9</a> passes the second array object's reference returned by the 
first processing method to the second processing method named <b>
<a name="Listing_9">processImg02</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          double[][][] threeDPixModC = 
                        imageProcessingObject.processImg02(
                                            threeDPixModB);<br><br><b><font face="Courier New,Courier"><a href="#Listing_9">Listing 9</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_9">Listing 9</a> also saves the reference to an array object returned by the second 
processing method named <b>processImg02</b>.</p>
<p><font color="#FF0000"><b>Prepare the data for display</b></font></p>
<p>At this point, the time has come to display the contents of two 3D array objects as the 
middle and bottom images in one of the panels shown in <a href="#Figure_2">
Figure 2</a> and <a href="#Figure_4">Figure 4</a>.&nbsp; However, 
the data is not in a form suitable for display at this point in the program, so 
the data must be prepared to be displayed.</p>
<p><a href="#Listing_10">Listing 10</a> invokes the method named <b>convertTo1D</b> to convert one 3D array of modified pixel data of type
<b>double</b> to a 1D array of pixel data of type <b>int</b>.&nbsp; This 1D array is in a standard pixel 
<a name="Listing_10">format</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          int[] oneDPixA = <b>convertTo1D</b>(threeDPixModA);<br><br><b><font face="Courier New,Courier"><a href="#Listing_10">Listing 10</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The method named convertTo1D</b></font></p>
<p>At this point, I will set the discussion of the <b>actionPerformed</b> method 
aside and discuss the method named <b>convertTo1D</b>, which is shown in its 
entirety in <a name="Listing_11"><a href="#Listing_11">Listing 11</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  int[] convertTo1D(double[][][] data){
    int imgRows = data.length;
    int imgCols = data[0].length;

    //Create the 1D array of type int to be populated with
    // pixel data, one int value per pixel, with four
    // color and alpha bytes per int value.
    int[] oneDPix = new int[imgCols * imgRows * 4];

    //Move the data into the 1D array.  Note the use of the
    // bitwise OR operator and the bitwise left-shift
    // operators to put the four 8-bit bytes into each int.
    // Also note that the values are clamped at 0 and 255.
    for(int row = 0,cnt = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        if(data[row][col][0] &lt; 0) data[row][col][0] = 0;
        if(data[row][col][0] &gt; 255) data[row][col][0]=255;
        if(data[row][col][1] &lt; 0) data[row][col][1] = 0;
        if(data[row][col][1] &gt; 255) data[row][col][1]=255;
        if(data[row][col][2] &lt; 0) data[row][col][2] = 0;
        if(data[row][col][2] &gt; 255) data[row][col][2]=255;
        if(data[row][col][3] &lt; 0) data[row][col][3] = 0;
        if(data[row][col][3] &gt; 255) data[row][col][3]=255;
        
        oneDPix[cnt] = (((int)data[row][col][0] &lt;&lt; 24)
                                             & 0xFF000000)
                     | (((int)data[row][col][1] &lt;&lt; 16)
                                             & 0x00FF0000)
                      | (((int)data[row][col][2] &lt;&lt; 8)
                                             & 0x0000FF00)
                           | (((int)data[row][col][3])
                                             & 0x000000FF);
        cnt++;
      }//end for loop on col
    }//end for loop on row

    return oneDPix;
  }//end convertTo1D<br><br><b><font face="Courier New,Courier"><a href="#Listing_11">Listing 11</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Purpose of the convertTo1D method</b></font></p>
<p>The purpose of the <b>convertTo1D</b> method in <a href="#Listing_11">Listing 11</a> is to convert the 
data in the 3D array of type <b>double</b> back into a 1d array of type <b>int</b> 
in the same format as the format produced by the invocation of the <b>getData</b> 
of the <b>DataBufferInt</b> class in <a href="#Listing_4">Listing 4</a>.</p>
<p><font color="#FF0000"><b>The int array data format</b></font></p>
<p>Each element of type <b>int</b> in the 1D array returned by the <b>
convertTo1D</b> method contains the four unsigned data bytes that represent a 
single pixel.&nbsp; The most significant byte contains the alpha or transparency 
data.&nbsp; Moving from most to least significant, the remaining bytes contain 
the unsigned values for red, green, and blue in that order.</p>
<p>If the image has N columns of pixels in each row, the first N elements in the 
array contain the data for the first row of pixels, the second N elements 
contain the data for the second row of pixels, etc.</p>
<blockquote>
	<p><i>(Note that the data values are clamped at 0 and 255 before casting to type
	<b>int</b>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Reverse the process</b></font></p>
<p>This is the reverse of the process implemented by the method named <b>
convertTo3D</b> that was invoked in <a href="#Listing_4">Listing 4</a> to convert the image data from 
type <b>int</b> to type <b>double</b>.</p>
<blockquote>
	<p><i>(If you understand the use of bitwise operators, the code in 
	<a href="#Listing_11">Listing 
	11</a> shouldn't require further explanation.&nbsp; If not, you can learn about bitwise operators in the earlier lesson entitled
	<a href="http://www.dickbaldwin.com/java/Java022.htm#bitwiseoperations">
	Operators</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Create the Image object</b></font></p>
<p>Returning to the <b>actionPerformed</b> method, <a href="#Listing_12">Listing 12</a> invokes the <b>
createImage</b> method of the <b>Component</b> class to create a new <b>Image</b> object from the 1D array of pixel 
<a name="Listing_12">data</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          modImgA = <b>createImage</b>(new MemoryImageSource(
                      imgCols,imgRows,oneDPixA,0,imgCols));<br><br><b><font face="Courier New,Courier"><a href="#Listing_12">Listing 12</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the <b>MemoryImageSource</b> class implements the <b>ImageProducer</b> interface and therefore satisfies one of the overloaded versions of the
<b>createImage</b> method.&nbsp; If this is new to you, you can read about it in 
the Sun documentation.&nbsp; You can also read about it in my earlier lesson 
entitled <a href="http://www.dickbaldwin.com/java/Java174.htm">The AWT Package, 
Graphics - Overview of Advanced Image Processing Capabilities</a>.</p>
<p>At this point, the image data has been converted into an object of type <b>
Image</b>, which is suitable for being passed as a parameter to the <b>drawImage</b> 
method of the <b>Graphics</b> class later in the overridden <b>paint</b> method.</p>
<p><font color="#FF0000"><b>Prepare the other image</b></font></p>
<p><a href="#Listing_13">Listing 13</a> uses the same methodology to convert the other 3D array of pixel data 
into an object of type <b><a name="Listing_13">Image</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          int[] oneDPixC = convertTo1D(threeDPixModC);
          modImgC = createImage(new MemoryImageSource(
                      imgCols,imgRows,oneDPixC,0,imgCols));<br><br><b><font face="Courier New,Courier"><a href="#Listing_13">Listing 13</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Repaint the display</b></font></p>
<p><a href="#Listing_14">Listing 14</a> invokes the <b>repaint</b> method.&nbsp; 
This sends a message to the 
operating system requesting that the overridden <b>paint</b> method be executed 
to cause the main display shown in <a href="#Figure_2">Figure 2</a> and
<a href="#Figure_4">Figure 4</a> to be <a name="Listing_14">repainted</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          display.repaint();<br><br><b><font face="Courier New,Courier"><a href="#Listing_14">Listing 14</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>This program invokes the <b>drawImage</b> method of the <b>Graphics</b> class 
to draw the three images on an object instantiated from a subclass of the <b>
Canvas</b> class.&nbsp; The <b>Canvas</b> class is extended into a new inner 
class named <b>Display</b> to make it possible to override the <b>paint</b> 
method.</p>
<blockquote>
	<p><i>(If you don't know about inner classes, see my earlier lessons 
	numbered <a href="http://www.developer.com/java/other/article.php/3085271">
	1636</a>, <a href="http://www.developer.com/java/other/article.php/3107181">
	1638</a>, and
	<a href="http://www.developer.com/java/other/article.php/3300881">1640</a>.)</i></p>
</blockquote>
<p>You can view the code for the <b>Display</b> class and its overridden <b>
paint</b> method in <a href="#Listing_28">Listing 28</a>.&nbsp; If you already know about the use of the 
overridden <b>paint</b> method in a callback sense to draw on the computer 
screen in Java, no explanation of the overridden <b>paint</b> method beyond the 
embedded comments should be needed.&nbsp; If you don't have that knowledge, go 
to <a href="http://www.google.com/">Google</a> and search for the following keywords:</p>
<p><pre><b>baldwin java overridden paint</b></pre></p>
<p>You will probably find that I have published more material on this topic than you 
will have the time to 
read.</p>
<p><b><font color="#FF0000">Write the JPEG files</font></b></p>
<p><a href="#Listing_15">Listing 15</a> invokes the method named <b>writeJpegFile</b> 
twice to cause the images 
shown in the middle and the bottom of the displays in <a href="#Figure_2">Figure 2</a> and <a href="#Figure_4">Figure 4</a> to be written into output files 
in JPEG format.&nbsp; The names of the files are hard-coded into the program.&nbsp; 
However, it would be easy for you to make the file names input parameters to the 
program if you wished to do so.&nbsp; The middle image is written into the file 
named <b>junk1.jpg</b>, and the bottom image is written into the file named <b>
<a name="Listing_15">junk2.jpg</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          writeJpegFile(modImgA,imgCols,imgRows,
                                              "junk1.jpg");
          writeJpegFile(modImgC,imgCols,imgRows,
                                              "junk2.jpg");<br><br><b><font face="Courier New,Courier"><a href="#Listing_15">Listing 15</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You can view the entire method named <b>writeJpegFile</b> in <a href="#Listing_28">Listing 28</a>.&nbsp; 
Although the code is not completely straightforward, the embedded comments in 
the method, along with the Sun documentation of the classes and methods 
involved, should suffice to explain the method.</p>
<p><font color="#FF0000"><b>End anonymous listener class definition</b></font></p>
<p>The nested curly braces along with the right-parenthesis and the semicolon in 
<a href="#Listing_16">Listing 16</a> signal the end of the definition of the anonymous listener 
<a name="Listing_16">class</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class registered on the Replot
    // button.<br><br><b><font face="Courier New,Courier"><a href="#Listing_16">Listing 16</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When the code in <a href="#Listing_16">Listing 16</a> has been executed, 
the anonymous class has been defined, an anonymous object of the anonymous class 
has been instantiated, and the anonymous object has been registered as an <b>
ActionListener</b> on the <b>Replot</b> button shown at the top of each of the 
displays in <a href="#Figure_2">Figure 2</a> and <a href="#Figure_4">Figure 4</a>.</p>
<p><font color="#FF0000"><b>Instantiate an image processing object</b></font></p>
<p>Continuing with the constructor code, <a href="#Listing_17">Listing 17</a> instantiates a new object of the image processing 
<a name="Listing_17">class</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{
      imageProcessingObject = (ImgIntfc04)Class.forName(
                         theProcessingClass).newInstance();<br><br><b><font face="Courier New,Courier"><a href="#Listing_17">Listing 17</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Recall that the name of the image processing class is provided as
<a href="#ProcessingProgramName">command-line parameter</a> when the program is 
started.&nbsp; <a href="#Listing_17">Listing 17</a> invokes the <b>forName</b> method of the class named
<b>Class</b> to get an object of the class named <b>Class</b> that represents 
the image processing class.</p>
<p>If you are unfamiliar with the use of the <b>forName</b> method for this 
purpose, go to <a href="http://www.google.com/">Google</a> and search for the following keywords:</p>
<p><pre><b>Baldwin java forName</b></pre></p>
<p><font color="#FF0000"><b>The newInstance method</b></font></p>
<p>Then <a href="#Listing_17">Listing 17</a> invokes the <b>newInstance</b> method of the class named <b>
Class</b> to create a new object of the image processing class that is 
represented by the <b>Class</b> object.</p>
<p>At the risk of seeming redundant, if you are unfamiliar with the use of the <b>
newInstance</b> method to create objects, go to <a href="http://www.google.com/">Google</a> and search for the 
following keywords:</p>
<p><pre><b>Baldwin java forName newInstance</b></pre></p>
<blockquote>
	<p><i>(Because I have published hundreds of tutorial lessons on hundreds of 
	Java programming topics, you can find what I have had to say on most basic Java 
	programming topics by searching for the appropriate keywords at
	<a href="http://www.google.com/">Google</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Cast to type ImgIntfc04</b></font></p>
<p>Note that in <a href="#Listing_17">Listing 17</a>, the object of the image processing class is cast to the interface 
type, <b>ImgIntfc04</b> to make it compatible for storage in the instance 
variable named <b>imageProcessingObject</b> that was declared in <a href="#Listing_1">Listing 1</a>.</p>
<p><font color="#FF0000"><b>Cannot use a parameterized constructor</b></font></p>
<p>Also note that when you create a new object using the <b>newInstance</b> 
method, you do not have access to a parameterized constructor for the class.&nbsp; 
Therefore, when you define your image processing classes, there will be no point 
in defining parameterized constructors for the classes.&nbsp; I'll have more to 
say about this later in conjunction with the discussion of the
<a href="#ProgramTest">ProgramTest</a> class.</p>
<p><font color="#FF0000"><b><a name="Post_a_counterfeit_ActionEvent">Post a counterfeit ActionEvent</a></b></font></p>
<p><a href="#Listing_18">Listing 18</a> posts a counterfeit <b>ActionEvent</b> to the system event queue and attributes it to the
<b>Replot</b> button.</p>
<blockquote>
	<p><i>(See <a href="http://www.dickbaldwin.com/java/Java104.htm">Event Handling in JDK 1.1, 
Posting Synthetic Events to the System Event Queue</a><!--endtitle--> for an 
explanation of the use of the system event queue.)</i></p>
</blockquote>
<p>Posting this event causes the two image processing methods to be invoked in sequence at startup and causes the modified images to be displayed.&nbsp; 
The effect is exactly as if the user had clicked the <b>Replot</b> button on 
<a name="Listing_18">startup</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      Toolkit.getDefaultToolkit().getSystemEventQueue().
        postEvent(
          new ActionEvent(replotButton,
                          ActionEvent.ACTION_PERFORMED,
                          "Replot")
        );//end postEvent method

    }catch(Exception e){
      e.printStackTrace();
      System.exit(1);
    }//end catch<br><br><b><font face="Courier New,Courier"><a href="#Listing_18">Listing 18</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Status at this point in the execution</b></font></p>
<p>At this point, the original image has been processed.&nbsp; The original image and both 
of modified images have been displayed 
as shown in the panels of <a href="#Figure_2">Figure 2</a> and <a href="#Figure_4">Figure 4</a>.</p>
<p>From this point forward, each time the user clicks the
<b>Replot</b> button, the image will be processed again and the images returned 
from the image processing methods will be displayed along with the original image.</p>
<p><font color="#FF0000"><b>The catch block</b></font></p>
<p><a href="#Listing_18">Listing 18</a> also contains a <b>catch</b> block that matches up with the <b>try</b> 
block that began in <a href="#Listing_17">Listing 17</a>.</p>
<p><font color="#FF0000"><b>Make everything visible</b></font></p>
<p>Although the frame itself was made visible earlier to facilitate the reading 
of the inset values, it is still necessary to cause the composite of the frame, 
the canvas, the button, and the images to become visible.&nbsp; This is 
accomplished in <a name="Listing_19"><a href="#Listing_19">Listing 19</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.setVisible(true);<br><br><b><font face="Courier New,Courier"><a href="#Listing_19">Listing 19</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Activate the close button</b></font></p>
<p><a href="#Listing_20">Listing 20</a> defines, instantiates, and registers a <b>WindowListener</b> object that 
causes the program to terminate when the user clicks the X-button in the upper 
right of the frames shown <a name="Listing_20">in</a> <a href="#Figure_2">Figure 
2</a> and <a href="#Figure_4">Figure 4</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //===================================================//

  }//end constructor<br><br><b><font face="Courier New,Courier"><a href="#Listing_20">Listing 20</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_20">Listing 20</a> also signals the end of the constructor and the end of the class 
named <b>ImgMod04</b>.</p>
<h3><a name="The_Class_Named_ImgMod04a">The Class Named ImgMod04a</a></h3>
<p>As mentioned earlier, while I was at it, I decided to go ahead and provide a&nbsp;class named <b>ImgMod04a</b> that contains all of the features of <b>ImgMod04</b> 
except that it supports only one image processing method.</p>
<p>The most notable thing about this new class is that it replaces the earlier 
class named <b>ImgMod02a</b> with a class that writes the modified image into an 
output file in JPEG format.&nbsp; The name of the output file is <b>junk.jpg</b>.</p>
<p>A complete listing of the class is provided in <a href="#Listing_30">Listing 
30</a>.&nbsp; If you understand the class named <b>ImgMod04</b>, you should have 
no problem understanding the class named <b>ImgMod04a</b>.</p>
<p><font color="#FF0000"><b>Usage</b></font></p>
<p>Typical usage of this new class is as follows:</p>
<b><pre>java ImgMod04a <a name="ProcessingProgramName0">ProcessingProgramName</a> <a name="ImageFileName0">ImageFileName</a></pre></b></p>
<p><font color="#FF0000"><b>A built-in test program</b></font></p>
<p>For test and illustration purposes, the 
source code includes a class definition for an image processing program named <b>
ProgramTestA</b>.&nbsp; This test program is very similar to the test program 
named <a href="#ProgramTest"><b>ProgramTest</b></a>, which I will explain later.&nbsp; 
If you understand the test program named <a href="#ProgramTest"><b>ProgramTest</b></a>, 
you should have no difficulty understanding the test program named <b>
ProgramTestA</b>.</p>
<p><font color="#FF0000"><b>The interface named ImgIntfc04a</b></font></p>
<p>A program that is compatible with being driven by the new class named <b>
ImgMod04a</b> must implement the interface named <b>ImgIntfc04a</b>.&nbsp; A 
complete listing of the interface is provided in <a href="#Listing_31">Listing 
31</a>.</p>
<p>If you understand the interface named <b>ImgIntfc04</b>, you should have no 
difficulty understanding the interface named <b>ImgIntfc04a</b>.</p>
<h3><a name="The_Class_Named_ProgramTest">The Class Named ProgramTest</a></h3>
<p>As mentioned earlier, for test and illustration purposes, the source code 
includes a class definition for an image processing program named <b>ProgramTest</b>.&nbsp; 
A complete description of the class was provided <a href="#ProgramTest">earlier</a>.</p>
<p>The class definition, including the declaration of some instance variables,&nbsp;begins in <a name="Listing_21" href="#Listing_21">Listing 21</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ProgramTest extends Frame <b>implements ImgIntfc04</b>{

  double slope;//Controls the slope of the line
  String inputData;//Obtained via the TextField
  TextField inputField;//Reference to TextField<br><br><b><font face="Courier New,Courier"><a href="#Listing_21">Listing 21</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Must implement ImgIntfc04</b></font></p>
<p>This is an <i>image processing program</i> in the sense of the command-line 
parameter indicated by <b><a href="#ProcessingProgramName">ProcessingProgramName</a></b> earlier.&nbsp; For example, 
this image processing program can be run by entering the following at the 
command line:</p>
<p><pre><b>java ImgMod04 ProgramTest ImgMod04Test.jpg</b></pre></p>
<p>Perhaps the most important thing about <a href="#Listing_21">Listing 21</a> is the fact that the class 
implements the interface named <b>ImgIntfc04</b>.&nbsp; All image processing 
classes must implement that interface to make them capable of being driven by 
the class named <b>ImgMod04</b>.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor for the class is shown in its entirety in 
<a name="Listing_22"><a href="#Listing_22">Listing 22</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  ProgramTest(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    Label instructions = new Label(
                         "Type a slope value and Replot.");
    add(instructions);

    inputField = new TextField("1.0",5);
    add(inputField);

    setTitle("Copyright 2006, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor<br><br><b><font face="Courier New,Courier"><a href="#Listing_22">Listing 22</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of the constructor is to construct the simple GUI shown in 
<a href="#Figure_3">Figure 
3</a>.&nbsp; The code in <a href="#Listing_22">Listing 22</a> is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>The method named processImg01</b></font></p>
<p>The method named <b>processImg01</b> must be defined to implement the <b>ImgIntfc04</b> interface.&nbsp; 
This is the first image processing method that is applied to the original image 
file that is specified on the <a href="#ImageFileName">command line</a>.</p>
<p>Note that this method must return references to two 3D array objects of type
<b>double</b> encapsulated in an object of the <b>ImgIntfc04Method01Output</b> class.&nbsp; That class is defined in the same source file that defines the interface named
<b>ImgIntfc04 </b><i>(see <a href="#Listing_29">Listing 29</a>)</i>.&nbsp; As you learned earlier, the 
data in one of the 3D array objects is displayed as the middle image in the 
displays shown in <a href="#Figure_4">Figure 4</a>.&nbsp; The reference to the other array is passed as 
a parameter to the second image processing method named <b>processImg02</b>.</p>
<p><font color="#FF0000"><b>Can be simple or complex</b></font></p>
<p>The method named <b>processImg01</b> can be as simple or as complex as 
needed.&nbsp; This test version is relatively simple.&nbsp; The version that I 
have developed to do the watermark work shown in <a href="#Figure_2">Figure 2</a> is much more complex.&nbsp;
<i>(I will publish and explain it in a future lesson.)</i></p>
<p><a href="#Listing_23">Listing 23</a> shows the beginning of the method named <b><a name="Listing_23">processImg01</a></b>.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public ImgIntfc04Method01Output 
                      processImg01(double[][][] threeDPix){
                              
    //Determine number of rows and cols
    int imgRows = threeDPix.length;
    int imgCols = threeDPix[0].length;

    //Display some interesting information
    System.out.println("Program test");
    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

    //Make a working copy of the 3D array to avoid making
    // permanent changes to the image data.
    double[][][] temp3D = copy3DArray(threeDPix);<br><br><b><font face="Courier New,Courier"><a href="#Listing_23">Listing 23</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_23">Listing 23</a> gets the dimensions of the image, displays some 
interesting information, and then invokes the method named <b>copy3DArray</b> to 
make a working copy of the 3D array to avoid making permanent changes to the 
original image data.&nbsp; The code in the method named <b>copy3DArray</b> is 
straightforward and shouldn't require further explanation.&nbsp; You can view 
that code in <a href="#Listing_28">Listing 28</a>.</p>
<p><font color="#FF0000"><b>Draw a white diagonal line</b></font></p>
<p>Next, the code in <a href="#Listing_24">Listing 24</a> gets a value for the slope of a line from the 
text field shown in <a href="#Figure_3">Figure 3</a> and uses that slope to draw a sloping white 
diagonal line on the image as shown by the middle image in the displays 
<a name="Listing_24">in</a> 
<a href="#Figure_4">Figure 4</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Get slope value from the TextField
    slope = Double.parseDouble(inputField.getText());

    //Draw a white diagonal line on the image.
    for(int col = 0;col &lt; imgCols;col++){
      int row = (int)(slope * col);
      if(row &gt; imgRows -1) break;
      //Set values for alpha, red, green, and
      // blue colors.
      temp3D[row][col][0] = 255.0;
      temp3D[row][col][1] = 255.0;
      temp3D[row][col][2] = 255.0;
      temp3D[row][col][3] = 255.0;

    }//end for loop<br><br><b><font face="Courier New,Courier"><a href="#Listing_24">Listing 24</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The three images in the left panel of <a href="#Figure_4">Figure 4</a> were drawn with the default 
slope value of 1.0.&nbsp; The three images in the right panel of <a href="#Figure_4">Figure 4</a> were 
drawn with a user-defined slope value of 0.5.</p>
<p><font color="#FF0000"><b>Invert the colors</b></font></p>
<p>You may have noticed that the line in the middle images of <a href="#Figure_4">Figure 4</a> is black 
instead of white.&nbsp; This is because the code in <a href="#Listing_25">Listing 25</a> invokes the 
method named <b>invertColors</b> to invert the colors in the image.&nbsp; Thus, 
white becomes black and the other colors are replaced by their inverted 
<a name="Listing_25">values</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    invertColors(temp3D);<br><br><b><font face="Courier New,Courier"><a href="#Listing_25">Listing 25</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I explained color inversion in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3512456">Processing 
Image Pixels, Color Intensity, Color Filtering, and Color Inversion</a>.&nbsp; 
Once you understand the general concept of color inversion, the method named <b>
invertColors</b> is straightforward and shouldn't require further explanation.&nbsp; 
The method can be viewed in its entirety in <a href="#Listing_28">Listing 28</a>.&nbsp; <i>(Note that the 
method does not invert the alpha values because that would cause an opaque image 
to become transparent.)</i></p>
<p><font color="#FF0000"><b>Return the required references</b></font></p>
<p><a href="#Listing_26">Listing 26</a> instantiates a new object of the <b>ImgIntfc04Method01Output</b> 
class encapsulating references to two 3D arrays of type <b><a name="Listing_26">double</a></b>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    return new ImgIntfc04Method01Output(temp3D,temp3D);
  }//end processImg01<br><br><b><font face="Courier New,Courier"><a href="#Listing_26">Listing 26</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Both references point to the same array object</b></font></p>
<p>In this case, both of the references passed to the constructor for the <b>
ImgIntfc04Method01Output</b> object refer to the same 3D array.&nbsp; This 
causes the array to be displayed in the middle images of <a href="#Figure_4">Figure 4</a> and also to be 
passed as input to the second processing method.</p>
<p><font color="#FF0000"><b>A second alternative</b></font></p>
<p>A second alternative is to apply two different processes to the original 
image within the first processing method and to return the results of those two 
processes as the two required references.&nbsp; I will illustrate that 
alternative in conjunction with the hidden watermark work <i>(see <a href="#Figure_2">Figure 2</a>)</i> 
that I will explain in a future lesson.</p>
<p><font color="#FF0000"><b>A third alternative</b></font></p>
<p>A third alternative would be to return a reference to a 3D array containing 
the data from the original image as one of the two required references.&nbsp; 
This would make it possible to cause the two image processing methods to apply 
different processes to the same original image data.&nbsp; I may also illustrate 
that alternative in a future lesson.</p>
<p><a href="#Listing_26">Listing 26</a> signals the end of the image processing method named <b>
processImg01</b>.</p>
<p><font color="#FF0000"><b>The image processing method named processImg02</b></font></p>
<p>The method named <b>processImg02</b> must also be defined to satisfy the 
interface named <b>ImgIntfc04</b>.&nbsp; This method is shown in its entirety in 
<a name="Listing_27"><a href="#Listing_27">Listing 27</a></a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public double[][][] processImg02(double[][][] threeDPix){
    
    //Make a working copy of the 3D array to avoid making
    // permanent changes to the image data.
    double[][][] temp3D = copy3DArray(threeDPix);

    //Invert the colors.  Don't invert the alpha value.
    invertColors(temp3D);

    return temp3D;
  }//end processImg02<br><br><b><font face="Courier New,Courier"><a href="#Listing_27">Listing 27</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method begins by making a working copy of the 3D array received as an 
incoming parameter.</p>
<p>Then it invokes the same method named <b>invertColors</b> described above to 
invert the colors in the image.&nbsp; This effectively cancels out the inversion 
performed earlier by the method named <b>processImg01</b> causing the returned 
image to consist of a white diagonal line on a background that matches the 
original image.&nbsp; This is illustrated by the two bottom images in <a href="#Figure_4">Figure 4</a>.&nbsp; 
The bottom image on the left shows a line with the default slope of 1.0.&nbsp; 
The bottom image on the right shows a line with a user-defined slope of 0.5.</p>
<p>And that concludes the discussion of the class named <b>ProgramTest</b>.<br>
</p>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code from <a href="#Listing_28">Listing 28</a>,
<a href="#Listing_29">Listing 29</a>, <a href="#Listing_30">Listing 30</a>, and
<a href="#Listing_31">Listing 31</a> into your text
editor.&nbsp; Compile the code and execute it.&nbsp; Experiment with it, making
changes, and observing the results of your changes.</p>
<p>For example, it might be useful to modify the display to cause the three 
images to be displayed in a side-by-side format across the screen rather than up 
and down the screen.</p>
<p>Another useful alternative would be to cause the three images to be displayed 
in independent frames to make it possible to move them around the screen 
independently of one another.</p>
<p>You might also want to try adding one or more additional processing stages so that 
more than two different processes can be applied to an image with the output 
from all processing stages being displayed.</p>
<p>You might want to modify the program to support the specification of two or 
more input images to make it possible to define processes that require more than 
one image <i>(such as morphing one image into another image for example)</i>.</p>
<p>Above all, have fun and learn as much as you can about image processing.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson I presented and explained a new image processing framework 
named <b>ImgMod04</b> that incorporates the following features:</p>
<ul>
	<li>The ability to perform two sequential pixel-modification processes <i>(instead of just one)</i> on an image and to display the modified image 
	resulting from each process in addition to displaying the original image.</li>
	<li>The ability to write two modified images into output files in 
	JPEG format.&nbsp; <i>(The names of the output files are <b>junk1.jpg</b> and 
	<b>junk2.jpg</b>.&nbsp; They are written into the current directory.)</i></li>
	<li>The elimination of several conversions back and forth between type <b>double</b> and type 
	<b>int</b>.&nbsp; All computations can now be performed as 
	type <b>double</b>, and the data is maintained as type <b>double</b> from 
	the initial conversion from <b>int</b> to <b>double</b> to the point where 
	the data is ready to be displayed and written into a JPEG file.</li>
	<li>The <b>Replot</b> button <i>(see <a href="#Figure_1">Figure 1</a>)</i> was moved to the top of 
	the display <i>(see <a href="#Figure_2">Figure 2</a>)</i> to make it accessible when the display is 
	too long to fit on the screen. <i>(For purposes of viewing the display in that case, the frame can be moved up and down on the screen using 
	the right mouse button and the up and down arrow keys, but the lower portion 
	of the bottom display still gets chopped off.)</i></li>
</ul>
<p>In addition, I provided another new image processing framework named <b>
ImgMod04a</b> that contains all of the features of <b>ImgMod04</b> except that 
it supports only one image processing method.</p>
<p>The most notable thing about this new class is that it replaces the earlier 
class named <b>ImgMod02a</b> with a class that writes the modified image into an 
output file in JPEG format.&nbsp; The name of the output file is <b>junk.jpg</b>.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>I plan to use the new image processing frameworks to continue publishing Java 
programming tutorials on interesting image processing topics.&nbsp; This will 
include lessons on the creation of both visible and hidden watermarks in the 
images.</p>
<h2 align="center"><a name="References">References</a></h2>
<p><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
Processing Image Pixels using Java, Getting Started&nbsp; <br>
<a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
Processing Image Pixels using Java, Creating a Spotlight&nbsp; <br>
<a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
Processing Image Pixels Using Java: Controlling Contrast and Brightness<br>
<a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
Processing Image Pixels, Color Intensity, Color Filtering, and Color Inversion
<br>
<a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
Processing Image Pixels, Performing Convolution on Images<br>
<a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
Processing Image Pixels, Understanding Image Convolution in Java<br>
<a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
Processing Image Pixels, Applying Image Convolution in Java, Part 1 <br>
<a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
<a href="http://www.developer.com/java/other/article.php/3619081">2444</a> Understanding the Discrete Cosine Transform&nbsp; in Java<br>
<a href="http://www.developer.com/java/data/article.php/3634156">2446</a> Understanding the 2D Discrete Cosine Transform in Java<br>
<a href="http://www.developer.com/java/data/article.php/3635451">2448</a> Understanding the 2D Discrete Cosine Transform in Java, Part 2</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
	Complete listings of the programs discussed in this lesson are shown in 
<a href="#Listing_28">Listing 28</a>, <a href="#Listing_29">Listing 29</a>,
<a href="#Listing_30">Listing 30</a>, and <a href="#Listing_31">Listing 31</a> <a name="Listing_28">below</a>. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod04.java
Copyright 2006, R.G.Baldwin

The purpose of this program is to make it easy to 
experiment with the modification of pixel data in an image
and to display two modified versions of the image along 
with the original image.

This program is an update of the earlier program named
ImgMod02a.  This update supports the following new 
features:

The ability to perform two sequential processes on an image
and to display the modified image resulting from each
process in addition to the original image.

The ability to write two modified images into output files 
in JPEG format.  The names of the output files are 
junk1.jpg and junk2.jpg.  They are written into the current
directory.

The elimination of several conversions back and forth
between type double and type int.  All computations are now
performed as type double, and the data is maintained as
type double from the initial conversion from int to double
to the point where it is ready to be displayed or written 
into a JPEG file.

The Replot button was moved to the top of the display to
make it accessible when the display is too long to fit
on the screen.  (For purposes of seeing the entire 
display in that case, it can be moved up and down on the
screen using the right mouse button and the up and down
arrow keys.)

The program extracts the pixel data from an image file into
a 3D array of type:

double[row][column][depth].

The first two dimensions of the array correspond to the 
rows and columns of pixels in the image.  The third 
dimension always has a value of 4 and contains the 
following values by index:

0 alpha
1 red
2 green
3 blue

Note that these values are stored as type double rather 
than type unsigned byte which is the format of pixel data 
in the original image file.  This type conversion 
eliminates many problems involving the requirement to 
perform unsigned arithmetic on unsigned byte data.

The program supports gif and jpg input files and possibly 
some other file types as well.  The output file is always
a JPEG file.

Operation:  This program provides a framework that is 
designed to invoke another program to process the pixels 
extracted from an image.  In other words, this program 
extracts the pixels and puts them in a format that is 
relatively easy to work with.  A second program is invoked
to actually process the pixels.  Typical usage is as 
follows:

java ImgMod04 ProcessingProgramName ImageFileName

For test and illustration purposes, the source code 
includes a class definition for an image processing program
named ProgramTest.

If the ImageFileName is not specified on the command line,
the program will search for an image file in the current 
directory named ImgMod04Test.jpg and will process it using
the processing program specified by the second command-
line argument.

If both command-line arguments are omitted, the program 
will search for an image file in the current directory 
named ImgMod04Test.jpg and will process it using the built-
in processing program named ProgramTest.  A complete
description of the behavior of the test program is provided
by comments in the source code for the class named
ProgramTest.

The image file must be provided by the user in all cases.
However,it doesn't have to be in the current directory if a
path to the file is specified on the command line.

When the program is started, the original image and two
processed versions of the image are displayed in a frame
with the original image above the two processed images.  A
Replot button appears at the top of the frame.  If the 
user clicks the Replot button, the image processing methods
are re-run on the original image.  The original image is 
reprocessed and the newly processed versions of the images 
replace the old versions.

The processing program may provide a  GUI for data input 
making it possible for the user to modify the behavior of 
the image processing methods each time they are run.  This
capability is illustrated by the built-in processing 
program named ProgramTest.

The image processing programming must implement the 
interface named ImgIntfc04.  That interface declares two
image processing methods with the following signatures:

ImgIntfc04Method01Output processImg01(double[][][] input);
                       
double[][][] processImg02(double[][][] input);

The first processing method must return references to two
3D double array objects encapsulated in an object of the
class ImgIntfc04Method01Output.  The class definition for
this class is contained in the same source code file as
the source code for the interface named ImgIntfc04.

The contents of the array referred to by one of the 
returned references is displayed as the middle image on the
main display panel.  The other reference is passed as a
parameter to the second processing method.  Depending on
the objectives, the two references may point to the same
or to different array objects.

The second processing method must return a reference to a
single 3D double array object.  The contents of the array
object are displayed in the bottom image, and are also 
written into an output file in JPEG format.

Both processing methods receive a reference to a 3D double
array object containing image pixel data in the format
described earlier.

The image processing program cannot have a parameterized 
constructor.  This is because an object of the class is 
instantiated by invoking the newInstance method of the 
class named Class on the name of the image processing 
program provided as a String on the command line.  This
approach to object instantiation does not allow 
parameterized constructors.

If the image processing program has a main method, it will
be ignored.

The processImg methods receive a 3D array containing pixel
data.  They should make a copy of the incoming array and 
modify the copy rather than modifying the original.  Then 
the programs should return references to the modified 
copies of the 3D pixel arrays.

The processImg methods are free to modify the values of the
pixels in the incoming array in any manner before returning
reference to the modified arrays.  Note however that 
native pixel data consists of four unsigned bytes.  If the
modification of the pixel data produces negative values or
positive value greater than 255, this should be dealt with
before returning the modified pixel data.  Otherwise, the
results of displaying the modified pixel data may not be as
 expected.

There are at least two ways to deal with this situation.  
One way is to simply clamp all negative values at zero and
to clamp all values greater than 255 at 255.  The other way
is to perform a further modification so as to map the
range from -x to +y into the range from 0 to 255.  There is
no single correct way for all situations.

When the processImg methods return, this program causes the
original image and the modified images to be displayed in a
frame on the screen with the original image above the 
modified images.

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

Tested using J2SE5.0 under WinXP.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.io.*;
import javax.imageio.*;

class ImgMod04 extends Frame{
  Image rawImg;//A reference to the raw image.
  int imgCols;//Number of horizontal pixels
  int imgRows;//Number of rows of pixels
  Image modImgA;//Reference to first modified image
  Image modImgC;//Reference to third modified image

  //Default image processing program.  This class will be
  // executed to process the image if the name of another
  // class is not entered on the command line.  Note that
  // the source code for this class file is included in
  // this source code file.
  static String theProcessingClass = "ProgramTest";

  //Default image file name.  This image file will be
  // processed if another file name is not entered on the
  // command line.  You must provide this file in the
  // current directory if it is going to be processed.
  static String theImgFile = "ImgMod04Test.jpg";

  MediaTracker tracker;
  Display display = new Display();//A Canvas object
  Button replotButton = new Button("Replot");

  //Reference to the image processing object.
  ImgIntfc04 imageProcessingObject;
  //-----------------------------------------------------//

  public static void main(String[] args){
    //Get names for the image processing class and the
    // image file to be processed.  Program supports gif
    // files and jpg files and possibly some other file
    // types as well.
    if(args.length == 0){
      //Use default processing class and default image
      // file.  Class and file names were specified above.
    }else if(args.length == 1){
      theProcessingClass = args[0];
      //Use default image file along with this class.
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and image file.
    System.out.println(
              "Processing program: " + theProcessingClass);
    System.out.println("Image file: " + theImgFile);

    //Instantiate an object of this class.
    ImgMod04 obj = new ImgMod04();
  }//end main
  //-------------------------------------------//

  public ImgMod04(){//constructor
    //Get an image from the specified image file.  Can be
    // in a different directory if the path was entered
    // with the file name on the  command line.  This local
    // variable must be declared final because it is
    // accessed from within an anonymous inner class.
    final double[][][] threeDPix = getTheImage();
    
    //Construct the display object.
    this.setTitle("Copyright 2006, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.NORTH);
    
    //Make the frame visible so as to make it possible to
    // get insets and the height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and the height
    // of the button.
    int inTop = this.getInsets().top;
    int inLeft = this.getInsets().left;
    int buttonHeight = replotButton.getSize().height;
    
    //Size the frame so that a small amount of yellow
    // background will show on the right, between the
    // images, and on the bottom when all three images are
    // displayed, one above the other.
    this.setSize(2*inLeft+imgCols + 2,inTop
                           + buttonHeight + 3*imgRows + 9);

    //===================================================//
    //Anonymous inner class listener for Replot button.
    // This actionPerformed method is invoked when the user
    // clicks the Replot button.  It is also invoked at
    // startup  when this program posts an ActionEvent to
    // the system event queue attributing the event to the
    // Replot button.
    replotButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Pass a 3D array of pixel data to the first
          // processing method.  This method returns two 3D
          // arrays of pixel data, outputA and outputB
          // encapsulated in an object of type
          // ImgIntfc04Method01Output.
          //The contents of outputA are displayed as the
          // middle image in the display.  The contents of
          // outputB are passed along to the second
          // processing method, which returns a single 3D
          // array of pixel data.
          //The contents of outputA are also written into
          // an output JPEG file named junk1.jpg.
          //The contents of the array returned by the 
          // second processing method are displayed as the
          // bottom image in the display.
          //The contents of that array are also written
          // into an output JPEG file named junk2.jpg.
          //To cause the same 3D array to be displayed in
          // the middle and also to be passed into the
          // second processing method, write the first
          // processing method return two references to the
          // same 3D array.
          ImgIntfc04Method01Output output = 
             imageProcessingObject.processImg01(threeDPix);
          //Extract the references to the two 3D array
          // objects of type double from the returned
          // object.
          double[][][] threeDPixModA = output.outputA;
          double[][][] threeDPixModB = output.outputB;
          
          //Pass the contents of outputB to the second
          // processing method.
          double[][][] threeDPixModC = 
                        imageProcessingObject.processImg02(
                                            threeDPixModB);
          
          //Now prepare the two pixel arrays for display.

          //Convert one 3D array of modified pixel data of
          // type double to a 1D array of pixel data of
          // type int.  This 1D array is in a standard
          // pixel format.  See a brief description of the
          // format in the comments in the method named
          // convertTo1D.
          int[] oneDPixA = convertTo1D(threeDPixModA);
          //Use the createImage() method of the Component
          // class to create a new Image object from the
          // 1D array of pixel data.  Note that
          // MemoryImageSource implements the
          // ImageProducer interface and therefore
          // satisfies one of the overloaded versions of
          // the createImage method.
          modImgA = createImage(new MemoryImageSource(
                      imgCols,imgRows,oneDPixA,0,imgCols));
          
          //Convert the other array of modified pixel data
          // to a 1D array of pixel data using the same
          // methodology.
          int[] oneDPixC = convertTo1D(threeDPixModC);
          modImgC = createImage(new MemoryImageSource(
                      imgCols,imgRows,oneDPixC,0,imgCols));
          
          //Repaint the image display frame with the
          // original image at the top and the modified
          // images in the center and at the bottom.
          display.repaint();

          //Write the middle modified image into a JPEG
          // file named junk1.jpg
          writeJpegFile(modImgA,imgCols,imgRows,
                                              "junk1.jpg");
          
          //Write the final modified image into a JPEG
          // file named junk2.jpg.
          writeJpegFile(modImgC,imgCols,imgRows,
                                              "junk2.jpg");

        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class registered on the Replot
    // button.
    //===================================================//
    
    //Continuing with the constructor code ...
    
    //Instantiate a new object of the image processing
    // class.  Note that this object is instantiated using
    // the newInstance method of the class named Class.
    // This approach does not allow for the use of a
    // parameterized constructor.
    try{
      imageProcessingObject = (ImgIntfc04)Class.forName(
                         theProcessingClass).newInstance();

       //Post a counterfit ActionEvent to the system event
       // queue and attribute it to the Replot button.
       // (See the anonymous ActionListener class that
       // registers an ActionListener object on the RePlot
       // button above.)  Posting this event causes the
       // two image processing methods to be invoked in
       // sequence at startup and causes the modified
       // images to be displayed.
      Toolkit.getDefaultToolkit().getSystemEventQueue().
        postEvent(
          new ActionEvent(replotButton,
                          ActionEvent.ACTION_PERFORMED,
                          "Replot")
        );//end postEvent method

      //At this point, the image has been processed.  The
      // original image and both modified images have been
      // displayed.  From this point forward, each time the
      // user clicks the Replot button, the image will be
      // processed again and the new modified images will
      // be displayed along with the original image.

    }catch(Exception e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Cause the composite of the frame, the canvas, and the
    // button to become visible.
    this.setVisible(true);
    //===================================================//

    //Anonymous inner class listener to terminate
    // program.
    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //===================================================//

  }//end constructor
  //=====================================================//

  //Inner class for canvas object on which to display the
  // three images.
  class Display extends Canvas{
    //Override the paint method to display the rawImg and
    // the two modified images on the same Canvas object,
    // separated by a couple of rows of pixels in the
    // background color.
    public void paint(Graphics g){
      //First confirm that the image has been completely
      // loaded and that none of the image references are
      // null.
      if (tracker.statusID(1,false) ==
                                    MediaTracker.COMPLETE){
        if((rawImg != null) && 
           (modImgA != null) && 
           (modImgC != null)){
          g.drawImage(rawImg,0,0,this);
          g.drawImage(modImgA,0,imgRows + 2,this);
          g.drawImage(modImgC,0,2*imgRows + 4, this);
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas
//=======================================================//

  //Save pixel values as type double to make
  // arithmetic easier later.

  //The purpose of this method is to convert the data in
  // the int oneDPix array into a 3D array of type double.
  //The dimensions of the 3D array are row, col, and color
  // in that order.
  //Row and col correspond to the rows and columns of the
  // pixels in the image.  Color corresponds to
  // transparency and color information at the following
  // index levels in the third dimension:
  // 0 alpha (tranparency)
  // 1 red
  // 2 green
  // 3 blue
  // The structure of this code is determined by the way
  // that the pixel data is formatted into the 1D array of
  // pixel data of type int when the image file is read.
  double[][][] convertTo3D(
                    int[] oneDPix,int imgCols,int imgRows){
    //Create the new 3D array to be populated with pixwl
    // data.
    double[][][] data = new double[imgRows][imgCols][4];

    for(int row = 0;row &lt; imgRows;row++){
      //Extract a row of pixel data into a temporary array
      // of ints
      int[] aRow = new int[imgCols];
      for(int col = 0; col &lt; imgCols;col++){
        int element = row * imgCols + col;
        aRow[col] = oneDPix[element];
      }//end for loop on col

      //Move the data into the 3D array.  Note the use of
      // bitwise AND and bitwise right shift operations to
      // mask all but the correct set of eight bits.
      for(int col = 0;col &lt; imgCols;col++){
        //Alpha data
        data[row][col][0] = (aRow[col] &gt;&gt; 24) & 0xFF;
        //Red data
        data[row][col][1] = (aRow[col] &gt;&gt; 16) & 0xFF;
        //Green data
        data[row][col][2] = (aRow[col] &gt;&gt; 8)  & 0xFF;
        //Blue data
        data[row][col][3] = (aRow[col]) & 0xFF;
      }//end for loop on col
    }//end for loop on row
    return data;
  }//end convertTo3D
  //-------------------------------------------//

  //The purpose of this method is to convert the data in
  // the 3D array of type double back into the a 1d array
  // of type int.  This is the reverse of the method named
  // convertTo3D.  Note that the data values are clamped at
  // 0 and 255 before casting to type int.
  int[] convertTo1D(double[][][] data){
    int imgRows = data.length;
    int imgCols = data[0].length;

    //Create the 1D array of type int to be populated with
    // pixel data, one int value per pixel, with four
    // color and alpha bytes per int value.
    int[] oneDPix = new int[imgCols * imgRows * 4];

    //Move the data into the 1D array.  Note the use of the
    // bitwise OR operator and the bitwise left-shift
    // operators to put the four 8-bit bytes into each int.
    // Also note that the values are clamped at 0 and 255.
    for(int row = 0,cnt = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        if(data[row][col][0] &lt; 0) data[row][col][0] = 0;
        if(data[row][col][0] &gt; 255) data[row][col][0]=255;
        if(data[row][col][1] &lt; 0) data[row][col][1] = 0;
        if(data[row][col][1] &gt; 255) data[row][col][1]=255;
        if(data[row][col][2] &lt; 0) data[row][col][2] = 0;
        if(data[row][col][2] &gt; 255) data[row][col][2]=255;
        if(data[row][col][3] &lt; 0) data[row][col][3] = 0;
        if(data[row][col][3] &gt; 255) data[row][col][3]=255;
        
        oneDPix[cnt] = (((int)data[row][col][0] &lt;&lt; 24)
                                             & 0xFF000000)
                     | (((int)data[row][col][1] &lt;&lt; 16)
                                             & 0x00FF0000)
                      | (((int)data[row][col][2] &lt;&lt; 8)
                                             & 0x0000FF00)
                           | (((int)data[row][col][3])
                                             & 0x000000FF);
        cnt++;
      }//end for loop on col
    }//end for loop on row

    return oneDPix;
  }//end convertTo1D
  //-----------------------------------------------------//

  //Write the contents of an Image object to a JPEG file
  // with the name specified by the incoming parameter
  // fileName.
  void writeJpegFile(Image img,int width,int height,
                                          String fileName){
    //Create an off-screen drawable image by calling the
    // createImage method of the Component class.  Cast
    // it to type BufferedImage.
    BufferedImage bufferedImg = 
                  (BufferedImage)createImage(width,height);
    
    //Call the createGraphics method of the BufferedImage
    // class to create a Graphics2D object, which can be
    // used to draw into the BufferedImage object.
    Graphics2D bufferedGraphics = 
                              bufferedImg.createGraphics();
    
    //Call the drawImage method of the Graphics class to
    // draw the image into the off-screen buffer.  Pass
    // null as the ImageObserver.
    bufferedGraphics.drawImage(img,0,0,null);
    
    try{
      //Get a file output stream.
      FileOutputStream outStream = 
                            new FileOutputStream(fileName);
      //Call the write method of the ImageIO class to write
      // the contents of the BufferedImage object to an
      // output file in JPEG format.
      ImageIO.write(bufferedImg,"jpeg",outStream);
      outStream.close();
    }catch (Exception e) {
      e.printStackTrace();
    }//end catch
  }//end writeJpegFile
  //-----------------------------------------------------//
  
  //This method reads an image from a specified image file
  // and converts the pixel data into a 3D array of type
  // double.  The name of the image file is specified as
  // a String by theImgFile.
  double[][][] getTheImage(){
    rawImg = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImg,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if

    //Raw image has been loaded.  Get width and height of
    // the raw image.
    imgCols = rawImg.getWidth(this);
    imgRows = rawImg.getHeight(this);

    //Create a 1D array object to receive the pixel
    // representation of the image
    int[] oneDPix = new int[imgCols * imgRows];

    //Create an empty BufferedImage object
    BufferedImage buffImage = new BufferedImage(
                              imgCols,
                              imgRows,
                              BufferedImage.TYPE_INT_ARGB);

    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImg, 0, 0, null);

    //Convert the BufferedImage to numeric pixel
    // representation.
    DataBufferInt dataBufferInt =
                      (DataBufferInt)buffImage.getRaster().
                                           getDataBuffer();
    oneDPix = dataBufferInt.getData();

    //Convert the pixel byte data in the 1D array to
    // double data in a 3D array to make it easier to work
    // with the pixel data later.  Recall that pixel data
    // is unsigned byte data and Java does not support
    // unsigned arithmetic. Performing unsigned arithmetic
    // on byte data is particularly cumbersome.
    return convertTo3D(oneDPix,imgCols,imgRows);
  }//end getTheImage
  //-----------------------------------------------------//
}//end ImgMod04.java class
//=======================================================//

//The ProgramTest class

//The purpose of this class is to provide a simple example
// of an image processing class that is compatible with the
// use of the class program named ImgMod04 and the
// interface named ImgIntfc04.

//The constructor for the class displays a small frame on
// the screen with a single textfield. The purpose of the
// text field is to allow the user to enter a value that
// represents the slope of a line.  In operation, the user
// types a value into the text field and then clicks the
// Replot button on the main image display frame.  The user
// is not required to press the Enter key after typing the
// new value, but it doesn't do any harm to do so.  
// Negative slopes are not supported.  An attempt to use
// a negative slope will cause the program to abort with 
// an error.

//The method named processImage01 receives a 3D array of
// type double containing alpha, red, green, and blue
// values for an image.

// The 3D array that is received by processImg01 is
// modified by the method to cause a white diagonal line to
// be drawn down and to the right from the upper left
// corner of the image.  The slope of the line is
// controlled by the value in the text field.  Initially,
// this value is 1.0, but the value can be modified by the
// user.  (If the characters in the text field cannot be
// converted to a numeric type double, the program will
// abort with an error.)
//After drawing the line, the method inverts the colors in
// the image.  This results in a black line on an image
// with inverted colors.

//The method named processImg01 is required to return
// references to two 3D array objects of type double
// encapsulated in an object of type
// ImgIntfc04Method01Output.  This version of the method
// returns two references to the same modified pixel array,
// but that is not necessary.  The method could return
// references to two different pixel arrays.

//The data in the 3D array referenced by the value stored
// in the variable named objectA of the returned object is
// displayed as the center image of the main image display
// by the code in the class named ImgMod04. The reference
// stored in the variable named objectB of the returned
// object is passed as a parameter to the method named
// processImg02 by the code in the class named ImgMod04.
// In this version of the method,both references point to
// the same 3D array object, so the same reference is
// displayed and also passed to the processImg02 method.

//The method named processImg02 receives an incoming 3D
// array of type double containing pixel data and returns
// one reference to a 3D array of type double containing
// pixel data.  This version of the method performs a
// color inversion on the data and returns a reference to
// the modified array.  This reverses the color inversion
// performed by processImg01, causing the bottom image to
// match the original image except that it has a white
// diagonal line drawn on it.

//To cause a new line to be drawn, type a new slope
// value into the text field and click the Replot button
// at the top of the main image display frame.

//This class extends Frame.  However, a compatible class is
// not required to extend the Frame class. This example
// extends Frame because it provides a GUI for user data
// input.

//A compatible class is required to implement the
// interface named ImgIntfc04.

class ProgramTest extends Frame implements ImgIntfc04{

  double slope;//Controls the slope of the line
  String inputData;//Obtained via the TextField
  TextField inputField;//Reference to TextField

  //Constructor must take no parameters
  ProgramTest(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    Label instructions = new Label(
                         "Type a slope value and Replot.");
    add(instructions);

    inputField = new TextField("1.0",5);
    add(inputField);

    setTitle("Copyright 2006, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor
  //-----------------------------------------------------//

  //The following method must be defined to implement the
  // ImgIntfc04 interface.  Note that this method must
  // return references to two 3D array objects of type
  // double encapsulated in an object of the 
  // ImgIntfc04Method01Output class.  That class is defined
  // in the same source file that defines the interface
  // named ImgIntfc04.
  public ImgIntfc04Method01Output 
                      processImg01(double[][][] threeDPix){
                              
    //Determine number of rows and cols
    int imgRows = threeDPix.length;
    int imgCols = threeDPix[0].length;

    //Display some interesting information
    System.out.println("Program test");
    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

    //Make a working copy of the 3D array to avoid making
    // permanent changes to the image data.
    double[][][] temp3D = copy3DArray(threeDPix);

    //Get slope value from the TextField
    slope = Double.parseDouble(inputField.getText());

    //Draw a white diagonal line on the image.
    for(int col = 0;col &lt; imgCols;col++){
      int row = (int)(slope * col);
      if(row &gt; imgRows -1) break;
      //Set values for alpha, red, green, and
      // blue colors.
      temp3D[row][col][0] = 255.0;
      temp3D[row][col][1] = 255.0;
      temp3D[row][col][2] = 255.0;
      temp3D[row][col][3] = 255.0;

    }//end for loop
    
    //Invert the colors.  Do not invert the alpha value.
    invertColors(temp3D);
    
    //Return two references to the same array of image
    // data.
    return new ImgIntfc04Method01Output(temp3D,temp3D);
  }//end processImg01
  //-----------------------------------------------------//
  
  //The following method must be defined to
  // implement the ImgIntfc04 interface.
  public double[][][] processImg02(double[][][] threeDPix){
    
    //Make a working copy of the 3D array to avoid making
    // permanent changes to the image data.
    double[][][] temp3D = copy3DArray(threeDPix);

    //Invert the colors.  Don't invert the alpha value.
    invertColors(temp3D);

    return temp3D;
  }//end processImg02
  //-----------------------------------------------------//
  
  //This method copies a double version of a 3D pixel array
  // to an new pixel array of type double.
  double[][][] copy3DArray(double[][][] threeDPix){
    int imgRows = threeDPix.length;
    int imgCols = threeDPix[0].length;
    
    double[][][] new3D = new double[imgRows][imgCols][4];
    for(int row = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        new3D[row][col][0] = threeDPix[row][col][0];
        new3D[row][col][1] = threeDPix[row][col][1];
        new3D[row][col][2] = threeDPix[row][col][2];
        new3D[row][col][3] = threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop
    return new3D;
  }//end copy3DArray
  //-----------------------------------------------------//
  
  //This method inverts the colors in a double version of a
  // 3D array of pixel data.  It doesn't invert the alpha
  // value.
  void invertColors(double[][][] data3D){
    int imgRows = data3D.length;
    int imgCols = data3D[0].length;
    //Invert the colors.  Don't invert the alpha value.
    for(int row = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        data3D[row][col][1] = 255 - data3D[row][col][1];
        data3D[row][col][2] = 255 - data3D[row][col][2];
        data3D[row][col][3] = 255 - data3D[row][col][3];
      }//end inner loop
    }//end outer loop
  }//end invertColors
  //-----------------------------------------------------//
}//end class ProgramTest
<br><br><b><font face="Courier New,Courier"><a href="#Listing_28">Listing 28</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_29"><a href="#Listing_29">Listing 29</a></a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgIntfc04.java
Copyright 2006, R.G.Baldwin

The purpose of this interface is to declare the two
methods required by image processing classes that are 
compatible with the program named ImgMod04.java.

Note that this interface was modified relative to the 
interface named ImgIntfc02 to deal only with image pixel 
data as type double instead of type int.

Tested using J2SE 5.0 under WinXP
**********************************************************/

interface ImgIntfc04{
  ImgIntfc04Method01Output processImg01(
                                       double[][][] input);
                       
  double[][][] processImg02(double[][][] input);
}//end ImgIntfc04
//=======================================================//

//This class makes it possible for the method named
// processImg01 to return two references to 3D array object
// of type double.
class ImgIntfc04Method01Output{
  public double[][][] outputA;
  public double[][][] outputB;
  
  //Constructor
  public ImgIntfc04Method01Output(double[][][] outputA,
                                  double[][][] outputB){
    this.outputA = outputA;
    this.outputB = outputB;
  }//end constructor
}//end class ImgIntfc04Method01Output
//=======================================================//<br><br><b><font face="Courier New,Courier"><a href="#Listing_29">Listing 29</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_30" href="#Listing_30">Listing 30</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod04a.java
Copyright 2006, R.G.Baldwin

This is a modification to the class named ImgMod04 that 
eliminates the use of a second image-processing method.  
Otherwise, it is identical to the class named ImgMod04.

Note that some of the comments may not have been updated to
reflect the modifications.

The purpose of this program is to make it easy to 
experiment with the modification of pixel data in an image
and to display a modified version of the image along 
with the original image.

This program is an update of the earlier program named
ImgMod02a.  This update supports the following new 
features:

The ability to write the modified image into an
output file in JPEG format.  The name of the output file
is junk.jpg and it is written into the current directory.

The elimination of several conversions back and forth
between type double and type int.  All computations are now
performed as type double, and the data is maintained as
type double from the initial conversion from int to double
to the point where it is ready to be displayed or written 
into a JPEG file.

The Replot button was moved to the top of the display to
make it accessible when the display is too long to fit
on the screen.  (For purposes of seeing the entire 
display in that case, it can be moved up and down on the
screen using the right mouse button and the up and down
arrow keys.)

The program extracts the pixel data from an image file into
a 3D array of type:

double[row][column][depth].

The first two dimensions of the array correspond to the 
rows and columns of pixels in the image.  The third 
dimension always has a value of 4 and contains the 
following values by index:

0 alpha
1 red
2 green
3 blue

Note that these values are stored as type double rather 
than type unsigned byte which is the format of pixel data 
in the original image file.  This type conversion 
eliminates many problems involving the requirement to 
perform unsigned arithmetic on unsigned byte data.

The program supports gif and jpg input files and possibly 
some other file types as well.  The output file is always
a JPEG file.

Operation:  This program provides a framework that is 
designed to invoke another program to process the pixels 
extracted from an image.  In other words, this program 
extracts the pixels and puts them in a format that is 
relatively easy to work with.  A second program is invoked
to actually process the pixels.  Typical usage is as 
follows:

java ImgMod04a ProcessingProgramName ImageFileName

For test and illustration purposes, the source code 
includes a class definition for an image processing program
named ProgramTestA.

If the ImageFileName is not specified on the command line,
the program will search for an image file in the current 
directory named ImgMod04aTest.jpg and will process it using
the processing program specified by the second command-
line argument.

If both command-line arguments are omitted, the program 
will search for an image file in the current directory 
named ImgMod04aTest.jpg and will process it using the built
in processing program named ProgramTestA.  A complete
description of the behavior of the test program is provided
by comments in the source code for the class named
ProgramTestA.

The image file must be provided by the user in all cases.
However, it doesn't have to be in the current directory if
a path to the file is specified on the command line.

When the program is started, the original image and one
processed version of the image are displayed in a frame
with the original image above the processed image.  A
Replot button appears at the top of the frame.  If the 
user clicks the Replot button, the image processing method
is re-run on the original image.  The original image is 
reprocessed and the new processed version of the image 
replaces the old version.

The processing program may provide a  GUI for data input 
making it possible for the user to modify the behavior of 
the image processing method each time it is run.  This
capability is illustrated in the built-in processing 
program named ProgramTestA.

The image processing program must implement the 
interface named ImgIntfc04a.  That interface declares an
image processing method with the following signature:

double[][][]  processImg(double[][][] input);

The image processing method must return a reference to a
3D double array object.

The processing method receives a reference to a 3D double
array object containing image pixel data in the format
described earlier.

The image processing program cannot use a parameterized 
constructor.  This is because an object of the class is 
instantiated by invoking the newInstance method of the 
class named Class on the name of the image processing 
program provided as a String on the command line.  This
approach to object instantiation does not support 
parameterized constructors.

If the image processing program has a main method, it will
be ignored.

The processImg method receive a 3D array containing pixel
data.  It should make a copy of the incoming array and 
modify the copy rather than modifying the original.  Then 
the method should return a reference to the modified 
copy of the 3D pixel array.

The processImg method is free to modify the values of the
pixels in the incoming array in any manner before returning
reference to the modified array.  Note however that 
native pixel data consists of four unsigned bytes.  If the
modification of the pixel data produces negative values or
positive value greater than 255, this should be dealt with
before returning the modified pixel data.  Otherwise, the
results of displaying the modified pixel data may not be as
expected.

There are at least two ways to deal with this situation.  
One way is to simply clamp all negative values at zero and
to clamp all values greater than 255 at 255.  The other way
is to perform a further modification so as to map the
range from -x to +y into the range from 0 to 255.  There is
no single correct way for all situations.

When the processImg method returns, this program causes the
original image and the modified image to be displayed in a
frame on the screen with the original image above the 
modified image.

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

Tested using J2SE5.0 under WinXP.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.io.*;
import javax.imageio.*;

class ImgMod04a extends Frame{
  Image rawImg;//A reference to the raw image.
  int imgCols;//Number of horizontal pixels
  int imgRows;//Number of rows of pixels
  Image modImg;//Reference to modified image

  //Default image processing program.  This class will be
  // executed to process the image if the name of another
  // class is not entered on the command line.  Note that
  // the source code for this class file is included in
  // this source code file.
  static String theProcessingClass = "ProgramTestA";

  //Default image file name.  This image file will be
  // processed if another file name is not entered on the
  // command line.  You must provide this file in the
  // current directory if it is going to be processed.
  static String theImgFile = "ImgMod04aTest.jpg";

  MediaTracker tracker;
  Display display = new Display();//A Canvas object
  Button replotButton = new Button("Replot");

  //Reference to the image processing object.
  ImgIntfc04a imageProcessingObject;
  //-----------------------------------------------------//

  public static void main(String[] args){
    //Get names for the image processing class and the
    // image file to be processed.  Program supports gif
    // files and jpg files and possibly some other file
    // types as well.
    if(args.length == 0){
      //Use default processing class and default image
      // file.  Class and file names were specified above.
    }else if(args.length == 1){
      theProcessingClass = args[0];
      //Use default image file along with this class.
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and image file.
    System.out.println(
              "Processing program: " + theProcessingClass);
    System.out.println("Image file: " + theImgFile);

    //Instantiate an object of this class.
    ImgMod04a obj = new ImgMod04a();
  }//end main
  //-------------------------------------------//

  public ImgMod04a(){//constructor
    //Get an image from the specified image file.  Can be
    // in a different directory if the path was entered
    // with the file name on the  command line.  This local
    // variable mustbe declared final because it is
    // accessed from within an anonymous inner class.
    final double[][][] threeDPix = getTheImage();
    
    //Construct the display object.
    this.setTitle("Copyright 2006, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.NORTH);
    
    //Make the frame visible so as to make it possible to
    // get insets and the height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and the height
    // of the button.
    int inTop = this.getInsets().top;
    int inLeft = this.getInsets().left;
    int buttonHeight = replotButton.getSize().height;
    
    //Size the frame so that a small amount of yellow
    // background will show on the right, between the
    // images, and on the bottom when both images are
    // displayed, one above the other.
    this.setSize(2*inLeft+imgCols + 2,inTop
                           + buttonHeight + 2*imgRows + 8);

    //===================================================//
    //Anonymous inner class listener for Replot button.
    // This actionPerformed method is invoked when the user
    // clicks the Replot button.  It is also invoked at
    // startup  when this program posts an ActionEvent to
    // the system event queue attributing the event to the
    // Replot button.
    replotButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Pass a 3D array of pixel data to the 
          // processing method.  This method returns one 3D
          // array of pixel data.
          //The contents of output array are displayed as
          // the second image in the display.
          //The contents of the output array are also
          // written into an output JPEG file named
          // junk.jpg.
          double[][][] threeDPixModA = 
               imageProcessingObject.processImg(threeDPix);
          //Now prepare the pixel array for display.

          //Convert the 3D array of modified pixel data of
          // type double to a 1D array of pixel data of
          // type int.  This 1D array is in a standard
          // pixel format.  See a brief description of the
          // format in the comments in the method named
          // convertTo1D.
          int[] oneDPixA = convertTo1D(threeDPixModA);
          //Use the createImage() method of the Component
          // class to create a new Image object from the
          // 1D array of pixel data.  Note that
          // MemoryImageSource implements the
          // ImageProducer interface and therefore
          // satisfies one of the overloaded versions of
          // the createImage method.
          modImg = createImage(new MemoryImageSource(
                      imgCols,imgRows,oneDPixA,0,imgCols));
       
          //Repaint the image display frame with the
          // original image at the top and the modified
          // image at the bottom.
          display.repaint();
          
          //Write the modified image into a JPEG
          // file named junk.jpg.
          writeJpegFile(modImg,imgCols,imgRows);
                      
          
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class registered on the Replot
    // button.
    //===================================================//
    
    //Continuing with the constructor code ...
    
    //Instantiate a new object of the image processing
    // class.  Note that this object is instantiated using
    // the newInstance method of the class named Class.
    // This approach does not allow for the use of a
    // parameterized constructor.
    try{
      imageProcessingObject = (ImgIntfc04a)Class.forName(
                         theProcessingClass).newInstance();

       //Post a counterfeit ActionEvent to the system event
       // queue and attribute it to the Replot button.
       // (See the anonymous ActionListener class that
       // registers an ActionListener object on the RePlot
       // button above.)  Posting this event causes the
       // image processing method to be invoked at startup
       // and causes the modified image to be displayed.
      Toolkit.getDefaultToolkit().getSystemEventQueue().
        postEvent(
          new ActionEvent(replotButton,
                          ActionEvent.ACTION_PERFORMED,
                          "Replot")
        );//end postEvent method

      //At this point, the image has been processed.  The
      // original image and the modified image have been
      // displayed.  From this point forward, each time the
      // user clicks the Replot button, the image will be
      // processed again and the new modified image will
      // be displayed along with the original image.

    }catch(Exception e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Cause the composite of the frame, the canvas, and the
    // button to become visible.
    this.setVisible(true);
    //===================================================//

    //Anonymous inner class listener to terminate
    // program.
    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //===================================================//

  }//end constructor
  //=====================================================//

  //Inner class for canvas object on which to display the
  // two images.
  class Display extends Canvas{
    //Override the paint method to display the rawImg and
    // the modified image on the same Canvas object,
    // separated by a couple of rows of pixels in the
    // background color.
    public void paint(Graphics g){
      //First confirm that the image has been completely
      // loaded and that none of the image references are
      // null.
      if (tracker.statusID(1,false) ==
                                    MediaTracker.COMPLETE){
        if((rawImg != null) && 
           (modImg != null)){
          g.drawImage(rawImg,0,0,this);
          g.drawImage(modImg,0,imgRows + 2,this);
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas
//=======================================================//

  //Save pixel values as type double to make
  // arithmetic easier later.

  //The purpose of this method is to convert the data in
  // the int oneDPix array into a 3D array of type double.
  //The dimensions of the 3D array are row, col, and color
  // in that order.
  //Row and col correspond to the rows and columns of the
  // pixels in the image.  Color corresponds to
  // transparency and color information at the following
  // index levels in the third dimension:
  // 0 alpha (tranparency)
  // 1 red
  // 2 green
  // 3 blue
  // The structure of this code is determined by the way
  // that the pixel data is formatted into the 1D array of
  // pixel data of type int when the image file is read.
  double[][][] convertTo3D(
                    int[] oneDPix,int imgCols,int imgRows){
    //Create the new 3D array to be populated with pixwl
    // data.
    double[][][] data = new double[imgRows][imgCols][4];

    for(int row = 0;row &lt; imgRows;row++){
      //Extract a row of pixel data into a temporary array
      // of ints
      int[] aRow = new int[imgCols];
      for(int col = 0; col &lt; imgCols;col++){
        int element = row * imgCols + col;
        aRow[col] = oneDPix[element];
      }//end for loop on col

      //Move the data into the 3D array.  Note the use of
      // bitwise AND and bitwise right shift operations to
      // mask all but the correct set of eight bits.
      for(int col = 0;col &lt; imgCols;col++){
        //Alpha data
        data[row][col][0] = (aRow[col] &gt;&gt; 24) & 0xFF;
        //Red data
        data[row][col][1] = (aRow[col] &gt;&gt; 16) & 0xFF;
        //Green data
        data[row][col][2] = (aRow[col] &gt;&gt; 8)  & 0xFF;
        //Blue data
        data[row][col][3] = (aRow[col]) & 0xFF;
      }//end for loop on col
    }//end for loop on row
    return data;
  }//end convertTo3D
  //-----------------------------------------------------//

  //The purpose of this method is to convert the data in
  // the 3D array of type double back into the a 1d array
  // of type int.  This is the reverse of the method named
  // convertTo3D.  Note that the data values are clamped at
  // 0 and 255 before casting to type int.
  int[] convertTo1D(double[][][] data){
    int imgRows = data.length;
    int imgCols = data[0].length;

    //Create the 1D array of type int to be populated with
    // pixel data, one int value per pixel, with four
    // color and alpha bytes per int value.
    int[] oneDPix = new int[imgCols * imgRows * 4];

    //Move the data into the 1D array.  Note the use of the
    // bitwise OR operator and the bitwise left-shift
    // operators to put the four 8-bit bytes into each int.
    // Also note that the values are clamped at 0 and 255.
    for(int row = 0,cnt = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        if(data[row][col][0] &lt; 0) data[row][col][0] = 0;
        if(data[row][col][0] &gt; 255) data[row][col][0]=255;
        if(data[row][col][1] &lt; 0) data[row][col][1] = 0;
        if(data[row][col][1] &gt; 255) data[row][col][1]=255;
        if(data[row][col][2] &lt; 0) data[row][col][2] = 0;
        if(data[row][col][2] &gt; 255) data[row][col][2]=255;
        if(data[row][col][3] &lt; 0) data[row][col][3] = 0;
        if(data[row][col][3] &gt; 255) data[row][col][3]=255;
        
        oneDPix[cnt] = (((int)data[row][col][0] &lt;&lt; 24)
                                             & 0xFF000000)
                     | (((int)data[row][col][1] &lt;&lt; 16)
                                             & 0x00FF0000)
                      | (((int)data[row][col][2] &lt;&lt; 8)
                                             & 0x0000FF00)
                           | (((int)data[row][col][3])
                                             & 0x000000FF);
        cnt++;
      }//end for loop on col
    }//end for loop on row

    return oneDPix;
  }//end convertTo1D
  //-----------------------------------------------------//

  //Write the contents of an Image object to a JPEG file
  // named junk.jpg.
  void writeJpegFile(Image img,int width,int height){
    //Create an off-screen drawable image by calling the
    // createImage method of the Component class.  Cast
    // it to type BufferedImage.
    BufferedImage bufferedImg = 
                  (BufferedImage)createImage(width,height);
    
    //Call the createGraphics method of the BufferedImage
    // class to create a Graphics2D object, which can be
    // used to draw into the BufferedImage object.
    Graphics2D bufferedGraphics = 
                              bufferedImg.createGraphics();
    
    //Call the drawImage method of the Graphics class to
    // draw the image into the off-screen buffer.  Pass
    // null as the ImageObserver.
    bufferedGraphics.drawImage(img,0,0,null);
    
    try{
      //Get a file output stream.
      FileOutputStream outStream = 
                          new FileOutputStream("junk.jpg");
      //Call the write method of the ImageIO class to write
      // the contents of the BufferedImage object to an
      // output file in JPEG format.
      ImageIO.write(bufferedImg,"jpeg",outStream);
      outStream.close();
    }catch (Exception e) {
      e.printStackTrace();
    }//end catch
  }//end writeJpegFile
  //-----------------------------------------------------//
  
  //This method reads an image from a specified image file
  // and converts the pixel data into a 3D array of type
  // double.  The name of the image file is specified as
  // a String by theImgFile.
  double[][][] getTheImage(){
    rawImg = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImg,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if

    //Raw image has been loaded.  Get width and height of
    // the raw image.
    imgCols = rawImg.getWidth(this);
    imgRows = rawImg.getHeight(this);

    //Create a 1D array object to receive the pixel
    // representation of the image
    int[] oneDPix = new int[imgCols * imgRows];

    //Create an empty BufferedImage object
    BufferedImage buffImage = new BufferedImage(
                              imgCols,
                              imgRows,
                              BufferedImage.TYPE_INT_ARGB);

    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImg, 0, 0, null);

    //Convert the BufferedImage to numeric pixel
    // representation.
    DataBufferInt dataBufferInt =
                      (DataBufferInt)buffImage.getRaster().
                                           getDataBuffer();
    oneDPix = dataBufferInt.getData();

    //Convert the pixel byte data in the 1D array to
    // double data in a 3D array to make it easier to work
    // with the pixel data later.  Recall that pixel data
    // is unsigned byte data and Java does not support
    // unsigned arithmetic. Performing unsigned arithmetic
    // on byte data is particularly cumbersome.
    return convertTo3D(oneDPix,imgCols,imgRows);
  }//end getTheImage
  //-----------------------------------------------------//
}//end ImgMod04a.java class
//=======================================================//

//The ProgramTestA class

//The purpose of this class is to provide a simple example
// of an image processing class that is compatible with the
// use of the class program named ImgMod04a and the
// interface named ImgIntfc04a.

//The constructor for the class displays a small frame on
// the screen with a single textfield. The purpose of the
// text field is to allow the user to enter a value that
// represents the slope of a line.  In operation, the user
// types a value into the text field and then clicks the
// Replot button on the main image display frame.  The user
// is not required to press the Enter key after typing the
// new value, but it doesn't do any harm to do so.  
// Negative slopes are not supported.  An attempt to use
// a negative slope will cause the program to abort with 
// an error.

//The method named processImage receives a 3D array of
// type double containing alpha, red, green, and blue
// values for an image.

// The 3D array that is received by processImg is
// modified my the method to cause a white diagonal line to
// be drawn down and to the right from the upper left
// corner of the image.  The slope of the line is
// controlled by the value in the text field.  Initially,
// this value is 1.0, but the value can be modified by the
// user.  (If the characters in the text field cannot be
// converted to a numeric type double, the program will
// abort with an error.)
//After drawing the line, the method inverts the colors in
// the image.  This results in a black line on an image
// with inverted colors.

//The method named processImg is required to return one
// reference to a 3D array objects of type double

//To cause a new line to be drawn, type a new slope
// value into the text field and click the Replot button
// at the top of the main image display frame.

//This class extends Frame.  However, a compatible class is
// not required to extend the Frame class. This example
// extends Frame because it provides a GUI for user data
// input.

//A compatible class is required to implement the
// interface named ImgIntfc04a.

class ProgramTestA extends Frame implements ImgIntfc04a{

  double slope;//Controls the slope of the line
  String inputData;//Obtained via the TextField
  TextField inputField;//Reference to TextField

  //Constructor must take no parameters
  ProgramTestA(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    Label instructions = new Label(
                         "Type a slope value and Replot.");
    add(instructions);

    inputField = new TextField("1.0",5);
    add(inputField);

    setTitle("Copyright 2006, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor
  //-----------------------------------------------------//

  //The following method must be defined to implement the
  // ImgIntfc04a interface.
  public double[][][] processImg(double[][][] threeDPix){
                              
    //Determine number of rows and cols
    int imgRows = threeDPix.length;
    int imgCols = threeDPix[0].length;

    //Display some interesting information
    System.out.println("Program test");
    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);
    //Make a working copy of the 3D array to avoid making
    // permanent changes to the image data.
    double[][][] temp3D = copy3DArray(threeDPix);
    //Get slope value from the TextField
    slope = Double.parseDouble(inputField.getText());

    //Draw a white diagonal line on the image.
    for(int col = 0;col &lt; imgCols;col++){
      int row = (int)(slope * col);
      if(row &gt; imgRows -1) break;
      //Set values for alpha, red, green, and
      // blue colors.
      temp3D[row][col][0] = 255.0;
      temp3D[row][col][1] = 255.0;
      temp3D[row][col][2] = 255.0;
      temp3D[row][col][3] = 255.0;

    }//end for loop
    //Invert the colors.  Do not invert the alpha value.
    invertColors(temp3D);
    //Return two references to the same array of image
    // data.
    return temp3D;
  }//end processImg
  //-----------------------------------------------------//
  
  //This method copies a double version of a 3D pixel array
  // to an new pixel array of type double.
  double[][][] copy3DArray(double[][][] threeDPix){
    int imgRows = threeDPix.length;
    int imgCols = threeDPix[0].length;
    
    double[][][] new3D = new double[imgRows][imgCols][4];
    for(int row = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        new3D[row][col][0] = threeDPix[row][col][0];
        new3D[row][col][1] = threeDPix[row][col][1];
        new3D[row][col][2] = threeDPix[row][col][2];
        new3D[row][col][3] = threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop
    return new3D;
  }//end copy3DArray
  //-----------------------------------------------------//
  
  //This method inverts the colors in a double version of a
  // 3D array of pixel data.  It doesn't invert the alpha
  // value.
  void invertColors(double[][][] data3D){
    int imgRows = data3D.length;
    int imgCols = data3D[0].length;
    //Invert the colors.  Don't invert the alpha value.
    for(int row = 0;row &lt; imgRows;row++){
      for(int col = 0;col &lt; imgCols;col++){
        data3D[row][col][1] = 255 - data3D[row][col][1];
        data3D[row][col][2] = 255 - data3D[row][col][2];
        data3D[row][col][3] = 255 - data3D[row][col][3];
      }//end inner loop
    }//end outer loop
  }//end invertColors
  //-----------------------------------------------------//
}//end class ProgramTestA<br><br><b><font face="Courier New,Courier"><a href="#Listing_30">Listing 30</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_31" href="#Listing_31">Listing 31</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgIntfc04a.java
Copyright 2006, R.G.Baldwin

This is a modification to the interface named ImgIntfc04 
that eliminates the use of a second image-processing 
method. Otherwise, it is identical to the interface named 
ImgIntfc04.

The purpose of this interface is to declare the method 
required by image processing classes that are 
compatible with the program named ImgMod04a.java.

Tested using J2SE 5.0 under WinXP
**********************************************************/

interface ImgIntfc04a{
double[][][] processImg(double[][][] input);
}//end ImgIntfc04a
//=======================================================//<br><br><b><font face="Courier New,Courier"><a href="#Listing_31">Listing 31</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<hr align="center" size="3" width="100%">
<p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java image pixel framework&nbsp; </p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
