<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">Continuing with the SimpleTurtle Class:&nbsp; Multimedia Programming with Java</h2>
<i>Learn how the World class and the Turtle class of the multimedia library 
implement a practical version of the Model-View-Control programming paradigm.&nbsp; 
Investigate the differences between placing a turtle in a world and placing a 
turtle in a picture.</i><p><b>Published:</b>&nbsp; December 16, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 344</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
		<li><a href="#The_DrJava_IDE">The DrJava IDE</a></li>
		<li><a href="#Software_installation_and_testing">Software installation 
		and testing</a></li>
	</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#First_sample_program">First sample program - Java344a</a></li>
	<li><a href="#Second_sample_program">Second sample program - Java344b</a></li>
	<li><a href="#Why_the_dead_turtles">The reason for the dead turtles</a></li>
	<li><a href="#The_drop_method">The drop method</a></li>
	<li><a href="#Methods_that_cause_the_turtle_to_turn">Methods that cause the 
	turtle to turn</a><ul>
	<li><a href="#turn(int_degrees)">The turn(int degrees) method</a></li>
	<li><a href="#A_model_view_control_(MVC)_programming_paradigm">A model-view-control (MVC) programming paradigm</a></li>
	<li><a href="#turnLeft()">The turnLeft() and turnRight() methods</a></li>
	<li><a href="#turnToFace(int_x,int_y)">The turnToFace(int x,int y) method</a></li>
	<li><a href="#turnToFace(SimpleTurtle_turtle)">The turnToFace(SimpleTurtle turtle) 
	method</a></li>
</ul>
	</li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This is the third lesson in a series designed to teach you how to write Java 
programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters in videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Screen output from program named 
	Java344a. </li>
	<li><a href="#Figure_2">Figure 2</a>. Screen output from program named 
	Java344b.<b> </b></li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of source code for program 
	Java344a. </li>
	<li><a href="#Listing_2">Listing 2</a>. Load the turtle image into a Picture 
	object. </li>
	<li><a href="#Listing_3">Listing 3</a>. Instantiate and manipulate a Turtle 
	object in a World. </li>
	<li><a href="#Listing_4">Listing 4</a>. Drop more pictures while turning and 
	moving the turtle. </li>
	<li><a href="#Listing_5">Listing 5</a>. Abbreviated listing of the program 
	named Java344b. </li>
	<li><a href="#Listing_6">Listing 6</a>. Abbreviated listing of the 
	updateDisplay method. </li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the drop method. </li>
	<li><a href="#Listing_8">Listing 8</a>. Construct a rotation and translation 
	transform.</li>
	<li><a href="#Listing_9">Listing 9</a>. Draw dropPicture on the graphics 
	context. </li>
	<li><a href="#Listing_10">Listing 10</a>. Remainder of the drop method. </li>
	<li><a href="#Listing_11">Listing 11</a>. The turn(int degrees) method. </li>
	<li><a href="#Listing_12">Listing 12</a>. The turnLeft and turnRight methods </li>
	<li><a href="#Listing_13">Listing 13</a>. Beginning of the turn<a name="turnToFace(int_x,int_y)1">ToFace(int 
	x,int y) met</a>hod.</li>
	<li><a href="#Listing_14">Listing 14</a>. The turnToFace(SimpleTurtle 
	turtle) method.</li>
	<li><a href="#Listing_15">Listing 15</a>. Source code for the SimpleTurtle 
	class. </li>
	<li><a href="#Listing_16">Listing 16</a>. Source code for the program named 
	Java344a. </li>
	<li><a href="#Listing_17">Listing 17</a>. Source code for the program named 
	Java344b. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="The_DrJava_IDE">The DrJava IDE</a></h3>
<p>In some cases, I will use a free lightweight Java IDE named <b>DrJava</b> <i>
(see <a href="#Resources">Resources</a>)</i>.&nbsp; This IDE is useful because it 
provides an interactive Java programming mode.&nbsp; The interactive mode makes it 
easy to <i>&quot;try things out&quot;</i> without the requirement to write and compile a 
complete Java application.&nbsp; <i>(The IDE also provides a typical Java text 
editor, access to the Java compiler and runtime engine, a debugger, etc.)</i>&nbsp;
</p>
<p>Even though I will sometimes use DrJava, you should be able to use any Java 
IDE <i>(for the non-interactive material)</i> to compile and execute my sample 
programs so long as you set the <i>classpath</i> to include the multimedia class 
library.&nbsp; You should also be able to avoid the use of a Java IDE altogether if 
you choose to do so.&nbsp; You can create the source code files using a simple text 
editor, and then compile and execute the sample programs from the command line 
using a batch file.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test both the multimedia class 
library and the DrJava IDE in an earlier lesson titled <i>Multimedia Programming 
with Java, Getting Started (see <a href="#Resources">Resources</a>)</i>.</p>
<p>I also explained how to create a Windows batch file that you can use to set 
the classpath and run programs that use the multimedia library in the total 
absence of an IDE.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>As I promised in the previous lesson <i>(see <a href="#Resources">Resources</a>)</i>, 
I will begin this lesson with an explanation of the<b> drop</b> method of the <b>
SimpleTurtle</b> class.&nbsp; A complete listing of the <b>SimpleTurtle</b> 
class is provided in Listing 15 near the end of the lesson.</p>
<p>Then I will explain the following methods from the <b>SimpleTurtle</b> 
class.&nbsp; The methods in this group can be called to cause a turtle to face 
in a particular direction.</p>
<ul>
	<li>turn(int degrees)</li>
	<li>turnLeft()</li>
	<li>turnRight()</li>
	<li>turnToFace(int x,int y)</li>
	<li>turnToFace(SimpleTurtle turtle)</li>
</ul>
<p>Along the way, I will explain how the <b>World</b> class and the <b>Turtle</b> 
class implement a practical version of the <i>Model-View-Control</i> programming 
paradigm.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<p>I will begin by explaining two sample programs that illustrate the use 
of the <b>drop</b> method as well as some of the other methods that I will 
explain in this lesson.</p>
<h3><a name="First_sample_program">First sample program</a> 
- Java344a</h3>
<p>The purpose of this program is to illustrate several different methods 
of the <b>Turtle</b> class including the <b>drop</b> method.&nbsp; The program 
moves a <b>Turtle</b> object around on a <b>World</b> and drops several copies 
of a small <b>Picture</b> object along the way.</p>
<p><font color="#FF0000"><b>The screen output</b></font></p>
<p>The screen output produced by this program is shown in Figure 1.&nbsp; I will 
refer back to Figure 1 while discussing the program code.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Screen output from program named Java344a. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table11" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java344a.jpg" width="409" height="535"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the mediapath property</b></font></p>
<p>As is my custom, I will explain this program in fragments.&nbsp; A complete 
listing of the program is provided in Listing 16 near the end of the lesson.&nbsp; 
The source code begins with the fragment shown in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of source code for program 
Java344a. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table1">
  <tbody>
    <tr>
      <td>
      <pre>
import java.awt.Color;
public class Main{
  public static void main(String[] args){
    FileChooser.setMediaPath("M:/Ericson/mediasources/");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the mediapath</b></font></p>
<p>There are several ways to establish the location <i>(on the disk)</i> of an image file that will 
be loaded into a <b>Picture</b> object.&nbsp; One of those ways is shown 
in Listing 1.&nbsp; The code in Listing 1 calls the static <b>setMediaPath</b> 
method of the <b>FileChooser</b> class to set a property value named <b>
mediapath</b>.&nbsp; The value is set to point to a folder containing an image 
file that will be loaded in Listing 2.&nbsp; <i>(Note that all the slash 
characters in the <b>mediapath</b> string are forward-leaning slash characters 
and the <b>mediapath</b> string is terminated with a forward slash.)</i></p>
<p><font color="#FF0000"><b>Load the turtle image</b></font></p>
<p>Listing 2 instantiates a new object of the class <b>Picture</b> initializing 
its contents with the image of the smiling turtle shown in Figure 1.&nbsp; Note 
that after having set the <b>mediapath</b> property, only the name of the image 
file is required as type <b>String</b>.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Load the turtle image into a Picture 
object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table2">
  <tbody>
    <tr>
      <td>
      <pre>
    Picture p2 = new Picture("turtle.jpg");
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Eliminating the need to set the mediapath</b></font></p>
<p>You can also access an image file by omitting the <b>mediapath</b> entirely and providing a full path to the image file 
in Listing 2.&nbsp; Just be sure to use forward-leaning slashes and not backward-leaning 
slashes in the string.&nbsp; For the special case where the image file is in the 
current directory, you can also eliminate the path and simply specify the name 
of the image file.</p>
<p><font color="#FF0000"><b>The Picture class</b></font></p>
<p>I will be explaining the <b>Picture</b> class in some detail in a future 
lesson so I won't go into much detail regarding that class in this lesson.&nbsp; 
Suffice it at this point to say that one of the overloaded constructors for the
<b>Picture</b> class accepts 
an image file name as a <b>String</b> and uses that information to encapsulate 
the image in the new object.</p>
<p><font color="#FF0000">
<b>Instantiate and manipulate a Turtle object in a World</b></font></p>
<p>Listing 3 begins by instantiating a new <b>World</b> object with dimensions 
of 400 by 500 pixels as shown in Figure 1.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Instantiate and manipulate a Turtle object 
in a World. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table3">
  <tbody>
    <tr>
      <td>
      <pre>
    World mars = new World(400,500);
    Turtle joe = new Turtle(300,400,mars);

    joe.setShellColor(Color.RED);
    joe.setPenColor(Color.BLUE);
    joe.setPenWidth(2);

    joe.drop(p2);//Draw a small picture
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 3 instantiates a new <b>Turtle</b> object and places it in the 
world at coordinates 300,400.&nbsp; This places the turtle at the bottom of the 
vertical blue line on the bottom right side of Figure 1.&nbsp; <i>(Recall that 
the origin is the upper left corner.&nbsp; Positive x is to the right and positive y 
is down.)</i></p>
<p><font color="#FF0000"><b>Not related to the turtle image</b></font></p>
<p>It is also important to note that this <b>Turtle</b> object is completely 
independent of the turtle image that was loaded in Listing 2.&nbsp; Listing 2 
places an image of a turtle in an object of the <b>Picture</b> class.&nbsp; This 
turtle is an object of the <b>Turtle</b> class.</p>
<p><font color="#FF0000"><b>Set Turtle object properties</b></font></p>
<p>Then Listing 3 calls three property setter methods to:</p>
<ul>
	<li>Change the color of the turtle's shell from default green to red.</li>
	<li>Change the color of the pen from default green to blue.</li>
	<li>Change the width of the pen from the default of one pixel to two pixels.</li>
</ul>
<p><font color="#FF0000"><b>Drop a picture</b></font></p>
<p>Finally, Listing 3 calls the <b>drop</b> method on the <b>Turtle</b> object to 
draw the image of the smiling turtle at the current location and orientation of the 
<b>Turtle</b> object.&nbsp; Note 
that at this point the turtle is facing north and is centered at the bottom of 
the blue line segment.&nbsp; Also note that when you drop a picture, the 
upper-left corner of the picture coincides with the current location of the 
turtle.&nbsp; Thus, the bulk of the turtle image is to the right of and below 
the end of the blue line in Figure 1.</p>
<p><font color="#FF0000">
<b>Drop more pictures while turning and moving the turtle</b></font></p>
<p>Listing 4 begins by moving the turtle forward <i>(north)</i> by 90 pixels and 
then dropping another picture of the turtle image.&nbsp; This is the second 
turtle image from the bottom in Figure 1.&nbsp; Because the <b>Turtle</b> object 
is still facing north at this point, <b>t</b>his turtle image is oriented the same as the turtle image at 
the bottom.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Drop more pictures while turning and 
moving the turtle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table4">
  <tbody>
    <tr>
      <td>
      <pre>    joe.forward(90);
    joe.drop(p2);
    
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);
    
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);
  }//end main

}//end class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Turn, move, and drop</b></font></p>
<p>Then Listing 4 turns the turtle by -30 degrees, moves it forward by the 
default 100 pixels, and drops another picture.&nbsp; This is the third turtle 
image from the bottom, and it has been rotated by 30 degrees counter-clockwise.&nbsp;
<i>(Positive angles represent clockwise rotation.)</i></p>
<p>That process is repeated one more time producing the turtle image at the top 
along with the visual manifestation of the <b>Turtle</b> object with the green 
body and the red shell.</p>
<p><font color="#FF0000"><b>Only one Turtle object is visible</b></font></p>
<p>Note that unlike the next sample program, the <b>Turtle</b> 
object in this program is visible only at the final location.&nbsp; However, if we were to slow 
the execution down significantly, we would see the <b>Turtle</b> object jumping 
from the end of one line segment to the end of the next line segment and dropping a picture each time it stops.&nbsp; 
We could do that by calling the <b>sleep</b> 
method of the <b>Thread</b> class to insert a time delay immediately following 
each call to the <b>drop</b> 
method.</p>
<h3><a name="Second_sample_program">Second sample program</a> - Java344b</h3>
<p>A complete listing of this program is shown in Listing 17 near the end of the 
lesson.</p>
<p>The purpose of this program is to illustrate the use of several different 
methods of the <b>Turtle</b> class, as well as to illustrate the placement of a
<b>Turtle</b> object on a <b>Picture</b> object <i>(as opposed to a <b>World</b> 
object)</i>.</p>
<p>The program also illustrates dropping pictures at the current position and 
orientation of the <b>Turtle</b> object.</p>
<p>The program moves a <b>Turtle</b> object around on a Picture and drops 
several copies of a smaller <b>Picture</b> object along the way.</p>
<p><font color="#FF0000"><b>The screen output</b></font></p>
<p>The screen output produced by this program is shown in Figure 2.&nbsp; Except 
for the fact that this program places the Turtle object on a <b>Picture</b> 
object instead of a <b>World</b> object, the program is very similar to the 
previous program. There are, however, some significant differences in the 
behavior of the <b>Turtle</b> object in these two cases.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Screen output from program named Java344b. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table12" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java344b.jpg" width="431" height="532"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Lots of dead turtles lying around</b></font></p>
<p>We learned in the previous lesson that when a <b>Turtle</b> object is placed 
on a <b>Picture</b> object, it is made invisible by default.&nbsp; Therefore, in 
order to make the turtle visible, it was necessary for me to set the turtle's 
<i>visible</i> property to true.</p>
<p>I was initially surprised to learn that unlike the case of the <b>World</b> 
in 
Figure 1, an old image of the <b>Turtle</b> object remains on the screen when it moves 
from one location to the next.&nbsp; Further complicating matters, when a turtle 
is simply rotated, two images of the turtle appear, 
one on top of the other.&nbsp; As a result, two of the images of the <b>Turtle</b> 
object in Figure 2 appear to have two heads and eight legs.&nbsp; <i>(In each 
these two cases, there are really two images of the turtle, one on top of the 
other.)</i></p>
<p>I suppose that 
serves to illustrate the reason why the turtle is invisible by default.&nbsp; 
When you place a visible turtle on a picture and move it around, it leaves a 
trail of dead turtles along the way. </p>
<p><font color="#FF0000">
<b>An abbreviated listing of program named Java344b</b></font></p>
<p>An abbreviated listing of this program is shown in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Abbreviated listing of the program named 
Java344b. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table5">
  <tbody>
    <tr>
      <td>
      <pre>
import java.awt.Color;
public class Main{
  public static void main(String[] args){

    //...code deleted
    //Instantiate two objects of Picture class, each of 
    // which encapsulates an image.
    Picture p1 = new Picture("butterfly1.jpg");//large
    Picture p2 = new Picture("turtle.jpg");//small
    
    //Note that the Turtle object is different from the
    // image of the turtle in the Picture object.
    Turtle joe = new Turtle(300,400,p1);

    //..code deleted
    joe.setVisible(true);

    //..code deleted
    p1.show();
  }//end main

}//end class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 5 contains only the code that is different from the code that I 
explained earlier in Listing 1 through Listing 4.&nbsp; Hopefully the embedded 
comments in Listing 5 are sufficient to help you understand the difference 
between these two programs.</p>
<h3><a name="Why_the_dead_turtles">The reason for the dead turtles</a></h3>
<p>Before getting into an explanation of the <b>drop</b> method, let's see if we 
can understand why Figure 1 shows only one image of the turtle with the red 
shell and Figure 2 shows five images of the turtle with the red shell.&nbsp; 
<i>(Some of the turtle images in Figure 2 are drawn on top of other turtle 
images.)</i>&nbsp; To understand this, we 
need to go back and take another look at the <b>updateDisplay</b> method that I 
explained in the previous lesson <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>The updateDisplay method</b></font></p>
<p>An abbreviated listing of the <b>updateDisplay</b> method is shown in Listing 
6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Abbreviated listing of the updateDisplay 
method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table6">
  <tbody>
    <tr>
      <td>
      <pre>  public synchronized void updateDisplay(){
    //...code deleted
    if (picture != null){
      //...code deleted
      //Turtle was placed in a Picture object
      Graphics g = picture.getGraphics();
      paintComponent(g);
    }//end if
    else if (modelDisplay != null){
      //...code deleted
      //Turtle was placed in a World object
      modelDisplay.modelChanged();
    }//end else if
  }//end updateDisplay</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I refer to this as an abbreviated listing because I deleted all of the 
code that is not germane to the question regarding dead turtles.</p>
<p><font color="#FF0000"><b>Called by many other methods</b></font></p>
<p>We learned in the previous lesson that the <b>updateDisplay</b> method is 
called by many other methods that make changes to the position or orientation of 
a turtle.&nbsp; In fact, it is called by all of the following methods:</p>
<ul>
	<li>turnToFace</li>
<li>setVisible</li>
<li>forward</li>
	<li>moveTo</li>
	<li>turn</li>
</ul>
<p>In addition, the methods in the above list are called by other methods 
resulting ultimately in a call to the <b>updateDisplay</b> method by many 
different methods.&nbsp; For 
example, the <b>forward</b> method is called by the <b>backward</b> method with 
a negative parameter value.</p>
<p><font color="#FF0000"><b>Behavior of the updateDisplay method</b></font></p>
<p>Now consider the behavior of the <b>updateDisplay</b> method shown in Listing 
6.&nbsp; As you can see, the behavior is different depending on whether the 
turtle was placed in a <b>Picture</b> object or in a <b>World</b> object.</p>
<p><font color="#FF0000"><b>A turtle in a Picture object</b></font></p>
<p>For the case where the turtle was placed in a <b>Picture</b> object, the <b>
paintComponent</b> method is called every time the <b>updateDisplay</b> method 
is called.&nbsp; Nothing is done to erase the old image of the turtle before 
drawing a new one at the same or at a different location.&nbsp; This results in 
the multiple images of the turtle, some on top of others, shown in Figure 2.</p>
<p><font color="#FF0000"><b>A turtle in a World object</b></font></p>
<p>For the case where the turtle was placed in a <b>World</b> object, the <b>
updateDisplay</b> method does not call the <b>paintComponent</b> method 
directly.&nbsp; Instead it calls the <b>modelChanged</b> method on the <b>World</b> 
object. This sends a message to the <b>World</b> object indicating that the turtle 
has changed.&nbsp; The decision as to whether or not to repaint the turtle is 
made by the world.</p>
<p>As we will see when we study the <b>World</b> class later, if the <b>World</b> 
object decides to repaint the turtle as a result of that notification, it first 
draws a background image on the entire world, erasing everything that was previously displayed.&nbsp; 
Then it draws the turtle in its new location and/or orientation on the world's 
background image.</p>
<p><font color="#FF0000"><b><a name="A_question">An important question</a></b></font></p>
<p>This raises the question as to why this process erases old images of the 
turtle with the red shell but doesn't erase the pictures that were previously 
dropped.&nbsp; The answer is rather complicated, but I will attempt to answer it 
in conjunction with my explanation of the <b>drop</b> method later.</p>
<p><font color="#FF0000"><b>What about the history of pen movements?</b></font></p>
<p>This display approach also has very significant ramifications for the display of the turtle's 
track created by the pen, but that is another topic for another lesson.&nbsp; In 
effect, this means that the pen must maintain a history of its movements so that 
every time the world is repainted, the entire history of pen movements can be 
redrawn.&nbsp; I will explain the <b>Pen</b> class in a future lesson.</p>
<h3><a name="The_drop_method">The drop method</a></h3>
<p>The purpose of this method is to draw an incoming <b>Picture</b> object at the 
current location of the turtle with the same orientation as the turtle in either 
a <b>ModelDisplay</b> object <i>(such as a <b>World</b> object)</i> or a <b>Picture</b> 
object.</p>
<p><font color="#FF0000">
<b>Beginning of the drop method</b></font></p>
<p>The beginning of the <b>drop</b> method is shown in Listing 7.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the drop method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table7">
  <tbody>
    <tr>
      <td>
      <pre>
  public synchronized void drop(Picture dropPicture){
    Graphics2D g2 = null;

    if (picture != null)
      //Draw dropPicture on a Picture object
      g2 = (Graphics2D) picture.getGraphics();
    else if (modelDisplay != null)
      //Draw dropPicture on a ModelDisplay (World) object
      g2 = (Graphics2D) modelDisplay.getGraphics();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Figure 1 shows the result of dropping a picture of a smiling turtle four 
times in a <b>
World</b> object.&nbsp; Figure 2 shows the result of dropping the same picture 
four times in a <b>Picture</b> object.&nbsp; As I explained earlier, the 
upper-left corner of the dropped picture is aligned with the location of the turtle 
and the orientation of the picture matches the orientation of the turtle.&nbsp; This 
is most obvious in Figure 2 where images of the turtle at the time of the drop 
are still showing.</p>
<p><font color="#FF0000"><b>Decision between World and Picture object</b></font></p>
<p>The code in Listing 7 determines whether <b>dropPicture</b> is to be drawn on a <b>
Picture</b> object or on a <b>World</b> object.&nbsp; The case for a <b>Picture</b> 
object is 
relatively simple.&nbsp; 
The <b>getGraphics</b> method is called on the <b>Picture</b> object to get a 
reference to the graphics context for that object <i>(as type <b>Graphics</b>)</i>.&nbsp; The reference is cast to type <b>Graphics2D</b> and saved in the 
variable named <b>g2</b> for later use in drawing the image.</p>
<p><font color="#FF0000"><b>A much more complicated situation</b></font></p>
<p>The case for a <b>World</b> object in Listing 7 is much more complicated and provides the answer to the 
earlier <a href="#A_question">question</a> as to why this process erases old 
images of the turtle with the red shell but doesn't erase the pictures that have 
been dropped as shown in Figure 1.</p>
<p><font color="#FF0000"><b>Get a reference to a graphics context</b></font></p>
<p>Listing 7 calls the <b>getGraphics</b> method on the 
reference to the <b>World</b> object.&nbsp; Normally, you might expect this call 
to return a reference to the graphics context for the world, but that is not the 
case here.</p>
<p><font color="#FF0000"><b>Every World object contains a Picture object</b></font></p>
<p>By default, every <b>World</b> object contains a <b>Picture</b> object which 
is used to produce the background for the world.&nbsp; By default, this picture 
is simply a white image the same size as the world as shown by the background in 
Figure 1.&nbsp; <i>(You can easily replace the default picture with a 
different one.)</i></p>
<p><font color="#FF0000"><b>An overridden getGraphics method</b></font></p>
<p>The
<b>getGraphics</b> method of the <b>World</b> class is overridden so that it 
returns a reference to the graphics context for that background <b>Picture</b> 
object instead 
of returning a reference to the graphics context for the <b>World</b> object.</p>
<p>When the <b>getGraphics</b> method is called in Listing 7, the returned 
reference value is cast to type <b>Graphics2D</b> and stored in the variable named <b>g2</b> for later use.&nbsp; 
<i>(I will continue this explanation later.)</i></p>
<p><font color="#FF0000"><b>Construct a rotation and translation transform</b></font></p>
<p>Listing 8 begins by confirming that the reference stored in <b>g2</b> is not 
null.&nbsp; If it is null, no attempt will be made to draw the picture referred 
to by the incoming parameter named <b>dropPicture</b>.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Construct a rotation and translation 
transform.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table8">
  <tbody>
    <tr>
      <td>
      <pre>
    if (g2 != null){

      // save the current transform
      AffineTransform oldTransform = g2.getTransform();

      // rotate to turtle heading and translate to xPos
      // and yPos
      g2.rotate(Math.toRadians(heading),xPos,yPos);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>When g2 is not null...</b></font></p>
<p>When <b>g2</b> is not null, Listing 8 saves the current affine transform for 
the graphics context referred to by <b>g2</b> and 
then modifies the current transform to match the location and orientation of the 
turtle.&nbsp; <i>(I explained the use of the affine transform in some detail in 
the previous lesson.&nbsp; See  <a href="#Resources">Resources</a> for a link to that 
lesson.)</i>&nbsp; From this point forward, until the 
original transform is restored in Listing 10, the modified transform will be 
applied to any drawing commands that are issued against <b>g2</b>.</p>
<p><font color="#FF0000">
<b>Draw  dropPicture on the graphics context</b></font></p>
<p>Listing 9 calls the <b>drawImage</b> method to draw the image referred to by <b>
dropPicture</b> at the specified location on the graphics context referenced by
<b>g2</b>.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Draw dropPicture on the graphics context. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table9">
  <tbody>
    <tr>
      <td>
      <pre>
      g2.drawImage(dropPicture.getImage(),xPos,yPos,null);
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>ImageObserver</b><br />
  The last parameter to the<b> drawImage</b> method must either be null or must 
	be a referenced to an <b>ImageObserver</b> object.&nbsp; In this case, we 
	don't need such an object so we are passing null as the last parameter.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Where does that leave us?</b></font></p>
<p>At this point, we have drawn <b>dropPicture</b> at a specified location with 
a specified orientation on 
another <b>Picture</b> object.&nbsp; For the case where the program placed the turtle in 
a <b>Picture</b> object <i>(as in Figure 2)</i>, that's pretty much the end of the story.</p>
<p><font color="#FF0000"><b>Not the end of the story for a World object</b></font></p>
<p>However, for the case where the program placed the turtle in a <b>World</b> object, there is much 
more to the story.&nbsp; In this case, <b>g2</b> is a reference to the <b>
Picture</b> object owned by the <b>World</b> object AND IS not a reference to 
the <b>World</b> object itself.</p>
<p>When the statement in Listing 9 has been executed, the <b>Picture</b> object owned by the <b>World</b> 
object has been permanently modified such that the picture referred to by <b>dropPicture</b> has been 
drawn on that picture.&nbsp; <i>(Except in some very special circumstances, drawing one 
image on another image is a non-reversible process.)</i></p>
<p>Because the <b>World</b> object uses its <b>Picture</b> 
object to create a background, <b>dropPicture</b> has now become a permanent 
part of that background.</p>
<p><font color="#FF0000"><b>Repainting the world</b></font></p>
<p>Sometime later, for a variety of reasons, the <b>World</b> object 
will need to be repainted.&nbsp; This can result from the execution of program 
code, or can result from user actions such as minimizing and later restoring 
the <b>World</b>.&nbsp; When the World object decides that it needs to be 
repainted, it will call its <b>repaint</b> method.</p>
<p>Speaking in broad terms, a call to the <b>repaint</b> method sends a message to the 
operating system telling the operating system that the world would like to be 
repainted as soon as possible.&nbsp; Sometime after that, the operating 
system will cause the world's overridden <b>paintComponent</b> method to be 
executed.&nbsp; <i>(Essentially the same thing happens when the need to repaint 
results from user actions except that there is no call to the <b>repaint</b> 
method by the program.)</i></p>
<p><font color="#FF0000"><b>Behavior of the world's paintComponent method</b></font></p>
<p>Although the code from the <b>World</b> class isn't shown here, the first thing that the world's overridden <b>paintComponent</b> method does 
is to draw its <b>Picture</b> object on its own graphics 
context to create a background image.&nbsp; That completely overwrites or erases everything 
that was previously drawn there, <i>(including any Turtle objects that may have been 
drawn there)</i>.</p>
<p>At that point, the world's visual representation consists only of the 
background image contained in the world's <b>Picture</b> object.&nbsp; If that <b>Picture</b> 
object has been modified to include the image referred to by <b>dropPicture</b>, the <b>dropPicture</b> image will be a 
permanent part of the background.</p>
<p><font color="#FF0000"><b>Cause the turtles to draw themselves</b></font></p>
<p>Then the world's <b>paintComponent</b> method cycles through a list of 
turtles that have been placed in the world, calling the <b>paintComponent</b> 
method belonging to each turtle and passing the graphics context for the world 
as a parameter to the <b>paintComponent</b> method.&nbsp; <i>(Note that the graphics context for the world's <b>
Picture</b> object is not passed as a parameter.)</i></p>
<p><font color="#FF0000"><b>Behavior of the turtle's paintComponent method</b></font></p>
<p>We learned in the previous lesson that the turtle's <b>paintComponent</b> 
method draws a shape that looks something like a turtle <i>(see Figure 1)</i> 
on the incoming graphics context by drawing five overlapping filled ovals in the 
correct location with the correct orientation.&nbsp; Then it 
may optionally draw some text on the same graphics context, following which it 
will call the <b>paintComponent</b> method belonging to its <b>Pen</b> object to draw all of the line segments in 
the pen's history 
on the same graphics context.&nbsp; <i>(The <b>Pen</b> class is very 
interesting, so I will explain it in a future lesson.)</i></p>
<p><font color="#FF0000"><b>The important point</b></font></p>
<p>The important point is that the <b>drop</b> method draws an image on the 
graphics context belonging to the <b>Picture</b> object that belongs to the 
world, making a permanent change to that object.&nbsp; Later on, the world will 
draw the picture on its own graphics context to form a background for whatever 
else may be drawn there.</p>
<p>On the other hand, the turtle draws itself on the graphics context belonging to the world and does 
not draw itself on the graphics context belonging to the <b>Picture</b> object.&nbsp; 
Therefore, the next time the world repaints itself by drawing its 
<b>Picture</b> object as a background, all of the turtles that have been drawn on the world's graphics 
context are overwritten or erased.&nbsp; The result is 
that each time the <b>drop</b> method is called to draw a picture <i>&quot;on the 
world&quot;</i>, that picture actually becomes a permanent part of the world's background.&nbsp; 
However, the ovals that are drawn on the world's graphic context 
remain visible only until the next time the world repaints its background.</p>
<p><font color="#FF0000">
<b>Remainder of the drop method</b></font></p>
<p>The remainder of the <b>drop</b> method is shown in Listing 10.&nbsp; Listing 
10 restores the original affine transform for the graphics context referred to 
by <b>g2</b> and then causes the pen to draw its 
history of line segments on the graphics context stored in <b>g2</b>.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Remainder of the drop method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table10">
  <tbody>
    <tr>
      <td>
      <pre>      // reset the transformation matrix
      g2.setTransform(oldTransform);

      //  draw the pen
      pen.paintComponent(g2);
    }
  }//end drop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Nothing is really permanent</b><br />
  The World class contains a method named clearBackground that can be called to 
	erase everything in the world's background image.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>A possible redundancy</b></font></p>
<p>I believe that the call to the pen's <b>paintComponent</b> method in Listing 10 
may be redundant with a similar call in the <b>paintComponent</b> method 
belonging to the turtle.&nbsp; However, there may be some circumstance in which it is 
necessary to have that call in both locations.</p>
<p>In any 
event, placing the call in Listing 10 causes the lines drawn by the pen to 
become a permanent part of the background for the world when a picture is 
dropped into the world.&nbsp; The similar call in the turtle's <b>paintComponent</b> 
method causes the lines to be drawn on the world's graphics context instead of 
the background picture's graphics context.</p>
<h3><a name="Methods_that_cause_the_turtle_to_turn">Methods that cause the 
turtle to turn</a></h3>
<p>I have identified the following methods that cause the turtle to turn and 
face in a different direction:</p>
<ul>
	<li>turn(int degrees)</li>
	<li>turnLeft()</li>
	<li>turnRight()</li>
	<li>turnToFace(int x,int y)</li>
	<li>turnToFace(SimpleTurtle turtle)</li>
</ul>
<h4>The <a name="turn(int_degrees)">turn(int degrees)</a> method</h4>
<p>The <b>turn(int degrees)</b> method, which is shown in its entirety in 
Listing 11, causes a turtle to rotate around its center by a specified number 
of degrees.&nbsp; A positive value causes the turtle to rotate clockwise and a 
negative value causes the turtle to rotate counter-clockwise.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. The turn(int degrees) method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public void turn(int degrees){
    this.heading = (heading + degrees) % 360;
    this.updateDisplay();
  }//end turn</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Not actually true</b></font></p>
<p>In truth, this method really doesn't cause the turtle to rotate.&nbsp; 
Instead, it simply changes the value of an instance variable belonging to the 
turtle named <b>heading</b>.&nbsp; This is one of many variables that maintain 
the current state of a turtle.&nbsp; This variable keeps track of the direction that the turtle is 
facing.&nbsp; The value for heading is ultimately used to modify the affine transform to 
implement a rotation as I explained in the previous lesson <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p>The modulus operation in Listing 11 constrains the angle to the range from 
-359 degrees to +359 degrees where 0 degrees, 360 degrees, and -360 degrees all 
mean the same thing.</p>
<h4><a name="A_model_view_control_(MVC)_programming_paradigm">A model-view-control (MVC) programming paradigm</a></h4>
<p>In case you haven't already recognized it, the <b>Turtle</b> class and 
the <b>World</b> class work together to implement a practical form of the MVC 
programming paradigm.&nbsp; If you are unfamiliar with MVC, don't worry about 
it.&nbsp; It isn't necessary to understand MVC to understand the library.&nbsp; 
If you are familiar with MVC, however, you might want to think about how it is 
implemented here.</p>
<p><font color="#FF0000"><b>The view</b></font></p>
<p>In this case, the <b>World</b> object is the view.&nbsp; <i>(Perhaps that is 
why it implements an interface named <b>ModelDisplay</b>.)</i>&nbsp; Among other 
methods, the <b>ModelDisplay</b> interface declares a method named <b>
modelChanged</b>, whereby a model <i>(turtle)</i> can notify the view <i>(world)</i> that the 
state of the model has changed.&nbsp; The world then has the discretion to 
decide whether or not it wants to update the display to reflect those changes in 
the model.</p>
<p><font color="#FF0000"><b>The model</b></font></p>
<p>The model is represented by the many state variables in a <b>Turtle</b> 
object <i>(such as <b>heading</b>, <b>visible</b>, <b>xPos</b>, and<b> yPos</b>)</i> 
that maintain the state of the object.</p>
<p><font color="#FF0000"><b>The control</b></font></p>
<p>The control is represented by many of the methods that can be called to 
modify the state variables, including but not limited to the following:</p>
<ul>
	<li>turnToFace</li>
	<li>setVisible</li>
	<li>forward</li>
	<li>moveTo</li>
	<li>turn</li>
</ul>
<p>Many of those methods modify one or more state variables and then cause the
turtle's
<b>updateDisplay</b> method to be called.&nbsp; The <b>updateDisplay</b> method 
in turn calls the world's <b>modelChanged</b> method to notify the world that 
the model has changed.&nbsp; For 
example, the <b>turn</b> method in Listing 11 modifies the value of the <b>
heading</b> variable belonging to the <b>Turtle</b> object and then calls the 
turtle's <b>
updateDisplay</b> method to cause the
<b>World</b> object to be notified that the state of the <b>Turtle</b> object 
has changed.</p>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>More information</b><br>
				If you would like to learn more about MVC, see
				<font size="3" face="arial"><i>Implementing the 
				Model-View-Controller Paradigm using Observer and Observable</i>&nbsp;in
				<a href="#Resources">Resources</a></font></td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>Updating the view</b></font></p>
<p>As explained earlier, when the world object decides to update the view of the 
turtles, it first creates a new background image for the view.&nbsp; Then it 
calls the <b>paintComponent</b> method on each turtle in sequence.&nbsp; This 
causes each turtle to draw itself in its current state on the new background.</p>
<h4>The <a name="turnLeft()">turnLeft()</a> and turnRight() methods</h4>
<p>These two methods, which are shown in Listing 12, are very simple.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. The turnLeft and turnRight methods </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table13">
  <tbody>
    <tr>
      <td>
      <pre>  //Method to turn left
  public void turnLeft(){this.turn(-90);}

  //Method to turn right
  public void turnRight(){this.turn(90);}</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Each method makes a call to the <b>turn</b> method from Listing 11 passing 
either -90 degrees or 90 degrees as a parameter value.</p>
<h4>The <a name="turnToFace(int_x,int_y)">turnToFace(int x,int y)</a> method</h4>
<p>The purpose of this method, which is shown in Listing 13, is to cause a turtle to turn to face a given point 
in 2D space specified by a pair of x and y coordinates.&nbsp; This method is much more complex than the other <i>turn</i> 
methods discussed above.</p>
<p><font color="#FF0000"><b>Behavior of the method</b></font></p>
<p>The behavior of this method is to:</p>
<ul>
	<li>Consider a line that joins the turtle and the point in space to be the 
	hypotenuse of a right triangle.</li>
	<li>Determine the length of the base and the length of the opposite side of 
	the right triangle.</li>
	<li>Use trigonometry to compute the near angle in degrees for the right 
	triangle.</li>
	<li>Adjust the angle to be within the range of -180 to +180 degrees based on 
	the sign of the base of the right triangle.</li>
	<li>Store the resulting angle in the state variable named <b>heading</b>.</li>
	<li>Notify the world that the state of the turtle has changed.</li>
</ul>
<p>Along the way, the method is careful to avoid division by zero.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Beginning of the turn<a name="turnToFace(int_x,int_y)0">ToFace(int 
x,int y) met</a>hod.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table17">
  <tbody>
    <tr>
      <td>
      <pre>
  public void turnToFace(int x, int y){
    double dx = x - this.xPos;
    double dy = y - this.yPos;
    double arcTan = 0.0;
    double angle = 0.0;

    // avoid a divide by 0
    if (dx == 0){
      // if below the current turtle
      if (dy &gt; 0) heading = 180;

      // if above the current turtle
      else if (dy &lt; 0) heading = 0;
    }
    // dx isn't 0 so can divide by it
    else{
      arcTan = Math.toDegrees(Math.atan(dy/dx));
      if (dx &lt; 0) heading = arcTan - 90;
      else heading = arcTan + 90;
    }//end else

    // notify the display that we need to repaint
    updateDisplay();
  }//end turnToFace</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you already understand trigonometry, you should have no problem 
understanding this method.&nbsp; Otherwise, you will simply have to take it on 
faith that this method behaves as described above.</p>
<h4>The <a name="turnToFace(SimpleTurtle_turtle)">turnToFace(SimpleTurtle turtle)</a> 
method</h4>
<p>This method can be called to cause one turtle to face another turtle.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. The turnToFace(SimpleTurtle turtle) 
method.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table20">
  <tbody>
    <tr>
      <td>
      <pre>  /**
   * Method to turn to face another simple turtle
   */
  public void turnToFace(SimpleTurtle turtle){
    turnToFace(turtle.xPos,turtle.yPos);
  }//turnToFace</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method calls the method from Listing 13, passing the coordinates of the 
target turtle as parameters.</p><center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 16 and Listing 17, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I began this lesson with an explanation of the<b> drop</b> method of the <b>
SimpleTurtle</b> class.&nbsp; </p>
<p>Then I explained the following methods that cause a turtle to face in a 
particular direction:</p>
<ul>
	<li>turn(int degrees)</li>
	<li>turnLeft()</li>
	<li>turnRight()</li>
	<li>turnToFace(int x,int y)</li>
	<li>turnToFace(SimpleTurtle turtle)</li>
</ul>
<p>Along the way, I explained how the <b>World</b> class and the <b>Turtle</b> 
class implement a practical version of the <i>Model-View-Control</i> programming 
paradigm.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, I will explain the methods in the following list along 
with some of the other methods in the multimedia library:</p>
<ul>
	<li>forward()</li>
	<li>forward(int pixels)</li>
	<li>backward()</li>
	<li>backward(int pixels)</li>
	<li>moveTo(int x,int y)</li>
</ul>
<p>These are the methods that make it possible for a turtle to move around in 
either a <b>World</b> object or a <b>Picture</b> object.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a rel="license" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a href="http://coweb.cc.gatech.edu/mediaComp-plan/101">Media 
	Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a href="http://drjava.sourceforge.net/">DrJava</a> download site</li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, the JavaPLT 
	group at Rice University</a></li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava Open Source 
	License</a></li>
	<li><a href="http://www.developer.com/java/article.php/1440571">The Essence 
	of OOP using Java, The this and super Keywords</a></li>
	<li><font color="#000000">
	<a href="http://www.dickbaldwin.com/java/Java058.htm">Threads of Control</a></font></li>
	<li><a href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Swing</a></li>
	<li><a href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable&nbsp; </li>
	<li><a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D 
	Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D 
	Graphics, The Point2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D 
	Graphics, The Graphics2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D 
	Graphics, Simple Affine Transforms</li>
	<li><a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D 
	Graphics, The Shape Interface, Part 1</li>
	<li><a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D 
	Graphics, The Shape Interface, Part 2</li>
	<li><a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D 
	Graphics, Solid Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D 
	Graphics, Gradient Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D 
	Graphics, Texture Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D 
	Graphics, The Stroke Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D 
	Graphics, The Composite Interface and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D 
	Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D 
	Graphics, The Color Constructors and Transparency</li>
	<li><a href="http://www.developer.com/java/other/article.php/3782471">340</a> Multimedia Programming with Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3788086">342</a> Getting Started with the Turtle 
	Class:&nbsp; Multimedia Programming with Java</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
15 through Listing 17 below.
<p>
<b><a name="Listing_15">Listing 15</a>. Source code for the SimpleTurtle class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import javax.swing.*;
import java.awt.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.util.Observer;
import java.util.Random;

/**
 * Class that represents a Logo-style turtle.  The turtle
 * starts off facing north.
 * A turtle can have a name, has a starting x and y
 * position, has a heading, has a width, has a height,
 * has a visible flag, has a body color, can have a shell
 * color, and has a pen.
 * The turtle will not go beyond the model display or
 * picture boundaries.
 *
 * You can display this turtle in either a picture or in
 * a class that implements ModelDisplay.
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class SimpleTurtle{
  ///////////////// fields ////////////////////////

  /** count of the number of turtles created */
  private static int numTurtles = 0;

  /** array of colors to use for the turtles */
  private static Color[] colorArray = {Color.green,
              Color.cyan,new Color(204,0,204),Color.gray};

  /** who to notify about changes to this turtle */
  private ModelDisplay modelDisplay = null;

  /** picture to draw this turtle on */
  private Picture picture = null;

  /** width of turtle in pixels */
  private int width = 15;

  /** height of turtle in pixels */
  private int height = 18;

  /** current location in x (center) */
  private int xPos = 0;

  /** current location in y (center) */
  private int yPos = 0;

  /** heading angle */
  private double heading = 0;  // default is facing north

  /** pen to use for this turtle */
  private Pen pen = new Pen();

  /** color to draw the body in */
  private Color bodyColor = null;

  /** color to draw the shell in */
  private Color shellColor = null;

  /** color of information string */
  private Color infoColor = Color.black;

  /** flag to say if this turtle is visible */
  private boolean visible = true;

  /** flag to say if should show turtle info */
  private boolean showInfo = false;

  /** the name of this turtle */
  private String name = "No name";

  ////////////////// constructors ///////////////////

  /**
   * Constructor that takes the x and y position for the
   * turtle
   * @param x the x pos
   * @param y the y pos
   */
  public SimpleTurtle(int x, int y){
    xPos = x;
    yPos = y;
    bodyColor =
               colorArray[numTurtles % colorArray.length];
    setPenColor(bodyColor);
    numTurtles++;
  }//end constructor

  /**
   * Constructor that takes the x and y position and the
   * model displayer
   * @param x the x pos
   * @param y the y pos
   * @param display the model display
   */
  public SimpleTurtle(int x, int y, ModelDisplay display){
    this(x,y); // invoke constructor that takes x and y
    modelDisplay = display;
    display.addModel(this);
  }//end constructor

  /**
   * Constructor that takes a model display and adds
   * a turtle in the middle of it
   * @param display the model display
   */
  public SimpleTurtle(ModelDisplay display){
    // invoke constructor that takes x and y
    this((int) (display.getWidth() / 2),
         (int) (display.getHeight() / 2));
    modelDisplay = display;
    display.addModel(this);
  }//end constructor

  /**
   * Constructor that takes the x and y position and the
   * picture to draw on
   * @param x the x pos
   * @param y the y pos
   * @param picture the picture to draw on
   */
  public SimpleTurtle(int x, int y, Picture picture){
    this(x,y); // invoke constructor that takes x and y
    this.picture = picture;
    this.visible = false;//default is not to see turtle
  }//end constructor

  /**
   * Constructor that takes the
   * picture to draw on and will appear in the middle
   * @param picture the picture to draw on
   */
  public SimpleTurtle(Picture picture){
    // invoke constructor that takes x and y
    this((int) (picture.getWidth() / 2),
         (int) (picture.getHeight() / 2));
    this.picture = picture;
    this.visible = false;//default is not to see turtle
  }//end constructor

  //////////////////// methods /////////////////////////

  /**
   * Get the distance from the passed x and y location
   * @param x the x location
   * @param y the y location
   */
  public double getDistance(int x, int y){
    int xDiff = x - xPos;
    int yDiff = y - yPos;
    return (Math.sqrt((xDiff * xDiff) + (yDiff * yDiff)));
  }//end getDistance

  /**
   * Method to turn to face another simple turtle
   */
  public void turnToFace(SimpleTurtle turtle){
    turnToFace(turtle.xPos,turtle.yPos);
  }//turnToFace

   /**
   * Method to turn towards the given x and y
   * @param x the x to turn towards
   * @param y the y to turn towards
   */
  public void turnToFace(int x, int y){
    double dx = x - this.xPos;
    double dy = y - this.yPos;
    double arcTan = 0.0;
    double angle = 0.0;

    // avoid a divide by 0
    if (dx == 0){
      // if below the current turtle
      if (dy &gt; 0) heading = 180;

      // if above the current turtle
      else if (dy &lt; 0) heading = 0;
    }
    // dx isn't 0 so can divide by it
    else{
      arcTan = Math.toDegrees(Math.atan(dy/dx));
      if (dx &lt; 0) heading = arcTan - 90;
      else heading = arcTan + 90;
    }//end else

    // notify the display that we need to repaint
    updateDisplay();
  }//end turnToFace

  /**
   * Method to get the picture for this simple turtle
   * @return the picture for this turtle (may be null)
   */
  public Picture getPicture() { return this.picture; }

  /**
   * Method to set the picture for this simple turtle
   * @param pict the picture to use
   */
  public void setPicture(Picture pict){
    this.picture = pict;
  }//end setPicture

  /**
   * Method to get the model display for this simple
   * turtle.
   * @return the model display if there is one else null
   */
  public ModelDisplay getModelDisplay(){
    return this.modelDisplay;
  }//end getModelDisplay

  /**
   * Method to set the model display for this simple
   * turtle.
   * @param theModelDisplay the model display to use
   */
  public void setModelDisplay(
                            ModelDisplay theModelDisplay){
    this.modelDisplay = theModelDisplay;
  }//end setModelDisplay

  /**
   * Method to get value of show info
   * @return true if should show info, else false
   */
  public boolean getShowInfo(){return this.showInfo;}

  /**
   * Method to show the turtle information string
   * @param value the value to set showInfo to
   */
  public void setShowInfo(boolean value){
    this.showInfo = value;
  }//end setShowInfo

  /**
   * Method to get the shell color
   * @return the shell color
   */
  public Color getShellColor(){
    Color color = null;
    if(this.shellColor == null && this.bodyColor != null)
      color = bodyColor.darker();
    else color = this.shellColor;
    return color;
  }//end getShellColor

  /**
   * Method to set the shell color
   * @param color the color to use
   */
  public void setShellColor(Color color){
    this.shellColor = color;
  }//setShellColor

  /**
   * Method to get the body color
   * @return the body color
   */
  public Color getBodyColor(){return this.bodyColor;}

  /**
   * Method to set the body color which
   * will also set the pen color
   * @param color the color to use
   */
  public void setBodyColor(Color color){
    this.bodyColor = color;
    setPenColor(this.bodyColor);
  }//end setBodyColor

  /**
   * Method to set the color of the turtle.
   * This will set the body color
   * @param color the color to use
   */
  public void setColor(Color color){
    this.setBodyColor(color);
  }//end setColor

  /**
   * Method to get the information color
   * @return the color of the information string
   */
  public Color getInfoColor(){return this.infoColor;}

  /**
   * Method to set the information color
   * @param color the new color to use
   */
  public void setInfoColor(Color color){
    this.infoColor = color;
  }//setInfoColor

  /**
   * Method to return the width of this object
   * @return the width in pixels
   */
  public int getWidth(){return this.width;}

  /**
   * Method to return the height of this object
   * @return the height in pixels
   */
  public int getHeight(){return this.height;}

  /**
   * Method to set the width of this object
   * @param theWidth in width in pixels
   */
  public void setWidth(int theWidth){
    this.width = theWidth;
  }//end setWidth

  /**
   * Method to set the height of this object
   * @param theHeight the height in pixels
   */
  public void setHeight(int theHeight){
    this.height = theHeight;
  }//end setHeight

  /**
   * Method to get the current x position
   * @return the x position (in pixels)
   */
  public int getXPos(){return this.xPos;}

  /**
   * Method to get the current y position
   * @return the y position (in pixels)
   */
  public int getYPos(){return this.yPos;}

  /**
   * Method to get the pen
   * @return the pen
   */
  public Pen getPen(){return this.pen;}

  /**
   * Method to set the pen
   * @param thePen the new pen to use
   */
  public void setPen(Pen thePen){this.pen = thePen;}

  /**
   * Method to check if the pen is down
   * @return true if down else false
   */
  public boolean isPenDown(){return this.pen.isPenDown();}

  /**
   * Method to set the pen down boolean variable
   * @param value the value to set it to
   */
  public void setPenDown(boolean value){
    this.pen.setPenDown(value);
  }//end setPenDown

  /**
   * Method to lift the pen up
   */
  public void penUp(){this.pen.setPenDown(false);}

  /**
   * Method to set the pen down
   */
  public void penDown(){this.pen.setPenDown(true);}

  /**
   * Method to get the pen color
   * @return the pen color
   */
  public Color getPenColor(){return this.pen.getColor();}

  /**
   * Method to set the pen color
   * @param color the color for the pen ink
   */
  public void setPenColor(Color color){
    this.pen.setColor(color);
  }//end setPenColor

  /**
   * Method to set the pen width
   * @param width the width to use in pixels
   */
  public void setPenWidth(int width){
    this.pen.setWidth(width);
  }//end setPenWidth

  /**
   * Method to get the pen width
   * @return the width of the pen in pixels
   */
  public int getPenWidth(){return this.pen.getWidth();}

  /**
   * Method to clear the path (history of
   * where the turtle has been)
   */
  public void clearPath(){
    this.pen.clearPath();
  }//end clearPath

  /**
   * Method to get the current heading
   * @return the heading in degrees
   */
  public double getHeading(){return this.heading;}

  /**
   * Method to set the heading
   * @param heading the new heading to use
   */
  public void setHeading(double heading){
    this.heading = heading;
  }//end setHeading

  /**
   * Method to get the name of the turtle
   * @return the name of this turtle
   */
  public String getName(){return this.name;}

  /**
   * Method to set the name of the turtle
   * @param theName the new name to use
   */
  public void setName(String theName){
    this.name = theName;
  }//end setName

  /**
   * Method to get the value of the visible flag
   * @return true if visible else false
   */
  public boolean isVisible(){return this.visible;}

  /**
   * Method to hide the turtle (stop showing it)
   * This doesn't affect the pen status
   */
  public void hide(){this.setVisible(false);}

  /**
   * Method to show the turtle (doesn't affect
   * the pen status
   */
  public void show(){this.setVisible(true);}

  /**
   * Method to set the visible flag
   * @param value the value to set it to
   */
  public void setVisible(boolean value){
    // if the turtle wasn't visible and now is
    if (visible == false && value == true){
      // update the display
      this.updateDisplay();
    }//end if

    // set the visibile flag to the passed value
    this.visible = value;
  }//end setVisible

  /**
   * Method to update the display of this turtle and
   * also check that the turtle is in the bounds
   */
  public synchronized void updateDisplay(){
    // check that x and y are at least 0
    if (xPos &lt; 0) xPos = 0;
    if (yPos &lt; 0) yPos = 0;

    // if picture
    if (picture != null){
      if (xPos &gt;= picture.getWidth())
        xPos = picture.getWidth() - 1;
      if (yPos &gt;= picture.getHeight())
        yPos = picture.getHeight() - 1;
      Graphics g = picture.getGraphics();
      paintComponent(g);
    }//end if
    else if (modelDisplay != null){
      if (xPos &gt;= modelDisplay.getWidth())
        xPos = modelDisplay.getWidth() - 1;
      if (yPos &gt;= modelDisplay.getHeight())
        yPos = modelDisplay.getHeight() - 1;
      modelDisplay.modelChanged();
    }//end else if
  }//end updateDisplay

  /**
   * Method to move the turtle foward 100 pixels
   */
  public void forward(){forward(100);}

  /**
   * Method to move the turtle forward the given number
   * of pixels
   * @param pixels the number of pixels to walk forward in
   * the heading direction
   */
  public void forward(int pixels){
    int oldX = xPos;
    int oldY = yPos;

    // change the current position
    xPos = oldX + (int)(pixels * Math.sin(Math.toRadians(
                                               heading)));
    yPos = oldY + (int)(pixels * -Math.cos(Math.toRadians(
                                               heading)));

    // add a move from the old position to the new
    // position to the pen
    pen.addMove(oldX,oldY,xPos,yPos);

    // update the display to show the new line
    updateDisplay();
  }//end forward

  /**
   * Method to go backward by 100 pixels
   */
  public void backward(){backward(100);}

  /**
   * Method to go backward a given number of pixels
   * @param pixels the number of pixels to walk backward
   */
  public void backward(int pixels){
    forward(-pixels);
  }//end backward

  /**
   * Method to move to turtle to the given x and y
   * location
   * @param x the x value to move to
   * @param y the y value to move to
   */
  public void moveTo(int x, int y){
    this.pen.addMove(xPos,yPos,x,y);
    this.xPos = x;
    this.yPos = y;
    this.updateDisplay();
  }//end moveTo

  /**
   * Method to turn left
   */
  public void turnLeft(){this.turn(-90);}

  /**
   * Method to turn right
   */
  public void turnRight(){this.turn(90);}

  /**
   * Method to turn the turtle the passed degrees
   * use negative to turn left and pos to turn right
   * @param degrees the amount to turn in degrees
   */
  public void turn(int degrees){
    this.heading = (heading + degrees) % 360;
    this.updateDisplay();
  }//end turn

  /**
   * Method to draw a passed picture at the current turtle
   * location and rotation in a picture or model display
   * @param dropPicture the picture to drop
   */
  public synchronized void drop(Picture dropPicture){
    Graphics2D g2 = null;

    // only do this if drawing on a picture
    if (picture != null)
      g2 = (Graphics2D) picture.getGraphics();
    else if (modelDisplay != null)
      g2 = (Graphics2D) modelDisplay.getGraphics();

    // if g2 isn't null
    if (g2 != null){

      // save the current tranform
      AffineTransform oldTransform = g2.getTransform();

      // rotate to turtle heading and translate to xPos
      // and yPos
      g2.rotate(Math.toRadians(heading),xPos,yPos);

      // draw the passed picture
      g2.drawImage(dropPicture.getImage(),xPos,yPos,null);

      // reset the tranformation matrix
      g2.setTransform(oldTransform);

      //  draw the pen
      pen.paintComponent(g2);
    }
  }//end drop

  /**
   * Method to paint the turtle
   * @param g the graphics context to paint on
   */
  public synchronized void paintComponent(Graphics g){
    // cast to 2d object
    Graphics2D g2 = (Graphics2D) g;

    // if the turtle is visible
    if (visible){
      // save the current tranform
      AffineTransform oldTransform = g2.getTransform();

      // rotate the turtle and translate to xPos and yPos
      g2.rotate(Math.toRadians(heading),xPos,yPos);

      // determine the half width and height of the shell
      int halfWidth = (int) (width/2); // of shell
      int halfHeight = (int) (height/2); // of shell
      int quarterWidth = (int) (width/4); // of shell
      int thirdHeight = (int) (height/3); // of shell
      int thirdWidth = (int) (width/3); // of shell

      // draw the body parts (head)
      g2.setColor(bodyColor);
      g2.fillOval(xPos - quarterWidth,
                  yPos - halfHeight - (int) (height/3),
                  halfWidth, thirdHeight);
      g2.fillOval(xPos - (2 * thirdWidth),
                  yPos - thirdHeight,
                  thirdWidth,thirdHeight);
      g2.fillOval(xPos - (int) (1.6 * thirdWidth),
                  yPos + thirdHeight,
                  thirdWidth,thirdHeight);
      g2.fillOval(xPos + (int) (1.3 * thirdWidth),
                  yPos - thirdHeight,
                  thirdWidth,thirdHeight);
      g2.fillOval(xPos + (int) (0.9 * thirdWidth),
                  yPos + thirdHeight,
                  thirdWidth,thirdHeight);

      // draw the shell
      g2.setColor(getShellColor());
      g2.fillOval(xPos - halfWidth,
                  yPos - halfHeight, width, height);

      // draw the info string if the flag is true
      if (showInfo) drawInfoString(g2);

      // reset the tranformation matrix
      g2.setTransform(oldTransform);
    }//end if

    //  draw the pen
    pen.paintComponent(g);
  }//end paintComponent

  /**
   * Method to draw the information string
   * @param g the graphics context
   */
  public synchronized void drawInfoString(Graphics g){
    g.setColor(infoColor);
    g.drawString(
             this.toString(),xPos + (int) (width/2),yPos);
  }//end drawInfoString

  /**
   * Method to return a string with information
   * about this turtle
   * @return a string with information about this object
   */
  public String toString(){
    return this.name + " turtle at " + this.xPos + ", " +
      this.yPos + " heading " + this.heading + ".";
  }//end toString

} // end of class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Source code for the program named Java344a. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Java344a
 * The purpose of this program is to illustrate the use
 * of several different methods of the Turtle class.
 * 
 * Also illustrates dropping pictures at the current
 * position and orientation of the turtle.
 * 
 * Moves a Turtle object around on a World and drops 
 * several copies of a small Picture along the way.
 */
import java.awt.Color;
public class Main{
  public static void main(String[] args){
    //Following statement eliminates necessity to manually
    // establish location of media files. Modify this to
    // point to the mediasources folder on your machine.
    FileChooser.setMediaPath("M:/Ericson/mediasources/");
    
    //Instantiate an object of a small picture of a turtle
    // with a white background.
    Picture p2 = new Picture("turtle.jpg");
    
    //Note that the Turtle object is different from the
    // image of the turtle in the Picture object.
    World mars = new World(400,500);
    Turtle joe = new Turtle(300,400,mars);
    joe.setShellColor(Color.RED);
    joe.setPenColor(Color.BLUE);
    joe.setPenWidth(2);
    joe.drop(p2);//Draw a small picture
    joe.forward(90);
    joe.drop(p2);
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);
  }//end main

}//end class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Source code for the program named Java344b.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Java344b
 * The purpose of this program is to illustrate the use
 * of several different methods of the Turtle class, as
 * well as to illustrate the placement of a Turtle object
 * on a Picture object.
 * 
 * Also illustrates dropping pictures at the current
 * position and orientation of the turtle.
 * 
 * Moves a Turtle object around on a Picture and drops 
 * several copies of a smaller Picture along the way.
 */
import java.awt.Color;
public class Main{
  public static void main(String[] args){
    //Following statement eliminates necessity to manually
    // establish location of media files. Modify this to
    // point to the mediasources folder on your machine.
    FileChooser.setMediaPath("M:/Ericson/mediasources/");
    
    //Instantiate two objects of Picture class, each of 
    // which encapsulates an image.
    Picture p1 = new Picture("butterfly1.jpg");//large
    Picture p2 = new Picture("turtle.jpg");//small
    
    //Note that the Turtle object is different from the
    // image of the turtle in the Picture object.
    Turtle joe = new Turtle(300,400,p1);
    joe.setShellColor(Color.RED);
    joe.setPenColor(Color.BLUE);
    joe.setPenWidth(2);
    joe.setVisible(true);
    joe.drop(p2);//Draw a small picture
    joe.forward(90);
    joe.drop(p2);
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);
    joe.turn(-30);
    joe.forward();
    joe.drop(p2);

    p1.show();
  }//end main

}//end class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
