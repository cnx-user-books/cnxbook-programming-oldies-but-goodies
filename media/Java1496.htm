<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Using the Full-Screen Exclusive Mode API in Java</h2>
<p> <i>Learn how to use the Full-Screen Exclusive Mode API to write programs 
that take over the entire screen.&nbsp; Also learn how to use active rendering as opposed to passive rendering to 
eliminate the overhead associated with passive rendering.</i></p><b>Published:</b>&nbsp; 
May 30, 2006<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
<p>Java Programming Notes # 1496</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#General%20Background%20Information">General
Background Information</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
	<ul><li> <a href="#The_program_named_FullScreen01">The Program Named 
		FullScreen01</a></li>
		<li> <a href="#The_program_named_FullScreen02">The Program Named 
		FullScreen02</a></li></ul>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> <font color="#FF0000"><b>Oh for the <i>good old days</i></b></font></p>
<p> Do you have a secret longing for the <i>&quot;good old days&quot;</i> when you could 
write a program that would take over the entire screen and wouldn't be bothered 
by a lot of pesky other programs competing for screen space.&nbsp; If so, those 
days are back.&nbsp; In this lesson, I will show you how to use the <i>Full-Screen Exclusive Mode API</i> to 
write programs that take over 
the entire screen, as shown by the output from the animation program in
<a href="#Figure_3">Figure 3</a>.</p>
<p> Once your program has entered the <i>Full-Screen Exclusive Mode</i>, I will show 
you how to use <i>active rendering</i> as opposed to <i>passive rendering</i> to 
eliminate the overhead associated with <i>passive rendering</i>.</p>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different listings and figures while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>I also recommend that you pay particular attention to the lessons listed in 
the <a href="#References">References</a> section of this document.
</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General Background Information</a></font></h2>
<p><font color="#FF0000"><b>Display many programs concurrently</b></font></p>
<p>Recent history would indicate that in most cases, it is probably best to 
have a multitude of programs running concurrently and sharing screen space, as 
indicated by the typical screen shot of my computer in
<a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>Dedicate display capacity to a single program</b></font></p>
<p>However, sometimes it might be best to dedicate the computational and display capacity of your computer screen to a single 
program as shown in <a href="#Figure_3">Figure 3</a>.&nbsp; Dedicating the 
display capacity to a single program can be achieved by writing the program so 
that uses the <i>Full-Screen Exclusive Mode API</i>.</p>
<p><font color="#FF0000"><b>Active versus passive rendering</b></font></p>
<p>In addition to providing dedicated display space, the use of <i>Full-Screen 
Exclusive Mode</i> makes it possible to employ <i>active rendering</i> as opposed to <i>passive rendering</i> of 
the material on the screen.&nbsp; This eliminates some of the rendering 
overhead, and should make the system more responsive when running simulation, game, and animation programs 
where a responsive screen display is important.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>A screen shot <i>(showing the entire screen)</i> of my computer screen during a typical working session is 
shown in <a name="Figure_1">Figure 1</a>.</p>






<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1496a01.jpg" width="470" height="353"><br></pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, there were several different applications competing for space 
on my screen when I captured the screen shot.</p>
<p><font color="#FF0000"><b>A sense of scale</b></font></p>
<p>I'm sure that you have no interest in what my computer 
screen happened to look like while I was writing this lesson.&nbsp; 
<a href="#Figure_1">Figure 1</a> is 
provided to give you a sense of scale <i>(The purpose is similar to that of photographing 
a small object 
with a coin laying beside it so that the size of the object will be apparent.)&nbsp; </i>Because of the narrow publication 
format for this lesson, it was not possible for me to show screen shots in their full size.&nbsp; 
Therefore, the size of the image in 
<a href="#Figure_1">Figure 1</a> was reduced from 1024x768 pixels to 
470x353 pixels for publication purposes.</p>
<p><font color="#FF0000"><b>The output from the program named <i>FullScreen01</i></b></font></p>
<p><a href="#Figure_2">Figure 2</a> shows a screen shot of my computer screen 
while running the 
program named <b>FullScreen01</b>.&nbsp; <i>(Once again, <a name="Figure_2">
Figure 2</a> shows my entire screen.)</i></p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1496a02.jpg" width="470" height="353"><br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A <i>JFrame</i> object in <i>Full-Screen Exclusive Mode</i></b></font></p>
<p>As was the case in <a href="#Figure_1">Figure 1</a>, the screen-shot image in <a href="#Figure_2">Figure 2</a> was also reduced to 470x353 pixels for 
inclusion in this lesson.&nbsp; Briefly, <a href="#Figure_2">Figure 2</a> shows a <b>JFrame</b> object 
displayed by a program using the <i>Full-Screen Exclusive Mode API</i>.</p>
<blockquote>
	<p><i>(In the remainder of this lesson, I will often refer to the 
	Full-Screen Exclusive Mode simply 
	as the full-screen mode.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>One button and four labels</b></font></p>
<p>For illustration purposes, the <b>JFrame</b> object shown in <a href="#Figure_2">Figure 2</a> has a
<b>JButton</b> object placed in the NORTH location, and has <b>JLabel</b> 
objects with colored backgrounds placed in the other four locations managed by 
the <b>BorderLayout</b> manager.</p>
<p>I will present and explain the code for the program named <b>Layout01</b> 
later in this lesson.</p>
<p><font color="#FF0000"><b>A more substantive program</b></font></p>
<p>I will also present and explain a much more substantive program named <b>
FullScreen02</b> in this lesson.&nbsp; A screen shot <i>(showing the entire 
screen)</i> of the output from the program named 
<b>FullScreen02</b> is shown 
in <a name="Figure_3">Figure 3</a>.</p>
<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1496a03.jpg" width="470" height="353"><br></pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Figure_3">Figure 3</a> shows the result of running an animation program in full-screen 
mode.&nbsp; </p>
<p><font color="#FF0000"><b>Based on an earlier animation lesson</b></font></p>
<p>The animation program named <b>FullScreen02</b> is largely based on an 
animation program that I presented and explained in an earlier lesson entitled
<a href="http://www.developer.com/java/article.php/930871">Fun with Java: 
Animated Sea Worms</a>.&nbsp; However, the version of the program that I will 
present and explain this 
lesson makes use of full-screen mode, and also includes some other modernization 
features relative to the earlier version.</p>
<p><font color="#FF0000"><b>Begin with <i>FullScreen01</i></b></font></p>
<p>I will begin by explaining the program named <b>FullScreen01</b>.&nbsp; The 
purpose of this program is to teach you how to implement full-screen mode while 
avoiding the additional complexity of a substantive application.</p>
<p>Then I will explain the more 
substantive program named <b>FullScreen02</b>, to teach you how to make 
productive use of full-screen mode once you know how to implement it.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
<h3><a name="The_program_named_FullScreen01">The Program Named FullScreen01</a></h3>
<p><b>FullScreen01</b> is a skeleton program that implements the <i>Full-Screen Exclusive Mode 
API</i>.</p>
<p><font color="#FF0000"><b>An undecorated non-resizable <i>JFrame</i> object</b></font></p>
<p>The program places an undecorated non-resizable <b>JFrame</b> object on the 
screen in the <i>Full-Screen Exclusive Mode</i>.&nbsp; The <b>JFrame</b> object 
is managed by a <b>BorderLayout</b> manager.&nbsp; A <b>JButton</b> object appears in the 
NORTH location of the <b>JFrame</b> as shown in <a href="#Figure_2">Figure 2</a>.&nbsp; Clicking the button causes the 
program to exit the full-screen mode, restore the original graphics mode, and 
terminate.</p>
<p>The program places red, green, and white <b>JLabel</b> objects in the EAST, 
WEST, SOUTH, and CENTER locations of the <b>JFrame</b> object, as shown in 
<a href="#Figure_2">Figure 2</a>.&nbsp; This is done to demonstrate that the graphics object that occupies the 
entire screen is an undecorated non-resizable <b>JFrame</b> object.</p>
<p><font color="#FF0000"><b>A list of screen devices</b></font></p>
<p>The program displays a list of the available screen devices solely for 
information purposes in the command-line window.&nbsp; <i>(There is only one 
available screen device on my laptop computer, but there may be more than one on your 
computer.)</i>&nbsp; However, the command line window is hidden behind the 
full-screen version of the <b>JFrame</b> object and isn't visible until the 
full-screen mode is terminated.</p>
<p><font color="#FF0000"><b>Use only the first screen device in the list</b></font></p>
<p>Even though the program displays a list of all of the available screen 
devices, it operates only on the first screen device in the list.</p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>The program was tested using J2SE5.0 under WinXP.&nbsp; J2SE 1.4 or later is 
required to support the <b>setFullScreenWindow</b> method of the <b>
GraphicsDevice</b> object.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As is my custom, I will discuss the program in fragments.&nbsp; You can view 
a complete listing of the program in <a href="#Listing_26">Listing 26</a> near the end of the lesson.</p>
<p>The class definition begins in <a name="Listing_1">Listing 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class FullScreen01 extends JFrame 
                                 implements ActionListener{

  private GraphicsDevice graphicsDevice;
  private DisplayMode origDisplayMode;
  private JButton exitButton = new JButton(
                                  "Exit Full-Screen Mode");<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A container and an action listener</b></font></p>
<p>The class extends <b>JFrame</b> and implements <b>ActionListener</b>.&nbsp; 
Thus an object of the class is a top-level container that can be placed directly 
on the computer screen as a GUI.&nbsp; An object of the class is also suitable 
for being registered as an action listener on objects that fire action events.</p>
<p>The code in <a href="#Listing_1">Listing 1</a> declares a couple of instance variables that will be 
used later.&nbsp; It also declares, instantiates, and initializes a reference to the <b>JButton</b> 
object shown at the top of <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method begins in <a name="Listing_2">Listing 2</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void <b>main</b>(String[] args){

    GraphicsEnvironment graphicsEnvironment = 
         GraphicsEnvironment.getLocalGraphicsEnvironment();

    GraphicsDevice[] devices = 
                    graphicsEnvironment.getScreenDevices();

    for(int cnt = 0;cnt &lt; 1;cnt++){
      System.out.println(devices[cnt]);
    }//end for loop<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>List all available screen devices</b></font></p>
<p>The <b>main</b> method begins by getting and displaying a list of all the 
available screen devices on the computer.&nbsp; As you can see in 
<a href="#Listing_2">Listing 2</a>, 
getting the list of screen devices is a two-step process:</p>
<ol>
	<li>Get a <b>GraphicsEnvironment</b> object that describes your computer.</li>
	<li>Invoke the <b>getScreenDevices</b> method on that object to get a list 
	of available screen devices, each as a reference to an object of type <b>
	GraphicsDevice</b>.</li>
</ol>
<p><font color="#FF0000"><b>The <i>GraphicsEnvironment</i> class and <i>GraphicsDevice</i> 
objects</b></font></p>
<p>Here is part of what Sun has to say about the <b>GraphicsEnvironment</b> 
class and <b>GraphicsDevice</b> objects:</p>
<blockquote>
	<p><i>&quot;The <b>GraphicsEnvironment</b> class describes the collection of <b>
	GraphicsDevice</b> objects and <b>Font</b> objects available to a Java(tm) 
	application on a particular platform. The resources in this <b>
	GraphicsEnvironment</b> might be local or on a remote machine. <b>
	GraphicsDevice</b> objects can be screens, printers or image buffers and are 
	the destination of <b>Graphics2D</b> drawing methods. Each <b>GraphicsDevice</b> 
	has a number of <b>GraphicsConfiguration</b> objects associated with it. 
	These objects specify the different configurations in which the <b>
	GraphicsDevice</b> can be used.&quot;</i></p>
</blockquote>
<p>This seems straightforward enough, and shouldn't require further explanation.</p>
<p><font color="#FF0000"><b>The <i>getScreenDevices</i> method</b></font></p>
<p>As you have probably also guessed, the Sun documentation for the <b>
getScreenDevices</b> method of the <b>GraphicsEnvironment</b> class states that the method <i>&quot;Returns an array of all 
of the screen <b>GraphicsDevice</b> objects.&quot;</i>&nbsp; <i>(The class provides 
several other interesting instance methods that you might want to investigate as 
well.)</i></p>
<p><font color="#FF0000"><b>Display the list of screen devices</b></font></p>
<p>After getting the list of available screen devices, the code in 
<a href="#Listing_2">Listing 2</a> 
uses a <b>for</b> loop to display the items in the list in the command-line 
window.&nbsp; On my laptop computer, the single-item list of screen devices reads as follows:</p>
<p><pre><b>Win32GraphicsDevice[screen=0]</b></pre></p>
<p>The remainder of the <b>main</b> method is shown in <a name="Listing_3">Listing 3</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    new FullScreen01(devices[0]);
  }//end main<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The constructor for <i>FullScreen01</i></b></font></p>
<p>The statement in <a href="#Listing_3">Listing 3</a> instantiates an object of the <b>FullScreen01</b> 
class, causing the constructor for the class, which begins in 
<a name="Listing_4">Listing 4</a>, to be 
executed.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public FullScreen01(GraphicsDevice graphicsDevice){

    this.graphicsDevice = graphicsDevice;<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the code in <a href="#Listing_3">Listing 3</a> passes the first reference in the list of 
screen devices to the constructor that begins in <a href="#Listing_4">Listing 4</a>.&nbsp; The code in 
<a href="#Listing_4">Listing 4</a> saves this reference in one if the instance variables that was 
declared in <a href="#Listing_1">Listing 1</a>.&nbsp; This reference will be used later when time comes 
to exit the full-screen mode.</p>
<p><font color="#FF0000"><b>The <i>JFrame</i> title</b></font></p>
<p>The code in <a name="Listing_5">Listing 5</a> sets the <i>title</i> property on the <b>JFrame</b> object.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    setTitle("<b>This title will be hidden (undecorated)</b>");

<br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I included this code to remind me to mention that when the <b>JFrame</b> object is 
displayed as an undecorated object the title 
doesn't show.&nbsp; <i>(The <b>JFrame</b> object will be displayed as an 
undecorated <b>JFrame</b> in this lesson.)</i></p>
<p><font color="#FF0000"><b>Save the original display mode</b></font></p>
<p><a name="Listing_6">Listing 6</a> gets and saves a reference to the original display mode in one of 
the instance variables declared in <a href="#Listing_1">Listing 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    origDisplayMode = graphicsDevice.getDisplayMode();<br><br><b><font face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This reference will be used later by the program to restore the original 
display mode before terminating.</p>
<p><font color="#FF0000"><b>The <i>JButton</i> object</b></font></p>
<p><a name="Listing_7">Listing 7</a> registers this <b>FullScreen01</b> object as an <b>ActionListener</b> on the <b>JButton</b> object that was 
instantiated in <a href="#Listing_1">Listing 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    exitButton.addActionListener(this);
    
    getContentPane().add(exitButton, BorderLayout.NORTH);<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I will discuss the behavior of the <b>ActionListener </b>object a little later in 
conjunction with the discussion of the <b>actionPerformed</b> method.</p>
<p>Then <a href="#Listing_7">Listing 7</a> places the <b>JButton</b> object at the top of the <b>JFrame</b> 
object as shown in <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>Add some colored <i>JLabel</i> objects</b></font></p>
<p><a name="Listing_8">Listing 8</a> places four colored <i>(red, green, and white)</i> <b>JLabel</b> objects in the remaining <b>
BorderLayout</b> positions in the <b>JFrame</b> object to demonstrate that the 
screen is filled with an undecorated <b>JFrame</b> object as shown in <a href="#Figure_2">Figure 2</a>. </p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Place four labels in the JFrame solely for the
    // purpose of showing that it is a full-screen
    // undecorated JFrame.
    JLabel eastLabel = new JLabel("     East     ");
    eastLabel.setOpaque(true);
    eastLabel.setBackground(Color.RED);
    getContentPane().add(eastLabel,BorderLayout.EAST);
    
    JLabel southLabel = 
                 new JLabel("South",SwingConstants.CENTER);
    southLabel.setOpaque(true);
    southLabel.setBackground(Color.GREEN);
    getContentPane().add(southLabel,BorderLayout.SOUTH);
    
    JLabel westLabel = new JLabel("     West     ");
    westLabel.setOpaque(true);
    westLabel.setBackground(Color.RED);
    getContentPane().add(westLabel,BorderLayout.WEST);
    
    JLabel centerLabel = 
                new JLabel("Center",SwingConstants.CENTER);
    centerLabel.setOpaque(true);
    centerLabel.setBackground(Color.WHITE);
    getContentPane().add(centerLabel,BorderLayout.CENTER);<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Switch to <i>Full-Screen Exclusive Mode</i></b></font></p>
<p><a name="Listing_9">Listing 9</a> invokes the <b>isFullScreenSupported</b> method to confirm that the 
device is capable of operating in <i>Full-Screen Exclusive Mode</i>, and if so, 
invokes the <b>setFullScreenWindow</b> method to switch the display to the <i>
Full-Screen Exclusive Mode</i>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if (graphicsDevice.<b>isFullScreenSupported</b>()){
      // Enter full-screen mode with an undecorated,
      // non-resizable JFrame object.
      setUndecorated(true);
      setResizable(false);
      //Make it happen!
      graphicsDevice.<b>setFullScreenWindow</b>(this);
      validate();
    }else{
      System.out.println("Full-screen mode not supported");
    }//end else    

  }//end constructor<br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The <i>isFullScreenSupported</i> method</b></font></p>
<p>As you probably guessed from the syntax, the <b>isFullScreenSupported</b> 
method returns <i>true</i> if the <b>GraphicsDevice</b> object supports <i>
Full-Screen Exclusive Mode</i>, and returns <i>false</i> otherwise.</p>
<p><font color="#FF0000"><b>The <i>setFullScreenWindow</i> method</b></font></p>
<p>Invoking the <b>setFullScreenWindow</b> method has a number of interesting 
ramifications in addition to switching the screen to <i>Full-Screen Exclusive 
Mode</i>.&nbsp; I recommend that you go to the Sun documentation and read 
about those ramifications prior to using this mode in production programs.</p>
<p><font color="#FF0000"><b>An undecorated non-resizable <i>JFrame</i> object</b></font></p>
<p>Although it isn't a requirement to do so, <a href="#Listing_9">Listing 9</a> sets the <i>undecorated</i> 
property of the <b>JFrame</b> object to <i>true</i> and the <i>resizable</i> 
property to <i>false</i>.</p>
<p>Setting the<i> undecorated</i> property to <i>true </i>eliminates the title 
bar at the top and the borders on the sides of the <b>JFrame</b> object as shown 
in <a href="#Figure_2">Figure 2</a>.&nbsp; Although not required, this probably should be done, particularly if <i>active 
rendering</i> is to be used.&nbsp; Otherwise, the <b>JFrame</b> object can be 
moved or iconified by the user to expose other windows behind it in the Z-order.</p>
<blockquote>
	<p>(<i>Having eliminated the title bar and the borders, I suppose that 
	setting the resizable property to false may be superfluous, because there is 
	nothing to grab hold of with the mouse to change the size.&nbsp; I don't 
	know if it is possible to change the size of a <b>JFrame</b> object without 
	the use of a mouse by using keystrokes alone.&nbsp; If so, this is not 
	superfluous and the resizable property should be set to false.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The full-screen object should appear</b></font></p>
<p><a href="#Listing_9">Listing 9</a> signals the end of the constructor.&nbsp; Once the constructor has 
executed, the <b>JFrame</b> object should fill the screen as shown in <a href="#Figure_2">Figure 2</a>.&nbsp; 
</p>
<p><a href="#Figure_2">Figure 2</a> shows the results on my laptop computer with a screen size of 
1024x768 pixels.&nbsp; Your results may be somewhat different depending on your 
overall screen size in pixels, and the sizes of your fonts.&nbsp; The font size 
determines the height of the <b>JButton</b> object at the top and the <b>JLabel</b> 
object at the bottom, as well as the widths of the two <b>JLabel</b> objects on 
the sides.</p>
<p><font color="#FF0000"><b>The <i>ActionEvent</i> handler</b></font> </p>
<p>That leaves us with one more item to discuss for this program.&nbsp; 
<a name="Listing_10">Listing 
10</a> shows the <b>actionPerformed</b> method, which is invoked when the button at 
the top of <a href="#Figure_2">Figure 2</a> is clicked.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void <b>actionPerformed</b>(ActionEvent evt){
    //Restore the original display mode
    graphicsDevice.setDisplayMode(origDisplayMode);
    //Terminate the program
    System.exit(0);
  }//end actionPerformed
}//end class<br><br><b><font face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The <i>setDisplayMode</i> method</b></font></p>
<p><a href="#Listing_10">Listing 10</a> invokes the <b>setDisplayMode</b> method of the <b>GraphicsDevice</b> 
class, passing a reference to the <b>DisplayMode</b> object saved earlier in 
order to restore the display mode to the original display mode.&nbsp; Then 
<a href="#Listing_10">Listing 10</a> terminates the program.</p>
<p>Sun has this to say about the <b>setDisplayMode</b> method:</p>
<blockquote>
	<p><i>&quot;Sets the display mode of this graphics device. This may only be 
	allowed in full-screen, exclusive mode.&quot;</i></p>
</blockquote>
<p>Sun has this to say about the <b>DisplayMode</b> class:</p>
<blockquote>
	<p><i>&quot;The <b>DisplayMode</b> class encapsulates the bit depth, height, 
	width, and refresh rate of a <b>GraphicsDevice</b>. Display modes are 
	hardware-dependent and may not always be available.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>May be superfluous</b></font></p>
<p>Setting the display mode in this manner at this point may be superfluous.&nbsp; 
For this program on my computer, it doesn't seem to make any difference relative 
to the appearance of the display after the program terminates whether or not I 
invoke this method prior to termination.</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p><a href="#Listing_10">Listing 10</a> signals the end of the class and the end of the program.</p>
<p>You should be able to use this skeleton to write programs that use the <i>
Full-Screen Exclusive Mode API</i>.&nbsp; As you will see in the next program 
named <b>FullScreen02</b>, this skeleton can be wrapped around a much more 
substantive application to control the display mode used by that application.</p>
<p><font color="#FF0000"><b>Shrink the Exit button</b></font></p>
<p>If you use the full-screen mode with an <i>undecorated</i> <b>Frame</b> or <b>
JFrame</b> object, you should always provide an <b>Exit</b> button to terminate.&nbsp;
<i>(The buttons that are typically in the upper-right corner of the frame will 
be unavailable.)</i>&nbsp; However, the <b>Exit</b> button needn't be as large 
as the one shown in <a href="#Figure_2">Figure 2</a>.&nbsp; Rather, you should be able to use a 
different layout manager and place a small <b>Exit</b> button unobtrusively in 
one of the corners of the screen.</p>
<h3><a name="The_program_named_FullScreen02">The Program Named FullScreen02</a></h3>
<p>The purpose of this program is to demonstrate the use of the <i>Full-Screen 
Exclusive Mode API</i> for simulation and animation.</p>
<p><font color="#FF0000"><b>Update to an earlier program</b></font></p>
<p>This program animates colored sea worms on a background image in <i>Full-Screen 
Exclusive Mode</i>.&nbsp; A screen shot of the program in operation is shown in 
<a href="#Figure_3">Figure 3</a>.&nbsp; The program is an update to the program named <b>Animate03</b>, 
which I explained in the earlier lesson entitled
<a href="http://www.developer.com/java/article.php/930871">Fun with Java: 
Animated Sea Worms</a>.</p>
<p>This version of the animation code has been modernized to make use of 
the Swing <b>Timer</b> class as an animation timer, and also to use <i>Active 
Rendering</i> as opposed to <i>Passive Rendering</i> in <i>Full-Screen Exclusive 
Mode</i>.&nbsp; The program has also been modernized to use
<a href="http://www.developer.com/java/other/article.php/3495121">generics</a>.</p>
<p><font color="#FF0000"><b>Active rendering</b></font></p>
<p>You will find a good discussion of <i>Active Rendering</i> 
versus <i>Passive Rendering</i> in
<a href="http://java.sun.com/docs/books/tutorial/extra/fullscreen/exclusivemode.html">
The Java Tutorial</a>.</p>
<p>Because the program uses <i>Active Rendering</i>, it does not call the <b>repaint</b> 
method to ask the operating system to make a callback to the <b>update</b> method.&nbsp; 
Rather, the program invokes a method named <b>activeRenderer</b>, which causes 
the animated sprites to be drawn on the screen without concern for sharing the screen with 
other applications.&nbsp; <i>(There are no other applications on the screen in 
Full-Screen Exclusive Mode.)</i></p>
<p><font color="#FF0000"><b>An undecorated, non-resizable <i>JFrame</i> object</b></font></p>
<p>As shown in <a href="#Figure_3">Figure 3</a>, the program places an undecorated non-resizable <b>JFrame</b> object on the 
screen in <i>Full-Screen Exclusive Mode</i>.&nbsp; A <b>JButton</b> is placed in 
the NORTH location in the <b>JFrame</b>.&nbsp; Clicking the button causes the 
program to exit the full- screen mode, restore the original graphics mode, and 
terminate.</p>
<p><font color="#FF0000"><b>A <i>JPanel</i> in the <i>JFrame</i></b></font></p>
<p>A <b>JPanel</b> object is placed in the center of the <b>JFrame</b> object.&nbsp; 
The colored worms are animated as sprites on the <b>JPanel</b> object.</p>
<p>A 
background image is drawn on the <b>JPanel</b> object at the beginning of each 
animation cycle.&nbsp; This image erases the sprites that were previously there 
producing a clean slate for drawing the sprites in their new locations.&nbsp; </p>
<p><font color="#FF0000"><b>Importance of the background image</b></font></p>
<p>The drawing of the background image can be eliminated by deleting one 
statement from the program.&nbsp; If the background image is eliminated, the worms turn into long tubes because 
the old sprite images are never erased.</p>
<p>The background image that I used fits a 
1024 x 768 screen in <i>Full-Screen Exclusive Mode</i>.&nbsp; If your screen is a 
different size, a different size background image will be required.</p>
<p>The program was tested using J2SE5.0 under 
WinXP.&nbsp; J2SE 1.4 or later is required to support the <b>setFullScreenWindow</b> 
method of a <b>GraphicsDevice</b> object.&nbsp; However, J2SE 5.0 or later is required to support 
<a href="http://www.developer.com/java/other/article.php/3495121">generics</a>.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As usual, I will discuss this program in fragments.&nbsp; You can view the 
program in its entirety in <a href="#Listing_27">Listing 27</a> near the end of the lesson.</p>
<p><font color="#FF0000"><b>Won't discuss all of the code</b></font></p>
<p>Because this program is an update of the program named <b>Animate03</b>, 
which I explained in the lesson entitled
<a href="http://www.developer.com/java/article.php/930871">Fun with Java: 
Animated Sea Worms</a>, I will assume that you already understand that code, as 
well as the code in the other lessons listed in the <a href="#References">
References</a> section of this document.&nbsp; I won't repeat the explanation of 
that code in this lesson.</p>
<p>Also, this animation program is wrapped in the skeleton that I explained 
earlier in this lesson for the program named <b>FullScreen01</b>.&nbsp; I will also assume that 
you understand that code and won't repeat the explanation of that code here.</p>
<p>Rather, I will explain only the code that is new and different in this 
program.</p>
<p>An abbreviated listing of the beginning of the class and the <b>main</b> 
method is shown in <a name="Listing_11">Listing 11</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class FullScreen02 extends JFrame 
                                 implements ActionListener{

  //Code deleted for brevity.
  
  public static void <b>main</b>(String[] args){
    //Code deleted for brevity.
  }//end main<br><br><b><font face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in this part of the program is essentially the same as in the 
program named <b>FullScreen01</b>.&nbsp; Therefore, I deleted that code from 
<a href="#Listing_11">Listing 11</a> for brevity.&nbsp; Once again, you can view the program named <b>
FullScreen02</b> in its entirety in <a href="#Listing_27">Listing 27</a> near the end of the lesson.</p>
<p><font color="#FF0000"><b>The constructor for <i>FullScreen02</i></b></font></p>
<p>The constructor begins in <a name="Listing_12">Listing 12</a>.&nbsp; Much of the code in this 
constructor is the same as in the earlier program.&nbsp; Therefore, I deleted 
the repeated code for brevity.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public FullScreen02(GraphicsDevice graphicsDevice){

    //Code deleted for brevity.
    
    getContentPane().<b>add(new AnimationPanel()</b>);

    //Code deleted for brevity.    

  }//end constructor<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>An animation panel</b></font></p>
<p>The only significant difference between this constructor and the constructor 
that I explained earlier occurs in the single statement shown in 
<a href="#Listing_12">Listing 12</a>.&nbsp; 
This statement instantiates an object of the class <b>AnimationPanel</b> and 
places it in the center of the <b>JFrame</b> object.&nbsp; This is the mechanism 
by which the skeleton program wraps the <i>Full-Screen Exclusive Mode</i> around the 
animation program.</p>
<p><font color="#FF0000"><b>The <i>actionPerformed</i> method</b></font></p>
<p><a name="Listing_13">Listing 13</a> shows the <b>actionPerformed</b> method, which is the same as 
before.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void actionPerformed(ActionEvent evt){
    //Code deleted for brevity.
  }//end actionPerformed

}//end class FullScreen02<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_13">Listing 13</a> also signals the end of the class definition for the class named
<b>FullScreen02</b>.</p>
<p><font color="#FF0000"><b>The <i>BackgroundImage</i> class</b></font></p>
<p><a name="Listing_14">Listing 14</a> shows an abbreviated version of a class named <b>
Background Image</b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
class BackgroundImage{
  //Code deleted for brevity.
}//end class BackgroundImage<br><br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is a convenience class, from the earlier program named<b> Animate03</b>, 
which makes it a little easier to deal with the background image. Note, however, 
that this version is much simpler than the earlier version.&nbsp; Much of the 
impetus for this class went away when the animation program named <b>Animate03</b> 
was converted to full-screen mode.&nbsp; Several convenience methods having to 
do with the size of the background image were eliminated in conjunction with 
that conversion.</p>
<p><font color="#FF0000"><b>The <i>SpriteManager</i> class</b></font></p>
<p><a name="Listing_15">Listing 15</a> shows an abbreviated and slightly modified version of a class 
named <b>SpriteManager</b> from the earlier program named <b>Animate03</b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class SpriteManager{
  private ArrayList <b>&lt;Sprite&gt;</b> theSprites = 
                                   new ArrayList<b>&lt;Sprite&gt;</b>();
    //Code deleted for brevity.<P<pre>
}//end class SpriteManager<br><br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>An object of this class manages a collection of animated sprites stored in an
<b>ArrayList</b> object.&nbsp; <i>(A <b>Vector</b> object was used in the 
earlier version named <b>Animate03</b>.)</i>&nbsp; Note that this class also 
underwent some modernization with respect to the use of
<a href="http://www.developer.com/java/other/article.php/3495121">generics</a> 
as shown by the boldface code near the beginning of <a href="#Listing_15">Listing 15</a>.</p>
<p><font color="#FF0000"><b>The <i>Sprite</i> class</b></font></p>
<p><a name="Listing_16">Listing 16</a> shows an abbreviated and slightly modified version of the <b>
Sprite</b> class from the earlier program named <b>Animate03</b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sprite{
  //Code deleted for brevity.
  private ArrayList <b>&lt;History&gt;</b> tailData = 
                                  new ArrayList<b>&lt;History&gt;</b>();

  //Code deleted for brevity.

  public void drawSpriteImage(Graphics g){
    //Code deleted for brevity.
    Iterator <b>&lt;History&gt;</b> iterator = tailData.iterator();
    //Code deleted for brevity.
  }//end drawSpriteImage()

  //Code deleted for brevity.

}//end Sprite class<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As suggested by the name, this is the class from which the sprites are 
instantiated.</p>
<p>This class was also updated for
<a href="http://www.developer.com/java/other/article.php/3495121">generics</a> 
as indicated by the boldface code in <a href="#Listing_16">Listing 16</a>.</p>
<p><font color="#FF0000"><b>The <i>History</i> class</b></font></p>
<p><a name="Listing_17">Listing 17</a> shows an abbreviated version of the <b>History</b> class from the 
earlier program named <b>Animate03</b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class History{
  //Code deleted for brevity.
}//end class History<br><br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>An object of this class is used to contain state information for each segment of each worm.</p>
<p><font color="#FF0000"><b>The <i>AnimationPanel</i> class</b></font></p>
<p>The animation is played out by drawing images on an object of the 
<b>AnimationPanel</b> class, which begins in <a href="#Listing_18">Listing 18</a>.&nbsp; An object of this class 
is placed in the CENTER of an undecorated non-resizable <b>JFrame</b> object 
that is displayed in <i>Full-Screen Exclusive Mode</i>.</p>
<p>Most of the code in this class was applied directly to the <b>JFrame</b> object in the 
earlier program named <b>Animate03</b>, because in that program, the animation 
images were drawn directly on the <b>JFrame</b> <a name="Listing_18">object</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class AnimationPanel extends JPanel implements Runnable{

    //Code deleted for brevity.

  private int <b>animationDelay = 83</b>;
  private <b>javax.swing.Timer animationTimer;</b><br><br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Uses a <i>Swing</i> <i>Timer</i> object</b></font></p>
<p>The first substantive difference between this code and the code in the 
earlier program named <b>Animate03</b> is shown by the boldface code in 
<a href="#Listing_18">Listing 18</a>.&nbsp; This program uses an object of the <b>javax.swing.Timer</b> class to 
control the animation timing, whereas the earlier program used a timer built around the <b>sleep</b> method of the <b>Thread</b> class.</p>
<p>The <b>animationDelay</b> value of 83 milliseconds shown in
<a href="#Listing_18">Listing 18</a> will result in an animation frame rate of 
approximately twelve frames per second.</p>
<p><a href="#Listing_18">Listing 18</a> declares an instance variable named <b>animationTimer</b>, which will 
be populated later with a reference to a <b>Timer</b> object.</p>
<p><font color="#FF0000"><b>The constructor for the <i>AnimationPanel</i> class</b></font></p>
<p>The constructor begins in <a name="Listing_19">Listing 19</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public AnimationPanel(){//constructor
    // Load and track the images
    mediaTracker = new MediaTracker(this);
    
    //Get and track the background image.
    backGroundImage = Toolkit.getDefaultToolkit().
                              getImage("background03.gif");<br><br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When you run this program, you will need to have an image file named <b>
background03.gif</b> with a size that matches the size of your computer screen.&nbsp; 
In my case, that is 1024x768 pixels, but your screen may be a different size.&nbsp; 
That image is loaded by the code in <a href="#Listing_19">Listing 19</a>.</p>
<p><font color="#FF0000"><b>The <i>Timer</i> object</b></font></p>
<p>The next substantive difference is shown by the code shown in
<a name="Listing_20">Listing 20</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    animationTimer = <b>new javax.swing.Timer</b>(animationDelay,
      new ActionListener(){
        public void <b>actionPerformed</b>(ActionEvent e){
          //Update the sprites
          spriteManager.<b>updateSprites</b>();
          //Update the animation panel on the screen
          <b>activeRenderer</b>(getGraphics());
        }//end actionPerformed
      }//end new ActionListener
    );//end new javax.swing.Timer

  }//end constructor<br><br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_20">Listing 20</a> instantiates a <b>Timer</b> object and registers an 
anonymous <b>ActionListener</b> on it using the peculiar listener registration 
process for a <b>Timer</b> object.</p>
<blockquote>
	<p><i>(An <b>ActionListener</b> object is registered on a <b>Timer</b> 
	object by passing the listener object's reference as the second parameter to 
	the constructor for the <b>Timer</b> object.&nbsp; Then the listener object 
	is notified of an <b>ActionEvent</b> each time the <b>Timer</b> object 
	ticks.&nbsp; In this program, I set the <b>Timer</b> object to tick once 
	every 83 milliseconds in <a href="#Listing_18">Listing 18</a>.&nbsp; This later results in 
	approximately twelve animation frames per second being drawn on the 
	animation panel.)</i></p>
</blockquote>
<p>The <b>Timer</b> object must be <i>started </i>before it will begin ticking.&nbsp; 
It will be started in the <b>run</b> method of the animation thread after 
everything is set up and is ready to run.</p>
<p><font color="#FF0000"><b>The <i>ActionEvent</i> handler</b></font></p>
<p>Each time the <b>Timer</b> object ticks, the <b>actionPerformed</b> method 
shown in <a href="#Listing_20">Listing 20</a> is executed.&nbsp; The code in this method invokes the <b>
updateSprites</b> method on the <b>SpriteManager</b> object.&nbsp; This causes 
the state of each sprite to be updated in terms of location, color, direction of 
motion, etc.</p>
<p>Then the code in the <b>actionPerformed</b> method invokes the <b>
activeRenderer</b> method to cause the background image and the updated sprites 
to be drawn on the animation panel.&nbsp; Note that control does not flow 
through the operating system in a <i>callback</i> sense as is typically the case 
with <i>passive rendering</i>.&nbsp; Instead, the <b>activeRenderer</b> method 
causes the material to be drawn directly on the screen without regard for 
sharing the screen with other programs.</p>
<p><font color="#FF0000"><b>The <i>activeRenderer</i> method</b></font></p>
<p>The <b>activeRenderer</b> method is shown in its entirety in 
<a name="Listing_21">Listing 21</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private void activeRenderer(Graphics g){
    //Create the offscreen graphics context
    if(offScreenGraphicsCtx == null){
      offScreenImage = 
             createImage(getSize().width,getSize().height);
      offScreenGraphicsCtx = offScreenImage.getGraphics();
    }//end if

    // Draw the sprites offscreen
    spriteManager.drawScene(offScreenGraphicsCtx);

    // Draw the scene onto the screen
    if(offScreenImage != null){
      g.drawImage(offScreenImage,0,0,this);
    }//end if

  }//end activeRenderer method<br><br><b><font face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>activeRenderer</b> method is used to draw directly on the screen using
<i>active rendering</i> without invoking the <b>repaint</b> method as is the case for
<i>passive rendering</i>.</p>
<p><font color="#FF0000"><b>Same as earlier code</b></font></p>
<p>The code in the <b>activeRenderer</b> method is essentially the same as the 
code that I explained in the overridden <b>update(Graphics g)</b> method in the 
earlier program named <b>Animate03</b>.&nbsp; Therefore, I won't repeat the 
explanation of that code here.</p>
<p>The big difference is the flow of control through which the two methods are 
called.&nbsp; The <b>activeRenderer</b> method is called directly in this 
program.&nbsp; The overridden <b>update</b> method in the earlier program is 
called in a <i>callback</i> sense after the program invokes the <b>repaint</b> method 
to send a message to the operating system requesting the callback.&nbsp; The <i>
active rendering</i> approach eliminates the overhead associated with that 
callback system, and therefore should be more responsive than <i>passive 
rendering</i>.</p>
<p><font color="#FF0000"><b>The <i>makeSprite</i> method</b></font></p>
<p><a name="Listing_22">Listing 22</a> shows an abbreviated version of the <b>makeSprite</b> method.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private Sprite <b>makeSprite</b>(Point position,int imageIndex){
    //Code deleted for brevity.
  }//end makeSprite()<br><br><b><font face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method is essentially the same as the version in the earlier program 
named <b>Animate03</b>, so I won't discuss it further.</p>
<p><font color="#FF0000"><b>The animation thread</b></font></p>
<p>The <b>run</b> method for the animation thread begins in <a name="Listing_23">Listing 23</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void run(){
    while(getWidth() == 0){
      System.out.print(".");
    }//end while loop
    while(getHeight() == 0){
      System.out.print(".");
    }//end while loop<br><br><b><font face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Delay until size is stable</b></font></p>
<p>The <b>run</b> method begins by creating and adding sprites to the <b>
SpriteManager</b> object.&nbsp; First, however, the code in 
<a href="#Listing_23">Listing 23</a> implements a loop to delay the 
process until the <b>AnimationPanel</b> is fully constructed and the width and height of the <b>AnimationPanel</b> 
has become stable in
<i>Full-Screen Exclusive Mode</i>.</p>
<p>There is probably a better way to do this, but I don't know what it is right 
off the top of my head.&nbsp; In any event, this happens only once while the 
program is getting started and is switching from normal mode to <i>Full-Screen 
Exclusive Mode</i>.&nbsp; Therefore, I didn't worry too much about it.&nbsp; If 
this were something that happens often during the running of the program, I 
would have given more thought towards a better solution to the problem.</p>
<p><font color="#FF0000"><b>Create and add 200 worms</b></font></p>
<p><a name="Listing_24">Listing 24</a> creates 200 sprites <i>(200 worms in 
<a href="#Figure_3">Figure 3</a>)</i> and hands them 
off to the <b>SpriteManager</b> object.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    spriteManager = new SpriteManager(
                 new BackgroundImage(this,backGroundImage),
                 getWidth(),
                 getHeight());

    //Create 200 sprites from 6 gif files.
    for(int cnt = 0;cnt &lt; 200;cnt++){
      Point position = 
                 spriteManager.getEmptyPosition(
                 new Dimension(gifImages[0].getWidth(this),
                 gifImages[0].getHeight(this)));
      spriteManager.addSprite(
                             makeSprite(position,cnt % 6));
    }//end for loop
<br><b><font face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the published version of the earlier program named <b>Animate03</b> 
only had fifteen worms swimming around in the fish tank.&nbsp; However, that 
program operated in a small <b>JFrame</b> object where fifteen worms represented 
a crowd.&nbsp; This program has the entire screen for the worms to swim in, so 
there is plenty of room for all 200 worms as shown in <a href="#Figure_3">Figure 3</a>.</p>
<p><font color="#FF0000"><b>Smooth animation up to 800 worms</b></font></p>
<p>As an interesting side note, I increased the number of sprites in this 
full-screen program to 800 worms with no apparent loss in smooth animation at 
twelve animation frames per second.&nbsp; As the number of worms increased 
beyond 800, however, the quality of the animation began to deteriorate.</p>
<p><font color="#FF0000"><b>Let the show begin</b></font></p>
<p><a name="Listing_25">Listing 25</a> causes the animation timer to start running and generating 
approximately twelve ticks per second.&nbsp; That in turn causes the worms to 
start swimming.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
    animationTimer.<b>start</b>();//Start the animation timer

  }//end run method

}//end AnimationPanel class<br><br><b><font face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once started, the worms will continue to swim until the user clicks the 
button at the top of <a href="#Figure_3">Figure 3</a> to terminate the program.</p>
<p><a href="#Listing_25">Listing 25</a> also signals the end of the <b>AnimationPanel</b> class and the 
end of the program.</p>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code from <a href="#Listing_26">Listing 26</a> 
and <a href="#Listing_27">Listing 27</a> into your text
editor, compile it, and execute it.&nbsp; Experiment with it, making
changes, and observing the results of your changes.</p>
<p><font color="#FF0000"><b>You will need some images</b></font></p>
<p><a name="Figure_4">Figure 4</a> contains links to the image files that you 
will need to run the program named <b>FullScreen02.</b>&nbsp;
</p>
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td><br>
<center><pre><img SRC="java1496c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1496d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1496e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1496f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1496g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1496h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1496i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center><br>
Figure 4.&nbsp; GIF image files that you will need.</center>

<p>You should be able to capture the images by right-clicking on them 
individually, and then saving them into files on your local disk.&nbsp; Having done 
that, you will need to rename the files to match the names that are hard-coded 
into the program.</p>
<p><font color="#FF0000"><b>Resize the background image</b></font></p>
<p>In addition, you will need to resize the background image to cause it to 
match the size of your computer screen.&nbsp; You will need an image processing 
program such as <a href="http://www.lview.com/">LView</a> to resize the image.&nbsp; 
In case you don't already have one, a trial version is available for <a href="http://www.lview.com/download.htm">
downloading</a>.</p>
<p><font color="#FF0000"><b>Image resizing within the program</b></font></p>
<p>As you will see in the comments in the program, it is supposed to be possible 
to cause the image file to be resized when it is loaded by the program.&nbsp; 
I was unable to get that to work properly, but I didn't spend much time 
troubleshooting the problem.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p> In this lesson, I showed you how to use the <i>Full-Screen Exclusive Mode API</i> to 
write programs that take over 
the entire screen, as shown by the output from the animation program in
<a href="#Figure_3">Figure 3</a>.</p>
<p> I also showed you how to use <i>active rendering</i> as opposed to <i>passive rendering</i> to 
eliminate the overhead associated with <i>passive rendering</i>.</p>
<ul>
</ul>
<h2 align="center"><a name="References">References</a></h2>
<p>The program named <b>FullScreen02</b> is an update to a program named <b>
Animate03</b>, first published in the last lesson in the following list.</p>
<ul>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_893471,00.html">
	1450</a> Fun with Java: Sprite Animation, Part 1</li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/sdjjavase/article/0,,12395_897751,00.html">
	1452</a> Fun with Java: Sprite Animation, Part 2 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_902071,00.html">
	1454</a> Fun with Java: Sprite Animation, Part 3 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_906501,00.html">
	1456</a> Fun with Java: Sprite Animation, Part 4 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_910811,00.html">
	1458</a> Fun with Java: Sprite Animation, Part 5 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_915191,00.html">
	1460</a> Fun with Java: Sprite Animation, Part 6 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_920121,00.html">
	1462</a> Fun with Java: Sprite Animation, Part 7 </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_924551,00.html">
	1464</a> Fun with Java: Frame Animation </li>
	<li>
	<a href="http://softwaredev.earthweb.com/java/article/0,,12082_930871,00.html">
	1466</a> Fun with Java: Animated Sea Worms</li>
</ul>
<p>The program named <b>Animate03</b> uses material published in the earlier 
lessons in the above list.</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
<a name="Listing_26">Listing 26</a> and <a href="#Listing_27">Listing 27</a> below. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*FullScreen01.java
This is a skeleton program that implements the
Full-Screen Exclusive Mode

The program places an undecorated non-resizable JFrame
object on the screen in the Full-Screen Exclusive Mode.

A JButton appears in the North location of the JFrame.
Clicking the button causes the program to exit the full-
screen mode, restore the original graphics mode, and
terminate.

The program places red, green, and white JLabels in the
East, West, South, and Center locations solely to 
demonstrate that the graphics object is an undecorated
non-resizable JFrame object.

The program displays a list of the available graphics 
devices solely for information purposes in the command-
line window.  However, that window is hidden behind the
full-screen version of the JFrame object and isn't visible
until the full-screen mode is terminated.

Even though the program displays a list of all of the
graphics devices, it operates only on the first graphics 
device in the list.

Tested using J2SE5.0 under WinXP.  J2SE 1.4 or later is
required for the setFullScreenWindow method of the
GraphicsDevice object.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

public class FullScreen01 extends JFrame 
                                 implements ActionListener{

  private GraphicsDevice graphicsDevice;
  private DisplayMode origDisplayMode;
  private JButton exitButton = new JButton(
                                  "Exit Full-Screen Mode");
  
  public static void main(String[] args){
    //Get and display a list of graphics devices solely for
    // information purposes.
    GraphicsEnvironment graphicsEnvironment = 
         GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice[] devices = 
                    graphicsEnvironment.getScreenDevices();
    for(int cnt = 0;cnt &lt; 1;cnt++){
      System.out.println(devices[cnt]);
    }//end for loop
    
    //Construct a full-screen object using
    // graphicsDevice 0.
    new FullScreen01(devices[0]);
  }//end main

  //Constructor
  public FullScreen01(GraphicsDevice graphicsDevice){
    //Save a reference to the graphics device as an
    // instance variable so that it can be used later to
    // exit the full-screen mode.
    this.graphicsDevice = graphicsDevice;
    
    setTitle("This title will be hidden (undecorated)");
    
    //Get and save a reference to the original display
    // mode as an instance variable so that it can be
    // restored later.
    origDisplayMode = graphicsDevice.getDisplayMode();
    
    //Register an action listener on the exitButton.
    exitButton.addActionListener(this);
    
    //Place the exitButton in the JFrame    
    getContentPane().add(exitButton, BorderLayout.NORTH);
    
    //Place four labels in the JFrame solely for the
    // purpose of showing that it is a full-screen
    // undecorated JFrame.
    JLabel eastLabel = new JLabel("     East     ");
    eastLabel.setOpaque(true);
    eastLabel.setBackground(Color.RED);
    getContentPane().add(eastLabel,BorderLayout.EAST);
    
    JLabel southLabel = 
                 new JLabel("South",SwingConstants.CENTER);
    southLabel.setOpaque(true);
    southLabel.setBackground(Color.GREEN);
    getContentPane().add(southLabel,BorderLayout.SOUTH);
    
    JLabel westLabel = new JLabel("     West     ");
    westLabel.setOpaque(true);
    westLabel.setBackground(Color.RED);
    getContentPane().add(westLabel,BorderLayout.WEST);
    
    JLabel centerLabel = 
                new JLabel("Center",SwingConstants.CENTER);
    centerLabel.setOpaque(true);
    centerLabel.setBackground(Color.WHITE);
    getContentPane().add(centerLabel,BorderLayout.CENTER);

    if (graphicsDevice.isFullScreenSupported()){
      // Enter full-screen mode witn an undecorated,
      // non-resizable JFrame object.
      setUndecorated(true);
      setResizable(false);
      //Make it happen!
      graphicsDevice.setFullScreenWindow(this);
      validate();
    }else{
      System.out.println("Full-screen mode not supported");
    }//end else    

  }//end constructor

  //The following method is invoked when the used clicks
  // the exitButton
  public void actionPerformed(ActionEvent evt){
    //Restore the original display mode
    graphicsDevice.setDisplayMode(origDisplayMode);
    //Terminate the program
    System.exit(0);
  }//end actionPerformed
}//end class<br><br><b><font face="Courier New,Courier">Listing 26</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_27">Listing 27</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*FullScreen02.java
Copyright 2006, R.G.Baldwin

The purpose of this program is to demonstrate the use of
the Full-Screen Exclusive Mode API for simulation and
animation.

This program is an update to the earlier program named
Animate03 as described in the earlier lesson number 
Java1466.  This program has been modernized to
make use of the Swing Timer class as an animation timer,
and also to use Active Rendering (as opposed to Passive
Rendering) in Full-Screen Exclusive Mode.  It has also been
modernized to use generics.

The program animates colored worms on a background image
in Full-Screen Exclusive mode.  See the discussion of
Active Rendering versus Passive Rendering in The Java
Tutorial at:

http://java.sun.com/docs/books/tutorial/extra/fullscreen/
index.html

Using Active Rendering, the program does not call the 
repaint method to ask the operating system to call the 
update method.  Rather, the program invokes a method named 
activeRenderer, which draws the animated sprites on the 
screen without concern for sharing the screen with other
applications.  (There are no other applications on the
screen in full-screen mode.)

The program places an undecorated non-resizable JFrame
object on the screen in Full-Screen Exclusive Mode.

A JButton appears in the North location of the JFrame.
Clicking the button causes the program to exit the full-
screen mode, restore the original graphics mode, and
terminate.

A JPanel appears in the center of the JFrame object.
The colored worms are animated as sprites on the JPanel.
A background image is drawn on the JPanel at the beginning
of each animation cycle.  This image erases the sprites
that were previously there creating a clean slate for 
drawing the sprites in their new positions.  If the
background image is eliminated, the worms turn into long
tubes because the old sprite images are never erased.

The background image that is used fits a 1024 x 768
screen in Full-Screen Exclusive mode.  If the screen is
a different size, a different size background image is
needed.

Tested using J2SE5.0 under WinXP.  J2SE 1.4 or later is
required for the setFullScreenWindow method of the
GraphicsDevice object.  J2SE 5.0 or later is required
to support generics.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

class FullScreen02 extends JFrame 
                                 implements ActionListener{

  private GraphicsDevice graphicsDevice;
  private DisplayMode origDisplayMode;
  private JButton exitButton = new JButton(
     "Exit Full-Screen Mode  Copyright 2006, R.G.Baldwin");
  
  public static void main(String[] args){
    //Get a list of available graphics devices.
    GraphicsEnvironment graphicsEnvironment = 
         GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice[] devices = 
                    graphicsEnvironment.getScreenDevices();
    
    //Construct a full-screen object using the first
    // graphics device in the array.  Ignore the others, if
    // there are any.
    new FullScreen02(devices[0]);
  }//end main
  //-----------------------------------------------------//

  //Constructor
  public FullScreen02(GraphicsDevice graphicsDevice){
    //Save a reference to the graphics device as an
    // instance variable so that it can be used later to
    // exit the full-screen mode.
    this.graphicsDevice = graphicsDevice;
    
    setTitle("This title will be hidden (undecorated)");
    
    //Get and save a reference to the original display
    // mode as an instance variable so that it can be
    // restored later.
    origDisplayMode = graphicsDevice.getDisplayMode();
    
    //Register an action listener on the exitButton.
    exitButton.addActionListener(this);
    
    //Place the exitButton at the top of the JFrame    
    getContentPane().add(exitButton,BorderLayout.NORTH);
    
    //Create an animation panel and place it in the center
    // of the JFrame.
    getContentPane().add(new AnimationPanel());

    if(graphicsDevice.isFullScreenSupported()){
      // Enter full-screen mode witn an undecorated,
      // non-resizable JFrame object.
      setUndecorated(true);
      setResizable(false);
      graphicsDevice.setFullScreenWindow(this);
      validate();
    }else{
      System.out.println("Full-screen mode not supported");
    }//end else    

  }//end constructor
  //-----------------------------------------------------//

  //The following method is invoked when the used clicks
  // the exitButton
  public void actionPerformed(ActionEvent evt){
    //Restore the original display mode
    graphicsDevice.setDisplayMode(origDisplayMode);
    //Terminate the program
    System.exit(0);
  }//end actionPerformed
  //-----------------------------------------------------//
}//end class FullScreen02
//=======================================================//

//This is a convenience class that makes it a little
// easier to deal with the background image.  Note that
// much of the impetus for this class went away when the
// animation program named Animate 03 was converted to
// full-screen mode. Several convenience methods having to
// do with the size of the background image were eliminated
// at that time.
class BackgroundImage{
  private Image image;
  private Component component;

  public BackgroundImage(Component component,Image image){
    this.component = component;
    this.image = image;
  }//end construtor

  public void drawBackgroundImage(Graphics g){
    //Note that component is an ImageObserver in the
    // following statement.
    g.drawImage(image,0,0,component);
  }//end drawBackgroundImage()
}//end class BackgroundImage
//=======================================================//

//An object of this class manages a collection of animated
// sprites stored in an ArrayList object.  (A Vector
// object was used in the earlier version named Animate03.)
// Note that this class also underwent some modernization
// with respect to the use of generics as released in
// J2SE 5.0. 
class SpriteManager{
  private ArrayList &lt;Sprite&gt; theSprites = 
                                   new ArrayList&lt;Sprite&gt;();
  private BackgroundImage backgroundImage;
  private int panelWidth;
  private int panelHeight;
  //-----------------------------------------------------//
  
  public SpriteManager(BackgroundImage backgroundImage,
                       int panelWidth,
                       int panelHeight){
    this.backgroundImage = backgroundImage;
    this.panelWidth = panelWidth;
    this.panelHeight = panelHeight;
  }//end constructor
  //-----------------------------------------------------//
  
  public Point getEmptyPosition(Dimension spriteSize){
    Rectangle trialSpaceOccupied = new Rectangle(
                   0,0,spriteSize.width,spriteSize.height);
    Random rand = new Random(System.currentTimeMillis());
    boolean empty = false;
    int numTries = 0;

    //Search for an empty position.  If an empty position
    // can't be found after 100 tries, give up and allow
    // two sprites to occupy the same initial location.
    while(!empty && numTries++ &lt; 100){
      // Get a trial position
      trialSpaceOccupied.x = Math.abs(
                              rand.nextInt() % panelWidth);
      trialSpaceOccupied.y = Math.abs(
                             rand.nextInt() % panelHeight);

      // Iterate through existing sprites, checking if
      // position is empty
      boolean collision = false;
      for(int cnt = 0;cnt &lt; theSprites.size();cnt++){
        Rectangle testSpaceOccupied = 
                    theSprites.get(cnt).getSpaceOccupied();

        if(trialSpaceOccupied.intersects(
                                       testSpaceOccupied)){
          collision = true;
        }//end if
      }//end for loop
      empty = !collision;
    }//end while loop
    
    return new Point(trialSpaceOccupied.x,
                                     trialSpaceOccupied.y);
  }//end getEmptyPosition()
  //-----------------------------------------------------//
  
  //This method updates the state information for each of
  // the sprites.
  public void updateSprites(){
    Sprite sprite;
    
    //Iterate through sprite list
    for(int cnt = 0;cnt &lt; <P<pre>theSprites.size();cnt++){
      sprite = theSprites.get(cnt);
      //Update a sprite's position
      sprite.updatePosition();

      //Test for collision. Positive 
      // result indicates a collision
      int hitIndex = testForCollision(sprite);
      if(hitIndex &gt;= 0){
        //A collision has occurred.  Make the two sprites
        // involved in the collision bounce off the other
        // sprite.
        bounceOffSprite(cnt,hitIndex);
      }//end if
    }//end for loop
  }//end updateSprites
  //-----------------------------------------------------//
  
  //This method tests for a collision between two sprites.
  private int testForCollision(Sprite testSprite){
    //Check for collision with other sprites
    Sprite  sprite;
    for(int cnt = 0;cnt &lt; theSprites.size();cnt++){
      sprite = theSprites.get(cnt);
      if(sprite == testSprite)
        //Don't check self
        continue;
      //Invoke testCollision method of Sprite class to
      // perform the actual test.
      if(testSprite.testCollision(sprite))
        //Return index of colliding sprite
        return cnt;
    }//end for loop
    return -1;//No collision detected
  }//end testForCollision()
  //-----------------------------------------------------//
  
  private void bounceOffSprite(
                        int spriteAindex,int spriteBindex){
    //Swap motion vectors for bounce algorithm
    Sprite spriteA = theSprites.get(spriteAindex);
    Sprite spriteB = theSprites.get(spriteBindex);
    Point swap = spriteA.getMotionVector();
    spriteA.setMotionVector(spriteB.getMotionVector());
    spriteB.setMotionVector(swap);
  }//end bounceOffSprite()
  //-----------------------------------------------------//
  
  //This method draws the sprites in their new locations
  // on the animation panel.
  public void drawScene(Graphics g){
    //Draw the background and erase sprites from animation
    // panel.
    //Disable the following statement for an interesting
    // effect.  This will turn the short worms into tube
    // worms that increase in length forever.
    backgroundImage.drawBackgroundImage(g);

    //Iterate through sprites, drawing each sprite
    for(int cnt = 0;cnt &lt; theSprites.size();cnt++)
      theSprites.get(cnt).drawSpriteImage(g);
  }//end drawScene()
  //-----------------------------------------------------//
  
  public void addSprite(Sprite sprite){
    //Add a new sprite to the ArrayList object.
    theSprites.add(sprite);
  }//end addSprite()
  //-----------------------------------------------------//
}//end class SpriteManager
//=======================================================//

//The class from which Sprite objects are instantiated.
class Sprite{
  private Component component;
  private Image[] image;
  private Rectangle spaceOccupied;
  private Point motionVector;
  private Rectangle bounds;
  private Random rand;
  private int frameNumber;
  //The following collection contains a reference to a
  // History object containing state information about
  // each spherical segment that makes up a worm.
  private ArrayList &lt;History&gt; tailData = 
                                  new ArrayList&lt;History&gt;();
  private int wormLength;
  //-----------------------------------------------------//
  
  //Constructor
  public Sprite(Component component,
                Image[] image,
                Point position,
                Point motionVector){
    //Seed a random number generator for this sprite with
    // the sprite position.
    rand = new Random(position.x);
    wormLength = Math.abs(rand.nextInt() % 20);
    this.component = component;
    this.image = image;
    this.spaceOccupied = new Rectangle(
                           position.x,
                           position.y,
                           image[0].getWidth(component),
                           image[0].getHeight(component));
    this.motionVector = motionVector;
    //Compute edges of usable graphics area.  Because we
    // are drawing on a JPanel, we don't need to worry
    // about insets for borders, banner, etc. This is much
    // simpler than in the earlier program named Animate03.
    bounds = new Rectangle(0,0,component.getSize().width,
                               component.getSize().height);
  }//end constructor
  //-----------------------------------------------------//
  
  public Rectangle getSpaceOccupied(){
    return spaceOccupied;
  }//end getSpaceOccupied()
  //-----------------------------------------------------//

  private void setSpaceOccupied(Point position){
    spaceOccupied.setLocation(position.x,position.y);
  }//setSpaceOccupied()
  //-----------------------------------------------------//

  public Point getMotionVector(){
    return motionVector;
  }//end getMotionVector()
  //-----------------------------------------------------//

  public void setMotionVector(Point motionVector){
    this.motionVector = motionVector;
  }//end setMotionVector()
  //-----------------------------------------------------//

  private void setBounds(Rectangle bounds){
    this.bounds = bounds;
  }//end setBounds()
  //-----------------------------------------------------//
  
  public void updatePosition(){
    Point position = new Point(
                          spaceOccupied.x,spaceOccupied.y);
    
    //Insert random behavior.  During each update, a sprite
    // has about one chance in 10 of making a small random
    // change to its motionVector.  When a change occurs,
    // the motionVector coordinate values are forced to
    // fall between -7 and 7.
    if(rand.nextInt() % 10 == 0){
      Point randomOffset = 
          new Point(rand.nextInt() % 3,rand.nextInt() % 3);
      motionVector.x += randomOffset.x;
      if(motionVector.x &gt;= 7) 
        motionVector.x -= 7;
      if(motionVector.x &lt;= -7) 
        motionVector.x += 7;
      motionVector.y += randomOffset.y;
      if(motionVector.y &gt;= 7) 
        motionVector.y -= 7;
      if(motionVector.y &lt;= -7) 
        motionVector.y += 7;
    }//end if

    //Make the move
    position.translate(motionVector.x,motionVector.y);

    //Bounce off the walls
    boolean bounceRequired = false;
    Point tempMotionVector = 
                  new Point(motionVector.x,motionVector.y);
    
    //Handle walls in x-dimension
    if(position.x &lt; bounds.x){
      bounceRequired = true;
      position.x = bounds.x;
      //reverse direction in x
      tempMotionVector.x = -tempMotionVector.x;
    }else if((position.x + spaceOccupied.width) &gt; 
                                (bounds.x + bounds.width)){
      bounceRequired = true;
      position.x = 
             bounds.x + bounds.width - spaceOccupied.width;
      //Reverse direction
      tempMotionVector.x = -tempMotionVector.x;
    }//end else if
    
    //Handle walls in y-dimension
    if(position.y &lt; bounds.y){
      bounceRequired = true;
      position.y = bounds.y;
      tempMotionVector.y = -tempMotionVector.y;
    }else if((position.y + spaceOccupied.height) &gt; 
                               (bounds.y + bounds.height)){
      bounceRequired = true;
      position.y = 
           bounds.y + bounds.height - spaceOccupied.height;
      tempMotionVector.y = -tempMotionVector.y;
    }//end else if
    
    //Save new motionVector
    if(bounceRequired) 
     setMotionVector(tempMotionVector);

    //Update spaceOccupied
    setSpaceOccupied(position);
  }//end updatePosition()
  //-----------------------------------------------------//

  //This method draws each worm, one segment at a time.
  // A new segment is added for the head each time this
  // method is called.  When the worm has reached its
  // specified length, the oldest segment is discarded 
  // each time this method is called.
  public void drawSpriteImage(Graphics g){
    frameNumber = Math.abs(rand.nextInt() % 6);
    //Add a new head to the worm.
    tailData.add(new History(
      image[frameNumber],spaceOccupied.x,spaceOccupied.y));
    Iterator &lt;History&gt; iterator = tailData.iterator();
    int cnt = 0;
    while(iterator.hasNext()){
      //Draw each segment of the worm.
      History history = iterator.next();
      //Discard the first segment in the list if the worm
      // has met its length requirement.  This will keep
      // the length of the worm constant.
      if(tailData.size() &gt; wormLength && cnt == 0){ 
        iterator.remove();
      }//end if
      
      g.drawImage(history.image,
                  history.x,
                  history.y,
                  component);
      cnt++;
    }//end while
  }//end drawSpriteImage()
  //-----------------------------------------------------//

  public boolean testCollision(Sprite testSprite){
    // Check for collision with another sprite
    if(testSprite != this){
      return spaceOccupied.intersects(
                            testSprite.getSpaceOccupied());
    }//end if
    return false;
  }//end testCollision
}//end Sprite class
//=======================================================//

//An object of this class is used to contain state 
// information for each segment of each worm.
class History{
  Image image;
  int x;
  int y;
  
  public History(Image image,int x,int y){
    this.image = image;
    this.x = x;
    this.y = y;
  }//end constructor
}//end class History
//=======================================================//

//The animation is played out by drawing images on an
// object of this class.  The object is placed in the 
// center of an undecorated non-resizable JFrame object
// that is displayed in Full-Screen Exclusive Mode.
//Most of the code in this class was applied to the JFrame
// object in the earlier program named Animate03, because
// in that case, the images were drawn directly on the
// JFrame object.
class AnimationPanel extends JPanel implements Runnable{
  private Image offScreenImage;
  private Image backGroundImage;
  private Image[] gifImages = new Image[6];
  private Graphics offScreenGraphicsCtx;
  private Thread animationThread;
  private MediaTracker mediaTracker;
  private SpriteManager spriteManager;
  //Animation display rate, 12fps
  private int animationDelay = 83;
  private Random rand = 
                    new Random(System.currentTimeMillis());
  private javax.swing.Timer animationTimer;
  //-----------------------------------------------------//
  
  public AnimationPanel(){//constructor
    // Load and track the images
    mediaTracker = new MediaTracker(this);
    
    //Get and track the background image.  Note that this
    // background image is appropriate only for a screen
    // size of 1024x768.  For a different screen size, you
    // will need to use a different background image file.
    backGroundImage = Toolkit.getDefaultToolkit().
                              getImage("background03.gif");
    
    mediaTracker.addImage(backGroundImage,0);
    
    //Note that it should be possible to use the following
    // code to load a smaller version of the image and
    // have it scaled to the required size as it is loaded,
    // but this doesn't seem to work properly.  (I probably
    // just don't understand how it is supposed to work.)
//    backGroundImage = Toolkit.getDefaultToolkit().
//                            getImage("background02.gif");
//    mediaTracker.addImage(backGroundImage,0,1024,768);
    
    //Get and track 6 images to use for sprites
    gifImages[0] = Toolkit.getDefaultToolkit().
                                   getImage("redball.gif");
    mediaTracker.addImage(gifImages[0],0);
    gifImages[1] = Toolkit.getDefaultToolkit().
                                 getImage("greenball.gif");
    mediaTracker.addImage(gifImages[1],0);
    gifImages[2] = Toolkit.getDefaultToolkit().
                                  getImage("blueball.gif");
    mediaTracker.addImage(gifImages[2],0);
    gifImages[3] = Toolkit.getDefaultToolkit().
                                getImage("yellowball.gif");
    mediaTracker.addImage(gifImages[3],0);
    gifImages[4] = Toolkit.getDefaultToolkit().
                                getImage("purpleball.gif");
    mediaTracker.addImage(gifImages[4],0);
    gifImages[5] = Toolkit.getDefaultToolkit().
                                getImage("orangeball.gif");
    mediaTracker.addImage(gifImages[5],0);
    
    //Block and wait for all images to be loaded
    try{
      mediaTracker.waitForID(0);
    }catch(InterruptedException e){
      System.out.println(e);
    }//end catch
    
    //Instantiate an animation thread and start it running.
    animationThread = new Thread(this);
    animationThread.start();
    
    //Instantiate a Timer object and register an anonymous
    // ActionListener on it using the peculiar listener
    // registration process for a Timer object.  The 
    // Timer will be started in the run method of the
    // animationThread.
    animationTimer = new javax.swing.Timer(animationDelay,
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Update the sprites
          spriteManager.updateSprites();
          //Update the animation panel on the screen
          activeRenderer(getGraphics());
        }//end actionPerformed
      }//end new ActionListener
    );//end new javax.swing.Timer

  }//end constructor
  //-----------------------------------------------------//

  //This method is used to draw directly on the screen
  // using Active Rendering, without invoking the repaint
  // method.
  private void activeRenderer(Graphics g){
    //Create the offscreen graphics context
    if(offScreenGraphicsCtx == null){
      offScreenImage = 
             createImage(getSize().width,getSize().height);
      offScreenGraphicsCtx = offScreenImage.getGraphics();
    }//end if

    // Draw the sprites offscreen
    spriteManager.drawScene(offScreenGraphicsCtx);

    // Draw the scene onto the screen
    if(offScreenImage != null){
      g.drawImage(offScreenImage,0,0,this);
    }//end if

  }//end activeRenderer method
  //-----------------------------------------------------//
  
  public void run(){
    //Create and add sprites to the sprite manager
    
    //Delay until the width and the height of the
    // AnimationPanel stabilize in Full-Screen mode.  There
    // is probably a better way to do this, but I don't
    // know what it is.  In any event, this happens only
    // once while the program is getting started and
    // switching to Full-Screen Exclusive Mode.
    while(getWidth() == 0){
      System.out.print(".");
    }//end while loop
    while(getHeight() == 0){
      System.out.print(".");
    }//end while loop

    spriteManager = new SpriteManager(
                 new BackgroundImage(this,backGroundImage),
                 getWidth(),
                 getHeight());
    //Create 200 sprites from 6 gif files.
    for(int cnt = 0;cnt &lt; 200;cnt++){
      Point position = 
                 spriteManager.getEmptyPosition(
                 new Dimension(gifImages[0].getWidth(this),
                 gifImages[0].getHeight(this)));
      spriteManager.addSprite(
                             makeSprite(position,cnt % 6));
    }//end for loop

    animationTimer.start();//Start the animation timer

  }//end run method 
  //-----------------------------------------------------//
  
  private Sprite makeSprite(Point position,int imageIndex){
    return new Sprite(this,
                      gifImages,
                      position,
                      new Point(rand.nextInt() % 5,
                              rand.nextInt() % 5));
  }//end makeSprite()
  //-----------------------------------------------------//
}//end AnimationPanel<br><br><b><font face="Courier New,Courier">Listing 27</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<hr align="center" size="3" width="100%">
<p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java full-screen exclusive mode active passive rendering </p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
