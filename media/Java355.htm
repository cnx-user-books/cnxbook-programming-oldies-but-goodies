<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">The HSB Color Model</h2>
<i>Develop both a technical and an 
intuitive understanding of the HSB color model, which is closer to the way we 
think and talk about color than the RGB color model.</i><p><b>Published:</b>&nbsp; 
March 18, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 355</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_from_earlier_lessons">What you have 
		learned from earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you 
		will learn in this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia 
		class library</a></li>
		<li><a href="#Software_installation_and_testing">Software 
		installation and testing</a></li>
		<li><a href="#The_HSB_color_model">The HSB color model</a></li>
	</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see
<a href="#Resources">Resources</a>)</i> designed to teach you how 
to write Java programs to do things like:</p>
<ul>
	<li>Edit the color of your digital photos</li>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_from_earlier_lessons">What you have learned 
from earlier lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> 
in this series, among other things, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>Many aspects of image processing, including color distance, projecting 
	3D coordinates onto a 2D display plane, and edge detection.</li>
	<li>How to write an animated flocking program.</li>
	<li>How to sharpen or soften your digital photos.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p> In this lesson, you will learn about the HSB color model.&nbsp; You will 
learn that the HSB color model is closer to the way we think and talk about 
color than the RGB color model.&nbsp; You will also learn how to write a program 
that lets you convert back 
and forth between the two models.</p>
<p> The purpose of this lesson 
is to help you develop not only a technical understanding but also an 
intuitive understanding of the HSB color model.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Sample screen output for the 
	program named HsbColor01.</li>
	<li><a href="#Figure_2">Figure 2</a>. Top surface of the HSB cone.</li>
	<li><a href="#Figure_3">Figure 3</a>. HSB parameters for burnt orange in 
	cylinder format.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the class named 
	HsbColor01. </li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the method named 
	handleSliders. </li>
	<li><a href="#Listing_3">Listing 3</a>. Decide between cone and cylinder 
	display formats. </li>
	<li><a href="#Listing_4">Listing 4</a>. Construct a new Ellipse2D.Double 
	object. </li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the pixel processing 
	loop. </li>
	<li><a href="#Listing_6">Listing 6</a>. Compute the hue angle for the pixel. </li>
	<li><a href="#Listing_7">Listing 7</a>. Translate the angle into the correct 
	quadrant. </li>
	<li><a href="#Listing_8">Listing 8</a>. Compute the saturation value for the 
	pixel. </li>
	<li><a href="#Listing_9">Listing 9</a>. Convert to RGB and draw the pixel in 
	the correct color. </li>
	<li><a href="#Listing_10">Listing 10</a>. Get intersection coordinates of 
	hue and saturation.</li>
	<li><a href="#Listing_11">Listing 11</a>. Display the color at the 
	intersection. </li>
	<li><a href="#Listing_12">Listing 12</a>. Draw the white radial hue line and 
	the white saturation circle. </li>
	<li><a href="#Listing_13">Listing 13</a>. Source code for the program named 
	HsbColor01. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see
<a href="#Resources">Resources</a>) </i>by Mark Guzdial and 
Barbara Ericson at Georgia Institute of Technology.&nbsp; In doing this, I will also 
present some interesting sample programs that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h3><a name="The_HSB_color_model">The HSB color model</a></h3>
<p>Color is tricky.&nbsp; Not only do different individuals perceive color in 
different ways, the same color often looks different to the same person when viewed 
under different lighting conditions, and often looks different when viewed on different computer 
monitors.&nbsp; </p>
<p>There are several different models that are used to describe 
color in the computer world.&nbsp; Fortunately, we have well-defined 
mathematical ways to define color.</p>
<p><font color="#FF0000"><b>Won't make you an expert</b></font></p>
<p>Even if I were qualified to do so, I wouldn't try to make you a digital color expert in this lesson.&nbsp; 
Instead, I will briefly introduce you to some of the different color models that 
are in common use today.&nbsp; Then I will try to teach you enough about the HSB 
color model that you can understand what you are doing when you use a program 
that I will explain in a future lesson <i>(or any other software based on HSB)</i> to edit your digital photographs.</p>
<p><font color="#FF0000"><b>What are a color model and a color space?</b></font></p>
<p>According to Wikipedia, <i>&quot;A 
<a href="http://en.wikipedia.org/wiki/Color_model">color model</a> is an 
abstract mathematical model describing the way
<a title="Color" href="http://en.wikipedia.org/wiki/Color">colors</a> can be 
represented as
multiples 
of numbers, typically as three or four values or color components. When this 
model is associated with a precise description of how the components are to be 
interpreted (viewing conditions, etc.), the resulting set of colors is called
<a title="Color space" href="http://en.wikipedia.org/wiki/Color_space">color 
space</a>.&quot;</i></p>
<p><font color="#FF0000"><b>Different color models</b></font></p>
<p>Several different color models are commonly used to represent colors in a 
computer.&nbsp; These include:</p>
<ol>
	<li>The hue, saturation, lightness <i>(HSL) </i>model.</li>
	<li>The hue, saturation, value <i>(HSV)</i> model.</li>
	<li>The hue, saturation, brightness <i>(HSB)</i> model.</li>
	<li>The red, green, blue <i>(RGB)</i> model <i>(with a couple of variations)</i>.</li>
</ol>
<p>I am assuming that you are already well versed in the use of the basic RGB 
color model.&nbsp; In this lesson, we will be concerned mainly with the third 
model in the above list <i>(HSB)</i>.</p>
<p><font color="#FF0000"><b>HSV versus HSB</b></font></p>
<p>According to <i>Light and color:&nbsp; an introduction (see
<a href="#Resources">Resources</a>)</i>,</p>
<blockquote>
	<p><i>&quot;Hue is what we perceive as color. S 
is saturation: 100% is a pure color. 0% is a shade of gray. Value is related to 
brightness. HSV and HSL (below) are obtained by mathematically transforming RGB. 
	<u><b>HSV is the identical to HSB</b></u>&quot;</i></p>
</blockquote>
<p>I included this quotation, and particularly the last sentence in the 
quotation to deal with the following issue.&nbsp; The Java <b>Color</b> class 
provides methods for converting back and forth between the RGB and the HSB color 
models.&nbsp; As far as I know, the Java API 
does not provide direct support for HSV.&nbsp; On the other hand, most of the articles that you 
find on the web refer to the model as HSV rather than HSB.&nbsp; For purposes of 
this lesson, I will assume that either the HSB and HSV models are identical <i>(as indicated in the above quotation)</i>, or 
they are so close that the differences are of no practical importance.</p>
<p><font color="#FF0000"><b>Why do we need HSB when we already have RGB?</b></font></p>
<p>The RGB color model is convenient for storing pixel-color data in a 
computer.&nbsp; In addition, it maps very well into the way that color is 
displayed on a color monitor where each pixel consists of three tiny dots, each 
of which can be caused to glow in red, green, or blue.&nbsp; </p>
<p>However, it does not map very well into the way we think and talk about color.&nbsp; For 
example, it is unlikely that you would go into a clothing store and tell the 
clerk that you would like to see a jacket with a red color value of 0x96<i> (hex)</i>, a 
green color value of 0x48, and a blue color value of 0x1B.&nbsp; <i>(Well -- if 
you are a true computer geek you might, but the clerk probably wouldn't know what you 
are 
talking about.)</i></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="Burnt_orange">Burnt orange</a></b><br />
  If you were a University of Texas sports fan living in my home town of Austin, 
	TX, you could simply tell the clerk that you would like to see a Texas <i>
	burnt orange</i> jacket and the clerk would know exactly what color you are 
	seeking.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Burnt orange</b></font></p>
<p>On the other hand, you might very well describe the color as orange, not too bright, 
and not too vivid or bold.&nbsp; In that case, you would be describing the color 
using parameters that are similar to the parameters in the HSB color model.</p>
<p>To a first approximation, <i>orange</i> corresponds to hue, <i>vivid or bold </i> corresponds to saturation, and <i>bright</i> corresponds to brightness.&nbsp; 
In other words, the HSB color model is closer to the way we think and talk about 
colors than the RGB model.</p>
<p><font color="#FF0000"><b>How did I create burnt orange?</b></font></p>
<p><a name="In_case_you_are_wondering">In case you are wondering</a> how I came up with the RGB formula for 
a color that is very close to UT burnt orange <i>(see <a href="#Burnt_orange">
sidebar</a>)</i>, I used the program that I will 
explain later in this lesson and adjusted the sliders shown in Figure 1 to produce a color that is 
<i>orange, not too bright, and not too vivid or bold</i>.&nbsp; Then I made some 
minor adjustments to the positions of the sliders to produce a color that is very close to the color on a 
University of Texas coffee mug.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain a program that lets you experiment 
with the HSB color model and its relationship to the RGB model.&nbsp; The program displays an HSB color wheel and a 
GUI as shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Sample screen output for the program named 
	HsbColor01</b>.<table bgcolor="#FEFFF0"  border="1" cols="1">
<tr><td><img border="0" src="java355a1.jpg" width="409" height="431"></td></tr>
<tr><td><img border="0" src="java355a2.jpg" width="408" height="224"></td></tr>
</table></p>

<p><font color="#FF0000"><b>The GUI</b></font></p>
<p>There are three sliders, a pair of radio buttons, and four text fields in the 
GUI.&nbsp; The radio buttons control whether the HSB color model is displayed as 
a slice through a cone or a slice through a cylinder.&nbsp; <i>(I will have more 
to say about this <a href="#A_slice_through">later</a>.)</i></p>
<p><font color="#FF0000"><b>A 3D geometric solid</b></font></p>
<p>Using the HSB color model, any color can be specified by the values of three 
parameters.&nbsp; One parameter is an angular measure ranging from 0 to 360 
degrees.&nbsp; The other two parameters are linear measures ranging from 0 to 
1.0.</p>
<p>As with other models defined by three parameters, it is convenient to 
visualize the HSB model as being represented by a solid shape in 3D space.&nbsp; 
Using that concept, each color is represented by a point somewhere inside or on 
the surface of the solid.</p>
<p><font color="#FF0000"><b>A cylinder or a cone</b></font></p>
<p>There are a variety of different ways to visualize that 3D shape.&nbsp; 
Because one of the parameters is an angular measure, it is convenient to 
visualize the shape as either a cylinder or a cone.&nbsp; Using that concept, 
one of the linear parameters can be visualized as relating to the radius of the 
cylinder or the cone.&nbsp; The other linear parameter can be visualized as a 
longitudinal axis extending from one end of the cylinder or cone to the other 
end of the cylinder or cone.&nbsp; Most authors seem to prefer a cone to a 
cylinder.&nbsp; I will let you decide for yourself which you prefer.</p>
<p><font color="#FF0000"><b><a name="A_slice_through">A slice through</a> the cylinder or the cone</b></font></p>
<p>Using this concept, the color wheel shown in the top image in Figure 1 
becomes a slice through the cylinder or the cone.&nbsp; If the slice is at the 
very top of the cone, the diameter of the slice is equal to the maximum diameter 
of the cone.&nbsp; If the slice is at the very bottom of the cone, the diameter 
of the slice is very small.</p>
<p>If the model is visualized as a cylinder, the diameter of the slice will be 
equal to the diameter of the cylinder no matter where it is taken.</p>
<p><font color="#FF0000"><b>The sliders</b></font></p>
<p>The value of the bottom slider in the GUI in Figure 1 <i>(labeled Percent Brightness)</i> determines which horizontal slice of the cone <i>(or cylinder)</i> is displayed 
in the image above the GUI.</p>
<p>The value of the top 
slider labeled <i>Hue in Degrees</i> determines the angular position of the white radial line shown in the top 
image in Figure 1.&nbsp; The value of the middle slider labeled <i>Percent 
Saturation</i> determines the radius of 
the white circle shown in Figure 1.</p>
<p><font color="#FF0000"><b>The color specified by the slider values</b></font></p>
<p>The colored disk in the upper-left corner of Figure 1 shows the color 
specified by the intersection of the slice through the cone, the radial line, and the circle.&nbsp; 
The three text fields to the right of the sliders show the current values 
pointed to by the buttons on the sliders.</p>
<p>The Text field at the bottom of the GUI displays the RGB color value in hexadecimal 
corresponding to that color.&nbsp; In other words, the values of the three 
sliders <i>(and their corresponding text fields)</i> specify a color using HSB parameters.&nbsp; The text field 
at the bottom shows the 
parameters of the RGB color model corresponding to that same color.&nbsp; The 
colored disk in the upper-left corner shows the color independent of the manner in which it is specified.</p>
<p><font color="#FF0000"><b>UT burnt orange</b></font></p>
<p>Figure 1 shows the slider positions that produced the burnt orange color that 
I referred to <a href="#In_case_you_are_wondering">earlier</a>.&nbsp; As you can 
see, the HSB parameter values for this color are 22 degrees for hue, 83-percent 
saturation, and 59-percent brightness.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<p>The purpose of this program is to demonstrate and allow you to experiment 
with the HSB color model.</p>
<p>This program requires access to <a href="#A_multimedia_class_library">Ericson's multimedia library</a>.</p>
<p><font color="#FF0000"><b>Terminating the program</b></font></p>
<p>Clicking the large X in the upper-right corner of the color-wheel display 
shown in Figure 1 will not terminate the program.&nbsp; Instead, the program is 
terminated by clicking the large X in the upper-right corner of the GUI shown in the 
lower portion of Figure 1.</p>
<p><font color="#FF0000"><b>The handleSliders method</b></font></p>
<p>Aside from the event handlers that are registered on the sliders, the 
behavior of this program is largely controlled by a method named <b>
handleSliders</b>, which is called by the event handlers.&nbsp; This method processes the 
three sliders, the two radio buttons, the four text fields, the filled oval, and 
the large display of a color wheel shown in Figure 1.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Conversion of the hue value</b><br />
<font size="3" face="arial">
	The hue value in degrees is later converted to a value from 0 to 1.0 for computational 
purposes and to satisfy the parameter requirements for the Java 
method named <b>HSBtoRGB</b>.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The hue slider</b></font></p>
<p>The radio buttons allow the HSB color model to be displayed either as a cone 
or as a cylinder.&nbsp;&nbsp; In either case, the slider labeled <i>Hue in 
Degrees</i>, which is graduated in degrees from 0 to 360, specifies a value for 
hue between zero and 360 degrees inclusive.</p>
<p>Because it is difficult to read an exact value from the slider, the current 
value of the slider in degrees is also displayed in a text field to the right of 
the slider.</p>
<p><font color="#FF0000"><b>The saturation slider</b></font></p>
<p>A second slider labeled <i>Percent Saturation</i>, which is graduated from 0 
to 100, specifies a value for saturation from 0 to 100-percent.&nbsp; <i>(The 
value of 100-percent corresponds to an actual computational value of 1.0.)</i>&nbsp; The 
current percentage value of the saturation slider is displayed in a text field to the right 
of the slider.</p>
<p><font color="#FF0000"><b>The brightness slider</b></font></p>
<p>A third slider labeled <i>Percentage Brightness</i>, which is graduated from 
0 to 100, specifies a value for brightness from 0 to 100-percent <i>(1.0)</i>.&nbsp; 
Once again, the percentage value of the slider is displayed in a text field to 
the right of the slider.</p>
<p><font color="#FF0000"><b>The color wheel</b></font></p>
<p>The color wheel that is displayed represents a horizontal slice through the 
cone or the cylinder with the location of the slice being specified by the value 
of the brightness slider.</p>
<p>A brightness value of 0 produces a horizontal 
slice at the very bottom.&nbsp; For the cone display format, this is simply a 
black dot in the center of the picture.&nbsp; I won't show a screen shot of it 
here because I am confident that you know what a black dot looks like.</p>
<p>The color wheel for a brightness value of zero and the cylinder display 
format is a black disk having the same diameter as the color 
wheel in Figure 2.&nbsp; Again, I won't waste space with a screen shot because 
you know what a black disk looks like.</p>
<p>A 
brightness value of 100 produces a horizontal slice at the very top of the cone 
or cylinder as shown in 
Figure 2.</p>












<p>
 <b><a name="Figure_2">Figure 2</a>. Top surface of the HSB cone.</b><table bgcolor="#FEFFF0"  border="1" cols="1" id="table1">
<tr><td><img border="0" src="java355b1.jpg" width="409" height="435"></td></tr>
<tr><td><img border="0" src="java355b2.jpg" width="408" height="228"></td></tr>
</table></p>

<p>In effect, Figure 2 shows the top surface of the cone or the cylinder.</p>
<p><font color="#FF0000"><b>Color wheel appearance versus brightness value</b></font></p>
<p>As the 
brightness slider moves toward 0, the color wheel becomes darker as shown in 
Figure 1.&nbsp; For the cone display 
format, the color wheel becomes smaller in diameter, also as shown by the color wheel in Figure 1.</p>
<p><font color="#FF0000"><b>A white radial line</b></font></p>
<p>Moving the hue slider causes a white radial line, 
similar to the big hand on a clock, to be displayed on the color wheel to show 
the value of the hue slider in 
degrees.</p>
<p>The line is in the 3:00 o'clock position for a hue of red at the 0 and 
360-degree positions at the ends of the track.&nbsp; Although barely visible, 
the white line is in the green area at a hue value of 120 degrees in Figure 2.&nbsp; 
The white line is much easier to see in Figure 1 due to the improved contrast 
between the darker background color and the white line.</p>
<p>Moving the hue slider to the right causes the white line to rotate in a 
clockwise direction.</p>
<p><font color="#FF0000"><b>A white circle</b></font></p>
<p>Moving the saturation slider causes 
a white circle to be displayed inside of and concentric with the color wheel as 
shown in Figure 1.</p>
<p>The white circle is the 
same size as the color wheel when the slider is at the 100 end of the track.&nbsp; 
<i>(Therefore, it can't be seen in Figure 2.)</i>&nbsp; The 
diameter of the white circle reduces to zero and the circle disappears when the slider 
approaches the 0 at the left end of the track.&nbsp; The white circle is easy to 
see in Figure 1 for a saturation value of 83-percent.</p>
<p><font color="#FF0000"><b>A specific color</b></font></p>
<p>The intersection of the horizontal plane 
defined by the value of the brightness slider, the radial line defined by the 
value of the hue slider, and the circle defined by the value of the saturation 
slider identifies a specific color.&nbsp; That color, which is the color of the 
wheel at the intersection, is also enlarged and displayed in a filled oval in the 
upper-left corner of the display.&nbsp; The color is burnt orange in Figure 1, 
and is fully-saturated pure green in Figure 2.</p>
<p><font color="#FF0000"><b>A hexadecimal color display</b></font></p>
<p>The color specified by the positions of the three sliders is also displayed in 
numeric RGB hexadecimal format in a 
text field at the bottom of the GUI.&nbsp; If you are familiar with this format, 
you will know that the text field at the bottom of Figure 2 contains the RGB 
value for pure green <i>(00FF00)</i>.</p>
<p><font color="#FF0000"><b>Selection of the cone or cylinder display format</b></font></p>
<p>A pair of radio buttons labeled <i>Cone</i> and 
<i>Cylinder</i> allows the user to select either the cone display format or the cylinder 
display format.&nbsp; Figure 1 shows the cone format along with the HSB 
parameter values for burnt orange.&nbsp; Figure 3 shows the 
same HSB parameter values in cylinder format.</p>












<p>
 <b><a name="Figure_3">Figure 3</a>. HSB parameters for burnt orange in cylinder 
	format.</b>
<table bgcolor="#FEFFF0"  border="1" cols="1" id="table2">
<tr><td><img border="0" src="java355c1.jpg" width="409" height="435"></td></tr>
<tr><td><img border="0" src="java355c2.jpg" width="408" height="228"></td></tr>
</table></p>

<p><font color="#FF0000"><b>The big difference is the diameter</b></font></p>
<p>The only real difference between the cone and cylinder display formats is that with 
the cone format, the diameter of the color wheel is proportional to the 
brightness value.&nbsp; With the cylinder format, the diameter of the color 
wheel is the same regardless of the brightness value.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>As is my 
custom, I will break the program down into code fragments and explain the 
fragments.&nbsp; A complete listing of the program is provided in Listing 13 
near the end of the lesson.<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Construction of the GUI</b><br />
  If this material is new to you, I recommend that you study my other tutorial 
	lessons at <font color="#000000" size="3" face="arial">
	<a href="http://www.dickbaldwin.com/toc.htm">www.DickBaldwin.com</a>.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
<b>Beginning of the class named HsbColor01</b></font></p>
<p>The class named <b>HsbColor01</b> begins in Listing 1.&nbsp; A very large 
percentage of the code in this class is concerned only with declaring instance 
variables and with the construction of the GUI in terms of placing sliders, radio buttons, etc., in the <b>JFrame</b> 
object.&nbsp; I will assume that none of that is new to you and will skip over that 
material.&nbsp; You can view the code that I skipped in Listing 13.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the class named HsbColor01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class HsbColor01 extends JFrame{

//Code skipped for brevity.


    //Cause the color wheel image to be created on the
    // display.
    handleSliders();
    
    //Display the GUI and the color wheel.
    setVisible(true);
    display.show();
    //--------------------------------------------------//

    //Register a ChangeListener object on the hueSlider.
    // Each time the hueSlider fires a ChangeEvent, this
    // event handler erases the current image and calls a
    // method named handleSliders to create and process a
    // new image.
    hueSlider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Erase the current display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          //Create and process a new display.
          handleSliders();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
//Registration of event handlers on the satSlider and the
// bright slider skipped for brevity.
    //--------------------------------------------------//

  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A call to the handleSliders method</b></font></p>
<p>Having skipped a large portion of the code in Listing 13, Listing 1 picks up 
with a call to the method named <b>handleSliders</b>.&nbsp; Most of the 
significant behavior of this program resides in that method and I will explain 
the method in detail shortly.</p>
<p><font color="#FF0000"><b>Register listener objects on the sliders</b></font></p>
<p>Then Listing 13 uses anonymous classes to register a different <b>ChangeListener</b> 
object on each of the three sliders shown in Figure 1.&nbsp; The code used to 
register the listener object on each slider is essentially the same.&nbsp; 
Listing 1 shows only the code required to register the listener object on the 
slider referred to by the instance variable named <b>hueSlider</b>.&nbsp; You 
can view the registration of the listener objects on the other two sliders in 
Listing 13.</p>
<p>Once again, I will assume that you are familiar with the use of anonymous 
classes to register listener objects on objects that are capable of firing 
events.&nbsp; If not, you should probably study some of my other
<a href="http://www.dickbaldwin.com/toc.htm">lessons</a>.</p>
<p><font color="#FF0000"><b>Erase the current image from the display</b></font></p>
<p>The top image in Figure 1 is a <b>Picture</b> object referred to by an 
instance variable named <b>display</b>.&nbsp; The body of the registration code 
in Listing 1 begins by erasing the image of the color wheel from that <b>Picture</b> object.&nbsp; 
This is accomplished by drawing a copy of another <b>Picture</b> object onto the
<b>display</b> object.&nbsp; The second <b>Picture</b> object 
contains an all-white image, and the result is to cause the <b>display</b> 
object to also contain an all-white image.</p>
<p><font color="#FF0000"><b>Create and process a new display</b></font></p>
<p>Then the body of the event-registration code calls the method named <b>
handleSliders</b> to create and process a new display.&nbsp; </p>
<p>Each time a button on one of the sliders is moved, the display is 
erased and then redrawn by the code in the method named <b>handleSliders</b>.&nbsp; 
Therefore, it is important for the code in that method to execute very quickly.&nbsp; I made some efforts 
in the design of the method to cause it to execute quickly.&nbsp; 
If the method doesn't execute quickly, the program will not be responsive to the movement of the sliders.</p>
<p><font color="#FF0000"><b>Improving the speed</b></font></p>
<p>For example, one of the things that I did in an attempt to improve the speed 
of the method was 
to declare all of the required working variables as instance variables.&nbsp; 
This eliminates the requirement to declare local variables and to push them onto 
the runtime stack every time the 
method is called.</p>
<p>I also used an <b>Ellipse2D.Double</b> object to limit 
the number of required computations in a manner that I will explain later.</p>
<p>Listing 1 also signals the end of the constructor, so it is time for me to 
explain the method named <b>handleSliders</b>.</p>
<p><font color="#FF0000">
<b>Beginning of the method named handleSliders</b></font></p>
<p>This method is called once during the construction process and then each time 
the user moves a button on any of the three sliders.&nbsp; Regardless of what 
caused the method to be called, Listing 2:</p>
<ul>
	<li>Gets and the hue, saturation, and brightness values from all three sliders.</li>
	<li>Displays the values in the text fields positioned immediately to the right of the 
	sliders.</li>
	<li>Converts the three values to floating point values ranging from 0 to 1.0 
	and saves the converted values.</li>
</ul>
<p>The conversion to type <b>float</b> is necessary because the method named <b>HSBtoRGB</b> that will 
be called later requires that the HSB parameter be in this format.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the method named 
handleSliders. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private synchronized void handleSliders(){
    tempInt = hueSlider.getValue();
    hueField.setText("" + tempInt);
    hue = tempInt/360.0;

    tempInt = satSlider.getValue();
    satField.setText("" + tempInt);
    sat = tempInt/100.0;
    
    tempInt = brightSlider.getValue();
    brightField.setText("" + tempInt);
    bright = tempInt/100.0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The uses of the slider values</b></font></p>
<p>The value of the brightness slider will be used to establish the slice 
through the cone or the cylinder that will be drawn as a color wheel.</p>
<p>The hue and saturation slider values will be used to draw the white line and 
the white circle shown in Figure 1 onto the color wheel after the color wheel 
has been drawn.</p>
<p><font color="#FF0000">
<b>Decide between cone and cylinder display formats</b></font></p>
<p>Listing 3 tests the current status of the two radio buttons at the bottom of 
the GUI in Figure 1 to determine if the HSB color model should be displayed as a 
cone or as a cylinder. </p>
<p>
<b><a name="Listing_3">Listing 3</a>. Decide between cone and cylinder display 
formats. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    if(coneButton.isSelected()){
      //Use the following for a cone.
      radius = halfWidth * bright;
    }else{
      //Use the following for a cylinder.
      radius = halfWidth;
    }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If the button labeled <b>Cone</b> is selected, the diameter of the color 
wheel is proportional to the brightness value as shown in Figure 1.&nbsp; If the 
button labeled <b>Cylinder</b> is selected, the diameter of the color wheel is 
the same regardless of the brightness value as shown in Figure 3.</p>
<p><font color="#FF0000">
<b>Construct a new Ellipse2D.Double object</b></font></p>
<p>As you can see in Figure 1 through Figure 3, a large percentage of the pixels 
in the <b>Picture</b> object that displays the color wheel are always white.&nbsp; 
Other pixels are frequently white, depending on the diameter of the color wheel.&nbsp; Therefore, there is no 
need to waste computer resources processing these pixels.&nbsp; They are already white 
<i>(see Listing 1)</i> and that is the color that they need to stay.</p>
<p>Listing 4&nbsp;constructs an object of the <b>Ellipse2D.Double</b> class.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Construct a new Ellipse2D.Double object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    ellipse = new Ellipse2D.Double(halfWidth-radius,
                                   halfHeight-radius,
                                   2*radius,2*radius);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A somewhat unusual use of an Ellipes2D.Double object</b></font></p>
<p>Typically, an object of this class is used to draw an ellipse on the screen.&nbsp; 
However, that is not the purpose of the object in this case.&nbsp; The purpose 
of the object in this case is probably a little unusual.</p>
<p>One of the 
methods of an <b>Ellipse2D.Double</b> object allows the program to test a pair 
of pixel-coordinate values to 
determine if they are contained inside the boundary 
of the ellipse.</p>
<p>In this program, the <b>Ellipse2D.Double</b> object is constructed as a circle, 
centered on the color wheel with the same radius as the color wheel <i>(but it 
is never drawn on the screen)</i>.&nbsp; If a pair of coordinate values is not 
contained in the ellipse, the coordinates are not contained in the color wheel 
either.</p>
<p>If a pixel at the specified coordinates is inside the color wheel, it is 
processed.&nbsp; Otherwise the pixel is simply ignored and allowed to remain 
white.</p>
<p><font color="#FF0000">
<b>Beginning of the pixel processing loop</b></font></p>
<p>Listing 5 shows the beginning of a pair of nested <b>for</b> loops.&nbsp; The 
code in the loops examines every pixel in the picture to determine whether or 
not an individual pixel is contained in the ellipse described above.&nbsp; If 
the pixel is contained in the ellipse, it is processed.&nbsp; Otherwise, it is 
ignored and the next pixel is examined.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the pixel processing loop. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    for(int row = 0;row &lt; pictureWidth;row++){
      for(int col = 0;col &lt; pictureHeight;col++){
        if(ellipse.contains(col,row)){
          //Only process those pixels that are inside the
          // ellipse.
          //Compute values for x and y relative to the
          // center.
          x = col - halfWidth;
          y = row - halfHeight;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Staying on track</b></font></p>
<p>Just to help you to stay on track, let me point out that the purpose of the 
code in the nested <b>for</b> loops is to draw the color wheel.&nbsp; The values 
of the hue slider and the saturation slider are not involved in that process.&nbsp; 
Those values are not used until later when time comes to draw the white line and 
the white circle onto the color wheel.</p>
<p><font color="#FF0000"><b>A new pair of coordinates</b></font></p>
<p>When a pixel is determined to be within the boundary of the ellipse, two new coordinates named <b>x</b> and <b>y</b> are created to describe the 
location of the pixel relative to the center of the color wheel.&nbsp; Those 
coordinate values are used for most of the processing that follows.</p>
<p><font color="#FF0000"><b>Caution, trigonometry ahead</b></font></p>
<p>In order to understand the processing that follows, you must understand 
trigonometry.&nbsp; If that is not the case, there is little that I can do about 
that.&nbsp; In that case, you will simply need to read along and take my word 
for it that the code works correctly.</p>
<p><font color="#FF0000">
<b>Compute the hue angle for the pixel</b></font></p>
<p>Listing 6 calls the <b>atan</b> method of the <b>Math</b> class to determine 
the angle <i>(relative to the horizontal axis)</i> of a line that goes through 
the center of the color wheel and also goes through the pixel. </p>
<p>
<b><a name="Listing_6">Listing 6</a>. Compute the hue angle for the pixel. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          if(x != 0){
            //Must avoid division by 0.
            hueAngle = (float)(Math.atan(y/x));
          }else{
            //x is equal to zero
            if(y &gt;= 0){
              hueAngle = (float)(Math.PI/2);
            }else{
              hueAngle = (float)(2 * Math.PI - Math.PI/2);
            }//end else
          }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This angle determines the hue value that will be ascribed to the pixel later 
when the HSB parameters for the pixel are converted to RGB colors so that the 
pixel can be drawn with the correct color.</p>
<p>Listing 6 also contains some code that is required to avoid division by zero.&nbsp; 
If you understand trigonometry, you should have no problem understanding the 
code in Listing 6.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The atan2 method</b><br />
  When <font size="3" face="arial">
	I reached this point in the writing of the lesson, I discovered that the <b>Math</b> class also provides another method named <b>
atan2</b>, 
which appears to solve the quadrant problem.&nbsp; Therefore, this code could be streamlined even 
more by calling <b>atan2</b> in place of <b>atan</b> and leaving out the code in 
	Listing 7.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
<b>Translate the angle into the correct quadrant</b></font></p>
<p>If you understand trigonometry, you will also know that simply calling the <b>
atan</b> method as in Listing 6 doesn't provide a complete answer.&nbsp; In 
particular, the method returns the angle in the range -pi/2 through pi/2 <i>(-90 
degrees through 90 degrees)</i>.&nbsp; This is true even if the pixel is 
actually located in one of the other two quadrants.</p>
<p>The code in Listing 7 applies the necessary correction to 
translate the angle computed in Listing 6 into the correct quadrant.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Translate the angle into the correct 
quadrant. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Now get the angle into the correct quadrant.
          if((x &lt; 0) && (y &lt;= 0)){
            hueAngle = (float)(Math.PI + hueAngle);
          }else if((x &gt; 0) && (y &lt; 0)){
            hueAngle = (float)(2 * Math.PI + hueAngle);
          }else if((x &lt; 0) && (y &gt; 0)){
            hueAngle = (float)(Math.PI + hueAngle);
          }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Compute the saturation value for the pixel</b></font></p>
<p>Listing 6 and Listing 7 together tell us the hue value for the pixel being 
processed.&nbsp; Listing 8 computes the saturation value for the pixel.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Compute the saturation value for the 
pixel. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          if(radius != 0){
            satVal = (float)(Math.sqrt(
                               (x/radius) * (x/radius) +
                               (y/radius) * (y/radius)));
          }else{
            //The radius is equal to 0. This is the 
            // very bottom of the cone.
            satVal = (float)(0.0);
          }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The square root of the sum of the squares</b></font></p>
<p>The saturation value for the pixel is the distance of the pixel from the 
center of the color wheel.&nbsp; For the cone display format, the saturation 
value is actually the distance of the pixel from the center of the color wheel 
as a fraction of the radius of the color wheel for that brightness value.</p>
<p>If the radius of the color wheel is greater 
than zero, Listing 8 gets the length of a line from the center of the color 
wheel to the pixel as the square root of the sum of the squares of the <b>x</b> 
and <b>y</b> coordinate values.</p>
<p><font color="#FF0000"><b>Not an absolute</b></font></p>
<p>Note that this is not an absolute 
distance.&nbsp; Rather, the computed distance is normalized by the radius of the 
HSB color model at the current brightness value.&nbsp; As mentioned above, this is a necessary 
adjustment for the cone display format.</p>
<p>Once again, it is necessary to avoid division by zero.&nbsp; Therefore, for 
the case at the very bottom of the cone where the radius is zero, Listing 8 sets 
the saturation value to 0.0.</p>
<p><font color="#FF0000"><b>Draw the pixel in the correct color</b></font></p>
<p>At this point, we have determined the brightness value based on the current 
position of the brightness slider, and have determined the hue and saturation 
values based on the location of the pixel relative to the center of the color 
wheel.&nbsp; The time has come to apply the hue, saturation, and brightness 
values and draw the pixel in the correct color.</p>
<p><font color="#FF0000"><b>Convert from radians to degrees</b></font></p>
<p>All of the angles involved in the earlier trigonometric calculations were 
expressed in radians instead of degrees.&nbsp; In order to get back into 
territory that is more familiar to those without a background in trigonometry, 
the first statement in Listing 9 calls the <b>toDegrees</b> method of the <b>Math</b> class to 
convert the hue angle from radians to degrees.&nbsp; Because the <b>HSBtoRGB</b> 
method that will be called later requires the hue angle value to be type <b>
float</b> instead 
of type <b>double</b>, that statement also casts the hue angle in degrees to 
type <b>float</b>.</p>
<p><font color="#FF0000">
<b>Convert to RGB and draw the pixel</b></font></p>
<p>The <b>Pixel</b> class in the Ericson library provides a <b>setColor</b> 
method that allows for setting the color of a pixel by passing a parameter of 
type <b>Color</b>.&nbsp; It appears that all of the constructors 
for objects of the <b>Color</b> class are based on the RGB color model.&nbsp; 
None are based on the HSB color model.</p>
<p><font color="#FF0000"><b>An int representation of a color</b></font></p>
<p>The second statement in Listing 9 calls the <b>HSBtoRGB</b> method of the <b>
Color</b> class, passing the hue, saturation, and brightness values as parameters 
of type <b>float</b>.&nbsp; This method returns an <b>int</b> value that encodes 
the red, green, and blue color values in the 24 least-significant bits of the <b>
int</b> value.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Convert to RGB and draw the pixel in the 
correct color. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Convert hue angle to degrees.
          hueAngle = (float)(Math.toDegrees(hueAngle));

          //Convert the color to an RGB color that can be
          // used to set the color of a pixel. Note that
          // this method requires parameters of type float
          // and not type double.
          color = new Color(Color.HSBtoRGB(
                                    (float)(hueAngle/360),
                                    satVal,
                                    (float)bright));
   
          //Set the color of the pixel.
          pixel = display.getPixel(col,row);
          pixel.setColor(color);

        }//end if on ellipse contains the coordinates

      }//end inner loop
    }//end outer loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Construct a new Color object</b></font></p>
<p>This <b>int</b> value is then passed to a <b>Color</b> constructor to create 
a new <b>Color</b> object, whose reference is saved in the instance variable 
named <b>color</b>.</p>
<p><font color="#FF0000"><b>Set the color of the pixel</b></font></p>
<p>This <b>Color</b> object is then used to set the color of the pixel whose 
location is specified by the <b>col</b> and <b>row</b> indices of the nested <b>
for</b> loops that began in Listing 5.&nbsp; Once again note that this pixel has 
been processed only if the coordinates of the pixel are inside the ellipse <i>
(having the same radius and center as the color wheel)</i>, which was 
constructed in Listing 4.</p>
<p><font color="#FF0000"><b>When the for loops terminate...</b></font></p>
<p>When the inner and outer <b>for</b> loops <i>(that begin in Listing 5 and end in 
Listing 9)</i> terminate, the color of each pixel inside the color wheel has been set based on the hue, saturation, and brightness values ascribed to the 
pixel.&nbsp; Those values are ascribed to the pixel on the basis of the pixel's 
location relative to the center of the color wheel being 
drawn.&nbsp; The brightness value will have been used to determine which slice 
through the HSB color model to draw.</p>
<p><font color="#FF0000"><b>What about the hue and saturation slider values?</b></font></p>
<p>As I mentioned earlier, the values of the hue and saturation sliders that 
were saved in Listing 2 have not yet come into play.&nbsp; The appearance of the 
color wheel depends only on the value of the brightness slider.</p>
<p>The values of the hue and saturation sliders are not used to draw the color wheel.&nbsp; Instead, they are used 
to draw the white radial hue line and the white saturation circle onto the color 
wheel as shown in 
Figure 1.</p>
<p><font color="#FF0000"><b>Caution, more trigonometry ahead</b></font></p>
<p>The next step is to use the hue and saturation slider values saved in Listing 
2 to compute the location of the intersection between an imaginary radial line 
that represents the value of the hue slider and an imaginary circle that 
represents the value of the saturation slider.&nbsp; This is accomplished in 
Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Get intersection coordinates of hue and 
saturation.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    graphics = display.getGraphics();

    //Get the coordinates of the intersection of the 
    // radial hue line indicated by hueSlider and the 
    // saturation circle indicated by satSlider.
    int xLoc = (int)(halfWidth + 
                       (radius*satSlider.getValue()/100) *
                                Math.cos(Math.toRadians(
                                  hueSlider.getValue())));
    int yLoc = (int)(halfHeight + 
                       (radius*satSlider.getValue()/100) *
                                Math.sin(Math.toRadians(
                                  hueSlider.getValue())));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, if you understand trigonometry <i>(and maybe a little about 
vectors)</i>, you should have no problem with the code in Listing 10.&nbsp; <i>(Listing 10 also gets a reference 
to a <b>
Graphics</b> object that represents the display.&nbsp; This object will be used 
later to draw the white line and the white circle shown in Figure 1.)</i></p>
<p><font color="#FF0000"><b>Get the color at the intersection</b></font></p>
<p>Listing 11 begins by getting the color of the pixel at the location of the 
intersection of the imaginary line and the imaginary circle described above.&nbsp;
<i>(Note that the white line and the white circle shown in Figure 1 haven't been 
drawn yet.&nbsp; If they had been drawn, the color of the pixel at the 
intersection would always be white.)</i></p>
<p>
<b><a name="Listing_11">Listing 11</a>. Display the color at the intersection. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    if((xLoc &lt; pictureWidth) && (yLoc &lt; pictureHeight)){
      color = display.getPixel(xLoc,yLoc).getColor();
    }//end if

    //Display the value of the color in hex format in a
    // text field.
    hexField.setText(Integer.toHexString(color.getRGB()).
                              toUpperCase().substring(2));
    //Draw a round color swatch in the upper-left corner 
    // that matches the pixel color at the intersection.
    graphics.setColor(color);
    graphics.fillOval(5,5,40,40);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display the color at the intersection</b></font></p>
<p>Then Listing 11 displays the color at the intersection in two different 
formats.&nbsp; 
First, an <b>int</b> value that encodes the red, green, and blue color values in 
the 24 least significant bits is 
obtained, converted to hexadecimal format, and displayed in a text field at the 
bottom of the GUI in Figure 1.&nbsp; <i>(Only the hexadecimal value of the 24 
least significant bits is displayed in the text field.)</i></p>
<p>Then the <b>Color</b> object is used to draw and fill a small circle in the 
upper-left corner of the display as shown in Figure 1.</p>
<p><font color="#FF0000"><b>An interactive program</b></font></p>
<p>When 
the button on any of the sliders shown in Figure 1 is moved, the color wheel is 
redrawn at the brightness value specified by the brightness slider.&nbsp; Then 
the values of the hue and saturation sliders are used to specify the location of 
a particular pixel within the color wheel at the intersection of the hue and 
saturation slider values.</p>
<p>The color of the pixel at the 
intersection of hue and saturation is enlarged and shown as an actual color in a filled circle in the 
upper-left corner of the display.&nbsp; The color is also converted to RGB 
hexadecimal format and displayed in a text field at the bottom of the GUI.</p>
<p><font color="#FF0000"><b>Provide visual feedback to the user</b></font></p>
<p>In order for the program to be useful to a human, it needs to 
provide visual feedback showing the effect on the color wheel of moving any of the three sliders.</p>
<p><font color="#FF0000"><b>Moving the brightness slider</b></font></p>
<p>When the user moves the brightness slider, the overall color of the color 
wheel becomes darker or lighter depending on the new position of the slider.&nbsp; 
In addition, when the cone display format has been selected, the diameter of the 
color wheel gets smaller as the button is moved toward zero on the slider and 
gets larger as the button is moved toward 100.</p>
<p><font color="#FF0000"><b>Moving the hue slider</b></font></p>
<p>When the user moves the hue slider, the white radial line shown in Figure 1 
rotates around the center of the color wheel like the big hand on a clock.&nbsp; 
The line is at the 3:00 o'clock position when the hue slider value is zero.&nbsp; 
It rotates in a clockwise direction making one full revolution as the button on 
the slider is moved from the zero position at the left end to the 360-degree 
position at the right end.</p>
<p><font color="#FF0000"><b>Moving the saturation slider</b></font></p>
<p>When the user moves the saturation slider, the radius of the 
white circle shown in Figure 1 increases and decreases.&nbsp; The radius is 
zero when the saturation slider is at the zero position, and is the same as the 
radius of the color wheel when the saturation slider is at the 100-percent 
position.</p>
<p><font color="#FF0000"><b>Get the color and then draw the line and the circle</b></font></p>
<p>Once again, let me emphasize that the white line and the white circle are not 
drawn until the program gets and displays the color of the pixel at the location 
that will be the intersection of the line and the circle when they are drawn.</p>
<p><font color="#FF0000">
<b>Draw the white radial hue line and the white saturation circle</b></font></p>
<p>
The code in Listing 12 uses the <b>drawOval</b> method and the <b>drawLine</b> 
methods of the <b>Graphics</b> class to draw the white circle and the white line 
as shown in Figure 1.<p>
<b><a name="Listing_12">Listing 12</a>. Draw the white radial hue line and the 
white saturation circle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Now draw the white radial hue line and the white 
    // saturation circle.
    graphics.setColor(Color.WHITE);

    //Draw a white circle at the saturation value 
    // indicated by satSlider.
    graphics.drawOval(
        (int)(halfWidth-radius*satSlider.getValue()/100),
        (int)(halfHeight-radius*satSlider.getValue()/100),
        (int)(2*radius*satSlider.getValue()/100),
        (int)(2*radius*satSlider.getValue()/100));

    //Draw a radial line at the hue angle indicated by
    // hueSlider.
    graphics.drawLine(
                halfWidth,
                halfHeight,
                halfWidth + (int)(radius * Math.cos(
                  Math.toRadians(hueSlider.getValue()))),
                halfHeight + (int)(radius * Math.sin(
                  Math.toRadians(hueSlider.getValue()))));

    //Autograph the painting.
    display.addMessage("Dick Baldwin",150,50);

    //Repaint the display.
    display.repaint();

  }//end handleSliders
  //----------------------------------------------------//

}//end class HsbColor01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 12 autographs and repaints the display.</p>
<p>Listing 12 also signals the end of the <b>handleSliders</b> method, the end 
of the <b>HsbColor01</b> class, and the end of the program.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 13, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<p>Also use the program to produce colors that match the colors of some of your 
favorite items.&nbsp; See if you agree that this process is much more intuitive 
when it is based on the HSB color model than it would be if it were based on the 
RGB color model.</p>
<p>As a major exercise, try restructuring this program so that it can be 
instantiated as an HSB color chooser dialog, returning the color specified by 
the three sliders to another program.</p>
<p>Don't forget that this program requires access to Ericson's multimedia 
library.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you a little about the HSB color model and showed 
you how to write a program that you can use to experiment with the model.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson in this series, you will <i>learn how the show() method of 
the <b>Picture</b> class causes the image contained in a <b>Picture</b> object 
to be displayed on the screen in a <b>JFrame</b> object.&nbsp; You will also learn 
about the <b>PictureFrame</b> class, which serves as an intermediary between the
<b>Picture</b> object and the <b>JFrame</b> object.</i></p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program discussed in this lesson is shown in Listing 
13 below.
<p>
<b><a name="Listing_13">Listing 13</a>. Source code for the program named HsbColor01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File HsbColor01 Copyright 2009 R.G.Baldwin

The purpose of this program is to demonstrate the HSB 
color model. See the comments at the beginning of the 
method named handleSliders for a more complete description
of the program.

This program requires access to Ericson's multimedia 
library.

The program is terminated by clicking the large X in the
upper-right corner of the GUI.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JRadioButton;
import javax.swing.ButtonGroup;
import javax.swing.WindowConstants;
import javax.swing.JLabel;
import javax.swing.JTextField;

import java.awt.Graphics;
import java.awt.Color;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;

import java.awt.geom.Ellipse2D;
import java.awt.geom.Ellipse2D.Double;

public class HsbColor01 extends JFrame{
  //The following constants are used to configure the 
  // JSlider components as well as the text on the JSlider
  // and JLabel components.

  //Change the following int values to change the limits
  // and initial positions of the sliders.
  private final int hueSliderMin = 0;//minimum
  private final int hueSliderMax = 360;//maximum
  private final int hueSliderInit = 0;//initial value

  private final int satSliderMin = 0;
  private final int satSliderMax = 100;
  //Set to following value 99 to cause the saturation 
  // circle to initially be inside the radius.
  private final int satSliderInit = 99;

  private final int brightSliderMin = 0;
  private final int brightSliderMax = 100;
  private final int brightSliderInit = 100;

  //Change the following int values to change the tick
  // spacing on the sliders.
  private final int hueSliderMajorTickSpacing = 60;
  private final int hueSliderMinorTickSpacing = 15;
  private final int satSliderMajorTickSpacing = 10;
  private final int satSliderMinorTickSpacing = 5;
  private final int brightSliderMajorTickSpacing = 10;
  private final int brightSliderMinorTickSpacing = 5;

  //Change these string values to change the labels
  // displayed to the left of the sliders.
  private final String hueSliderLabel = "Hue in Degrees";
  private final String satSliderLabel = 
                                     "Percent Saturation";
  private final String brightSliderLabel = 
                                     "Percebt Brightness";
  //----------------------------------------------------//

  //The following components are used to build up the GUI.
  private final JPanel mainPanel = new JPanel();
  private final JPanel northPanel = new JPanel();
  private final JPanel radioButtonPanel = new JPanel();

  private final JPanel hueSliderPanel = new JPanel();
  private final JPanel satSliderPanel = new JPanel();
  private final JPanel brightSliderPanel = new JPanel();

  //Change the int values at the beginning of the program
  // to configure these sliders.
  private final JSlider hueSlider =
     new JSlider(hueSliderMin,hueSliderMax,hueSliderInit);
  private final JSlider satSlider =
     new JSlider(satSliderMin,satSliderMax,satSliderInit);
  private final JSlider brightSlider = new JSlider(
        brightSliderMin,brightSliderMax,brightSliderInit);

  private final ButtonGroup buttonGroup = 
                                        new ButtonGroup();
  private final JRadioButton coneButton = 
                            new JRadioButton("Cone",true);
  private final JRadioButton cylinderButton = 
                             new JRadioButton("Cylinder");

  //The hue, saturation, brightness, and RGB color values
  // will be displayed in the following text fields.
  private final JTextField hueField = new JTextField(3);
  private final JTextField satField = new JTextField(3);
  private final JTextField brightField = 
                                        new JTextField(3);
  private final JTextField hexField = new JTextField(6);

  //This program draws either a cone or a cylinder that 
  // displays HSB colors. Define the size of the Picture 
  // object on which the cone or the cylinder is 
  // displayed.
  private int pictureWidth = 400;
  private int pictureHeight = 400;
  private int halfWidth = pictureWidth/2;
  private int halfHeight = pictureHeight/2;

  //Instantiate a blank white Picture object that is used 
  // to erase the current drawing on the display each time
  // a slider fires an event.
  private Picture picture = 
                  new Picture(pictureWidth,pictureHeight);

  //A second Picture object is actually used to draw the
  // slice through the cone or the cylinder. A reference 
  // to that object will be stored here.
  private Picture display = 
                  new Picture(pictureWidth,pictureHeight);

  //Miscellaneous working variables.
  private Graphics graphics = null;
  private Pixel pixel = null;
  private Color color = null;
  private  double hue = 0;
  private double sat = 0;
  private double bright = 0;
  private double x = 0;
  private double y = 0;
  private double radius = 0;
  private float hueAngle = 0;
  private float satVal = 0;
  private Ellipse2D.Double ellipse = null;
  private int tempInt = 0;
  //----------------------------------------------------//

  public static void main(String[] args){
    new HsbColor01();
  }//end main method
  //----------------------------------------------------//

  public HsbColor01(){//constructor
    //Put decorations on the sliders. Change the constants
    // at the beginning of the program to control major
    // and minor tick spacing.
    hueSlider.setMajorTickSpacing(
                               hueSliderMajorTickSpacing);
    hueSlider.setMinorTickSpacing(
                               hueSliderMinorTickSpacing);
    hueSlider.setPaintTicks(true);
    hueSlider.setPaintLabels(true);

    satSlider.setMajorTickSpacing(
                               satSliderMajorTickSpacing);
    satSlider.setMinorTickSpacing(
                               satSliderMinorTickSpacing);
    satSlider.setPaintTicks(true);
    satSlider.setPaintLabels(true);

    brightSlider.setMajorTickSpacing(
                            brightSliderMajorTickSpacing);
    brightSlider.setMinorTickSpacing(
                            brightSliderMinorTickSpacing);
    brightSlider.setPaintTicks(true);
    brightSlider.setPaintLabels(true);

    //Construct the GUI working generally from the top
    // down.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(northPanel,BorderLayout.NORTH);
    mainPanel.add(radioButtonPanel,BorderLayout.CENTER);

    northPanel.setLayout(new BorderLayout());

    //Add sliders.
    northPanel.add(hueSliderPanel,BorderLayout.NORTH);
    northPanel.add(satSliderPanel,BorderLayout.CENTER);
    northPanel.add(brightSliderPanel,BorderLayout.SOUTH);

    hueSliderPanel.setLayout(
                        new FlowLayout(FlowLayout.RIGHT));
    hueSliderPanel.add(new JLabel(hueSliderLabel));
    hueSliderPanel.add(hueSlider);
    hueSliderPanel.add(hueField);
    hueField.setEditable(false);//make it read only

    satSliderPanel.setLayout(
                        new FlowLayout(FlowLayout.RIGHT));
    satSliderPanel.add(new JLabel(satSliderLabel));
    satSliderPanel.add(satSlider);
    satSliderPanel.add(satField);
    satField.setEditable(false);

    brightSliderPanel.setLayout(
                        new FlowLayout(FlowLayout.RIGHT));
    brightSliderPanel.add(new JLabel(brightSliderLabel));
    brightSliderPanel.add(brightSlider);
    brightSliderPanel.add(brightField);
    brightField.setEditable(false);

    //Add radio buttons.
    radioButtonPanel.add(coneButton);
    radioButtonPanel.add(cylinderButton);
    //Make the radio buttons mutually exclusive.
    buttonGroup.add(coneButton);
    buttonGroup.add(cylinderButton);

    //Add a text field to display hex color value
    radioButtonPanel.add(hexField);
    hexField.setEditable(false);

    getContentPane().add(mainPanel);
    //Call the pack method to get the height right on the
    // GUI.
    pack();
    //Set the width of the GUI to match the width of the 
    // color wheel display.
    setSize(pictureWidth + 7,this.getHeight());

    //Decorate the GUI.
    setTitle("Copyright 2009, R.G.Baldwin");

    //Position the GUI immediately below the color wheel 
    // display.
    setLocation(0,pictureHeight + 30);
    
    //Terminate the program when the user clicks the large
    // X in the upper-right corner of the GUI.
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    //Cause the color wheel image to be created on the
    // display.
    handleSliders();
    
    //Display the GUI and the color wheel.
    setVisible(true);
    display.show();
    //--------------------------------------------------//

    //Register a ChangeListener object on the hueSlider.
    // Each time the hueSlider fires a ChangeEvent, this
    // event handler erases the current image and calls a
    // method named handleSliders to create and process a
    // new image.
    hueSlider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Erase the current display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          //Create and process a new display.
          handleSliders();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the satSlider.
    //Behavior is the same as the hueSlider.
    satSlider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliders();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the
    // brightSlider.
    //Behavior is the same as the hueSlider.
    brightSlider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliders();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*
  This method processes three sliders, two radio buttons, 
  four text fields, a filled oval, and a large display of
  a color wheel.
  
  The radio buttons allow the HSB color model to be 
  displayed either as a cone or as a cylinder. In either 
  case, one slider labeled Hue in Degrees, which is 
  graduated in degrees from 0 to 360 specifies a value for
  hue between zero and 360 degrees inclusive. Because it 
  is difficult to read an exact value from the slider, the
  current value of the slider in degrees is also displayed
  in a text field to the right of the slider. The value in
  degrees is converted to a value from 0 to 1.0 for 
  computational purposes.
  
  A second slider labeled Percent Saturation, which is 
  graduated from 0 to 100 specifies a value for saturation
  from 0 to 100-percent or 1.0. The current percentage 
  value of the slider is displayed in a text field to the
  right of the slider.
  
  A third slider labeled Percentage Brightness, which is 
  graduated from 0 to 100 specifies a value for brightness
  from 0 to 100-percent or 1.0. The percentage value is 
  displayed in a text field to the right of the slider.

  The color wheel that is displayed represents a 
  horizontal slice through the cone or the cylinder with 
  the location of the slice being specified by the value 
  of the brightness slider. A value of 0 produces a 
  horizontal slice at the very bottom, which for the cone
  display is simply a dot. A value of 100 produces a 
  horizontal slice at the very top. In effect, this is the
  top surface of the cone or the cylinder. Generally, as 
  the slider approaches 0, the display becomes darker, and
  for the cone display format, becomes smaller in 
  diameter.

  Moving the hue slider causes a radial line, similar to 
  the big hand on a clock to be displayed to show a value
  for hue in degrees. The line is in the 3:00 o'clock 
  position for a hue of red at the 0 and 360-degree 
  positions at the ends of the track.

  Moving the saturation slider causes a circle to be 
  displayed inside of and concentric with the color wheel.
  It is the same size as the wheel when the slider is at 
  the 100 end of the track. The diameter of the circle
  reduces to zero and the circle disappears when the 
  slider approaches the 0 end of the track.

  The intersection of the horizontal plane defined by the
  value of the brightness slider, the radial line defined
  by the value of the hue slider, and the circle defined
  by the value of the saturation slider defines a 
  specific color. That color is displayed in a filled oval
  in the upper-left corner of the display and is also 
  displayed in hexadecimal format in a text field at the 
  bottom of the GUI.

  A pair of radio buttons labeled Cone and Cylinder allows
  the user to select either the cone display format or the
  cylinder display format.

  The method is synchronized to eliminate the possiblilty
  that it may be called on two threads concurrently.

  All of the working variables in this method were 
  declared as instance variables in an attempt to make the
  method as responsive as possible.
  */
  private synchronized void handleSliders(){
    //Get the hue, saturation, and brightness values from
    // the sliders, display them in the text fields, and 
    // convert them to floating point values ranging from
    // 0 to 1.0.
    tempInt = hueSlider.getValue();
    hueField.setText("" + tempInt);
    hue = tempInt/360.0;

    tempInt = satSlider.getValue();
    satField.setText("" + tempInt);
    sat = tempInt/100.0;
    
    tempInt = brightSlider.getValue();
    brightField.setText("" + tempInt);
    bright = tempInt/100.0;

    //Decide between cone and cylinder display formats.
    if(coneButton.isSelected()){
      //Use the following for a cone.
      radius = halfWidth * bright;
    }else{
      //Use the following for a cylinder.
      radius = halfWidth;
    }//end else

    //Construct a circle object with the same radius as 
    // the wheel. It will be used to avoid processing any
    // pixels that are outside the wheel.
    ellipse = new Ellipse2D.Double(halfWidth-radius,
                                   halfHeight-radius,
                                   2*radius,2*radius);

    //Process every pixel in the wheel.
    for(int row = 0;row &lt; pictureWidth;row++){
      for(int col = 0;col &lt; pictureHeight;col++){
        if(ellipse.contains(col,row)){
          //Only process those pixels that are inside the
          // ellipse.
          //Compute values for x and y relative to the
          // center.
          x = col - halfWidth;
          y = row - halfHeight;
          if(x != 0){
            //Must avoid division by 0.
            hueAngle = (float)(Math.atan(y/x));
          }else{
            //x is equal to zero
            if(y &gt;= 0){
              hueAngle = (float)(Math.PI/2);
            }else{
              hueAngle = (float)(2 * Math.PI - Math.PI/2);
            }//end else
          }//end else

          //Now get the angle into the correct quadrant.
          if((x &lt; 0) && (y &lt;= 0)){
            hueAngle = (float)(Math.PI + hueAngle);
          }else if((x &gt; 0) && (y &lt; 0)){
            hueAngle = (float)(2 * Math.PI + hueAngle);
          }else if((x &lt; 0) && (y &gt; 0)){
            hueAngle = (float)(Math.PI + hueAngle);
          }//end else

          if(radius != 0){
            //Get the length of a line from the center to
            // the pixel as the square root of the sum of
            // the squares. Must avoid division by 0.
            // Must also scale by radius to support the
            // varying diameter of the color wheel for the
            // cone display format.
            satVal = (float)(Math.sqrt(
                               (x/radius) * (x/radius) +
                               (y/radius) * (y/radius)));
          }else{
            //The radius is equal to 0. This is the 
            // very bottom of the cone.
            satVal = (float)(0.0);
          }//end else

          //Up to this point, the angle has been expressed
          // in radians. Convert it to degrees.
          hueAngle = (float)(Math.toDegrees(hueAngle));

          //Convert the color to an RGB color that can be
          // used to set the color of a pixel. Note that
          // this method requires parameters of type float
          // and not type double.
          color = new Color(Color.HSBtoRGB(
                                    (float)(hueAngle/360),
                                    satVal,
                                    (float)bright));

          //Set the color of the pixel.
          pixel = display.getPixel(col,row);
          pixel.setColor(color);

        }//end if
      }//end inner loop
    }//end outer loop

    //The wheel has been drawn with the correct colors for
    // the horizontal slice through the cone or the 
    // cylinder based on the value of the Brightness 
    // slider.
    //Now superimpose a white radial line and a white 
    // circle on the wheel with their positions, radius, 
    // etc., based on the values of the Hue and Saturation
    // sliders.
    graphics = display.getGraphics();

    //Get the coordinates of the intersection of the 
    // radial hue line indicated by hueSlider and the 
    // saturation circle indicated by satSlider.
    int xLoc = (int)(halfWidth + 
                       (radius*satSlider.getValue()/100) *
                                Math.cos(Math.toRadians(
                                  hueSlider.getValue())));
    int yLoc = (int)(halfHeight + 
                       (radius*satSlider.getValue()/100) *
                                Math.sin(Math.toRadians(
                                  hueSlider.getValue())));

    //Get the color of the pixel at the intersection. 
    // Note, the line and the circle haven't been drawn 
    // yet. Otherwise, the color of the pixel would be 
    // white.
    if((xLoc &lt; pictureWidth) && (yLoc &lt; pictureHeight)){
      color = display.getPixel(xLoc,yLoc).getColor();
    }//end if

    //Display the value of the color in hex format in a
    // text field.
    hexField.setText(Integer.toHexString(color.getRGB()).
                              toUpperCase().substring(2));
    //Draw a round color swatch in the upper-left corner 
    // that matches the pixel color at the intersection.
    graphics.setColor(color);
    graphics.fillOval(5,5,40,40);

    //Now draw the white radial hue line and the white 
    // saturation circle.
    graphics.setColor(Color.WHITE);

    //Draw a white circle at the saturation value 
    // indicated by satSlider.
    graphics.drawOval(
        (int)(halfWidth-radius*satSlider.getValue()/100),
        (int)(halfHeight-radius*satSlider.getValue()/100),
        (int)(2*radius*satSlider.getValue()/100),
        (int)(2*radius*satSlider.getValue()/100));

    //Draw a radial line at the hue angle indicated by
    // hueSlider.
    graphics.drawLine(
                halfWidth,
                halfHeight,
                halfWidth + (int)(radius * Math.cos(
                  Math.toRadians(hueSlider.getValue()))),
                halfHeight + (int)(radius * Math.sin(
                  Math.toRadians(hueSlider.getValue()))));

    //Autograph the painting.
    display.addMessage("Dick Baldwin",150,50);

    //Repaint the display.
    display.repaint();

  }//end handleSliders
  //----------------------------------------------------//

}//end class HsbColor01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
