<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Back to Basics with MIDlets and the Sun Java Wireless Toolkit 
for CLDC</h2>
<p><i>Learn how the CLDC and the MIDP fit into the grand scheme of things in MIDlet 
programming.&nbsp; Learn how to change the behavior of a Java program by 
replacing the classes in the Java standard library with custom classes of your 
own design. Learn that the required life cycle behavior of a MIDlet is not 
enforced, requiring the programmer to write MIDlet code that plays by the rules.&nbsp; 
Learn one approach to writing MIDlet code that does play by the rules.</i></p>
<p><b>Published:</b>&nbsp; January 29, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2574</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#How_CLDC_and_MIDP_fit_into_the_grand_scheme_of_things">How 
	the CLDC and the MIDP fit into the grand scheme of things</a></li>
	<li><a href="#A_simple_example">A simple example</a></li>
	<li><a href="#The_life_cycle_of_a_MIDlet">The life cycle of a MIDlet</a><ul>
	<li><a href="#General_background_information3">General background 
	information</a></li>
	<li><a href="#Preview3">Preview</a></li>
	<li><a href="#Discussion_and_sample_code3">Discussion and sample code</a><ul>
	<li><a href="#The_MIDlet_named_LifeCycle02">The MIDlet named LifeCycle02</a></li>
	<li><a href="#The_MIDlet_named_LifeCycle01">The MIDlet named LifeCycle01</a></li>

</ul>
	</li>
</ul>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a><hr size="3" width="100%" align="center">
</ul><center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> This is the third lesson in a series of tutorial lessons designed to teach 
you how to write programs using the Sun Java Wireless Toolkit for CLDC.&nbsp; 
The first lesson was titled <i>Getting Started with MIDlets and the Sun Java 
Wireless Toolkit for CLDC (see <a href="#Resources">Resources</a>)</i>.&nbsp; The previous lesson was titled <i>Capturing Output 
Produced by Programs Running in a Child Process</i>.</p>
	<p> <font color="#FF0000"><b>A MIDlet development framework</b></font></p>
<p> In the first lesson I provided and explained a MIDlet development framework 
that makes experimenting with the programming of MIDlets fairly easy.&nbsp; In 
the previous lesson, I taught you how to capture and display the standard output 
and the error output produced by programs executing in a child process.&nbsp; I applied that knowledge to upgrade the MIDlet development framework from the 
earlier lesson.</p>
	<p><font color="#FF0000"><b>What you will learn</b></font></p>
	<p> In this lesson, I will tackle two topics.&nbsp; 
First, I will teach you how the CLDC and the MIDP fit into the 
grand scheme of things when programming MIDlets.&nbsp; Next, I will explain and demonstrate the life cycle of 
a MIDlet.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Output from program DateDemo02.</li>
	<li><a href="#Figure_2">Figure 2</a>. Output from program DateDemo01.</li>
	<li><a href="#Figure_3">Figure 3</a>. Output from the MIDlet named 
	LifeCycle02.</li>
	<li><a href="#Figure_4">Figure 4</a>. Cell phone emulator output when MIDlet 
	is in paused state.</li>
	<li><a href="#Figure_5">Figure 5</a>. Standard output from the MIDlet named 
	LifeCycle01.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Command for compiling a MIDlet.</li>
	<li><a href="#Listing_2">Listing 2</a>. DateDemo01.java.</li>
	<li><a href="#Listing_3">Listing 3</a>. DateDemo02.java.</li>
	<li><a href="#Listing_4">Listing 4</a>. Batch file to demonstrate class 
	substitution.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of LifeCycle02 MIDlet 
	program.</li>
	<li><a href="#Listing_6">Listing 6</a>. Beginning of the startApp method.</li>
	<li><a href="#Listing_7">Listing 7</a>. The pauseApp method.</li>
	<li><a href="#Listing_8">Listing 8</a>. The startApp method continues 
	executing code.</li>
	<li><a href="#Listing_9">Listing 9</a>. The destroyApp method.</li>
	<li><a href="#Listing_10">Listing 10</a>. The startApp method executes even 
	more code.</li>
	<li><a href="#Listing_11">Listing 11</a>. Beginning of the class named 
	LifeCycle01.</li>
	<li><a href="#Listing_12">Listing 12</a>. The beginning of the startApp 
	method.</li>
	<li><a href="#Listing_13">Listing 13</a>. When the running flag is true.</li>
	<li><a href="#Listing_14">Listing 14</a>. The pauseApp method.</li>
	<li><a href="#Listing_15">Listing 15</a>. The destroyApp method.</li>
	<li><a href="#Listing_16">Listing 16</a>. The resume method.</li>
	<li><a href="#Listing_17">Listing 17</a>. The beginning of the Toggler 
	class.</li>
	<li><a href="#Listing_18">Listing 18</a>. Beginning of the run method in the 
	Toggler object.</li>
	<li><a href="#Listing_19">Listing 19</a>. Wake up and do something.</li>
	<li><a href="#Listing_20">Listing 20</a>. Cause the MIDlet to enter the 
	destroyed state.</li>
	<li><a href="#Listing_21">Listing 21</a>. The Thread class named Worker.</li>
	<li><a href="#Listing_22">Listing 22</a>. The beginning of the run method 
	for the Worker class.</li>
	<li><a href="#Listing_23">Listing 23</a>. When the kill flag is false.</li>
	<li><a href="#Listing_24">Listing 24</a>. The Worker thread goes to sleep.</li>
	<li><a href="#Listing_25">Listing 25</a>. The MIDlet named LifeCycle02.</li>
	<li><a href="#Listing_26">Listing 26</a>. The MIDlet program named 
	LifeCycle01.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center">
<a name="How_CLDC_and_MIDP_fit_into_the_grand_scheme_of_things">How the CLDC and 
the MIDP fit into the grand scheme of things</a></h2>
<p><font color="#FF0000"><b>What are the CLDC and the MIDP anyway?</b></font></p>
<p>Let's begin by taking a look at what some others have to say on this topic <i>
(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>According to Wikipedia</b></font></p>
<blockquote>
	<p><i>&quot;The <b>Connected Limited Device Configuration (CLDC)</b> is a 
specification of a framework for Java ME applications targeted at devices with 
very limited resources such as pagers and mobile phones.&quot;</i></p>
	<p><i>&quot;<b>Mobile Information Device Profile</b> (<b>MIDP</b>) is a specification 
published for the use of Java on embedded devices such as mobile phones and PDAs. 
MIDP is part of the Java Platform, Micro Edition (Java ME) framework and sits on 
top of Connected Limited Device Configuration, a set of lower level programming 
interfaces.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>According to Vikram Goyal </b></font> <i>
<font color="#FF0000">(see </font> <a href="#Resources"><font color="#FF0000">Resources</font></a><font color="#FF0000">)</font></i></p>
<blockquote>
	<p><i>&quot;J2ME can be divided into three parts... a configuration, a profile, and 
optional packages. A configuration contains the JVM (not the traditional JVM, 
but the cut-down version) and some class libraries; a profile builds on top of 
these base class libraries by providing a useful set of APIs ... The 
configuration and profile are supplied by the device manufacturers and they 
embed them in the devices.&quot;</i></p>
</blockquote>
<p>Continuing with Goyal:</p>
<blockquote>
	<p><i>&quot;The most popular profile and configuration that Sun provides are the 
Mobile Information Device Profile (MIDP) and Connected Limited Device 
Configuration (CLDC), respectively. As the name suggests, CLDC is for devices 
with limited configurations; for example, devices that have only 128 to 512KB of 
memory available for Java applications. Consequently, the JVM that it provides is very 
limited and supports only a small number of traditional Java classes. (This 
limited JVM is actually called the KVM.) ...</i></p>
	<p><i>The MID profile ... provides the basic API that is used for creating 
application for these devices.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>According to this author</b></font></p>
<p>Let me take a crack at the explanation in more fundamental and 
practical terms.&nbsp; You 
learned in a previous lesson that you can compile a MIDlet using a standard J2SE 
compiler <i>(javac.exe)</i>.&nbsp;&nbsp; You compile the MIDlet by entering a 
command at the command line containing the terms shown in Listing 1.&nbsp; <i>
(All of the terms must be on a single line to constitute a valid command.)</i></p>
<p>
<b><a name="Listing_1">Listing 1</a>. Command for compiling a MIDlet. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table5">
  <tbody>
    <tr>
      <td>
      <pre>javac -target 1.4 -source 1.4 
-bootclasspath 
C:\WTK2.5.2\lib\<b>cldcapi11.jar</b>;
C:\WTK2.5.2\lib\<b>midpapi20.jar</b> 
WTK001\WTK001.java</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In Listing 1, <b>cldcapi11.jar</b> and <b>midpapi20.jar</b> are the names of 
two JAR files containing class files in the <b>lib</b> directory of the 
installation directory tree for the wireless toolkit, <b>WTK2.5.2</b>.&nbsp; 
These two JAR files correspond to CLDC 1.1 and MIDP 2.0 respectively.</p>
<p><font color="#FF0000"><b>Other versions are available</b></font></p>
<p>These are not the only JAR files corresponding to the CLDC and the MIDP in 
the wireless toolkit.&nbsp; The <b>lib</b> directory of <b>WTK2.5.2</b> contains 
the following JAR files corresponding to these and other versions of
<a name="the_CLDC_and_the_MIDP:">the CLDC and the MIDP:</a></p>
<ol>
	<li>cldcapi10.jar</li>
	<li>cldcapi11.jar</li>
	<li>midpapi10.jar</li>
	<li>midpapi20.jar</li>
	<li>midpapi21.jar</li>
</ol>
<p>Links to online API documentation for the first four items in the above list 
are provided in <a href="#Resources">Resources</a>.</p>
<p><font color="#ff0000"><b>The bootclasspath option</b></font></p>
<p>The <i>bootclasspath</i> option to <b>javac</b> <i>(-bootclasspath in Listing 1)</i> instructs 
the compiler to <i>&quot;Override the location of bootstrap class files.&quot;</i>&nbsp; In 
other words, as used in Listing 1, this option instructs the compiler to forgo the use of the standard 
J2SE class libraries and to use the class libraries provided by the wireless toolkit 
instead.</p>
<p>The two elements in the classpath specify the paths to the<b> WTK2.5.2 </b>
JAR files for CLDC 1.1 and MIDP 2.0 respectively.&nbsp; Thus, the classes in those 
two JAR files will be used to compile the program instead of the classes in the 
standard J2SE class library.</p>
<p>If you want to compile to a different version of the CLDC and/or the MIDP, 
substitute the names of different JAR files from the above
<a href="#the_CLDC_and_the_MIDP:">list</a> in the command shown in Listing 1.&nbsp; 
For example, the cell phone that I carry in my pocket has CLDC 1.0 and MIDP 1.0 
installed.&nbsp; Therefore, it would not support some of the features in the 
later versions of the CLDC and the MIDP.</p>
<p><font color="#FF0000"><b>What class files are provided by CLDC 1.1?</b></font></p>
<p>Now that we have eliminated the class files from the standard J2SE class 
libraries, it is useful to know what class files we have to work with.&nbsp; According to the 
API documentation <i>(see <a href="#Resources">Resources</a>)</i>, CLDC 1.1 contains the
<a name="following_packages">following packages</a>:</p>
<ul>
	<li><b>java.io</b></li>
	<li><b>java.lang</b></li>
	<li>java.lang.ref</li>
	<li><b>java.util</b></li>
	<li>javax.microedition.io</li>
</ul>
<p><font color="#FF0000"><b>Common package names</b></font></p>
<p>The three packages shown in boldface have exactly the same names as packages 
in JDK 1.6.&nbsp; Thus, they are direct but smaller replacements for the 
packages in the standard J2SE class library having the same names.&nbsp; 
</p>
<p><font color="#FF0000"><b>Consider the java.io package</b></font></p>
<p>Consider, for example, the <b>java.io</b> package.&nbsp; This package contains 
the following eleven classes in CLDC 1.1:</p>
<ol>
	<li><font class="FrameItemFont">ByteArrayInputStream </font></li>
	<li><font class="FrameItemFont">ByteArrayOutputStream </font></li>
	<li><font class="FrameItemFont">DataInputStream </font></li>
	<li><font class="FrameItemFont">DataOutputStream </font></li>
	<li><font class="FrameItemFont">InputStream </font></li>
	<li><font class="FrameItemFont">InputStreamReader </font></li>
	<li><font class="FrameItemFont">OutputStream </font></li>
	<li><font class="FrameItemFont">OutputStreamWriter </font></li>
	<li><font class="FrameItemFont">PrintStream </font></li>
	<li><font class="FrameItemFont">Reader </font></li>
	<li><font class="FrameItemFont">Writer</font></li>
</ol>
<p>On the other hand, if I counted correctly, the <b>java.io</b> package in JDK 
1.6 contains more than fifty classes, including all eleven of the classes in the 
above list.</p>
<p><font color="#FF0000"><b>What about the methods in the classes?</b></font></p>
<p>Drilling down even deeper, the <b>Reader</b> class in CLDC 1.1 contains only nine 
methods whereas the <b>Reader</b> class in JDK 1.6 contains ten methods.</p>
<p><font color="#FF0000"><b>What about the package names that don't match?</b></font></p>
<p>The two packages in the above <a href="#following_packages">list</a> that are contained in CLDC 1.1 but are not contained in JDK 1.6 contain only three classes: <b>Connector</b>, <b>
Reference</b>, and <b>WeakReference</b>.</p>
<p>I don't believe that JDK 1.6 contains a class named <b>Connector</b>.&nbsp; 
JDK 1.6 does contain several different classes named <b>Reference</b> and several 
different classes named <b>WeakReference</b> in different packages.</p>
<p>To the extent that the wireless toolkit classes have the same package and 
class names as their counterparts in JDK 1.6, those packages and classes exist 
in three packages in the CLDC portion of the wireless class library.</p>
<p><font color="#FF0000"><b>The MIDP class library</b></font></p>
<p>Curiously, those same three matching packages plus the package named <b>
javax.microedition.io</b> are also contained in MIDP 2.0 and in some cases, the 
version in MIDP 2.0 contains more classes than the version in CLDC 1.1.&nbsp; 
For example, the following 
two classes are contained in the <b>java.util</b> package in MIDP 2.0 but are not contained in the<b> 
java.util</b> 
package in<b> </b>CLDC 1.1:</p>
<ol>
	<li><font class="FrameItemFont">java.util.Timer</font></li>
	<li><font class="FrameItemFont">java.util.TimerTask</font></li>
</ol>
<p>In a similar vein, the <b>javax.microedition.io</b> package in MIDP contains 
a class named <font class="FrameItemFont"><b>PushRegistry</b> that is not 
contained in the package having the same name in CLDC 1.1.</font></p>
<p>A quick scan indicates that other than the three classes mentioned above, the 
four packages that are common to CLDC 1.1 and MIDP 2.0 have the same number of 
classes with the same names.&nbsp; However, I haven't drilled deep enough to determine if any of the 
classes that are common between CLDC 1.1 and MIDP 2.0 have different methods.</p>
<p><font color="#FF0000"><b>What about the other packages in MIDP 2.0?</b></font></p>
<p>MIDP 2.0 contains the following packages:</p>
<ol>
	<li><b><font class="FrameItemFont">java.io</font> </b></li>
	<li><b><font class="FrameItemFont">java.lang</font> </b></li>
	<li><b><font class="FrameItemFont">java.util</font></b> </li>
	<li><font class="FrameItemFont">javax.microedition.io</font> </li>
	<li><font class="FrameItemFont">javax.microedition.lcdui</font> </li>
	<li><font class="FrameItemFont">javax.microedition.lcdui.game</font> </li>
	<li><font class="FrameItemFont">javax.microedition.media</font> </li>
	<li><font class="FrameItemFont">javax.microedition.media.control</font> 
	</li>
	<li><font class="FrameItemFont">javax.microedition.midlet</font> </li>
	<li><font class="FrameItemFont">javax.microedition.pki</font> </li>
	<li><font class="FrameItemFont">javax.microedition.rms</font> </li>
</ol>
<p>Except for the first three packages <i>(highlighted in boldface)</i>, 
packages having these names are not contained in JDK 1.6.&nbsp; Therefore, the 
classes in these packages were probably designed specifically for use with MIDlets.</p>
	<p><font color="#FF0000"><b>The bottom line</b></font></p>
<p>In the most basic sense, the CLDC and the MIDP are simply a pair of JAR files 
containing class files that are used in place of the class files from the 
standard J2SE class library to compile and execute MIDlet code.</p>
<p>The total number of class files in the CLDC and the MIDP is much lower than 
the number of class files in the standard J2SE class library.</p>
<p>The class files in the CLDC and the MIDP are specially designed to be run in 
devices with limited configurations under the control of a scaled down virtual 
machine.</p>
<p>Different versions of the CLDC and the MIDP are available and you must 
specify the versions that you are targeting when you compile a MIDlet.</p>
<p>A virtual machine, a CLDC, and an MIDP are embedded in a Java-compatible 
device by the manufacturer of the device.&nbsp; Therefore, it isn't necessary to 
provide the class files and the virtual machine to deploy a MIDlet into a cell 
phone.&nbsp; However, it is necessary to make certain that the versions of the 
class files and the virtual machine used to develop and test the MIDlet are 
compatible with the versions that are embedded in the cell phone.</p>
<h2 align="center"><a name="A_simple_example">A simple example</a></h2>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table6">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table7">
  <tr><td bgcolor="#eeeeee">
  <b>Windows versus other platforms</b><br />
  The batch file used in this example is written in Windows format.&nbsp; 
	Hopefully you can write a comparable script that is compatible with your 
	platform.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>An important characteristic of Java</b></font></p>
<p>Before getting into the life cycle of a MIDlet, I want to show you a pair of simple 
example programs to refresh you memory on an important characteristic of Java.&nbsp; 
This is something that you probably already knew, but may have forgotten about, 
or may never have thought much about.&nbsp; That characteristic is:</p>
<blockquote>
	<p><i>You can 
completely change the behavior of a Java program by replacing one or more 
classes in the standard class library with custom classes of your own design.</i></p>
</blockquote>
<p><font color="#FF0000"><b>Create some files</b></font></p>
<p>Use your text editor to create the two simple Java programs and the batch 
file shown in Listings 2 through 4 in the current directory.&nbsp; Then execute 
the batch file.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. DateDemo01.java. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table8">
  <tbody>
    <tr>
      <td>
      <pre>/*DateDemo01.java
Tested using Java SE 6 running under Windows XP.
*********************************************************/
import java.util.*;

class DateDemo01{
  public static void main(String[] args){
    System.out.println(new Date());
  }//end mail
}//end DateDemo01

class Date{
  public String toString(){
    return "A custom Date class.";
  }//end overridden toString method

}//end substitute class named Date</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_3">Listing 3</a>. DateDemo02.java. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table9">
  <tbody>
    <tr>
      <td>
      <pre>/*DateDemo02.java
Tested using Java SE 6 running under Windows XP.
*********************************************************/
import java.util.*;

class DateDemo02{
  public static void main(String[] args){
    System.out.println(new Date());
  }//end mail
}//end DateDemo02</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Batch file to demonstrate class 
substitution. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table10">
  <tbody>
    <tr>
      <td>
      <pre>echo off
echo Demonstrate class substitution

del *.class
javac <b>-classpath .;</b>  DateDemo02.java
dir /B *.class
java <b>-classpath .;</b>  DateDemo02

del *.class
javac <b>-classpath .;</b> DateDemo01.java
dir /B *.class
java <b>-classpath .;</b>  DateDemo01

pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The behavior of the batch file</b></font></p>
<p>The batch file in Listing 4 begins by:</p>
<ul>
	<li>Deleting all of the class files in the current directory.</li>
	<li>Compiling the program named <b>DateDemo02</b> shown in Listing 3.</li>
	<li>Displaying all of the class files in the current directory.</li>
	<li>Executing the program named <b>DateDemo02</b>.</li>
</ul>
<p><font color="#FF0000">
 <b>Output from program DateDemo02</b></font></p>
<p>This produces the output shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Output from program DateDemo02.</b><table width="477" border="1" cols="1" bgcolor="#ffffff" id="table11">
  <tbody>
    <tr>
      <td>
      <pre>Demonstrate class substitution
DateDemo02.class
<b>Sun Dec 09 09:16:25 CST 2007</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see in Figure 1, following compilation of the program named <b>
DateDemo02</b>, the current directory contains only one class file and it is 
named <b>DateDemo02.class</b>.</p>
<p>As you can also see in Figure 1, execution of the program named <b>DateDemo02</b> 
produces an output consisting of the current date and time.&nbsp; This is what 
you would normally expect from the single statement in the <b>main</b> method in
<b>DateDemo02</b>, which</p>
<ul>
	<li>Instantiates a new object of the <b>Date</b> class in the standard class 
	library by calling the constructor that takes no parameters.</li>
	<li>Passing that object's reference to the <b>println</b> method.</li>
</ul>
<p>So far, everything is as you would normally expect when you execute the code 
in the <b>main</b> method in the program named <b>DateDemo02</b>.</p>
<p><font color="#FF0000"><b>The program named DateDemo01</b></font></p>
<p>Now consider the behavior of the program named <b>DateDemo01</b> shown in 
Listing 2.&nbsp; Note in particular that the <b>main</b> method in <b>DateDemo01</b> 
is identical to the <b>main</b> method in <b>DateDemo02</b>.</p>
<p>The batch file in Listing 4 continues by:</p>
<ul>
	<li>Deleting all of the class files in the current directory again.</li>
	<li>Compiling the program named <b>DateDemo01</b> shown in Listing 2.</li>
	<li>Displaying all of the class files in the current directory.</li>
	<li>Executing the program named <b>DateDemo01</b>.</li>
</ul>
<p><font color="#FF0000">
 <b>Output from program DateDemo01</b></font></p>
<p>This produces the output shown in Figure 2.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Output from program DateDemo01. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table12">
  <tbody>
    <tr>
      <td>
      <pre>Date.class
DateDemo01.class
<b>A custom Date class.</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first thing to note about the output shown in Figure 2 is that the 
current directory now contains a class file named <b>Date.class</b> in addition 
to the class file named <b>DateDemo01.class</b>.&nbsp; This results from the 
fact that a simple class named <b>Date</b> is included in Listing 2 in addition 
to the class named <b>DateDemo01</b>.</p>
<p>The next thing to notice is that the output shown in Figure 2 doesn't display 
the current date and time.&nbsp; Instead, it displays the text shown in boldface 
in Figure 2.</p>
<p><font color="#FF0000"><b>How did this happen?</b></font></p>
<p>This happened as a result of:</p>
<ul>
	<li>The inclusion of the definition of the class named <b>Date</b> in 
	Listing 2.</li>
	<li>The inclusion of the <i>&quot;-classpath&quot;</i> option 
shown in boldface in the batch file in Listing 4.</li>
</ul>
<p><font color="#FF0000"><b>What is the <i>&quot;-classpath&quot;</i> option?</b></font></p>
<p>The <i>&quot;-classpath&quot;</i> option 
is described in one of the following two ways, depending on whether you are 
looking at the documentation for <b>java</b> or the documentation for <b>javac</b> respectively:</p>
<ul>
	<li>class search path of directories and zip/jar files</li>
	<li>Specify where to find user class files and annotation processors</li>
</ul>
<p>Both descriptions of the <i>&quot;-classpath&quot;</i> option mean essentially the same 
thing.&nbsp; The classpath that you provide along with this option tells the compiler or the virtual 
machine where to look for class files before looking for them in the standard 
library.&nbsp; If a suitable class file is found in one of the locations 
specified by the classpath, the compiler or the virtual machine will look no 
further but will attempt to use that class file to either compile or execute the 
program, depending on whether <b>javac.exe</b> or <b>java.exe</b> is being 
executed.</p>
<p><font color="#FF0000"><b>The current directory</b></font></p>
<p>In this case, the classpath used in the batch file in all four cases was &quot;.;&quot;
<i>(this is a period followed by a semicolon in case it is not clear in the 
rendering of this document on your machine)</i>.&nbsp; This tells the compiler or the virtual 
machine to look in the current directory before looking in the standard library 
for all class files that are needed.</p>
<p>The <b>main</b> method in both programs required the compiler and the virtual machine to find and use a 
class named <b>Date</b> that has a constructor that takes no parameters.&nbsp; 
In the case of compiling and executing the program named <b>DateDemo02</b>, 
there was no local definition of a class named <b>Date</b> and no file named <b>
Date.class</b> in the current directory.&nbsp; Therefore, the 
compiler and the virtual machine retrieved and used the class file named <b>
Date.class</b> from the standard library, producing the current date and time 
in the output shown in Figure 1.</p>
<p>In the second case involving the program named <b>DateDemo01</b>, the 
compiler found the definition for a suitable class named <b>Date</b> in the file with 
the definition of the class named <b>DateDemo01</b>.&nbsp; It compiled this 
<b>Date</b> class and wrote the resulting class file named <b>Date.class</b> in the current directory.&nbsp; 
As a result, 
the current directory ended up containing a file named <b>Date.class</b>.&nbsp; 
That is the class file that was used by the virtual machine to execute the 
program, producing the output shown in Figure 2.</p>
<p><font color="#FF0000"><b>The bottom line</b></font></p>
<p>The bottom line is that you can completely change the behavior of a Java 
program by substituting custom class files in place of the class files in the 
standard library.</p>
<p>Furthermore, this doesn't require you to perform major 
surgery on the JAR files that contain the standard library.&nbsp; All that is 
required is that you cause the compiler and the virtual machine to find your 
custom classes before they search the standard library for the required class 
files.&nbsp; This can be accomplished through the manipulation of the <b>classpath</b> 
environment variable.</p>
<p>In this example, I only wanted to replace one class 
files, so I simply placed the replacement class file in the current directory and 
manipulated the classpath to cause the virtual machine to search the current 
directory before searching the standard library.&nbsp; As a result, it found and 
used the version of the required class file in the current directory and didn't 
search the standard library for that class file.</p>
<p>The J2ME on the other hand replaces all of the classes in the 
standard library with a smaller set of custom classes.&nbsp; It accomplishes 
this by using the <i>&quot;-bootclasspath&quot;</i> option with the compiler to <i>&quot;Override the 
location of bootstrap class files&quot;</i> and substitutes a complete new class 
library contained in two JAR files as shown in Listing 1.</p>
<h2 align="center"><a name="The_life_cycle_of_a_MIDlet">The life cycle of a 
MIDlet</a></h2>
<h3 align="left"><a name="General_background_information3">General background information</a></h3>
<p>When you write your code for a new MIDlet, the main class must extend the <b>
javax.microedition.midlet.MIDlet</b> class.&nbsp; Otherwise, you are very likely 
to encounter compiler errors.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table13">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table14">
  <tr><td bgcolor="#eeeeee">
  <b>The main class ...</b><br />
  As used here, the term<i> main class</i> refers to the class that will be 
	instantiated by the Application Management Software <i>(AMS)</i> to 
	instantiate the object that constitutes the MIDlet in the cell phone.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Methods of the MIDlet class</b></font></p>
<p>The MIDlet class in MIDP 2.0 defines
<a name="nine_methods_including_the_following">nine methods including the six 
methods shown below</a>:</p>
<ul>
	<li>protected <i>abstract</i> void <b>startApp</b>()</li>
	<li>protected <i>abstract</i> void <b>pauseApp</b>()</li>
	<li>public final void <b>notifyPaused</b>()</li>
	<li>protected <i>abstract</i> void <b>destroyApp</b>(boolean&nbsp;unconditional)</li>
	<li>public final void <b>notifyDestroyed</b>()</li>
	<li>public final void <b>resumeRequest</b>()</li>
</ul>
<p>As you can see from the above list, three of the methods are abstract.&nbsp; 
Whenever you extend a class containing abstract methods, you must provide 
concrete definitions of those abstract methods, or you must declare your new class 
<i>abstract</i> meaning that it cannot be 
instantiated.</p>
<p><font color="#FF0000"><b>Instantiating the MIDlet class</b></font></p>
<p>At some point during the process of deploying a MIDlet into 
a cell phone, the cell phone instantiates an object from your main MIDlet class.&nbsp; 
Therefore, you must provide concrete definitions of the three abstract methods 
in the above list.</p>
<p>According to Goyal,</p>
<blockquote>
	<p><i>&quot;Mobile devices, whether emulators or real, interact with a MIDlet using 
their own software, which is called Application Management Software (AMS). The 
AMS is responsible for initializing, starting, pausing, resuming, and destroying 
a MIDlet. (Besides these services, AMS may be responsible for installing and 
removing a MIDlet, as well.) To facilitate this management, a MIDlet can be in 
one of three states which is <b>
	<a name="controlled_via_the_MIDlet_class_methods">controlled via the MIDlet class methods</a></b>, that every MIDlet extends and overrides. 
These states are <b>active</b>, <b>paused</b> and <b>destroyed</b>.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>The three states of a MIDlet</b></font></p>
<p>As described by Goyal, a MIDlet can exist in any one of three states:</p>
<ol>
	<li>paused</li>
	<li>active</li>
	<li>destroyed</li>
</ol>
<p>The MIDlet can be switched back and forth between the <i>paused</i> and <i>active</i> 
states either by the AMS or by code written into the MIDlet.&nbsp; The MIDlet 
can enter the destroyed state from either the paused state or from the active 
state.</p>
<p><font color="#FF0000"><b>Apparently the required behavior of the states is 
not enforced</b></font></p>
<p>A first reading of the literature may cause you to believe that the required 
behavior of these states 
is enforced by some higher power.&nbsp; In other words, you might conclude that a 
MIDlet in the destroyed state cannot execute code <i>(much like a thread that 
has gone to sleep cannot execute code)</i>.&nbsp; While that may be true for 
actual cell phones, it is certainly not true for MIDlet code executing in Sun's 
cell phone emulator.&nbsp; As I will show later, a MIDlet in the destroyed state 
running in the emulator can continue to execute code just as though it never 
entered the destroyed state in the first place.</p>
<p><font color="#FF0000"><b>Control over MIDlet state</b></font></p>
<p>Therefore, the control over MIDlet state that is provided by the
<a href="#controlled_via_the_MIDlet_class_methods">MIDlet class methods</a> 
should be considered somewhat analogous to the control over automobile drivers 
that is provided 
by traffic lights.&nbsp; Drivers are expected to follow a set of well-defined 
rules when approaching a traffic light, but there is nothing to prevent a driver 
from speeding right through a red light.&nbsp; For example, the requirement for 
the driver to stop when the 
traffic light turns red is not enforced by a large gate coming down and blocking 
the road, as is the case at many railroad crossings and ferry landings.</p>
<p><font color="#FF0000">
 <b>Output from the MIDlet named LifeCycle02</b></font></p>
<p>This lack of enforcement is illustrated in Figure 3,which shows a portion of 
the output from a MIDlet named <b>LifeCycle02</b>.&nbsp; <i>(Four lines of text 
in Figure 3 were manually made boldface by the author for emphasis.)</i></p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Output from the MIDlet named LifeCycle02. </b>
<table border="1" cols="1" bgcolor="#ffffff" id="table15">
  <tbody>
    <tr>
      <td>
      <pre>OUT: Running with locale: English_United States.1252
OUT: Running in the identified_third_party security domain
OUT: <b>Constructed at: 0</b>
OUT: <b>startApp method called at: 40</b>
OUT:
OUT: <b>pauseApp method called at: 50</b>
OUT: Time is: 1052
OUT: Time is: 2053
OUT: Time is: 3055
OUT: Time is: 4056
OUT: Time is: 5058
OUT: <b>destroyApp method called at:  5058</b>
OUT: Time is: 6059
OUT: Time is: 7060
OUT: Time is: 8062
OUT: Time is: 9063
OUT: Time is: 10065</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display time that certain events occur</b></font></p>
<p>I will present and explain the code in the MIDlet named <b>LifeCycle02</b> 
later.&nbsp; For now, suffice it to say that the MIDlet displays the time in 
milliseconds that certain events happen during the execution of the MIDlet <i>
(relative to the time that the MIDlet object was constructed)</i>.&nbsp; The 
output for four of these events is highlighted in boldface in Figure 3.</p>
<p>The MIDlet object was constructed at time zero.&nbsp; The <b>startApp</b> 
method was called by the AMS at 40 milliseconds following construction.</p>
<p><font color="#FF0000"><b>A call to the pauseApp method</b></font></p>
<p>The <b>pauseApp</b> method was called by the <b>startApp</b> method at 50 
milliseconds following construction.&nbsp; The <b>pauseApp</b> method 
immediately notified the AMS that it was entering the paused state by calling 
the <b>notifyPaused</b> method.&nbsp; Then it executed another statement to 
produce the third boldface line of text in Figure 3 even though it was supposed 
to be in the paused state.&nbsp; Then it returned control to the <b>startApp</b> 
method.</p>
<p><font color="#FF0000"><b>A call to the destroyApp method</b></font></p>
<p>When the <b>startApp</b> method received control, it continued to execute 
code even though the MIDlet was supposed to be in the paused state.&nbsp; Note 
that it wasn't restarted.&nbsp; It simply continued with the next statement 
following the earlier call to the <b>pauseApp</b> method.</p>
<p>At this point, the <b>startApp</b> method executed the code necessary to 
produce five more lines of output text and then called the <b>destroyApp</b> 
method.</p>
<p>The <b>destroyApp</b> method notified the AMS that it was entering the 
destroyed state by calling the method named <b>notifyDestroyed</b>.&nbsp; Then 
it executed another statement to produce the fourth line of boldface text in Figure 
3 even though the MIDlet was supposed to be in the destroyed state at that point 
in time.&nbsp; Then the <b>destroyApp</b> method returned control to the <b>
startApp</b> method.</p>
<p><font color="#FF0000"><b>Execute some more code</b></font></p>
<p>Once again, when the <b>startApp</b> method received control, it continued to 
execute code even though the MIDlet was supposed to be in the destroyed state.&nbsp; 
It executed the code necessary to produce five more lines of output text before 
returning control to the AMS from which it was called it in the first place.</p>
<p><font color="#FF0000"><b>Not how it is supposed to be done</b></font></p>
<p>This is not how it is supposed to be done.&nbsp; This MIDlet clearly failed 
to follow the rules and ran several red lights during its execution.</p>
<p><font color="#FF0000"><b>Programmers are expected to follow the rules</b></font></p>
<p>Unlike the author of the MIDlet named <b>LifeCycle02</b> <i>(yours truly)</i>, 
programmers using the MIDlet class methods to control the state of 
the MIDlet are expected to follow a set of rules, which are reasonably well 
defined in the documentation.&nbsp; If a programmer fails to follow the rules, 
chaos may ensue when the MIDlet is actually executed in a cell phone or cell 
phone emulator.&nbsp; However, there appears to be nothing to force that 
programmer to follow the rules; at least that is true for Sun's cell phone 
emulator.</p>
<p><font color="#FF0000"><b>How the MIDlet class methods are supposed to be used</b></font></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table16">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table17">
  <tr><td bgcolor="#eeeeee">
  <b>No constructor parameters allowed</b><br />
  It is my understanding that the constructor for the MIDlet may not have any 
	arguments.&nbsp; This makes sense due to the fact that if the constructor 
	did have arguments, the AMS would have no way of knowing what those 
	arguments are.&nbsp; <i>(A simple 
test will probably demonstrate that if you include arguments in your MIDlet 
constructor, it will throw a runtime error or exception.)</i></td></tr></table>
</td>
</tr>
</table>
<p>That having been said, let's discuss how the five methods in the above
<a href="#nine_methods_including_the_following">list</a> are supposed to be used 
to control the state of a MIDlet.</p>
<p>It appears that when a MIDlet is installed in a cell phone, the JAR file 
containing the class files is saved by the cell phone.&nbsp; Then when the 
MIDlet is <i>launched</i>, the AMS 
instantiates a new object of the MIDlet class by applying the <b>new</b> 
operator to the constructor for the class in the normal way.&nbsp; <i>(The term 
launched comes from the Sun cell phone emulator.&nbsp; Other emulators or actual 
cell phones may use different terminology for this process.)</i></p>
<p><font color="#FF0000"><b>Starts out in the paused state</b></font></p>
<p>When the object is instantiated from your MIDlet class, the 
MIDlet starts out in the paused state.&nbsp; <i>(This probably occurs when you 
click the soft key on the cell phone keypad to launch the MIDlet.)</i>&nbsp; 
Shortly thereafter, the AMS will 
call the <b>startApp</b> method on the MIDlet object.&nbsp; This provides the 
first opportunity for the MIDlet to execute code.&nbsp; According to the Sun 
documentation, calling the <b>startApp</b> method </p>
<blockquote>
	<p><i>&quot;Signals the MIDlet that it has entered the Active state. In the Active 
state the MIDlet may hold resources. The method <b>
	<a name="will_only_be_called">will only be called</a></b> when the 
MIDlet is in the Paused state.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>The terminology is misleading</b></font></p>
<p>Once again, the terminology is somewhat misleading.&nbsp; There appears to be 
nothing to prevent the programmer from calling the <b>startApp</b> method when 
the MIDlet is in the active state.&nbsp; Experimentation shows that this does 
not produce a compiler error and does not necessarily produce an immediate 
runtime error in the Sun cell phone emulator.&nbsp; Of course, it does put the 
MIDlet into an infinite recursive loop from which it probably can't escape of its own 
accord, which is not a good thing.&nbsp; It would probably be more correct if 
the <a href="#will_only_be_called">above text</a> were to read, <i>&quot;should only 
be called.&quot;</i></p>
<p><font color="#FF0000"><b>The resumeRequest method</b></font></p>
<p>The <b>startApp</b> method probably should not be called by code executing in 
the MIDlet, even when the MIDlet is in the paused state.&nbsp; Instead, the 
method named <b>resumeRequest</b> <a href="#If_the_application_pauses_itself">
should be called</a>.&nbsp; If the AMS agrees that the MIDlet should be moved 
from the paused stat to the active state at that point in time, it will call the
<b>startApp</b> method on the MIDlet object.</p>
<p>Here is part of what Sun has to say about the <b>resumeRequest</b> method:</p>
<blockquote>
	<p><i>&quot;Provides a MIDlet with a mechanism to indicate that it is interested 
	in entering the Active state. Calls to this method can be used by the 
	application management software to determine which applications to move to 
	the Active state. </i></p>
	<p><i>When the application management software decides to activate this 
	application it will call the startApp method.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Executing code while in the paused state</b></font></p>
<p>You might wonder how the code in a MIDlet can call the <b>resumeRequest</b> 
method when it is in the paused state and is not supposed to be executing code.&nbsp; 
Here is some more of what Sun has to say about the <b>resumeRequest</b> method:</p>
<blockquote>
	<p><i>&quot;The application is generally in the Paused state when this is called. 
	Even in the paused state the application may handle asynchronous events such 
	as timers or callbacks.&quot;</i></p>
</blockquote>
<p>In other words, even though a paused MIDlet is supposed to have released 
certain resources and is not generally supposed to be executing code, it is not 
supposed to be dead or completely deaf.&nbsp; It should be able to service &quot;<i>asynchronous 
events such as timers or callbacks.&quot;</i></p>
<p><font color="#FF0000"><b>Entering the paused state</b></font></p>
<p>Either the AMS or code running in the MIDlet can cause the MIDlet to enter the 
paused state by calling the <b>pauseApp</b> method on the MIDlet object.&nbsp; 
Here is some of what Sun has to say about the <b>pauseApp</b> method:</p>
<blockquote>
	<p><i>&quot;Signals the MIDlet to enter the Paused state. In the Paused state the 
	MIDlet must release shared resources and become <a name="quiescent">quiescent</a>. This method will 
	only be called when the MIDlet is in the Active state.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Clarification of the text</b></font></p>
<p>Once again, in order to reflect the reality of non-enforcement, it would 
probably be better if the terms <i>&quot;must release&quot;</i> and <i>&quot;will only be 
called&quot;</i> were replaced by <i>&quot;should release&quot;</i> and <i>&quot;should only be 
called.&quot;</i></p>
<p><font color="#FF0000"><b>The notifyPaused method</b></font></p>
<p>To satisfy the spirit of the requirements, the overridden <b>pauseApp</b> 
method should not only <i>&quot;release shared resources&quot;</i> and <i>&quot;<a href="#quiescent">become 
quiescent</a>&quot;; </i>it should also call the method named <b>notifyPaused</b>, which 
notifies the AMS that the MIDlet is playing by the rules.&nbsp; Here is part of 
what Sun has to say about the <b>notifyPaused</b> method:</p>
<blockquote>
	<p><i>&quot;Notifies the application management software that the MIDlet does not 
	want to be active and has entered the Paused state. Invoking this method 
	will have no effect if the MIDlet is destroyed, or if it has not yet been 
	started. </i></p>
	<p><i>It may be invoked by the MIDlet when it is in the Active state. </i>
	</p>
	<p><i>If a MIDlet calls notifyPaused(), in the future its startApp() method 
	may be called make it active again, or its destroyApp() method may be called 
	to request it to destroy itself. </i></p>
	<p><i><a name="If_the_application_pauses_itself">If the application pauses 
	itself</a> it will need to call resumeRequest to request to reenter the 
	active state.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Not an accurate reflection of reality</b></font></p>
<p>Once again, I'm not certain that the first paragraph in the above quotation 
is an accurate reflection of reality.&nbsp; In fact, the MIDlet may have a great 
desire to remain active but the AMS may have called the <b>pauseApp</b> method 
on behalf of some higher priority activity such an incoming call on the cell 
phone.&nbsp; I view the act of calling the <b>notifyPaused</b> method on the 
part of the MIDlet as simply being an acknowledgement that:</p>
<ul>
	<li>Its <b>pauseApp</b> method has been called</li>
	<li>It will play by the rules</li>
	<li>It will <i>(possibly grudgingly) </i>release shared resources and become 
	quiescent</li>
</ul>
<p><font color="#FF0000"><b>Entering the destroyed state</b></font></p>
<p>That brings us to the final two methods of immediate interest in the MIDlet 
class:</p>
	</li>
<ul>
	<li>protected <i>abstract</i> void <b>destroyApp</b>(boolean&nbsp;unconditional)</li>
	<li>public final void <b>notifyDestroyed</b>()</li>
</li>
</ul>
<p><font color="#FF0000"><b>The destroyApp method</b></font></p>
<p>The <b>destroyApp</b> method is a little more complicated than the other 
methods in the earlier <a href="#nine_methods_including_the_following">list</a>.&nbsp; Here is part of what Sun has to say about this method:</p>
<blockquote>
	<p><i>&quot;Signals the MIDlet to terminate and enter the Destroyed state. In the 
	destroyed state the MIDlet must release all resources and save any 
	persistent state. This method may be called from the Paused or Active 
	states.<br><br>MIDlets should perform any operations required before being terminated, such 
	as releasing resources or saving preferences or state.<br><br>Note: The MIDlet can request that it not enter the Destroyed state by 
	throwing an MIDletStateChangeException. This is only a valid response if the 
	unconditional flag is set to false. If it is true the MIDlet is assumed to 
	be in the Destroyed state regardless of how this method terminates. If it is 
	not an unconditional request, the MIDlet can signify that it wishes to stay 
	in its current state by throwing the MIDletStateChangeException. This 
	request may be honored and the destroyApp() method called again at a later 
	time.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b><a name="Asking_for_a_reprieve">Asking for a reprieve</a></b></font></p>
<p>As you can see from the above quotation, unlike the <b>pauseApp</b> method, 
the MIDlet can ask for a reprieve from entering the destroyed state by throwing 
a <b>MIDletStateChangeException</b> if the incoming parameter is false.&nbsp; 
However, this opportunity for a reprieve is not available if the incoming 
parameter is true.</p>
<p>The calling method may grant the reprieve or it may call the <b>destroyApp</b> 
method again, this time with a true parameter indicating that the reprieve is 
not granted.&nbsp; However, it is apparently assumed that the MIDlet has not 
entered the destroyed state if the incoming parameter is false and the <b>destroyApp</b> method throws the 
<b>MIDletStateChangeException</b>.</p>
<p><font color="#FF0000"><b>The notifyDestroyed method</b></font></p>
<p>According to Sun, this method is </p>
<blockquote>
	<p><i>&quot;Used by an MIDlet to notify the application management software that 
	it has entered into the Destroyed state. The application management software 
	will not call the MIDlet's destroyApp method, and all resources held by the 
	MIDlet will be considered eligible for reclamation. The MIDlet must have 
	performed the same operations (clean up, releasing of resources etc.) it 
	would have if the MIDlet.destroyApp() had been called.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>When should this method be called?</b></font></p>
<p>This method should be called if the MIDlet elects to enter the destroyed 
state of its own accord without its <b>destroyApp</b> method having been called.&nbsp; 
However, it is unclear to me whether or not the MIDlet should also call this 
method:</p>
<ul>
	<li>When its <b>destroyApp</b> method has been called.</li>
	<li>When either the incoming parameter is true, or the MIDlet has elected 
	not to throw a <b>MIDletStateChangeException</b>.</li>
	<li>When it has completed all cleanup activities, and is ready to enter the 
	destroyed state.</li>
</ul>
<p>However, my assumption is that calling the <b>notifyDestroyed</b> method at 
this point may be useful to the AMS and probably wouldn't be harmful.&nbsp; The 
AMS should be able to interpret this call as a signal that the MIDlet has 
entered the destroyed state as requested.</p>
<h3><a name="Preview3">Preview</a></h3>
<p>I will present and explain two MIDlet programs in this lesson:</p>
<ul>
	<li>LifeCycle02</li>
	<li>LifeCycle01</li>
</ul>
<p>The MIDlet named <b>LifeCycle02</b> produces the output shown in Figure 3 and 
demonstrates that the required behavior for each of the three states of a MIDlet 
is not enforced.</p>
<p>Given that state behavior is not enforced, the MIDlet named <b>LifeCycle01</b> 
illustrates one approach to writing MIDlet code that plays by the rules.</p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table21">
	<tr>
		<td width="10">
		<td>
		<table width="100%" cellpadding="5" cellspacing="0" border="1" id="table22">
			<tr>
				<td bgcolor="#eeeeee"><b>MIDlet testing</b><br />The MIDlets in this lesson were tested using a 
Java SE 6 compiler, targeted at a V1.4 virtual machine, and WTK 2.5.2, <i>(which 
	includes the Sun cell phone emulator)</i> running 
under Windows XP.
</td>
			</tr>
		</table></td>
	</tr>
</table>
<h3><a name="Discussion_and_sample_code3">Discussion and sample code</a></h3>
<p></p>
<h4><a name="The_MIDlet_named_LifeCycle02">The MIDlet named LifeCycle02</a></h4>
<p>This MIDlet demonstrates that a MIDlet can continue to execute code while in 
the paused state or in the destroyed state when running in the Sun cell phone emulator.</p>
<p>During the time that the MIDlet is in the paused state, the Sun cell phone 
emulator displays a box on the cell phone screen as shown in Figure 4.&nbsp; 
This is an example of what is often referred to as a <i>system screen</i>.</p>
<p><b><a name="Figure_4">Figure 4</a>. Cell phone emulator output when MIDlet is 
	in paused state. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table18">
	<tbody>
		<tr>
			<td>
			<pre><img border="1" src="java2574a1.jpg" width="314" height="477"></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>In addition, as shown in Figure 4, a red indicator shows in the middle of the right-most soft key while the MIDlet is in the paused state.&nbsp; Despite this, 
however, this MIDlet continues to execute code and to display text on the standard output screen 
while it is in the paused state or the destroyed state.&nbsp; The text that the 
MIDlet displays on the standard output device is shown in Figure 3.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>I will explain the code in this MIDlet in fragments, the first of which is 
shown in Listing 5.&nbsp; <i>(A complete listing of the MIDlet program is 
provided in Listing 25.)</i></p>
<p><b><a name="Listing_5">Listing 5</a>. Beginning of LifeCycle02 MIDlet program. 
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table23">
	<tbody>
		<tr>
			<td>
			<pre>package LifeCycle02;

import javax.microedition.midlet.MIDlet;
import java.lang.Thread;
import java.util.Date;

public class LifeCycle02 extends MIDlet{

  long timeBase;
  boolean running = false;

  public LifeCycle02(){
    timeBase = new Date().getTime();
    System.out.println("Constructed at: "
                       + (new Date().getTime()-timeBase));
  }//end constructor</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Listing 5 shows the beginning of the MIDlet class including the constructor.&nbsp; 
The code in the constructor establishes the time <i>(in milliseconds relative to 
Jan 1, 1970)</i> that the MIDlet object is constructed.&nbsp; This time will be 
used to compute the elapsed times in milliseconds at which other events occur 
relative to the construction time of the MIDlet.</p>
<p><font color="#FF0000"><b>Beginning of the startApp method</b></font></p>
<p>The beginning of the method named <b>startApp</b> is shown in Listing 6.</p>
<p><b><a name="Listing_6">Listing 6</a>. Beginning of the startApp method. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table24">
	<tbody>
		<tr>
			<td>
			<pre>  public void startApp(){

    System.out.println("startApp method called at: "
                       + (new Date().getTime()-timeBase));
    //Make the AMS believe that the MIDlet is paused
    <b>pauseApp()</b>;</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>startApp</b> method is initially called by the AMS to change the state of the MIDlet from 
<i>paused</i> to <i>active</i>.</p>
<p><font color="#FF0000"><b>The pauseApp method</b></font></p>
<p>The code in the <b>startApp</b> method in Listing 6 calls the <b>pauseApp</b> 
method to cause the AMS to believe that the MIDlet is in the paused state.&nbsp; 
Putting the <b>startApp</b> method on the back burner for a little while, 
Listing 7 shows the <b>pauseApp</b> method in its entirety.</p>
<p><b><a name="Listing_7">Listing 7</a>. The pauseApp method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table25">
	<tbody>
		<tr>
			<td>
			<pre>  public void pauseApp(){
    notifyPaused();
    System.out.println("\npauseApp method called at: "
                       + (new Date().getTime()-timeBase));
  }//end pauseApp</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>pauseApp</b> method begins by calling the <b>notifyPaused</b> method.&nbsp; 
This erroneously notifies the AMS that the MIDlet will follow the rules, go into 
the paused state, and will <a href="#quiescent">release shared resources and become quiescent</a>.&nbsp; 
However, the MIDlet does not become quiescent.&nbsp; Rather, the <b>pauseApp</b> 
method immediately executes another statement, which produces the third line of 
boldface text shown in Figure 3.&nbsp; Then the <b>pauseApp</b> method returns 
control to the <b>startApp</b> method from which it was called.</p>
<p><font color="#FF0000"><b>The startApp method continues executing code</b></font></p>
<p>Rather than being quiescent, when control returns to the <b>startApp</b> 
method, it continues executing code as shown in Listing 8.</p>
<p><b><a name="Listing_8">Listing 8</a>. The startApp method continues executing 
code. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table26">
	<tbody>
		<tr>
			<td>
			<pre>    for(int cnt = 0;cnt < 5;cnt++){
      try{Thread.currentThread().sleep(1000);
      }catch(InterruptedException e){}
      System.out.println("Time is: "
                       + (new Date().getTime()-timeBase));
    }//end for loop
    
    //Destroy the MIDlet.
    <b>destroyApp</b>(true);</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The code shown in Listing 8 produces the five lines of text following the 
third line of boldface text in Figure 3.</p>
<p><font color="#FF0000"><b>The destroyApp method</b></font></p>
<p>Then the <b>startApp</b> method calls the method named <b>destroyApp</b> as 
shown by the last statement in Listing 8.&nbsp; The <b>destroyApp</b> method is 
shown in its entirety in Listing 9.</p>
<p><b><a name="Listing_9">Listing 9</a>. The destroyApp method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table27">
	<tbody>
		<tr>
			<td>
			<pre>  public void destroyApp(boolean unconditional){
    notifyDestroyed();
    System.out.println("destroyApp method called at:  "
                       + (new Date().getTime()-timeBase));
  }//end destroyApp</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>destroyApp</b> method immediately calls the <b>notifyDestroyed</b> 
method to erroneously tell the AMS that the MIDlet is in the destroyed state.&nbsp; 
Once it is in the destroyed state, it can then be launched again.</p>
<p>Then, rather than acting like the MIDlet is in the destroyed state, the <b>destroyApp</b> method executes another statement, which produces the fourth line 
of boldface text in Figure 3.&nbsp; Then the <b>destroyApp</b> method returns 
control to the <b>startApp</b> method from which it was called.</p>
<p><font color="#FF0000"><b>The startApp method executes even more code</b></font></p>
<p>When control returns to the <b>startApp</b> method, it executes even more 
code as shown in Listing 10 even though the MIDlet is supposed to be in the 
destroyed state.&nbsp; This produces the last five lines of output text shown in 
Figure 3.</p>
<p><b><a name="Listing_10">Listing 10</a>. The startApp method executes even more 
code. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table28">
	<tbody>
		<tr>
			<td>
			<pre>    for(int cnt = 0;cnt &lt; 5;cnt++){
      try{Thread.currentThread().sleep(1000);
      }catch(InterruptedException e){}
      System.out.println("Time is: "
                       + (new Date().getTime()-timeBase));
    }//end for loop
  }//end startApp
}//end class LifeCycle02</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Finally, after executing that code, which requires about five seconds, the <b>startApp</b> method returns control to the AMS from which it was called and the 
MIDlet acts as though it is in the destroyed state.</p>
<p><font color="#FF0000"><b>Not how it should be done</b></font></p>
<p>The MIDlet named <b>LifeCycle02</b> demonstrates how you should <b>not</b> 
use the methods of the <b>MIDlet</b> class to control the state of the <b>MIDlet</b>.&nbsp; 
The code in this MIDlet simply doesn't follow the rules of the road.&nbsp; 
However, the MIDlet program named <b>LifeCycle01</b>, which I will present and 
explain next does follow the rules of the road and does show how I believe the 
methods of the <b>MIDlet</b> class should be used to control the state of the <b>MIDlet</b>.</p>
<h4><a name="The_MIDlet_named_LifeCycle01">The MIDlet named LifeCycle01</a></h4>
<p>The purpose of this MIDlet is to demonstrate the following three states in 
which a MIDlet can reside:</p>
<ul>
	<li>paused</li>
	<li>active</li>
	<li>destroyed</li>
</ul>
<p><font color="#FF0000"><b>Three threads</b></font></p>
<p>This MIDlet is comprised of three threads.&nbsp; One thread is the main 
MIDlet thread containing the methods <b>startApp</b>, <b>pauseApp</b>, and <b>destroyApp</b>.</p>
<p>A second thread is instantiated from a <b>Thread</b> class named <b>Toggler</b>.&nbsp; 
This thread is spawned and run to toggle the MIDlet between the active and 
paused states at approximately two-second intervals.&nbsp; After approximately 
twenty seconds, the <b>Toggler</b> instructs the MIDlet to enter the destroyed 
state.</p>
<p>A third thread is instantiated from a <b>Thread</b> class named <b>Worker</b>.&nbsp; 
This thread is spawned and run to do some work while the MIDlet is in the active 
state.&nbsp; The work that it does is to display a period on the standard output 
device approximately once every half second.&nbsp; This thread sleeps while the 
MIDlet is in the paused state, and dies when the MIDlet enters the destroyed 
state.&nbsp; <i>(It also sleeps some of the time that the MIDlet is in the 
active state to avoid consuming excessive computer resources.)</i></p>
<p><font color="#FF0000"><b>Cell phone output from the MIDlet</b></font></p>
<p>During those time intervals that the MIDlet is in the paused state, the Sun 
cell phone emulator displays the image shown in Figure 4.&nbsp; Because the <b>Toggler</b> repeatedly toggles the MIDlet between the active state and the 
paused state, the cell phone emulator screen repeatedly toggles between a blank 
screen <i>(except for the name of the MIDlet at the top of the screen)</i> and 
the image shown in Figure 4.&nbsp; When the MIDlet enters the destroyed state, 
the cell phone emulator screen goes blank and stays blank until the MIDlet is 
launched again.</p>
<p><font color="#FF0000"><b>Standard output from the MIDlet</b></font></p>
<p>Figure 5 shows the output produced by the MIDlet on the standard output 
device while the MIDlet is running.&nbsp; <i>(Note that this output does not 
appear on the cell phone screen.)</i></p>
<p><b><a name="Figure_5">Figure 5</a>. Standard output from the MIDlet named 
	LifeCycle01. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table29">
	<tbody>
		<tr>
			<td>
			<pre>OUT: Constructed at: 0
OUT: Started at: 47
OUT: <b>I'm working .....</b>
OUT: Paused at: 2047
OUT: Re-started at: 4047
OUT: <b>I'm awake .....</b>
OUT: Paused at: 6047
OUT: Re-started at: 8047
OUT: <b>I'm awake .....</b>
OUT: Paused at: 10047
OUT: Re-started at: 12047
OUT: <b>I'm awake .....</b>
OUT: Paused at: 14047
OUT: Re-started at: 16047
OUT: <b>I'm awake .....</b>
OUT: Paused at: 18047
OUT: Destroyed at:  20047
OUT: <b>I'm awake Terminating worker</b></pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>What is the boldface text in Figure 5?</b></font></p>
<p>Some of the text in Figure 5 was manually highlighted in boldface by this 
author when this tutorial was written.&nbsp; The boldface text shows the 
standard output produced by the <b>Worker</b> thread while the MIDlet is in the 
active state.</p>
<p>It is important to note that there is no output produced by the <b>Worker</b> 
thread while the MIDlet is in the paused state because it has been put to sleep.&nbsp; 
There is also no output produced by the <b>Worker</b> thread while the MIDlet is 
in the destroyed state, except that when the worker wakes up and discovers that 
the MIDlet is in the destroyed state, the worker thread notifies us of that fact 
and terminates itself by causing itself to die a natural death.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will present and explain this MIDlet program in fragments.&nbsp; You can 
view a complete program listing in Listing 26 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Beginning of the class named LifeCycle01</b></font></p>
<p>The first fragment, which shows the beginning of the class named <b>LifeCycle01</b> is shown in Listing 11.</p>
<p><b><a name="Listing_11">Listing 11</a>. Beginning of the class named 
LifeCycle01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table30">
	<tbody>
		<tr>
			<td>
			<pre>package LifeCycle01;

import javax.microedition.midlet.MIDlet;
import java.lang.Thread;
import java.util.Date;

public class LifeCycle01 extends MIDlet{

  Toggler theToggler;
  Worker theWorker;
  long timeBase;
  boolean running = false;

  public LifeCycle01(){
    theToggler = new Toggler(this);
    theWorker = new Worker(true,false);
    //Establish the time (in milliseconds relative to
    // Jan 1, 1970) that the MIDlet object is constructed.
    // This time will be used to compute the elapsed times
    // in milliseconds at which other events occur
    // relative to the construction time of the MIDlet.
    timeBase = new Date().getTime();
    System.out.println("Constructed at: "
                       + (new Date().getTime()-timeBase));
  }//end constructor</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Given the previous discussion of the overall behavior of the MIDlet and 
comments in Listing 11, you should have no difficulty understanding the code in 
Listing 11.</p>
<p><font color="#FF0000"><b>The beginning of the startApp method</b></font></p>
<p>Listing 12 shows the beginning of the <b>startApp</b> method.&nbsp; This 
method is called by the AMS to change the state of the MIDlet from its initial 
paused state to the active state.</p>
<p><b><a name="Listing_12">Listing 12</a>. The beginning of the startApp method. 
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table31">
	<tbody>
		<tr>
			<td>
			<pre>  public void startApp(){
    if(!running){
      //This is the first time that this method has been
      // called.
      System.out.println("Started at: "
                       + (new Date().getTime()-timeBase));
      running = true;
      //Start the Toggler thread running.
      theToggler.start();
      //Start the worker thread running in an active
      // (not-paused) MIDlet state.
      theWorker.paused = false;
      theWorker.start();</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>The running flag</b></font></p>
<p>The <b>boolean</b> variable named <b>running</b> is used to determine if the 
MIDlet is being moved to the active state for the first time or being moved from 
the paused state to the active state after having been paused earlier while the 
MIDlet was already running.&nbsp; Basically this variable is used:</p>
<ul>
	<li>To control which message to display on the standard output device:<ul>
		<li>Started at ..., or</li>
		<li>Re-started at ...</li>
	</ul></li>
	<li>To decide whether to:<ul>
		<li>Start the <b>Toggler</b> thread running or not.</li>
		<li>Start the <b>Worker</b> thread running for the first time, or </li>
		<li>To wake the <b>Worker</b> thread up from its self-imposed sleep.</li>
	</ul></li>
</ul>
<p>The code in Listing 12 discovers that the <b>running</b> flag is false.&nbsp; 
As a result, it:</p>
<ul>
	<li>Displays a message telling when the MIDlet was first started <i>(put 
	into the active state)</i>.</li>
	<li>Sets the <b>running</b> flag to true.</li>
	<li>Starts the <b>Toggler</b> thread running.</li>
	<li>Sets the <b>paused</b> flag belonging to the <b>Worker</b> thread to 
	false.</li>
	<li>Starts the <b>Worker</b> thread running for the first time.</li>
</ul>
<p><font color="#FF0000"><b>When the running flag is true...</b></font></p>
<p>Listing 13 shows the <b>else</b> clause associated with the <b>if-else</b> 
construct that began in Listing 12.</p>
<p><b><a name="Listing_13">Listing 13</a>. When the running flag is true.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table32">
	<tbody>
		<tr>
			<td>
			<pre>    }else{
      //This is not the first time that this method has
      // been called.
      System.out.println("Re-started at: "
                       + (new Date().getTime()-timeBase));
      //Wake the Worker thread up if it is asleep. Set
      // the paused flag to false to tell the worker to
      // get to work.
      theWorker.paused = false;
      theWorker.interrupt();
    }//end else
  }//end startApp</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The code in Listing 13 is executed when the <b>running</b> flag is found to 
be true.&nbsp; This will be the case for the remainder of the execution of the 
MIDlet after the code in Listing 12 is executed once.</p>
<p><font color="#FF0000"><b>Wake up and get to work!</b></font></p>
<p>The code in Listing 13:</p>
<ul>
	<li>Displays a message showing the relative time that the MIDlet is being 
	restarted <i>(entering the active state)</i> after having earlier been put 
	in the paused state during the execution of the MIDlet.</li>
	<li>Sets the <b>paused</b> flag belonging to the <b>Worker</b> thread to 
	false, indicating that the thread should start working.</li>
	<li>Wakes the <b>Worker</b> thread up.&nbsp; <i>(It should have been 
	sleeping while the MIDlet was in the paused state)</i>.</li>
</ul>
<p><font color="#FF0000"><b>The pauseApp method</b></font></p>
<p>Listing 14 shows the <b>pauseApp</b> method in its entirety.&nbsp; This method is called by the
<b>Toggler</b> thread to cause the MIDlet to enter the paused state. It may also be called by the AMS 
if the AMS decides that the MIDlet needs to enter the paused state for any 
reason <i>(such as to release resources to support an incoming call)</i>.</p>
<p><b><a name="Listing_14">Listing 14</a>. The pauseApp method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table33">
	<tbody>
		<tr>
			<td>
			<pre>  public void <b>pauseApp</b>(){
    System.out.println("\nPaused at: "
                       + (new Date().getTime()-timeBase));
    //Tell Worker to go to sleep for a long time the next
    // time it checks the paused flag.
    theWorker.paused = true;
    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Behavior of the pauseApp method</b></font></p>
<p>The <b>pauseApp</b> method begins by setting the <b>paused</b> flag belonging 
to the <b>Worker</b> thread to true.&nbsp; The next time the <b>Worker</b> 
thread wakes up and checks this flag, it will put itself to sleep for a very 
long time.</p>
<p>Then the <b>pauseApp</b> method calls the <b>notifyPaused</b> method to tell 
the AMS that the MIDlet is playing by the rules.&nbsp; In particular, it has 
released shared resources and will become quiescent.&nbsp; The only remaining 
activity on the part of the MIDlet while it is in the paused state will be a 
very small amount of activity on the part of the <b>Worker</b> thread while it 
is checking its <b>paused</b> flag and putting itself to sleep for a long time.</p>
<p><font color="#FF0000"><b>The destroyApp method</b></font></p>
<p>Listing 15 shows the <b>destroyApp</b> method in its entirety.&nbsp; This 
thread is called by the <b>Toggler</b> thread to cause the MIDlet to enter the 
destroyed state.&nbsp; It is also possible that this method could be called by 
the AMS if the AMS decides for some reason to put the MIDlet into the destroyed 
state.</p>
<p><b><a name="Listing_15">Listing 15</a>. The destroyApp method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table34">
	<tbody>
		<tr>
			<td>
			<pre>  public void <b>destroyApp</b>(boolean unconditional){
    //Tell the Worker to terminate the next time it checks
    // its flags.
    theWorker.kill = true;
    //Wake the worker up if it is asleep.
    theWorker.interrupt();
    System.out.println("Destroyed at:  "
                       + (new Date().getTime()-timeBase));
    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Behavior of the destroyApp method</b></font></p>
<p>The <b>destroyApp</b> method begins by setting the <b>kill</b> flag belonging 
to the <b>Worker</b> thread to true.&nbsp; This tells the <b>Worker</b> thread 
to commit suicide the next time it checks the value of its <b>kill</b> flag.</p>
<p>Then the <b>destroyApp</b> method wakes the <b>Worker</b> thread up if it is 
asleep.&nbsp; This will cause it to check its <b>kill</b> flag and commit 
suicide fairly quickly.</p>
<p>Then the <b>destroyApp</b> method prints a message on the standard output 
device showing the relative time that it entered the destroyed state.</p>
<p></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table53">
	<tr>
		<td width="10">
		<td>
		<table width="100%" cellpadding="5" cellspacing="0" border="1" id="table54">
			<tr>
				<td bgcolor="#eeeeee"><b>No reprieve requested</b><br />Note that in this example, the code in the<b>
				</b>destroyApp method doesn't 
	exercise its right to request a <a href="#Asking_for_a_reprieve">reprieve</a> 
	from entering the destroyed state.<b> </b></td>
			</tr>
		</table></td>
	</tr>
</table>
<p>Finally, the <b>destroyApp</b> method calls the <b>notifyDestroyed</b> method 
to tell the AMS that the MIDlet is entering the destroyed state.&nbsp; Although 
I'm not certain, I assume that the AMS destroys its current reference to the 
MIDlet object at that time, causing that object, and all the objects on which it 
holds references to become eligible for garbage collection.&nbsp; 
In any event, after the <b>destroyApp</b> method is called, it becomes possible 
to click the top right soft key on the cell phone emulator keyboard shown in 
Figure 4 and launch 
the MIDlet again.</p>
<p><font color="#FF0000"><b>The resume method</b></font></p>
<p>The resume method is shown in its entirety in Listing 16.</p>
<p><b><a name="Listing_16">Listing 16</a>. The resume method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table35">
	<tbody>
		<tr>
			<td>
			<pre>  public void resume(){
    resumeRequest();
  }//end resume</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b><a name="Behavior_of_the_resume_method">Behavior of the resume method</a></b></font></p>
<p>The <b>resume</b> method is called by the <b>Toggler</b> thread to cause the 
MIDlet to call the <b>resumeRequest</b> method.&nbsp; This sends a request to 
the AMS to return the MIDlet from the paused state to the active state.&nbsp; If 
the request is honored, the AMS will call the <b>startApp</b> method on the 
MIDlet thread, leading to the behavior discussed <a href="#Listing_13">earlier</a>.&nbsp;
<i>(Note in particular that the <b>Toggler</b> thread does not call the <b>startApp</b> method directly but delegates that task back to the main MIDlet 
thread and the AMS.)</i></p>
<p></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table55">
	<tr>
		<td width="10">
		<td>
		<table width="100%" cellpadding="5" cellspacing="0" border="1" id="table56">
			<tr>
				<td bgcolor="#eeeeee"><b>A member class</b><br />Not that it is terribly important, the 
				<b>Toggler</b> class is also a member 
	class of the class named <b>LifeCycle01</b>.&nbsp; I tend to use member 
	classes, local classes, and anonymous classes frequently because it makes 
	Java programming easier.
</td>
			</tr>
		</table></td>
	</tr>
</table>
<p><font color="#FF0000"><b>The beginning of the Toggler class</b></font></p>
<p>The beginning of the <b>Thread</b> class named <b>Toggler</b> is shown in 
Listing 17.&nbsp; It is important to note that this class extends the Thread 
class.&nbsp; </p>
<p><b><a name="Listing_17">Listing 17</a>. The beginning of the Toggler class. 
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table36">
	<tbody>
		<tr>
			<td>
			<pre>  class Toggler extends Thread{
    LifeCycle01 theMIDlet;

    Toggler(LifeCycle01 theMIDlet){
      this.theMIDlet = theMIDlet;
    }//end constructor</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table39">
	<tr>
		<td width="10">
		<td>
		<table width="100%" cellpadding="5" cellspacing="0" border="1" id="table40">
			<tr>
				<td bgcolor="#eeeeee"><b>Multithreaded programming</b><br />I am going to assume that you already understand multithreaded programming.&nbsp; 
	If not, you may want to take a look
				<a href="http://www.dickbaldwin.com/java/Java058.htm">here</a>.</td>
			</tr>
		</table></td>
	</tr>
</table>
<p><font color="#FF0000"><b>Purpose of the Toggler class</b></font></p>
<p>The purpose of an object of the <b>Toggler</b> class is to cause the main thread to toggle between the active state and the paused state every two seconds during a total of ten cycles.&nbsp; Then it causes the main thread to enter the destroyed state.&nbsp; 
In other words, the <b>Toggler</b> object exists solely to exercise the 
remaining code in the MIDlet to confirm that it is working properly.</p>
<p><font color="#FF0000"><b>A reference back to the MIDlet</b></font></p>
<p>The constructor for the <b>Toggler</b> object receives and saves a 
reference back to the MIDlet from which the thread was spawned.&nbsp; This makes 
it possible later to call methods on the MIDlet object.</p>
<p><font color="#FF0000"><b>The run method in a thread</b></font></p>
<p>Every <b>Thread</b> object has a method named <b>run</b>, and this is where 
the action begins and ends.&nbsp; I often tell my students that the <b>run</b> 
method in a thread is somewhat analogous to the <b>main</b> method in an 
application.</p>
<p>The <b>run</b> method is executed by calling the <b>start</b> method on the 
thread object.&nbsp; The <b>run</b> method can instantiate new objects, call 
other methods, etc., but when the <b>run</b> method terminates, the thread dies.&nbsp; 
That is to say, if you call the <b>isAlive</b> method on a thread before the <b>run</b> method terminates, it will return true.&nbsp; If you call the same 
method after the <b>run</b> method terminates, it will return false.</p>
<p></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table41">
	<tr>
		<td width="10">
		<td>
		<table width="100%" cellpadding="5" cellspacing="0" border="1" id="table42">
			<tr>
				<td bgcolor="#eeeeee"><b>Making the threads eligible for garbage collection</b><br />When the AMS causes the MIDlet object to become eligible for garbage 
	collection, this should in turn cause the thread objects held by the MIDlet 
	object to also become eligible for garbage collection.
</td>
			</tr>
		</table></td>
	</tr>
</table>
<p><font color="#FF0000"><b>Not eligible for garbage collection yet</b></font></p>
<p>It is important to note, however that causing a thread to die does not make the <b>Thread</b> object eligible for garbage collection.&nbsp; The 
<b>Thread</b> 
object continues to occupy memory for as long as there is an active reference to 
the object being held by the MIDlet program.&nbsp; As a result, it is possible 
to call the <b>start</b> method on the object and bring the thread back to life.&nbsp; 
However, even though the MIDlet continues to hold a reference to the <b>Toggler</b> 
object, it isn't brought back to life in this MIDlet once it has died.</p>
<p><font color="#FF0000"><b>Beginning of the run method in the Toggler object</b></font></p>
<p>The <b>run</b> method in the <b>Toggler</b> object begins in Listing 18.</p>
<p><b><a name="Listing_18">Listing 18</a>. Beginning of the run method in the 
Toggler object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table37">
	<tbody>
		<tr>
			<td>
			<pre>    public void run(){
      for(int cnt = 0;cnt &lt; 10;cnt++){
        //Sleep for two seconds.
        try{Thread.currentThread().sleep(2000);
        }catch(Exception e){}</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The method begins by entering a <b>for</b> loop that it will iterate ten 
times.&nbsp; Then it immediately puts itself to sleep for two seconds <i>(2000 
milliseconds)</i>.</p>
<p><font color="#FF0000"><b>Wake up and do something</b></font></p>
<p>After two seconds, the <b>Toggler</b> thread wakes up naturally and executes 
the <b>if-else</b> construct shown in Listing 19.</p>
<p><b><a name="Listing_19">Listing 19</a>. Wake up and do something. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table38">
	<tbody>
		<tr>
			<td>
			<pre>        if(cnt % 2 == 0){
          theMIDlet.<b>pauseApp</b>();
        }else{
          theMIDlet.<b>resume</b>();
        }//end else
      }//end for loop</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>If the counter value is even...</b></font></p>
<p>The conditional clause in the <b>if</b> statement tests to determine if the 
current value of the counter in the <b>for</b> loop is even or odd.&nbsp; If the 
counter value is even, the <b>Toggler</b> calls the <b>pauseApp</b> method on 
the MIDlet to cause the MIDlet to enter the paused state.&nbsp; Then control 
goes back to the top of the <b>for</b> loop where the <b>Toggler</b> goes back 
to sleep for two more seconds.</p>
<p><font color="#FF0000"><b>If the counter value is odd...</b></font></p>
<p>If the counter value is odd, the <b>Toggler</b> calls the <b>resume</b> 
method on the MIDlet to cause the MIDlet to send a request to the AMS to return it to the active state 
as explained <a href="#Listing_16">earlier</a>.&nbsp; Also as explained earlier, 
if the request is honored, by the AMS, the AMS will call the <b>startApp</b> method on the main 
MIDlet thread. Once again, that the <b>Toggler</b> object does not call the <b>startApp</b> method directly.</p>
<p>Then the <b>Toggler</b> object goes back to sleep for another two seconds.</p>
<p><font color="#FF0000"><b>Cause the MIDlet to enter the destroyed state</b></font></p>
<p>Listing 20 shows the code that is executed when the <b>for</b> loop counter 
reaches 10 and the conditional clause in Listing 18 is false.</p>
<p><b><a name="Listing_20">Listing 20</a>. Cause the MIDlet to enter the destroyed 
state. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table43">
	<tbody>
		<tr>
			<td>
			<pre>      theMIDlet.<b>destroyApp</b>(true);
    }//end run
  }//end class Toggler</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>At that point, the <b>Toggler</b> calls the <b>destroyApp</b> method on the 
MIDlet causing the MIDlet to enter the destroyed state as described
<a href="#Listing_15">earlier</a>.</p>
<p><font color="#FF0000"><b>The Toggler thread dies</b></font></p>
<p>At this point, the <b>run</b> method terminates causing the <b>Toggler</b> 
thread to die.</p>
<p><font color="#FF0000"><b>The Thread class named Worker</b></font></p>
<p>Listing 21 shows the beginning of the final <b>Thread</b> class that I will 
discuss in this MIDlet program.</p>
<p><b><a name="Listing_21">Listing 21</a>. The Thread class named Worker. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table44">
	<tbody>
		<tr>
			<td>
			<pre>  class <b>Worker</b> extends Thread{
    boolean paused;//true indicates paused
    boolean kill;//true means time to die
    long shortSleep = 500;//one-half second
    long longSleep = 25000000;//6.94 hours
    long sleepTime = shortSleep;

    Worker(boolean paused,boolean kill){//constructor
      this.paused = paused;
      this.kill = kill;
    }//end constructor</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>The purpose of a Worker object</b></font></p>
<p>This class is also a member class.&nbsp; The purpose of an object of this class is to do some work while the 
MIDlet is in the active state and to sleep while the MIDlet is in the paused state.&nbsp; 
</p>
<p>The work that gets done is to display some period characters on the standard 
output device.&nbsp; Although this isn't very sophisticated work, it is work 
nonetheless.</p>
<p>The <b>Worker</b> object also sleeps some of the time while the MIDlet is in the active state to avoid consuming 
computer resources.</p>
<p><font color="#FF0000"><b>Declare and initialize some instance variables</b></font></p>
<p>The <b>Worker</b> class begins by declaring and in some cases initializing 
some instance variables that are used as working variables.&nbsp; The initial 
values for two of those variables are received as incoming parameters to the 
constructor.&nbsp; The need for these variables should become clear once I begin 
explaining the code.</p>
<p>If you look back at Listing 11, you will see that the <b>paused</b> variable 
in Listing 21 is initialized to true by the constructor and the <b>kill</b> 
variable in Listing 21 is initialized to false by the constructor.</p>
<p><font color="#FF0000"><b>The beginning of the run method for the Worker class</b></font></p>
<p>Listing 22 shows the beginning of the <b>run</b> method for the class named
<b>Worker</b>.</p>
<p><b><a name="Listing_22">Listing 22</a>. The beginning of the run method for the 
Worker class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table45">
	<tbody>
		<tr>
			<td>
			<pre>    public void <b>run</b>(){
      System.out.print("I'm working ");
      while(true){
        //Check the kill flag and behave appropriately.
        if(kill){
          System.out.println("Terminating worker");
          //This break will cause the thread to break out
          // of the while loop and to die.
          break;
        }//end if</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>run</b> method displays a message telling us that it is working.&nbsp; 
Then it enters an infinite loop.</p>
<p><font color="#FF0000"><b>Is it time to die?</b></font></p>
<p>Once inside the infinite loop, it immediately checks the value of the <b>kill</b> 
flag to see if it is time to die.&nbsp; If so, it displays a message to that 
effect and breaks out of the infinite <b>while</b> loop.</p>
<p>As you will see later, when control exits the <b>while</b> loop, the <b>run</b> 
method terminates and the <b>Worker</b> thread dies.</p>
<p><font color="#FF0000"><b>When the kill flag is false...</b></font></p>
<p>If the <b>kill</b> flag is false, the code in Listing 23 is executed.</p>
<p><b><a name="Listing_23">Listing 23</a>. When the kill flag is false. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table46">
	<tbody>
		<tr>
			<td>
			<pre>        //Check the paused flag and behave appropriately.
        if(!paused){
          //Do some work and then go to sleep for a short
          // time period.  The thread will sleep until it
          // awakes normally or until it is interrupted.
          System.out.print(".");
          sleepTime = shortSleep;
        }else{
          //The main thread is in the paused state.  Go
          // to sleep for a very long time.
          sleepTime = longSleep;
        }//end else</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Listing 23 checks the <b>paused</b> flag to see if the MIDlet is in the 
paused state.&nbsp; As mentioned above, the <b>paused</b> flag will be 
initialized to true when the <b>Worker</b> object is first constructed.&nbsp; It 
will first be changed to false when the <b>startApp</b> method is called by the 
AMS to put the MIDlet in the active state. <i>(See Listing 12.)</i></p>
<p><font color="#FF0000"><b>When the paused flag is true...</b></font></p>
<p>When the <b>paused</b> flag is true, the <b>else</b> clause in Listing 23 is 
executed, setting the<b> sleepTime </b>variable to the value of <b>longSleep</b>.&nbsp; This will ultimately cause the 
<b>Worker</b> thread to go to sleep for a 
very long time.&nbsp; As a practical matter, it will continue to sleep until it 
is awakened by the <b>startApp</b> method calling the <b>interrupt</b> method on 
the <b>Worker</b> object telling it to wake up and do some work.&nbsp; <i>(See 
Listing 13.)</i></p>
<p><font color="#FF0000"><b>When the paused flag is false...</b></font></p>
<p>When the <b>paused</b> flag is false, the <b>if</b> clause in Listing 23 will 
be executed.&nbsp; This causes the <b>Worker</b> object to display a period 
character on the standard output device, which is the work that this simple 
MIDlet is supposed to do.</p>
<p>Then the code in Listing 23 sets the<b> sleepTime </b>variable to the value 
of <b>shortSleep</b>.&nbsp; This will ultimately cause the <b>Worker</b> thread 
to go to sleep for a short time period before it wakes up and does some more 
work.</p>
<p><font color="#FF0000"><b>The Worker thread goes to sleep</b></font></p>
<p>The code in Listing 24 causes the <b>Worker</b> thread to go to sleep for a 
time period specified by the current value of <b>sleepTime</b>.&nbsp; As you can 
see in Listing 21, that period will be either one-half second, or 6.94 hours, 
depending on whether the value of <b>shortSleep</b> or the value of <b>longSleep</b> 
was assigned to <b>sleepTime</b> earlier.</p>
<p><b><a name="Listing_24">Listing 24</a>. The Worker thread goes to sleep. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table47">
	<tbody>
		<tr>
			<td>
			<pre>        try{
          Thread.currentThread().sleep(sleepTime);
        }catch(InterruptedException e){
          System.out.print(&quot;I'm awake &quot;);
        }//end catch

      }//end while loop

      //This thread will die at this point.
    }//end run
  }//end class Worker
}//end class LifeCycle01</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Waking naturally</b></font></p>
<p>If the specified sleep time passes without another thread calling the <b>interrupt</b> method on the sleeping 
<b>Worker</b> thread, it will awake of its 
own accord.&nbsp; Control will transfer back to the top of the infinite <b>while</b> 
loop where it will test the values of the <b>kill</b> flag and the <b>paused</b> 
flag to decide what to do next.&nbsp; <i>(See Listing 22 and Listing 23.)</i></p>
<p><font color="#FF0000"><b>Being awakened by another thread</b></font></p>
<p>If another thread calls the <b>interrupt</b> method on the sleeping <b>Worker</b> 
thread, it will throw an <b>InterruptedException</b>.&nbsp; This will cause 
control to be transferred unconditionally to the body of the <b>catch</b> block 
in Listing 24.&nbsp; In that case, it will display an <i>&quot;I'm awake&quot;</i> 
message.&nbsp; Then control will exit the <b>catch</b> block and go back to the 
top of the infinite <b>while</b> loop where it will test the values of the <b>kill</b> flag and the 
<b>paused</b> flag to decide what to do next.&nbsp; </p>
<p>Once again, see Listing 22 and Listing 23.&nbsp; As explained earlier, if the
<b>kill</b> flag is true, control will break out of the infinite loop, the <b>run</b> 
method will terminate, and the <b>Worker</b> thread will die.</p>
<p>If both the <b>kill</b> flag and the <b>paused</b> flag are false, the <b>Worker</b> thread will display a single period character on the standard output 
device and go back to sleep for one-half second.</p>
<p>If the <b>kill </b>flag is false but the <b>paused</b> flag is true, the <b>Worker</b> thread will go to sleep for 6.94 hours.&nbsp; As a practical matter, 
it will probably sleep until it is awakened by another thread, but if that time 
passes and it wakes up naturally, it will check the <b>kill</b> flag and the <b>paused</b> flag and behave accordingly.</p>
<p><font color="#FF0000"><b>End of the run method, the Worker class, and the 
LifeCycle01 class</b></font></p>
<p>Listing 24 also signals the end of the <b>run</b> method, the <b>Worker</b> 
class, and the <b>LifeCycle01</b> class.&nbsp; It also signals the end of the 
explanation of the MIDlet named <b>LifeCycle01</b>.</p><center>
<h2><a name="Run the program"></a>Run the program</h2></center>
<p>I encourage you to copy the code from Listing 25 and Listing 26 and run it in 
the MIDlet development framework that I provided in the earlier lesson titled 
<i>Capturing Output Produced by Programs Running in a Child Process (see
<a href="#Resources">Resources</a>)</i>.</p>
<p>Experiment with the MIDlet code in conjunction with the framework program from the 
earlier lesson.&nbsp; Make some changes to the MIDlets and observe the results of your changes.</p>
<p>Don't forget that you will need to download and install the latest version of 
the Sun Java Wireless Toolkit for CLDC <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; As of the date this lesson is being written, the latest version of the toolkit is WTK2.5.2.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I began by explaining how the CLDC and the MIDP fit into the grand scheme of 
things in MIDlet programming.</p>
<p>Then I provided a simple example to show you how to change the behavior of a 
Java program by replacing the classes in the Java standard library with custom 
classes of your own design.</p>
<p>Then I presented and explained a MIDlet named <b>LifeCycle02</b> that 
demonstrates that the required behavior for each of the three states of a MIDlet 
is not enforced.&nbsp; The implication of the lack of enforcement is that it 
is the responsibility of the MIDlet programmer to make certain that the MIDlet 
follows the life-cycle rules.</p>
<p>Finally I presented and explained a MIDlet named <b>LifeCycle01</b> that 
illustrates one approach to writing MIDlet code that does play by the rules.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn:</p>
<ul>
	<li>The fundamentals of user interfaces for MIDlets.</li>
	<li>How to instantiate user interface components.</li>
	<li>How to cause user interface components to become visible on the cell 
	phone screen.</li>
	<li>The difference between a Screen and a Display.</li>
	<li>About restrictive constraints and modifier flags.</li>
	<li>About the MIDlet user interface class hierarchy.</li>
	<li>About the methods of the various classes that can be used to manipulate 
	user input and output.</li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/sjwtoolkit/download-2_5.html">Download</a> Sun Java Wireless Toolkit 2.5 for CLDC Release</li>
	<li><a href="http://en.wikipedia.org/wiki/MIDlet">MIDlet</a>: From 
	Wikipedia, the free encyclopedia</li>
	<li><a href="http://www.scmad.com/j2me-glossary1.php">MIDlet</a>: According 
	to SCMAD Certification Center</li>
	<li><a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html">J2ME 
	Tutorial, Part 1: Creating MIDlets</a> by Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step4">Pre-verifying</a> MIDlet code according to Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step7">Deploying</a> a MIDlet according to Vikram Goyal</li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/device/device;jsessionid=3F91C410E754F34B1A44DEBCE011ED18">The Java ME Device Table</a></span></li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/midp/ttips/getAppProperty/index.html">Retrieving MIDlet Attributes</a> by Richard Marejka</span></li>
	<li><a href="http://developers.sun.com/mobility/learn/midp/lifecycle/">Learning Path: MIDlet Life Cycle</a></li>
	<li><span class="style2">
	<a href="http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html?page=1">When Runtime.exec() won't</a> By 
	</span>Michael C. Daconta</li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration">Connected Limited Device Configuration</a>
	<i>(CLDC)</i> from <span class="style2">Wikipedia</span></li>
	<li><span class="style2">
	<a href="http://en.wikipedia.org/wiki/Mobile_Information_Device_Profile">Mobile Information Device Profile</a>
	<i>(MIDP)</i> from Wikipedia</span></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr030/">CLDC 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr139/">CLDC 1.1</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr037/">MIDP 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr118/">MIDP 2.0</a></li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3719111">2570</a> 
	Getting Started with MIDlets and the Sun Java Wireless Toolkit for CLDC</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3721706">2572</a> Capturing Output Produced by Programs Running in a Child Process</li>
</ul><center>
<h2><a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
<p>Complete listings of the life cycle programs discussed in this lesson are shown 
in Listing 25 and Listing 26 below.&nbsp; Listings of the shorter DateDemo programs 
are shown in Listing 2, Listing 3, and Listing 4.</p>
<p><b><a name="Listing_25">Listing 25</a>. The MIDlet named LifeCycle02. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tbody>
		<tr>
			<td>
			<pre>/*LifeCycle02.java
Copyright 2007, R.G.Baldwin
December 9, 2007

This MIDlet demonstrates that a MIDlet can continue to
execute code while in the paused state or in the
destroyed state in the Sun cell phone emulator.

During the time that the MIDlet is in the paused state,
the Sun cell phone emulator displays a box with the
following words on the cell phone screen:

Incoming Call ...

In addition, a red indicator shows in the middle of the
right-most soft key while the MIDlet is in the paused
state. Despite this, however, the MIDlet continues to
execute code and display text on the standard output
screen.

The MIDlet also continues to execute code and to display
output on the standard output screen after it enters the
destroyed state.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package LifeCycle02;

import javax.microedition.midlet.MIDlet;
import java.lang.Thread;
import java.util.Date;

public class LifeCycle02 extends MIDlet{

  long timeBase;
  boolean running = false;

  public LifeCycle02(){
    //Establish the time (in milliseconds relative to
    // Jan 1, 1970) that the MIDlet object is constructed.
    // This time will be used to compute the elapsed times
    // in milliseconds at which other events occur
    // relative to the construction time of the MIDlet.
    timeBase = new Date().getTime();
    System.out.println("Constructed at: "
                       + (new Date().getTime()-timeBase));
  }//end constructor

  //The following method is called by the AMS to change
  // the state of the MIDlet from paused to active.
  public void startApp(){

    System.out.println("startApp method called at: "
                       + (new Date().getTime()-timeBase));
    //Make the AMS believe that the MIDlet is paused
    pauseApp();
    //Now keep executing code.  Note that the Sun's cell
    // phone emulator displays an Incoming Call message on
    // its screen from this point until the MIDlet enters
    // the destroyed state.
    for(int cnt = 0;cnt &lt; 5;cnt++){
      try{Thread.currentThread().sleep(1000);
      }catch(InterruptedException e){}
      System.out.println("Time is: "
                       + (new Date().getTime()-timeBase));
    }//end for loop

    //Destroy the MIDlet.
    destroyApp(true);
    
    //Try to execute some more code.
    for(int cnt = 0;cnt &lt; 5;cnt++){
      try{Thread.currentThread().sleep(1000);
      }catch(InterruptedException e){}
      System.out.println("Time is: "
                       + (new Date().getTime()-timeBase));
    }//end for loop
    
  }//end startApp
  //----------------------------------------------------//

  public void pauseApp(){
    notifyPaused();
    System.out.println("\npauseApp method called at: "
                       + (new Date().getTime()-timeBase));
  }//end pauseApp
  //----------------------------------------------------//

  public void destroyApp(boolean unconditional){
    notifyDestroyed();
    System.out.println("destroyApp method called at:  "
                       + (new Date().getTime()-timeBase));
  }//end destroyApp
  //----------------------------------------------------//

}//end class LifeCycle02
//======================================================//</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>&nbsp;</p>
<p><b><a name="Listing_26">Listing 26</a>. The MIDlet program named LifeCycle01. 
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tbody>
		<tr>
			<td>
			<pre>/*LifeCycle01.java
Copyright 2007, R.G.Baldwin
December 9, 2007

The purpose of this MIDlet is to demonstrate the following
three states in which a MIDlet can reside:
paused
active
destroyed

This MIDlet is comprised of three threads.  One thread is
the main MIDlet thread.

A second thread is instantiated from a class named
Toggler. This thread is spawned and run to toggle the
MIDlet between the active and paused states at
approximately two-second intervals. After approximately
twenty seconds, the Toggler instructs the MIDlet to enter
the destroyed state.

A third thread is instantiated from a class named Worker.
This thread is spawned and run to do some work while the
MIDlet is in the active state.  The work that it does is
to display a period on the standard output device
approximately once every half second.  This thread sleeps
while the MIDlet is in the paused state, and dies when the
MIDlet enters the destroyed state. (It also sleeps some of
the time that the MIDlet is in the active state to avoid
consuming excessive computational resources.)

During those time intervals that the MIDlet is in the
paused state, the Sun cell phone emulator displays a
box with the following words on the cell phone screen:

Incoming Call ...

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package LifeCycle01;

import javax.microedition.midlet.MIDlet;
import java.lang.Thread;
import java.util.Date;

public class LifeCycle01 extends MIDlet{

  Toggler theToggler;
  Worker theWorker;
  long timeBase;
  boolean running = false;

  public LifeCycle01(){
    theToggler = new Toggler(this);
    theWorker = new Worker(true,false);
    //Establish the time (in milliseconds relative to
    // Jan 1, 1970) that the MIDlet object is constructed.
    // This time will be used to compute the elapsed times
    // in milliseconds at which other events occur
    // relative to the construction time of the MIDlet.
    timeBase = new Date().getTime();
    System.out.println("Constructed at: "
                       + (new Date().getTime()-timeBase));
  }//end constructor

  //The following method is called by the AMS to change
  // the state of the MIDlet from paused to active.
  public void startApp(){
    if(!running){
      //This is the first time that this method has been
      // called.
      System.out.println("Started at: "
                       + (new Date().getTime()-timeBase));
      running = true;
      //Start the Toggler thread running.
      theToggler.start();
      //Start the worker thread running in an active
      // (not-paused) MIDlet state.
      theWorker.paused = false;
      theWorker.start();
    }else{
      //This is not the first time that this method has
      // been called.
      System.out.println("Re-started at: "
                       + (new Date().getTime()-timeBase));
      //Wake the Worker thread up if it is asleep. Set
      // the paused flag to false to tell the worker to
      // get to work.
      theWorker.paused = false;
      theWorker.interrupt();
    }//end else
  }//end startApp

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the paused state. It may also be
  // called by the AMS.
  public void pauseApp(){
    System.out.println("\nPaused at: "
                       + (new Date().getTime()-timeBase));
    //Tell Worker to go to sleep for a long time the next
    // time it checks the paused flag.
    theWorker.paused = true;
    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the destroyed state. It may also
  // be called by the AMS.
  public void destroyApp(boolean unconditional){
    //Tell the Worker to terminate the next time it checks
    // its flags.
    theWorker.kill = true;
    //Wake the worker up if it is asleep.
    theWorker.interrupt();
    System.out.println("Destroyed at:  "
                       + (new Date().getTime()-timeBase));
    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp

  public void resume(){
    resumeRequest();
  }//end resume
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to cause the main thread to toggle
  // between the active state and the paused state every
  // two seconds during a total of ten cycles.  Then it
  // causes the main thread to enter the destroyed state.
  class Toggler extends Thread{
    LifeCycle01 theMIDlet;

    Toggler(LifeCycle01 theMIDlet){
      this.theMIDlet = theMIDlet;
    }//end constructor

    public void run(){
      for(int cnt = 0;cnt &lt; 10;cnt++){
        //Sleep for two seconds.
        try{Thread.currentThread().sleep(2000);
        }catch(Exception e){}

        if(cnt % 2 == 0){
          //Tell the main thread to enter the paused
          // state.
          theMIDlet.pauseApp();
        }else{
          //Cause the main thread to send a request to
          // the AMS to return it to the active
          // state.  If the request is honored, the
          // AMS will call the startApp method on the
          // main thread. Note in particular that this
          // code does not call the startApp method
          // directly.
          theMIDlet.resume();
        }//end else
      }//end for loop

      //Instruct the main thread to enter the destroyed
      // state.
      theMIDlet.destroyApp(true);

      //This thread will die at this point.
    }//end run
  }//end class Toggler
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to do some work (display periods)
  // while the main thread is in the active state and
  // to sleep while the main thread is in the paused
  // state.  It also sleeps some while the main thread
  // is in the active state to avoid consuming major
  // computational resources.
  class Worker extends Thread{
    boolean paused;//true indicates paused
    boolean kill;//true means time to die
    long shortSleep = 500;//one-half second
    long longSleep = 25000000;//6.94 hours
    long sleepTime = shortSleep;

    Worker(boolean paused,boolean kill){//constructor
      this.paused = paused;
      this.kill = kill;
    }//end constructor

    public void run(){
      System.out.print("I'm working ");
      while(true){
        //Check the kill flag and behave appropriately.
        if(kill){
          System.out.println("Terminating worker");
          //This break will cause the thread to break out
          // of the while loop and to die.
          break;
        }//end if

        //Check the paused flag and behave appropriately.
        if(!paused){
          //Do some work and then go to sleep for a short
          // time period.  The thread will sleep until it
          // awakes normally or until it is interrupted.
          System.out.print(".");
          sleepTime = shortSleep;
        }else{
          //The main thread is in the paused state.  Go
          // to sleep for a very long time.
          sleepTime = longSleep;
        }//end else

        try{
          Thread.currentThread().sleep(sleepTime);
        }catch(InterruptedException e){
          //Control reaches here when another thread calls
          // the interrupt() method on this thread while
          // it is sleeping.  Loop back to the top and
          // either terminate or do some work depending
          // on the state of the flags.  If the thread
          // wakes up on its own accord, this code will
          // not be executed.
          System.out.print("I'm awake ");
        }//end catch

      }//end while loop

      //This thread will die at this point.
    }//end run
  }//end class Worker
  //====================================================//

}//end class LifeCycle01
//======================================================//</pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>&nbsp;</p>
<p></p><hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<p><b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>
</p>
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>java J2ME MIDlet &quot;cell phone emulator&quot; &quot;wireless toolkit&quot; 
WTK MIDP CLDC &quot;MIDlet life cycle&quot;</p>
<p>-end- </p>
<p><br>&nbsp; </p>
<p><br><br><br><br></p>
</body>
</html>
