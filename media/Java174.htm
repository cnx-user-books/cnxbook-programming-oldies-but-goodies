<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->The AWT Package, Graphics - Overview of Advanced Image Processing Capabilities<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 174, Revised 11/30/97.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#imageproducer interface">ImageProducer Interface</a></li>

<li><a href="#imageconsumer interface">ImageConsumer Interface</a></li>

<li><a href="#imageobserver interface">ImageObserver Interface</a></li>

<li><a href="#colormodel class">ColorModel Class</a></li>

<ul><li><a href="#indexcolormodel class">IndexColorModel Class</a></li>

<li><a href="#directcolormodel class">DirectColorModel Class</a></li></ul>

<li><a href="#filteredimagesource class">FilteredImageSource Class</a></li>

<li><a href="#imagefilter class">ImageFilter Class</a></li>

<ul><li><a href="#rgbimagefilter class">RGBImageFilter Class</a></li>

<li><a href="#cropimagefilter class">CropImageFilter Class</a></li>

<li><a href="#replicatescalefilter class">ReplicateScaleFilter Class</a></li>

<ul><li><a href="#areaaveragingscalefilter class">AreaAveragingScaleFilter Class</a></li></ul></ul>

<li><a href="#memoryimagesource class">MemoryImageSource Class</a></li>

<li><a href="#pixelgrabber class class">PixelGrabber Class</a></li>

<li><a href="#sample program">Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#program listing">Program Listing</a></li></ul></ul>

<hr width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b>Advanced Java Programming</b> classes at
ACC are responsible for knowing and understanding all of the material in
this lesson.

<p>The material in this lesson is extremely important. However, there is
simply too much material to be covered in detail during lecture periods.
Therefore, students in Prof. Baldwin's <b>Advanced Java Programming</b>
classes at ACC will be responsible for studying this material on their
own, and bringing any questions regarding the material to class for discussion.

<p>This lesson was originally written on November 30, 1997 using the software
and documentation in the JDK 1.1.3 download package.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
Previous lessons have introduced you to many aspects of working with images
in Java. To an image-processing novice like myself, the advanced image
processing capabilities of Java are somewhat mind-boggling. It would seem
that a group of image-processing enthusiasts could easily spend an entire
semester digging into the many capabilities offered in this area.

<p>Of necessity then, this lesson will present a cursory overview of those
capabilities. For a more in-depth discussion, see the book entitled <u>Java
AWT Reference</u> by John Zukowski.

<p>Most of the advanced image processing capabilities of Java are in the
package named <b>java.awt.image</b>. Note that this is not the <b>Image</b>
class of the package named <b>java.awt</b>. This is another package containing
three interfaces and eleven classes.

<p>The three interfaces are:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><ul><li>
ImageConsumer&nbsp;</li>

<li>
ImageObserver&nbsp;</li>

<li>
ImageProducer&nbsp;</li></ul></td></tr></table>
The eleven classes in hierarchical arrangement are:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><menu><li>
Object</li>

<ul><li>
ColorModel&nbsp;</li>

<ul><li>
IndexColorModel&nbsp;</li>

<li>
DirectColorModel&nbsp;</li></ul>

<li>
FilteredImageSource&nbsp;</li>

<li>
ImageFilter&nbsp;</li>

<ul><li>
RGBImageFilter&nbsp;</li>

<li>
CropImageFilter&nbsp;</li>

<li>
ReplicateScaleFilter&nbsp;</li>

<ul><li>
AreaAveragingScaleFilter&nbsp;</li></ul></ul>

<li>
MemoryImageSource&nbsp;</li>

<li>
PixelGrabber&nbsp;</li></ul></menu></td></tr></table>
A brief discussion of each of the interfaces and each of the classes follows.
<center><h2><a name="imageproducer interface"></a><font color="#ff0000">ImageProducer
Interface</font></h2></center>
Classes that implement this interface serve as sources for pixel data.
The methods of such a class may generate the pixels from scratch, or may
interpret data from another source, such as a GIF file. No matter how it
generates the data, the primary purpose of an image producer is to deliver
pixels to an image consumer.

<p>Image producers operate somewhat like event sources, and the image producer/consumer
model is somewhat analogous to the event source/listener model.

<p>In particular, the methods declared in the <b>ImageProducer</b> interface
make it possible for one or more <b>ImageConsumer</b> objects to register
their interest in an image. The image producer then invokes methods declared
in the <b>ImageConsumer</b> interface to deliver the pixels to the image
consumers.

<p>Note that an image producer can register many consumers for its pixels
in much the same way that an event source can register many listeners for
its events. Several methods are declared in the <b>ImageProducer</b> interface,
including methods for adding interested consumers to a list of interested
consumers, and removing consumers from the list of interested consumers.

<p>Thus, in our analogy, the image <i>producer </i>is analogous to the
event <i>source</i>, and the image <i>consumers </i>are analogous to the
event <i>listeners</i>.
<center><h2><a name="imageconsumer interface"></a><font color="#ff0000">ImageConsumer
Interface</font></h2></center>
The <b>ImageConsumer</b> interface declares methods that must be implemented
by classes which are to receive data from an image producer.

<p>Several methods are declared in the <b>ImageConsumer</b> interface which
are used to support the delivery of pixels from the producer to the consumer.
The primary method used for delivery is
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>void <b>setPixels</b>(int <i>x</i>, int <i>y</i>, int <i>width</i>,
int <i>height</i>, ColorModel <i>model</i>, byte <i>pixels[]</i>, int <i>offset</i>,
int <i>scansize</i>)</td></tr></table>
The JDK 1.1.3 documentation provides the following explanation of some
of the parameters to this method.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>The pixels of the image are delivered using one or more calls to the
<b>setPixels </b>method. Each call specifies the location and size of the
rectangle of source pixels that are contained in the array of pixels. The
specified <b>ColorModel </b>object should be used to convert the pixels
into their corresponding color and alpha components.&nbsp;

<p>Pixel (m,n) is stored in the pixels array at index (n * scansize + m
+ offset). The pixels delivered using this method are all stored as bytes.&nbsp;</td></tr></table>

<center><h2><a name="imageobserver interface"></a><font color="#ff0000">ImageObserver
Interface</font></h2></center>
The <b>ImageObserver</b> interface was discussed in an earlier lesson and
therefore won't be discussed further in this lesson.
<center><h2><a name="colormodel class"></a><font color="#ff0000">ColorModel Class</font></h2></center>
Pictures on a computer screen are composed of individual dots. Each of
the dots is commonly referred to as a <i>pixel</i> which I believe is an
abbreviation for the term <i>Picture Element</i>.

<p>Depending on how you want to represent an image on the screen, a single
pixel can be required to contain a lot of information, or very little information.

<p>For example, if all you want to display is a series of lines all of
exactly the same color against a background of a different color, then
the only information that must be contained in an individual pixel is whether
it is turned on or off. In this case, only one bit of information is required
to represent a pixel.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>As an aside, an early use of the word <i>bit<b> </b></i>was in information
theory (Shannon and contemporaries) where one bit of information was deemed
to be that amount of information required to determine how an event would
fall if, lacking additional information, it had an equal probability of
falling in either of two ways. The word was then adopted by computer scientists
to represent the fundamental unit of information stored in a computer.</td></tr></table>
At the other extreme in the pixel data format arena is the format used
to represent a pixel in many modern computers where 32-bits are used to
represent an individual pixel.

<p>These 32 bits are commonly partitioned into four 8-bit groups or bytes.
Three of the bytes are used to represent the contribution of the primary
colors: <i>red</i>, <i>green</i>, and <i>blue</i>. The fourth byte (commonly
known as the <i>alpha </i>byte) is used to represent the degree of transparency
with a value of zero representing total transparency and a value of 255
representing total opacity.

<p>In theory, this format can ascribe some 16-million colors to an individual
pixel (but your monitor may not be capable of displaying that many individual
colors electronically).

<p>Each of these extreme cases could be considered to represent a color
model. In Java, a color model <u>determines how colors are represented
within the AWT</u>. The <b>ColorModel</b> class is an abstract class that
you can extend to specify your own representation for colors.

<p>The description of this class from the JDK 1.1.3 documentation reads
as follows:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>A class that encapsulates the methods for translating from pixel values
to alpha, red, green, and blue color components for an image. This class
is abstract.&nbsp;</td></tr></table>
So, why do we need a color model anyway?

<p>Because many of the methods that receive an array of bytes and convert
those bytes into actual pixels for rendering on the screen need to know
how to interpret the bytes in the array, i.e., how are the bytes to be
converted into visual pixels on the screen.

<p>For example, with a simple direct color model, each group of four bytes
would probably be interpreted as representing the color value of a single
pixel.

<p>For a simple indexed color model, each byte in the array would probably
be interpreted as an index into a table of 32-bit integers where each integer
represents the actual color to be ascribed to a pixel.

<p>For a crude display which requires only that each pixel be turned on
or off, one byte could represent eight pixels on the screen.

<p>The AWT provides two subclasses of the <b>ColorModel</b> class: <b>IndexedColorModel</b>
and <b>DirectColorModel</b>. You can also define your own subclasses if
you have a mind to.
<center><h3><a name="indexcolormodel class"></a><font color="#ff0000">IndexColorModel
Class</font></h3></center>
You can consume a lot of memory by creating high-resolution images with
lots of colors. For example, a 1024 x 768 display contains 786,432 individual
pixels. If you represent each of those pixels with four bytes of memory,
you will consume 3,145,728 bytes of memory for only one image.

<p>It doesn't take very many images like this to consume more memory than
you may have available.

<p>As a result, various schemes have evolved over the years to make it
possible to represent images in a reasonable fashion using far less memory
to represent each individual image.

<p>A very common scheme is to allocate a smaller number of bits to each
pixel (8 bits for example) and to use the pixel values as an index into
a table containing the 32-bit representations for some subset of all the
possible colors.

<p>For example, if eight bits are used to represent an individual pixel,
the pixel value can be used to index into a table containing 256 actual
colors. These 256 colors can be selected beforehand, and are often referred
to as a palette.

<p>Given the same 1024 x 768 display, this scheme would require 1024 bytes
to represent the palette of 256 colors, and 786,432 bytes to represent
an image. If there are many images involved, this may be a more paractical
approach than representing every pixel by four bytes.

<p>According to the book <u>Java AWT Reference</u> by John Zukowski, in
his discussion of the <b>IndexColorModel</b>, the says:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"... specifies a <b>ColorModel</b> that uses a color map lookup table
(with a maximum size of 256), rather than storing color information in
the pixels themselves. Pixels are represented by an index into the color
map, which is at most an 8-bit quantity. Each entry in the color map gives
the alpha, red, green, and blue components of some color. One entry in
the map can be designated "transparent." This is called the "transparent"
pixel"; the alpha compnent of this map entry is ignored."</td></tr></table>
The explanation of the same thing in the JDK 1.1.3 documentation reads
as follows:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>A <b>ColorModel </b>class that specifies a translation from pixel values
to alpha, red, green, and blue color components for pixels which represent
indices into a fixed colormap. An optional transparent pixel value can
be supplied which indicates a completely transparent pixel, regardless
of any alpha value recorded for that pixel value.&nbsp;</td></tr></table>

<center><h3><a name="directcolormodel class"></a><font color="#ff0000">DirectColorModel
Class</font></h3></center>
This class implements the full 32-bit color format in which each pixel
consists of four bytes, representing <i>alpha</i>, <i>red</i>, <i>green</i>,
and <i>blue</i>. The description in the JDK 1.1.3 documentation reads as
follows:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>A <b>ColorModel </b>class that specifies a translation from pixel values
to alpha, red, green, and blue color components for pixels which have the
color components embedded directly in the bits of the pixel itself.&nbsp;</td></tr></table>
John Zukowski provides the following description of the <b>DirectColorModel</b>
class:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"... specifies a color model in which each pixel contains all the color
information (alpha, red, green, and blue values) explicitly. Pixels are
represented by 32-bit (int) quantities; the constructor lets you change
which bits are allotted to each component."</td></tr></table>

<center><h2><a name="filteredimagesource class"></a><font color="#ff0000">FilteredImageSource
Class</font></h2></center>
Here is what the JDK 1.1.3 documentation has to say about this class:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>This class is an implementation of the <b>ImageProducer </b>interface
which takes an existing image and a filter object and uses them to produce
image data for a new filtered version of the original image.&nbsp;</td></tr></table>
The constructor for this class requires two parameters:
<ul><li>
a source image of type <b>ImageProducer</b> and</li>

<li>
a filter object of type <b>ImageFilter</b>.</li></ul>
It constructs an object of type <b>ImageProducer</b> which is the result
of applying the filter object to the original source image object. The
filter can perform a variety of operations such as color shifting, image
rotation, cropping, etc.

<p>The methods of the class are generally the methods declared in the <b>ImageProducer</b>
interface.
<center><h2><a name="imagefilter class"></a><font color="#ff0000">ImageFilter Class</font></h2></center>
According to the JDK 1.1.3 documentation:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>This class implements a filter for the set of interface methods that
are used to deliver data from an <b>ImageProducer </b>to an <b>ImageConsumer</b>.
It is meant to be used in conjunction with a <b>FilteredImageSource </b>object
to produce filtered versions of existing images.&nbsp;

<p>It is a base class that provides the calls needed to implement a "Null
filter" which has no effect on the data being passed through. Filters should
subclass this class and override the methods which deal with the data that
needs to be filtered and modify it as necessary.&nbsp;</td></tr></table>
This class implements the <b>ImageConsumer</b> interface. There are a number
of methods defined in this class, including those declared in the interface,
and those that are used to implement the "null filter" capability described
above.

<p>There is only one constructor and it takes no parameters.

<p>To review, this class extends <b>Object</b> and is subclassed as shown
in the following hierarchy diagram from the JDK 1.1.3 AWT.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><menu><li>
ImageFilter&nbsp;</li>

<ul><li>
RGBImageFilter&nbsp;</li>

<li>
CropImageFilter&nbsp;</li>

<li>
ReplicateScaleFilter&nbsp;</li>

<ul><li>
AreaAveragingScaleFilter&nbsp;</li></ul></ul></menu></td></tr></table>
In practice, objects of this class and its subclasses are instantiated
to be passed as one of the two parameters to the constructor of a <b>FilteredInputSource</b>
object, where it is combined with a source image object to produce a new
filtered image object.

<p>The <b>FilteredInputSource</b> object that is produced can become the
source image object for another image consumer.
<center><h3><a name="rgbimagefilter class"></a><font color="#ff0000">RGBImageFilter
Class</font></h3></center>
The JDK 1.1.3 documentation describes this class as follows:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>This class provides an easy way to create an <b>ImageFilter </b>which
modifies the pixels of an image in the default <b>RGB </b>ColorModel. It
is meant to be used in conjunction with a <b>FilteredImageSource </b>object
to produce filtered versions of existing images.&nbsp;

<p>It is an abstract class that provides the calls needed to channel all
of the pixel data through a single method which converts pixels one at
a time in the default <b>RGB </b><i>ColorModel </i>regardless of the <b>ColorModel
</b>being used by the <b>ImageProducer</b>.&nbsp;

<p>The only method which needs to be defined to create a useable image
filter is the <b>filterRGB </b>method.</td></tr></table>

<center><h3><a name="cropimagefilter class"></a><font color="#ff0000">CropImageFilter
Class</font></h3></center>
The JDK 1.1.3 documentation describes this class as:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>An <b>ImageFilter </b>class for cropping images. This class extends
the basic <b>ImageFilter </b>Class to extract a given rectangular region
of an existing <b>Image </b>and provide a source for a new image containing
just the extracted region. It is meant to be used in conjunction with a
<b>FilteredImageSource </b>object to produce cropped versions of existing
images.&nbsp;</td></tr></table>

<center><h3><a name="replicatescalefilter class"></a><font color="#ff0000">ReplicateScaleFilter
Class</font></h3></center>
According to the JDK 1.1.3 documentation, this class is:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>An <b>ImageFilter </b>class for scaling images using the simplest algorithm.
This class extends the basic <b>ImageFilter </b>Class to scale an existing
image and provide a source for a new image containing the resampled image.&nbsp;

<p>The pixels in the source image are sampled to produce pixels for an
image of the specified size by replicating rows and columns of pixels to
scale up or omitting rows and columns of pixels to scale down. It is meant
to be used in conjunction with a <b>FilteredImageSource </b>object to produce
scaled versions of existing images.&nbsp;</td></tr></table>

<center><h4><a name="areaaveragingscalefilter class"></a><font color="#ff0000">AreaAveragingScaleFilter
Class</font></h4></center>
The following description of this class was taken from the JDK 1.1.3 documentation:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>An <b>ImageFilter </b>class for scaling images using a simple area
averaging algorithm that produces smoother results than the nearest neighbor
algorithm.&nbsp;

<p>This class extends the basic <b>ImageFilter </b>Class to scale an existing
image and provide a source for a new image containing the resampled image.
The pixels in the source image are blended to produce pixels for an image
of the specified size. The blending process is analogous to scaling up
the source image to a multiple of the destination size using pixel replication
and then scaling it back down to the destination size by simply averaging
all the pixels in the supersized image that fall within a given pixel of
the destination image.&nbsp;</td></tr></table>

<center><h2><a name="memoryimagesource class"></a><font color="#ff0000">MemoryImageSource
Class</font></h2></center>
The following brief description of this class is from the JDK 1.1.3 documentation.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>This class is an implementation of the <b>ImageProducer </b>interface
which uses an array to produce pixel values for an <b>Image</b>.&nbsp;</td></tr></table>
There are six different constructors, each of which requires some or all
of the following parameters:
<ul><li>
Width and height in pixels of the image being created,</li>

<li>
Color model to be used in the conversion (two of the constructors don't
require this and default to the <b>RGB </b>color model),</li>

<li>
An array of bytes or integers containing the values to be converted to
pixels in accordance with the color model,</li>

<li>
An offset specifying the first pixel used in the array,</li>

<li>
The number of pixels per scan line in the array which may be larger than
the number of pixels in the actual scan line in the image, resulting in
some of the data in the array being ignored,</li>

<li><b>A Hashtable</b> object containing the properties associated with the
image, if any.</li></ul>
In all cases, the constructor constructs an <b>ImageProducer </b>object
which uses an array of bytes or integers to produce data for an <b>Image
</b>object.

<p>This class implements the <b>ImageProducer</b> interface and as such
defines all of the methods of that interface. Several other methods are
defined as well.

<p>Also according to the JDK 1.1.3 documentation:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>The MemoryImageSource is also capable of managing a memory image which
varies over time to allow animation or custom rendering.&nbsp;</td></tr></table>
According to Zukowski, in JDK 1.1.x, <b>MemoryImageSource</b> can now pass
multiple frames to interested consumers, and mimics <b>GIF89A</b> multiframe
functionality to produce animation. Zukowski provides an example of this
feature in his book <u>Java AWT Reference</u>.
<center><h2><a name="pixelgrabber class class"></a><font color="#ff0000">PixelGrabber
Class</font></h2></center>
The <b>PixelGrabber</b> class is a utility for converting an image into
an array of pixel values. The description of the class, according to the
JDK 1.1.3 documentation is:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>The <b>PixelGrabber </b>class implements an <b>ImageConsumer </b>which
can be attached to an <b>Image </b>or <b>ImageProducer </b>object to retrieve
a subset of the pixels in that image.&nbsp;</td></tr></table>
This class has three constructors which require different parameters to
control how the object is constructed.

<p>Two of the constructors require you to pass an array of <b>int</b> which
is where the numeric values of the pixels will be stored.

<p>The third constructor doesn't require the array as a parameter. In this
case, you invoke the <b>getPixel()</b> method on the <b>PixelGrabber</b>
object to get the buffer where the resulting data is stored.

<p>This class implements the <b>ImageConsumer</b> interface. Hence, it
defines the methods of that interface as well as other methods which determine
its behavior.
<center><h2><a name="sample program"></a><font color="#ff0000">Sample Program</font></h2></center>
As I mentioned early in this lesson, the image-processing capabilities
of Java are extensive. Thus, many different sample programs would be required
to illustrate all of the features.

<p>We won't attempt to illustrate all the features in this lesson. Rather,
we will provide a simple program that illustrates a few of the features
in hopes that you can use that as a jumping off place to investigate the
other features on your own.

<p>This program illustrates image manipulation by removing the red color
from all the pixels in an image and also making the image partially transparent.

<p>The program requires access to an image file named <b>"logomain.gif"</b>
in the current directory on the hard disk.

<p>Just about any image should do, but it needs to be large enough that
you can see it when it is displayed at its normal size and should be small
enough to fit on the screen.

<p>If the program is unable to load the image file within ten seconds,
it will abort with an error message. You can easily modify the source code
to change the name of the image file and change the timeout interval if
you wish to do so.

<p>A large portion of the code in this program has been illustrated in
previous lessons and won't be discussed in this lesson. The following discussion
primarily involves material that has not been covered in a previous lesson.

<p>This program reads an image file from the disk and saves it in memory
under the name <b>rawImage</b>.

<p>Then it declares an array of int of sufficient size to contain one int
value for every pixel in the image. The name of the array is <b>pix</b>.

<p>Then it instantiates an object of type <b>PixelGrabber </b>which associates
the <b>rawImage </b>with the array of int named <b>pix</b>.

<p>Following this, it invokes the <b>grabPixels()</b> method on the object
of type <b>PixelGrabber </b>to cause the pixels in the <b>rawImage </b>to
be converted to numeric values of type <b>int</b> and stored in the array
named <b>pix</b>.

<p>Then it uses bitwise operators to mask the <i>red </i>byte out of every
pixel value and to make the image partially transparent by masking the
<i>alpha </i>byte with the hex value <b>C0 </b>(an alpha value of <b>00
</b>is completely transparent, and an alpha value of <b>FF </b>is completely
opaque).

<p>Then it uses the <b>createImage()</b> method of the <b>Component </b>class
along with the constructor for the <b>MemoryImageSource</b> class to create
a new image from the modified pixel data. The name of the new image is
<b>modImage</b>.

<p>Finally, it overrides the <b>paint()</b> method where it uses the <b>drawImage()</b>
method to display both the raw image and the modified image on the same
<b>Frame </b>object for comparison.

<p>The colors in the modified image should <u>reflect the lack of red</u>
(assuming they contained red in the first place).

<p>Also the modified image is <u>partially transparent</u>, allowing the
yellow background to show through on many pixels.

<p>On a Win95 system. transparency seems to be accomplished by causing
a regular distribution of pixels to be rendered in the background color.
The higher the degree of transparency, the larger the percentage of pixels
that are rendered in the background color.

<p>This program was tested using JDK 1.1.3 under Win95.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
The first interesting code fragment is the statement in the constructor
that gets an image from a specified file. We have seen this before, but
it is being repeated here for review purposes.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; rawImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().<b>getImage</b>("logomain.gif");</pre></td></tr></table>
Follwing this, we use the <b>MediaTracker </b>class to track the loading
of the image file, etc., but you have seen all of that before. After doing
some things with height, width, etc., we get down to the topic that is
being illustrated in this lesson.

<p>We declare an array object of type <b>int</b> to receive the numeric
representation of all the pixels in the image.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; int[] pix = new int[rawWidth * rawHeight];</pre></td></tr></table>
Then we instantiate an object of type <b>PixelGrabber</b> that deals with
some size information, and associates our <b>rawImage</b> object with the
array named <b>pix</b> where we will deposit the numeric values for the
pixels. This is accomplished with the following statement. You are referred
to the JDK 1.1.3 documentation for an explanation of all the parameters
to the constructor.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PixelGrabber pgObj = new <b>PixelGrabber</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>rawImage</b>,0,0,rawWidth,rawHeight,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>pix</b>,0,rawWidth);</pre></td></tr></table>
Once we have the <b>PixelGrabber</b> object, we invoke the <b>grabPixels()</b>
method on that object to <u>perform the actual conversion</u> of the pixels
in the image to numeric form.

<p>A more detailed description of this method is definitely worth seeing.
The following description was extracted from the JDK 1.1.3 documentation.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>public boolean <b>grabPixels</b>() throws InterruptedException&nbsp;

<p>Request the <b>Image </b>or <b>ImageProducer </b>to start delivering
pixels and wait for all of the pixels in the rectangle of interest to be
delivered.&nbsp;

<p>Returns: <b>true </b>if the pixels were successfully grabbed, <b>false
</b>on abort, error or timeout&nbsp;

<p>Throws: InterruptedException Another thread has interrupted this thread.&nbsp;</td></tr></table>
We also invoked the <b>getStatus() </b>method to check the status of the
operation. A description of that method follows.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>public synchronized int <b>getStatus</b>()&nbsp;

<p>Return the status of the pixels. The <b>ImageObserver </b><i>flags </i>representing
the available pixel information are returned.&nbsp;

<p>Returns: the bitwise OR of all relevant <b>ImageObserver </b>flags&nbsp;</td></tr></table>
To make much sense out of this, we need information about the <b>ImageObserver</b><i>flags</i>. A description of the <b>ImageObserver</b> flags follows.
We will make use of the <b>ALLBITS</b> flag in our program.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><dt><b>ABORT</b> - An image which was being tracked asynchronously was aborted
before production was complete.&nbsp;</dt>

<dt><b>ALLBITS</b> - A static image which was previously drawn is now complete
and can be drawn again in its final form.&nbsp;</dt>

<dt><b>ERROR</b> - An image which was being tracked asynchronously has encountered
an error.&nbsp;</dt>

<dt><b>FRAMEBITS</b> - Another complete frame of a multi-frame image which
was previously drawn is now available to be drawn again.&nbsp;</dt>

<dt><b>HEIGHT</b> - The height of the base image is now available and can be
taken from the height argument to the imageUpdate callback method.&nbsp;</dt>

<dt><b>PROPERTIES</b> - The properties of the image are now available.&nbsp;</dt>

<dt><b>SOMEBITS</b> - More pixels needed for drawing a scaled variation of
the image are available.&nbsp;</dt>

<dt><b>WIDTH</b> - The width of the base image is now available and can be
taken from the width argument to the imageUpdate callback method.&nbsp;</dt></td></tr></table>
The statement in our sample program that invokes the <b>grabPixels()</b>
and <b>getStatus()</b> methods is shown below.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pgObj.<b>grabPixels</b>() &amp;&amp; ((pgObj.<b>getStatus</b>() &amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageObserver.<b>ALLBITS</b>) != 0)){</pre></td></tr></table>
If the above statement returns <b>true</b>, the next step is to process
the numeric pixel values to produce the desired modification of the image.
(When examining the above statement, pay close attention to the difference
between the use of logical <b>&amp;&amp;</b> and bitwise <b>&amp;</b>.)

<p>Once we have the pixel data in numeric <b>int </b>form (alpha, red,
green, blue bytes) it is a simple matter to use a <b>for</b> loop and a
bitwise <b>AND</b> operation to mask out the <i>red </i>byte and to modify
the <i>alpha </i>byte. To accomplish this, we <b>AND</b> the <i>red </i>byte
with hex <b>00</b> and <b>AND</b> the <i>alpha </i>byte with hex <b>C0</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; (rawWidth*rawHeight);cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pix[cnt] = pix[cnt] &amp; 0xC000FFFF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop&nbsp;</pre></td></tr></table>
The next step is to use the <b>createImage()</b> method of the <b>Component</b>
class to create an image from the numeric array.

<p>To accomplish this, we need to instantiate an object of the <b>MemoryImageSource</b>
class describing the manner in which we want to convert the array of numeric
data to an image and pass that object to the <b>createImage()</b> method.
(See the JDK 1.1 documentation for a description of the parameters to the
<b>MemoryImageSource</b> constructor.) You will probably recognize most
of those parameters from their names.

<p>The following code creates the desired <b>Image </b>object and names
it <b>modImage</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; modImage = this.createImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MemoryImageSource(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rawWidth,rawHeight,pix,0,rawWidth));&nbsp;</pre></td></tr></table>
Finally, we override the <b>paint()</b> method to display both the raw
image and the modified image, one above the other on the same <b>Frame</b>
object for comparison.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(rawImage,inLeft,inTop,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(modImage,inLeft,inTop+rawHeight,this);&nbsp;</pre></td></tr></table>
A complete listing of the program is provided in the next section.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
Some of the interesting code fragments are highlighted in <b>boldface</b>
in the following program listing. A description of the program was provided
in an earlier section.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Image05.java
Copyright 1997, R.G.Baldwin

This program illustrates image manipulation by removing
the red color from all the pixels in an image and also
making the image partially transparent.

The program requires access to an image file named
"logomain.gif" in the current directory on the hard disk.

If the program is unable to load the image file within ten
seconds, it will abort with an error message.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;

class Image05 extends Frame{ //controlling class
&nbsp; Image rawImage;//ref to raw image file fetched from disk
&nbsp; int rawWidth;
&nbsp; int rawHeight;

&nbsp; Image modImage; //ref to modified image
&nbsp;&nbsp;
&nbsp; //Inset values for the container object
&nbsp; int inTop;
&nbsp; int inLeft;
&nbsp;&nbsp;
&nbsp; //=====================================================//

&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; Image05 obj = new Image05();//instantiate this object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.repaint();//render the image
&nbsp;&nbsp; }//end main

&nbsp; //=====================================================//
&nbsp;&nbsp;
&nbsp; public Image05(){//constructor
&nbsp;&nbsp;&nbsp; //Get an image from the specified file in the current
&nbsp;&nbsp;&nbsp; // directory on the local hard disk.
&nbsp;&nbsp;&nbsp; rawImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().<b>getImage</b>("logomain.gif");
&nbsp;
&nbsp;&nbsp;&nbsp; //Use a MediaTracker object to block until the image
&nbsp;&nbsp;&nbsp; // is loaded or ten seconds has elapsed.
&nbsp;&nbsp;&nbsp; MediaTracker tracker = new MediaTracker(this);
&nbsp;&nbsp;&nbsp; tracker.addImage(rawImage,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{ //because waitForID throws InterruptedException
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!tracker.waitForID(1,10000)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Load error.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Raw image has been loaded.&nbsp; Establish width and&nbsp;
&nbsp;&nbsp;&nbsp; // height of the raw image.
&nbsp;&nbsp;&nbsp; rawWidth = rawImage.getWidth(this);
&nbsp;&nbsp;&nbsp; rawHeight = rawImage.getHeight(this);

&nbsp;&nbsp;&nbsp; this.setVisible(true);//make the Frame visible
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and store inset data for the Frame object so&nbsp;
&nbsp;&nbsp;&nbsp; // that it can be easily avoided.
&nbsp;&nbsp;&nbsp; inTop = this.getInsets().top;
&nbsp;&nbsp;&nbsp; inLeft = this.getInsets().left;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the insets and the size of the raw image to
&nbsp;&nbsp;&nbsp; // establish the overall size of the Frame object.
&nbsp;&nbsp;&nbsp; // Make the Frame object twice the height of the
&nbsp;&nbsp;&nbsp; // image so that the raw image and the modified image
&nbsp;&nbsp;&nbsp; // can both be rendered on the Frame object.
&nbsp;&nbsp;&nbsp; this.setSize(inLeft+rawWidth,inTop+2*rawHeight);
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, Baldwin");
&nbsp;&nbsp;&nbsp; this.setBackground(Color.yellow);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Declare an array object to receive the pixel&nbsp;
&nbsp;&nbsp;&nbsp; // representation of the image
&nbsp;&nbsp;&nbsp; <b>int[] pix = new int[rawWidth * rawHeight];

</b>&nbsp;&nbsp;&nbsp; //Convert the rawImage to numeric pixel representation
&nbsp;&nbsp;&nbsp; try{//because grapPixels() throws InterruptedException
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a PixelGrabber object specifying
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pix as the array in which to put the numeric&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pixel data. See JDK 1.1.3 docs for parameters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PixelGrabber pgObj = new <b>PixelGrabber</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rawImage,0,0,rawWidth,rawHeight,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pix,0,rawWidth);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke the grabPixels() method on the PixelGrabber
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object to actually convert the image to an array&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of numeric pixel data stored in pix. Also test&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for success in the process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pgObj.<b>grabPixels</b>() &amp;&amp; ((pgObj.<b>getStatus</b>() &amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageObserver.ALLBITS) != 0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Mask the red byte out of every pixel by ANDing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the red byte with 00.&nbsp; Also make partially
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // transparent by ANDing the alpha byte with C0&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; (rawWidth*rawHeight);cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pix[cnt] = <b>pix[cnt] &amp; 0xC000FFFF</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if statement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println("Pixel grab not successful");
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the createImage() method to create a new image&nbsp;
&nbsp;&nbsp;&nbsp; // from the array of pixel values.
&nbsp;&nbsp;&nbsp; modImage = this.<b>createImage</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new <b>MemoryImageSource</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rawWidth,rawHeight,pix,0,rawWidth));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor&nbsp;&nbsp;
//=======================================================//
&nbsp;&nbsp;
&nbsp; //Override the paint method to display both the rawImage
&nbsp; // and the modImage on the same Frame object.
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; if(modImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawImage</b>(rawImage,inLeft,inTop,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawImage</b>(modImage,inLeft,inTop+rawHeight,this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end paint()
}//end Image05 class
//=======================================================//</pre></td></tr></table>
-end-<!--end--></body></html>