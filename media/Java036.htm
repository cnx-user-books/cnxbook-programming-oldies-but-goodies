<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Java Objects by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Objects<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 36, Revised 10/02/99.</P>

<P>
<!-toc file=Java036a.htm words=Preface-><A HREF="#preface">Preface</A><BR><!--endtoc-->
<!-toc file=Java036b.htm words=Introduction-><A HREF="#introduction">Introduction</A><BR><!--endtoc-->
<!-toc file=Java036c.htm words=The Stages of an Object's Life-><A HREF="#thestagesofanobjectslife">The Stages of an Object's Life</A><BR><!--endtoc-->
<!-toc file=Java036d.htm words=Creating Objects-><A HREF="#creatingobjects">Creating Objects</A><BR><!--endtoc-->
<!-toc file=Java036e.htm words=Using Objects-><A HREF="#usingobjects">Using Objects</A><BR><!--endtoc-->
<!-toc file=Java036f.htm words=Cleaning Up Leftover Objects-><A HREF="#cleaningupleftoverobjects">Cleaning Up Leftover Objects</A><BR><!--endtoc-->
<!-toc file=Java036g.htm words=Review-><A HREF="#review">Review</A><!--endtoc-->
</P>




<P><!-next=Java036a.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of those persons who are already familiar with C++ and who are making the transition into Java. </P>




<P><!-prev=Java036.htm-><!-next=Java036b.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Start with a little jargon</P>
</B></I></FONT><P>As computer programmers, we are beset by the jargon of the profession. </P>
<P>An <I>object</I> is an <I>instance</I> of a <I>class</I>, so we <I>instantiate</I> objects. </P>
<P>An object has <I>state</I> and <I>behavior</I>. </P>
<P>An object's state is contained in its <I>member variables</I> (data members) and its behavior is implemented through its <I>methods</I> (member functions). </P>
<P>Its member variables can be either <I>instance variables</I> or <I>class variables</I>. </P>
<P>We activate the behavior of an object by <I>invoking one of its methods</I> (sending it a message). </P>
<P>When an object receives a message (has one of its methods invoked), it either <I>performs an action</I>, or <I>modifies its state</I>, or both. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The garbage collector</P>
</B></I></FONT><P>When an object is no longer needed in Java, we simply forget it. Eventually, the <I>garbage collector</I> may (or may not) come by and pick it up for recycling. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The destructor function in C++</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>When an object is no longer needed in C++, it is <I>destroyed</I> and the memory that it occupies is returned to the operating system for recycling (provided that you have written a correct <I>destructor</I> function). </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Object-oriented programming</P>
</B></I></FONT><P>Perhaps nowhere does jargon run so rampant as in object-oriented programming. Hopefully, we can make it through the jargon and gain an understanding of the underlying concepts. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Jargon from an earlier age</P>
</B></I></FONT><P>For simplicity, this lesson will <I>put the cart before the horse</I> (jargon from an earlier age). In particular, we will initially assume that class or type definitions exist, and discuss how to use the <I>methods </I>(member functions) and <I>variables </I>(data members) of those class definitions. Later, we will discuss the detailed ramifications of defining classes. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Differences between Java and C++</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Much of what we discuss will have close ties to C++. However, a few of the things that we will discuss will not have any tie to C++. For example, the <I>interface</I> is one of the Java concepts that does not exist in C++. Even for many of the concepts that do exist in C++, there will be subtle differences between the two languages. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The stages of an object's life</P>
</B></I></FONT><P>This lesson discusses the stages of an Object's life consisting of: </P>

<UL>
<LI>Creation </LI>
<LI>Use </LI>
<LI>Cleanup</LI></UL>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Defining classes</P>
</B></I></FONT><P>A subsequent lesson will discuss the development of classes from which objects can be instantiated. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The Java interface</P>
</B></I></FONT><P>In a subsequent lesson, we will also discuss the <I>interface</I>, which is a collection of method definitions and constant values. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Packages</P>
</B></I></FONT><P>Once we have developed a few classes, we will need a way to organize them, and this will lead us into a discussion of the <I>package</I>. Later on, we will discuss how to create and use packages, and also how to use some of the standard packages that come with Java. </P>




<P><!-prev=Java036a.htm-><!-next=Java036c.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="thestagesofanobjectslife"></A>The Stages of an Object's Life</H2>
</FONT><B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What are the stages?</P>
</B></I></FONT><P>The stages of an object's life consist of </P>

<UL>
<LI>creation </LI>
<LI>use </LI>
<LI>cleanup.</LI></UL>





<P><!-prev=Java036b.htm-><!-next=Java036d.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="creatingobjects"></A>Creating Objects</H3>
</FONT><P>Again, we are going to assume that we either have access to existing classes, or we know how to create our own (which we will learn how to do later). </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is an object?</P>
</B></I></FONT><P>An object is an <I>instance of a class</I>. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What steps are involved in creation of an object?</P>
</B></I></FONT><P>In both Java and C++, the creation of an object involves three steps (which are often combined): </P>

<UL>
<I><LI>declaration </I>(providing a name for the object) </LI>
<I><LI>instantiation </I>(setting aside memory for the object) </LI>
<LI>optional <I>initialization </I>(providing initial values for the object's instance variables)</LI></UL>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Objects vs. primitive types</P>
</B></I></FONT><P>When discussing Java, it is important to recognize the difference between objects and variables of primitive types. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The difference between objects and primitive types is not so pronounced in C++ because they are treated more similarly.</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Primitive types</P>
</B></I></FONT><P>In both Java and C++, there are a large number of primitive types. In both languages, the declaration and instantiation of a variable of a <U>primitive</U> type uses a statement such as the following to cause memory to be set aside for the variable and a name to be associated with the variable. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>int myVar;</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Combining all three steps for primitive types</P>
</B></I></FONT><P>Also, in both languages, you can initialize the value of the variable when it is declared, thereby accomplishing <I>declaration</I>, <I>instantiation</I>, and <I>initialization</I> all in one statement such as the following. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>int myVar = 6;</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What does the compiler know? </P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Perhaps even more important, everything that happens in the above statements regarding primitive variables is <U>known to the compiler at compile time</U>. </TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ also allows you to declare and instantiate variables of primitive types <U>or</U> objects from classes at runtime in such a way that the compiler doesn't know at compile time where the variable or object is stored. This is illustrated in the following simple C++ program. This is referred to as instantiating a variable or an object in <I>dynamic memory</I>. </P>
<P>In addition to instantiating and initializing variables and objects in dynamic memory, this program also illustrates static instantiation and initialization of objects and variables, as well as the instantiation of arrays of objects and variables in dynamic memory. Note that when C++ is used to instantiate an array in dynamic memory, initialization is not allowed in conjunction with the instantiation. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>/*File dynamic1.cpp  Copyright 1997, R.G.Baldwin
Illustrates static and dynamic instantiation of both
primitive variables and objects.  Also illustrates
instantiation of dynamic arrays of both primitive
variables and objects.

The output from this program is as follows:

myIntVar contains 6
myIntPtr points to 7
myIntArrayPtr points to 8 9 10
myStaticObj contains 11
myObjPtr points to 12
myObjArrayPtr points to 13 14 15

********************************************************/

#include&lt;iostream.h

class dynamic1 {
  int objData; //single instance variable of the class

public:
  dynamic1(){}//default constructor

  //parameterized constructor
  dynamic1(int inData){objData = inData;}

  int getData(){return objData;} //get method

  void putData(int inData){objData = inData;}//put method

  static void classMain(){ //class method named classMain
    //Instantiate and initialize static primitive
    // variable
    int myIntVar = 6;
    cout &lt;&lt; "myIntVar contains " &lt;&lt; myIntVar &lt;&lt; endl;

    //Instantiate and initialize dynamic primitive
    // variable
    int *myIntPtr = new int(7);
    cout &lt;&lt; "myIntPtr points to " &lt;&lt; *myIntPtr &lt;&lt; endl;

    //Instantiate dynamic array of primitive variables.
    // Initialization is not supported for dynamic
    // arrays.
    int *myIntArrayPtr = new int[3];

    //Put some data in the dynamic array.
    for(int i = 0; i &lt; 3; i++) *(myIntPtr+i) = i+8;

    //Display the data in the dynamic array.
    cout &lt;&lt; "myIntArrayPtr points to ";
    for(i = 0; i &lt; 3; i++) cout &lt;&lt; *(myIntPtr+i)
                                                 &lt;&lt; " ";
    cout &lt;&lt; endl;

///Now work with objects instead of primitive variables.

    //Instantiate and initialize static object
    dynamic1 myStaticObj(11);
    cout &lt;&lt; "myStaticObj contains "
                       &lt;&lt; myStaticObj.getData() &lt;&lt; endl;

    //Instantiate and initialize dynamic object
    dynamic1 *myObjPtr = new dynamic1(12);
    cout &lt;&lt; "myObjPtr points to "
                       &lt;&lt; myObjPtr - getData() &lt;&lt; endl;

    //Instantiate dynamic array of objects.
    // Initialization of dynamic arrays is not supported.
    dynamic1 *myObjArrayPtr = new dynamic1[3];

    //Put some data in the dynamic array of objects
    for(i = 0; i &lt; 3; i++)
      (myObjArrayPtr+i)-putData(i+13);

    //Display the data in the dynamic array of objects
    cout &lt;&lt; "myObjArrayPtr points to ";
    for(i = 0; i &lt; 3; i++)
      cout &lt;&lt; (myObjArrayPtr+i)-getData() &lt;&lt; " ";

  }//end classMain
};//End dynamic1 class definition.
//=====================================================//

void main()
{
  //call the class method named classMain
  dynamic1::classMain();
}//end main</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Static vs. dynamic memory in Java</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In Java, all <U>primitive variables</U> must be allocated to <I>static</I> memory at compile time. Java <U>does not allow</U> primitive variables to be instantiated into <I>dynamic</I> memory at runtime. However, there are <I>wrapper</I> classes for primitive types that can be used to turn them into objects for this purpose. </P>
<P>In Java, all <U>objects</U> must be instantiated into <I>dynamic</I> memory at runtime. Java <U>does not allow</U> objects to be instantiated in <I>static</I> memory at compile time.</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>An array of objects </P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>When C++ instantiates an array of objects in dynamic memory, it actually instantiates an array of objects and returns a pointer to the first object. </TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>When Java instantiates <I>"an array of objects"</I> (which is always in dynamic memory), it actually instantiates an array of <I><U>references</I> to objects</U>. </P>
<P>An <U>additional step</U> is required to create the objects pointed to by the references. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>A sample Java application</P>
</B></I></FONT><P>The next sample program is a Java application similar to the above C++ program but with the restrictions mentioned above. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Displaying the values of the objects and the references to the objects</P>
</B></I></FONT><P>This program not only displays the data in the objects referred to by the reference variables in the array, it also displays the values contained in the reference variables themselves. These reference values may be used either directly or indirectly (depending on the JVM) to access the objects referred to by the reference variables. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>A quick review</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>To review, in C++, an array of objects instantiated in dynamic memory consists of an actual array of objects and a single pointer is returned which points to the first object in the array. Pointer arithmetic can then be used to access the other objects. </TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>An <I>array of objects</I> in Java is instantiated as <U>an array of reference variables</U> where each reference variable can then be used to instantiate an object and have it referred to by the reference variable. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Multiple use of the new operator is required in Java</P>
</B></I></FONT><P>In Java, <U>multiple usage</U> of the <B>new</B> operator is required to instantiate an <I>"array of objects" </I>because the array doesn't actually contain the objects; it contains references to the objects.</P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>C++ requires only one use of the new operator</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Only one usage of the <B>new</B> operator will instantiate a (single dimensional) array of objects in C++. </P>
<P>Instantiation of an array of objects in Java is very similar to the instantiation of an array of pointers in C++, which is often used to point to a group of strings. However, from a syntax viewpoint, the array of <I>references</I> in Java is much easier to use than an array of pointers in C++. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Default display format for a Java reference</P>
</B></I></FONT><P>Note in the output shown at the beginning of the following program that the display format for the reference is to <U>identify the class</U> and the <U>value</U> contained in the reference as a hexadecimal value. This is the default display format when you include an object reference of a type without an overridden <B>toString()</B> method as a parameter to the <B>println()</B> method. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>main() instantiates objects of its own class</P>
</B></I></FONT><P>You should also note that when the main method in this application instantiates objects dynamically, those objects are of a new type defined by the class <U>of which the main method is a member</U>. In other words, the <B>main()</B> method instantiates objects of the same class of which it is a member. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Dynamic1.java Copyright 1997, R.G.Baldwin
Illustrates allocation of primitive variables to static
memory at <B>compile time</B>.

Also illustrates instantiation of dynamic objects and 
dynamic arrays of objects <B>at runtime</B>.

The output from this program is as follows:

<B>myPrimitiveVariable contains 6
myObjRef contains Dynamic1@1cc748
Object referred to by myObjRef contains 12
myArrayOfRefs contains 
Dynamic1@1cc766 
Dynamic1@1cc767 
Dynamic1@1cc768 

Objects referred to by myArrayOfRefs contain 
13 
14 
15 
</B>********************************************************/

class <B>Dynamic1 </B>{
  //single instance variable of the class of type int
  private int <B>objData</B>; 

  //parameterized <B>constructor
</B>  public <B>Dynamic1(int</B> inData){
    objData = inData;
  }//end constructor

  //get method
  public int <B>getData</B>(){
    return objData;
  }//end getData()

  public static void <B>main</B>(String[] args){//main method
    //Declare and initialize <B>primitive </B>variable of type 
    // int in static memory at compile time. Display it.
    int <B>myPrimitiveVariable </B>= 6;
    System.out.println("myPrimitiveVariable contains " 
                                  + myPrimitiveVariable);

    //Instantiate and initialize <B>object in dynamic memory
</B>    // at runtime.  Display the contents of the reference
    // variable and the contents of the object it refers
    // to.
    <B>Dynamic1 myObjRef = new Dynamic1(12)</B>;
    System.out.println("myObjRef contains " + <B>myObjRef</B>);
    System.out.println(
              "Object referred to by myObjRef contains " 
                                 + <B>myObjRef.getData()</B> );

    //Instantiate <B>array of references</B> to objects in 
    // dynamic memory at runtime.
    <B>Dynamic1</B>[] <B>myArrayOfRefs </B>= <B>new Dynamic1[3]</B>;

    //Instantiate some objects in dynamic memory and
    // <B>store references</B> to those objects in the array
    // of references.
    for(int i = 0; i &lt; 3; i++)
      <B>myArrayOfRefs[i] = new Dynamic1(i+13)</B>;

    //Display the <B>values </B>contained in the array of 
    // <B>references </B>to objects
    System.out.println("myArrayOfRefs contains ");
    for(int i = 0; i &lt; 3; i++)
      System.out.println(myArrayOfRefs[i<B>]</B>);
    System.out.println();

    //Display the <B>values </B>in the <B>objects </B>referenced by
    // the array of references
    System.out.println(
        "Objects referred to by myArrayOfRefs contain ");
    for(int i = 0; i &lt; 3; i++)
      System.out.println(myArrayOfRefs[i].getData<B>()</B>);

  }//end Main
}//End Dynamic1 class definition.</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Assignment to superclass type reference variable</P>
</B></I></FONT><P>The next program is a modified version of the previous one that illustrates a very important object-oriented programming concept in Java. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A reference to an object in Java can be assigned to any reference variable whose type is the type of the object, or is a superclass of the type of the object.</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Using Object class</P>
</B></I></FONT><P>In the next program, the array of reference variables is declared to be of type <B>Object</B> (rather than the actual type of the objects to which they will refer). </P>
<P>Recall that <B>Object</B> is the superclass of all classes in Java. Therefore, a reference variable of type <B>Object</B> can refer to an object of any type. Three objects of the <B>Dynamic2</B> class are instantiated, and references to those objects are stored in the three elements of the array of reference variables. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Displaying the values of the reference variables</P>
</B></I></FONT><P>Then the values contained in the reference variables are displayed. By observing the values that are displayed (in the comments near the beginning of the program) you can see that the actual type of the objects, <B>Dynamic2</B>, is embedded in the reference values. The actual type of the objects is displayed (as opposed to the type <B>Object,</B> which is the type of the reference variables.) </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Downcasting is required</P>
</B></I></FONT><P>After this, the reference variables are used to display the contents of the objects to which they refer. However, this is where things get a little more complex. The reference variables of type <B>Object</B> can be used in their raw form to access <U>only those members</U> of the object that are defined in the <B>Object</B> class. In order to access members defined in a subclass of <B>Object</B>, you must <B><I>downcast</I> </B>the reference to that subclass. </P>
<P>In this case, we downcast the reference to type <B>Dynamic2</B> so that we can access and display the instance variable defined in the class <B>Dynamic2</B>. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Downcast syntax can be complex</P>
</B></I></FONT><P>The syntax for the downcasting can be a little complex, involving lots of parentheses, so pay particular attention to the syntax as you review this program. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Dynamic2.java Copyright 1997, R.G.Baldwin
Illustrates instantiation of array of references of type
Object and the use of that array to refer to objects
of an inherited class.

The output from this program is as follows:

<B>myArrayOfRefs contains 
Dynamic2@1cc738 
Dynamic2@1cc739 
Dynamic2@1cc73a 

Objects referred to by myArrayOfRefs contain 
13
14
15
</B>********************************************************/

class <B>Dynamic2 </B>{
  //single instance variable of the class of type int
  private int <B>objData</B>; 

  //parameterized <B>constructor
</B>  public <B>Dynamic2(int</B> inData){
    objData = inData;
  }//end constructor

  //get method
  public int <B>getData</B>(){
    return objData;
  }//end getData()

  public static void <B>main</B>(String[] args){//main method
    //Instantiate <B>array of references</B> to objects of type
    // <B>Object </B>in dynamic memory at runtime.
    <B>Object[] myArrayOfRefs = new Object[3]</B>;

    //Instantiate some objects of type <B>Dynamic2 </B>in 
    // dynamic memory and <B>store </B>references to those 
    // objects in the <B>array </B>of references of type Object.
    for(int i = 0; i &lt; 3; i++)
      myArrayOfRefs[i] = <B>new Dynamic2(i+13)</B>;

    //<B>Display </B>the <B>values </B>contained in the array of 
    // references to objects. Note that the values
    // identify the <B>actual type of object</B> referred to.
    System.out.println("myArrayOfRefs contains ");
    for(int i = 0; i &lt; 3; i++)
      System.out.println(myArrayOfRefs[i<B>]</B>);
    System.out.println();

    //Display the <B>values </B>in the <B>objects </B>referenced by
    // the array of references.  Note the requirement
    // to <B>downcast </B>the references to the actual type
    // of object referred to by the references in
    // order to access the instance variables of the
    // objects.
    System.out.println(
        "Objects referred to by myArrayOfRefs contain ");
    for(int i = 0; i &lt; 3; i++)
      System.out.println(
        <B>((Dynamic2)(myArrayOfRefs[i])).getData</B>());
  }//end Main
}//End Dynamic2 class definition.</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Anonymous objects </P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In Java, it is <U>not always necessary to declare</U> an object (to give it a name). Objects instantiated without a declaration are called <U>anonymous objects</U>.</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>When might you use an anonymous object?</P>
</B></I></FONT><P>Consider, for example a case where a new object is instantiated to be used in an expression and there is no requirement to be able to access that object outside of the expression. In that case, there is no need to declare a reference variable and assign the object to the reference variable. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Instantiating an anonymous object in a method call</P>
</B></I></FONT><P>This is illustrated in the following program. In this program, a <B>Date</B> object is instantiated and passed to the I/O system for display. The object is not assigned to a reference variable. At least it is not assigned to a reference variable within the code that we wrote. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File date1.java Copyright 1997, R.G.Baldwin
Illustrates instantiation of an object without the 
declaration of a name.  A Date object is instantiated 
and passed to the I/O system for display.  The Date 
class is contained in java.util, thus the requirement 
for the import statement.

The output for one particular run was:

Thu Oct 24 16:44:35  1996

********************************************************/
import java.util.*;
class date1 { //define the controlling class
  public static void main(String[] args){ //main method
    System.out.println( <B>new Date()</B> );
  }//end main
}//End date1 class.  </PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Is the object really anonymous?</P>
</B></I></FONT><P>One might argue that the object in the above program is actually assigned to a reference variable (which is a method parameter) inside the <B>println()</B> method, and they would probably be correct. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Instantiating an anonymous object within an expression</P>
</B></I></FONT><P>The following program instantiates an anonymous object and uses it within a <U>local expression</U> without assigning it to a reference variable. In this case, there is no method call involved, so there is no method parameter to assign the anonymous object to. </P>
<P>This program instantiates an anonymous object, initializing it with a value of 10, then immediately retrieves the value of the instance variable and adds that value to 3. The overall expression evaluates to 13, which is displayed on the screen. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Anonymous1.java Copyright 1997, R.G.Baldwin
Illustrates instantiation and use of an anonymous
object in a local expression.

The output from this program is as follows:
13

********************************************************/

class Anonymous1 {
  private int objData; //instance variable

  public Anonymous1(int inData){//constructor
    objData = inData;
  }//end constructor

  public int getData(){//get method
    return objData;
  }//end getData()

public static void main(String[] args){//main method
    System.out.println("" 
                    + (<B>new Anonymous1(10).getData()+3</B>));
  }//end Main
}//End Anonymous1 class definition.</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Useful for illustration only</P>
</B></I></FONT><P>Granted, the previous program isn't too useful, but it does illustrate the concept of anonymous objects. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>A more useful anonymous object</P>
</B></I></FONT><P>The following program uses anonymous objects in a more useful way. In particular, this program uses an anonymous object to gain access to a method that converts integers to hexadecimal representation. In so doing, it displays the integer value of 128 in hexadecimal format. </P>
<P>In order to do this, the program instantiates an anonymous object of type Integer passing a dummy value of zero to the constructor. The objective is to be able to access the <B>toHexString()</B> method of the integer class and to use that method to convert 128 to hex. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Anonymous2.java Copyright 1997, R.G.Baldwin
Illustrates instantiation and use of an anonymous
object to display the integer value 128 in hex.

The output from this program is as follows:
80
80

********************************************************/

class Anonymous2 {

public static void main(String[] args){//main method
    //Note that the value of zero being passed to the
    // Integer class constructor is a dummy value 
    // provided to make it possible to instantiate
    // the object of type Integer.  The object of 
    // type Integer is needed so that its instance
    // method named toHexString() can be invoked.
    System.out.println("" 
                    + <B>new Integer(0).toHexString(128)</B>);

    //Access the toHexString() method as a class method
    // without the requirement for an object of the 
    // Integer type.
    System.out.println(Integer.toHexString(128));      
  }//end Main
}//End Anonymous2 class definition.</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The truth shall prevail</P>
</B></I></FONT><P>To be truthful, I will point out that the <B>toHexString()</B> method is a <I>class </I>method that can be accessed without the requirement to instantiate an object, so the anonymous object wasn't really required in this case. But hopefully, you get the picture insofar an anonymous objects are concerned. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>A similar approach in C++</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The following program illustrates a similar concept in C++ where an object is instantiated and passed as a parameter to a function. In truth, there is a hidden declaration of the object in this program, and it is contained in the argument list of the function. The parameter that is instantiated and passed is then used to initialize the local automatic object in the function. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>/*File date1.cpp  Copyright 1997 R.G.Baldwin
Illustrates instantiating an object without an "obvious"
declaration of the object.  An object is instantiated and
passed to a function where it is used to initialize one
of the parameters in the function.

The output from the program is:

The date is 10/24/96

*****************************************************/

#include&lt;iostream.h
#include&lt;string.h

class dateContainer{ //class to instantiate a date object
public:
  char dataArray[20];
  dateContainer(char* inString){
    strcpy(dataArray,inString);
  }
};//end class

class date1 { //simulates Java controlling class
public:
  //Function to receive an object containing a date
  // and display it.
  void displayDate(dateContainer objIn){
    cout &lt;&lt; "The date is "&lt;&lt; objIn.dataArray &lt;&lt; endl;
  }//end displayDate()

  static void classMain(){
    //object is required to call displayDate()
    date1 thisObject;

    //Put a call to the constructor as a parameter in
    // the function call.
    thisObject.displayDate(dateContainer("10/24/96") );
  }//end classMain
};//End date1 class definition.
//=====================================================//

void main()
{
  //call the class method named classMain
  date1::classMain();
}//end main</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Overloaded constructors</P>
</B></I></FONT><P>We have been using a <I>constructor </I>for the class to initialize a new object in the above Java and C++ programs. Because constructors can be overloaded, new objects can often be initialized in a variety of ways. We will discuss this further when we discuss the various methods of a class. </P>




<P><!-prev=Java036c.htm-><!-next=Java036e.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="usingobjects"></A>Using Objects</H3>
</FONT><B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Member variables and methods may be hidden</P>
</B></I></FONT><P>In both Java and C++, once we have an object that contains instance variables and methods, we can access those variables and methods to do useful work. There is essentially no difference in the syntax used to access a variable or a method. However, sometimes variables or methods may be hidden so as to make it impossible to access them. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Hide the variables and expose the access methods</P>
</B></I></FONT><P>It is very common to hide the variables and to expose the methods that can be accessed to serve as a pathway to the variables. We will discuss more about how to do this later. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Joining the member name to the reference variable</P>
</B></I></FONT><P>In the meantime, assuming that they aren't hidden, variables and methods may be accessed in either Java or C++ by specifying the name of the object (reference) and the name of the variable or method and using a period to join the two. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>An Aside: Objects don't have a name in Java</P>
</B></I></FONT><P>It is important to remember that objects don't have names in Java. Only the reference variables that refer to the objects have names. </P>
<P>For brevity, we often speak of "an object named <I>theObject</I>." What we really mean is a reference variable named <I>theObject</I> that currently refers to a particular object. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Reference variables can refer to different objects</P>
</B></I></FONT><P>It is also very important to remember that the same reference variable can refer to different objects at different points in time during execution of a Java program.</P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Now back to the main thought</P>
</B></I></FONT><P>Use of the joining operator is illustrated in the following code fragments from the above programs. Note that these code fragments are not related in any way. They are simply isolated statements from above. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>    System.out.println(
                ((Dynamic2)(myArrayOfRefs[i])).getData());
    System.out.println("" 
                    + (new Anonymous1(10).getData()+3));</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The pointer operator in C++ </P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In addition, in C++, if a pointer contains the address of an object, the members of that object can be accessed by joining the name of the pointer to the name of the member using the pointer operator <B>-</B>. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Sending a message to an object</P>
</B></I></FONT><P>The process that is often referred to as <I>"sending a message to an object"</I>, is really nothing more than making a call to a method associated with an object. As in any call to a method, the method may return a value. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Using the new operator in Java</P>
</B></I></FONT><P>In Java, the <B>new</B> operator, used in conjunction with a constructor, returns a reference to a new object. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Using the new operator in C++</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The <B>new</B> operator also returns something in C++. It returns a pointer. In Java, it returns a reference (which is similar to a pointer) but the reference that it returns is very restricted relative to pointers in C++. (In particular, you cannot do pointer arithmetic with Java references and you cannot arbitrarily change the address stored in a Java reference.) </P>
<P>In C++, the <B>new</B> operator can be used in an expression which expects a pointer of a given type.</TD>
</TR>
</TABLE>

<P>In Java, the <B>new</B> operator can be used in an expression which expects a <I>reference </I>of a given type. </P>




<P><!-prev=Java036d.htm-><!-next=Java036f.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="cleaningupleftoverobjects"></A>Cleaning Up Leftover Objects</H3>
</FONT><P><A HREF="#thecapproachtocleanup">The C++ Approach to Cleanup</A><BR>
<A HREF="#thejavaapproachtocleanup">The Java Approach to Cleanup</A> </P>
<P>The process of cleaning up is completely different between Java and C++. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The C++ approach to cleanup</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P><A NAME="thecapproachtocleanup"></A>In C++, the programmer is responsible for all cleanup. Of particular importance is the need to return dynamically allocated memory to the operating system. However, in addition to returning memory to the operating system, there may be other important tasks that need to be taken care of such as shutting down communication channels, closing files, etc. </P>
<P>C++ supports the concept of the <I>destructor</I> method for this purpose. The <I>destructor</I> is a special method or member function of a class which <U>always</U> executes automatically whenever an object goes out of scope. You can place any code that is needed for cleanup in the body of the destructor and be confident that it will be executed. </P>
<P>The following C++ program illustrates the automatic action of the destructor. In this program, an object is instantiated in dynamic memory within a code block of limited scope. When control passes beyond the scope of the block, the destructor is executed, returning the memory to the operating system and displaying a message to announce that it is has been invoked. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>/*File template.cpp Copyright 1997, R.G.Baldwin
Illustrates use of destructor for cleanup in C++.  Also
illustrates use of a block for scope reduction.

The output from the program is:

In constructor
In showData method. Data value is 5
Leaving scope-reduction block.  Object will be destroyed.
In destructor
No longer in scope-reduction block.
Terminating program

******************************************************/

#include&lt;iostream.h
#include&lt;new.h
#include&lt;stdlib.h

class newClass{ //prog instantiates an obj of this type
  int* ptrToNewData; //use as pointer to dynamic memory
public:
  newClass(int inData){ //constructor
    cout &lt;&lt; "In constructor\n";
    //Instantiate and initiate object in dynamic memory
    ptrToNewData = new int(inData);
    if(!ptrToNewData) exit(1);
  }//end constructor

  ~newClass(){//destructor
    cout &lt;&lt; "In destructor\n";
    delete ptrToNewData;//return memory to op sytem
  }//end destructor

  void showData(){cout &lt;&lt;
               "In showData method. Data value is "
    &lt;&lt; *ptrToNewData &lt;&lt; endl;}

};//end newClass

class cleanup1{ //simulates controlling class in Java
public:
  static void classMain(){//simulates main method in Java
    //prepare new operator for null return on failure
    set_new_handler(0);

    { //begin scope-reduction block
    //instantiate and initialize object
    newClass newObject(5);
    newObject.showData();  //display contents of object
    cout &lt;&lt; "Leaving scope-reduction block. "
                         "Object will be destroyed.\n";
    } //end scope-reduction block

    cout &lt;&lt; "No longer in scope-reduction block."
                             "\nTerminating program\n";
  }//end classMain
};//End cleanup1 class definition.

//===================================================//

void main()
{
  //call the class method named classMain
  cleanup1::classMain();
}//end main</PRE></TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>To reiterate, although it is the responsibility of the programmer in C++ to provide the code which returns memory to the operating system, the programmer can be assured that the <I>destructor</I> will <U>always</U> be executed whenever the object goes out of scope, and can include other required cleanup code in the <I>destructor.</I> </TD>
</TR>
</TABLE>

<P>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="thejavaapproachtocleanup"></A>The Java Approach to Cleanup</H4>
</FONT><P><A HREF="#garbagecollection">Garbage Collection</A><BR>
<A HREF="#thefinalizemethod">The finalize Method</A></P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The good news</P>
</B></I></FONT><P>The good news (if things work as planned) is that the Java programmer never needs to worry about returning memory to the operating system. This is taken care of automatically by a feature of Java known as the <I>garbage</I> collector. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The bad news</P>
</B></I></FONT><P>The bad news is that Java does not support anything like a <I>destructor</I> that is guaranteed to be called whenever the object goes out of scope or is no longer needed. Therefore, other than returning allocated memory, it is the responsibility of the programmer to explicitly perform <U>any other required cleanup</U> at the appropriate point in time. </P>
<P>Other kinds of cleanup could involve closing files, disconnecting from open telephone lines, etc.</P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="garbagecollection"></A>Garbage Collection</H4>
</FONT><B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Purpose of garbage collection</P>
</B></I></FONT><P>The <U>sole purpose</U> of <I>garbage collection</I> is to reclaim memory occupied by objects that are no longer needed. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Eligibility for garbage collection</P>
</B></I></FONT><P>An object becomes <I><U>eligible</I></U> for <I>garbage collection</I> when there are <U>no more references</U> to that object. You can make an object <I>eligible </I>for garbage collection by setting all references to that object to <B>null</B>, or allowing them to go out of scope. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Eligible garbage may not be collected</P>
</B></I></FONT><P>However, just because an object is <I>eligible </I>for <I>garbage collection</I> doesn't mean that it will be reclaimed. </P>
<P>The <I>garbage collector</I> runs in a low-priority thread, and presumably is designed to create minimal interference with the other threads of the program. Therefore, the garbage collector may not run unless a memory shortage is detected. And when it does run, it runs asynchronously relative to the other threads in the program. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>A formal definition of garbage collection</P>
</B></I></FONT><P>According to <B>Campione and Walrath</B>, http://java.sun.com/books/Series/Tutorial/java/javaOO/garbagecollection.html </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>"The Java garbage collector is a <I>mark-sweep</I> garbage collector that scans Java's dynamic memory areas for objects, marking those that are referenced. After all possible paths to objects are investigated, those objects that are not marked (that is, not referenced) are known to be garbage and are collected. </TD>
</TR>
</TABLE>

<P>Although you can ask the garbage collector to run by calling <B>System.gc()</B>, Campione and Walrath go on to point out: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>"Asking the garbage collection to run does not guarantee that your objects will be garbage collected." </TD>
</TR>
</TABLE>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="thefinalizemethod"></A>The finalize Method</H4>
</FONT><P>Before the <I>garbage collector</I> reclaims the memory occupied by an object, it calls the object's <B>finalize()</B> method. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Doing cleanup in the finalize() method</P>
</B></I></FONT><P>The <B>finalize()</B> method is a member of the <B>Object </B>class. Since all classes inherit from the <B>Object </B>class, your classes also contain the default <B>finalize()</B> method. This gives you an opportunity to execute your special cleanup code on each object before the memory is reclaimed. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Overriding the finalize() method</P>
</B></I></FONT><P>In order to make use of the <B>finalize()</B><I> </I>method, you must <I>override</I> it, providing the code that you want to have executed before the memory is reclaimed. (We will discuss <I>overriding</I> methods in detail later.) </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>finalize() is not a destructor</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The <B>finalize()</B> method does not take the place of the <I>destructor</I> from C++. Although you can be confident that the <I>finalize</I> method will be called before the <I>garbage collector</I> reclaims the memory occupied by a particular object, you cannot be certain when, or if that memory will be reclaimed. </TD>
</TR>
</TABLE>

<P>To reiterate, the <I>finalize</I> method is not a <I>destructor</I> in the C++ sense. It does not run automatically when your object references go out of scope or are set to null. </P>
<P>You can never be certain when the <B>finalize()</B> method will be executed (except that in JDK 1.1 and later, you can force finalization methods to run on all non-finalized objects at program termination, but these methods were deprecated in JDK 1.2.) </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Is the cleanup timing critical?</P>
</B></I></FONT><P>If you simply need to do cleanup work on an object sometime before the program terminates, (and you have specified finalization on exit) you can depend on your overridden <B>finalize()</B> method being executed sometime before the program terminates. </P>
<P>If you need cleanup work to be performed earlier (such as disconnecting an open long-distance telephone call), you must explicitly call methods to do cleanup at the appropriate point in time and not depend on finalization to get the job done. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Asking for garbage collection</P>
</B></I></FONT><P>As mentioned earlier, Campione and Walrath indicate that you can ask the <I>garbage collector</I> to run at any time by calling the method </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>System.gc();</PRE></TD>
</TR>
</TABLE>

<P>They point out however, that making the request does not guarantee that your objects will be <I>garbage collected</I>. </P>
<P>They also indicate: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>"You can force object finalization to occur by calling the System's <I>runFinalization</I> method as follows: </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>System.runFinalization();</PRE></TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>They state: "This method calls the finalize methods on all objects that are waiting to be <I>garbage collected</I>."</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Forcing finalization on exit</P>
</B></I></FONT><P>Fortunately, the following very important method was added to JDK 1.1. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><B>runFinalizersOnExit(boolean)</B> </P>
<P>With this method, you can guarantee that finalization will occur before the program exits. This enables you to guarantee that any necessary cleanup will be accomplished before program termination by overriding the <B>finalize()</B> method for your class to perform that cleanup. </P>
<P>To guarantee finalization on exit, call this method passing <B>true</B> as an argument somewhere early in your program.</TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>runFinalizersOnExit() has been deprecated</P>
</B></I></FONT><P>Of the three methods involving finalization and garbage collection, the only one that I have found to be reliable is <B>runFinalizersOnExit().</B> Unfortunately, it was deprecated in JDK 1.2 with the following explanation</P>
<BLOCKQUOTE>"Deprecated. This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock."</BLOCKQUOTE>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>System.runFinalization() and System.gc()</P>
</I></FONT><P>System.runFinalization()</B> and <B>System.gc()</B> don't seem to behave as I would hope they would. However, the JavaSoft documentation points out that these two methods simply "suggest" that the JVM "expend its best effort" to do what you have requested (finalization or garbage collection). </P>
<P>An excellent discussion of this topic can be found in Bruce Eckel's online book, <U>Thinking in Java</U>, http://www.eckelobjects.com. </P>




<P><!-prev=Java036e.htm-><!-next=Java036g.htm><!-first=Java036.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review"></A>Review</H2>
</FONT><P>Q - In Object-Oriented Programming, an object is often said to be an ____________ of a class. Provide the missing word. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An object is often said to be an <B>instance</B> of a class.</FONT> </P>
<P>Q - In Object-Oriented Programming, an object is often said to have s_______ and b_______. Provide the missing words which begin with the letters shown. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - In OOP, an object is often said to have <B>state </B>and <B>behavior</B>.</FONT> </P>
<P>Q - An object's state is contained in its ________ and its behavior is implemented through its ________. Provide the missing words. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An object's state is contained in its <I>member variables</I> ( or data members) and its behavior is implemented through its <I>methods</I> ( or member functions).</FONT> </P>
<P>Q - The member variables of an object can be either ____________ or _________ . Provide the missing words. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Its member variables can be either <I>instance variables</I> or <I>class variables</I>.</FONT> </P>
<P>Q - What is generally meant by the terminology "sending a message to an object?" </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - We activate the behavior of an object by <I>invoking one of its methods</I> (sending it a message).</FONT> </P>
<P>Q - What are the two things that can usually happen when an object <I>receives a message</I>? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - When an object receives a message, it usually either <I>performs an action</I>, or <I>modifies its state</I>, or both.</FONT> </P>
<P>Q - What happens to the memory occupied by an object in Java when the object is no longer needed, and what do we normally do to make that happen? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - When an object is no longer needed in Java, we simply forget it. Eventually, the <I>garbage collector</I> may (or may not) come by and pick it up for recycling.</FONT> </P>
<P>Q - What does Baldwin's Java tutorial identify as the stages of an object's life? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The stages of an Object's life are:</P>

<UL>
<LI>Creation</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Use</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Cleanup</LI></UL>

</FONT><P>Q - According to Baldwin's Java tutorial, the creation of an object involves three steps (which are often combined). What are the three steps? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The three steps are:</P>

<UL>
<LI>declaration (providing a name for the object)</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>instantiation (setting aside memory for the object)</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>optional initialization (providing initial values for the object's instance variables)</LI></UL>

</FONT><P>Q - Java allows the instantiation of variables of <I>primitive</I> types in dynamic memory: True or False? If false, explain why and what you might be able to do to achieve almost the same result. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Java does <U>not</U> allow the instantiation of primitive variables in dynamic memory. (However, there are <I>wrapper</I> classes for primitive types which can be used to turn them into objects for this purpose.)</FONT> </P>
<P>Q - An array of objects in Java is instantiated as an array of <I>reference variables </I>where each <I>reference variable </I>can then be used to instantiate an object pointed to by the <I>reference variable</I>: True or False. If false, explain why and either provide a code fragment that illustrates your answer, or refer to a sample program in Baldwin's Java tutorial that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, it is always necessary to declare (give a name to) all new objects: True or False? If false, explain why and either provide a code fragment that illustrates your answer, or refer to a sample program in Baldwin's Java tutorial that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - It is not always necessary in Java to declare an object (to give it a name). Consider, for example a case where a new object is instantiated to be used in an expression and there is no requirement to be able to access that object outside of the expression. This is illustrated in the program named date1.java in the lesson entitled Java036.htm.</FONT> </P>
<P>Q - <I>Instance variables</I> and <I>instance methods</I> can be accessed using an object as the access mechanism. What is the difference in the syntax used to access an <I>instance variable</I> and an <I>instance method</I>. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - None. There is essentially no difference in the syntax used to access a variable or a method.</FONT> </P>
<P>Q - Once you have instantiated an object, it is always possible to access all of the <I>instance variables</I> and <I>instance methods</I> of that object by joining the name of the object to the name of the variable or method using a period: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Sometimes variables or methods may be hidden so as to make it impossible to access them. It is very common to hide the variables and to provide methods which can be accessed to serve as a pathway to the variables.</FONT> </P>
<P>Q - Given an object named <B>obj</B> that has a <B>public</B> instance method named <B>myMethod()</B>, provide a code fragment that shows the proper syntax for accessing the method. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The proper syntax for accessing an instance method named myMethod() follows:</FONT> </P>
<FONT COLOR="#0000ff"><TT><P>obj.myMethod()</FONT></TT> </P>
<P>Q - The object-oriented approach normally recommends hiding instance variables behind access methods: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. The object-oriented approach normally recommends hiding instance variables behind access methods.</FONT> </P>
<P>Q - The object-oriented approach normally recommends hiding instance variables behind access methods: True or False? If true, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. The object-oriented approach normally recommends hiding instance variables behind access methods. There are a variety of reasons why. One important reason is that hiding the instance variables makes it possible to later modify the implementation of instance variables to improve the behavior of objects of the class, without a requirement for modifying code that uses the clsss, provided that the access methods are not modified.</FONT> </P>
<P>Q - The returning of memory (to the operating system) occupied by objects that are no longer needed is automatically accomplished in Java by a feature commonly known as the ____________________. Fill in the missing word(s). </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The returning of memory to the operating system is taken care of automatically by a feature of Java known as the <I>garbage</I> <I>collector</I>.</FONT> </P>
<P>Q - <U>All necessary cleanup</U> in a Java program is performed automatically by the <I>garbage collector</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Java does not support anything like a <I>destructor</I> that is guaranteed to be called whenever the object is no longer needed. Therefore, other than returning allocated memory, it is the responsibility of the programmer to explicitly perform any other required cleanup at the appropriate point in time.</FONT> </P>
<P>Q - When does an object become <I>eligible</I> for <I>garbage collection</I>? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An object becomes <I>eligible</I> for <I>garbage collection</I> when there are no more references to that object.</FONT> </P>
<P>Q - What can your program do to purposely make an object <I>eligible</I> for <I>garbage collection</I>. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Your program can make an object <I>eligible</I> for garbage collection by assigning <I>null </I>to all references to the object.</FONT> </P>
<P>Q - The purpose of <I>garbage collection</I> in Java is to perform <U>all necessary cleanup</U> and the memory occupied by objects that are no longer needed will <U>always</U> be reclaimed by the <I>garbage collector</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The <U>sole purpose</U> of <I>garbage collection</I> is to reclaim memory occupied by objects that are no longer needed, and it has no other purpose relative to necessary cleanup. An object becomes <I><U>eligible</I></U> for <I>garbage collection</I> when there are no more references to that object. However, just because an object is eligible for <I>garbage collection</I> doesn't mean that it will be reclaimed. The <I>garbage collector</I> runs in a low-priority thread, and may not run at all unless a memory shortage is detected.</FONT> </P>
<P>Q - Before the <I>garbage collector</I> reclaims the memory occupied by an object, it always calls the object's _________ method. (Provide the name of the method.) Explain why this method is one of the methods in all new classes that you define. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Before the <I>garbage collector</I> reclaims the memory occupied by an object, it calls the object's <B><I>finalize</B></I>method. The <I>finalize</I> method is a member of the <I>Object</I> class. Since all classes inherit from the <I>Object</I> class, your classes also contain the default <I>finalize</I> method.</FONT> </P>
<P>Q - What must you do to make effective use of the <B>finalize</B> method? Explain why you might want to do this. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - In order to make use of the <B>finalize </B>method, you must <I>override</I> it, providing the code that you want to have executed before the memory is reclaimed.</FONT> </P>
<P>Q - You can always be confident that the <B>finalize</B> method will be promptly executed to perform necessary cleanup in a Java program when an object becomes eligible for <I>garbage collection</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Although you can be confident that the <I>finalize</I> method will be called before the <I>garbage collector</I> reclaims the memory occupied by a particular object, you cannot be certain when, or if that memory will be reclaimed. There is no guarantee that the memory will be reclaimed by the <I>garbage collector</I> during the execution of your program.</FONT> </P>
<P>Q - Provide a code fragment illustrating the method call that you can make to ask the <I>garbage collector</I> to run. This guarantees that <I>garbage collection</I> will take place: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Campione and Walrath indicate that you can ask the <I>garbage collector</I> to run at any time by calling the method shown below. They further point out, however, that making the request does not guarantee that your objects will be reclaimed through <I>garbage collection</I>.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffffff">
<PRE>System.gc();</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java program that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg12.java from lesson 36
Copyright 1997, R.G.Baldwin
Without reviewing the solution that follows, write a Java
application that illustrates static instantiation of
primitive variables and also illustrates instantiation 
of dynamic objects and dynamic arrays of objects. In 
this case, the word static is not being used in the 
sense of the static keyword that produces class 
variables and class methods.  It is being used in the 
sense of "not dynamic", meaning that the memory is
allocated at compile time and not at runtime.

Display the value contained in each reference variable 
as well as the value stored in the object pointed to 
by the reference variable.

Provide a termination message with your name.
**********************************************************/

class SampProg12 {
  //single instance variable of the class
  private int objData;

  //constructor
  public SampProg12(int inData){objData = inData;}

  public int getData(){return objData;} //get method

  public static void main(String[] args){
    //Instantiate and initialize static primitive variable
    int myIntVar = 6;
    System.out.println("myIntVar contains " + myIntVar);

    //Instantiate and initialize dynamic object
    SampProg12 myObjPtr = new SampProg12(12);
    System.out.println("myObjPtr contains " + myObjPtr);
    System.out.println(
      "myObjPtr points to object containing " 
      + myObjPtr.getData() );

    //Instantiate dynamic array of objects.
    SampProg12[] myObjArrayPtr = new SampProg12[3];

    //Put some data in the dynamic array of objects
    for(int i = 0; i &lt; 3; i++)
      myObjArrayPtr[i] = new SampProg12(i+13);

    //Display the addresses in the array of pointers 
    // to objects
    System.out.print("myObjArrayPtr contains ");
    for(int i = 0; i &lt; 3; i++)
      System.out.print(myObjArrayPtr[i] + " ");
    System.out.println();

    //Display the data pointed-to by the array of pointers
    System.out.print(
      "myObjArrayPtr points objects containing ");
    for(int i = 0; i &lt; 3; i++)
      System.out.print(myObjArrayPtr[i].getData() + " ");
    System.out.println();

    System.out.println("Terminating, Dick Baldwin");
  }//end Main
}//End SampProg12 class definition.</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java program that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg13.java from lesson 36
Copyright 1997, R.G.Baldwin
Without reviewing the following solution, write a Java
application that illustrates the instantiation and use
of an anonymous object.

Also provide a termination message with your name.
**********************************************************/

class SampProg13{
  public static void main(String[] args){
    System.out.println("" 
      + ((new Integer(5).intValue()) * 3));
    System.out.println("Terminating, Dick Baldwin");
  }//end main
  
}//end class SampProg13</PRE></TD>
</TR>
</TABLE>





<P><!-prev=Java036f.htm-><!-first=Java036.htm-></P>
<P>-end-<!--end--></P>
</BODY>
</HTML>
