<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Processing Image Pixels, Color Intensity, Color Filtering, and 
Color Inversion </h2>
    <p><i>Learn to write a Java program to control color intensity, apply color 
	filtering, and apply color inversion to an image.&nbsp; Learn to relate the 
	colors to points on a color wheel and points in a color cube.</i></p>
<p><b>Published:</b>&nbsp; June 14, 2005<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 406</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
	<li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a><li>
	<a href="#Communication_between_the_Programs">Communication between the 
	Programs</a><li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>Fourth in a series</b></font></p>
<p>This is the fourth lesson in a series designed to teach you how to 
use Java to create special effects with images by directly manipulating the 
pixels in the images.</p>
<p>The first lesson in the series was entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; The previous lesson 
was entitled <a href="http://www.developer.com/java/other/article.php/3441391">
Processing Image Pixels Using Java: Controlling Contrast and Brightness</a>.&nbsp; This lesson 
builds upon those earlier lessons.&nbsp; You will need to understand the code in the 
lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> before the code in this lesson will make much sense.</p>
<p><font color="#FF0000"><b>Not a lesson on JAI</b></font></p>
<p>The lessons in this series do not provide instructions on how to use 
the Java Advanced Imaging <i>(JAI)</i> API.&nbsp; 
<i>(That will be the primary topic for a future series of lessons.)</i>&nbsp; The purpose of 
this series is to teach you how to implement common 
image-processing algorithms by 
working directly with the pixels.</p>
<p><font color="#FF0000"><b>A framework or driver program</b></font></p>
<p>The lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> provided and explained a program named <b>
ImgMod02</b> that makes it easy to:</p>
<ul>
	<li>Manipulate and modify the pixels that belong to an image.</li>
	<li>Display the processed image along with the original image.</li>
</ul>
<p>The lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> provided an upgraded version of that program named
<b>ImgMod02a</b>.&nbsp; <b>ImgMod02a</b> serves as a driver that controls 
the execution of a second program that actually processes the pixels.</p>The program that I will explain in this lesson runs under the control of <b>
ImgMod02a</b>.&nbsp; 
In order to compile and run the program that I will provide in this lesson, you will need to go to the lessons entitled 
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> and 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> to get copies of the program 
named <b>ImgMod02a</b> and the interface named <b>ImgIntfc02</b>.<p><font color="#FF0000"><b>Purpose of this lesson</b></font></p>
<p>The purpose of this lesson is to teach you how to write a Java program that 
can be used to:</p>
<ul>
	<li>Control color intensity</li>
	<li>Apply color filtering</li>
	<li>Apply color inversion</li>
</ul>
<p>Future lessons will show you how to create a number of other special effects 
by directly modifying the pixels belonging to an image.&nbsp; </p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <a href="http://www.dickbaldwin.com">
www.DickBaldwin.com</a><font color="#000000">.</font></p>
<p><font color="#FF0000"><b>Sample program output</b></font></p>
<p>I will begin this lesson by showing you three examples of the types of things 
that you can do with this program.&nbsp; I will discuss the examples very 
briefly here and will discuss them in more detail later in the lesson.</p>
<p><font color="#FF0000"><b>Color intensity control</b></font></p>
<p>Figure 1 shows an example of color intensity control.&nbsp; The bottom image 
in Figure 1 is the result of reducing the intensity of every color pixel to 
fifty-percent of its original value.&nbsp; As you can see, this basically caused 
the intensity of the entire image to be reduced resulting in a darker image 
where the colors were somewhat washed out.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406a.jpg" width="334" height="714">

<b>Figure 1 Color intensity control example.</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>The user interface GUI</b></font></p>
<p>Figure 2 shows the state of the user interface GUI that produced Figure 1.&nbsp; 
Each of the three sliders in Figure 2 controls the intensity of one of the 
colors red, green, and blue.&nbsp; The intensity of each color can be adjusted 
within the range from 0% to 100% of its original value.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406b.jpg" width="221" height="331">

<b>Figure 2 Control for Fig. 1</b>
</pre></td>
</tr>
</table>
<p>Each of the sliders in Figure 2 was adjusted to a value of 50, causing the 
intensity of every color in every pixel to be reduced to 50% of its original 
value.</p>
<blockquote>
	<p><i>(Note that the check box at the top was not checked.&nbsp; I will 
	explain the purpose of this checkbox later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Color filtering</b></font></p>
<p>Figure 3 shows an extreme example of color filtering.</p>
<blockquote>
	<p><i>(I elected to provide an extreme example so that the results would be 
	obvious.)</i></p>
</blockquote>
<p>In Figure 1, there was no modification of any color relative to any other 
color.&nbsp; <i>(The value of every color was adjusted to 50% of its original 
value.)</i>&nbsp; However, in Figure 3, the relative intensities of the three colors 
were modified relative to each other.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406c.jpg" width="334" height="714">

<b>Figure 3 Color filtering example.</b>
</pre></td>
</tr>
</table>
<p>There was no change to the color values for any of the red pixels in Figure 
3.&nbsp; The color values for all of the green pixels were reduced to 50% of 
their original values.&nbsp; The color values for all blue pixels were reduced 
to zero.&nbsp; Thus, the color blue was completely eliminated from the output.</p>
<p>As you can see, modifying the pixel color values in this way caused the 
overall color of the processed image to be more orange than the original.</p>
<blockquote>
	<p><i>(Some would say that the processed image in Figure 3 is warmer than 
	the original image in Figure 3 because it emphasizes warm colors rather than 
	cool colors.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The user interface GUI for Figure 3</b></font></p>
<p>Figure 4 shows the state of the user interface GUI that produced Figure 3. </p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406d.jpg" width="221" height="331">

<b>Figure 4 Control for Fig. 3</b>
</pre></td>
</tr>
</table>
<p>The red slider in Figure 4 is positioned at 100, causing the red color 
values of all the pixels to remain unchanged.&nbsp; The green slider is 
positioned at 50, causing the green color values of all the pixels to be 
reduced to 50% of their original values.&nbsp; The blue slider is positioned at 
0 causing the blue color values of all pixels to be reduced to 0.</p>
<p>Once again the checkbox at the top of Figure 4 is not checked.&nbsp; I will 
explain the purpose of this checkbox in the next section.</p>
<p><font color="#FF0000"><b>Color inversion</b></font></p>
<p>Figure 5 shows an example of color inversion with no color filtering.</p>
<blockquote>
	<p><i>(Note that it is also possible to apply a combination of color 
	filtering and color inversion.)</i></p>
</blockquote>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406e.jpg" width="334" height="714">

<b>Figure 5 Color inversion example.</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>What is color inversion?</b></font></p>
<p>I will have a great deal to say about color inversion later in this lesson.&nbsp; 
For now, suffice it to say that color inversion causes a change to all the 
colors in an image.&nbsp; That change is computationally economical, reversible, 
and usually obvious to the viewer.&nbsp; As you can readily see, the colors in 
the processed image in Figure 5 are obviously different from the colors in the 
original image.</p>
<p><font color="#ff0000"><b>The user interface GUI for Figure 5</b></font></p>
<p>Figure 6 shows the state of the user interface GUI that produced Figure 5.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406f.jpg" width="221" height="331">

<b>Figure 6 Control for Fig. 5</b>
</pre></td>
</tr>
</table>
<p>The check box at the top of Figure 6 is checked, sending a message to the 
image-processing program to implement color inversion.</p>
<p>Each of the sliders in Figure 6 is positioned at 100.&nbsp; As a result, no 
color filtering was applied.&nbsp; As mentioned earlier, however, it is possible 
to combine color filtering with color inversion.&nbsp; In fact, by using comment 
indicators to enable and disable different blocks of code and recompiling, the 
program that I will discuss later makes it possible to combine color filtering and color inversion in two different ways:</p>
<ul>
	<li>Filter first and then invert.</li>
	<li>Invert first and then filter.</li>
</ul>
<p>The two different approaches can result in significantly different results.</p>
<p><font color="#FF0000"><b>Display format</b></font></p>
<p>The images shown in Figures 1, 3, and 5 were produced by the driver program named <b>
ImgMod02a</b>.&nbsp; The user interface GUIs in Figures 2, 4, and 6 were produced by the program named
<b>ImgMod15</b>.</p>
<p>As in all of the graphic output produced by the driver program 
named <b>ImgMod02a</b>, the 
original image is shown at the top and the processed image is shown at the 
bottom.</p>
<p><font color="#FF0000"><b>An interactive image-processing program</b></font></p>
<p>The image-processing program named <b>ImgMod15</b> illustrated by the above figures allows the user to 
interactively </p>
<ul>
	<li>Control the color intensity</li>
	<li>Apply color filtering</li>
	<li>Apply color inversion</li>
</ul>
<p>Color intensity and color filtering are controlled by adjusting the three 
sliders where each slider corresponds to one of the colors red, green, and blue.</p>
<p>Color inversion is controlled by checking or not checking the check box near 
the top of the GUI.</p>
<p>After making adjustments to the GUI, the user presses the <b>Replot</b> 
button shown at the bottom of Figures 1, 3, and 5 to cause the image to be 
reprocessed and replotted.</p>
<p><font color="#FF0000"><b>Theoretical basis and practical implementation</b></font></p>
<p>While discussing the lessons in this series, I will provide some of the theoretical basis for 
special-effects algorithms.&nbsp; In addition, I will show you how to implement those algorithms in Java.</p>
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p>The earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> provided a great deal of background 
information as to how images are constructed, stored, transported, and rendered.&nbsp; 
I won't repeat that material here, but will simply refer you to the earlier 
lesson.</p>
<p><font color="#FF0000"><b>File formats</b></font></p>
<p>The earlier lesson introduced and explained the concept of a pixel.&nbsp; In 
addition, the lesson provided a brief discussion of image files, and indicated 
that the program named <b>ImgMod02a</b> is compatible with <b>gif</b> files,
<b>jpg</b> 
files, and possibly some other file formats as well.</p>
<p><font color="#FF0000"><b>A three-dimensional array of pixel data as type int</b></font></p>
<p>The driver program named <b>ImgMod02a</b>:</p>
<ul>
	<li>Extracts the pixels from an image file.</li>
	<li>Converts the pixel data to type <b>int.</b></li>
	<li>Stores the pixel data in a three-dimensional array of type <b>int</b> that is 
	well suited for processing.</li>
	<li>Passes the three-dimensional array object's reference to an 
	image-processing program.</li>
</ul>
<p><font color="#FF0000"><b>Display of processed image results</b></font></p>
<p>When the image-processing program completes its work, the driver program 
named <b>ImgMod02a</b>:</p>
<ul>
	<li>Receives a reference to a three-dimensional array object containing 
	processed pixel data from the image-processing program.</li>
	<li>Displays the original image and the processed image in a stacked display 
	as shown in Figure 1.</li>
</ul>
<p><font color="#FF0000"><b>Reprocessing with different parameters</b></font></p>
<p>In addition, the way in which the two programs work together makes it possible for the user to:</p>
<ul>
	<li>Provide new input data to the 
	image-processing program.</li>
	<li>Invoke the image-processing program again.</li>
	<li>Create a new display showing the newly-processed image along with the 
	original image.</li>
</ul>
<p>The manner in which all of this communication between the programs is accomplished was explained in the earlier lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3403921">
Processing Image Pixels using Java, Getting Started</a>.</p>
<p><font color="#FF0000"><b>Will concentrate on the three-dimensional array of 
type int</b></font></p>
<p>This lesson will show you how to write 
an image-processing program that receives raw pixel data in the form of a three-dimensional array 
of type <b>int</b>, 
and returns processed pixel data in the form of a three-dimensional array of 
type <b>int</b>.&nbsp; The program is designed to achieve the image-processing 
objectives described earlier.</p>
<p><font color="#FF0000"><b>A grid of colored pixels</b></font></p>
<p>Each three-dimensional array object represents one image consisting of a 
grid of colored pixels.&nbsp; The pixels in the grid are arranged in rows 
and columns when they are rendered.&nbsp; One of the dimensions of the array represents rows.&nbsp; 
A second dimension represents columns.&nbsp; The third dimension represents the color <i>(and transparency)</i> of 
the pixels.</p>
<p><font color="#FF0000"><b>Fundamentals</b></font></p>
<p>Once again, I will refer you to the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> to learn:</p>
<ul>
	<li>How the primary colors of red, green, and blue and the transparency of a 
	pixel are represented by four <b><i>unsigned</i></b> 8-bit bytes of data.</li>
	<li>How specific colors are created by mixing different amounts of red, 
	green, and blue.</li>
	<li>How the range of each primary color and the range of transparency 
	extends from 0 to 255.</li>
	<li>How black, white, and the colors in between are created.</li>
	<li>How the overall color of each individual pixel is 
determined by the values stored in the three color bytes for that pixel, as 
	modified by the transparency byte.</li>
</ul>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p><font color="#FF0000"><b>Three programs and one interface</b></font></p>
<p>The program that I will discuss in this lesson requires the program named
<b>ImgMod02a</b> and the interface named <b>ImgIntfc02</b> for compilation and 
execution.&nbsp; I provided and explained that material in the earlier lessons 
entitled <a href="http://www.developer.com/java/other/article.php/3403921">
Processing Image Pixels using Java, Getting Started</a> and 
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a>. </p>
<p>I will present and explain a new Java program named <b>
ImgMod15</b> in this lesson.&nbsp; This program, when run under control of the program named <b>
ImgMod02a</b>, will produce outputs similar to those shown in Figures 1, 3, and 
5.</p>
<blockquote>
	<p><i>(The results will be different if you use a different image 
	file or provide different user input values.)</i></p>
</blockquote>
<p>I will also provide, <i>(but will not explain)</i> a simple program named <b>
ImgMod27</b>.&nbsp; This program can be used to display <i>(in 128 different 
panels)</i> all of the 16,777,216 different colors that can be produced using 
three primary colors, each of which can take on any one of 256 values.&nbsp; The 
different colors are displayed in groups of 131,072 colors in each panel.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The program named <b>ImgMod15</b>, <i>(and all 
image-processing programs that are capable of being driven by <b>ImgMod02a</b>),</i> 
must implement the interface named <b>ImgIntfc02</b>.&nbsp; That interface 
declares a single method named <b>processImg</b>, which must be defined by all 
implementing classes.</p>
<p>When the user runs the program named <b>ImgMod02a</b>, that program 
instantiates an object of the image-processing program class and invokes the <b>
processImg</b> method on that object.</p>
<p>A three-dimensional array containing the pixel data 
for the image is passed to the method.&nbsp; The <b>processImg</b> method must 
return a 
three-dimensional array containing the pixel data for a processed version of the 
original image.</p>
<p><font color="#FF0000"><b>A <i>before</i> and <i>after</i> display</b></font></p>
<p>When the <b>processImg</b> method returns, the driver program named<b> 
ImgMod02a </b>causes the 
original image and the processed image to be displayed in a frame 
with the original image above the processed image <i>(see Figure 1 for 
an example of the display format).</i></p>
<p><font color="#FF0000"><b>Usage information for ImgMod02a and ImgMod15</b></font></p>
<p>To use the program named <b>ImgMod02a</b> to drive the program named <b>
ImgMod15</b>, enter the following at the 
command line: </p>
<b><pre>java ImgMod02a ImgMod15 ImagePathAndFileName</pre></b> </p>
<p><font color="#FF0000"><b>The image file</b></font></p>
<p>The image file can be a <b>gif</b> file or a 
<b>jpg</b> file.&nbsp; 
Other file types may be compatible as well.&nbsp; If the program is unable to load the image file within ten 
seconds, it will abort with an error message.</p>
<blockquote>
	<p><i>(You should be able to right-click on the images in Figures 16, 17, 
	and 18 to download and save the images used in this lesson.&nbsp; Then you should be able to replicate the 
	results shown in 
	the various figures in this lesson.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Image display format</b></font></p>
<p>When the program is started, the original image and the processed image are 
displayed in a frame with the original image above the processed image.&nbsp; 
The two images are identical when the program first starts running.</p>
<p>A
<b>Replot</b> button appears at the bottom of the frame. If the user clicks the
<b>Replot</b> button, the <b>processImg</b> method is rerun, the image is 
reprocessed, and the new version of the processed image replaces the old version 
in the display. </p>
<p><font color="#FF0000"><b>Input to the image-processing program</b></font></p>
<p>The image-processing program named <b>ImgMod15</b> provides a GUI for user input, 
as shown in Figure 2.&nbsp; The sliders on the GUI make it possible for the user to provide different 
filter values for red, green, and blue each time the image-processing method is rerun.&nbsp; 
The check box near the top of the GUI makes it possible for the user to request 
that the colors in the image be inverted.</p>
<p>To rerun the 
image-processing method with different parameters, adjust the sliders, 
optionally check the check box in the GUI, and then press the <b>
Replot</b> button at the bottom of the main display.</p>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p><font color="#FF0000"><b>The program named ImgMod15</b></font></p>
<p>This program illustrates how to control color intensity, apply 
color filters, and apply color inversion to an image.</p>
<p>The program is designed to be driven by the program named <b>ImgMod02a</b>.</p>
<p><font color="#FF0000"><b>The <i>before</i> and <i>after</i> images</b></font></p>
<p>The program places two GUIs on the screen.&nbsp; One GUI displays the 
&quot;before&quot; and &quot;after&quot; versions of an image that is subjected to color intensity 
control, color filtering, and color inversion.</p>
<p>The image at the top of this GUI is the &quot;before&quot; image. The image at the 
bottom is the &quot;after&quot; image.&nbsp; An example is shown in Figure 1.</p>
<p><font color="#FF0000"><b>The user interface GUI</b></font></p>
<p>The other GUI provides instructions and components by which the user can 
control the processing of the image.&nbsp; An example of the user interface GUI 
is shown in Figure 2.</p>
<p>A check box appears near the top of this GUI.&nbsp; If the user checks the 
check box, color inversion is performed.&nbsp; If the check box is not checked, 
no color inversion is performed.</p>
<p>This GUI also provides three sliders that make it possible for the user to 
control color intensity and color filtering.&nbsp; Each slider controls the 
intensity of a single color.&nbsp; The intensity control ranges from 0% to 100% 
of the original intensity value for each color for every pixel.</p>
<p><font color="#FF0000"><b>Controlling color intensity</b></font></p>
<p>If all three sliders are adjusted to the same value and the replot button is 
pressed, the overall intensity of the image is modified with no change in the 
relative contribution of each color.&nbsp; This makes it possible to control the 
overall intensity of the image from very dark <i>(black)</i> to the maximum 
intensity supported by the original image.&nbsp; This is illustrated in Figure 
1.</p>
<p><font color="#FF0000"><b>Color filtering</b></font></p>
<p>If the three sliders are adjusted to different values and the replot button 
is pressed, color filtering occurs.&nbsp; In this case, the intensity of each 
color is changed relative to the intensity of the other colors.&nbsp; This makes 
it possible, for example to adjust the &quot;warmth&quot; of the image by emphasizing red 
over blue, or to make the image &quot;cooler&quot; by emphasizing blue over red.&nbsp; 
This is illustrated in Figure 3.</p>
<p><font color="#FF0000"><b>A greenscale image</b></font></p>
<p>It is also possible to totally isolate and view the individual contributions 
of red, green, and blue to the overall image as illustrated in Figure 7.</p>
<p>The values for red and blue were set to zero for all of the pixels in the 
processed image in Figure 7.&nbsp; This leaves only the differing green values 
for the individual pixels, producing what might be thought of as a <i>greenscale</i> 
image <i>(in deference to the use of the term grayscale for a common class of 
black, gray, and white images).</i></p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406g.jpg" width="334" height="714">

<b>Figure 7 Green color filter example.</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>The user interface GUI for Figure 7</b></font></p>
<p>Figure 8 shows the state of the user interface GUI that produced the 
processed image in Figure 7.&nbsp; As you can see, the sliders for red and blue 
were set to zero causing all red and blue color values to be set to zero.&nbsp; 
The slider for green was set to 100 causing the green value for every pixel to 
remain the same as in the original image.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406h.jpg" width="221" height="331">

<b>Figure 8 Control for Fig. 7</b>
</pre></td>
</tr>
</table>
<p>The checkbox was not checked.&nbsp; Therefore, color inversion was not 
performed.</p>
<p><font color="#FF0000"><b>Which comes first, the filter or the inversion?</b></font></p>
<p>As written, the program applies color filtering before it applies color inversion.&nbsp; 
As you will see later, sample code is also provided that can be used to modify 
the program to cause it to provide color inversion before it applies color filtering.&nbsp; 
There is a significant difference in the results produced by these two approaches, and you may want to experiment with them.</p>
<p><font color="#FF0000"><b>A practical example of color inversion</b></font></p>
<p>As a side note, Microsoft Word and Microsoft FrontPage appear to 
use color inversion to change the colors in images that have been selected 
for editing.&nbsp; I will have more to say about this later.</p>
<p><font color="#FF0000"><b>Beware of transparent images</b></font></p>
<p>This program illustrates the modification of red, green, and blue values 
belonging to all the pixels in an image.&nbsp; It 
works best with an image that contains no transparent areas.&nbsp; The pixel 
modifications performed in this program have no impact on transparent pixels.&nbsp; 
Therefore, if you don't see what you expect when you process an image, it may be because 
your image contains transparent pixels.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font> </p>
<p>I will break the program down into fragments for discussion.&nbsp; A complete 
listing of the program is provided in Listing 8 near the end of the 
lesson.</p>
<p><font color="#FF0000"><b>The ImgMod15 class</b></font></p>
<p>The ImgMod15 class begins in Listing 1.&nbsp; In order 
to be suitable for being driven by the program named <b>ImgMod02a</b>, this 
class must implement the interface named <b>ImgIntfc02</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class ImgMod15 extends Frame
                           implements ImgIntfc02{

  //GUI components used to control color
  // filtering and color inversion.
  JSlider redSlider;
  JSlider greenSlider;
  JSlider blueSlider;
  JCheckBox checkBox;

<b>Listing 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The class extends <b>Frame</b>, because an object of this class is the user 
interface GUI shown in Listings 2, 4, 6, and 8.&nbsp; The code in Listing 1 
declares four instance variables that will refer to the check box and the three 
sliders in Figure 8.</p>
<p><font color="#FF0000"><b>The constructor for ImgMod15</b></font></p>
<p>The constructor is shown in its entirety in Listing 2.&nbsp; Because of the 
way that an object of the class is instantiated by <b>ImgMod02a</b>, the 
constructor is not allowed to take any parameters.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  ImgMod15(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    //Provide user instructions at the top of the
    // GUI.
    add(new Label(
            "Adjust Color Sliders and Replot."));
    
    //Provide a check box that is used to request
    // color inversion.
    checkBox = new JCheckBox();
    add(new Label("Check to Invert Colors"));
    add(checkBox);
    
    //Create three sliders each with a range of
    // 0 to 100 and an initial value of 100.
    redSlider = new JSlider(0,100,100);
    add(redSlider);
    //Put a label under the slider.
    add(new Label("Red"));

    greenSlider = new JSlider(0,100,100);
    add(greenSlider);
    add(new Label("Green"));

    blueSlider = new JSlider(0,100,100);
    add(blueSlider);
    add(new Label("Blue"));
    
    //Put numeric labels and tick marks on the
    // sliders.
    redSlider.setMajorTickSpacing(20);
    redSlider.setMinorTickSpacing(5);
    redSlider.setPaintTicks(true);
    redSlider.setPaintLabels(true);
    
    greenSlider.setMajorTickSpacing(20);
    greenSlider.setMinorTickSpacing(5);
    greenSlider.setPaintTicks(true);
    greenSlider.setPaintLabels(true);
    
    blueSlider.setMajorTickSpacing(20);
    blueSlider.setMinorTickSpacing(5);
    blueSlider.setPaintTicks(true);
    blueSlider.setPaintLabels(true);

    setTitle("Copyright 2005, Baldwin");
    setBounds(400,0,220,330);
    setVisible(true);
  }//end constructor

<b>Listing 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Although the code in Listing 2 is rather long, all of the code in Listing 2 
is straightforward if you are familiar with the construction of 
GUIs in Java.&nbsp; If you are not familiar with such constructions, you 
should study some of my other lessons on this topic.&nbsp; As mentioned earlier, 
you will find an index to all of my lessons at
<a href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font color="#000000">.</font> </p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>To be compatible with <b>ImgMod02a</b>, the image-processing program must implement the interface named <b>
ImgIntfc02</b>.&nbsp; A listing of that interface was provided in the earlier 
lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; That interface declares a single method with the following 
signature:</p><b><pre>
int[][][] processImg(int[][][] threeDPix, 
                     int imgRows, 
                     int imgCols);</pre></b></p>
<p>The first parameter is a reference to an incoming three-dimensional array of pixel data stored as 
type <b>int</b>.&nbsp; The second and third parameters specify the number of rows 
and the number of columns of pixels in the image.</p>
<p>The beginning of the <b>processImg</b> method is shown in Listing 3.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public int[][][] processImg(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    //Make a working copy of the 3D array to
    // avoid making permanent changes to the
    // raw image data.
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

<b>Listing 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>It's best to make and modify a copy</b></font></p>
<p>Normally the <b>processImg</b> 
method should make a copy of the incoming 
array and process the copy rather than modifying the original.&nbsp; Then the 
method should return a reference to the processed copy of the three-dimensional pixel array.&nbsp; 
The code in Listing 3 makes such a copy.</p>
<p><font color="#FF0000"><b>Get the slider values</b></font></p>
<p>The code in Listing 4 gets the current values of each of the three sliders.&nbsp; 
This information will be used to scale the red, green, and blue pixel values to 
new values in order to implement color intensity control and color filtering.&nbsp; 
The new color values can range from 0% to100% of the original values </p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    int redScale = redSlider.getValue();
    int greenScale = greenSlider.getValue();
    int blueScale = blueSlider.getValue();

<b>Listing 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Process each color value</b></font></p>
<p>The code in Listing 5 is the beginning of a <b>for</b> loop that is used to 
process each color value for every pixel.&nbsp; The boldface code in Listing 5 
is executed for the case where the check box near the top of Figure 2 has not 
been checked.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        if(!checkBox.isSelected()){
          //Apply color filtering but no color
          // inversion
<b>          temp3D[row][col][1] = 
              temp3D[row][col][1] * redScale/100;
          temp3D[row][col][2] = 
            temp3D[row][col][2] * greenScale/100;
          temp3D[row][col][3] = 
             temp3D[row][col][3] * blueScale/100;</b>

<b>Listing 5</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>In this case, each color value for every pixel is multiplied by a scale 
factor that is determined by the position of the slider corresponding to that 
color.&nbsp; In effect, the product of the color value and the scale factor 
causes the processed color value to range from 0% to 100% of the original color 
value.</p>
<p>Note that the code in Listing 5 is the first half of an <b>if-else</b> 
statement.</p>
<p><font color="#FF0000"><b>Apply color inversion</b></font></p>
<p>In the event that the color-inversion check box is checked, the boldface code 
in Listing 6 is executed instead of the boldface code in Listing 5.&nbsp; The 
code in Listing 6 first applies color filtering using the slider values and then 
applies color inversion.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        }else{
<b>          temp3D[row][col][1] = 255 - 
              temp3D[row][col][1] * redScale/100;
          temp3D[row][col][2] = 255 - 
            temp3D[row][col][2] * greenScale/100;
          temp3D[row][col][3] = 255 - 
             temp3D[row][col][3] * blueScale/100;</b>

<b>Listing 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The formula for color inversion</b></font></p>
<p>Recall that an individual color value can fall anywhere in the range from 0 to 255.&nbsp; 
The code in Listing 6 performs color inversion by subtracting the scaled color 
value from 255.&nbsp; Therefore, a scaled color value of 200 would be inverted 
into a value of 55.&nbsp; Likewise, a scaled color value of 55 would be inverted 
into a value of 200.&nbsp; Thus, the inversion process can be reversed simply by 
applying it twice in succession.</p>
<p>Since it may not be obvious what the results of such an operation will be, 
I will discuss the ramifications of color inversion in some detail.</p>
<p><font color="#FF0000"><b>An experiment</b></font></p>
<p>Let's begin with an experiment.&nbsp; You will need access to either 
Microsoft Word or Microsoft FrontPage to perform this experiment.</p>
<p><font color="#FF0000"><b>Get and save the image</b></font></p>
<p>Figure 5 shows the result of performing color inversion on an image of a 
starfish.&nbsp; 
The original image is shown at the top of Figure 5 and the color-inverted image 
is shown at the bottom of Figure 5.&nbsp; Begin the experiment by right-clicking 
the mouse on the image in Figure 5 and saving the image locally on your disk.</p>
<p><font color="#FF0000"><b>Insert the image into a Word or FrontPage document</b></font></p>
<p>Now create a new document in either Microsoft Word or Microsoft FrontPage and 
type a couple of paragraphs of text into the new document.</p>
<p>Insert the image that you saved between the paragraphs in your document.&nbsp; It 
should be the image with the tan starfish at the top and the blue starfish at 
the bottom.</p>
<p><font color="#FF0000"><b>Select the image</b></font></p>
<p>Now use your mouse and select some of the text from both paragraphs.&nbsp; 
Include the image between the paragraphs in the selection.&nbsp; If your system 
behaves like mine, the starfish at the top should turn blue and the starfish at 
the bottom should turn tan.&nbsp; In other words, the two images should be 
exactly the same except that their positions should be reversed.</p>
<p><font color="#FF0000"><b>What does this mean?</b></font></p>
<p>Whenever an image is selected in an editor program like Microsoft Word or 
Microsoft FrontPage, some visual change must be made to the image so that the 
user will know that the image has been selected.&nbsp; It appears that Microsoft 
inverts the colors in selected images in Word and FrontPage 
for this purpose.</p>
<blockquote>
	<p><i>(Note, however, that the Netscape browser, the Netscape 
Composer, and the Internet Explorer browser all use a different method for 
indicating that an image has been selected, so this is not a universal approach.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Why use inverted colors?</b></font></p>
<p>Color inversion is a very good way to change the colors in a 
selected image.&nbsp; The approach has several very good qualities.</p>
<p><font color="#FF0000"><b>Computationally economical</b></font></p>
<p>To begin with, inverting the colors is computationally economical.&nbsp; All that is required 
computationally to invert the colors is to subtract each color value from 255.&nbsp; This is much 
less demanding of computer resources than would be the case if the computation required multiplication or division, for example.</p>
<p><font color="#FF0000"><b>Overflow is not possible</b></font></p>
<p>Whenever you modify the color values in a pixel, you must be very careful to 
make sure that the new color value is within the range from 0 to 255.&nbsp; 
Otherwise, serious overflow problems can result.&nbsp; The inversion process 
guarantees that the new color value will fall within this range, so overflow is 
not possible.</p>
<p><font color="#FF0000"><b>A reversible process</b></font></p>
<p>The process is guaranteed to be reversible with no requirement to maintain any 
information outside the image regarding the original color values in the image.&nbsp; 
All that is required to 
restore the inverted color value back to the original color value is to subtract the inverted color value from 255.&nbsp; 
The original color value is restored after two successive inversions.&nbsp; Thus, it is 
easy and economical to switch back and forth between original color values and 
inverted color values.</p>
<p>Given all of the above, I'm surprised that the color-inversion process isn't 
used by programs other than Word and FrontPage.</p>
<p><font color="#FF0000"><b>Another example of color inversion</b></font></p>
<p>The color values in a digitized color film negative are similar to <i>(but 
not identical to)</i> the inverse of the colors in the corresponding color film 
positive.&nbsp; Therefore, some photo processing programs begin the process of 
converting a digitized color film negative to a positive by inverting the 
colors. Additional color adjustments must usually be made after inversion to get 
the colors just right.</p>
<p>You will find an interesting discussion of this process in an article 
entitled <a href="http://www.macedition.com/feat/film/feat_film_20030626.php">
Converting negative film to digital pictures</a> by Phil Williams.</p>
<p><font color="#FF0000"><b>What will the inverted color be?</b></font></p>
<p>Another interesting aspect of color inversion has to do with knowing what 
color will be produced by applying color inversion to a pixel with a given 
color.&nbsp; For this, let's look at another example shown in Figures 9 and 10.</p>
<p>Figure 9 shows the result of applying color inversion to the pure primary 
colors red, green, and blue.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406i.jpg" width="149" height="102">

<b>Figure 9 Color inversion
for primary colors.</b>
</pre></td>
</tr>
</table>
<p>The color bar at the top in Figure 9 shows the three primary colors.&nbsp; 
The color bar at the bottom shows the corresponding inverted colors.</p>
<p><font color="#FF0000"><b>No color filtering was applied</b></font></p>
<p>Figure 10 shows that no color filtering was involved.&nbsp; The colors shown 
in the bottom image of Figure 9 are solely the result of performing color 
inversion on the top image in Figure 9.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406j.jpg" width="221" height="328">

<b>Figure 10 Control for Fig 9</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>Experimental results</b></font></p>
<p>From Figure 9, we can conclude experimentally that applying color inversion 
to a pure red pixel will cause the new pixel color to be aqua.&nbsp; Similarly, 
applying color inversion to a pure green pixel will cause the new pixel color to 
be fuchsia.&nbsp; Finally, applying color conversion to a pure blue pixel will 
cause the new pixel color to be yellow.&nbsp; To summarize:</p>
<ul>
	<li>Red inverts to aqua</li>
	<li>Green inverts to fuchsia</li>
	<li>Blue inverts to yellow</li>
</ul>
<p><font color="#FF0000"><b>An explanation of the results</b></font></p>
<p>Consider why the experimental results turn out the way that they do.&nbsp; 
Consider the case of the pure blue pixel.&nbsp; The red, green, and blue color 
values for that pixel are as shown below:</p>
<ul>
	<li>R = 0</li>
	<li>G = 0</li>
	<li>B = 255</li>
</ul>
<p>Let the inverted color values be given by R', G', and B'.&nbsp; Looking back 
at the code in Listing 6 <i>(with no color filtering applied)</i>, the color 
values for the pixel following the inversion will be:</p>
<ul>
	<li>R' = 255 - 0 = 255</li>
	<li>G' = 255 - 0 = 255</li>
	<li>B' = 255 - 255 = 0</li>
</ul>
<p><font color="#FF0000"><b>The inverted color is yellow</b></font></p>
<p>Thus we end up with a pixel having full color intensity for red and green and 
no intensity for blue.&nbsp; What do we get when we mix red and green in equal 
amounts?&nbsp; The 
answer is yellow.&nbsp; Adding equal amounts of red and green produces yellow.&nbsp; Hence, the inverted color for a pure blue 
pixel is yellow, as shown in Figure 9 and explained on the basis of the 
arithmetic.</p>
<p>We could go through a similar argument to determine the colors resulting from 
inverting pure red and pure green.&nbsp; The answers, of course, would be aqua 
for red and fuchsia for green.</p>
<p><font color="#FF0000"><b>A more difficult question</b></font></p>
<p>What colors are produced by inverting pixels that are not pure red, green, or 
blue, but rather consist of weighted mixtures of red, green, and blue?</p>
<p>The answer to this question requires a bit of an extrapolation on our part.&nbsp; First, 
let's establish the colors that result from mixing equal amounts of the three 
primary colors in pairs.</p>
<ul>
	<li>red + green = yellow <i>(bottom right in Figure 9)</i></li>
	<li>red + blue = fuchsia <i>(bottom center in Figure 9)</i></li>
	<li>green + blue = aqua <i>(bottom left in Figure 9)</i></li>
</ul>
<p><font color="#FF0000"><b>A simple color wheel</b></font></p>
<p>Now let's construct a simple color wheel.&nbsp; Draw a circle and mark 
three points on the circle at 0 degrees, 120 degrees, and 240 degrees.&nbsp; 
Label the first point red, the second point green, and the third point blue.</p>
<p>Now mark three points on the circle half way between the three points 
described above.&nbsp; Label each of these points with the color that results 
from mixing equal quantities of the colors identified with that point's neighbors.&nbsp; For 
example, the point half way between red and green would be labeled yellow.&nbsp; 
The point half way between green and blue would be labeled aqua, and the point 
half way between blue and red would be labeled fuchsia.</p>
<p><font color="#FF0000"><b>Look across to the opposite side</b></font></p>
<p>Now note the color that is on the opposite side of the circle from each of 
the primary colors.&nbsp; Aqua is opposite of red.&nbsp; Fuchsia is opposite of 
green, and yellow is opposite of blue.&nbsp; Comparing this with the colors 
shown in Figure 9, we see that the color that results from inverting one of the 
primary colors on the circle is the color that appears on the opposite side of 
the color wheel.</p>
<p><font color="#FF0000"><b>A reversible process</b></font></p>
<p>Earlier I told you that the inversion process is reversible.&nbsp; For 
example, if we have a full-intensity yellow pixel, the color values for that pixel will be:</p>
<ul>
	<li>R = 255</li>
	<li>G = 255</li>
	<li>B = 0</li>
</ul>
<p>If we invert the colors for that pixel, the result will be:</p>
<ul>
	<li>R' = 255 - 255 = 0</li>
	<li>G' = 255 - 255 = 0</li>
	<li>B' = 255 - 0 = 255</li>
</ul>
<p>Thus, the color of the inverted yellow pixel is blue, which is the color that is 
opposite yellow on the circle.</p>
<p><font color="#FF0000"><b>General conclusion</b></font></p>
<p>In general, we can conclude that if we 
invert a pixel whose color corresponds to a color at a point on the color wheel, <i>(such 
as the color wheel shown in Figure 11),</i> the color of the inverted pixel will match 
the color at the corresponding point on the opposite side of the color wheel.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406k.jpg" width="200" height="200">

<b>Figure 11 Color wheel.</b>
</pre></td>
</tr>
</table>
<p><b><font color="#FF0000">Experimental confirmation</font></b></p>
<p>We can demonstrate this experimentally by inverting the image of 
the color wheel without performing any color filtering.&nbsp; The result of such 
an inversion is shown in the bottom half of Figure 12.&nbsp; Once again, the original image of the 
color wheel is shown at the top, and the inverted image of the color wheel is 
shown at the bottom.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406l.jpg" width="210" height="454">

<b>Figure 12 Inverted color
wheel.</b>
</pre></td>
</tr>
</table>
<p>As you can see in Figure 12, each of the colors in the original image moved 
to the opposite side of the wheel when the color wheel was inverted.</p>
<p>Also, you can see from Figure 12 that white pixels turn into black pixels and 
black pixels turn into white pixels when they are inverted.&nbsp; You should be 
able to explain that by considering the color values for black and white pixels 
along with the inversion formula.</p>
<p><font color="#FF0000"><b>Another exercise</b></font></p>
<p>Another exercise might be useful.&nbsp; It might be possible to use the color wheel in Figure 11 to explain what happened to the colors when the starfish image was inverted 
in Figure 5.&nbsp; Pick a point on the starfish in the original image in Figure 5 and note the 
color of that point.&nbsp; Then find a point on the color wheel of Figure 11 
whose color matches that point.&nbsp; Then find the corresponding point on the 
opposite side of the color wheel.&nbsp; The color of that point should match the 
color of the corresponding point on the inverted starfish image at the bottom of 
Figure 5.</p>
<p><font color="#FF0000"><b>May not have found the matching point</b></font></p>
<p>A potential problem here is that you may not be able to find a point 
on the color wheel that matches the color of a point on the starfish.&nbsp; That is because 
any individual pixel on the starfish can take on any one of 16,777,216 
different colors.&nbsp; The colors shown on the color wheel are a small 
subset of that total and may not include the color of a specific point on the 
starfish.</p>
<p><font color="#FF0000"><b>Difficulty of displaying 3-dimensional data</b></font></p>
<p>The problem that we have here is the classic problem of trying to represent a 
three-dimensional entity in a two-dimensional display medium.&nbsp; Pixel color is a three-dimensional 
entity, with the dimensions being red, green, and blue.&nbsp; Any of the 
three color values belonging to a pixel can take on any one of 256 different 
values.&nbsp; It is very difficult to represent that on a flat two-dimensional 
screen, and a color wheel is just one of many schemes that have devised in an 
attempt to do so.</p>
<p><font color="#FF0000"><b>Could display as a cube</b></font></p>
<p>One way to represent these 16,777,216 colors is as a large cube having 
eight corners and six faces.&nbsp; Consider the large cube to be made up of 
16,777,216 small cubes, each being a different color.&nbsp; Arrange the small 
cubes so as to form the large cube with 256 cubes <i>(colors)</i> along each edge.&nbsp; Thus, 
each face is a square with 256 small cubes along each side.</p>
<p>Arrange the small cubes so that the colors of the cubes at the corners 
on one face are black, blue, green, and aqua as shown in the top half of Figure 13.&nbsp; Arrange the remaining 
cubes 
on that face to contain the same colors in the same order as that shown in the top half of Figure 13.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406p.jpg" width="277" height="552">

<b>Figure 13 Colors on one face at
top. Inverse colors at bottom.</b>
</pre></td>
</tr>
</table>
<blockquote>
	<p><i>(The colors in the bottom half of Figure 13 are the inverse of the 
	colors shown in the top half.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The opposite face</b></font></p>
<p>Arrange the small cubes such that the diagonal corners on the opposite face 
are set to white, yellow, red, and fuchsia as shown in the top half of Figure 
14.&nbsp; Recall that these colors are the inverse of black, 
blue, green, and aqua.&nbsp; Arrange additional small cubes such that 
the colors on that face progress in an orderly manner between the colors at the corners 
as shown in the top half of Figure 14.</p>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406q.jpg" width="277" height="552">

<b>Figure 14 Colors on opposite face
at top.  Inverse colors at bottom.</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>Inverse colors</b></font></p>
<p>Each of the colors in the top half of Figure 14 is the inverse of the color 
at the diagonally opposite location on the face shown in Figure 13.&nbsp; For 
example, the yellow hues near the bottom left corner of Figure 14 are the inverse of 
the blues hues near the upper right corner in Figure 13.</p>
<blockquote>
	<p><i>(Also, the colors in the bottom half of Figure 14 are the inverse of 
	the colors at the corresponding locations in the upper half of Figure 14.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Can't show all 16,777,216 colors</b></font></p>
<p>In order for me to show you all 16,777,216 colors, I would have to display 
128 panels like those shown in Figures 13 and 14.&nbsp; Each panel would 
represent two slices cut through the cube parallel to the two faces shown in Figures 
13 and 14.</p>
<blockquote>
	<p><i>(The top half of the panel would represent one slice and the bottom 
	half would represent the other slice.)</i></p>
</blockquote>
<p>Each slice would represent the colors produced by combining a different value 
for red with all possible combinations of the values for green and blue. 
Obviously, it would be impractical for me to attempt to display 128 such panels 
in this lesson.</p>
<blockquote>
	<p><i>(Because each panel shows the raw colors at the top and the inverse 
	colors at the bottom, only 128 such panels would be required.&nbsp; If only 
	the raw colors were shown in each panel, 256 panels would be required to 
	show all 16,777,216 colors.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Two slices from inside the cube</b></font></p>
<p>The top half of Figure 15 shows a slice through the cube for a red value of 
50 combined with all possible values for green and blue.&nbsp; The bottom half 
shows a slice for the inverse red value given by (255 - 50) or 205.</p>
<blockquote>
	<p><i>(Once again, the colors in the bottom half of Figure 15 are the 
	inverse of the colors in the top half of Figure 15.)</i></p>
</blockquote>
<table bgcolor="#00ffff" border="1" cols="1">
<tr>
<td>
<pre><img border="0" src="java406r.jpg" width="277" height="552">

<b>Figure 15 A single slice through
the cube for a red value of 50.</b>
</pre></td>
</tr>
</table>
<p><font color="#FF0000"><b>You can generate the colors yourself</b></font></p>
<p>Since it is impractical for me to show you all 16,777,216 colors and their 
inverse, I am going to do the next best thing.&nbsp; Listing 9 contains the 
program named <b>ImgMod27</b> that I used to produce the output shown in Figures 
13, 14, and 15.&nbsp; You can compile this program and run it yourself for any 
value of red from 0 to 255.&nbsp; Just enter the red value as a command-line 
parameter.</p>
<p>The top half of the output produced by the program displays the 65,536 colors 
represented by a single slice through the cube parallel to the faces shown in 
Figures 13 and 14.&nbsp; The bottom half of the output in each case represents 
the inverse of the colors shown in the top half.</p>
<p><font color="#FF0000"><b>Most colors don't have names</b></font></p>
<p>Most of the different colors don't have names, and even if they all did have 
names, most of us wouldn't have them all memorized.&nbsp; Therefore, it is 
impossible for me to describe in a general sense the color that will be produced 
by inverting a pixel having one of the 16,777,216 possible colors.</p>
<p><font color="#FF0000"><b>Contribution of red, green, and blue</b></font></p>
<p>By doing a little arithmetic, I can describe the inverse color numerically by 
indicating the contribution of red, green, and blue, but most of us would probably have difficulty seeing the color in our mind's eye 
even if we knew the contribution of red, green, and blue.</p>
<p>The colors that result from some 
combinations of red, green, and blue are intuitive, and others are not.&nbsp; For 
example, I have no difficulty picturing that red plus blue produces fuchsia, and 
I have no difficulty picturing that green plus blue produces aqua.&nbsp; 
However, I am unable to picture that red plus green produces yellow.&nbsp; 
That seems completely counter-intuitive to me.&nbsp; I don't see anything in 
yellow that seems to derive from either red or green.</p>
<p>Of course, things get even 
more difficult when we start thinking about mixtures of different contributions 
of all three of the primary colors.</p>
<p><font color="#FF0000"><b>Back to experimentation</b></font></p>
<p>So, that brings us back to experimentation.&nbsp; The program in Listing 9 
can be used to produce any of the 16,777,216 colors in groups of 65,536 colors, 
along with the inverse of each color in the group.&nbsp; Perhaps you can 
experiment with this program to produce the color that matches a point on the 
starfish at the top of Figure 5.&nbsp; If so, the inverse color shown in your 
output will match the color shown in the corresponding point on the starfish at 
the bottom of Figure 5.</p>
<p>And that is probably more than you ever wanted to hear about color inversion.</p>
<p><font color="#FF0000"><b>The remaining code</b></font></p>
<p>Now back to the main program named <b>ImgMod15</b>.&nbsp; The remaining code in the program is shown in Figure 7.</p>
<blockquote>
	<p><i>(Note that the boldface code in Listing 7 is inside a comment block.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          /*Compile the following block of code
             instead to invert before filtering.
          <b>temp3D[row][col][1] = (255 - 
             temp3D[row][col][1]) * redScale/100;
          temp3D[row][col][2] = (255 - 
           temp3D[row][col][2]) * greenScale/100;
          temp3D[row][col][3] = (255 - 
            temp3D[row][col][3]) * blueScale/100;</b>
          */ end comment block
        }//end else
      }//end inner loop
    }//end outer loop
    //Return the modified array of image data.
    return temp3D;
  }//end processImg
}//end class ImgMod15

<b>Listing 7</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>As I mentioned earlier, the boldface code in Listing 6 filters <i>(scales)</i> the pixel 
first and then inverts the pixel.&nbsp; In some cases, it might be useful to 
reverse this process by replacing the boldface code in Listing 6 with the 
boldface code in Listing 7.&nbsp; This code inverts the color of the pixel first 
and then applies the filter.&nbsp; If you filter and you also invert, the order 
in which you perform these two operations can be significant with respect to the 
outcome.</p>
<p>The remaining code in Listing 7 signals the end of the <b>processImg</b> 
method and the end of the <b>ImgMod15</b> class.</p>
<h2 align="center"><a name="Communication_between_the_Programs">Communication 
between the Programs</a></h2>
<p>In case you are interested in the details, this section describes how the 
program named <b>ImgMod02a</b> communicates with the image-processing program.&nbsp; 
If you aren't interested in this much detail, just skip to the section entitled
<a href="#Run_the_Programs">Run the Program</a>.</p>
<p><font color="#FF0000"><b>Instantiate an image-processing object</b></font></p>
<p>During execution, the program named <b>ImgMod02a</b> reaches a point where it has captured the 
pixel data from the original image file into a three-dimensional array of type <b>int</b> 
suitable for processing.&nbsp; Then it invokes the <b>newInstance</b> method of the 
class named <b>Class</b> to instantiate an object of the 
image-processing class.</p>
<p><font color="#FF0000"><b>Invoke the processImg method</b></font></p>
<p>At this point, the program named <b>ImgMod02a</b>:</p>
<ul>
	<li>Has the pixel data in the correct format</li>
	<li>Has an 
image-processing object that will process those pixels and will return an array 
containing processed pixel values&nbsp; </li>
</ul>
<p>All that the <b>ImgMod02a</b> program needs to do at this point is to invoke the <b>
processImg</b> method on the image-processing object passing the pixel data 
along with the number of rows and columns of pixels as parameters.</p>
<p><font color="#FF0000"><b>Posting a counterfeit ActionEvent</b></font></p>
<p>The <b>ImgMod02a</b> program posts a counterfeit <b>ActionEvent</b> to the system event queue 
and attributes the event to the <b>Replot</b> button.&nbsp; The result is 
exactly the same as if the user had pressed the <b>Replot</b> button shown in 
Figure 1.</p>
<p>In 
either case, the <b>actionPerformed</b> method is invoked on an <b>
ActionListener</b> object that is registered on the <b>Replot</b> button.&nbsp; 
The code in the <b>actionPerformed</b> method invokes the <b>processImg</b> 
method on the image-processing object.</p>
<p>The three-dimensional array of pixel data is passed to the <b>processImg</b> 
method.&nbsp; The <b>processImg</b> method returns a three-dimensional array of 
processed pixel data, which is displayed as an image below the original image as 
shown in Figure 1.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2>
<p>I encourage you to copy, compile, and run the programs named <b>ImgMod15 </b>
and<b> ImgMod27 </b>provided in this lesson.&nbsp; 
Experiment with them, making changes and observing the results of your changes.</p>
<p><font color="#FF0000"><b>Process a variety of images</b></font></p>
<p>Download a variety of images from the web and process those images with the 
program named <b>ImgMod15</b>.</p>
<blockquote>
	<p><i>(Be careful of transparent pixels when processing images that you have 
	downloaded from the web.&nbsp; Because of the quality of the data involved, 
	you will probably get better results from jpg images than from gif images.&nbsp; Remember, you will also need to copy the program named <b>ImgMod02a</b> 
	and the interface named <b>ImgIntfc02</b> from the earlier lessons entitled
	<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
	Image Pixels Using Java: Controlling Contrast and Brightness</a> and <a href="http://www.developer.com/java/other/article.php/3403921">
	Processing Image Pixels using Java, Getting Started</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>View a large number of different colors</b></font></p>
<p>Compute and observe the colors and their 
inverse for various slices through the color cube as provided by the program 
named <b>ImgMod27</b>.</p>
<p><font color="#FF0000"><b>Change the order of filtering and inversion</b></font></p>
<p>Run some experiments to determine the difference in results for various 
images based on filtering before inverting and on inverting before filtering.</p>
<blockquote>
	<p><i>(Of course, if you don't filter, it won't matter which approach you use.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Write an advanced filter program</b></font></p>
<p>Write an advanced version of the program that applies color filtering by 
allowing you to control both the location and the width of the distribution for 
each of the three colors separately.&nbsp; You can get some ideas on how to 
do this from the program entitled
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a>.</p>
<p><font color="#FF0000"><b>Replicate the results</b></font></p>
<p>To replicate the results shown in this lesson, right-click and download the jpg image files in 
Figures 17, 18, and 19 below.</p>
<p><font color="#ff0000"><b>Have fun and learn</b></font></p>
<p>Above all, have fun and use this program to learn as much as you can about 
manipulating images by modifying image pixels using Java.</p>
<p><font color="#FF0000"><b>Test images</b></font></p>
<p>Figures 17, 18, and 19 contain the jpg images that were used to produce the 
results shown in 
this lesson.&nbsp; You should be able to right-click on the images to download and 
save them locally.&nbsp; Then you should be able to replicate the results shown 
in this lesson.</p>
<p align="center"><img border="0" src="java406m.jpg" width="324" height="330"></p>
<p align="center">Figure 17</p>
<p align="center"><img border="0" src="java406n.jpg" width="139" height="24"></p>
<p align="center">Figure 18</p>
<p align="center"><img border="0" src="java406o.jpg" width="200" height="200"></p>
<p align="center">Figure 19</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I showed you how to write a Java program that can be used to:</p>
<ul>
	<li>Control color intensity</li>
	<li>Apply color filtering</li>
	<li>Apply color inversion</li>
</ul>
<p>I provided several examples of these capabilities.&nbsp; In 
addition, I explained some of the theory behind color inversion and showed you 
how to relate the colors on original and inverted pixels to points on a color 
wheel as well as pixels in a color cube.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons will show you how to write image-processing programs that 
implement many common special effects as well as a few that aren't so common.&nbsp; 
This will include programs to do the following:</p>
<ul>
	<li>Blur all or part of an image.</li>
	<li>Deal with the effects of noise in an image.</li>
	<li>Sharpen all or part of an image.</li>
	<li>Perform edge detection on an image.</li>
	<li>Morph one image into another image.</li>
	<li>Rotate an image.</li>
	<li>Change the size of an image.</li>
	<li>Other special effects that I may dream up or discover while doing the 
	background research for the lessons in this series.</li>
</ul>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program Listing</a>s</h2><p>
Complete listings of the programs discussed in this lesson are provided in 
Listings 8 and 9.</p>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>The programs that I will provide and explain in this series of lessons are 
not intended to be used for high-volume production work.&nbsp; Numerous 
integrated image-processing programs are available for that purpose.&nbsp; In 
addition, the Java Advanced Imaging API <i>(JAI)</i> has a number of built-in special effects if you prefer to write 
your own production image-processing programs using Java.</p>
<p>The programs that I will provide in this series are intended to 
make it easier for you to develop and experiment with image-processing algorithms and 
to gain a better understanding of how they work, and why they do what they do.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ImgMod15.java.java
Copyright 2005, R.G.Baldwin

This program illustrates color intensity control,
color filtering, and color inversion.

The program is designed to be driven by the
program named ImgMod02.  Enter the following at
the command line to run this program.

java ImgMod02 ImgMod15 gifFileName

The program places two GUIs on the screen. One
GUI displays the "before" and "after" images of 
an image that is subjected to color intensity 
cotrol, color filtering, and color inversion. The
image at the top is the "before" image.  The 
image at the bottom is the "after" image.

The other GUI provides instructions and 
components by which the user can control the
processing of the image.  A check box appears
near the top of this GUI.  If the user checks
the check box, color filtering is performed
before color inversion takes place.  If the
check box is not checked, no color inversion is
performed.

This GUI also provides three sliders that make
it possible for the user to control color 
intensity and filtering.  Each slider controls
the intensity of a single color.  The intensity 
control ranges from 0% to 100% of the original
intensity value for each pixel.

If all three sliders are adjusted to the same
percentage value and the replot button is 
pressed, the overall intensity of the image is
modified with no change in the relative
contribution of each color. This makes it 
possible to control the overall intensity of the
image from very dark (black) to the maximum
intensity supported by the image.

If the three sliders are adjusted to different
percentage values and the replot button is
pressed, color filtering occurs. By this, I mean
that the intensity of one color is changed
relative to the intensity of the other colors.
This makes it possible, for example to adjust the
"warmth" of the image by emphasizing red over
blue, or to make the image "cooler" by
emphasizing blue over red.  It is also possible
to totally isolate and view the contributions of
red, green, and blue to the overall image.

As written, the program applies color filtering
before color inversion.  Sample code is also 
provided that can be used to modify the program 
to cause it to provide color inversion before 
color filtering.  There is a significant 
difference in the results produced by these two
different approaches.

As an interesting side note, Microsoft Word and 
Microsoft FrontPage appear to use color 
inversion to change the colors in images that
have been selected for editing.

This program illustrates the modification of
the pixels in an image.  It works best with
an image file that contains no transparent areas.

The pixel modifications performed in this program
have no impact on transparent pixels.  If you
don't see what you expect, it may be because your
image contains transparent pixels.

Tested using JDK 1.5.0 and WinXP
************************************************/
import java.awt.*;
import javax.swing.*;

class ImgMod15 extends Frame
                           implements ImgIntfc02{

  //GUI components used to control color
  // filtering and color inversion.
  JSlider redSlider;
  JSlider greenSlider;
  JSlider blueSlider;
  JCheckBox checkBox;

  //Constructor must take no parameters
  ImgMod15(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    //Provide user instructions at the top of the
    // GUI.
    add(new Label(
            "Adjust Color Sliders and Replot."));
    
    //Provide a check box that is used to request
    // color inversion.
    checkBox = new JCheckBox();
    add(new Label("Check to Invert Colors"));
    add(checkBox);
    
    //Create three sliders each with a range of
    // 0 to 100 and an initial value of 100.
    redSlider = new JSlider(0,100,100);
    add(redSlider);
    //Put a label under the slider.
    add(new Label("Red"));

    greenSlider = new JSlider(0,100,100);
    add(greenSlider);
    add(new Label("Green"));

    blueSlider = new JSlider(0,100,100);
    add(blueSlider);
    add(new Label("Blue"));
    
    //Put numeric labels and tick marks on the
    // sliders.
    redSlider.setMajorTickSpacing(20);
    redSlider.setMinorTickSpacing(5);
    redSlider.setPaintTicks(true);
    redSlider.setPaintLabels(true);
    
    greenSlider.setMajorTickSpacing(20);
    greenSlider.setMinorTickSpacing(5);
    greenSlider.setPaintTicks(true);
    greenSlider.setPaintLabels(true);
    
    blueSlider.setMajorTickSpacing(20);
    blueSlider.setMinorTickSpacing(5);
    blueSlider.setPaintTicks(true);
    blueSlider.setPaintLabels(true);

    setTitle("Copyright 2005, Baldwin");
    setBounds(400,0,220,330);
    setVisible(true);
  }//end constructor

  //The following method must be defined to
  // implement the ImgIntfc02 interface.
  public int[][][] processImg(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    //Make a working copy of the 3D array to
    // avoid making permanent changes to the
    // raw image data.
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

    //Get the current values of the three
    // sliders.  This information will be used to
    // scale the red, green, and blue pixel
    // values to new values ranging from 0% to
    // 100% of the original values in order to 
    // implement color filtering.
    int redScale = redSlider.getValue();
    int greenScale = greenSlider.getValue();
    int blueScale = blueSlider.getValue();

    //Process each pixel value to apply color
    // filtering either with, or without color
    // inversion depending on the state of the
    // check box.
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        if(!checkBox.isSelected()){
          //Apply color filtering but no color
          // inversion
          temp3D[row][col][1] = 
              temp3D[row][col][1] * redScale/100;
          temp3D[row][col][2] = 
            temp3D[row][col][2] * greenScale/100;
          temp3D[row][col][3] = 
             temp3D[row][col][3] * blueScale/100;
        }else{
          //Apply color filtering with inversion.
          // Compile the following block of code
          // to filter before inverting.
          temp3D[row][col][1] = 255 - 
              temp3D[row][col][1] * redScale/100;
          temp3D[row][col][2] = 255 - 
            temp3D[row][col][2] * greenScale/100;
          temp3D[row][col][3] = 255 - 
             temp3D[row][col][3] * blueScale/100;
             
          /*Compile the following block of code
             instead to invert before filtering.
          temp3D[row][col][1] = (255 - 
             temp3D[row][col][1]) * redScale/100;
          temp3D[row][col][2] = (255 - 
           temp3D[row][col][2]) * greenScale/100;
          temp3D[row][col][3] = (255 - 
            temp3D[row][col][3]) * blueScale/100;
          */
        }//end else
      }//end inner loop
    }//end outer loop
    //Return the modified array of image data.
    return temp3D;
  }//end processImg
}//end class ImgMod15

<b>Listing 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ImgMod27.java Copyright 2005, R.G.Baldwin
Creates a Frame containing 65536 colors at the 
top and the inverse of those 65536 colors at the
bottom for a total of 131072 different colors.

Enter a color for red between 0 and 255 at the 
command line.  Program displays 65536 colors 
based on that color for red combined with all 
possible combinations of green and blue in the 
top half of the Frame.

The 131072 colors are surrounded by a thin
yellow border, which in turn is surrounded by
a wider gray border, all inside a Frame.

Tested using JDK 1.5 under WinXP.
************************************************/

import java.awt.*;
import java.awt.event.*;

public class ImgMod27 extends Frame{
  
  static int red = 0;
  
  public static void main(String[] args){
    //Get input value for red.
    if(args.length == 1){
      red = Integer.parseInt(args[0]);
    }else{
      System.out.println(
                "Usage: java ImgMod27 redValue\n"
              + "Using red = 0");
    }//end else
    
    //Confirm that red is within range.
    if((red < 0) || (red > 255)){
      System.out.println(
                  "Red must be >= 0 and <= 255\n"
                + "Terminating");
      System.exit(0);
    }//end if
    new ImgMod27();
  }//end main
  
  ImgMod27(){//constructor
    int panelWidth = 256 + 4;
    int panelHeight = 512 + 4;
    setVisible(true);
    setBackground(Color.gray);
    Insets insets = this.getInsets();
    setSize(panelWidth + insets.left 
                              + insets.right + 8,
            panelHeight + insets.top 
                            + insets.bottom + 8);
    setLayout(null);

    MyPanel panel = new MyPanel();
    panel.setBounds(insets.left + 4,
          insets.top + 4,panelWidth,panelHeight);
    panel.setBackground(Color.YELLOW);
    add(panel);
    setTitle("Copyright 2005, Baldwin");
    //=========================================//

    //Anonymous inner class listener to terminate
    // program.
    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor
  //-------------------------------------------//
  
  //Inner class
  class MyPanel extends Panel{
    int green = 0;
    int blue = 0;
    int xcoor = 1; 
    int ycoor = 1;
    public void paint(Graphics g){
      //Compute and display colors at top of
      // Frame.
      for(green = 0;green < 256;green++){
        for(blue = 0;blue < 256;blue++){
          g.setColor(new Color(red,green,blue));
          g.drawOval(xcoor++,ycoor,1,1);
          if(xcoor > 256){
            xcoor = 1;
            ycoor++;
          }//end if
        }//end inner loop
      }//end outer loop
      
      //Now compute and display inverted colors
      // at bottom of Frame.
      for(green = 0;green < 256;green++){
        for(blue = 0;blue < 256;blue++){
          g.setColor(new Color(255-red,
                            255-green,255-blue));
          g.drawOval(xcoor++,ycoor,1,1);
          if(xcoor > 256){
            xcoor = 1;
            ycoor++;
          }//end if
        }//end inner loop
      }//end outer loop
    }//end overridden paint
  }//end inner class MyPanel
}//end class ImgMod27

<b>Listing 9</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4><a name="About_the_author">About the author</a></h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he frequently 
provides onsite training at the high-tech companies located in and around 
Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords<br>
</b>java image pixel color intensity filtering inversion framework GUI 
transparent slider experiment wheel cube</p>
<p>-end-</p>
   </body>
</html>
