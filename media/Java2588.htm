<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Programming MIDlet Graphics using the Canvas Class</h2>
<i>Learn how to use methods of the Canvas class along with methods of the 
Graphics class to draw text and lines on the cell phone screen.&nbsp; Also learn how 
to use anchor point coordinates to control the position of text that is drawn on 
the screen and how to handle keyPressed events fired by a Canvas 
object.</i>
<p><b>Published:</b>&nbsp; July 15, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2588</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#The_Canvas_class">The Canvas class</a></li>
	<li><a href="#The_Graphics_class">The Graphics class</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_MIDlet_named_Canvas01">The MIDlet named Canvas01</a></li>
	<li><a href="#The_MIDlet_named_Canvas02">The MIDlet named Canvas02</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p>This is Part 1 of a two-part lesson in a series of tutorial lessons designed 
to teach you how to write programs using the Sun Java Wireless Toolkit for 
CLDC.&nbsp; The first lesson was titled <i>Getting Started with MIDlets and the Sun 
Java Wireless Toolkit for CLDC</i>.&nbsp; The previous lesson was titled <i>
Programming MIDlets for Interactive Behavior (see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p> In this lesson, you will learn how to use several methods of the <b>Canvas</b> 
class <i>(including paint and repaint)</i>, along with several methods of the <b>
Graphics</b> class to draw text and lines on the cell phone screen.&nbsp; You 
will learn how to use anchor point coordinates to control the position of text 
that is drawn on the screen.&nbsp; You will also learn how to handle <b>
keyPressed</b> events fired by a <b>Canvas</b> object.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Partial class hierarchy for MIDP 2.0.</li>
	<li><a href="#Figure_2">Figure 2</a>. Output from MIDlet named Canvas01 in 
	Sun emulator.</li>
	<li><a href="#Figure_3">Figure 3</a>. Sun cell phone emulator output for the 
	MIDlet named Canvas02.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. The main class for the MIDlet named 
	Canvas01.</li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the member class named 
	MyCanvas.</li>
	<li><a href="#Listing_3">Listing 3</a>. Draw eight lines and eight text 
	strings.</li>
	<li><a href="#Listing_4">Listing 4</a>. Draw two more lines.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the class for the 
	MIDlet named Canvas02.</li>
	<li><a href="#Listing_6">Listing 6</a>. Remainder of the main class for the 
	MIDlet named Canvas02.</li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the member class named 
	MyCanvas.</li>
	<li><a href="#Listing_8">Listing 8</a>. Beginning of the overridden paint 
	method.</li>
	<li><a href="#Listing_9">Listing 9</a>. Remainder of the overridden paint 
	method.</li>
	<li><a href="#Listing_10">Listing 10</a>. Overridden keyPressed method.</li>
	<li><a href="#Listing_11">Listing 11</a>. Source code for the MIDlet named 
	Canvas01.</li>
	<li><a href="#Listing_12">Listing 12</a>. Source code for the MIDlet named 
	Canvas02.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>If you are familiar with graphics programming in J2SE without the benefit of 
Java 2D and Java 3D, you will probably be reasonably comfortable with the 
material in this lesson.&nbsp; J2ME graphics is very similar to graphics 
programming in the early days of Java, but with some interesting new wrinkles.</p>
<p><font color="#ff0000"><b>Partial class hierarchy for MIDP 2.0</b></font></p>
<p>A partial class hierarchy for MIDP 2.0 is shown in Figure 1.&nbsp; Figure 1 
includes all of the classes that are included in the package named <b>
javax.microedition.lcdui</b>.&nbsp; In addition, Figure 1 includes three classes 
that are in other 
packages.</p>
<p><b><a name="Figure_1">Figure 1</a>. Partial class hierarchy for MIDP 2.0. </b>

<table bgcolor="#ffffff" border="1" cols="1" width="477">
	<tr>
		<td>
		<ul>
			<li>Object<ul>
				<li><i><b>Displayable</b></i><ul>
					<li><i><b>Screen</b></i><ul>
						<li><i><b>TextBox</b></i></li>
						<li><i><b>Alert</b></i></li>
						<li><i><b>List</b></i></li>
						<li><i><b>Form</b></i></li>
					</ul>
					</li>
					<li><b>Canvas <i>(abstract)</i></b><ul>
						<li>GameCanvas <i>(abstract)</i></li>
					</ul>
					</li>
				</ul>
				</li>
				<li><i><b>Display</b></i></li>
				<li><b><i>Ticker</i></b></li>
				<li><i><b>AlertType</b></i></li>
				<li><i><b>Image</b></i></li>
				<li><i><b>Item</b></i><ul>
					<li><i><b>Gauge</b></i></li>
					<li><i><b>ChoiceGroup</b></i></li>
					<li>CustomItem</li>
					<li><i><b>DateField</b></i></li>
					<li><i><b>ImageItem</b></i></li>
					<li><i><b>Spacer</b></i></li>
					<li><i><b>StringItem</b></i></li>
					<li><i><b>TextField</b></i></li>
				</ul>
				</li>
				<li><i><b>Timer</b></i></li>
				<li><i><b>TimerTask</b></i></li>
				<li><i><b>Command</b></i></li>
				<li><b>Graphics</b></li>
				<li><b>Font</b></li>
			</ul>
			</li>
		</ul>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>Classes to be illustrated</b></font></p>
<p>I have discussed and illustrated the classes shown in boldface Italics <i>
(plus the <b>Choice</b> interface, the <b>CommandListener</b> interface, and the
<b>ItemCommandListener</b> interface)</i> in earlier lessons <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; I will discuss and illustrate the 
following classes in this lesson:</p>
<ul>
	<li><b>Canvas</b> class</li>
	<li><b>Graphics </b>class</li>
	<li><b>Font </b>class</li>
</ul>
<p>I will discuss and illustrate the<b> GameCanvas</b> class in a future 
lesson.&nbsp; I will leave <b>CustomItem</b> as an exercise for the student.</p>
<h3><a name="The_Canvas_class">The Canvas class</a></h3>
<p>Here is part of what Sun has to say about the <b>Canvas</b> class:</p>
<blockquote>
	<p><i>&quot;The <b>Canvas</b> class is a base class for writing applications that 
	need to handle low-level events and to issue graphics calls for drawing to 
	the display. Game applications will likely make heavy use of the <b>Canvas</b> 
	class. From an application development perspective, the <b>Canvas</b> class 
	is interchangeable with standard <b>Screen</b> classes, so an application 
	may mix and match <b>Canvas</b> with high-level screens as needed. For 
	example, a <b>List</b> screen may be used to select the track for a racing 
	game, and a <b>Canvas</b> subclass would implement the actual game.&quot;</i></p>
</blockquote>
<p>The use of the <b>Canvas</b> class and the <b>GameCanvas</b> class for 
programming games will be the topic of a future lesson.&nbsp; In this lesson, I 
will concentrate on using the <b>Canvas</b> class for presenting graphic 
information on the cell phone screen, and handling key events that are fired by 
a <b>Canvas</b> object.</p>
<p><font color="#FF0000"><b>Yes, I really did mean <i>key events</i></b></font></p>
<p>Unlike the commands that we 
studied in an earlier lesson, the <b>Canvas</b> class provides the ability to 
detect and handle key events in a manner that is very similar, but not identical 
to the JavaBeans or Delegation event model in J2SE <i>(see <a href="#Resources">
Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Pointer events</b></font></p>
<p>The <b>Canvas</b> class also provides the ability to detect and handle 
pointer <i>(mouse like)</i> events on hardware implementations that support 
them.&nbsp; However, in these lessons, I am constrained to the use of the Sun 
cell phone emulator, which does not appear to support pointer events.&nbsp; <i>
(If it does support pointer events, I haven't figured out how to make it do so.)</i>&nbsp; Therefore, I 
will have very little, if anything to say about pointer events.</p>
<p><font color="#FF0000"><b>Canvas also supports commands</b></font></p>
<p>Just like other <b>Displayable</b> objects, <b>Canvas</b> objects also 
support commands such as EXIT, BACK, OK, etc. <i>(see Programming MIDlets for 
Interactive Behavior in <a href="#Resources">Resources</a>)</i>.&nbsp; Therefore, you 
can mix command programming and real event-driven programming for <b>Canvas</b> 
objects.</p>
<p><font color="#FF0000"><b>Canvas is an abstract class</b></font></p>
<p>The <b>Canvas</b> class is abstract, so you must extend it in order to use it.&nbsp; The reason for this is that the primary use of the <b>
Canvas</b> class is to serve as a surface on which to draw.&nbsp; In order to 
draw, you must override the <b>paint</b> method of the <b>Canvas</b> class.&nbsp; 
The only way to override a method is to extend the class to which the method 
belongs.</p>
<p><font color="#FF0000"><b>Comparison with J2SE</b></font></p>
<p>When programming in J2SE <i>(using the JavaBeans source-listener event model)</i>, 
if you want to detect and handle key events on an object that is the source of 
events, you must:</p>
<ul>
	<li>Define a class that implements the <b>KeyListener</b> 
interface.</li>
	<li>Instantiate an object of that class.</li>
	<li>Register the listener object on the source 
object.</li>
</ul>
<p>Event handler methods, such as <b>keyPressed</b> are declared in 
the <b>KeyListener</b> interface and must be defined in your new class.&nbsp; That is not the case with MIDP 2.0.&nbsp; The <b>Canvas</b> class already 
defines the following <i>empty</i> event-handler methods:</p>
<ul>
	<li>keyPressed</li>
	<li>keyReleased</li>
	<li>keyRepeated</li>
	<li>pointerDragged</li>
	<li>pointerPressed</li>
	<li>pointerReleased</li>
</ul>
<p><font color="#FF0000"><b>Handling an event</b></font></p>
<p>To handle one of the events in the above list, you must override the 
corresponding method in your subclass of the <b>Canvas </b>class, writing the 
desired behavior into your overridden method.&nbsp; If you don't want to handle 
any of the events in the above list, just forget about the ones that you don't 
want to handle.&nbsp; Unlike the JavaBeans event model, it is not necessary to 
define empty methods for the events that you don't want to handle.</p>
<p><font color="#FF0000"><b>More information from Sun</b></font></p>
<p>According to Sun,</p>
<blockquote>
	<p><i>&quot;Applications receive keystroke events in which the individual keys 
	are named within a space of key codes. Every key for which events are 
	reported to MIDP applications is assigned a key code. The key code values 
	are unique for each hardware key unless two keys are obvious synonyms for 
	each other.&quot; </i></p>
</blockquote>
<p>Sun goes on to tell us,</p>
<blockquote>
	<p><i>&quot;MIDP defines the following key codes: KEY_NUM0, KEY_NUM1, KEY_NUM2, 
	KEY_NUM3, KEY_NUM4, KEY_NUM5, KEY_NUM6, KEY_NUM7, KEY_NUM8, KEY_NUM9, 
	KEY_STAR, and KEY_POUND. (These key codes correspond to keys on a ITU-T 
	standard telephone keypad.)&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Public static final variables</b></font></p>
<p>The <b>Canvas</b> class provides a public static final variable <i>(constant)</i> for each of 
the key codes listed above.&nbsp; Finally, Sun tells us,</p>
<blockquote>
	<p><i>&quot;Other keys may be present on the keyboard, and they will generally 
	have key codes distinct from those list above. In order to guarantee 
	portability, applications should use only the standard key codes.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Did not adhere to the rule</b></font></p>
<p>As you will see later, I did not adhere to this rule in one of the sample 
MIDlets.&nbsp; I wasn't interested in achieving portability.&nbsp; Rather, I was 
mainly interested in clarity and I found it easier to be clear using the 
following key names <i>(which may be peculiar to the Sun emulator)</i> in the MIDlet:</p>
<ul>
	<li>LEFT</li>
	<li>RIGHT</li>
	<li>UP</li>
	<li>DOWN</li>
	<li>SELECT</li>
</ul>
<p>These names apply to the arrow keys and the large key in the middle of the 
arrow keys on the Sun cell phone emulator keypad <i>(see Figure 2)</i>.&nbsp; As 
mentioned above, 
they may not apply to similar keys in other cell phone emulators or in real cell 
phones for that matter.&nbsp; <i>(There is a better way to deal with the arrow 
keys, which you will learn about in a future lesson on the <b>GameCanvas</b> 
class.)</i></p>
<p><font color="#FF0000"><b>Normal versus full-screen mode</b></font></p>
<p>Here is some of what Sun has to say on this topic:</p>
<blockquote>
	<p><i>&quot;A <b>Canvas</b> can be in normal mode or in full-screen mode. In 
	normal mode, space on the display may be occupied by command labels, a 
	title, and a ticker. By setting a <b>Canvas</b> into full-screen mode, the 
	application is requesting that the <b>Canvas</b> occupy as much of the 
	display space as is possible. In full-screen mode, the title and ticker are 
	not displayed even if they are present on the <b>Canvas</b>, and 
	<a name="Commands_may_be_presented"> <b>Commands</b> 
	may be presented</a> using some alternative means (such as through a pop-up 
	menu).&quot;</i></p>
</blockquote>
<p>A <b>Canvas</b> object is in normal mode by default.&nbsp; You will see an 
example of normal and full-screen modes in one of the sample MIDlets in this 
lesson.</p>
<p>Numerous methods are defined in the <b>Canvas</b> class.&nbsp; I will 
illustrate the use of many of those methods in the sample MIDlets in this lesson.</p>
<h3><a name="The_Graphics_class">The Graphics class</a></h3>
<p>Sun describes this class as follows:</p>
<blockquote>
	<p><i>&quot;Provides simple 2D geometric rendering capability.&quot;</i></p>
</blockquote>
<p>While true, this statement hardly does justice to the importance of the <b>
Graphics</b> class.</p>
<p><font color="#FF0000"><b>No public constructor</b></font></p>
<p>The <b>Graphics</b> class doesn't have a public 
constructor, so you can't directly instantiate an object of the <b>Graphics</b> class.&nbsp; I 
am aware of at least two ways to get access to an object of the class.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>The <b>paint</b> method that I mentioned earlier is a callback method.&nbsp;&nbsp; 
Whenever your <b>Canvas</b> object is visible on the screen and the system needs 
to display graphics information on that canvas, it will call your overridden <b>
paint</b> method.&nbsp; When your overridden <b>paint</b> method is called, it 
will receive a reference to an object of <b>Graphics </b>class.</p>
<p>You can think of that object as a drawing surface that represents the screen.&nbsp; 
When you call the various methods of the <b>Graphics</b> class to draw pictures 
on the <b>Graphics</b> object, those pictures will appear on the screen <i>
(assuming that your MIDlet currently has access to the screen)</i>.</p>
<p><font color="#FF0000"><b>The createImage and getGraphics methods</b></font></p>
<p>As you will see in one the sample MIDlets in this lesson, you can use the <b>
createImage</b> and <b>getGraphics</b> methods together to get access to an off-screen drawing area that is 
represented by a <b>Graphics</b> object.&nbsp; When you use the various methods 
of the <b>Graphics</b> class to draw on that <b>Graphics</b> object, the results 
are not immediately visible.&nbsp; Rather, you are simply drawing in memory when 
you do that and only you know what is happening.</p>
<p>This makes it possible for you to compose a complex drawing in memory and 
then transfer it to the <b>Canvas</b> object <i>(the screen)</i> very quickly by calling the <b>drawImage</b> method on the <b>Canvas</b> passing 
the off-screen image's reference as a parameter.&nbsp; This is often a more 
visually pleasing approach than composing a complex drawing on the screen in 
full view of the user, particularly if the time required to compose the drawing 
is significant.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>What about circles?</b><br />
  Circles are constructed from 360-degree circular arcs.&nbsp; Note that for the 
	case of the <b>drawArc</b> method, angles are specified in degrees instead 
	of radians.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Drawing primitives</b></font></p>
<p>The methods of the <b>Graphics</b> class provide drawing primitives for text, 
images, lines, rectangles, and arcs. Rectangles and arcs may be filled with 
a solid color. Rectangles may also be specified with rounded corners.</p>
<p><font color="#FF0000"><b>The coordinate system</b></font></p>
<p>The origin of the default coordinate system is at the upper left-hand corner 
of the screen or off-screen drawing area. The X-axis direction is positive 
towards the right, and the Y-axis direction is positive downwards.&nbsp; You can 
translate the origin to some other location if you want to by calling the <b>
translate</b> method.</p>
<p>For example, by using the <b>translate</b> method and the appropriate 
arithmetic operations, you could cause the origin to be relocated to the center 
of the screen with the positive Y-axis direction going up the screen instead of 
down.</p>
<p>You can assume that horizontal and vertical distances in the coordinate 
system represent equal distances on the actual device display.&nbsp; In other 
words, if you draw a square, it won't be turned into a rectangle and if 
you draw a circle, it won't be turned into an ellipse.</p>
<p>All coordinates are specified as integers.</p>
<p><font color="#FF0000"><b>Drawing text</b></font></p>
<p>When a character is painted, the pixels forming the character's shape are 
filled with the <b>Graphics</b> object's <i>current color</i>.&nbsp; The pixels 
that are not part 
of the character's shape are left untouched. Several methods are available to 
draw text.&nbsp; As far as I know, you can only draw text horizontally.</p>
<p><font color="#FF0000"><b>Line stroke styles</b></font></p>
<p>Lines, arcs, rectangles, and rounded rectangles may be drawn with either a 
SOLID or a DOTTED stroke style.&nbsp; The default is SOLID.&nbsp; You can change 
the style by calling the <b>setStrokeStyle</b> method, which doesn't affect 
fill, text, and image operations.</p>
<p>Lines, arcs, rectangles, and rounded rectangles are drawn with a stroke that 
is one pixel wide.&nbsp; If you need additional width, you must draw two or more 
lines in parallel.</p>
<p><font color="#FF0000"><b>Clipping</b></font></p>
<p>Sun tells us,</p>
<blockquote>
	<p><i>&quot;The clip is the set of pixels in the destination of the Graphics 
	object that may be modified by graphics rendering operations.&quot;</i></p>
</blockquote>
<p>To make a long story short, there is a single clip per <b>Graphics</b> 
object, and it is a rectangle that you can set with a call to the <b>setClip</b> 
method.&nbsp; The only pixels modified by graphics operations are those that lie 
within the clip rectangle. Pixels outside the clip rectangle are not modified by 
any graphics operations.</p>
<p><font color="#FF0000"><b>Anchor points</b></font></p>
<p>One of the more complex aspects of the MIDP 2.0 graphics drawing system is 
the concept of anchor points.&nbsp; Anchor points apply when you are drawing 
text, images, regions, and areas.&nbsp; <i>(They do not apply when drawing lines, 
arcs, rectangles, and rounded rectangles.)</i></p>
<p>Later, I will present and explain a sample MIDlet named <b>Canvas01</b> that illustrates what is meant 
by anchor points in conjunction with the drawing of text.&nbsp; <i>(The 
interpretation is generally the same when drawing images, etc.)</i>&nbsp; The output from the MIDlet, when run in the Sun cell 
phone emulator, is shown in Figure 2.&nbsp; I will explain the output from the 
MIDlet here, and explain the code that produced that output later.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Output from MIDlet named Canvas01 in Sun 
	emulator. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2588a1.jpg" width="315" height="475"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>No anchor point in J2SE graphics</b><br />
  The <i>anchor</i> parameter is not used in the argument list of the <i>drawString</i> 
	method of J2SE version 1.6.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Drawing parameters</b></font></p>
<p>When you call the <b>drawString</b> method to draw text on the screen, you 
must provide the following four parameters:</p>
<ul>
	<li><b>String&nbsp;string</b> - the text string to be drawn.</li>
	<li><b>int&nbsp;x</b> - a horizontal coordinate value.</li>
	<li><b>int&nbsp;y</b> - a vertical coordinate value.</li>
	<li><b>int&nbsp;anchor</b> - an anchor point value.</li>
</ul>
<p><font color="#FF0000"><b>The big question...</b></font></p>
<p>The parameter values x and y clearly specify a point in the Cartesian 
coordinate system.&nbsp; The big question is what does the location of that 
point in the coordinate system have to do with the location of the text <i>(or 
the image, etc.)</i>?</p>
<p><font color="#FF0000"><b>Allowable anchor-point values</b></font></p>
<p>The allowable anchor-point values are given below in terms of public static 
final variables <i>(constants)</i> of the <b>Graphics</b> class:</p>
<p><a name="Horizontal_Anchor_Values">Horizontal Anchor-Point Values</a></p>
<ul>
	<li>LEFT</li>
	<li>HCENTER</li>
	<li>VCENTER</li>
	<li>RIGHT</li>
</ul>
<p><a name="Vertical_Anchor_Values">Vertical Anchor-Point Values</a></p>
<ul>
	<li>TOP</li>
	<li>BASELINE</li>
	<li>BOTTOM</li>
</ul>
<p><i>(Note that VCENTER can be used with images, but cannot be used with text.&nbsp; 
BASELINE can be used with text but cannot be used with images.)</i></p>
<p><font color="#FF0000"><b>Must construct a bitwise inclusive OR value</b></font></p>
<p>The value that is passed as the <b>anchor</b> parameter to the<b> drawString</b> 
method must be constructed as the bit-wise inclusive OR of one of the
<a href="#Horizontal_Anchor_Values">horizontal</a> anchor-point values <i>
(excluding VCENTER for text)</i> and one of the
<a href="#Vertical_Anchor_Values">vertical</a> anchor-point values <i>
(excluding BASELINE for images)</i>.&nbsp; The 
value zero may also be passed as the <b>anchor</b> parameter and is interpreted 
the same as the value that would be constructed from TOP | LEFT.</p>
<p><font color="#FF0000"><b>Eight calls to the drawString method</b></font></p>
<p>Now turn your attention to Figure 2.&nbsp; When we examine the code later, 
you will see that this MIDlet called the <b>drawString</b> method eight times in 
succession.&nbsp; Each time the method is called the string that is passed as 
the first parameter is the text displayed on a single line on the screen in 
Figure 2.&nbsp; The 
value that is passed as <b>anchor</b> is constructed according to that text <i>
(exclusive of the part of the text that reads &quot;y-,&quot; more on this later)</i>.</p>
<p>For example, the first call to the <b>drawString</b> method constructs the <b>
anchor</b> value as TOP|RIGHT and the text in Figure 2 reads y-TOP|RIGHT.</p>
<p><font color="#FF0000"><b>The coordinate values for the first call to 
drawString</b></font></p>
<p>The <b>x</b> and <b>y</b> coordinate values passed to the method specify the 
point identified by the intersection of two lines immediately above the text at 
the right end of the text.&nbsp; In other words, the specified value for <b>
anchor</b> instructs the system to display the text string below and to the left 
of the point at the specified coordinate values.</p>
<p><font color="#FF0000"><b>Compare intersections of lines with the text</b></font></p>
<p>If you follow the lines down the screen and compare the intersection of each 
pair of two lines with the construction of the <b>anchor</b> value given by the 
text, you should be able to see the correlation between the location of the 
specified point in the coordinate system and the location of the text string 
relative to that point.</p>
<p><font color="#FF0000"><b>TOP</b></font></p>
<p>Note that in all cases that use TOP for the construction of <b>anchor</b>, 
there is some space between the actual top of the upper case characters and the 
vertical location of the point in the coordinate system.</p>
<p><font color="#FF0000"><b>BOTTOM</b></font></p>
<p>Note also that in all cases that use BOTTOM for the construction of <b>anchor</b> 
there is some space between the bottom of the characters and the vertical 
location of the point.&nbsp; This is true even when the text includes a lower 
case y with a descender.</p>
<p><font color="#FF0000"><b>BASELINE</b></font></p>
<p>However, when BASELINE is used for the construction of <b>anchor</b>, there 
is no space between the bottom of the characters and the vertical location of 
the point.&nbsp; In other words, when BASELINE is used for the vertical 
placement, that is interpreted to mean that the bottom of the characters should 
coincide with that vertical coordinate with no blank space in between.&nbsp; 
When there are no descenders, the bottoms of the characters without descenders 
match the BASELINE value.&nbsp; When there are descenders, the bottom of the 
lowest descender matches the BASELINE value.</p>
<p>On the other hand, both BOTTOM and TOP allow for some blank space at the 
bottom and top of the characters.</p>
<p><b><font color="#FF0000">RIGHT, LEFT, and HCENTER</font></b></p>
<p>RIGHT and LEFT mean what they say.&nbsp; As you can see, no blank space 
margin is allowed.&nbsp; HCENTER means that the horizontal center of the text 
should occur at the specified horizontal coordinate.</p>
<p><font color="#FF0000"><b>Interpretation for images</b></font></p>
<p>As mentioned earlier, the same concept applies to the placement of images 
with the added benefit of being able to use VCENTER to specify that the image 
should be centered vertically on the specified vertical coordinate value.&nbsp;
<i>(I will illustrate this in one of the sample MIDlets in this lesson.)</i>&nbsp; 
On the other hand, BASELINE cannot be used with images.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>I will present and explain two sample MIDlets named <b>Canvas01</b> and <b>
Canvas02</b> in Part 1 of this lesson, and will present and explain a third 
sample MIDlet named <b>Canvas03</b> in Part 2 of this lesson.</p>
<p><font color="#FF0000"><b>Canvas01</b></font></p>
<p>The purpose of the MIDlet named <b>Canvas01</b> is to illustrate the use of a
<b>Canvas</b> object and a <b>Graphics</b> object in a very simple and 
understandable way.</p>
<p><font color="#FF0000"><b>Canvas02</b></font></p>
<p>The purpose of the MIDlet named <b>Canvas02</b> is to illustrate the 
detection and handling of key events on a <b>Canvas</b> object.&nbsp; The MIDlet also 
demonstrates certain aspects of the <i>full-screen</i> mode versus the <i>normal</i> 
mode.</p>
<p><font color="#FF0000"><b>Canvas03</b></font></p>
<p>The purpose of this MIDlet named <b>Canvas03</b> is to illustrate the 
following major programming concepts involving the use of the <b>Canvas</b> 
class and the <b>Graphics</b> class:</p>
<ul>
	<li>Creating an off-screen image.</li>
	<li>Importing <b>Image</b> files and drawing them in specified locations on 
	the off-screen image.</li>
	<li>Drawing a variety of shapes in different colors on the off-screen image, 
	including the following:<ul>
		<li>Rectangle</li>
		<li>Filled triangle</li>
		<li>Full circular arc</li>
		<li>Rounded rectangle</li>
	</ul>
	</li>
	<li>Drawing the off-screen image onto the <b>Canvas</b> in a specified 
	location.</li>
	<li>Handling <b>keyPressed</b> events on the <b>Canvas</b> to cause the 
	off-screen image to be drawn at different locations on the <b>Canvas</b> as 
	a result of the user having pressed the following keys <i>(simple animation)</i>:<ul>
		<li>RIGHT</li>
		<li>LEFT</li>
		<li>UP</li>
		<li>DOWN</li>
		<li>SELECT</li>
	</ul>
	</li>
</ul>
<p>In addition, the MIDlet named <b>Canvas03</b> implements an EXIT command that 
can be used to terminate the MIDlet and cause it to enter the destroyed state.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>MIDlet testing</b><br>
				All of the MIDlets in this lesson were tested using a Java SE 6 
				compiler, targeted at a V1.4 virtual machine, and WTK 2.5.2 
				running under Windows XP.
				</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<h3><a name="The_MIDlet_named_Canvas01">The MIDlet named Canvas01</a></h3>
<p>The purpose of this MIDlet is to illustrate the use of a <b>Canvas</b> object 
and a <b>Graphics</b> object in a very simple and understandable way.</p>
<p><font color="#FF0000"><b>Anchor point constants</b></font></p>
<p>The MIDlet further illustrates the use of anchor point constants to establish 
the alignment of drawn text.&nbsp; The output from the MIDlet running in the Sun 
cell phone emulator is shown in Figure 2.</p>
<p><font color="#FF0000"><b>Clear the screen</b></font></p>
<p>The MIDlet begins by painting the entire screen white.&nbsp; Otherwise, the 
new drawing would appear on top of what was previously on the screen.&nbsp; Then 
it sets the drawing color to black.</p>
<p><font color="#FF0000"><b>Draw the text and the lines</b></font></p>
<p>Following that, the MIDlet draws eight pairs of graphic objects.&nbsp; Each 
pair consists of: </p>
<ul>
	<li>A line from 0,0 to a specific location on the canvas.</li>
	<li>A string of text with the anchor point coordinates set to match the end 
	of the line.</li>
</ul>
<p>The text contents of each string give the combination of anchor point 
constants used to position that particular string.&nbsp; Some text strings also 
begin with a lower case y- to show the effect of descenders on the vertical 
alignment of the text string.</p>
<p><font color="#FF0000"><b>The anchor point constants</b></font></p>
<p>The eight pairs of graphic objects illustrate the effect of different 
combinations of the following anchor point constants as well as the impact of 
lower-case descenders on the alignment produced <a name="by_the_constants:">by 
the constants:</a></p>
<ul>
	<li>TOP</li>
	<li>BASELINE</li>
	<li>BOTTOM</li>
	<li>LEFT</li>
	<li>HCENTER</li>
	<li>RIGHT</li>
</ul>
<p><font color="#FF0000"><b>Combining anchor point constants</b></font></p>
<p>An anchor point must be specified for each text string that is drawn.&nbsp; 
The anchor point must be produced by the bitwise inclusive OR of one of the top 
three <i>(vertical)</i> anchor constants in the above
<a href="#by_the_constants:">list</a> and one of the bottom three <i>
(horizontal)</i> anchor constants.&nbsp; For example, the following would be a 
valid anchor point: value to pass to the <b>drawString</b> method</p>
<p>TOP|RIGHT</p>
<p><font color="#FF0000"><b>Determining the position and the alignment of the 
text</b></font></p>
<p>The actual position and the alignment of the text string are determined by 
the combination of a pair of specified coordinate values and the bitwise 
inclusive OR of two anchor constants.&nbsp; The coordinates specify the position 
that will be assumed by a particular point in the text string.&nbsp; The bitwise 
inclusive OR of two anchor constants determines which point in the text string 
will be located at the specified coordinates.</p>
<p>The special anchor point value of 0 is interpreted to mean TOP|LEFT.</p>
<p><font color="#FF0000"><b>Two more straight lines</b></font></p>
<p>Another pair of straight lines is used to connect the ends of the sloping lines 
that originate in the upper left corner of the screen.&nbsp; This makes it 
easier to visually determine the location of the anchor point in each text 
string.</p>
<p><font color="#FF0000"><b>Methods that are used</b></font></p>
<p>This MIDlet illustrates the use of the following methods from the <b>Graphics</b> 
class:</p>
<ul>
	<li>setColor</li>
	<li>fillRect</li>
	<li>drawLine</li>
	<li>drawString</li>
</ul>
<p>The MIDlet also illustrates the use of the following methods from the <b>
Canvas</b> class:</p>
<ul>
	<li>paint</li>
	<li>repaint</li>
	<li>getWidth</li>
	<li>getHeight</li>
</ul>
<p><font color="#FF0000"><b>Display for twenty seconds</b></font></p>
<p>The MIDlet displays the canvas for 20 seconds to give you a chance to view it 
and then enters the destroyed state.</p>
<p><font color="#FF0000">
<b>The main class for the MIDlet named Canvas01</b></font></p>
<p>The MIDlet class is shown in its entirety in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. The main class for the MIDlet named 
Canvas01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Canvas01 extends MIDlet{
  Canvas myCanvas;

  public Canvas01(){
    System.out.println("Construct MIDlet");
    myCanvas = <b>this.new MyCanvas()</b>;
    //Guarentee that the screen gets painted.
    myCanvas.<b>repaint</b>();
  }//end constructor

  public void startApp(){
                                  
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);

    //Sleep for 20 seconds.
    try{Thread.currentThread().sleep(20000);
    } catch(Exception e){}

    //Enter the destroyed state.
    this.destroyApp(true);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you have studied the previous lessons in this series, the only new 
material in Listing 1 should be:</p>
<ul>
	<li>The instantiation of an object of a member class named <b>MyClass</b>.</li>
	<li>The call to the <b>repaint</b> method belonging to that object.</li>
</ul>
<p><font color="#FF0000"><b>Java graphics 101</b></font></p>
<p>As you will see later, the new class overrides the <b>paint</b> method 
inherited from the <b>Canvas</b> class.&nbsp; The code in the <b>paint</b> 
method produces the graphics on the screen.&nbsp; However, the <b>paint</b> 
method is a callback method and MIDlet code normally doesn't call it directly <i>
(although there may be exceptions to this rule of thumb)</i>.&nbsp; 
Rather, the MIDlet code normally calls the <b>repaint</b> method.&nbsp; This sends a 
request to the virtual machine to execute the <b>paint</b> method.&nbsp; This 
allows the virtual machine and the operating system to act as a traffic cop 
forcing the different applications needing access to the screen to play nice and 
take turns.</p>
<p>
<a name="The_call_to_the_repaint_method_in_Listing_1_is_probably_superfluous.">The call to the <b>repaint</b> method in Listing 1 is probably superfluous.</a>&nbsp; 
The screen would probably be painted by executing the <b>paint</b> method anyway 
with or without this call to <b>repaint</b>.&nbsp; The call to <b>repaint</b> 
was included in Listing 1 simply to guarantee that the <b>paint</b> method does 
get called when the MIDlet becomes active.&nbsp; <i>(Another sample MIDlet in this 
lesson illustrates the requirement to call the <b>repaint</b> method to cause 
the screen to be repainted with new information.)</i></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>No requirement for a member class</b><br />
  The class named<b> </b>MyCanvas was defined as a member class for programming 
	convenience only.&nbsp; There was no technical requirement for making it a member 
	class.<b> </b>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Beginning of the member class named MyCanvas</b></font></p>
<p>Listing 2 shows the beginning of the member class named <b>MyCanvas</b>.&nbsp; 
This class extends the <b>Canvas</b> class and overrides the <b>paint</b> 
method.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the member class named 
MyCanvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class <b>MyCanvas extends Canvas</b>{
    public void <b>paint</b>(Graphics g){
      //Paint the screen white
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      //Set the drawing color to black.
      g.setColor(0x000000);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Clear the screen</b></font></p>
<p>Listing 2 begins by painting the entire screen white.&nbsp; Otherwise, the new drawing 
would simply appear over top of what was previously on the screen.&nbsp; Even 
though that was not desired in this MIDlet, drawing on top of the existing 
material on the screen can sometimes be useful.&nbsp; For example, that would 
make it possible to combine a <b>TextBox</b> object and a <b>Canvas</b> object 
on the same screen.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>No Color class available</b><br />
  Unlike J2SE, MIDP 2.0 does not provide a Color class containing constants for 
	use in setting color values.<b>&nbsp; </b>
	Therefore, you must set the color using a mixture of red, green, and blue 
	values as shown in Listing 2.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Set the drawing color</b></font></p>
<p>After painting the screen white, Listing 2 sets the drawing color to black.&nbsp; 
This color will be used for all subsequent drawing until the drawing color is 
changed to some other color.</p>
<p><font color="#FF0000"><b>Draw eight graphic objects</b></font></p>
<p>Listing 3 draws the eight lines that originate in the upper left corner along 
with 
the eight text strings shown in Figure 2. </p>
<p>
<b><a name="Listing_3">Listing 3</a>. Draw eight lines and eight text strings.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      g.<b>drawLine</b>(0,0,200,20);
      g.<b>drawString</b>("y-TOP|RIGHT",200,20,
                             <b>Graphics.TOP|Graphics.RIGHT</b>);
      
      g.drawLine(0,0,150,40);
      g.drawString("y-TOP|HCENTER",150,40,
                           Graphics.TOP|Graphics.HCENTER);
      
      g.drawLine(0,0,100,60);
      g.drawString("y-TOP|LEFT",100,60,
                              Graphics.TOP|Graphics.LEFT);
      
      g.drawLine(0,0,100,90);
      g.drawString("y-BOTTOM|LEFT",100,90,
                           Graphics.BOTTOM|Graphics.LEFT);
                           
      g.drawLine(0,0,100,110);
      g.drawString("BOTTOM|LEFT",100,110,
                           Graphics.BOTTOM|Graphics.LEFT);
      
      g.drawLine(0,0,100,130);
      g.drawString("y-BASELINE|LEFT",100,130,
                         Graphics.BASELINE|Graphics.LEFT);
                         
      g.drawLine(0,0,100,150);
      g.drawString("BASELINE|LEFT",100,150,
                         Graphics.BASELINE|Graphics.LEFT);
                          
      g.drawLine(0,0,100,170);
      g.drawString("Special Case of Zero",100,170,0);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Drawing on a Graphics object</b></font></p>
<p>Note that the overridden paint method receives an incoming parameter of type
<b>Graphics</b> known locally simply as <b>g</b>.&nbsp; This is a reference to 
an object of the class <b>Graphics </b>and you can think of the <b>
Graphics</b> object as representing the screen.&nbsp; Whatever you draw on the
<b>Graphics</b> object will be rendered on the screen.</p>
<p>The <b>drawLine</b> method of the <b>Graphics</b> class is called eight times 
to draw the eight lines that originate at the origin and end at a particular 
location on the screen.</p>
<p>The <b>drawString</b> method is also called eight times to draw the 
eight text strings with the anchor point coordinate values matching the ends of 
the corresponding lines.&nbsp; Each time the <b>drawString</b> method is called, 
two anchor point constants are combined using a bitwise inclusive OR to provide 
the value that is passed as the fourth parameter.&nbsp; As explained 
earlier, this value is used to determine how the text string will be positioned 
relative to the point defined by the specified coordinate values.</p>
<p><font color="#FF0000">
<b>Draw two more lines</b></font></p>
<p>Listing 4 draws two additional lines that connect the ends of the sloping lines 
that originate in the upper left corner of the screen.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Draw two more lines. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      g.drawLine(200,20,100,60);
      g.drawLine(100,60,100,170);

    }//end overridden paint method
  }//end member class MyCanvas

}//end class Canvas01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 4 also signals the end of the overridden paint method and the end of 
the class named <b>Canvas01</b>.</p>
<h3><a name="The_MIDlet_named_Canvas02">The MIDlet named Canvas02</a></h3>
<p>The purpose of this MIDlet is to illustrate the detection and handling of 
key events on a <b>Canvas</b> object.&nbsp; The MIDlet also demonstrates certain 
aspects of the <i>full-screen</i> mode versus the <i>normal</i> mode.</p>
<p>A <b>Canvas</b> object is instantiated and set to full-screen mode.&nbsp; The 
inherited <b>keyPressed</b> method is overridden to:</p>
<ul>
	<li>Capture each user keystroke,</li>
	<li>Convert the key code to a key name.</li>
	<li>Add the key name to a <b>Vector</b> object.</li>
	<li>Cause the screen to be repainted each time a <b>keyPressed</b> event 
	occurs.</li>
</ul>
<p>The <b>paint</b> method is overridden to:</p>
<ul>
	<li>Clear the canvas.</li>
	<li>Extract each of the key names from the <b>Vector</b>.</li>
	<li>Display the key names in two columns on the screen by using the <b>
	drawString</b> method to draw the key names on the Canvas object.</li>
</ul>
<p><font color="#FF0000">
 <b>Sun cell phone emulator output for the MIDlet named Canvas02</b></font></p>
<p>Figure 3 shows an output from the MIDlet when run in the Sun cell phone 
emulator for a particular sequence of keystrokes on the emulator keypad.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Sun cell phone emulator output for the 
	MIDlet named Canvas02. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2588a2.jpg" width="310" height="665"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Keys that don't fire events</b></font></p>
<p>You can terminate the MIDlet that is running in the emulator by clicking 
the button on the right that has
<a name="a_picture_of_an_old-fashioned_telephone_receiver">a picture of an 
old-fashioned telephone receiver</a> in a horizontal position.&nbsp; <i>(When you point to this button, the picture of the telephone receiver 
should turn red.)</i>&nbsp; This button doesn't fire a <b>keyPressed</b> event.&nbsp;
<i>(At least it doesn't fire one 
that you can handle)</i>.</p>
<p>The key on the left with the picture of the 
house also doesn't fire a <b>keyPressed</b> event.</p>
<p><font color="#FF0000"><b>The key pressed order</b></font></p>
<p>Figure 3 shows the result of starting at the top left soft key and pressing 
keys going from left to right, top to bottom, excluding the two keys mentioned
<a href="#a_picture_of_an_old-fashioned_telephone_receiver">above</a>.&nbsp; The 
names of most of the keys in the Sun emulator are pretty easy to correlate with 
the label on the key.&nbsp; Two that may not be clear are SELECT and CLEAR.&nbsp; 
The SELECT key is the large square key in the middle of the arrow keys.&nbsp; 
The CLEAR key is the key on the right with the picture of the audio speaker.</p>
<p><font color="#FF0000"><b>Comparing <i>full-screen</i> and <i>normal</i> mode</b></font></p>
<p>You can see one of the differences between full-screen mode and normal mode 
by comparing Figure 3, <i>(which is in full-screen mode)</i> and Figure 2, <i>
(which is in normal mode)</i>.&nbsp; Since neither of these MIDlets displays a 
title and a ticker, the main difference between Figure 2 and Figure 3 is the 
disappearance of the gray bar at the bottom of the screen in Figure 3 where soft 
key commands normally appear.&nbsp; <i>(I will have more to say about this 
later.)</i></p>
<p><font color="#FF0000">
<b>Beginning of the class for the MIDlet named Canvas02</b></font></p>
<p>Listing 5 shows the beginning of the class for the MIDlet named <b>Canvas02</b> 
including the constructor.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the class for the MIDlet 
named Canvas02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Canvas02 extends MIDlet{
  Canvas myCanvas;  

  public Canvas02(){//Constructor
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    //Guarentee that the screen gets painted.
    myCanvas.repaint();
    
    //Add three commands to the Canvas
    myCanvas.addCommand(new Command("EXIT",
                                         Command.EXIT,2));
    myCanvas.addCommand(new Command("BACK",
                                         Command.BACK,2));
    myCanvas.addCommand(new Command("OK",Command.OK,2));
  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Three commands are added</b></font></p>
<p>Note that the constructor in Listing 5 adds three commands to the <b>Canvas</b> 
object.&nbsp; 
However, even if visible, the commands could not be activated because there is no 
<b>CommandListener</b> registered on the <b>Canvas</b> object.&nbsp; The 
commands were added to the <b>Canvas</b> solely to 
demonstrate the impact of full-screen mode versus normal mode.&nbsp; As 
mentioned earlier, when the <b>Canvas</b> 
object is set to full-screen mode, as is the case for this MIDlet, the commands 
are not visible.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Alternative command presentation</b><br />
  The Sun documentation indicates that in full-screen mode, &quot;<i>Commands 
	may be presented using some alternative means (such as through a pop-up 
	menu).&quot;</i>&nbsp; If the Sun cell phone emulator provides such an 
	alternative presentation, I haven't figured out what it is.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Accessing the commands</b></font></p>
<p>If the<b> Canvas</b> is switched to normal 
mode, the commands are displayed on the gray bar that normally appears at the 
bottom of the screen and also in a command menu accessible from the gray bar.&nbsp; You can demonstrate this 
behavior by modifying the code to pass true or false to the <b>setFullScreenMode</b> 
method in the <b>MyCanvas</b> constructor that I will discuss later.</p>
<p><font color="#FF0000">
<b>Remainder of the main class for the MIDlet named Canvas02</b></font></p>
<p>Listing 6 shows the remainder of the main class for the MIDlet named <b>
Canvas02</b>.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Remainder of the main class for the MIDlet 
named Canvas02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void startApp(){
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing new in this code so further explanation should not be 
necessary.</p>
<p><font color="#FF0000">
<b>Beginning of the member class named MyCanvas</b></font></p>
<p>Listing 7 shows the beginning of the member class named <b>MyCanvas</b>, 
including the constructor.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the member class named 
MyCanvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class MyCanvas extends Canvas{
    Vector vect = new Vector();
    
    MyCanvas(){//constructor
      this.<b>setFullScreenMode</b>(true);
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The constructor calls the method named <b>setFullScreenMode</b> to cause the
<b>Canvas</b> to appear on the screen in full-screen mode.&nbsp; If you change 
the parameter from true to false, the <b>Canvas</b> will revert to normal mode.&nbsp; 
If what you need is normal mode, you don't need to call this method because the
<b>Canvas</b> is in normal mode by default.</p>
<p><font color="#FF0000">
<b>Beginning of the overridden paint method</b></font></p>
<p>Listing 8 shows the beginning of the overridden <b>paint</b> method.&nbsp; 
The method begins by painting the screen white and then setting the drawing 
color to black.&nbsp; Following this, the method declares some working variables 
and initializes some of them.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Beginning of the overridden paint method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void paint(Graphics g){
      //Paint the entire screen white.
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      g.setColor(0x000000);//Set drawing color to black
      
      //Declare and initialize some working variables.
      String keyData = null;
      int fontHeight = g.getFont().getHeight();
      //Number of lines of text that fit on screen.
      int cntLimit = this.getHeight()/fontHeight;
      int yOffset = 0;
      int xOffset = 0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A two-column display</b></font></p>
<p>Most of the complexity of this method resides in the requirement to create 
two columns for drawing the text strings.&nbsp; This requires knowledge of the 
number of strings that will fit from top to bottom on the screen, which in turn 
requires knowledge of the vertical space occupied by each character.&nbsp; The 
code in Listing 8 gets the font height and performs that calculation.</p>
<p><font color="#FF0000">
<b>Remainder of the overridden paint method</b></font></p>
<p>Listing 9 displays the data captured from the user keyboard input in two 
columns.&nbsp; When the length of the first column exceeds the height of the 
screen, the display wraps and starts a new column as shown in Figure 3.&nbsp; If 
the length of the second column exceeds the height of the screen, the data will 
simply be lost off the bottom of the screen.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Remainder of the overridden paint method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      for(int cnt = 0;cnt &lt; vect.size();cnt++){
        keyData = (String)vect.elementAt(cnt);//note cast

        if(cnt * fontHeight &lt; this.getHeight() - 
                                              fontHeight){
          //Display in first column.
          yOffset = cnt * fontHeight;
          xOffset = 5;
        }else{
          //Display in second column
          yOffset = (cnt - cntLimit) * fontHeight;
          xOffset = this.getWidth()/2;
        }//end else
        
        //Draw the string on the Canvas.
        g.<b>drawString</b>(keyData,xOffset,yOffset,<b>0</b>);
      }//end for loop

    }//end overridden paint method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Drawing from top to bottom of the screen</b></font></p>
<p>Note that a value of 0 is passed as the fourth parameter to the <b>drawString</b> 
method.&nbsp; This causes the anchor point location to default to TOP|LEFT.&nbsp; 
</p>
<p>Since the direction for increasing values of the Y-coordinate is down the 
screen, the code in Listing 9 extracts the text data from the <b>Vector</b> and 
draws the text on the screen moving from top to bottom.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The keyReleased method</b><br />
  When the MyCanvas object is on the screen and the user releases one of the 
	keys, the <i>keyReleased</i> method is called.&nbsp; In this MIDlet, the empty 
	<i>keyReleased</i> method is not overridden.&nbsp; Calling the empty method is of 
	no consequence.&nbsp; It simply returns quietly.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Overridden keyPressed method</b></font></p>
<p>The<b> MyCanvas</b> class inherits an empty method named<b> keyPressed</b> 
from the<b> Canvas</b> class and overrides that method.&nbsp; Whenever the <b>
MyCanvas</b> object is being displayed on the screen and the used presses one of 
the keys shown in Figure 3, the <b>Canvas</b> object &quot;fires&quot; a <b>keyPressed</b> 
event, causing the overridden <b>keyPressed</b> method to be called.&nbsp; The 
overridden <b>keyPressed</b> method is shown in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Overridden keyPressed method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void <b>keyPressed</b>(int keyCode){
      vect.addElement(getKeyName(keyCode));
      this.repaint();
    }//end keyPressed
  }//end member class MyCanvas

}//end class Canvas02</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the code in Listing 10</b></font></p>
<p>The code in Listing 10:</p>
<ul>
	<li>Gets the name of the key that was pressed <i>(which may be peculiar to 
	the Sun cell phone emulator)</i>.</li>
	<li>Adds that name to the data already in the <b>Vector</b> object.</li>
	<li>Calls the <b>repaint</b> method on the <b>Canvas</b> object.</li>
</ul>
<p>The call to the <b>repaint</b> method causes the overridden <b>paint</b> method to be executed.&nbsp; 
As described earlier, the call to the overridden paint method:</p>
<ul>
	<li>Clears the canvas by painting it white.</li>
	<li>Extracts the text data from the <b>Vector</b> <i>(including the new 
	data)</i>.</li>
	<li>Draws the text on the screen in two columns as shown in Figure 3.</li>
</ul>
<p>Therefore, each time the user presses a key, the screen is re-drawn, causing 
the contents of the <b>Vector</b> object to be displayed.&nbsp; In this case, the 
call to the <b>repaint</b> method is not superfluous as it probably 
was
<a href="#The_call_to_the_repaint_method_in_Listing_1_is_probably_superfluous.">earlier</a>.</p>
<p><font color="#FF0000"><b>When is the paint method called?</b></font></p>
<p>As mentioned above, the <b>paint</b> method is called whenever the program 
code calls the <b>repaint</b> method.&nbsp; However, that is not the only time 
the <b>paint</b> method is called.&nbsp; It is called at any time that the system needs to 
cause the <b>Canvas</b> to be repainted by the MIDlet for any reason.&nbsp; For example, if a 
system screen covers the <b>Canvas</b> temporarily, the <b>paint</b> method will 
be called to redraw the screen when the system screen goes away.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the MIDlet code from Listing 11 and Listing 12.&nbsp; 
Run 
the MIDlets in the updated MIDlet development framework named <b>WTKFramework03</b> 
that I provided in the lesson titled <i>Using Alerts, Images, Timers, and Gauges 
in MIDlets (see <a href="#Resources">Resources</a>)</i>.&nbsp; Experiment with the 
MIDlet code, making changes and running your modified MIDlets in the framework 
program.&nbsp; See if you can explain the results produced by your changes.</p>
<p>Don't forget that you will need to download and install the latest version of 
the Sun Java Wireless Toolkit for CLDC <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
As of the date this lesson is being written, the latest version of the toolkit 
is WTK2.5.2.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, you learned how to use several methods of the <b>Canvas</b> 
class <i>(including <b>paint</b> and <b>repaint</b>)</i>, along with several methods of the <b>
Graphics</b> class to draw text and lines on the cell phone screen.&nbsp; You 
learned how to use anchor point coordinates to control the position of text that 
is drawn on the screen.&nbsp; You also learned how to handle <b>keyPressed</b> 
events fired by a <b>Canvas</b> object.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In Part 2 of this lesson, you will learn how to mix image file data and drawn 
graphics on a cell phone screen.&nbsp; You will learn how to draw various shapes such 
as rectangles, circles, arcs, filled triangles, and rounded rectangles.&nbsp; You 
will learn how to use an off-screen image, and how to use the event handling 
capability of the <b>Canvas</b> class for simple animation.&nbsp; You will also learn 
how to make you MIDlet animations efficient by minimizing the screen area that 
must be repainted.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/sjwtoolkit/download-2_5.html">
	Download</a> Sun Java Wireless Toolkit 2.5 for CLDC Release</li>
	<li><a href="http://en.wikipedia.org/wiki/MIDlet">MIDlet</a>: From 
	Wikipedia, the free encyclopedia</li>
	<li><a href="http://www.scmad.com/j2me-glossary1.php">MIDlet</a>: According 
	to SCMAD Certification Center</li>
	<li><a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html">J2ME 
	Tutorial, Part 1: Creating MIDlets</a> by Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step4">
	Pre-verifying</a> MIDlet code according to Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step7">
	Deploying</a> a MIDlet according to Vikram Goyal</li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/device/device;jsessionid=3F91C410E754F34B1A44DEBCE011ED18">
	The Java ME Device Table</a></span></li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/midp/ttips/getAppProperty/index.html">
	Retrieving MIDlet Attributes</a> by Richard Marejka</span></li>
	<li><a href="http://developers.sun.com/mobility/learn/midp/lifecycle/">
	Learning Path: MIDlet Life Cycle</a></li>
	<li><span class="style2">
	<a href="http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html?page=1">
	When Runtime.exec() won't</a> By </span>Michael C. Daconta</li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration">
	Connected Limited Device Configuration</a> <i>(CLDC)</i> from
	<span class="style2">Wikipedia</span></li>
	<li><span class="style2">
	<a href="http://en.wikipedia.org/wiki/Mobile_Information_Device_Profile">
	Mobile Information Device Profile</a> <i>(MIDP)</i> from Wikipedia</span></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr030/">CLDC 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr139/">CLDC 1.1</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr037/">MIDP 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr118/">MIDP 2.0</a></li>
	<li><a href="http://www.pictureresize.org/online-images-converter.html">Free 
	Online Image Converter</a></li>
	<li><a href="http://www.dickbaldwin.com/java/Java062.htm">62</a>
	<font color="#000000">Event Handling in JDK 1.0.2, The Event Class</font></li>
	<li><a href="http://www.dickbaldwin.com/java/Java080.htm">80</a>
	<font color="#000000">Event Handling in JDK 1.1, A First Look, Delegation 
	Event Model</font></li>
	<li><a href="http://www.dickbaldwin.com/java/Java102.htm">102</a>
	<font color="#000000">Handling Events in Extended Components without 
	Listener Objects</font></li>
	<li><a href="http://www.developer.com/java/other/article.php/3300881">1640</a> 
	The Essence of OOP using Java, Anonymous Classes</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3719111">
	2570</a> Getting Started with MIDlets and the Sun Java Wireless Toolkit for 
	CLDC</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3721706">
	2572</a> Capturing Output Produced by Programs Running in a Child Process</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3724381">
	2574</a> Back to Basics with MIDlets and the Sun Java Wireless Toolkit for 
	CLDC</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3727396">
	2576</a> Introduction to the MIDlet User Interface, A First Look</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3730141">
	2578</a> Handling Life-Cycle Issues with the MIDlet User Interface</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3736301">2580</a> 
	Using Alerts, Images, Timers, and Gauges in MIDlets</li>
	<li><a href="http://www.developer.com/java/other/article.php/3742196">2582</a> 
	Using Lists in MIDlets</li>
	<li><a href="http://www.developer.com/java/other/article.php/3747896">2584</a> 
	Using Forms and Items in MIDlets</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3753321">2586</a> Programming MIDlets for Interactive Behavior</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
11 and Listing 12 below.<p>
<b><a name="Listing_11">Listing 11</a>. Source code for the MIDlet named Canvas01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Canvas01.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to illustrate a simple 
MIDlet using a Canvas object and a Graphics object. It
further illustrates the use of anchor point constants to
establish the alignment of drawn text.

The MIDlet begins by painting the entire screen white.
Otherwise, the new drawing would appear on top of what
was previously on the screen.

Then it sets the drawing color to black.

Then it draws eight pairs of graphic objects.  Each pair 
consists of:

A line from 0,0 to a specific coordinate value on the
 canvas.
A string of text with the anchor point set to match the
 end of the line. The text contents of each string give
 the combination of anchor point constants used to
 position that particular string. Some text strings also
 begin with a lower case y- to show the effect of
 descenders on the alignment of the text string.

The eight pairs of graphic objects illustrate the effect 
of different combinations of the following anchor point 
constants as well as the impact of lower-case descenders
on the alignment produced by the constants:

TOP
BASELINE
BOTTOM

LEFT
HCENTER
RIGHT

An anchor point must be specified for each text string 
that is drawn. The anchor point must be produced by the
bitwise inclusive OR of one of the top three vertical 
anchor constants and one of the bottom three horizontal 
anchor constants. For example, the following would be a
valid anchor point:

TOP|RIGHT

The actual position and the alignment of the text string 
are determined by the combination of a pair of specified 
coordinate values and the bitwise inclusive OR of two 
anchor constants. The coordinates specify the position 
that will be assumed by a particular point in the text 
string. The bitwise inclusive OR of two anchor constants
determines which point in the text string will be located
at the specified coordinates.

The special anchor point value of zero is interpreted to 
mean TOP|LEFT.

A pair of straight lines is used to connect the ends of
two groups of sloping lines.  This makes it easier to
visually determine the location of the anchor point in
each text string.

This MIDlet illustrates the use of the following methods
from the Graphics class:

setColor
fillRect
drawLine
drawString

It also illustrates the use of the following method from
the Canvas class:

paint
repaint
getWidth
getHeight

The MIDlet displays the canvas for 20 seconds and then
enters the destroyed state.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package Canvas01;

import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;
import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Graphics;

public class Canvas01 extends MIDlet{
  Canvas myCanvas;

  public Canvas01(){
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    //Guarentee that the screen gets painted.
    myCanvas.repaint();
  }//end constructor

  public void startApp(){
                                  
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);

    //Sleep for 20 seconds.
    try{Thread.currentThread().sleep(20000);
    } catch(Exception e){}

    //Enter the destroyed state.
    this.destroyApp(true);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//
  
  //member class
  class MyCanvas extends Canvas{
    public void paint(Graphics g){
      //Paint the entire screen white. Otherwise, the new
      // drawing will simply appear over top of what was
      // previously on the screen.
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      //Set the drawing color to black.
      g.setColor(0x000000);

      //Draw text at eight different anchor points. The
      // text shows the vertical and horizontal constants
      // required to set the respective anchor points.
      // In addition, a line is drawn from 0,0 to the
      // anchor point to visually identify the anchor
      // point. A lower-case y is used to show the effect
      // of descenders on the alignment of the text.
      g.drawLine(0,0,200,20);
      g.drawString("y-TOP|RIGHT",200,20,
                             Graphics.TOP|Graphics.RIGHT);
      
      g.drawLine(0,0,150,40);
      g.drawString("y-TOP|HCENTER",150,40,
                           Graphics.TOP|Graphics.HCENTER);
      
      g.drawLine(0,0,100,60);
      g.drawString("y-TOP|LEFT",100,60,
                              Graphics.TOP|Graphics.LEFT);
      
      g.drawLine(0,0,100,90);
      g.drawString("y-BOTTOM|LEFT",100,90,
                           Graphics.BOTTOM|Graphics.LEFT);
                           
      g.drawLine(0,0,100,110);
      g.drawString("BOTTOM|LEFT",100,110,
                           Graphics.BOTTOM|Graphics.LEFT);
      
      g.drawLine(0,0,100,130);
      g.drawString("y-BASELINE|LEFT",100,130,
                         Graphics.BASELINE|Graphics.LEFT);
                         
      g.drawLine(0,0,100,150);
      g.drawString("BASELINE|LEFT",100,150,
                         Graphics.BASELINE|Graphics.LEFT);
                          
      g.drawLine(0,0,100,170);
      g.drawString("Special Case of Zero",100,170,0);
      
      //Draw straight lines that connect the ends of the
      // sloping lines.
      g.drawLine(200,20,100,60);
      g.drawLine(100,60,100,170);

    }//end overridden paint method
  }//end member class MyCanvas

}//end class Canvas01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Source code for the MIDlet named Canvas02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Canvas02.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to illustrate the 
detection and handling of key events on a Canvas object.
The MIDlet also demonstrates certain aspects of the
FullScreenMode versus the normal mode.

A Canvas object is instantiated and set to FullScreenMode.

The inherited keyPressed method is overridden to capture
a user keystroke, convert the key code to a key name, add
the key name to a Vector object, and cause the screen to
be repainted each time a keyPressed event occurs.

The paint method is overridden to clear the canvas,
extract all of the key names from the Vector, and display
the key names in two columns by using the drawString
method to draw the key names on the Canvas object.

Note, on the Sun cell phone emulator, you can terminate
the MIDlet by clicking the button on the right that has
a picture of a horizontal telephone receiver. When you
point to this button, the picture of the telephone
receiver should turn red. I did not register an EXIT
command listener because I did not want to cause the
left soft key to be occupied with a command when in
normal mode.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package Canvas02;

import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;
import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Displayable;
import java.util.Vector;

public class Canvas02 extends MIDlet{
  Canvas myCanvas;

  public Canvas02(){
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    //Guarentee that the screen gets painted.
    myCanvas.repaint();
    
    //Note: The following commands cannot be activated
    // because there is no CommandListener registered on
    // the Canvas object. They are here solely to
    // demonstrate the impact of FullScreenMode versus
    // normal mode. When the Canvas object is set to
    // FullScreenMode, as is the case in this MIDlet,
    // these commands are not displayed. Therefore, even
    // if a CommandListener were registered on the Canvas,
    // it would not be possible for the user to activate
    // the commands.  In normal mode, the commands are
    // displayed. If there was a CommandListener
    // registered on the Canvas, the user could activate
    // the commands. You can demonstrate this behavior by
    // modifying the code to pass true or false to the
    // setFullScreenMode method in the MyCanvas
    // constructor. 
    myCanvas.addCommand(new Command("EXIT",
                                         Command.EXIT,2));
    myCanvas.addCommand(new Command("BACK",
                                         Command.BACK,2));
    myCanvas.addCommand(new Command("OK",Command.OK,2));
  }//end constructor

  public void startApp(){
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//
  
  //Member class
  class MyCanvas extends Canvas{
    Vector vect = new Vector();
    
    MyCanvas(){//constructor
      //Note: In normal mode, the gray bar where the soft
      // key commands normally appear is visible at the
      // bottom of the screen.  However, in
      // FullScreenMode, that gray bar disappears. This
      // seems it make it impossible for the user to
      // activate commands on the Canvas when in
      // FullScreenMode. You can demonstrate this behavior
      // by either removing the following statement or
      // modifying the code to pass false to the
      // setFullScreenMode method. Passing false to the
      // method will switch the Canvas to normal mode.
      this.setFullScreenMode(true);
    }//end constructor
    
    public void paint(Graphics g){
      //Paint the entire screen white.
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      g.setColor(0x000000);//Set drawing color to black
      
      //Declare and initialize some working variables.
      String keyData = null;
      int fontHeight = g.getFont().getHeight();
      //Number of lines of text that fit on screen.
      int cntLimit = this.getHeight()/fontHeight;
      int yOffset = 0;
      int xOffset = 0;
      
      //Display the data captured from the user keyboard
      // input in two columns using graphic display
      // capabilities. If the length of the second
      // column exceeds the height of the screen, the
      // data will simply fall off the bottom of the
      // screen.
      for(int cnt = 0;cnt &lt; vect.size();cnt++){
        keyData = (String)vect.elementAt(cnt);//note cast

        if(cnt * fontHeight &lt; this.getHeight() - 
                                              fontHeight){
          //Display in first column.
          yOffset = cnt * fontHeight;
          xOffset = 5;
        }else{
          //Display in second column
          yOffset = (cnt - cntLimit) * fontHeight;
          xOffset = this.getWidth()/2;
        }//end else
        
        //Draw the string on the Canvas.
        g.drawString(keyData,xOffset,yOffset,0);
      }//end for loop

    }//end overridden paint method
    //--------------------------------------------------//
    
    //Override the keyPressed method to:
    // capture keystrokes
    // save them in a Vector object
    // repaint the canvas.
    public void keyPressed(int keyCode){
      vect.addElement(getKeyName(keyCode));
      this.repaint();
    }//end keyPressed
  }//end member class MyCanvas

}//end class Canvas02</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java J2ME MIDlet &quot;cell phone emulator&quot; &quot;wireless toolkit&quot; WTK MIDP CLDC 
Displayable TextBox Ticker TextField Alerts Images Timers Gauges Lists Forms 
Items String StringItem ImageItem ChoiceGroup DateField Command CommandListener 
ItemCommandListener Canvas Graphics &quot;anchor point&quot; keyPressed paint repaint</p>
<p>-end- </p>
</body>
</html>
