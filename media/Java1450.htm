<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Fun with Java: Sprite Animation, Part 1</h2>
<i>Programming in Java doesn't have to be dull and boring.&nbsp; In fact,
it's possible to have a lot of fun while programming in Java.&nbsp; This
is the first lesson in a miniseries that will concentrate on having fun
while programming in Java.</i>
<p><b>Published:</b>&nbsp; October 1, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1450
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
Programming in Java doesn't have to be dull and boring.&nbsp; In fact,
it's possible to have a lot of fun while programming in Java.&nbsp; This
is the first lesson in a miniseries that will concentrate on having fun
while programming in Java.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Animation is fun</font></b>
<p><font color="#000000">When it comes to having fun while programming,
it's hard to beat a good old fashioned program that provides visual feedback
and stimulation.&nbsp; And in that category, it's hard to beat an animation
program.</font>
<p><font color="#000000">This is the first of several lessons that will
teach you how to write animation programs in Java.&nbsp; These lessons
will teach you how to write sprite animation, frame animation, and a combination
of the two.&nbsp; Once you know how to do animation, there are lots of
ways to put that knowledge to use.&nbsp; For example, you could use that
newfound knowledge to write some neat game programs.&nbsp; Or, you could
take your newfound knowledge and use it to explore the world of <i>Artificial
Life</i>.</font>
<p><b><font color="#FF0000">Descriptions of upcoming programs</font></b>
<p><font color="#000000">The first program that I will discuss in this
and the next few lessons will show you how to write a program in which
you animate a group of colored spherical sea creatures swimming around
in a fish tank.&nbsp; A screen shot of the output produced by this program
is shown in Figure 1.</font>
<center>
<p><img SRC="java1450a.gif" height=212 width=301>
<p><font color="#000000">Figure 1.&nbsp; Animated spherical sea creatures
in a fish tank.</font></center>

<p><b><font color="#FF0000">Uses sprite animation</font></b>
<p><font color="#000000">This program will use sprite animation to cause
the spherical creatures to swim around.&nbsp; Of course, the screen shot
doesn't do justice to the effect that you will see when you run the program
in its animated form.</font>
<p><b><font color="#FF0000">Using frame animation to change colors</font></b>
<p><font color="#000000">If you watch The Discovery Channel or The Learning
Channel very much, you will already know that many sea creatures have the
ability to change their color in very impressive ways.&nbsp; The second
program that I will discuss will simulate that process.&nbsp; It will use
sprite animation to cause the spherical creatures to swim, and will also
use frame animation to cause them to change their color at the same time.&nbsp;
Since a screen shot can't show the creatures changing colors, a screen
shot of the second program would look very similar to the screen shot in
Figure 1 above.&nbsp; Therefore, I didn't provide a screen shot of the
second program.</font>
<p><b><font color="#FF0000">How about some sea worms?</font></b>
<p><font color="#000000">A screen shot of the output from the third program
is shown in Figure 2.</font>
<center>
<p><img SRC="java1450b.gif" height=212 width=301>
<p><font color="#000000">Figure 2.&nbsp; Animated sea worms in a fish tank.</font></center>

<p><font color="#000000">This program will use a combination of sprite
animation, frame animation, and some other techniques to cause a group
of multi-colored sea worms to slither around in the fish tank.&nbsp; In
addition to slithering, the sea worms will also change the color of different
parts of their body, much like the real sea creatures that have this amazing
ability to change the colors on their bodies do.</font>
<p><b><font color="#FF0000">The required GIF files</font></b>
<p>Figure 3 shows the GIF image files that you will need to run these three
programs.
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td>
<center><pre><img SRC="java1450c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1450d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1450e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1450f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1450g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1450h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1450i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center>
<p>Figure 3.&nbsp; GIF image files that you will need.</center>

<p>You should be able to capture the various images from Figure 3 by right-clicking
on them individually, and then saving them into files on your local disk.
<p><b><font color="#FF0000">Rename the captured files</font></b>
<p>Having done that, you will need to rename the files to match the names
that are hard-coded into the programs <i>(or change the names in the programs
to match the names of your files).</i>
<p><b><font color="#FF0000">Important classes</font></b>
<p>In this lesson, I will introduce you to several classes and concepts
that you must understand in order to understand animation in Java.
<p>Included in the classes that I will discuss will be the following, which
are particularly important to sprite animation:
<ul>
<li>
Image</li>

<li>
Toolkit</li>

<li>
Graphics</li>

<li>
MediaTracker</li>

<li>
Random</li>
</ul>
<b><font color="#FF0000">Important concepts</font></b>
<p>I will also discuss a number of concepts, including the following, which
are particularly important to sprite animation:
<ul>
<li>
offscreen graphics contexts</li>

<li>
coordinates in Java graphics</li>

<li>
translation origins</li>

<li>
the drawImage method</li>

<li>
animation repetition rates</li>

<li>
pseudo-random numbers</li>
</ul>
<b><font color="#FF0000">Preview of control structure</font></b>
<p>Here is a preview of the control structure that I will use for this
animation program.
<p>The controlling class extends the <b>Frame</b> class and implements
the <b>Runnable </b>interface.&nbsp; Thus, an object of the controlling
class is used to provide the visual manifestation of the program as a visual
<b>Frame</b>
object.&nbsp; An object of the controlling class is also suitable for using
as an animation thread, which controls the overall behavior of the animation
process.&nbsp; In other words, an object of the controlling class acts
both as the director of the play, and the stage upon which the play is
performed.
<p>The <b>main</b> method of the controlling class instantiates an object
of the controlling class, thus causing the constructor for the controlling
class to be executed.
<p><b><font color="#FF0000">Objects of type Image</font></b>
<p>The constructor for the controlling class causes seven <b>Image</b>
objects to be created.&nbsp; Each <b>Image</b> object is based on the pixel
contents of a GIF file.
<p>One of the <b>Image</b> objects is used to produce the background scenery
against which the animation is played out.&nbsp; The other six <b>Image</b>
objects are used to provide the visual manifestation of the sprites.
<p>Each <b>Image</b> object provides the visual manifestation for more
than one sprite.&nbsp; Therefore, some of the sprites look alike<i> (twins
in some cases and triplets in others).</i>
<p><b><font color="#FF0000">Set the Frame size</font></b>
<p>After the <b>Image</b> objects have been created, the size of the <b>Image</b>
object used for the background scenery is used by the constructor to set
the size of the <b>Frame</b>.&nbsp; Then the <b>Frame</b> is made visible.
<p><b><font color="#FF0000">Start the animation thread</font></b>
<p>Finally, the constructor creates the animation thread and starts it
running.&nbsp; From this point forward, the <b>run</b> method of the controlling
class controls the animation behavior of the program.
<p><b><font color="#FF0000">The run method</font></b>
<p>The <b>run</b> method begins by creating and populating a <b>SpriteManager</b>
object.&nbsp; An object of the <b>SpriteManager </b>class is capable of
managing a collection of sprites, causing them to update their positions
on demand, and dealing with collisions between the sprites.
<p><b><font color="#FF0000">The SpriteManager object</font></b>
<p>The <b>SpriteManager</b> object is populated with fifteen separate <b>Sprite</b>
objects.&nbsp; Each sprite has a visual manifestation based on one of the
six <b>Image</b> objects.&nbsp; Each sprite also has an initial position
based on a random number and has a <i>motion vector<b> </b></i>whose components
are also based on random numbers.&nbsp; The motion vector is used to determine
the next position of the sprite when the sprite is told by the <b>SpriteManager</b>
to change its position.
<p><b><font color="#FF0000">The animation loop</font></b>
<p>Then the <b>run</b> method enters an infinite loop, iterating approximately
twelve times per second.&nbsp; At the beginning of each iteration, the
<b>SpriteManager</b>
is told to update the positions of all of the sprites in its collection.&nbsp;
It does so, dealing with collisions in the process.
<p>The <b>run</b> method sends a message to the operating system asking
it to repaint the <b>Frame</b> object on the screen.
<p><b><font color="#FF0000">The upDate method</font></b>
<p>When the operating system honors the request to repaint, it invokes
the <b>upDate</b> method on the <b>Frame</b> object, <i>(which normally
does some initialization and then invokes the paint method).</i>
<p>The <b>update</b> method is overridden in this program to cause the
new scene to be drawn in its entirety, showing each of the sprites in its
new position superimposed upon the background image.&nbsp; Note that in
this case, the <b>update</b> method does not invoke the <b>paint</b> method,
because there is nothing for the <b>paint</b> method to do.
<p><b><font color="#FF0000">An offscreen image</font></b>
<p>When drawing the scene, the <b>update</b> method first draws the scene
on an offscreen graphics context, and then causes the scene to be transferred
from that context to the screen context.&nbsp; This is done to improve
the animation quality of the program.
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
That's enough of the preliminaries.&nbsp; It's time to get down to business
and start discussing code.
<p><b><font color="#FF0000">A fairly long program</font></b>
<p>This is a fairly long program.&nbsp; It is so long, in fact, that several
lessons will be required to discuss it fully.&nbsp; However, rather than
to make you wait until I complete all of those lessons to get your hands
on the program, I have provided a copy of the entire program in Listing
6 near the end of the lesson.&nbsp; That way, you can copy it into a source
file on your local disk, compile it, run it, and start seeing the results
immediately.
<p><b><font color="#FF0000">Will discuss in fragments</font></b>
<p>As usual, I will discuss the program in fragments.&nbsp; In addition
to the controlling class named <b>Animate01</b>, the program contains several
other important classes.&nbsp; I will discuss the controlling class in
this lesson and defer my discussion of the other classes until future lessons.&nbsp;
In fact, the controlling class itself is quite long, so I will partition
the discussion of the controlling class into several consecutive lessons
as well.
<p><b><font color="#FF0000">Acknowledgment</font></b>
<p>Before getting into the details, I want to acknowledge that some of
the techniques used in this program, such as the animation timer and the
collision detector, were taken from the book entitled <u>Teach Yourself
Internet Game Programming with Java in 21 days</u>, by Michael Morrison.
<p>The copy of the book that I have is the first edition <i>(I don't know
if there are later editions)</i> and is somewhat dated by now <i>(for example,
it uses the original JDK 1.0 event model)</i>.&nbsp; However, even though
Java has been updated significantly since the publication of the book,
some techniques discussed in the book are still appropriate for use.
<p>In addition, the book provides a good discussion of the benefits of
Object-Oriented Programming.&nbsp; That information is beneficial to anyone
embarking on a career as a Java programmer.
<p><b><font color="#FF0000">The controlling class</font></b>
<p>The beginning of the class definition for the controlling class named
<b>Animate01</b>
is shown in Listing 1.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public class <b>Animate01</b> extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable{
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Extends the Frame class</font></b>
<p>As you can see, the controlling class extends the <b>Frame</b> class
<i>(extending
JFrame would work just as well provided that you take the Swing content
pane into account).</i>&nbsp; This causes an object instantiated from the
controlling class to be suitable as a drawing surface for the animation.&nbsp;
Thus, the animation images are presented directly on the surface of the
<b>Frame</b>
as shown in Figure 1 and Figure 2.
<p><b><font color="#FF0000">Implements the Runnable interface</font></b>
<p>The controlling class also implements the <b>Runnable</b> interface.&nbsp;
This makes it suitable for use as a <b>Thread</b> object.&nbsp; We will
see later that the animation loop is actually implemented inside the <b>run</b>
method of the controlling class.
<p><b><font color="#FF0000">The Image Class</font></b>
<p>The code in Listing 1 declares three reference variables.&nbsp; The
first two are reference variables of the type <b>Image</b>.&nbsp; The third
is a reference variable that refers to an array object containing six references
to objects of type <b>Image</b>.&nbsp; From this, you might surmise that
an understanding of the <b>Image</b> class is important to this type of
animation, and if so, you are correct.
<p><b><font color="#FF0000">What does Sun have to say about the Image class?</font></b>
<p>Here is part of what Sun has to say about the <b>Image</b> class:
<blockquote><i>"The abstract class Image is the superclass of all classes
that represent graphical images. The image must be obtained in a platform-specific
manner."</i></blockquote>
Because <b>Image</b> is an abstract class, we can't directly instantiate
objects of the class.&nbsp; We will see later that we obtain our objects
of type <b>Image</b> using a roundabout approach involving the <b>Toolkit</b>
class.&nbsp; <i>(I will have more to say about that later.)</i>
<p><b><font color="#FF0000">The Toolkit class</font></b>
<p>For the time being, suffice it to say the <b>Toolkit</b> class makes
it possible to gain access to <i>system-dependent</i> resources using <i>system-independent</i>
code.
<p><i>(Other examples of the use of the Toolkit class have to do with the
system event queue, and access to system printers, which I discuss at length
in other lessons.)</i>
<p><b><font color="#FF0000">Getting Image objects</font></b>
<p>We will get our <b>Image</b> objects by invoking one of the overloaded
<b>getImage</b>
methods of the <b>Toolkit</b> class.&nbsp; Once we get an <b>Image</b>
object, we really won't know the name of the class from which it was instantiated.&nbsp;
Furthermore, we won't care about the name of the class from which it was
instantiated.&nbsp; We will know simply that we can treat it as type
<b>Image</b>
and let polymorphic behavior take care of us.
<p><i>(Hopefully, you already know all about polymorphic behavior.&nbsp;
If not, I discuss it in detail in several other lessons, including the
lessons on the Collections Framework.)</i>
<p><b><font color="#FF0000">Using Image objects</font></b>
<p>The <b>Image</b> class <i>(and the classes that extend it)</i> define
<i>(or
override)</i> a number of useful methods that we will use throughout the
program.&nbsp; This will include the methods named <b>getGraphics</b>,
<b>getWidth</b>,
and <b>getHeight</b>.
<p><b><font color="#FF0000">The Graphics class</font></b>
<p>The code in Listing 2 declares two more reference variables.&nbsp; Of
particular interest at this point is the reference variable of type <b>Graphics</b>.&nbsp;
This particular variable will be used to refer to an object that will serve
as offscreen graphics context.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; private <b>Graphics</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What is an offscreen graphics context?</font></b>
<p>Put simply, in this program, an offscreen graphics context is an area
of memory that serves as a stand-in for the computer screen.
<p>We use the methods of the <b>Graphics</b> class to draw pictures in
that memory without disturbing the pictures currently showing on the computer
screen.
<p><b><font color="#FF0000">Why use an offscreen graphics context?</font></b>
<p>Then we can blast the pictures from the offscreen graphics context to
the actual computer screen very rapidly.
<p>This is an important capability for animation.&nbsp; A noticeable amount
of time is often required to create a picture.&nbsp; Because this approach
doesn't disturb the visible image during the time required to create the
picture, it usually results in smoother animation than can be achieved
by creating and drawing the pictures directly on the computer screen.&nbsp;
It eliminates the flashing and other distractions that can occur when the
material is being displayed as it is being created.
<p><b><font color="#FF0000">What does Sun have to say about the Graphics
class?</font></b>
<p>The sun documentation has quite a lot to say about the <b>Graphics</b>
class in general.&nbsp; Here is a brief sampling:
<blockquote><i>"The Graphics class is the abstract base class for all graphics
contexts that allow an application to draw onto components that are realized
on various devices, as well as onto offscreen images."</i></blockquote>
For example, printing in Java involves the use of methods of the <b>Graphics</b>
class to draw pictures on the paper in the printer.&nbsp; It doesn't matter
whether those pictures represent landscapes or letters; they are pictures
nonetheless.&nbsp; In that sense, the printer paper can be thought of as
a <i>graphics context</i>.
<p><b><font color="#FF0000">Our graphics contexts</font></b>
<p>In this program, we will be particularly interested in two graphics
contexts:
<ul>
<li>
The computer screen.</li>

<li>
An offscreen image.</li>
</ul>
<b><font color="#FF0000">More info from Sun</font></b>
<p>Here is more of what Sun has to say about the <b>Graphics</b> class:
<blockquote><i>"A Graphics object encapsulates state information needed
for the basic rendering operations that Java supports. This state information
includes the following properties ..."</i></blockquote>
Sun goes on to list several properties, which won't be too important to
us in this lesson.
<p><b><font color="#FF0000">Location, width, and height</font></b>
<p>In this lesson, we will frequently be working with the location, width,
and height of images.&nbsp; This requires some knowledge of how coordinate
positions are treated.&nbsp; In this regard, Sun says:
<blockquote><i>"All coordinates that appear as arguments to the methods
of this Graphics object are considered relative to the translation origin
of this Graphics object prior to the invocation of the method."</i></blockquote>
<b><font color="#FF0000">What is a translation origin?</font></b>
<p>By default, the plotting origin of a graphics surface is the upper left-hand
corner of the surface on which the plotting is being performed.&nbsp; That
origin can be translated to a different spot <i>(the translation origin),</i>
but none of the code in this lesson does that.
<p>Positive horizontal coordinates progress from left to right across the
graphics surface <i>(relative to the origin).</i>&nbsp; Positive vertical
coordinates progress from top to bottom down the surface <i>(relative to
the origin).</i>
<p><i>(The translation origin for the images produced by this program is
the upper-left corner of the Frame object.)</i>
<p><b><font color="#FF0000">The drawImage methods</font></b>
<p>The <b>Graphics</b> class, <i>(and its subclass named Graphics2D)</i>
provide dozens of methods that can be used to draw pictures on a graphics
context.&nbsp; However, most of those methods have to do with drawing lines,
circles, polygons, etc.
<p>Only about eight methods are provided for drawing images, and most of
those methods are overloaded versions of the method named <b>drawImage</b>.&nbsp;
The <b>drawImage</b> method will surely become our friend in this and the
next few lessons.
<p><b><font color="#FF0000">The Thread class</font></b>
<p>The other reference variable declared in the code in Listing 2 is of
type <b>Thread</b>.&nbsp; Hopefully you already know all about Java threads.&nbsp;
If not, I have published several lessons explaining the use of threads
on my web site, and you should probably refer to them before getting too
far into this program.
<p><b><font color="#FF0000">The MediaTracker class</font></b>
<p>The variable declaration in Listing 3 exposes one of the more abstract
issues involved in this program, the <b>MediaTracker</b> class.
<p>The primary purpose of the <b>MediaTracker</b> class is to help you
deal with time delays that may occur when loading image data into memory.&nbsp;
If the images are being loaded via the Internet, those time delays can
be quite long.&nbsp; Even if the images are being loaded from a local hard
drive, the delays can be long enough to be troublesome.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; private <b>MediaTracker</b> mediaTracker;

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p>In other words, when you are using images, you need to know the load
status of each image before you try to use it.&nbsp; If it hasn't finished
loading, you must be careful what you try to do with it.
<p><b><font color="#FF0000">What does Sun have to say about MediaTracker?</font></b>
<p>Here is part of what the Sun documentation for JDK 1.3 has to say about
the <b>MediaTracker</b> class:
<blockquote><i>"The MediaTracker class is a utility class to track the
status of a number of media objects. Media objects could include audio
clips as well as images, though currently only images are supported.</i>
<p><i>To use a media tracker, create an instance of MediaTracker and call
its addImage method for each image to be tracked.</i>
<p><i>In addition, each image can be assigned a unique identifier. This
identifier controls the priority order in which the images are fetched.
It can also be used to identify unique subsets of the images that can be
waited on independently. Images with a lower ID are loaded in preference
to those with a higher ID number."</i></blockquote>
<b><font color="#FF0000">How do you use a MediaTracker object?</font></b>
<p>Once you have registered an image with a <b>MediaTracker</b> object
<i>(using
the addImage method and identifying the image with a specific ID value),</i>
there are several methods that you can invoke on the <b>MediaTracker</b>
object to learn the current status of the image.
<p>Some of the methods allow you to manipulate the images in other ways,
such as <i>unregistering</i> an image using the <b>removeImage</b> method.
<p><b><font color="#FF0000">The MediaTracker methods</font></b>
<p>Here is a partial list of the available methods <i>(note that, as usual,
some of the methods have several overloaded versions).</i>
<ul>
<li>
checkAll</li>

<li>
checkID</li>

<li>
getErrorsAny</li>

<li>
getErrorsID</li>

<li>
isErrorAny</li>

<li>
isErrorID</li>

<li>
removeImage</li>

<li>
statusAll</li>

<li>
statusID</li>

<li>
waitForAll</li>

<li>
waitForID</li>
</ul>
The names of these methods are fairly descriptive, so you should be able
to surmise what most of them do.
<p>I will use some of these methods in this program to track the loading
of GIF images that are used for the background graphic and the sprites.
<p><b><font color="#FF0000">The SpriteManager class</font></b>
<p>Listing 4 shows the declaration of three additional instance variables.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>The <b>SpriteManager</b> class is defined in this program.&nbsp; As
the name implies, an object of this class is used to manage the sprites
involved in the animation process.&nbsp; This class will be discussed in
detail in a subsequent lesson.
<p><b><font color="#FF0000">Animation repetition rate</font></b>
<p>The variable named <b>animationDelay</b> is used to control the repetition
rate of the animation process.
<p>As in the movies, or on TV, animation is achieved by presenting a series
of pictures on the screen.&nbsp; Each picture represents a slightly different
version of an object being animated.
<p><i>(When I was a child, I used to create stick-man movies by drawing
different versions of a stick-man doing acrobatics on the edges of the
pages in a book.&nbsp; By rapidly flipping through the pages with my thumb
and forefinger, I could animate the stick-man and cause him to do his acrobatics.)</i>
<p><b><font color="#FF0000">What is the required repetition rate?</font></b>
<p>The pictures need to be presented at a sufficiently fast rate to fool
the brain and give the illusion of continuous motion.&nbsp; On the other
hand, presenting the pictures too rapidly simply wastes computer resources
because the animation quality is not significantly improved.
<p><b><font color="#FF0000">Is twelve repetitions per second adequate?</font></b>
<p>The <b>animationDelay</b> variable in Listing 4 is initialized to a
value of 83 milliseconds.&nbsp; This is used by the program to insert 83
milliseconds between repetitions of the animated sprites.&nbsp; This works
out to approximately 12 repetitions per second.&nbsp; Many authors agree
that this rate is a good compromise between too slow and too fast.&nbsp;
However, only you can be the final judge of that.
<p><b><font color="#FF0000">Changing the repetition rate</font></b>
<p>To the extent that you computer can handle it, it isn't difficult to
increase the repetition rate.&nbsp; Decrease the initialization value for
the <b>animationDelay</b> variable to increase the repetition rate, or
increase the value to decrease the repetition rate.
<p><i>Divide the animationDelay value into 1 to get the repetition rate.&nbsp;
Note, however, that if you make the animationDelay value too small, you
computer won't be able to achieve the repetition rate specified by your
new value for animationDelay.&nbsp; In that case, the computer will simply
be displaying new pictures as fast as it can create them.</i>
<p><b><font color="#FF0000">Pseudo-random numbers</font></b>
<p>As we go through the program, you will see a number of instances where
a random number is needed for some purpose.&nbsp; The third reference variable
in Listing 4 contains a reference to an object of the class <b>Rand</b>.&nbsp;
Here is part of what the Sun documentation has to say about the <b>Rand</b>
class:
<blockquote><i>"An instance of this class is used to generate a stream
of pseudo-random numbers. The class uses a 48-bit seed, ...</i>
<p><i>If two instances of Random are created with the same seed, and the
same sequence of method calls is made for each, they will generate and
return identical sequences of numbers."</i></blockquote>
<b><font color="#FF0000">The converse is also true</font></b>
<p>Although it isn't explicitly stated in the Sun documentation, the converse
of the second paragraph above is also true.&nbsp; In particular, if two
instances of <b>Random</b> are created with different seeds, and the same
sequence of method calls is made for each, they will generate and return
different sequences of numbers.
<p>In this program, I didn't want identical sequences of numbers.&nbsp;
Therefore, in the code shown in Listing 4, the <b>Random</b> object was
constructed using the current time in milliseconds <i>(relative to midnight
on January 1, 1970)</i> as the seed.&nbsp; Using this approach, unless
two <b>Random</b> objects are created within the same millisecond, they
will produce different sequences of numbers.
<p>In some cases, using time as a seed is inadequate.&nbsp; Other instances
of <b>Random</b> are created at other places in the program using seed
values based on something other than time.
<p><b><font color="#FF0000">What can you do with a Random object?</font></b>
<p>Once you have an object of the <b>Random</b> class, a number of methods
are available that allow you to extract random numbers from the object.
<p>For example, the method named <b>nextInt r</b>eturns the next pseudo
random, uniformly distributed <b>int</b> value from a random number generator's
sequence.&nbsp; This method will be used frequently, in conjunction with
the modulus operator
<b>(%)</b> to obtain random numbers that are uniformly
distributed between the positive and negative values of a particular whole
number <i>(between -8 and +8, for example).</i>
<p><b><font color="#FF0000">The main method</font></b>
<p>The code shown in Listing 5 is the <b>main</b> method for this application.&nbsp;
This code simply creates a new instance of the controlling class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public static void <b>main</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate01();
&nbsp; }//end main

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>This code, working in conjunction with the constructor and the <b>run</b>
method of the animation thread starts the program running.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have introduced you to several classes and concepts that
you must understand in order to understand animation in Java.
<p>I have introduced and discussed a number of classes used by the program.&nbsp;
Included were the following, which are particularly important to sprite
animation:
<ul>
<li>
Image</li>

<li>
Toolkit</li>

<li>
Graphics</li>

<li>
MediaTracker</li>

<li>
Random</li>
</ul>
I have also discussed a number of concepts, including the following, which
are particularly important to sprite animation:
<ul>
<li>
offscreen graphics contexts</li>

<li>
coordinates in Java graphics</li>

<li>
translation origins</li>

<li>
the drawImage method</li>

<li>
animation repetition rates</li>

<li>
pseudo-random numbers</li>
</ul>

<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
The next lesson in this series will pick up with a discussion of the constructor
for the <b>Animate01</b> class.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
6</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate01.java
Copyright 2001, R.G.Baldwin

This program displays several animated
colored spherical creatures swimming&nbsp;
around in an aquarium.&nbsp; Each creature&nbsp;
maintains generally the same course
with until it collides with another&nbsp;
creature or with a wall.&nbsp; However,&nbsp;
each creature has the ability to&nbsp;
occasionally make random changes in&nbsp;
its course.

**************************************/
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Animate01 extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable {
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];
&nbsp; //offscreen graphics context
&nbsp; private Graphics&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;
&nbsp; private MediaTracker mediaTracker;
&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate01();
&nbsp; }//end main
&nbsp; //---------------------------------//

&nbsp; Animate01() {//constructor
&nbsp;&nbsp;&nbsp; // Load and track the images
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Get and track the background&nbsp;
&nbsp;&nbsp;&nbsp; // image
&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("background02.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and track 6 images to use&nbsp;
&nbsp;&nbsp;&nbsp; // for sprites
&nbsp;&nbsp;&nbsp; gifImages[0] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("redball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);
&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("greenball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("blueball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("yellowball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("purpleball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("orangeball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Block and wait for all images to&nbsp;
&nbsp;&nbsp;&nbsp; // be loaded
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.waitForID(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Base the Frame size on the size&nbsp;
&nbsp;&nbsp;&nbsp; // of the background image.
&nbsp;&nbsp;&nbsp; //These getter methods return -1 if
&nbsp;&nbsp;&nbsp; // the size is not yet known.
&nbsp;&nbsp;&nbsp; //Insets will be used later to&nbsp;
&nbsp;&nbsp;&nbsp; // limit the graphics area to the&nbsp;
&nbsp;&nbsp;&nbsp; // client area of the Frame.
&nbsp;&nbsp;&nbsp; int width =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getWidth(this);
&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getHeight(this);

&nbsp;&nbsp;&nbsp; //While not likely, it may be&nbsp;
&nbsp;&nbsp;&nbsp; // possible that the size isn't
&nbsp;&nbsp;&nbsp; // known yet.&nbsp; Do the following&nbsp;
&nbsp;&nbsp;&nbsp; // just in case.
&nbsp;&nbsp;&nbsp; //Wait until size is known
&nbsp;&nbsp;&nbsp; while(width == -1 || height == -1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Waiting for image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWidth(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the frame
&nbsp;&nbsp;&nbsp; setSize(width,height);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2001, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; //Create and start animation thread
&nbsp;&nbsp;&nbsp; animationThread = new Thread(this);
&nbsp;&nbsp;&nbsp; animationThread.start();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner class window&nbsp;
&nbsp;&nbsp;&nbsp; // listener to terminate the&nbsp;
&nbsp;&nbsp;&nbsp; // program.
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public void run() {
&nbsp;&nbsp;&nbsp; //Create and add sprites to the&nbsp;
&nbsp;&nbsp;&nbsp; // sprite manager
&nbsp;&nbsp;&nbsp; spriteManager = new SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, backGroundImage));
&nbsp;&nbsp;&nbsp; //Create 15 sprites from 6 gif&nbsp;
&nbsp;&nbsp;&nbsp; // files.
&nbsp;&nbsp;&nbsp; for (int cnt = 0; cnt &lt; 15; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position = spriteManager.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEmptyPosition(new Dimension(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].getWidth(this),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.addSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeSprite(position, cnt % 6));
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Loop, sleep, and update sprite&nbsp;
&nbsp;&nbsp;&nbsp; // positions once each 83&nbsp;
&nbsp;&nbsp;&nbsp; // milliseconds
&nbsp;&nbsp;&nbsp; long time =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis();
&nbsp;&nbsp;&nbsp; while (true) {//infinite loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time += animationDelay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0,time -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end run method
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private Sprite makeSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex) {
&nbsp;&nbsp;&nbsp; return new Sprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[imageIndex],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Overridden graphics update method&nbsp;
&nbsp; // on the Frame
&nbsp; public void update(Graphics g) {
&nbsp;&nbsp;&nbsp; //Create the offscreen graphics&nbsp;
&nbsp;&nbsp;&nbsp; // context
&nbsp;&nbsp;&nbsp; if (offScreenGraphicsCtx == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createImage(getSize().width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage.getGraphics();
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Draw the sprites offscreen
&nbsp;&nbsp;&nbsp; spriteManager.drawScene(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx);

&nbsp;&nbsp;&nbsp; // Draw the scene onto the screen
&nbsp;&nbsp;&nbsp; if(offScreenImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage, 0, 0, this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end overridden update method
&nbsp; //---------------------------------//

&nbsp; //Overridden paint method on the&nbsp;
&nbsp; // Frame
&nbsp; public void paint(Graphics g) {
&nbsp;&nbsp;&nbsp; //Nothing required here.&nbsp; All&nbsp;
&nbsp;&nbsp;&nbsp; // drawing is done in the update&nbsp;
&nbsp;&nbsp;&nbsp; // method above.
&nbsp; }//end overridden paint method
&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Animate01
//===================================//

class BackgroundImage{
&nbsp; private Image image;
&nbsp; private Component component;
&nbsp; private Dimension size;

&nbsp; public BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image) {
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; size = component.getSize();
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end construtor
&nbsp;&nbsp;
&nbsp; public Dimension getSize(){
&nbsp;&nbsp;&nbsp; return size;
&nbsp; }//end getSize()

&nbsp; public Image getImage(){
&nbsp;&nbsp;&nbsp; return image;
&nbsp; }//end getImage()

&nbsp; public void setImage(Image image){
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end setImage()

&nbsp; public void drawBackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g) {
&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image, 0, 0, component);
&nbsp; }//end drawBackgroundImage()
}//end class BackgroundImage
//===========================

class SpriteManager extends Vector {
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage) {
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getEmptyPosition(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void update() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.updatePosition();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for collision. Positive&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result indicates a collision
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testForCollision(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitIndex >= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceOffSprite(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private int testForCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite) {
&nbsp;&nbsp;&nbsp; //Check for collision with other&nbsp;
&nbsp;&nbsp;&nbsp; // sprites
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void bounceOffSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawScene(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBackgroundImage(g);

&nbsp;&nbsp;&nbsp; //Iterate through sprites, drawing
&nbsp;&nbsp;&nbsp; // each sprite
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawSpriteImage(g);
&nbsp; }//end drawScene()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void addSprite(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()
&nbsp;&nbsp;
}//end class SpriteManager
//===================================//

class Sprite {
&nbsp; private Component component;
&nbsp; private Image image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;

&nbsp; public Sprite(Component component,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp;&nbsp;&nbsp; //Compute edges of usable graphics
&nbsp;&nbsp;&nbsp; // area in the Frame.
&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().top;
&nbsp;&nbsp;&nbsp; int bottomBorder =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public Rectangle getSpaceOccupied(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getMotionVector(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; Point position = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.&nbsp; This&nbsp;
&nbsp;&nbsp;&nbsp; // puts a cap on the maximum speed
&nbsp;&nbsp;&nbsp; // for a sprite.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point randomOffset =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Move the sprite on the screen
&nbsp;&nbsp;&nbsp; position.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

&nbsp;&nbsp;&nbsp; //Bounce off the walls
&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector = new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if ((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x + spaceOccupied.width)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(bounceRequired)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector);
&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.drawImage(image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public boolean testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; //Check for collision with&nbsp;
&nbsp;&nbsp;&nbsp; // another sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class
//===================================//

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2001, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
