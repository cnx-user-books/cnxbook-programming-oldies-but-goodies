<html>

<head>
<meta name=Generator content="Microsoft Office HTML Filter 2.0">
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name=Originator content="Microsoft Word 9">
<title>... in Java by Richard G Baldwin</title>
<style>
<!--
 
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h2
	{margin-right:0in;
	margin-left:0in;
	text-align:center;
	font-size:18.0pt;
	font-family:"Times New Roman";
	color:red;
	font-weight:bold;}
h3
	{margin-right:0in;
	margin-left:0in;
	font-size:13.5pt;
	font-family:"Times New Roman";
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:blue;
	text-decoration:underline;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";}
p
	{margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman";}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<meta name=author content="richard g. baldwin">
</head>

<body lang=EN-US link=blue vlink=blue>
<!--start-->

<div class=Section1>

<p>February 9, 2000</p>

<h2 align=left style='text-align:left'><!--title--><span style='color:black'>Java
2D Graphics, the Graphics2D Class<!--endtitle--></span></h2>

<p>Java Programming, Lecture Notes # 304</p>

<p><i>by Richard G. Baldwin<br>
baldwin@austin.cc.tx.us</i> </p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><a
     href="#_Introduction">Introduction</a></li>
 <li class=MsoNormal><a
     href="#_Coordinates">Coordinates</a></li>
 <li class=MsoNormal><a
     href="#_David_Flanagan_to">David Flanagan to the Rescue!</a></li>
 <li class=MsoNormal><a
     href="#_The_Rendering_Process">The Rendering Process</a></li>
 <li class=MsoNormal><a
     href="#_What_is_a">What is a Shape?</a></li>
 <li class=MsoNormal><a
     href="#_Types_of_Rendering">Types of Rendering Operations</a></li>
 <li class=MsoNormal><a
     href="#_The_Stroke_Interface">The Stroke Interface</a></li>
 <li class=MsoNormal><a
     href="#_Shape_Operations">Shape Operations</a></li>
 <li class=MsoNormal><a
     href="#_Text_Operations">Text Operations</a></li>
 <li class=MsoNormal><a
     href="#_Image_Operations">Image Operations</a></li>
 <li class=MsoNormal><a
     href="#_Rendering_Attributes">Rendering Attributes</a></li>
 <li class=MsoNormal><a
     href="#_Additional_Details_and">Additional Details and Compatibility
     Issues</a></li>
 <li class=MsoNormal><a
     href="#_Sample_Programs">Sample Programs</a></li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal><a
      href="#_Program_Graphics2D01.java">Program Graphics2D01.java</a></li>
  <li class=MsoNormal><a
      href="#_Program_Graphics2D02.java">Program Graphics2D02.java</a></li>
  <li class=MsoNormal><a
      href="#_Complete_Program_Listings">Complete Program Listings</a></li>
 </ul>
</ul>


<div class=MsoNormal align=center style='text-align:center'>

<hr size=3 width="100%" align=center>

</div>


<h2><a name="_Introduction"></a>Introduction</h2>

<p>The <b>Graphics2D</b> class<b>, </b>which was released with JDK 1.2, extends
the <b>Graphics</b> class to provide more sophisticated control over geometry,
coordinate transformations, color management, and text layout. Beginning with
JDK 1.2, this is the fundamental class for rendering two-dimensional shapes,
text and images.</p>

<p>Because it extends the <b>Graphics</b> class, the capabilities of the <b>Graphics</b>
class that existed in earlier versions of the JDK continue to be available.</p>

<p>Unfortunately, without understanding the behavior of other classes and
interfaces such as <b>Shape</b>, <b>AffineTransform</b>, <b>GraphicsConfiguration</b>,
<b>PathIterator</b>, and <b>Stroke</b>, it is not possible to fully understand
the inner workings of the <b>Graphics2D</b> class.</p>

<h3><span style='color:red'>Setter methods&nbsp; </span></h3>

<p>The manner in which <b>Graphics2D </b>renders shapes, text, and images
depends on the current values of several properties of the <b>Graphics2D </b>object.&nbsp;
The values of these properties are controlled using standard <i>setter</i>
methods of the class.&nbsp; This and subsequent lessons will discuss the
following methods that are used to set the properties of the object.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>setComposite()</b></li>
 <li class=MsoNormal><b>setPaint()</b></li>
 <li class=MsoNormal><b>setRenderingHint()</b></li>
 <li class=MsoNormal><b>setStroke()</b></li>
 <li class=MsoNormal><b>setTransform()</b></li>
</ul>

<p>This lesson provides an overview of <b>Graphics2D</b> and discusses
transforms.&nbsp; It illustrates the use of the <b>setTransform() </b>method
for <i>setting</i> an Affine transform.</p>

<p>Information about the other classes listed above, and additional information
about <b>Graphics2D</b> will be provided in subsequent lessons.</p>

<h2><a name="_Coordinates"></a>Coordinates</h2>

<p>A system of device-independent coordinates (called <i>User Space</i>) is
used to pass all coordinate information to the methods of a <b>Graphics2D</b>
object.&nbsp; An <b>AffineTransform</b> object (see definition below) is
contained in the <b>Graphics2D</b> object as part of its state.&nbsp; This <b>AffineTransform</b>
object defines how to convert coordinates from user space to device-dependent
coordinates in <i>Device Space.</i>&nbsp; </p>

<h3><span style='color:red'>What is an Affine transform?</span></h3>

<p>According to Sun:</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=339 style='width:203.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>The <b>AffineTransform</b> class represents a 2D Affine transform that
  performs a linear mapping from 2D coordinates to other 2D coordinates that
  preserves the &quot;straightness&quot; and &quot;parallelness&quot; of lines.
  Affine transformations can be constructed using sequences of translations,
  scales, flips, rotations, and shears.</p>
  </td>
 </tr>
</table>

<p>&nbsp;The transformation of coordinate information from <i>User Space</i> to
<i>Device Space</i> may consist either of </p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Transformation
     to a space representing individual pixels on a device of known resolution,
     or </li>
 <li class=MsoNormal>Transformation
     into a graphics metafile for playback on a device of unknown physical
     resolution at a later time.&nbsp; </li>
</ul>

<p>&nbsp;In the latter case, the <b>Graphics2D </b>transform is set up to transform
user coordinates to a virtual device space that approximates the expected
resolution of the target device.&nbsp; If the estimate proves to be incorrect,
it might be necessary to apply further transformations at playback time.</p>

<p>All <b>Graphics2D</b> methods take user space coordinates.</p>

<h3><span style='color:red'>GraphicsConfiguration object</span></h3>

<p>Every <b>Graphics2D</b> object is associated with a target that defines
where rendering takes place (such as the screen or a printer), and the same
rendering target is used throughout the life of a <b>Graphics2D</b> object.&nbsp;
A <b>GraphicsConfiguration</b> object defines the characteristics of the
rendering target, such as pixel format and resolution.&nbsp; </p>

<p>&nbsp;According to Sun:</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=339 style='width:203.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>The <b>GraphicsConfiguration</b> class describes the characteristics of a graphics
  destination such as a printer or monitor.&nbsp; There can be many <b>GraphicsConfiguration</b>
  objects associated with a single graphics device. For example, on X11
  windowing systems, each visual is a different <b>GraphicsConfiguration</b>.
  On PCs and Macintoshes, the different screen resolution/color resolution
  combinations would be different <b>GraphicsConfiguration</b> objects.</p>
  </td>
 </tr>
</table>

<p>According to the Sun documentation, when the <b>Graphics2D </b>object is
created, a default transform for the target of the <b>Graphics2D</b> (a
Component or Image) is specified by the <b>GraphicsConfiguration</b>.&nbsp;
This default transform is used to map the user space coordinate system to
screen or printer device coordinates.&nbsp; The origin maps to the upper left
hand corner of the target region of the device.&nbsp; Increasing X coordinates
extend to the right and increasing Y coordinates extend downward. </p>

<h3><span style='color:red'>What, me worry?</span></h3>

<p>According to <u>Java 2D Graphics</u>, by Jonathan Knudsen, </p>

<p><i>&#8220;In general, you don&#8217;t ever have to worry about the details of a
particular device.&nbsp; Your applications live in User Space.&nbsp; As long as
you remember that User Space, by default, has 72 coordinates per inch, Java 2D
will ensure that everything is the right size on your output devices.&#8221;</i></p>

<p>In other words, it seems that Sun and Knudsen are saying that if I create a
square whose dimensions are 72 units by 72 units, that square will be rendered
on my output device as a square with dimensions of one inch on each side.&nbsp;
The idea is to stop thinking about dimensions in terms of pixels and to start
thinking of dimensions in <i>User Space</i> with 72 units per inch.</p>

<h3><span style='color:red'>Something isn&#8217;t working!</span></h3>

<p>While the above may be true of output devices such as printers, I don&#8217;t find
it to be true for screen output.&nbsp; For example, the computer that I am working
on right now reports a screen resolution of 120 pixels per inch.&nbsp; If I
draw a 72x72 square on the screen using the <b>Rectangle2D</b> class, the
square is rendered at a size of about 0.6 inch on each side.&nbsp; In other
words, the square is rendered on the screen as a square that is 72 pixels on
each side, and not one inch on each side.</p>

<h3><span style='color:red'>Is there a workaround?</span></h3>

<p>Obviously I can use the <b>getScreenResolution()</b> method of the <b>Toolkit</b>
class (that returns the screen resolution in pixels per inch) to scale my
coordinate values, but the requirement to do that doesn&#8217;t seem to be consistent
with the above discussion.&nbsp; (A sample program later in this tutorial
lesson shows how to do that.)</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=339 style='width:203.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>At least I could do that if the <b>getScreenResolution()</b> method would
  return the correct value for actual screen resolution.&nbsp; As it turns out,
  this method always returns 120 on my machine no matter what the actual
  resolution is.&nbsp; This value is fairly close for a screen size of 1280 by
  1024, but isn&#8217;t even close for other screen settings.</p>
  <p>I am going to assume that this is a bug, or at least an incompatibility
  between JDK 1.2.2, WinNT Workstation 4.0, and the driver software for my
  screen, and proceed through these lessons as if the method <b>getScreenResolution()</b>
  returns the correct value.&nbsp; Hopefully, someday it will.</p>
  <p>By the way, the method <b>getScreenSize()</b> of the Toolkit class does
  return the correct values for total horizontal and vertical size in pixels.</p>
  </td>
 </tr>
</table>

<p>Also, I can define and set a modified <b>AffineTransform</b> object that compensates
for the difference in the actual screen resolution and the assumed default
screen resolution of 72 pixels per inch.&nbsp; Then I can forget about pixels
and think in terms of <i>User Space</i> coordinates with 72 units per
inch.&nbsp; This also doesn&#8217;t seem to be consistent with the explanation given
earlier because it still requires me to deal explicitly with actual screen
resolution.&nbsp; (Another sample program later in this lesson shows how to do
this as well.)</p>

<h2><a name="_David_Flanagan_to"></a>David Flanagan to the Rescue!</h2>

<p>Just when I was beginning to feel distraught because my experience wasn&#8217;t
matching what Sun and Knudsen seemed to be saying, one of my favorite authors,
David Flanagan came to the rescue.&nbsp; In <u>Java Foundation Classes in a
Nutshell</u>, Flanagan tells us, </p>

<p><i>&#8220;When drawing to a screen or an off-screen image, X and Y coordinates are
measured in pixels.&nbsp; When drawing to a printer or other high-resolution
device, however, X and Y coordinates are measured in points instead of pixels
(and there are 72 points in one inch).&#8221;</i></p>

<p>Flanagan goes on to tell us </p>

<p><i>&#8220;By default, when drawing to a screen or image, <u>user space is the same
as device space</u>.&nbsp; However, the <b>Graphics2D</b> class defines methods
that allow you to trivially modify the default coordinate system...&nbsp; By
default, when drawing to the screen, one unit in user space corresponds to one
pixel in device space.&nbsp; The <b>scale()</b> method changes this.&nbsp; If
you scale the coordinate system by a factor of 10, one unit of user space
corresponds to 10 pixels in device space...&#8221;</i></p>

<h3><span style='color:red'>A new AffineTransform object</span></h3>

<p>Although the sample programs in this lesson don&#8217;t make use of the <b>scale()</b>
method as described by Flanagan, one of the programs does take a similar
approach by creating a new <b>AffineTransform</b> object to provide the
necessary scaling from user space to device space on the screen.</p>

<p>On a related subject, in the same section, Flanagan discusses how <b>Graphics2D</b>
provides improved graphics capability for high-resolution devices, such as
printers, by allowing us to specify coordinate values as either <b>float</b> or
<b>double</b>, rather than being required to specify them as integers, as has
been the case prior to the release of <b>Graphics2D</b>. </p>

<p>Flanagan has published another excellent book in <u>Java Foundation Classes
in a Nutshell</u>, and I highly recommend it.</p>

<h2><a name="_The_Rendering_Process"></a>The Rendering Process</h2>

<p>According to the Sun documentation, the rendering process consists of the
following four steps that are controlled by the <b>Graphics2D</b> rendering
attributes:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Determine
     what to render. </li>
 <li class=MsoNormal>Constrain
     the rendering operation to the current <i>Clip</i> (see below). </li>
 <li class=MsoNormal>Determine
     what colors to render. </li>
 <li class=MsoNormal>Apply
     the colors to the destination drawing surface using the current <i>Composite</i>
     attribute in the <b>Graphics2D</b> context.</li>
</ul>

<p>The <i>Clip</i> refers to a defined region outside of which nothing is
drawn.&nbsp; Additional information from Sun about the Clip follows:</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=339 style='width:203.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>The Clip is specified by a <b>Shape</b> in user space and is controlled by
  the program using the various clip manipulation methods of <b>Graphics</b>
  and <b>Graphics2D</b>. This user clip is transformed into device space by the
  current Transform and combined with the device clip, which is defined by the
  visibility of windows and device extents. The combination of the user clip
  and device clip defines the composite clip, which determines the final
  clipping region. The user clip is not modified by the rendering system to
  reflect the resulting composite clip. </p>
  </td>
 </tr>
</table>

<p>The <i>Composite</i> attribute defines how the colors of the new item are
combined with the existing colors in the location where the item is to be
rendered.&nbsp; There are a variety of choices here that I will discuss in a
subsequent lesson.&nbsp; For example, this is where you can control the <i>transparency</i>
to cause the new item to completely cover an existing item, or to allow the
pixels of an existing item to partially show through the new item being
rendered at that location.</p>

<h2><a name="_What_is_a"></a>What is a Shape?</h2>

<p>I will have more to say about the <b>Shape</b> interface in a subsequent
lesson.&nbsp; However, for the time being, the following information should
suffice.&nbsp; According to Sun:</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=354 style='width:212.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>The <b>Shape</b> interface provides definitions for objects that represent
  some form of geometric shape. The <b>Shape</b> is described by a <b>PathIterator</b>
  object, which can express the outline of the <b>Shape</b> as well as a rule for
  determining how the outline divides the 2D plane into interior and exterior
  points. Each <b>Shape</b> object provides callbacks to get the bounding box
  of the geometry, determine whether points or rectangles lie partly or
  entirely within the interior of the <b>Shape</b>, and retrieve a <b>PathIterator</b>
  object that describes the trajectory path of the <b>Shape</b> outline.</p>
  </td>
 </tr>
</table>

<p>The <b>Shape</b> interface is implemented by the following classes (and
possibly others as well).&nbsp; These are classes from which geometric objects
can be instantiated:&nbsp; <b>Polygon</b>, <b>RectangularShape</b>, <b>Rectangle</b>,
<b>Line2D</b>, <b>CubicCurve2D</b>, <b>Area</b>, <b>GeneralPath</b>, and <b>QuadCurve2D</b>.&nbsp;
</p>

<p>Other geometric classes, such as <b>Rectangle2D</b> extend these geometric
classes, thus leading to other classes that implement the <b>Shape</b>
interface indirectly.&nbsp; The bottom line is that the <b>Shape</b> interface
completely permeates the Java 2D Graphics API.</p>

<h2><a name="_Types_of_Rendering"></a>Types of Rendering Operations</h2>

<p>According to Sun, there are three types of rendering operations:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Shape
     operations</li>
 <li class=MsoNormal>Text
     operations</li>
 <li class=MsoNormal>Image
     operations</li>
</ul>

<p>Each of these types will be discussed briefly in the following
sections.&nbsp; (More detailed discussions will be provided in subsequent
lessons.)&nbsp; However, before getting into the operations, it will be
necessary to provide some information about the <b>Stroke</b> interface.</p>

<h2><a name="_The_Stroke_Interface"></a>The Stroke Interface</h2>

<p>This is what Sun has to say about the <b>Stroke</b> interface.</p>

<table border=1 cellspacing=3 cellpadding=0 bgcolor="#ffff80" style='background:#FFFF80;'>
 <tr>
  <td width=354 style='width:212.1pt;background:aqua;padding:.75pt .75pt .75pt .75pt'>
  <p>The <b>Stroke</b> interface allows a <b>Graphics2D</b> object to obtain a <b>Shape</b>
  that is the decorated outline, or stylistic representation of the outline, of
  the specified <b>Shape</b>. Stroking a <b>Shape</b> is like tracing its
  outline with a marking pen of the appropriate size and shape. The area where
  the pen would place ink is the area enclosed by the outline <b>Shape</b>. </p>
  <p>The methods of the <b>Graphics2D</b> interface that use the outline <b>Shape</b>
  returned by a <b>Stroke</b> object include draw and any other methods that
  are implemented in terms of that method, such as drawLine, drawRect,
  drawRoundRect, drawOval, drawArc, drawPolyline, and drawPolygon. </p>
  </td>
 </tr>
</table>

<p>You need to read this very carefully to make sure that you understand
it.&nbsp; What this says to me is that the <b>Stroke</b> interface is used to
produce a <b>Shape</b> that forms the outline of another <b>Shape</b>.&nbsp; </p>

<h3><span style='color:red'>A simple example</span></h3>

<p>For example, consider tracing the complete outline of a star, on a piece of
tracing paper, using a wide marking pen.&nbsp; The drawing that you produce on
the tracing paper can itself be considered to be a shape, consisting of a pair
of (approximately) parallel lines, </p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>whose
     color is the same as the color of the ink in the pen, </li>
 <li class=MsoNormal>which
     connect at their ends to form two closed, non-intersecting contours, and </li>
 <li class=MsoNormal>which
     are filled in between with the color of the ink in the marking pen.</li>
</ul>

<p>At least, I think that is what this means.</p>

<h2><a name="_Shape_Operations"></a>Shape Operations</h2>

<p>Rendering operations of the <b>Shape</b> variety consist briefly of the
following steps:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If the
     rendering operation is a <b>draw(Shape)</b> operation, create a new <b>Shape</b>
     object that represents the outline of the <b>Shape</b> being rendered.</li>
 <li class=MsoNormal>Transform
     the new <b>Shape </b>from user space to device space using the current <b>Transform</b>
     in the <b>Graphics2D</b>&nbsp; context. </li>
 <li class=MsoNormal>Extract
     the outline of the <b>Shape</b> using the <b>getPathIterator()</b>&nbsp;
     method of the <b>Shape</b> interface.&nbsp; This returns a <b>PathIterator</b>
     object that iterates along the boundary of the <b>Shape</b>. </li>
 <li class=MsoNormal>In those
     cases where the <b>Graphics2D</b> object can&#8217;t handle the curved segments
     that the <b>PathIterator</b> object returns, an alternative <b>getPathIterator()</b>
     method of <b>Shape</b>, which redefines the shape as a series of straight
     line segments, can be used.</li>
 <li class=MsoNormal>Query
     the current <b>Paint</b> in the <b>Graphics2D</b> context for a <b>PaintContext</b>,
     which specifies the colors to render in device space.</li>
</ul>

<p>I will be discussing <b>PathIterator, Paint</b>, and <b>PaintContext</b> in
a subsequent lesson.</p>

<h2><a name="_Text_Operations"></a>Text Operations</h2>

<p>Rendering operations of the <b>Text </b>variety consist briefly of the
following steps:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Determine
     the set of <i>glyphs</i> required to render the indicated <b>String</b>.&nbsp;
     There are several possibilities here that I will discuss in subsequent
     lessons.</li>
 <li class=MsoNormal>Query
     the current <b>Font</b> to obtain outlines for the indicated glyphs. These
     outlines are treated as shapes in user space relative to the position of
     each glyph that was determined in step 1.</li>
 <li class=MsoNormal>Fill
     the character outlines as indicated above under <b>Shape</b> operations. </li>
 <li class=MsoNormal>Query
     the current <b>Paint</b> for a <b>PaintContext</b>, which specifies the
     colors to render in device space.</li>
</ul>

<p>That brings us to the third type of rendering operation, which is an <b>Image</b>
operation.</p>

<h2><a name="_Image_Operations"></a>Image Operations</h2>

<p>Rendering operations of the <b>Image </b>variety consist briefly of the
following steps:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Get
     the region of interest, which is defined by the bounding box of the source
     <b>Image</b>. This bounding box is specified in <i>Image Space</i>, which
     is the Image object's local coordinate system. </li>
 <li class=MsoNormal>Use
     the <b>AffineTransform</b> that is passed to <b>drawImage(Image,
     AffineTransform, ImageObserver)</b> to transform the bounding box from
     image space to user space. If no <b>AffineTransform</b> is supplied, treat
     the bounding box as if it is already in user space.</li>
 <li class=MsoNormal>Transform
     the bounding box of the source Image from user space into device space
     using the current <b>Transform</b>.&nbsp; </li>
 <li class=MsoNormal>Use
     the <b>Image</b> object, sampled according to the source to destination
     coordinate mapping specified by the current <b>Transform</b> and the
     optional image transform to determine what colors to render</li>
</ul>

<p>I will have a lot more to say about images in subsequent lessons.</p>

<h2><a name="_Rendering_Attributes"></a>Rendering Attributes</h2>

<p>As the author of the program, you have control over a number of rendering
attributes.&nbsp; The default rendering attributes are given below:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Paint</b>:&nbsp;
     The color of the Component. </li>
 <li class=MsoNormal><b>Font</b>:&nbsp;
     The Font of the Component. </li>
 <li class=MsoNormal><b>Stroke</b>:&nbsp;
     A square pen with a line width of 1, no dashing, miter segment joins and
     square end caps (will provide more information in subsequent lessons). </li>
 <li class=MsoNormal><b>Transform</b>:&nbsp;
     The <b>getDefaultTransform</b> for the <b>GraphicsConfiguration</b> of the
     <b>Component</b>. </li>
 <li class=MsoNormal><b>Composite</b>:&nbsp;
     The AlphaComposite.SRC_OVER rule. </li>
 <li class=MsoNormal><b>Clip</b>:&nbsp;
     No rendering Clip, the output is clipped to the Component.</li>
</ul>

<p>I am providing this information here simply as a very brief introduction to
the topic of rendering attributes.&nbsp; I will have much more to say about
this topic in subsequent lessons.</p>

<h2><a name="_Additional_Details_and"></a>Additional Details and Compatibility
Issues</h2>

<p>There is a great deal more detailed, and sometimes complex information
involved in a complete understanding of the <b>Graphics2D</b> class,
particularly with respect to compatibility issues between <b>Graphics2D</b> and
legacy code written under the earlier JDK 1.1.&nbsp; While I will be covering
many aspects of <b>Graphics2D</b> in subsequent lessons, I won&#8217;t spend much
time dealing with compatibility issues and legacy code.&nbsp; You are
encouraged to visit the Sun documentation for information on compatibility
issues.</p>

<h2><a name="_Sample_Programs"></a>Sample Programs</h2>

<p>I don&#8217;t have the final answers to the apparent ambiguity surrounding the
automatic transformation from user space to device space with respect to screen
coordinates.&nbsp; However, I can show you a couple of ways to write code that
will deal with the required transformation.&nbsp; Two programs follow that
contain this information.</p>

<h3 align=center style='text-align:center'><a name="_Program_Graphics2D01.java"></a><span
style='color:red'>Program Graphics2D01.java</span></h3>

<p>This program illustrates the use of the <b>Graphics2D</b> class and the <b>Rectangle2D</b>
class.&nbsp; The screen width, screen height, and screen resolution are
obtained by the program and displayed on the screen following the command
line.&nbsp; For the particular computer that I am using at the time of this
writing, the screen output is:</p>

<p><b><span style='font-size:10.0pt;font-family:Courier'>120 pixels per inch</span></b><br>
<b><span style='font-size:10.0pt;font-family:Courier'>1280 pixels wide</span></b><br>
<b><span style='font-size:10.0pt;font-family:Courier'>1024 pixels high</span></b>&nbsp;</p>

<p>This program should run successfully on your computer also, except that you
may get different values for the resolution, width, and height of the screen.</p>

<p>The program produces a <b>Frame</b> object on the screen that is two inches
on each side.&nbsp; The screen resolution (in pixels per inch) is used to
establish the size of the <b>Frame</b> object in inches.&nbsp; In addition, the
screen resolution is used to draw a square that is one inch on each side, centered
in the <b>Frame</b>.</p>

<p>This program is structured to make it as easy to follow as possible (For the
most part, I have tried to avoid the use of cryptic constructs such as Inner
Classes).&nbsp; I will break this program up and discuss it in fragments.&nbsp;
A complete listing of the program is provided at the end of the lesson.</p>

<h3><span style='color:red'>The controlling class</span></h3>

<p><a href="Java304-fig01.htm">Figure 1</a>&nbsp;shows the import directives
and the entire controlling class.&nbsp; As you can see, the <b>main()</b>
method in the controlling class does nothing but instantiate an object of
another class named <b>GUI</b>.&nbsp; All of the action occurs in the <b>GUI</b>
class. </p>

<h3><span style='color:red'>The GUI class</span></h3>

<p><a href="Java304-fig02.htm">Figure 2</a> shows the beginning of the <b>GUI</b>
class.&nbsp; Note that this class extends the <b>Frame</b> class.&nbsp; This is
necessary so that I can override the <b>paint()</b> method to make it possible
to use a <b>Graphics2D</b> object to render the desired graphics on the screen.</p>

<p>This class declares three instance variables that are later used to store
information about the resolution, width, and height of the computer screen.</p>

<h3><span style='color:red'>The constructor for the GUI class</span></h3>

<p><a href="Java304-fig03.htm">Figure 3</a> shows the beginning of the
constructor including the code used to get and display the resolution, width,
and height of the computer on which the program is executing.&nbsp; Hopefully
this is &#8220;old stuff&#8221; to you by now, because it really has nothing to do with the
Java 2D Graphics API.</p>

<h3><span style='color:red'>Using screen resolution data</span></h3>

<p><a href="Java304-fig04.htm">Figure 4</a> continues the constructor and shows
the use of the screen resolution information to cause the size of the <b>Frame</b>
object to be two inches on each side.&nbsp; It also causes the <b>Frame</b> to
become visible, and places a title in the title bar on the <b>Frame</b>.&nbsp;</p>

<p>I know that I promised to avoid cryptic code, but I couldn&#8217;t resist the use
of an anonymous Inner Class to create and register a Listener object to
terminate the program when the user clicks the <i>close</i> button on the top
of the <b>Frame</b>.&nbsp; This is a very standard use of anonymous Inner
Classes, and hopefully you know all about this sort of thing by this point in
your Java studies.</p>

<h3><span style='color:red'>Finally, the Graphics2D class</span></h3>

<p>Finally (thanks for your patience), I am going to talk about <b>Graphics2D.</b>&nbsp;
The following code fragment shows the beginning of a <b>paint()</b> method that
is overridden to draw a square, one inch on each side, which is centered in the
<b>Frame</b> object.&nbsp; Note that, as was the case in JDK 1.1, the
overridden <b>paint()</b> method always receives a reference to an object of
the class <b>Graphics</b>.&nbsp; Thus, for backward compatibility, all of the
methods of the <b>Graphics </b>&nbsp;class are still available.</p>

<h3><span style='color:red'>Downcast is required</span></h3>

<p>However, the <b>Graphics2D </b>class extends the <b>Graphics</b> class, and
in order to gain access to the new capabilities of the <b>Graphics2D</b> class,
it is necessary to downcast the incoming reference to <b>Graphics2D </b>as
shown in <a href="Java304-fig05.htm">Figure 5</a>.</p>

<h3><span style='color:red'>Invoking the draw(Shape) method</span></h3>

<p>Having downcast the reference to <b>Graphics2D</b>, I can now invoke the <b>draw(Shape)</b>
method of the <b>Graphics2D class </b>on that reference.&nbsp; Invoking this method
strokes the outline of the <b>Shape</b> using the settings of the current <b>Graphics2D</b>
context. The rendering attributes that are applied include the Clip, Transform,
Paint, Composite and Stroke attributes. &nbsp;I will have more to say about
these attributes in subsequent lessons.&nbsp;</p>

<p><a href="Java304-fig06.htm">Figure 6</a> instantiates and draws an object of
the <b>Rectangle2D</b> class that is centered in the <b>Frame</b> object.&nbsp;
The size of the <b>Rectangle2D</b> object is one inch on each side.&nbsp; The
rectangle is centered in the <b>Frame</b> by placing its upper left-hand corner
at a position that is one-half inch to the right and one-half inch below the
upper left-hand corner of the <b>Frame</b>.&nbsp; </p>

<h3><span style='color:red'>Actually this is a Rectangle2D.Double object</span></h3>

<p>Note that the actual rectangle object is instantiated from the <b>Rectangle2D.Double</b>
class.&nbsp; If you are not familiar with this terminology, see the first
lesson in this series on the Java 2D Graphics API for an explanation of just
what this means.</p>

<p>Note also that the screen resolution in pixels per inch is used in the
expressions that convert the dimensions in inches to dimensions in pixels for
drawing on the screen.&nbsp; Thus, although the <b>draw()</b> method is new to
the 2D API, the sizing and positioning of the rectangle does not use the new
features of the 2D API.&nbsp; This same approach can be used with JDK 1.1 to
size and locate an object in screen space.&nbsp; </p>

<p>The next sample program will make more significant use of the new features
of the 2D API.</p>

<h3 align=center style='text-align:center'><a name="_Program_Graphics2D02.java"></a><span
style='color:red'>Program Graphics2D02.java</span></h3>

<p>As with the previous program, this program illustrates the use of the <b>Graphics2D</b>
class and the <b>Rectangle2D</b> class.&nbsp; However, unlike the previous
program, this program also illustrates the use of the <b>AffineTransform</b>
class.&nbsp; </p>

<h3><span style='color:red'>Compensating for actual screen resolution</span></h3>

<p>A newly instantiated object of the <b>AffineTransform</b> class is used to
compensate for the difference in actual screen resolution on my computer (120
pixels per inch) and the default screen resolution (72 pixels per inch) used
the 2D API.</p>

<p>As before, this program uses the actual screen resolution to place a <b>Frame</b>
object on the screen that is two inches on each side.&nbsp; It then uses the <b>AffineTransform</b>
object mentioned above to draw a square that is one inch on each side, centered
in the <b>Frame</b>.</p>

<p>The drawing of the square inside the <b>Frame</b> is based on inches scaled
by the default resolution used by the 2D API of 72 pixels per inch (or 72
printer points per inch).&nbsp; The resulting square is scaled by the <b>AffineTransform</b>
that compensates for the difference in actual screen resolution and the default
resolution to produce a square that is one inch on each side.</p>

<p>As usual, I will discuss the program in fragments.&nbsp; A complete listing
of the program is provided at the end of the lesson.</p>

<h3><span style='color:red'>The entire controlling class plus some</span></h3>

<p><a href="Java304-fig07.htm">Figure 7</a> contains the entire controlling
class, along with the constructor for the <b>GUI</b> class.&nbsp; This code is
essentially the same as in the previous program, so I won&#8217;t discuss it further.</p>

<h3><span style='color:red'>Overridden paint() method</span></h3>

<p><a href="Java304-fig08.htm">Figure 8</a> shows the overridden <b>paint()</b>
method in the <b>GUI</b> class.&nbsp; As before, this fragment downcasts the
incoming reference to type <b>Graphics2D</b> to provide access to the new
features of the <b>Graphics2D</b> class.</p>

<p>The next fragment is where the differences begin to show up between this
program and the previous program.&nbsp; </p>

<h3><span style='color:red'>Using the setTransform() method</span></h3>

<p>The <b>setTransform()</b> method of the <b>Graphics2D</b> class can be used
to set the transform that is used to transform from user space to device space.&nbsp;
This method requires a reference to an object of the <b>AffineTransform</b>
class.</p>

<p>If you know about matrix algebra, you can use any of several overloaded
constructors to instantiate an <b>AffineTransform</b> objects to accomplish
different kinds of linear transforms.&nbsp; </p>

<p>Even if you don&#8217;t know about matrix algebra, certain specialized <b>AffineTransform</b>
objects are relatively easy to produce.</p>

<h3><span style='color:red'>Factory methods of the AffineTransform class</span></h3>

<p>The <b>AffineTransform</b> class provides several <i>static</i> factory
methods that can be used to produce transform objects.&nbsp; Some of them are
listed below.&nbsp; These methods each return an instance of the <b>AffineTransform</b>
class designed to perform a specific type of transform (rotate, scale, shear,
and translate).&nbsp; I will have a lot more to say about these transforms in
subsequent lessons.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>getRotateInstance(double
     theta) </li>
 <li class=MsoNormal>getScaleInstance(double
     sx, double sy) </li>
 <li class=MsoNormal>getShearInstance(double
     shx, double shy) </li>
 <li class=MsoNormal>getTranslateInstance(double
     tx, double ty) </li>
</ul>

<p>In this program, I am interested in scaling the coordinates of the rectangle
when transforming it from user space to device (screen) space to compensate for
the difference in actual screen resolution and the assumed screen resolution of
72 pixels per inch that is used in the 2D API.&nbsp; </p>

<h3><span style='color:red'>A scaling instance of the AffineTransform class</span></h3>

<p><a href="Java304-fig09.htm">Figure 9</a> gets a scaling instance of the <b>AffineTransform</b>
class, and passes it to the <b>setTransform()</b> method of the <b>Graphics2D</b>
object.&nbsp; </p>

<p>The scale factors that are set into the transform object are the ratio of
the actual screen resolution (<b>res</b>) to the assumed screen resolution of
the 2D API (72 pixels per inch).&nbsp; This transform will then properly
convert user space coordinates in inches (that assume 72 units per inch) to
actual inches on the computer screen.&nbsp; This should work on any computer
screen regardless of the actual resolution of the screen.</p>

<h3><span style='color:red'>Default resolution is 72 units per inch</span></h3>

<p><a href="Java304-fig10.htm">Figure 10</a> begins by declaring and
initializing a local variable to the value of 72 units per inch.&nbsp; (A more
robust approach would have been to make this a public static final instance
variable of the class.&nbsp; Then it would have been impossible to corrupt it.)</p>

<p>In any event, this variable serves as a scale factor for producing user
space coordinate values with 72 units per inch.&nbsp; </p>

<h3><span style='color:red'>Drawing a one-inch square</span></h3>

<p>Then the fragment draws a new <b>Rectangle2D.Double</b> object, one inch on
each side and centered in the <b>Frame</b> object.&nbsp; As before, the
centering is accomplished by locating the upper left corner of the rectangle at
<i>0.5 inch by 0.5 inch</i> relative to the upper left-hand corner of the <b>Frame</b>.&nbsp;
This is accomplished by the first two parameters to the constructor.</p>

<p>The size of the rectangle, <i>1.0 inch by 1.0 inch</i>, is accomplished by
the second two parameters to the constructor for the rectangle.&nbsp; In all
four cases, the multiplicative factor (<b>ds</b>) is used to account for the
fact that user space is assumed to be in inches where each inch is assumed to
be divided into 72 parts.</p>

<p>So there you have it.&nbsp; An introduction to the use of the <b>Graphics2D</b>
class along with a number of associated other aspects of the Java 2D Graphics
API.</p>

<h3 align=center style='text-align:center'><a name="_Complete_Program_Listing"></a><a
name="_Complete_Program_Listings"></a><span style='color:red'>Complete Program
Listings</span></h3>

<p>Complete listings of both programs are provided in <a
href="Java304-fig11.htm">Figure 11</a> and <a href="Java304-fig12.htm">Figure
12</a>.</p>

<p><b><i>Richard Baldwin</i></b><i> is a college professor and private
consultant whose primary focus is a combination of Java and XML. In addition to
the many platform-independent benefits of Java applications, he believes that a
combination of Java and XML will become the primary driving force in the
delivery of structured information on the Web.</i></p>

<p><i>Richard has participated in numerous consulting projects involving Java,
XML, or a combination of the two.&nbsp; He frequently provides onsite Java
and/or XML training at the high-tech companies located in and around Austin,
Texas.&nbsp; He is the author of Baldwin's Java Programming <a
href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java Pro
magazine. </i></p>

<p><i>Richard holds an MSEE degree from Southern Methodist University and has
many years of experience in the application of computer technology to
real-world problems.</i></p>

<p><i>baldwin@austin.cc.tx.us</i></p>

<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without&nbsp; express written permission from
Richard Baldwin is prohibited.&nbsp;

<p>-end-<!--end--></p>

</div>

</body>

</html>
