<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Data Structures in Java: Part 5, The Core Collection Interfaces</h2>
<i>The Java Collections Framework defines six core interfaces, in two distinct
trees.&nbsp; Learn the inheritance structure, and the purpose of those
interfaces.&nbsp; Learn how the interfaces declare polymorphic methods
that apply to implementations of the interfaces, and learn about the optional
methods of the Collection interface.</i>
<br>&nbsp;
<p><b>Published:</b>&nbsp; July 2, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1358
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This is the fifth lesson in a miniseries on Java data structures and the
Java Collections Framework.&nbsp; The first lesson in the miniseries was
entitled
<a href="Java1350.htm">Data Structures in Java: Part 1, Getting
Started</a>.&nbsp; The previous lesson was entitled <a href="Java1356.htm">Data
Structures in Java: Part 4, Purpose of Implementations and Algorithms</a>.
<p>The purpose of this miniseries is to help you learn the essential features
of Object-Oriented data structures in Java using the <i>Collections Framework</i>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings while you are reading about them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at </font><a href="http://softwaredev.earthweb.com/java">Gamelan.com</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
In an earlier lesson, you learned that at least three things are included
in a collections framework:
<ul>
<li>
interfaces</li>

<li>
implementations</li>

<li>
algorithms</li>
</ul>
The previous two lessons provided a general discussion of the purpose of
the interfaces, implementations, and algorithms in the Collections Framework.&nbsp;
This lesson takes that discussion further and illustrates the use of the
<i>core
collection interfaces.</i>
<p>The Java Collections Framework defines six core interfaces, in two distinct
trees.&nbsp; You will learn the names and the inheritance structure of
those interfaces.&nbsp; You will also learn about their purpose.&nbsp;
You will see how the interfaces declare polymorphic methods that apply
to implementations of the interfaces, and you will learn about the optional
methods of the <b>Collection</b> interface.
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Programs</font></h2></center>
<b><font color="#FF0000">Illustration of core collection interfaces</font></b>
<p>Let’s begin this lesson with a little quiz.&nbsp; Take a look at the
program shown in Listing 1 and see if you can answer the following question.
<p>What output does the program in Listing 1 produce?
<ul>
<li>
A.&nbsp; Compiler Error</li>

<li>
B.&nbsp; Runtime Error</li>

<li>
C.&nbsp; 44321 44321</li>

<li>
D.&nbsp; 12344 12344</li>

<li>
E.&nbsp; 1234 44321</li>

<li>
F.&nbsp; 1234 4321</li>

<li>
D.&nbsp; None of the above.</li>
</ul>

<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">import java.util.TreeSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class Ap401{
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Worker().doIt();
&nbsp; }//end main()
}//end class Ap401

class Worker{
&nbsp; public void doIt(){
&nbsp;&nbsp;&nbsp; Collection ref = new TreeSet();
&nbsp;&nbsp;&nbsp; Populator.fillIt(ref);
&nbsp;&nbsp;&nbsp; Iterator iter = ref.iterator();
&nbsp;&nbsp;&nbsp; while(iter.hasNext()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.next());
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; System.out.print(" ");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ref = new ArrayList();
&nbsp;&nbsp;&nbsp; Populator.fillIt(ref);
&nbsp;&nbsp;&nbsp; iter = ref.iterator();
&nbsp;&nbsp;&nbsp; while(iter.hasNext()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.next());
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; System.out.println();
&nbsp; }//end doIt()
}// end class Worker

class Populator{
&nbsp; public static void fillIt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection ref){
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(3));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(2));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(1));
&nbsp; }//end fillIt()
}//end class populator

<b>Listing 1</b></font></pre>
</td>
</tr>
</table>

<p>If you selected the following answer, then you are correct.
<p>E.&nbsp; 1234 44321
<p>The program in Listing 1 illustrates the basic purpose of the <i>core
collection interfaces</i> in the Java Collections Framework.&nbsp; That
purpose is to allow collections to be manipulated without regard for how
the collections are implemented.
<p><b><font color="#FF0000">Multiple list implementations</font></b>
<p>For example, there is more than one way to implement a list.&nbsp; Two
common ways involve arrays and linked structures.&nbsp; If two lists are
implemented in different ways, but both satisfy the requirements of the
core collection interfaces, they can each be manipulated the same way regardless
of the details of their implementation.
<p><b><font color="#FF0000">TreeSet and ArrayList</font></b>
<p>A collection of type <b>TreeSet</b> and a collection of type <b>ArrayList</b>
are instantiated in the program in Listing 1.&nbsp; Each of the collections
is viewed as being of the interface type <b>Collection</b>.&nbsp; A method
named <b>add()</b> is used to populate each collection with the same values.
<p><b><font color="#FF0000">Behavior is different but appropriate</font></b>
<p>The behavior of the <b>add()</b> method is appropriate, and different
in each of the two cases, with the final contents of each collection being
determined by the respective behavior of the <b>add()</b> method for that
type of collection.
<p><b><font color="#FF0000">The fillIt() method</font></b>
<p>The code in the fragment shown in Listing 2 defines a class method named
<b>fillIt()</b>
of the class named <b>Populator</b>.&nbsp; This is a class of my own design
intended solely to illustrate the primary point of this program.
<p>The method named <b>fillIt()</b> receives an incoming reference to a
collection object as type <b>Collection</b>.&nbsp; The method invokes the
<b>add()</b>
method on the incoming reference five times in succession to add five elements
to the collection.&nbsp; These elements are added without regard for the
actual type or underlying implementation of the collection <i>(in fact,
as the method is written, it has no way of knowing the underlying implementation).</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">class <b>Populator</b>{
&nbsp; public static void <b>fillIt</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection ref){
&nbsp;&nbsp;&nbsp; ref.<b>add</b>(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(3));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(2));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(1));
&nbsp; }//end fillIt()
}//end class populator

<b>Listing 2</b></font></pre>
</td>
</tr>
</table>

<p>The <b>fillIt()</b> method will be used to populate two collections
of different types with the same data.
<p><b><font color="#FF0000">Create and populate a TreeSet object</font></b>
<p>Consider the code fragment shown in Listing 3.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Collection ref = new <b>TreeSet</b>();
&nbsp;&nbsp;&nbsp; Populator.<b>fillIt</b>(ref);
&nbsp;&nbsp;&nbsp; Iterator iter = ref.iterator();
&nbsp;&nbsp;&nbsp; while(iter.hasNext()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.next());
&nbsp;&nbsp;&nbsp; }//end while loop

<b>Listing 3</b></font></pre>
</td>
</tr>
</table>

<p>The code in Listing 3 instantiates an object of type <b>TreeSet</b>,
and passes that object's reference to the <b>fillIt()</b> method as type
<b>Collection</b>.&nbsp;
As described above, the <b>fillIt()</b> method adds five elements to the
collection, in random order with two of the elements being duplicates.
<p><b><font color="#FF0000">Display the collection's contents</font></b>
<p>Then the code in Listing 3 gets an <b>Iterator</b> object on the collection
and uses the iterator to display the contents of the collection.
<p><b><font color="#FF0000">TreeSet object is type SortedSet</font></b>
<p>The <b>TreeSet</b> class implements one of the core collection interfaces
named <b>SortedSet</b>.<b>&nbsp; SortedSet</b> is a sub interface of <b>Set</b><i>.</i>&nbsp;
One of the characteristics of a <b>Set</b> object is that it doesn't allow
duplicate elements.&nbsp; One of the characteristics of a <b>SortedSet</b>
object is that it maintains its elements in ascending order.&nbsp; Since
the <b>TreeSet</b> class implements both of these interfaces, it is both
a <b>Set</b> and a <b>SortedSet</b>, and exhibits the characteristics of
both interfaces.
<p>Because the underlying structure of the <b>TreeSet</b> class doesn't
allow duplicates, and the underlying structure maintains its elements in
ascending order, the code in Listing 3 produces the following text on the
screen:
<p>1234
<p><b><font color="#FF0000">Create and populate an ArrayList object</font></b>
<p>Now consider the code fragment shown in Listing 4.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; ref = new <b>ArrayList</b>();
&nbsp;&nbsp;&nbsp; Populator.fillIt(ref);
&nbsp;&nbsp;&nbsp; iter = ref.iterator();
&nbsp;&nbsp;&nbsp; while(iter.hasNext()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.next());
&nbsp;&nbsp;&nbsp; }//end while loop

<b>Listing 4</b></font></pre>
</td>
</tr>
</table>

<p>The code in Listing 4 instantiates a new collection of type <b>ArrayList</b>,
and passes that object's reference to the same <b>fillIt()</b> method,
again as type collection.
<p>The code in the <b>fillIt()</b> method adds five elements having the
same values as before to the collection.&nbsp; The added elements are references
to <b>Integer</b> objects encapsulating the same values as were earlier
added to the <b>TreeSet</b> collection.&nbsp; Although they are physically
different objects, the result is that essentially the same data is added
to both collections.
<p><b><font color="#FF0000">Display the collection's contents</font></b>
<p>Then, as before, the code in Listing 4 gets an iterator and uses it
to access and display the contents of the <b>ArrayList</b> collection.
<p>The <b>ArrayList</b> class implements the <b>List</b> interface, which
does not prohibit duplicate elements, and does not maintain its elements
in sorted order.&nbsp; Therefore, in this case, the following text was
displayed:
<p>44321
<p>All five element values are displayed, including the duplicate, in the
order in which they were added to the list.
<p><b><font color="#FF0000">The important point</font></b>
<p>The important point is that although the <b>fillIt()</b> method invokes
the same method name (<b>add()</b>) on each of the collection objects,
the behavior of that method is different in each case.&nbsp; In both cases,
the behavior is appropriate for the underlying data structure.&nbsp; Furthermore,
the underlying data structure isn't even known to the <b>fillIt()</b> method.
<p><b><font color="#FF0000">No duplicate elements in ascending order</font></b>
<p>In the first case, where the underlying data structure was a <b>TreeSet</b>
object <i>(type SortedSet),</i> the duplicate element was eliminated, and
the elements were stored so as to be accessible in ascending order.
<p><b><font color="#FF0000">Duplicates allowed with no sorting</font></b>
<p>In the second case, where the underlying data structure was an <b>ArrayList</b>
object <i>(type List),</i> all five elements, including the duplicate element
were stored in the collection.&nbsp; Furthermore, they were stored and
later retrieved in the same order in which they were added.
<p><b><font color="#FF0000">Structure of core the interfaces</font></b>
<p>Interestingly, the <i>core collection interfaces</i> in the Java Collections
Framework do not all extend from a common root interface.
<p>Rather, the inheritance structure of the core interfaces is shown below.&nbsp;
Indentation is used to indicate the superinterface-subinterface relationship
among the interfaces.
<ul>
<li>
Collection</li>

<ul>
<li>
Set</li>

<ul>
<li>
SortedSet</li>
</ul>

<li>
List</li>
</ul>

<li>
Map</li>

<ul>
<li>
SortedMap</li>
</ul>
</ul>
<b><font color="#FF0000">A Map is not a true Collection</font></b>
<p><font color="#000000">As you can see, that there is no common root interface.&nbsp;
Rather, there are two distinct trees, one rooted by <b>Collection</b> and
the other rooted by <b>Map</b>.&nbsp; According to The Java Tutorial from
Sun, <i>"a Map is not a true Collection."&nbsp;</i> I will have more to
say about this in a future lesson.</font>
<p><b><font color="#FF0000">Some operations are optional</font></b>
<p>Every class that implements an interface in the tree rooted in <b>Collection</b>
is not required to support all of the modification methods <i>(operations)</i>
declared in the <b>Collection</b> interface.
<p><font color="#000000">Rather, the modification methods <i>(operations)</i>
in the <b>Collection</b> interface are designated optional.&nbsp; <i>(See
the list of optional modification methods for the Collection interface
below.)</i></font>
<p><font color="#000000">According to the contract for the Collections
Framework, if a given implementation doesn't support a specific modification
method, it must throw an <b>UnsupportedOperationException</b>.&nbsp; The
author of the implementation is responsible for providing documentation
that identifies the optional operations that the implementation does and
does not support.&nbsp; <i>(I have read that this approach has been the
source of some controversy within the Java community, but I haven't pursued
that controversy in any detail.)</i></font>
<p><b><font color="#FF0000">Support for optional operations</font></b>
<p><font color="#000000">This should not be an issue unless you are either
defining your own implementation, or using an implementation defined by
someone other than the programmers at Sun.&nbsp; As of JDK 1.3, all of
the general-purpose implementations from Sun support all of the optional
operations.</font>
<p><b><font color="#FF0000">Optional Collection operations</font></b>
<p><font color="#000000">The following list shows the optional operations
in the <b>Collection</b> interface as of JDK 1.3.&nbsp; Each of these methods
has the ability to modify the contents of the collection.</font>
<ul>
<li>
<font color="#000000">add()</font></li>

<li>
<font color="#000000">addAll()</font></li>

<li>
<font color="#000000">clear()</font></li>

<li>
<font color="#000000">remove()</font></li>

<li>
<font color="#000000">removeAll()</font></li>

<li>
<font color="#000000">retainAll()</font></li>
</ul>
<b><font color="#FF0000">Optional Map operations</font></b>
<p><font color="#000000">As of JDK 1.3, the following list shows the optional
operations in the <b>Map</b> interface.&nbsp; Each of these methods has
the ability to modify the contents of the map.</font>
<ul>
<li>
<font color="#000000">clear()</font></li>

<li>
<font color="#000000">put()</font></li>

<li>
<font color="#000000">putAll()</font></li>

<li>
<font color="#000000">remove()</font></li>
</ul>
<b><font color="#FF0000">Many methods are not optional</font></b>
<p><font color="#000000">In both cases, the interface declares numerous
other methods that are not optional.&nbsp; Generally, the non-optional
methods don't have the ability to modify the collection.&nbsp; For example,
the
<b>get()</b> method of the <b>Map</b> interface is not optional.&nbsp;
Although the
<b>get()</b> method receives an incoming <i>key</i> and returns
the <i>value</i> to which the key maps, the method doesn't have the ability
to modify the contents of the collection.</font>
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
A collections framework contains the following:
<ul>
<li>
interfaces</li>

<li>
implementations</li>

<li>
algorithms</li>
</ul>
The Java Collections Framework defines six core interfaces, in two distinct
trees.&nbsp; One tree is rooted in <b>Collection</b> and the other is rooted
in <b>Map</b>.
<p>The basic purpose of the core interfaces is to make it possible for
collections to be manipulated without regard for how they are implemented,
so long as the implementation satisfies the contracts of the interfaces.
<p>When the same method name is invoked on references to collections of
different types, the behavior of the method is likely to be different for
each collection.&nbsp; However, in each case, that behavior will be appropriate
for the type of collection object on which the method is invoked.&nbsp;
This is polymorphic behavior.
<p>Six of the methods declared in the <b>Collection </b>interface are optional
insofar as being supported by implementing classes.&nbsp; The optional
methods all have the ability to modify the contents of the collection.&nbsp;
Those implementing classes that don't support an optional method must throw
an <b>UnsupportedOperationException</b> if that method is invoked on an
object of the class.
<p>Many methods declared in the <b>Collection</b> interface are not optional.&nbsp;
Generally, the non-optional methods don't have the ability to modify the
collection.
<p>All of the general-purpose implementation classes of the <b>Collection</b>
interface in JDK 1.3 support all of the optional methods.
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will discuss and illustrate some of the details of
the core interfaces and the general-purpose implementations in the Java
Collections Framework. For example, I will discuss the difference between
a set and a list.&nbsp; I will also discuss the difference between <i>ordered</i>
and <i>sorted</i>.&nbsp; I will discuss the fact that additional stipulations
are applied as you progress down the framework interface hierarchy.&nbsp;
In order to help you learn and retain the material, I will provide a couple
of short quizzes.
<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
