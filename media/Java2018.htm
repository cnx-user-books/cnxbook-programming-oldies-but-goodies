<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">
<h2>
Java Sound, Using Audio Line Events</h2>
<i>Baldwin shows you how to use audio line events.&nbsp; You can use this 
approach to register listeners and to receive notifications whenever an audio 
line is opened, started, stopped, or closed.</i><p><b>Published:</b>&nbsp; April 
15, 2003<br><b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
<p>Java Programming Notes # 2018<ul >
<li>
<a href="#Preface">Preface</a></li>
<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Code</a></li>

<li>
<a href="#Run the program">Run the Program</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<p>
This  series of lessons is designed to teach you how to use the 
Java Sound API.&nbsp; The first lesson in the series was entitled 
<a href="http://www.developer.com/java/other/article.php/1565671">Java Sound, An 
Introduction</a>.&nbsp; The 
previous lesson was entitled
<a href="http://www.developer.com/java/other/article.php/2173111">Java Sound, 
Playing Back Audio Files using Java</a>.</p>
<p><font color="#FF0000"><b>Two types of audio data</b></font></p>
<p>
Two  different 
types of audio data are supported by the Java Sound API:<ul>
  <li>Sampled audio data</li>
  <li>Musical Instrument Digital Interface (MIDI) data</li>
  </ul>
  <p>The two types of audio data are very different.&nbsp;  I 
  am concentrating on sampled audio data at this point in time.&nbsp; I will defer 
  my discussion of 
      MIDI    until later.<p>
<b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings and figures while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at <font color="#000000">
<a href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font>
  <h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>The previous lesson showed you how to write a program that you can use to 
play back audio files, including those that you create using a Java program, and 
those that you acquire from other sources.<p>Earlier lessons in the series 
showed you how to:<ul>
  <li>Capture microphone data into audio files types of your own choosing.</li>
  <li>Capture microphone data into a <b>ByteArrayOutputStream</b> object, and 
  how to use the Sound API to play back previously captured audio data.</li>
  <li>Identify the mixers available on your system, and how to specify a 
  particular mixer for use in the acquisition of audio data from a microphone.</li>
  <li>Understand the use of lines and mixers in the Java Sound API.</li>
  </ul>
  <p>In this lesson, I will teach you how to use events fired by audio lines to 
  synchronize audio activities with other activities.<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2></center>
<p>
<font color="#FF0000"><b>Synchronizing other activities with sound</b></font><p>
Suppose  you need to play some music, and to cause an animation to start and 
stop in synchronism with the beginning and the ending of the music.&nbsp; How 
would you synchronize those two activities?<p>
There are probably several ways to accomplish this task.&nbsp; One way would be 
to use the events fired by the audio line to synchronize the beginning and the 
ending of the animation.<p>
<font color="#FF0000"><b>What is an audio line event?</b></font><p>
Audio lines fire events when they are opened, started, stopped, or closed.&nbsp; 
You can instantiate listener objects and register them on the <b>Line</b> object 
to be notified each time the line fires an event.<p>
You can define event handler methods belonging to the listener objects to 
perform whatever action you need to perform each time the line fires an event.&nbsp; 
I will provide a sample program and explain how to do this in this lesson.<p>
<font color="#FF0000"><b>The user interface</b></font><p>
When the sample program in this lesson is executed, the GUI shown in Figure 1 appears on the screen.&nbsp; 
As you can see, this GUI contains the following components:<ul>
  <li>A Capture button</li>
  <li>A Stop button</li>
  <li>A Playback button</li>
  </ul>
    <p align="center">
      <img border="0" src="java2018a.gif" width="251" height="71"><p align="center">
      Figure 1 Program GUI<p>
<font color="#FF0000"><b>Operation of the program</b></font><p>
The program demonstrates the capture and subsequent playback of audio data, and 
also demonstrates the instantiation, registration, and operation of line event 
listeners as well. The event listeners display messages on the screen when the 
various audio line events occur.<p>
Input data from a microphone is captured and saved in a <b>ByteArrayOutputStream</b> 
object when the user clicks the <b>Capture</b> button.<p>
Data capture stops when the user clicks the <b>Stop</b> button.<p>
Playback begins when the user clicks the <b>Playback</b> button.<p>
<font color="#FF0000"><b>Event handler output is displayed</b></font><p>
Line events are fired each time the user clicks one of the buttons and causes 
the line to be opened, started, stopped, or closed.&nbsp; The registered event 
handler methods display information on the screen about the event and the line 
each time such an event is fired.&nbsp; I will provide sample screen output at 
the appropriate points in the discussion.<p>
<font color="#FF0000"><b>Will discuss in fragments</b></font><p>
As usual, I will discuss this program in fragments.&nbsp; A complete listing of 
the program is shown in Listing 16 near the end of the lesson.<p>
<font color="#FF0000"><b>Updated version of a previously-discussed program</b></font><p>
The program that I will discuss in this lesson is an updated version of the 
program that I discussed in the following lessons:<ul>
  <li><a href="http://www.developer.com/java/other/article.php/1572251">Java 
  Sound, Getting Started, Part 1, Playback</a></li>
  <li><a href="http://www.developer.com/java/other/article.php/1579071">Java 
  Sound, Getting Started, Part 2, Capture using Specified Mixer</a></li>
  </ul>
  <p>
I will discuss the entire program very briefly to establish the context.&nbsp; 
However, I will concentrate my detailed discussion on those aspects of the 
program that were updated to support audio line event handling.<blockquote>
    <p>
<i>(I strongly recommend that you refer back to the two lessons listed above for 
the detailed discussion of those parts of the program that don't involve event 
handling.)</i></blockquote>
  <p>
<font color="#FF0000"><b>The program named AudioEvents01</b></font><p>
The program named <b>AudioEvents01</b> demonstrates the use of a Java program to:<ul>
    <li>Capture audio data from a microphone into a<b> ByteArrayOutputStream</b> 
    object.</li>
    <li>Register an event listener object on the line used to capture the data.</li>
    <li>Handle an event each time the capture line is opened, started, stopped, 
    or closed.</li>
    <li>Play back the data stored in the<b> ByteArrayOutputStream</b> object.</li>
    <li>Register an event listener object on the line used to play back the 
    captured data.</li>
    <li>Handle an event each time the playback line is opened, started, stopped, 
    or closed.</li>
    </ul>
    <p>
<font color="#FF0000"><b>Behavior of the event handler methods</b></font><p>
The behavior of the event handler methods is very simple in this sample program.&nbsp; 
The behavior is provided solely for purposes of illustration.&nbsp; You are 
reminded that the behavior of the event handler methods can be as simple or as 
complex as your needs may dictate.&nbsp; The important point is that the event 
handler methods are invoked when the events are fired.&nbsp; You can design 
those methods to provide whatever behavior is appropriate for your situation.<p>
<font color="#FF0000"><b>Should you spawn a new thread?</b></font><p>
As in all forms of event handling in Java, if the task to be performed by your 
event handler method will require a significant amount of time to complete, you 
should probably spawn a new thread to carry out that task and cause your event 
handler method to return as soon as possible.<blockquote>
      <p>
<i>(I didn't do that in this program due to the simplicity and speed of the 
behavior of my event handling methods.)</i></blockquote>
    <p>
<font color="#FF0000"><b>The controlling class named AudioEvents01</b></font><p>
The class definition for the controlling class begins in Listing 1.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public class <b>AudioEvents01</b> extends JFrame{

  boolean stopCapture = false;
  ByteArrayOutputStream byteArrayOutputStream;
  AudioFormat audioFormat;
  TargetDataLine targetDataLine;
  AudioInputStream audioInputStream;
  SourceDataLine sourceDataLine;

  public static void <b>main</b>(String args[]){
    new AudioEvents01();
  }//end main

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 1 includes the declaration of some instance variables and 
the <b>main</b> method.&nbsp; The behavior of the <b>main</b> method is simply 
to instantiate a new object of the controlling class.<p>
<font color="#FF0000"><b>The constructor</b></font><p>
The constructor for the controlling class begins in Listing 2.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public AudioEvents01(){//constructor
    final JButton captureBtn =
                          new JButton("Capture");
    final JButton stopBtn = new JButton("Stop");
    final JButton playBtn =
                         new JButton("Playback");

    captureBtn.setEnabled(true);
    stopBtn.setEnabled(false);
    playBtn.setEnabled(false);

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 2 creates the button objects shown in Figure 1, and sets the 
initial enabled and disabled properties of those buttons.<p>
<font color="#FF0000"><b>Action event handlers</b></font><p>
The code in Listing 3 instantiates three <b>ActionListener</b> objects and 
registers each of those listener objects on one of the three buttons shown in 
the GUI in Figure 1.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    <b>captureBtn.addActionListener(</b>
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(false);
          stopBtn.setEnabled(true);
          playBtn.setEnabled(false);
          //Capture input data from the
          // microphone until the Stop button is
          // clicked.
          captureAudio();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(captureBtn);

    <b>stopBtn.addActionListener(</b>
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(true);
          stopBtn.setEnabled(false);
          playBtn.setEnabled(true);
          //Terminate the capturing of input
          // data from the microphone.
          stopCapture = true;
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(stopBtn);

    <b>playBtn.addActionListener(</b>
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          //Play back all of the data that was
          // saved during capture.
          playAudio();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(playBtn);

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p>
Code very similar to that shown in Listing 3 was discussed in detail in the two 
lessons listed earlier.&nbsp; Therefore, I won't repeat that discussion here.<p>
<font color="#FF0000"><b>Complete the GUI</b></font><p>
The code in Listing 4 takes care of a few more details required to complete the 
GUI and make it visible.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    getContentPane().setLayout(new FlowLayout());
    setTitle("Copyright 2003, R.G.Baldwin");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setSize(250,70);
    setVisible(true);
  }//end constructor

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 4 signals the end of the constructor.<p>
<font color="#FF0000"><b>The captureAudio method</b></font><p>
If you refer back to Listing 3, you will see that the event handler on the <b>
Capture</b> button invokes the method named <b>captureAudio</b> to cause the 
actual data capture operation to be carried out.&nbsp; The method named <b>
captureAudio</b> captures audio input from a microphone and saves it in a <b>
ByteArrayOutputStream</b> object.<p>
The code for the method named <b>captureAudio</b> begins in Listing 5<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  private void <b>captureAudio</b>(){
    try{
      //Get everything set up for capture
      audioFormat = getAudioFormat();
      DataLine.Info dataLineInfo =
                          new DataLine.Info(
                            TargetDataLine.class,
                            audioFormat);
      <b>targetDataLine</b> =
             (TargetDataLine)AudioSystem.getLine(
                                   dataLineInfo);

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Nothing new so far</b></font><p>
So far, there is still nothing new to discuss.&nbsp; The code in Listing 5 was 
discussed in detail in the two lessons listed earlier, so I won't repeat that 
discussion here.<p>
The main thing to note in Listing 5 is the creation of an object of type <b>Line</b>, 
and the storage that object's reference in an instance variable of type <b>
TargetDataLine</b> named <b>targetDataLine.</b><p>
<font color="#FF0000"><b>The open, start, stop, and close methods</b></font><p>
The previous lessons have discussed the methods of the <b>TargetDataLine</b> 
object named <b>open</b> <b>start</b>, <b>stop</b>, and <b>close</b> in detail.&nbsp; 
However, here is some information from Sun that I did not discuss in those 
lessons.<p>
With respect to the <b>open</b> method, Sun tells us,<blockquote>

<p>
<i>&quot;If this operation succeeds, the line is marked as open, and an OPEN event is 
dispatched to the line's listeners.&quot;</i></blockquote>

<p>
Similarly, with respect to the <b>start</b> method, Sun tells us,<blockquote>

<p>
<i>&quot;When audio capture or playback starts, a START event is generated.&quot;</i></blockquote>

<p>
As you have probably guessed by now, Sun has this to say about the <b>stop</b> 
method.<blockquote>

<p>
<i>&quot;When audio capture or playback stops, a STOP event is generated.&quot;</i></blockquote>

<p>
Finally, Sun has this to say about the <b>close</b> method.<blockquote>

<p>
<i>&quot;If this operation succeeds, the line is marked closed and a CLOSE event is 
dispatched to the line's listeners.&quot;</i></blockquote>

<p>
<font color="#FF0000"><b>Event registration methods</b></font><p>
If you are familiar with Java event handling in general, and JavaBeans design 
patterns in particular, you have probably already predicted that the <b>
TargetDataLine</b> object provides the following event registration methods:<ul>
      <li>addLineListener(LineListener listener)</li>
      <li>removeLineListener(LineListener listener)</li>
      </ul>

<p>
<font color="#FF0000"><b>The addLineListener method</b></font><p>
Here is what Sun has to say about the <b>addLineListener</b> method.<blockquote>

<p>
<i>&quot;Adds a listener to this line. Whenever the line's status changes, the 
listener's <b>update</b>() method is called with a <b>LineEvent</b> object that 
describes the change.&quot;</i></blockquote>

<p>
Similarly, the <b>removeLineListener</b> method<blockquote>

<p>
<i>&quot;Removes the specified listener from this line's list of listeners.&quot;</i></blockquote>

<p>
<font color="#FF0000"><b>The LineListener interface</b></font><p>
Note that both of the registration methods require an incoming parameter of the
<b>LineListener</b> type.&nbsp; Stated differently, in each case, the incoming 
parameter must be a reference to an object instantiated from a class that 
implements the <b>LineListener</b> interface.<p>
Sun has this to say about the <b>LineListener</b> interface.<blockquote>

<p>
<i>&quot;Instances of classes that implement the <b>LineListener</b> interface can 
register to receive events when a line's status changes.&quot;</i></blockquote>

<p>
The <b>LineListener</b> interface declares a single method named <b>update</b>, 
which receives an incoming parameter of type <b>LineEvent</b>.<p>
<font color="#FF0000"><b>The update method</b></font><p>
Every class that implements the <b>LineListener</b> interface must provide a 
concrete definition of the update method.&nbsp; Sun has this to say about that 
method.<blockquote>

<p>
<i>&quot;Informs the listener that a line's state has changed. The listener can then 
invoke <b>LineEvent</b> methods to obtain information about the event.&quot;</i></blockquote>

<p>
In other words, whenever a <b>LineEvent</b> occurs, the <b>Line</b> object 
notifies all registered listeners by invoking the <b>update</b> method on each 
registered listener object, passing a <b>LineEvent</b> object's reference as a 
parameter to the <b>update</b> method.&nbsp; The <b>LineEvent</b> object 
encapsulates information about the event.<p>
<font color="#FF0000"><b>The LineEvent class</b></font><p>
That brings us to the crux of the matter involving audio line event firing and 
handling.&nbsp; Sun has this to say about the <b>LineEvent</b> class.<blockquote>

<p>
<i>&quot;The <b>LineEvent</b> class encapsulates information that a line sends its 
listeners whenever the line opens, closes, starts, or stops. Each of these four 
state changes is represented by a corresponding type of event. A listener 
receives the event as a parameter to its update method. By querying the event, 
the listener can learn the type of event, the line responsible for the event, 
and how much data the line had processed when the event occurred.&quot;</i></blockquote>

<p>
<font color="#FF0000"><b>The LineEvent methods</b></font><p>
As of Java SDK 1.4.1, an object of the <b>LineEvent</b> class provides the 
following methods that an event handler can use to obtain information about the 
event:<ul>
        <li><b>getFramePosition</b> - Returns the position of the line's audio 
        data when the event occurred, expressed in sample frames.</li>
        <li><b>getLine</b> - Returns a reference to the <b>Line</b> object that 
        fired the event.</li>
        <li><b>getType</b> - Returns the type of the event <i>(open, start, 
        stop, or close) </i>as <b>LineEvent.Type</b>.</li>
        <li><b>toString</b> - Returns a string representation of the event.</li>
        </ul>

<p>
<font color="#FF0000"><b>Register a line listener on the TargetDataLine object</b></font><p>
Finally, we are going to see the above discussion rendered in code.&nbsp; The 
somewhat cryptic code in Listing 6 instantiates an anonymous listener object 
from an anonymous class that implements the <b>LineListener</b> interface, and 
registers that listener object on the <b>TargetDataLine</b> object that was 
created in Listing 5.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      targetDataLine.<b>addLineListener</b>(
        new <b>LineListener</b>(){

          public void <b>update(LineEvent e</b>){
            System.out.println(
             "<b>Event handler for TargetDataLine</b>");
            System.out.println(
                   "Event type: " + <b>e.getType()</b>);
            System.out.println("Line info: " +
                      <b>e.getLine().getLineInfo()</b>);
            System.out.println();//blank line
          }//end update

        }//end LineListener
      );//end addLineListener()

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The update method</b></font><p>
The code in Listing 6 defines the <b>update</b> method that will be invoked on 
the registered listener object each time a line event occurs.<p>
The code in the <b>update</b> method begins by printing <b>"Event handler for TargetDataLine&quot;</b> 
on the screen.<p>
Then it invokes the <b>getType</b> method to get and display the type of the 
line event.<p>
Following that, it invokes the <b>getLine</b> method to get a reference to the
<b>Line</b> object that fired the event.&nbsp; It uses that reference to invoke 
the <b>getLineInfo</b> method on the line and display information about the 
line.<p>
<font color="#FF0000"><b>Sample screen output</b></font><p>
Figure 2 shows the screen output that appears following a click on the <b>Capture</b> button 
on my system.&nbsp; <i>(The line info output on your system may be different.)</i><blockquote>
          <p>
<i>(Note that line breaks were manually inserted in Figure 2 to accommodate this narrow format.&nbsp; 
The boldface was also manually added for emphasis.)</i></blockquote>
        <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td bgcolor="#00FFFF">
<pre>Event handler for TargetDataLine
Event type: <b>Open</b>
Line info: interface <b>TargetDataLine</b> supporting
 64 audio formats

Event handler for TargetDataLine
Event type: <b>Start</b>
Line info: interface <b>TargetDataLine</b> supporting
 64 audio formats

<b><font face="Courier New,Courier">Figure 2</font></b></pre>
</td>
</tr>
</table>

<p>
Later on, when we examine the code that is used to capture the data, you will 
see the statements that open and start the line, causing the <b>OPEN</b> and <b>
START</b> events shown in Figure 2 to be fired.<p>
<font color="#FF0000"><b>Create and start a thread to capture the audio data</b></font><p>
The code in Listing 7 instantiates a new thread object and starts it running.&nbsp; 
The purpose of this thread is to perform the actual data capture.&nbsp; The <b>
run</b> method of the thread will continue to capture audio data from the 
microphone until the <b>Stop</b> button is clicked by the user.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      <b>new CaptureThread().start();</b>
    }catch (Exception e) {
      System.out.println(e);
      System.exit(0);
    }//end catch
  }//end captureAudio method

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p>
Once the thread is running to capture the data, the <b>captureAudio</b> method 
returns control to the event handler on the <b>Capture</b> button, which 
terminates shortly thereafter.&nbsp; This frees up the event-handling thread to 
handle an event when the <b>Stop</b> button is clicked.<p>
<font color="#FF0000"><b>The CaptureThread class</b></font><p>
At this point, I am going to discuss an inner class, an object of which is used 
to capture data from the microphone.&nbsp; Once again, this class is very 
similar to one that was discussed in detail in the two lessons listed earlier.&nbsp; 
Therefore, this discussion will be very brief, emphasizing only those aspects of 
the code in the class that is important to audio line event handling.<p>
The beginning of the class named <b>CaptureThread</b> and its <b>run</b> method 
is shown in Listing 8.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>CaptureThread</b> extends Thread{
  //An arbitrary-size temporary holding buffer
  byte tempBuffer[] = new byte[10000];
  public void <b>run()</b>{

    byteArrayOutputStream =
                     new ByteArrayOutputStream();
    stopCapture = false;
    try{

<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p>
If you have studied the two lessons listed previously, there is nothing new or 
exciting about the code in Listing 8, so I won't discuss it further.&nbsp; I 
show it here simply to establish the context for the discussion that follows.<p>
<font color="#FF0000"><b>Open and start the line</b></font><p>
The code in Listing 9 isn't new, but it is very interesting in the context of 
this lesson.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      targetDataLine.<b>open</b>(audioFormat);
      targetDataLine.<b>start</b>();

<b><font face="Courier New,Courier">Listing 9</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 9 first invokes the <b>open</b> method on the <b>
TargetDataLine</b> object.&nbsp; Following that, it invokes the <b>start</b> 
method on the <b>TargetDataLine</b> object.<p>
I discussed these two methods in detail in previous lessons.&nbsp; In addition, 
I told you earlier in this lesson that the invocation of these methods causes 
the <b>OPEN</b> and <b>START</b> events to be fired.&nbsp; Therefore, it is the 
invocation of these two methods that causes the <b>update</b> method registered 
on the <b>TargetDataLine</b> object to be invoked.&nbsp; This, in turn, produces 
the screen output shown in Figure 2.<p>
<font color="#FF0000"><b>Behavior of the update method</b></font><p>
Once again, the behavior that I designed into my version of the <b>update</b> 
method is very simple.&nbsp; It just displays some information about the event 
and the line that fired it.<p>
However, the behavior that you design into your version of the <b>update</b> 
method can be as simple or as complex as your needs may dictate.<p>
<font color="#FF0000"><b>Loop until stopCapture variable goes true</b></font><p>
Continuing with the <b>run</b> method of the <b>CaptureThread</b> class, the 
code in Listing 10 loops until the value of the variable named <b>stopCapture</b> 
changes from false to true.&nbsp; <i>(This happens when the user clicks the <b>
Stop</b> button.)</i><br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      <b>while</b>(!stopCapture){
        //Read data from the internal buffer of
        // the data line.
        int cnt = targetDataLine.read(
                              tempBuffer,
                              0,
                              tempBuffer.length);
        if(cnt > 0){
          //Save data in output stream object.
          byteArrayOutputStream.write(
                             tempBuffer, 0, cnt);
        }//end if
      }//end while
      byteArrayOutputStream.close();

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>

<p>
During this period, the code in Listing 10 continues to capture audio data from 
the microphone and to store that data in the <b>ByteArrayOutputStream</b> 
object.&nbsp; <i>(I discussed the operation of this <b>while</b> loop in detail 
in the previous lessons.)</i><p>
<font color="#FF0000"><b>Stop and close the TargetDataLine object</b></font><p>
When the <b>while</b> loop terminates, the two statements in Listing 11 invoke 
the <b>stop</b> and <b>close</b> methods, respectively, on the <b>TargetDataLine</b> 
object.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      targetDataLine.<b>stop</b>();
      targetDataLine.<b>close</b>();

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Fire STOP and CLOSE events</b></font><p>
As explained earlier, this causes the <b>TargetDataLine</b> object to fire <b>
STOP</b> and <b>CLOSE</b> events respectively.&nbsp; This, in turn causes the <b>
update</b> method in the listener object to be invoked twice in succession, 
producing the screen output shown in Figure 3.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td bgcolor="#00FFFF">
<pre>Event handler for TargetDataLine
Event type: <b>Stop</b>
Line info: interface <b>TargetDataLine</b> supporting
 64 audio formats

Event handler for TargetDataLine
Event type: <b>Close</b>
Line info: interface <b>TargetDataLine</b> supporting
 64 audio formats

<b><font face="Courier New,Courier">Figure 3</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The end of the run method</b></font><p>
Except for a required <b>catch</b> block, the code in Listing 11 signals the end 
of the <b>run</b> method of the <b>CaptureThread</b> class.&nbsp; That code also 
signals the end of the class as well.<p>
Finally, the code in Listing 11 signals the end of the discussion of the data 
capture portion of this program.<p>
<font color="#FF0000"><b>The playback portion of the program</b></font><p>
With respect to audio line event handling, there is very little difference 
between the playback portion of this program and the data capture portion 
discussed above.<p>
I discussed the event handling aspects of the data capture portion of the 
program in detail in the preceding paragraphs.&nbsp; I discussed the other 
aspects of the playback portion of the program in detail in the lessons listed 
earlier.&nbsp; Therefore, in the remainder of this lesson, I will discuss the 
event handling aspects of the playback portion of the program only briefly.&nbsp; 
As mentioned earlier, you can view a complete listing of the program in Listing 
16 near the end of the lesson.<p>
<font color="#FF0000"><b>The playAudio method</b></font><p>
This program uses a method named <b>playAudio</b> to play back the data that was 
captured and saved in a <b>ByteArrayOutputStream</b> object.<p>
<font color="#FF0000"><b>Get a SourceDataLine object</b></font><p>
The capture portion of the program uses a <b>TargetDataLine</b> object to 
capture microphone data in real time.<p>
Similarly, the playback portion uses a <b>SourceDataLine</b> object to deliver 
the audio data to the speakers in real time.<p>
Much of the early code in the <b>playAudio</b> method was deleted from Listing 
12 for brevity.&nbsp; The first statement in Listing 12 gets a <b>SourceDataLine</b> 
object's reference and assigns it to a reference variable named <b>
sourceDataLine</b>.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>// Code deleted from playAudio method for brevity

      sourceDataLine =
             (SourceDataLine)AudioSystem.<b>getLine</b>(
                                   dataLineInfo);


      //Register a line listener on the
      // SourceDataLine object
      sourceDataLine.<b>addLineListener</b>(
        new <b>LineListener</b>(){
          public void <b>update</b>(LineEvent e){
            System.out.println(
             "Event handler for SourceDataLine");
            System.out.println(
                   "Event type: " + e.<b>getType</b>());
            System.out.println("Line info: "
                    + <b>e.getLine().getLineInfo()</b>);
            System.out.println();//blank line
          }//end update
        }//end LineListener
      );//end addLineListener()

      //Create a thread to play back the data and
      // start it running.
      <b>new PlayThread().start();</b>

<b><font face="Courier New,Courier">Listing 12</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Register a line listener on the SourceDataLine object</b></font><p>
Following that, the code in Listing 12 instantiates a <b>LineListener</b> object 
and registers it on the <b>SourceDataLine</b> object.&nbsp; The definition and 
behavior of the line listener instantiated in Listing 12 is essentially the same 
as that shown in Listing 6 earlier.<p>
<font color="#FF0000"><b>Start a playback thread running</b></font><p>
Then the code in Listing 12 instantiates a playback thread object and starts it 
running.&nbsp; The<b> run </b>method of the playback thread will continue 
running until the audio data previously stored in the <b>ByteArrayOutputStream</b> 
object is exhausted.<p>
<font color="#FF0000"><b>The PlayThread class</b></font><p>
The playback thread is instantiated from the <b>PlayThread</b> class, which 
begins in Listing 13.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>PlayThread</b> extends Thread{
  byte tempBuffer[] = new byte[10000];

  public void <b>run()</b>{
    try{
      int cnt;

      sourceDataLine.<b>open</b>(audioFormat);
      sourceDataLine.<b>start</b>();

<b><font face="Courier New,Courier">Listing 13</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 13 invokes the <b>open</b> and <b>start</b> methods on the
<b>SourceDataLine</b> object, causing <b>OPEN</b> and <b>START</b> events to be 
fired.<p>
<font color="#FF0000"><b>The screen output</b></font><p>
These events are handled by the <b>update</b> event handler method defined in 
Listing 12.&nbsp; This causes the output shown in Figure 4 to appear on the 
screen.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td bgcolor="#00FFFF">
<pre>Event handler for SourceDataLine
Event type: <b>Open</b>
Line info: interface <b>SourceDataLine</b> supporting
 8 audio formats

Event handler for SourceDataLine
Event type: <b>Start</b>
Line info: interface <b>SourceDataLine</b> supporting
 8 audio formats

<b><font face="Courier New,Courier">Figure 4</font></b></pre>
</td>
</tr>
</table>

        <blockquote>

<p>
<i>(Note that the Line info regarding the <b>SourceDataLine</b> in Figure 4 is a 
little different from the similar information regarding the <b>TargetDataLine</b> 
in Figure 2.&nbsp; Information for your system may be different from that shown 
for my system.)</i></blockquote>

<p>
<font color="#FF0000"><b>The playback loop</b></font><p>
As is the case for the data capture portion of this program, the playback 
portion uses a <b>while</b> loop to transfer data from the <b>
ByteArrayOutputStream</b> object to the internal buffer of the <b>SourceDataLine</b> 
object.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      <b>while</b>((cnt = audioInputStream.read(
                              tempBuffer,
                              0,
                              tempBuffer.length))
                                          != -1){
        if(cnt > 0){
          //Write data to the internal buffer of
          // the data line where it will be
          // delivered to the speaker.
          sourceDataLine.write(
                             tempBuffer, 0, cnt);
        }//end if
      }//end while

<b><font face="Courier New,Courier">Listing 14</font></b></pre>
</td>
</tr>
</table>

<p>
The <b>SourceDataLine</b> object delivers that audio data in real time to the 
speakers on the computer.<p>
The data transfer from the <b>ByteArrayOutputStream</b> object to the <b>
SourceDataLine</b> object continues until the data stored in the <b>
ByteArrayOutputStream</b> object is exhausted, at which time the <b>read</b> 
method in Listing 14 returns -1.<p>
<font color="#FF0000"><b>The drain method</b></font><p>
The <b>while</b> loop terminates when the data in the <b>ByteArrayOutputStream</b> 
object is exhausted.&nbsp; However, the program must not terminate at that point 
in time.&nbsp; In all likelihood, there is data still remaining in the internal 
buffer of the <b>SourceDataLine</b> object that needs to be sent to the speakers 
in real time.&nbsp; That is the purpose of the <b>drain</b> method that is 
invoked in Listing 15.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      sourceDataLine.<b>drain</b>();
      sourceDataLine.<b>close</b>();

<b><font face="Courier New,Courier">Listing 15</font></b></pre>
</td>
</tr>
</table>

<p>
The <b>drain</b> method blocks until the internal buffer of the <b>
SourceDataLine</b> object becomes empty, at which time it returns.<p>
<font color="#FF0000"><b>No stop method is invoked</b></font><p>
Note that in this case, I did not explicitly invoke the <b>stop</b> method, but 
a <b>STOP</b> event was fired anyway.&nbsp; Apparently invoking the <b>close</b> 
method on a line that has been drained causes both a <b>STOP</b> event and a <b>
CLOSE</b> event to be fired.&nbsp; The screen output produced by the code in 
Listing 15 is shown in Figure 5.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td bgcolor="#00FFFF">
<pre>Event handler for SourceDataLine
Event type: <b>Stop</b>
Line info: interface <b>SourceDataLine</b> supporting
 8 audio formats

Event handler for SourceDataLine
Event type: <b>Close</b>
Line info: interface <b>SourceDataLine</b> supporting
 8 audio formats

<b><font face="Courier New,Courier">Figure 5</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The getAudioFormat method</b></font><p>
There is one additional method that I haven't discussed in this lesson.&nbsp; 
The method named <b>getAudioFormat</b> is identical to the method with the same 
name used in the earlier version of the program.&nbsp; I explained the behavior 
of that method in detail in the lessons listed earlier.&nbsp; Therefore, I won't 
discuss this method in this lesson.&nbsp; You can view it in Listing 16 near the 
end of the lesson.<center>
<h2>
<a NAME="Run the program"></a>Run the Program</h2></center>
        <p>
      At this point, you may find it useful to compile and run the program shown 
      in Listing 16 near the end of the lesson.<p>
      <font color="#FF0000"><b>Capture the data</b></font><p>
      Start the program and click the <b>Capture</b> button.&nbsp; Talk into the 
      microphone for a short period of time and then click the <b>Stop</b> 
      button to terminate data capture.&nbsp; While you are doing this, observe 
      the output on the command-line screen.<blockquote>
          <p>
      <i>(Be careful and don't attempt to capture too much audio data.&nbsp; The 
      data is being captured in memory, and if you attempt to capture too much 
      data, you may run out of memory.)</i></blockquote>
        <p>
      <font color="#FF0000"><b>Play the captured data back</b></font><p>
      Click the <b>Playback</b> button to cause the captured data to be played 
      back through the speakers on your computer.&nbsp; Again, observe the 
      output on the command-line screen while you are doing this.<p>
      <font color="#FF0000"><b>Volume control</b></font><p>
      If you don't hear anything during playback, you may need to increase your speaker volume.&nbsp; 
      My laptop computer has a manual volume control in addition to the software volume 
      controls that are accessible via the speaker icon in the system tray.<p>
      <font color="#FF0000"><b>In case of a runtime error</b></font><p>
      If you get a runtime error while attempting to capture the audio data, see 
      the comments in the <b>getAudioFormat</b> method in Listing 16.&nbsp; You 
      may need to try using a different audio format.&nbsp; I have received 
      feedback from some readers who tell me that the format that I used in this 
      program doesn't work on all systems.<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I have presented and explained a program that demonstrates 
the use of audio line events.&nbsp; You can use this approach to register 
listeners and to receive notifications whenever an audio line is opened, 
started, stopped, or closed.&nbsp; Once you receive the notification, you can 
learn the type of event, the line responsible for the event, information about 
that line, and how much data the line had processed when the event occurred.</p>
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
        A complete listing of the program is shown in Listing 16.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File AudioEvents01.java
The main purpose of this program is to
demonstrate audio line event handling.

This program demonstrates the capture and
subsequent playback of audio data, and
demonstrates the instantiation and registration
of line event listeners as well.  The event
listeners display messages on the screen when
the various audio line events occur.

A GUI appears on the screen containing the
following buttons:
Capture
Stop
Playback

Input data from a microphone is captured and
saved in a ByteArrayOutputStream object when the
user clicks the Capture button.

Data capture stops when the user clicks the Stop
button.

Playback begins when the user clicks the Playback
button.

Following is the screen output following the
click on the Capture button.  Note that line
breaks were manually inserted in this, and the
other output material shown below, to cause the
material to fit this narrow format.

Event handler for TargetDataLine
Event type: Open
Line info: interface TargetDataLine supporting
 64 audio formats

Event handler for TargetDataLine
Event type: Start
Line info: interface TargetDataLine supporting
 64 audio formats



Following is the screen output following the
click on the Stop button.

Event handler for TargetDataLine
Event type: Stop
Line info: interface TargetDataLine supporting
 64 audio formats

Event handler for TargetDataLine
Event type: Close
Line info: interface TargetDataLine supporting
 64 audio formats



Following is the screen output following the
click on the Playback button.

Event handler for SourceDataLine
Event type: Open
Line info: interface SourceDataLine supporting
 8 audio formats

Event handler for SourceDataLine
Event type: Start
Line info: interface SourceDataLine supporting
 8 audio formats

Event handler for SourceDataLine
Event type: Stop
Line info: interface SourceDataLine supporting
 8 audio formats

Event handler for SourceDataLine
Event type: Close
Line info: interface SourceDataLine supporting
 8 audio formats

Tested using SDK 1.4.0 under Win2000
************************************************/

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.sound.sampled.*;

public class AudioEvents01 extends JFrame{

  boolean stopCapture = false;
  ByteArrayOutputStream byteArrayOutputStream;
  AudioFormat audioFormat;
  TargetDataLine targetDataLine;
  AudioInputStream audioInputStream;
  SourceDataLine sourceDataLine;

  public static void main(String args[]){
    new AudioEvents01();
  }//end main

  public AudioEvents01(){//constructor
    final JButton captureBtn =
                          new JButton("Capture");
    final JButton stopBtn = new JButton("Stop");
    final JButton playBtn =
                         new JButton("Playback");

    captureBtn.setEnabled(true);
    stopBtn.setEnabled(false);
    playBtn.setEnabled(false);

    //Register anonymous listeners
    captureBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(false);
          stopBtn.setEnabled(true);
          playBtn.setEnabled(false);
          //Capture input data from the
          // microphone until the Stop button is
          // clicked.
          captureAudio();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(captureBtn);

    stopBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(true);
          stopBtn.setEnabled(false);
          playBtn.setEnabled(true);
          //Terminate the capturing of input
          // data from the microphone.
          stopCapture = true;
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(stopBtn);

    playBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          //Play back all of the data that was
          // saved during capture.
          playAudio();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()
    getContentPane().add(playBtn);

    getContentPane().setLayout(new FlowLayout());
    setTitle("Copyright 2003, R.G.Baldwin");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setSize(250,70);
    setVisible(true);
  }//end constructor

  //This method captures audio input from a
  // microphone and saves it in a
  // ByteArrayOutputStream object.
  private void captureAudio(){
    try{
      //Get everything set up for capture
      audioFormat = getAudioFormat();
      DataLine.Info dataLineInfo =
                          new DataLine.Info(
                            TargetDataLine.class,
                            audioFormat);
      targetDataLine =
             (TargetDataLine)AudioSystem.getLine(
                                   dataLineInfo);

      //Register a line listener on the
      // TargetDataLine object
      targetDataLine.addLineListener(
        new LineListener(){
          public void update(LineEvent e){
            System.out.println(
             "Event handler for TargetDataLine");
            System.out.println(
                   "Event type: " + e.getType());
            System.out.println("Line info: " +
                      e.getLine().getLineInfo());
            System.out.println();//blank line
          }//end update
        }//end LineListener
      );//end addLineListener()

      //Create a thread to capture the
      // microphone data and start it running. It
      // will run until the Stop button is
      // clicked.
      new CaptureThread().start();
    }catch (Exception e) {
      System.out.println(e);
      System.exit(0);
    }//end catch
  }//end captureAudio method

  //This method plays back the audio
  // data that has been saved in the
  // ByteArrayOutputStream
  private void playAudio() {
    try{
      //Get everything set up for playback.
      //Get the previously-saved data into a
      // byte array object.
      byte audioData[] = byteArrayOutputStream.
                                   toByteArray();
      //Get an input stream on the byte array
      // containing the data
      InputStream byteArrayInputStream =
                        new ByteArrayInputStream(
                                      audioData);
      AudioFormat audioFormat = getAudioFormat();
      audioInputStream =
                new AudioInputStream(
                  byteArrayInputStream,
                  audioFormat,
                  audioData.length/audioFormat.
                    getFrameSize());

      DataLine.Info dataLineInfo =
                          new DataLine.Info(
                            SourceDataLine.class,
                              audioFormat);

      sourceDataLine =
             (SourceDataLine)AudioSystem.getLine(
                                   dataLineInfo);


      //Register a line listener on the
      // SourceDataLine object
      sourceDataLine.addLineListener(
        new LineListener(){
          public void update(LineEvent e){
            System.out.println(
             "Event handler for SourceDataLine");
            System.out.println(
                   "Event type: " + e.getType());
            System.out.println("Line info: "
                    + e.getLine().getLineInfo());
            System.out.println();//blank line
          }//end update
        }//end LineListener
      );//end addLineListener()

      //Create a thread to play back the data and
      // start it running.  It will run until all
      // the data has been played back, at which
      // time it will automatically stop the
      // line and fire a Stop event.
      new PlayThread().start();
    }catch (Exception e) {
      System.out.println(e);
      System.exit(0);
    }//end catch
  }//end playAudio

  //This method creates and returns an
  // AudioFormat object for a given set of format
  // parameters.  If these parameters don't work
  // well for you, try some of the other
  // allowable parameter values, which are shown
  // in comments following the declarations.
  private AudioFormat getAudioFormat(){
    float sampleRate = 8000.0F;
    //8000,11025,16000,22050,44100
    int sampleSizeInBits = 16;
    //8,16
    int channels = 1;
    //1,2
    boolean signed = true;
    //true,false
    boolean bigEndian = false;
    //true,false
    return new AudioFormat(sampleRate,
                           sampleSizeInBits,
                           channels,
                           signed,
                           bigEndian);
  }//end getAudioFormat
//=============================================//

//Inner class to capture data from microphone
class CaptureThread extends Thread{
  //An arbitrary-size temporary holding buffer
  byte tempBuffer[] = new byte[10000];
  public void run(){

    byteArrayOutputStream =
                     new ByteArrayOutputStream();
    stopCapture = false;
    try{
      targetDataLine.open(audioFormat);
      targetDataLine.start();

      //Loop until stopCapture is set by another
      // thread that services the Stop button.
      while(!stopCapture){
        //Read data from the internal buffer of
        // the data line.
        int cnt = targetDataLine.read(
                              tempBuffer,
                              0,
                              tempBuffer.length);
        if(cnt > 0){
          //Save data in output stream object.
          byteArrayOutputStream.write(
                             tempBuffer, 0, cnt);
        }//end if
      }//end while
      byteArrayOutputStream.close();

      targetDataLine.stop();
      targetDataLine.close();

    }catch (Exception e) {
      System.out.println(e);
      System.exit(0);
    }//end catch
  }//end run
}//end inner class CaptureThread
//=============================================//

//Inner class to play back the data that was
// saved.
class PlayThread extends Thread{
  byte tempBuffer[] = new byte[10000];

  public void run(){
    try{
      int cnt;

      sourceDataLine.open(audioFormat);
      sourceDataLine.start();

      //Loop until the input read method returns
      // -1 for empty stream.
      while((cnt = audioInputStream.read(
                              tempBuffer,
                              0,
                              tempBuffer.length))
                                          != -1){
        if(cnt > 0){
          //Write data to the internal buffer of
          // the data line where it will be
          // delivered to the speaker.
          sourceDataLine.write(
                             tempBuffer, 0, cnt);
        }//end if
      }//end while
      //Block and wait for internal buffer of the
      // data line to become empty.  When it
      // becomes empty, it will fire a Stop
      // event and return.
      sourceDataLine.drain();
      sourceDataLine.close();
    }catch (Exception e) {
      System.out.println(e);
      System.exit(0);
    }//end catch
  }//end run
}//end inner class PlayThread
//=============================================//

}//end outer class AudioEvents01.java

<b><font face="Courier New,Courier">Listing 16</font></b></pre>
</td>
</tr>
</table>

   <hr size=3 width="100%" align=center>
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. <h4>
<a NAME="About the author"></a>About the author</h4>
<i><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a> is a college professor (at Austin Community College in Austin, TX) and private consultant whose primary focus is a combination of Java, C#, and XML. In addition to the many platform and/or language independent benefits of Java and C# applications, he believes that a combination of Java, C#, and XML will become the primary driving force in the delivery of structured information on the Web.</i><br><p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a href="http://www.DickBaldwin.com">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring programmers.
He has also published articles in JavaPro magazine.</i> <p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i> <p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i> <p>-end- </body></html>