<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Adaptive Prediction using Java </h2>
<i>Learn how to use a Java adaptive filter to predict future values in a time 
series.&nbsp; Discover the relationship between the properties of the time 
series and the quality of the prediction.</i><p><b>Published:</b>&nbsp; June 27, 
2006<br>
<b>by <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2362</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Preview">Preview</a></li>
	<li> <a href="#Experimental_Results">Experimental Results</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" >

<h2 align="center"> <a name="Preface"></a>Preface</h2>

<p align="left"><font color="#ff0000"><b>DSP and adaptive filtering</b></font></p>

<p align="left">Digital Signal Processing <i>(<a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a>)</i> 
is showing up in everything from cell phones to hearing aids and rock concerts.&nbsp; 
A 
particularly interesting branch of DSP is <i>adaptive filtering.</i>&nbsp; This is a 
scenario where the characteristics of the digital processor change with time, 
circumstances, or both.</p>

<p align="left"><font color="#FF0000"><b>Seventh</b></font><font color="#ff0000"><b> 
in a series</b></font></p>

<p align="left">This is the seventh lesson in a series designed to teach you 
about adaptive filtering in Java.&nbsp; The first lesson, entitled
<a href="http://www.developer.com/java/other/article.php/3549991">Adaptive 
Filtering in Java, Getting Started</a>, introduced you to the topic of adaptively designing a convolution 
filter using an 
<a href="http://cnx.rice.edu/content/m11829/latest/">LMS</a> 
adaptive algorithm.</p>
<p align="left"><font color="#FF0000"><b>A general-purpose adaptive engine</b></font></p>
<p align="left">The third lesson in the series, entitled 
<a href="http://www.developer.com/java/other/article.php/3566951">A 
General-Purpose LMS Adaptive Engine in Java</a>, presented and explained a general-purpose
<a href="http://cnx.rice.edu/content/m11829/latest/">LMS</a> adaptive engine 
written in Java.&nbsp; That engine can be used to solve a wide variety of 
adaptive problems.</p>
<p align="left"><font color="#FF0000"><b>Adaptive noise cancellation</b></font></p>
<p align="left">The previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/3599661">Adaptive Noise Cancellation using Java</a> showed you how to accomplish the 
third item, <i>Noise Cancellation</i>, in 
the following list of common applications of adaptive filtering:</p>
<ul>
	<li>System Identification</li>
	<li>Inverse System Identification</li>
	<li>Noise Cancellation</li>
	<li>Prediction</li>
</ul>
<p><font color="#FF0000"><b>Adaptive prediction</b></font></p>
<p>This lesson presents and explains a program named <b>Adapt09</b>, which 
demonstrates the use of adaptive filtering for the prediction of future values 
in a time series.</p>

<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different listings and figures while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>In preparation for understanding the material in this lesson, 
I recommend that you also study the lessons identified in the <a href="#References">
References</a> section of this document.</p>
<h2 align="center" ><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#FF0000"><b>What is <i>adaptive prediction</i>?</b></font></p>
<p>Quite simply, adaptive prediction is the ability to adaptively design a 
convolution filter that can be applied to a time series in order to predict 
future values of the time series.&nbsp; I will let you use your own imagination
<i>(or perhaps research on the web)</i> to come up with various scenarios where this may 
be useful.</p>
<p><font color="#FF0000"><b>The program named Adapt09</b></font></p>
<p>The purpose of this program is to illustrate an adaptive prediction filter.&nbsp; 
The user can experiment with adaptive prediction by making changes to the 
following program parameters and observing the printed and graphic results:</p>
<ul>
	<li>feedbackGain</li>
	<li>adaptiveFilterLength</li>
	<li>predictionDistance</li>
	<li>signalScale</li>
	<li>noiseScale</li>
	<li>bandpassFilterLength <i>(and hence bandwidth)</i></li>
</ul>
<p><font color="#FF0000"><b>A block diagram</b></font></p>
<p>See the following URL for a brief description and a block diagram of an 
adaptive prediction filter.</p>
<p>
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/<br>
adaptiv8.html#5576</a></p>
<p>I will refer to this block diagram later when discussing this program.</p>
<p><font color="#FF0000"><b>Classes required</b></font></p>
<p>This program requires the following classes:</p>
<ul>
	<li>Adapt09.class</li>
	<li>AdaptEngine02.class</li>
	<li>AdaptiveResult.class</li>
	<li>ForwardRealToComplex01.class</li>
	<li>PlotALot01.class</li>
	<li>PlotALot03.class</li>
	<li>PlotALot05.class</li>
</ul>
<p>The source code for the class named <b>Adapt09</b> is presented in <a href="#Listing_14">Listing 14</a> 
near the end of the lesson.&nbsp; The source code for the other classes in the 
above list can be found in the lessons referred to in the <a href="#References">
References</a> section of this lesson.</p>
<p><font color="#FF0000"><b>A general-purpose adaptive engine</b></font></p>
<p>This program uses the adaptive engine named <b>AdaptEngine02</b> to 
adaptively develop a convolution prediction filter.&nbsp; The adaptive engine is 
represented by the shaded portion of the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.</p>
<p>One of the inputs to the adaptive engine is the current sample of the sum of 
signal plus noise, shown as <b>d(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.&nbsp; This is the target of the prediction process.</p>
<p>The other input to the adaptive engine is an historical sample of signal plus 
noise shown as <b>x(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.</p>
<p>The adaptive engine develops a convolution filter <i>(shown as Adaptive 
Filter in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>)</i> that attempts to use historical signal plus noise samples 
to predict the value of the current sample of signal plus noise <i>(target)</i>.&nbsp; 
Thus, the program attempts to adaptively develop a convolution filter that can 
operate on a time series to predict a future value of the time series.</p>
<p>The distance in time to the future value being predicted is a user input 
parameter.</p>
<p><font color="#FF0000"><b>The iterative process</b></font></p>
<p>The program performs 9890 iterations during which the convolution filter 
coefficients are adaptively updated.&nbsp; Then the adaptive update process is 
disabled.&nbsp; The program then performs 9890 more iterations during which time 
the quality of the prediction is measured and reported.</p>
<p><font color="#FF0000"><b>The prediction quality</b></font></p>
<p>The quality of the prediction is measured by:</p>
<ul>
	<li>Computing the 
	<a href="http://mathworld.wolfram.com/Root-Mean-Square.html">
	Root-Mean-Square</a> (RMS) value of the target <i>(shown as d(k) in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>)</i> averaged over 9890 samples.</li>
	<li>Computing the RMS value of the prediction error <i>(shown as e(k) in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>)</i> averaged over 9890 samples.</li>
	<li>Computing the percentage of the RMS target value represented by the RMS 
	error value.</li>
</ul>
<p><font color="#FF0000"><b>Signal and noise characteristics</b></font></p>
<p>The signal consists of a pure tone at a frequency that is one eighth of the 
sampling frequency <i>(eight samples per cycle)</i>.&nbsp; The peak-to-peak 
value of the signal prior to scaling is 2.</p>
<p>The noise consists of white noise produced by a random number generator with 
a uniform distribution between -1.0 and 1.0 prior to scaling.</p>
<p>The scaled signal is added to the scaled white noise.</p>
<p><font color="#FF0000"><b>Conditioning the signal plus noise</b></font></p>
<p>The sum of signal 
plus white noise can be passed through a variable-width band pass filter with a center frequency 
equal to one-eighth of the sampling frequency.</p>
<blockquote>
	<p><i>(The band pass filter is not shown in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>.&nbsp; Consider it to be to the left of the 
	<span lang="en-us"></span>block 
	diagram with s(k) as its output.)</i></p>
</blockquote>
<p>The center frequency of the band pass filter is the same as the frequency of 
the signal.&nbsp; Thus, the signal plus noise consists of a pure tone surrounded 
by noise for which the noise bandwidth can be controlled by the user.&nbsp; The 
frequency band for the noise is centered on the signal frequency.&nbsp; The user 
controls the signal level and the noise level and hence the signal-to-noise 
ratio.</p>
<p><font color="#FF0000"><b>The band pass filter</b></font></p>
<p>The band pass filter consists of a convolution filter in the form of a 
truncated sinusoid with a frequency of one-eighth of the sampling frequency.&nbsp; 
The user specifies the length of the convolution filter, <i>(up to a limit of 
128 coefficients)</i>, thereby specifying the bandwidth of the filter.&nbsp; The 
bandwidth of the filter is 
roughly proportional to the reciprocal of the length of the convolution filter.&nbsp; 
</p>
<p>The shape of the amplitude response of the pass band for the filter is roughly 
that of a sin(x)/x function.</p>
<p><font color="#FF0000"><b>The graphic program output</b></font></p>
<p>The program produces three graphs in a vertical stack on the screen as shown 
in <a name="Figure_1"><a href="#Figure_1">Figure 1</a></a>.</p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2362aa.jpg" width="450" height="338"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The three graphs display the following information in order from top to 
bottom:</p>
<ul>
	<li>The band pass convolution filter used to filter the raw signal plus 
noise <i>(see the left panel in <a href="#Figure_12">Figure 12</a> as an 
	example)</i>.</li>
	<li>The frequency response of the band pass filter used to filter the raw 
signal plus noise <i>(see the right panel in <a href="#Figure_12">Figure 12</a> 
	as an example)</i>.&nbsp; The frequency response extends from a frequency of 
	zero to one-half the sampling frequency <i>(the Nyquist folding frequency)</i>.</li>
	<li>Four traces of adaptive time-series data <i>(see <a href="#Figure_3">
	Figure 3</a> for an example)</i>.</li>
</ul>
<p><font color="#FF0000"><b>Multiple stacked pages</b></font></p>
<p>The bottom graph consists of 
multiple pages stacked on top of one another.&nbsp; <i>(There are 230 samples 
plotted in each trace on each page.)</i> You must physically move the pages on the top 
of the stack to view the pages further down.&nbsp; The pages on the top of the stack 
represent the results produced early in the adaptive process while those further 
down represent the results produced later in the adaptive process.</p>
<p><font color="#FF0000"><b>The time series</b></font></p>
<p>The four time 
series that are plotted in the bottom graph are, from top to bottom <i>(in the colors indicated):</i></p>
<ul>
	<li><i>(Black)</i> 
The historical signal plus noise input to the adaptive prediction filter, shown 
	as <b>x(k)</b> in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>.</li>
	<li><i>(Red)</i> 
The signal plus noise target for the adaptive prediction filter shown as <b>d(k)</b> 
	in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>.</li>
	<li><i>(Blue)</i> The 
output from the adaptive prediction filter shown as <b>y(k)</b> in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>.</li>
	<li><i>(Green)</i> The prediction error, shown as <b>e(k)</b> in the
	<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
	block diagram</a>.&nbsp; The prediction error is the 
difference between the red target and the blue output from the adaptive prediction filter.&nbsp; Ideally, 
	the prediction error approaches zero as the process 
converges to a solution.</li>
</ul>
<p><font color="#FF0000"><b>The printed program output</b></font></p>
<p>In addition to the graphic output, the program displays the quality of the 
prediction process and the program parameters on the command-line screen as shown in <a name="Figure_2"><a href="#Figure_2">Figure 2</a></a>.</p>






<p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 6.410217370961125
RMS error: 1.4675827349708308
Percent error: 22.894430095601994

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 26
predictionDistance: 1
signalScale: 0.0
noiseScale: 87.5
bpFilterLength: 128
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_2">Figure 2</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>User input</b></font></p>
<p>User input is provided by way of command-line 
parameters.&nbsp; If no command-line parameters are provided, default values are used 
for the program parameters.</p>
<p>The command-line parameters in order are:</p>
<ol>
	<li><b>double feedbackGain</b>:&nbsp; The gain used in the adaptive feedback loop.&nbsp; The default value is 
0.00001.</li>
	<li><b>int adaptiveFilterLength</b>:&nbsp; The default value is 26.</li>
	<li><b>int predictionDistance</b>:&nbsp; The distance in the future, <i>(measured in samples)</i>, that the 
adaptive process attempts to predict the value of signal plus noise (target).&nbsp; The 
default value is 1 sample.</li>
	<li><b>double signalScale</b>:&nbsp; The default value is 
0.&nbsp; Adjust this and the following parameter to adjust the signal-to-noise ratio, and 
also to cause the time-series plots to be in good plotting range.</li>
	<li><b>double noiseScale</b>:&nbsp; The default value is 87.5.</li>
	<li><b>int bandpassFilterLength</b>:&nbsp; The length of 
the convolution filter that is applied to the raw signal plus noise.&nbsp; This value 
must be less than or equal to 128.&nbsp; If it is greater than 128, it is automatically 
set to 128.</li>
</ol>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>The program was tested using J2SE 5.0 and WinXP.&nbsp; J2SE 5.0 or later is required.</p>
<h2 align="center"><font color="#000000"><a name="Experimental_Results">
Experimental Results</a></font></h2>
<p>Before getting into the program details, I'm going to show you some 
experimental results.</p>
<p><font color="#FF0000"><b>The bottom line at the beginning</b></font></p>
<p>As you will see from these experimental results, the ability to predict future values in a time series tends 
to vary inversely with the bandwidth of the time series.&nbsp; Future values of 
narrow-band time series can be predicted reasonably well.&nbsp; Future values of 
wide-band time series cannot be predicted well at all.</p>
<p>I will begin by showing you results for the two extremes:</p>
<ul>
	<li>A pure tone <i>(narrow-band to the extreme)</i>.</li>
	<li>A white time series <i>(wide-band to the extreme)</i>.</li>
</ul>
<p><font color="#FF0000"><b>A pure tone</b></font></p>
<p>A pure tone has the narrowest band width of all time series <i>(theoretically it 
has zero width)</i>.&nbsp; As you will 
see, a pure tone in the absence of noise is totally predictable.</p>
<p>The results of applying the adaptive prediction process to a pure tone are shown in
<a name="Figure_3"><a href="#Figure_3">Figure 3</a></a> and <a href="#Figure_4">Figure 4</a>.</p>
<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362ab1.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ab2.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ab3.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_3">Figure 3</a></b></pre>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>The time series data</b></font></p>
<p>Going from top to bottom, <a href="#Figure_3">Figure 3</a> shows the time series output for the first, second, and thirteenth 
pages.&nbsp; <i>(Recall that each trace on each page 
shows 230 samples of the time series data.)</i>&nbsp; The black trace shows the 
input to the adaptive filter and the red trace shows the target.&nbsp; The blue 
trace shows the output from the adaptive filter.&nbsp; The green trace shows the error.</p>
<p>In the top page of <a href="#Figure_3">Figure 3</a>, the blue output is small and the green error is large.&nbsp; By 
the thirteenth page, the blue output is almost an exact match for the red target 
and the green error has been reduced to almost zero.</p>
<p><font color="#FF0000"><b>The numeric prediction error</b></font></p>
<p>The numeric prediction error <i>(along with some other information)</i> is shown in 
<a name="Figure_4"><a href="#Figure_4">Figure 4</a></a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 8.838387896368511
RMS error: 0.0027504970625717136
<b>Percent error: 0.031119895334100794</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 3
<b>predictionDistance: 6</b>
signalScale: 12.5
noiseScale: 0.0
bpFilterLength: 1
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_4">Figure 4</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see in <a href="#Figure_4">Figure 4</a>, the prediction error was only 0.03-percent of the 
target.</p>
<p><font color="#FF0000"><b>The prediction distance</b></font></p>
<p>Also note in <a href="#Figure_4">Figure 4</a> that the <i>prediction distance</i> is six samples.&nbsp; 
In other words, the adaptive process was asked to design a convolution filter 
that can predict the value of a pure tone six samples into the future.</p>
<p><font color="#FF0000"><b>The adaptive filter length</b></font></p>
<p>Also note that the adaptive filter contained only three coefficients in this 
scenario.</p>
<p><b><font color="#FF0000">A somewhat pathological case</font></b></p>
<p>This is a case for which it is easy to develop a purely deterministic 
mathematical solution.&nbsp; All that is required is the solution of a set of 
simultaneous equations that will produce a convolution filter whose amplitude 
response is unity and whose phase response is a specified value at the frequency 
of the tone.</p>
<p>The case of a pure tone in the total absence of noise rarely occurs in the 
real world.&nbsp; Thus, the mathematical solution described above can produce 
undesirable results.&nbsp; While the amplitude response can be forced to unity 
at a particular frequency by solving the simultaneous equations, it is likely to be much larger than unity at other 
frequencies.&nbsp; If there is noise at those other frequencies, that noise will be 
amplified in the output of the adaptive filter.&nbsp; A much more realistic 
scenario is shown in <a href="#Figure_5">Figure 5</a> and <a href="#Figure_6">
Figure 6</a>.</p>
<p><font color="#FF0000"><b>A more realistic scenario</b></font></p>
<p><a href="#Figure_5">Figure 5</a> shows the results of applying the adaptive prediction process <i>
(with a three-coefficient prediction filter)</i> to a tone buried in white 
noise.&nbsp; The peak amplitude of the tone is ten times greater than the peak 
amplitude of the noise.&nbsp; <a href="#Figure_5">Figure 5</a> shows the same 
three pages that were shown for the pure tone <a name="Figure_5">in</a> <a href="#Figure_3">Figure 3</a>.</p>
<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362ac1.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ac2.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ac3.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_5">Figure 5</a></b></pre>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>The error is not zero</b></font></p>
<p>As you can see, the green error is not zero in <a href="#Figure_5">Figure 5</a>.&nbsp; In fact, the 
error never goes to zero.&nbsp; As shown in <a href="#Figure_6">Figure 6</a>, the prediction error is approximately ten percent 
of the <a name="Figure_6">target</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 8.866400709397215
RMS error: 0.9514570545236098
<b>Percent error: 10.731040539541494</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 3
predictionDistance: 6
signalScale: 12.5
noiseScale: 1.25
bpFilterLength: 1
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_6">Figure 6</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A mathematical solution</b></font></p>
<p>While there is a non-adaptive mathematical solution for this scenario, it is 
by no means a simple one and it is not deterministic.&nbsp; The solution involves computing a cross-correlation 
function between the signal plus noise and the target and then solving a matrix 
equation to compute the coefficient values for the prediction filter.</p>
<p><font color="#FF0000"><b>Probably better behaved</b></font></p>
<p>The frequency response of the adaptive filter developed for this 
scenario is probably better behaved than is the case for the pure tone shown in
<a href="#Figure_3">Figure 3</a>.&nbsp; It is unlikely that the 
<span lang="en-us"></span>amplitude response 
for this scenario will amplify the 
noise at frequencies other than the frequency of the tone, at least not in 
significant ways.&nbsp; <i>(This characteristic could be improved by using a 
longer adaptive filter.)</i></p>
<p><font color="#FF0000"><b>Increased prediction error</b></font></p>
<p>On the other hand, the prediction error for 
this scenario is significantly greater than the prediction error for the 
scenario involving the pure tone in the absence of noise.</p>
<blockquote>
	<p><i>(By the way, increasing the filter length for the scenario involving 
	the pure tone probably won't improve the final prediction error, but it 
	may cause 
	the adaptive process to converge to a solution more quickly.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Predictability of white noise</b></font></p>
<p>Now, let's take a look at the other extreme:&nbsp; white noise.</p>
<p><a href="#Figure_7">Figure 7</a> and <a href="#Figure_8">Figure 8</a> show the results of applying the 
adaptive prediction process to white noise produced by a random number 
<a name="Figure_7">generator</a>.</p>



<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362ad1.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ad2.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_7">Figure 7</a></b></pre>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>The time series output</b></font></p>
<p><a href="#Figure_7">Figure 7</a> shows the time-series output at the beginning of the adaptive 
process and at the end of 9890 adaptive iterations.</p>
<blockquote>
	<p><i>(The bottom panel of <a href="#Figure_7">Figure 7</a> shows the final 230 adaptive iterations 
	ending at iteration number 9890.)</i></p>
</blockquote>
<p>As you can see, the 
blue output from the adaptive filter in the bottom panel of <a href="#Figure_7">Figure 7</a> is very nearly 
zero, and the green error hasn't been reduced at all.&nbsp; The error trace is simply an 
upside-down version of the target trace.</p>
<p><font color="#FF0000"><b>The numeric prediction error</b></font></p>
<p><a name="Figure_8">Figure 8</a> shows the prediction error to be about 100 percent.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 7.195524462306129
RMS error: 7.225023010529711
<b>Percent error: 100.40995688887043</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 26
predictionDistance: 1
signalScale: 0.0
noiseScale: 12.5
bpFilterLength: 1
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_8">Figure 8</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Conclusion</b></font></p>
<p>The conclusion is that white noise is not predictable, even over a prediction 
distance of only one sample with an adaptive filter having 26 coefficients.</p>
<blockquote>
	<p><i>(If it were found to be predictable, that would indicate that the 
	random number generator used to produce the white noise doesn't really 
	produce random numbers after all.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Predictability of narrow-band noise</b></font></p>

<p>So far, we have seen experimental results for the following three scenarios:</p>
<ul>
	<li>A single-frequency tone.</li>
	<li>White noise.</li>
	<li>A single-frequency tone in white noise.</li>
</ul>
<p>On the basis of those experiments, we have concluded:</p>
<ul>
	<li>A single-frequency tone is totally predictable.</li>
	<li>White noise is totally unpredictable.</li>
	<li>A single-frequency tone in white noise is partially predictable, with 
	the quality of the prediction being a function of the signal-to-noise ratio.</li>
</ul>
<p>These scenarios represented the extremes.&nbsp; Now let's look at some 
in-between scenarios involving narrow-band time series for which the bandwidth 
is greater than a single frequency.&nbsp; We will begin with a scenario where 
the bandwidth has been reduced to that shown in the right panel of 
<a name="Figure_9"><a href="#Figure_9">Figure 9</a></a>.</p>



<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td><img border="0" src="java2362ae1.jpg" width="113" height="149"></td>
		<td><img border="0" src="java2362ae2.jpg" width="265" height="149"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_9">Figure 9</a></b></b></pre></td>
	</tr>
</table>
<p><font color="#FF0000"><b>The display format</b></font></p>
<p>The curve in the left panel of <a href="#Figure_9">Figure 9</a> shows a convolution filter having two 
coefficients.</p>
<p>The top curve in the right panel shows the amplitude 
response of that convolution filter computed and displayed from a frequency of 
zero to the Nyquist folding frequency.&nbsp; The bottom curve in the right panel 
shows the phase response of the convolution filter.</p>
<p><font color="#FF0000"><b>Apply band pass filter to white noise</b></font></p>
<p>This convolution filter was applied to the white noise, producing an output 
time series having approximately one-half the bandwidth of the white 
noise.</p>
<blockquote>
	<p><i>(Note that there are several different ways to measure bandwidth.&nbsp; 
	This estimate is based on the width of the lobe between the three-db down 
	points in the amplitude response.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The time series data</b></font></p>
<p>The adaptive prediction process was applied to this time series in an attempt 
to predict the value of the time series with a prediction distance of one sample 
and an adaptive filter length of 26 coefficients.&nbsp; The results are shown in
<a name="Figure_10"><a href="#Figure_10">Figure 10</a></a> and <a href="#Figure_11">Figure 11</a>.</p>



<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362ae3.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ae4.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_10">Figure 10</a></b></pre>
		</td>
	</tr>
</table>
<p>The top panel in <a href="#Figure_10">Figure 10</a> shows the time series at the beginning of the run.&nbsp; 
The bottom panel shows the time series ending at adaptive iteration number 9890.&nbsp; As 
you can see in the bottom panel of <a href="#Figure_9">Figure 9</a>, the blue output trace from the 
adaptive filter does look something like the red target trace.&nbsp; The green 
error trace in the bottom panel is smaller than the green output trace at the 
beginning of the run in the top panel.</p>
<p><font color="#FF0000"><b>The numeric prediction error</b></font></p>
<p>As shown in <a href="#Figure_11">Figure 11</a>, the prediction error was reduced from 100 percent for white noise to 
about 82 percent for this scenario.&nbsp; Reducing the bandwidth of 
the white noise caused the time series to become partially <a name="Figure_11">predictable</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 8.889476886391076
RMS error: 7.3078201913053915
<b>Percent error: 82.20753914657176</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 26
predictionDistance: 1
signalScale: 0.0
noiseScale: 12.5
bpFilterLength: 2
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_11">Figure 11</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Bandwidth at one-sixteenth of white noise</b></font></p>

<p><a href="#Figure_12">Figure 12</a>, <a href="#Figure_13">Figure 13</a>, and <a href="#Figure_14">Figure 14</a> show the results of applying 
the adaptive prediction process to a time series having a bandwidth 
approximately equal to one-sixteenth of the bandwidth of the white noise 
<a name="Figure_12">shown</a> 
in <a href="#Figure_7">Figure 7</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td><img border="0" src="java2362af1.jpg" width="113" height="149"></td>
		<td><img border="0" src="java2362af2.jpg" width="265" height="149"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_12">Figure 12</a></b></pre></td>
	</tr>
</table>
<p>The left panel in <a href="#Figure_12">Figure 12</a> shows the impulse response of a convolution 
filter having sixteen coefficients in the form of a truncated sinusoid.&nbsp; 
The right panel in <a href="#Figure_12">Figure 12</a> shows the frequency response of the convolution 
filter computed and displayed from a frequency of zero to the Nyquist folding 
frequency.&nbsp; The bandwidth of the filter is approximately one-sixteenth of the 
bandwidth of the white noise shown in <a href="#Figure_7">Figure 7</a> when 
measured at the three-db down points.</p>
<p><font color="#FF0000"><b>Apply the band pass filter</b></font></p>
<p>The filter shown in <a href="#Figure_12">Figure 12</a> was applied to the white noise producing the 
time series shown in the top trace in each panel of <a name="Figure_13">
<a href="#Figure_13">Figure 13</a></a>.</p>



<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362af3.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362af4.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_13">Figure 13</a></b></pre>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>The time series output</b></font></p>
<p>This time series was subjected to the adaptive prediction process with a 
prediction distance of one sample and an adaptive filter length of 26 
coefficients, producing the results shown in <a href="#Figure_13">Figure 13</a> and
<a href="#Figure_14">Figure 14</a>.</p>
<p>The top panel in <a href="#Figure_13">Figure 13</a> shows the time series at the beginning of the run.&nbsp; 
The bottom panel shows the time series at the end of 9890 adaptive iterations.&nbsp; As you can 
see, the blue output trace from the prediction filter is a reasonably good 
representation of the red target trace in the bottom panel of <a href="#Figure_13">Figure 13</a>.&nbsp; Also, the 
green error trace in the bottom panel is much smaller than the green error trace 
at the beginning of the run in the top panel.</p>
<p><font color="#FF0000"><b>The numeric prediction error</b></font></p>
<p>In fact, this reduction in bandwidth caused the prediction error to be 
reduced to about forty-six percent as shown in <a name="Figure_14"><a href="#Figure_14">Figure 14</a></a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 7.490714340573816
RMS error: 3.479276931459588
<b>Percent error: 46.447865627633355</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 26
predictionDistance: 1
signalScale: 0.0
noiseScale: 37.5
bpFilterLength: 16
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_14">Figure 14</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Predictability of a very narrow-band time series</b></font></p>
<p>Let's examine one more set of experimental results.&nbsp; These are the 
results produced by the default program parameters that are used if the user 
doesn't provide the appropriate number of command-line parameters.</p>
<p>For this experiment, we will reduce the bandwidth to approximately 1/128 of 
the bandwidth of the white noise shown in <a href="#Figure_7">Figure 7</a>.</p>
<p><font color="#FF0000"><b>The band pass filter</b></font></p>
<p><a name="Figure_15"><a href="#Figure_15">Figure 15</a></a> shows the convolution filter having 128 
coefficients.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2362ag1.jpg" width="265" height="149"><br></pre>
      <pre><b><a href="#Figure_15">Figure 15</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Figure_16">Figure 16</a> shows the frequency response of the 
convolution filter, computed and displayed from a frequency of zero to the 
Nyquist folding <a name="Figure_16">frequency</a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2362ag2.jpg" width="265" height="149"><br></pre>
      <pre><b><a href="#Figure_16">Figure 16</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Apply the band pass filter</b></font></p>
<p>As you can see, the bandwidth of this filter is quite narrow, as compared to
<a href="#Figure_12">Figure 12</a>, for example.&nbsp; This filter was applied 
to white noise, producing the top <i>(black)</i> trace in both panels of
<a name="Figure_17"><a href="#Figure_17">Figure 17</a></a>.</p><p>



<table bgcolor="#ccffff" border="1" cols="1">
	<tr>
		<td><img border="0" src="java2362ag3.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td><img border="0" src="java2362ag4.jpg" width="469" height="149"></td>
	</tr>
	<tr>
		<td>
		<pre><b><a href="#Figure_17">Figure 17</a></b></pre>
		</td>
	</tr>
</table>
<p>As before, the top panel in <a href="#Figure_17">Figure 17</a> shows the time series at the beginning 
of the run.&nbsp; The bottom panel shows the time series at the end of 9890 
adaptive iterations.&nbsp; The output from the adaptive filter <i>(blue)</i> is 
a good replica of the target <i>(red)</i>.&nbsp; Thus, the green error trace is 
quite small.</p>
<p><font color="#FF0000"><b>The numeric prediction error</b></font></p>
<p><a href="#Figure_18">Figure 18</a> shows that this reduction in bandwidth 
resulted in a reduction in the prediction error to about 23 <a name="Figure_18">percent</a>.</p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>RMS target: 6.482512172567318
RMS error: 1.4847104556284205
<b>Percent error: 22.903319208738477</b>

feedbackGain: 1.0E-5
numberAdaptiveIterations: 9890
adaptiveFilterLength: 26
predictionDistance: 1
signalScale: 0.0
noiseScale: 87.5
bpFilterLength: 128
rmsAveragingLength: 9890<br></pre>
      <pre><b><a href="#Figure_18">Figure 18</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b><a name="An_exercise_for_the_student">An exercise for the student</a></b></font></p>
<p>This is the longest convolution filter <i>(128 coefficients)</i> that is 
supported by the program in its current state.&nbsp; However, this limitation 
has nothing to do with the process of applying the filter to the noise.&nbsp; 
Rather, it has to do with the method named <b>displayFreqResponse</b> that is 
used to compute and display the frequency response of the filter.&nbsp; As an
<a name="exercise">exercise</a>, you may find it interesting to eliminate that 
limitation and observe how the prediction error behaves as you use longer and 
longer convolution filters <i>(narrower and narrower bandwidth)</i>.</p>
<p>Probably the easiest way to eliminate the limitation of 128 filter 
coefficients would be to disable the call to the method named <b>
displayFreqResponse </b>and simply forego the computation and display of the 
frequency response.&nbsp; By now, you should have a pretty good idea how the 
frequency response behaves as you increase the length of the convolution filter 
anyway.</p>
<blockquote>
	<p><i>(In addition, you will need to disable the code that limits the filter 
	length to 128 when you enter a command-line parameter greater than 128.)</i></p>
</blockquote>
<p>That's it for experimental results.&nbsp; I recommend that you do some 
experimentation on your own to gain a better understanding as to how the 
predictability behaves with respect to the various program parameters.</p>
<p>Now let's see some code. </p>

<h2 align="center"> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>

<p><font color="#FF0000"><b>The class named Adapt09</b></font></p>
<p>The class named Adapt09 is presented in its entirety in <a href="#Listing_14">Listing 14</a> near the 
end of the lesson.</p>
<p>I will discuss the program in fragments.&nbsp; The beginning of the class named <b>Adapt09</b> and the beginning of the <b>
main</b> method are shown in <a name="Listing_1"><a href="#Listing_1">Listing 1</a></a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Adapt09{
  public static void main(String[] args){
    //Default parameter values
    double feedbackGain = 0.00001;
    int numberAdaptiveIterations = 9890;//fixed value
    int adaptiveFilterLength = 26;
    int predictionDistance = 1;
    
    double signalScale = 0;
    double noiseScale = 87.5;
    int bpFilterLength = 128;//Must be &lt;= 128.
    
    int rmsAveragingLength = 9890;//fixed value
    
    if(args.length == 6){
      //Get and save command-line parameters.
      feedbackGain = Double.parseDouble(args[0]);
      adaptiveFilterLength = Integer.parseInt(args[1]);
      predictionDistance = Integer.parseInt(args[2]);
      signalScale = Double.parseDouble(args[3]);
      noiseScale = Double.parseDouble(args[4]);
      bpFilterLength = Integer.parseInt(args[5]);
      if(bpFilterLength &gt; 128){
        //Make sure this value is not greater than 128.
        bpFilterLength = 128;
        System.out.println(
                          "bpFilterLength must be &lt;= 128");
        System.out.println("Using bpFilterLength = 128");
      }//end if
    }else{
      System.out.println(
                      "Using default program parameters.");
    }//end else<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>All of the code in <a href="#Listing_1">Listing 1</a> is straightforward and shouldn't require 
explanation beyond the comments embedded in the code.</p>
<p><font color="#FF0000"><b>Create the band pass filter</b></font></p>
<p>The code in <a href="#Listing_2">Listing 2</a>:</p>
<ul>
	<li>Creates an array object suitable for storing the band pass filter.</li>
	<li>Creates an object of the <b>Adapt09</b> class, making it possible to call a 
	method of that class to get the convolution filter coefficients for the 
	band pass filter.</li>
	<li>Iteratively invokes the method named <b>getCosine</b> to get the filter 
	coefficients and store them in the array mentioned <a name="Listing_2">above</a>.</li>
</ul>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Create an array object to store the bandpass filter
    // coefficients.
    double[] bpFilterOperator = new double[bpFilterLength];
       
    //Instantiate a new object of the <span lang="en-us"></span>Adapt09 class.
    Adapt09 thisObject = new Adapt09();
    
    //Prepare the bandpass filter,which is a truncated
    // sinusoid with a frequency of one-eighth of the
    // sampling frequency.
    for(int cnt = 0;cnt &lt; bpFilterLength;cnt++){
      bpFilterOperator[cnt] = thisObject.getCosine(cnt);
    }//end for loop<br><br><b><font face="Courier New,Courier"><a href="#Listing_2">Listing 2</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The getCosine method</b></font></p>
<p>For every scenario, the band pass filter is simply a truncated cosine function 
with a frequency that is one-eighth of the sampling frequency.&nbsp; Thus, the 
coefficient values repeat with eight coefficient values occurring during each 
cycle of the cosine function.</p>
<p>The source code for the <b>getCosine</b> method is shown in <a href="#Listing_14">Listing 14</a> near 
the end of the lesson.&nbsp; That code is straightforward and shouldn't require 
further explanation.</p>
<p><font color="#FF0000"><b>The remainder of the main method</b></font></p>
<p>The remainder of the <b>main</b> method is shown in <a name="Listing_3"><a href="#Listing_3">Listing 3</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Invoke the method named process.
    thisObject.<b>process</b>(feedbackGain,
                       numberAdaptiveIterations,
                       rmsAveragingLength,
                       adaptiveFilterLength,
                       signalScale,
                       noiseScale,
                       bpFilterOperator,
                       predictionDistance);

    //Display program parameters at the end of the run.
    System.out.println("\nfeedbackGain: " + feedbackGain);
    System.out.println("numberAdaptiveIterations: " 
                               + numberAdaptiveIterations);
    System.out.println("adaptiveFilterLength: " 
                                   + adaptiveFilterLength);
    System.out.println("predictionDistance: " 
                                     + predictionDistance);
    System.out.println("signalScale: " + signalScale);
    System.out.println("noiseScale: " + noiseScale);
    System.out.println("bpFilterLength: " 
                                         + bpFilterLength);
    System.out.println("rmsAveragingLength: " 
                                     + rmsAveragingLength);

  }//end main<br><br><b><font face="Courier New,Courier"><a href="#Listing_3">Listing 3</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_3">Listing 3</a> invokes the <b>process</b> method of the <b>Adapt09</b> 
class, where all the hard work is done.&nbsp; When the <b>process</b> method 
returns, the code in <a href="#Listing_3">Listing 3</a> displays some summary information <i>(see
<a href="#Figure_18">Figure 18</a> for example)</i> and terminates the program.</p>
<p><font color="#FF0000"><b>The process method</b></font></p>
<p><a name="Listing_4"><a href="#Listing_4">Listing 4</a></a> shows the beginning of the <b>process</b> method.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>process</b>(double feedbackGain,
               int numberAdaptiveIterations,
               int rmsAveragingLength,
               int adaptiveFilterLength,
               double signalScale,
               double noiseScale,
               double[] bpFilterOperator,
               int predictionDistance){

    //Display the bandpassFilterOperator
    //First instantiate a plotting object.
    PlotALot01 bpFilterPlotObj = new PlotALot01(
           "Noise Filter Operator",
           (bpFilterOperator.length * 2) + 8,148,70,2,0,0);

    //Feed the data to the plotting object.
    for(int cnt = 0;cnt &lt; bpFilterOperator.length;cnt++){
      bpFilterPlotObj.feedData(40*bpFilterOperator[cnt]);
    }//end for loop
    
    //Cause the graph to be displayed on the computer
    // screen in the upper left corner.
    bpFilterPlotObj.plotData(0,0);
    
    //Now compute and plot the frequency response of the
    // bandpass filter.
    
    //Instantiate a plotting object for two channels of
    // frequency response data.  One channel is for
    // the amplitude and the other channel is for the
    // phase.
    PlotALot03 bpFilterFreqPlotObj = new PlotALot03(
            "Noise Filter Freq Response",264,148,35,2,0,0);
                   
    //Compute the frequency response and feed the results
    // to the plotting object.
    displayFreqResponse(
               bpFilterOperator,bpFilterFreqPlotObj,128,0);
                       
    //Cause the frequency response data stored in the
    // plotting object to be displayed on the screen in
    // the middle position.
    bpFilterFreqPlotObj.plotData(0,148);<br><br><b><font face="Courier New,Courier"><a href="#Listing_4">Listing 4</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>All of the code in <a href="#Listing_4">Listing 4</a> is the same as, or very similar to code that has 
been previously explained in lessons referred to in the <a href="#References">
References</a> section of this lesson.&nbsp; Therefore, it shouldn't be 
necessary to provide further explanation of that code beyond the comments 
contained in <a href="#Listing_4">Listing 4</a>.</p>
<p><font color="#FF0000"><b>Two delay lines</b></font></p>
<p><a href="#Listing_5">Listing 5</a> instantiates an array object that will be used as a delay line for 
the signal plus white noise data in order to convolve the samples with the 
band pass filter <a name="Listing_5">later</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    double[] whiteNoiseDelayLine = 
                       new double[bpFilterOperator.length];<br><br><b><font face="Courier New,Courier"><a href="#Listing_5">Listing 5</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the length of the delay line is determined by the length of the 
array created earlier and referred to by the reference variable named <b>
bpFilterOperator</b>.&nbsp; In other words, the length of the delay line matches 
the length of the convolution operator used to implement the band pass filter.&nbsp; 
The length of the convolution filter is a user input parameter.</p>
<p><a href="#Listing_6">Listing 6</a> instantiates an array object that will be used as a delay line for 
the filtered signal plus noise data.&nbsp; This delay line is used to obtain a 
target sample that is advanced in time relative to the data that is used to predict the 
target.&nbsp; The target sample is advanced in time by a number of samples equal 
to <b><a name="Listing_6">predictionDistance</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    double[] signalPlusNoiseDelayLine = 
                        new double[predictionDistance + 1];<br><br><b><font face="Courier New,Courier"><a href="#Listing_6">Listing 6</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The delay line created in <a href="#Listing_6">Listing 6</a> corresponds to the box labeled <b>Delay</b> 
in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>. </p>
<p><font color="#FF0000"><b>A plotting object and working variables</b></font></p>
<p><a href="#Listing_7">Listing 7</a> instantiates a plotting object that will be used to plot the four 
channels of time-series data shown in <a href="#Figure_3">Figure 3</a>.&nbsp; 
This code is similar to code that was explained in previous lessons referred to 
in the <a href="#References">References</a> section of this <a name="Listing_7">lesson</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Instantiate a plotting object for four channels of
    // time-series data at 230 samples per page.
    int sampPerPage = 230;
    PlotALot05 timePlotObj = new PlotALot05(
                         "Time-Domain Adaptive Data",
                         (2*sampPerPage + 8),148,25,2,0,0);

    //Declare and initialize working variables.
    double output = 0;
    double err = 0;
    double target = 0;
    double input = 0;
    double signal = 0;
    double whiteNoise = 0;
    boolean adaptOn;
    double targetSumSq = 0;
    double errSumSq = 0;<br><br><b><font face="Courier New,Courier"><a href="#Listing_7">Listing 7</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_7">Listing 7</a> also declares and initializes some working variables.</p>
<p>None of the code in <a href="#Listing_7">Listing 7</a> should require further explanation.</p>
<p><font color="#FF0000"><b>An adaptive engine object</b></font></p>
<p><a href="#Listing_8">Listing 8</a> instantiates an object of the class named <b>AdaptEngine02</b> to 
handle the adaptive behavior of this program.&nbsp; This class was explained 
earlier in the lesson entitled
<a href="http://www.developer.com/java/other/article.php/3583241">Adaptive Identification and Inverse 
Filtering using Java</a>.&nbsp; That explanation won't be repeated 
<a name="Listing_8">here</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
    AdaptEngine02 adapter = new AdaptEngine02(
                        adaptiveFilterLength,feedbackGain);<br><br><b><font face="Courier New,Courier"><a href="#Listing_8">Listing 8</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The object of the <b>AdaptEngine02</b> class represents the shaded portion of 
the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.</p>
<p><font color="#FF0000"><b>Perform adaptive iterations</b></font></p>
<p><a href="#Listing_9">Listing 9</a> contain the beginning of a <b>for</b> loop that is used to perform 
the required number of iterations.&nbsp; The required number of iterations is 
the sum of the specified number of adaptive iterations plus the non-adaptive 
iterations that are used to compute the percent error after the adaptive update 
process is <a name="Listing_9">disabled</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt = 0;
       cnt &lt; numberAdaptiveIterations + rmsAveragingLength;
                                                    cnt++){<br><br><b><font face="Courier New,Courier"><a href="#Listing_9">Listing 9</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Routine processing steps</b></font></p>
<p><a href="#Listing_10">Listing 10</a> performs a number of routine processing steps.&nbsp; These steps 
are either completely straightforward, or are very similar to code that has been 
explained in previous lessons, which are referred to in the
<a href="#References">References</a> section of this lesson.&nbsp; Therefore, no 
explanation beyond the embedded comments will be provided in this 
<a name="Listing_10">lesson</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //The following variable is used to control whether
      // or not the adapt method of the adaptive engine
      // updates the filter coefficients when it is called.
      // The filters are updated when this variable is
      // true and are not updated when this variable is
      // false.
      adaptOn = true;
      
      //Get and scale the next sample of white noise data
      // from a random number generator. Before scaling by
      // noiseScale, the values are uniformly distributed
      // from -1.0 to 1.0.
      whiteNoise = noiseScale*(2*(random() - 0.5));
      
      //Get and scale the next sample of signal.  The
      // signal is a pure tone with a frequency equal to
      // one-eighth of the sampling frequency.  Before
      // scaling by signalScale, the peak-to-peak value
      // is 2.
      signal = signalScale * getCosine(cnt);
      
      //Insert the signal plus white noise data into the
      // delay line that will be used to convolve the 
      // signal plus white noise data with the bandpass
      // filter.
      double signalPlusNoise = whiteNoise + signal;
      flowLine(whiteNoiseDelayLine,signalPlusNoise);
      
      //Declare a variable to receive the filtered signal
      // plus noise sample.
      double filteredSignalPlusNoise = 0;
    
      //Apply the bandpass filter operator to the signal
      // plus white noise data.  If the filter length is 1,
      // bypass the filtering operation and use the raw
      // signal plus white noise.
      if(bpFilterOperator.length == 1){
        filteredSignalPlusNoise = signalPlusNoise;
      }else{
        filteredSignalPlusNoise = reverseDotProduct(
           whiteNoiseDelayLine,
           bpFilterOperator)/(bpFilterOperator.length/2.0);
      }//end else
                   
      //Insert the filtered signal plus noise into the
      // delay line that is used to obtain a time-advanced
      // sample of the target.
      flowLine(
         signalPlusNoiseDelayLine,filteredSignalPlusNoise);

      //Declare a variable that will be populated with the
      // results returned by the adapt method of the
      // adaptive engine.
      AdaptiveResult result = null;
      
      //Disable adaptive updates when the specified number
      // of adaptive iterations has been performed.
      if(cnt &gt; numberAdaptiveIterations){
        adaptOn = false;
      }//end if<br><br><b><font face="Courier New,Courier"><a href="#Listing_10">Listing 10</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Perform the adaptive processing</b></font></p>
<p>The most important code in this class is contained in <a href="#Listing_11">Listing 11</a>.&nbsp; This 
code establishes the appropriate input values and invokes the <b>adapt</b> 
method of the <b>AdaptEngine02</b> object to perform the adaptive updates to the adaptive filter 
<a name="Listing_11">coefficients</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      input = signalPlusNoiseDelayLine[<b>0</b>];//historical samp
      target = 
              signalPlusNoiseDelayLine[<b>predictionDistance</b>];
      result = adapter.adapt(input,target,adaptOn);<br><br><b><font face="Courier New,Courier"><a href="#Listing_11">Listing 11</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Just to get our bearings, <b>input</b> in <a href="#Listing_11">Listing 11</a> corresponds to
<b>x(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.&nbsp; Similarly, <b>target</b> in <a href="#Listing_11">Listing 11</a> corresponds to
<b>d(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.</p>
<p>The oldest data in the delay line referred to by <b>signalPlusNoiseDelayLine</b> 
in <a href="#Listing_11">Listing 11</a> is the data value at index 0.</p>
<p>The newest data in the delay line is the data value at an index value of <b>
predictionDistance</b>.&nbsp; <i>(The length of the delay line is <b>
predictionDistance + 1</b>.)</i></p>
<p>Thus, the oldest value in the delay line is fed into the adaptive filter as
<b>x(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.&nbsp; The newest value in the delay line is used to compute 
the prediction error as shown by <b>d(k)</b> in the
<a href="http://www.mathworks.com/access/helpdesk/help/toolbox/filterdesign/adaptiv8.html#5576">
block diagram</a>.&nbsp; As a result, the LMS algorithm attempts to develop an 
adaptive convolution filter that will act on the incoming time series to predict 
the value of a sample that is <b>predictionDistance</b> samples in the future.</p>
<p><font color="#FF0000"><b>Complete the for loop</b></font></p>
<p><a href="#Listing_12">Listing 12</a> completes the <b>for</b> loop that controls the required number of 
<a name="Listing_12">iterations</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Get and save adaptive results.
      output = result.output;
      err = result.err;
      
      //Compute values that will be used later to compute
      // the percent error.  This computation is performed
      // only after adaptive updates have been disabled.
      if(!adaptOn){
        //Accumulate the sum of the squares of the target
        // and error values.
        targetSumSq += target * target;
        errSumSq += err * err;
      }//end if
    
      //Feed the time series data to the plotting object.
      // Plot only two pages of data after adaptive updates
      // are disabled.
      if(cnt &lt;= numberAdaptiveIterations + 2*sampPerPage){
        timePlotObj.feedData(input,target,output,err);
      }//end if

    }//End for loop on required number of iterations.<br><br><b><font face="Courier New,Courier"><a href="#Listing_12">Listing 12</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_12">Listing 12</a> is straightforward and shouldn't require an 
explanation beyond the embedded comments.</p>
<p><font color="#FF0000"><b>Complete the adapt method</b></font></p>
<p><a href="#Listing_13">Listing 13</a> shows the remaining code in the <b>adapt</b> method of the <b>
AdaptEngine02</b> <a name="Listing_13">object</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Compute and display the mean square values
    double rmsTarget = 
                      sqrt(targetSumSq/rmsAveragingLength);
    double rmsError = sqrt(errSumSq/rmsAveragingLength);
    System.out.println("\nRMS target: " + rmsTarget);
    System.out.println("RMS error: " + rmsError);
    System.out.println(
         "Percent error: " + 100.0*(rmsError)/(rmsTarget));
    
    //Cause the data stored in the plotting object to be
    // plotted.
    timePlotObj.plotData(0,296);

  }//end process method<br><br><b><font face="Courier New,Courier"><a href="#Listing_13">Listing 13</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This code is straightforward and shouldn't require further explanation.</p>
<h2 align="center"><a name="Run the program"></a>Run the Program</h2>

<p>I encourage you to copy the code for the class named <b>Adapt09</b> from the section entitled
<a href="#Complete Program Listings">Complete Program Listings</a>.&nbsp; 
Compile and execute the program.&nbsp; Experiment with the code.&nbsp; Make changes to the code, recompile, execute, 
and observe the results of your changes.</p>
<p>Modify the following program parameters and observe the results of your 
changes.&nbsp; See if you can explain the results of your changes.</p>
<ul>
	<li>feedbackGain</li>
	<li>adaptiveFilterLength</li>
	<li>predictionDistance</li>
	<li>signalScale</li>
	<li>noiseScale</li>
	<li>bandpassFilterLength</li>
</ul>
<p>For example, what happens if you use a large value for <b>feedbackGain</b>?&nbsp; 
What happens if you use a very small value for <b>feedbackGain</b>?&nbsp; What 
happens if you use a negative value for <b>feedbackGain</b>?&nbsp; Can you 
explain the results that you experience?</p>
<p>What happens if you use a large value for <b>predictionDistance</b>?</p>
<p>In particular I encourage you to make the changes suggested in the section 
entitled <a href="#An_exercise_for_the_student">An exercise for the student</a> 
and evaluate the results of those changes.</p>
<p><font color="#FF0000"><b>Other classes required</b></font></p>
<p>In addition to the class named <b>Adapt09</b>, you will need access to the 
following classes.&nbsp; The source code for these classes can be found in the 
lessons indicated.</p>
<ul>
	<li>AdaptEngine02:&nbsp;
	<a href="http://www.developer.com/java/other/article.php/3583241">Adaptive Identification and Inverse 
	Filtering using Java</a></li>
	<li>AdaptiveResult:&nbsp;
	<a href="http://www.developer.com/java/other/article.php/3583241">Adaptive Identification and Inverse 
	Filtering using Java</a></li>
	<li>ForwardRealToComplex01:&nbsp;
	<a href="http://www.developer.com/java/other/article.php/3380031">Spectrum 
	Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
	Algorithm</a></li>
	<li>PlotALot01:&nbsp;
	<a href="http://www.developer.com/java/data/article.php/3529186">Plotting 
	Large Quantities of Data using Java</a></li>
	<li>PlotALot03:&nbsp;
	<a href="http://www.developer.com/java/data/article.php/3529186">Plotting 
	Large Quantities of Data using Java</a></li>
	<li>PlotALot05:&nbsp;
	<a href="http://www.developer.com/java/other/article.php/3549991">Adaptive 
	Filtering in Java, Getting Started</a> </li>
</ul>
<h2 align="center" ><a name="Summary">Summary</a></h2>
<p>In this lesson, I showed you how to use a Java adaptive filter to predict 
future values in a time series.&nbsp; I also introduced you to the 
relationship between the properties of the time series and the quality of the 
prediction.</p>
<h2 align="center"><a name="References">References</a></h2>
<p>In preparation for understanding the material in this lesson, I recommend 
that you study the material in the following previously-published lessons:</p>
<ul>
	<li><a href="http://www.dickbaldwin.com/dsp/Dsp00100.htm">100</a>&nbsp;&nbsp; Periodic 
	Motion and Sinusoids</li>
	<li><a href="http://www.dickbaldwin.com/dsp/Dsp00104.htm">104</a>&nbsp;&nbsp; Sampled 
	Time Series</li>
	<li><a href="http://www.dickbaldwin.com/dsp/Dsp00108.htm">108</a>&nbsp;&nbsp; 
	Averaging Time Series</li>
	<li><a href="http://www.developer.com/java/other/article.php/3374611">1478</a> 
	Fun with Java, How and Why Spectral Analysis Works</li>
	<li><a href="http://www.developer.com/java/other/article.php/3380031">1482</a> 
	Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the 
	FFT Algorithm</li>
	<li><a href="http://www.developer.com/java/other/article.php/3392871">1483</a> 
	Spectrum Analysis using Java, Frequency Resolution versus Data Length</li>
	<li><a href="http://www.developer.com/java/other/article.php/3411041">1484</a> 
	Spectrum Analysis using Java, Complex Spectrum and Phase Angle</li>
	<li><a href="http://www.developer.com/java/other/article.php/3436341">1485</a> 
	Spectrum Analysis using Java, Forward and Inverse Transforms, Filtering in 
	the Frequency Domain</li>
	<li><a href="http://www.developer.com/java/other/article.php/3484591">1487</a> 
	Convolution and Frequency Filtering in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3487996">1488</a> 
	Convolution and Matched Filtering in Java</li>
	<li><a href="http://www.developer.com/java/data/article.php/3529186">1492</a> 
	Plotting Large Quantities of Data using Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3549991">2350</a> 
	Adaptive Filtering in Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3560501">2352</a> 
	An Adaptive Whitening Filter in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3566951">2354</a> 
	A General-Purpose LMS Adaptive Engine in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3576061">2356</a> An Adaptive Line Tracker in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3583241">2358</a> Adaptive Identification and Inverse Filtering using Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3599661">2360</a> Adaptive Noise Cancellation using Java</li>
</ul>

<h2 align="center"> <a name="Complete Program Listings"></a>Complete Program Listings</h2>

<p>A complete listings of the class discussed in this lesson is shown in Listing 
14 <a name="Listing_14">below</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Adapt09.java
Copyright 2005, R.G.Baldwin

The purpose of this program is to illustrate an adaptive 
prediction system.  The user can experiment with adaptive 
prediction by making changes to the following parameters 
and observing printed and graphic results:

feedbackGain
adaptiveFilterLength
predictionDistance
signalScale
noiseScale
bandpassFilterLength (and hence bandwidth)

See the following URL for a brief description and a block 
diagram of an adaptive prediction system.

http://www.mathworks.com/access/helpdesk/help/toolbox/
filterdesign/adaptiv8.html#5576

This program requires the following classes:
Adapt09.class
AdaptEngine02.class
AdaptiveResult.class
ForwardRealToComplex01.class
PlotALot01.class
PlotALot03.class
PlotALot05.class

This program uses the adaptive engine named AdaptEngine02 
to adaptively develop a convolution prediction filter.  One
of the inputs to the adaptive engine is the current sample 
of the sum of signal plus noise. This is the target of the 
prediction process.  The other input to the adaptive engine
is an historical sample of signal plus noise.

The adaptive engine develops a convolution filter that 
attempts to use historical signal plus noise samples to 
predict the value of the current sample of signal plus 
noise (target).  Thus, the program attempts to adaptively 
develop a convolution filter that can operate on a time 
series to predict a future value of the time series. The 
distance in time to the future value is a user input 
parameter.

The program performs 9890 iterations during which the 
convolution filter coefficients are adaptively updated.
Then the adaptive update process is disabled.  The program 
then performs 9890 more iterations during which the
quality of the prediction is measured and reported.

The quality of the prediction is measured by:
1.  Computing the RMS value of the target averaged over 
9890 samples.
2.  Computing the RMS value of the prediction error 
averaged over 9890 samples.
3.  Computing the percentage of the RMS target value 
represented by the RMS error.

The signal consists of a pure tone at a frequency that is 
one eighth of the sampling frequency (eight samples per 
cycle).  The peak-to-peak value of the signal prior to 
scaling is 2.

The noise consists of white noise produced by a random 
number generator with a uniform distribution between
-1.0 and 1.0 prior to scaling.

The scaled signal is added to the scaled white noise.  

The sum of signal plus white noise can be passed through a 
bandpass filter with a center frequency equal to one-
eighth of the sampling frequency.  The center frequency of
the bandpass filter is the same as the frequency of the 
signal.

Thus, the signal plus noise consists of a pure tone 
surrounded by noise for which the noise bandwidth can be 
controlled by the user.  The frequency band for the noise 
is centered on the signal frequency.  The user controls the
signal level and the noise level, and hence the 
signal-to-noise ratio.

The bandpass filter consists of a convolution filter in the
form of a truncated sinusoid with a frequency of one-eighth
of the sampling frequency.  The user specifies the length 
of the convolution filter, (up to a limit of 128 
coefficients), thereby specifying the bandwidth which is 
roughly proportional to the reciprocal of the length of the
convolution filter.  The shape of the amplitude response of
the pass band for the filter is roughly that of 
a sin(x)/x function.

The program produces three graphs in a vertical stack on 
the screen.  The graphs display the following information 
in order from top to bottom:

1.  The bandpass convolution filter used to filter the raw
signal plus noise.
2.  The frequency response of the bandpass filter used to 
filter the raw signal plus noise.
3.  Four traces of adaptive time-series data. 

Graph 3 consists of multiple pages stacked on top of one 
another.  You must move the pages on the top of the stack 
to view the pages further down.  The pages on the top of 
the stack represent the results produced early in the 
adaptive process while those further down represent the 
results produced later in the adaptive process.

The four time series that are plotted are, from top to
bottom in the colors indicated:
1.  (Black) The historical signal plus noise input to the 
adaptive prediction filter.
2.  (Red) The signal plus noise target for the adaptive 
prediction filter.
3.  (Blue) The output from the adaptive prediction filter.
4.  (Green) The error, which is the difference between the 
red target and the blue output from the adaptive
prediction filter.  Ideally, this trace approaches zero as 
the process converges to a solution.

User input is provided by way of command-line parameters.
If no command-line parameters are provided, default values 
are used for the program parameters.  The command-line 
parameters in order are:

1.  double feedbackGain:  The gain used in the adaptive 
feedback loop.  The default value is 0.00001.
2.  int adaptiveFilterLength:  The default value is 26.
3.  int predictionDistance:  The distance in the future, 
(measured in samples), that the adaptive process attempts
to predict the value of signal plus noise (target).  The 
default value is 1 sample.
4.  double signalScale:  The default value is 0.  Adjust
this and the following parameter to adjust the signal to
noise ratio, and also to cause the time-series plots to be 
in good plotting range.
5.  double noiseScale:  The default value is 87.5.
6.  int bandpassFilterLength:  The length of the 
convolution filter that is applied to the raw signal plus 
noise.  This value must be less than or equal to 128.  If
it is greater than 128, it is automatically set to 128.

Tested using J2SE 5.0 and WinXP.  J2SE 5.0 or later is 
required.
**********************************************************/
import static java.lang.Math.*;//J2SE 5.0 req

class Adapt09{
  public static void main(String[] args){
    //Default parameter values
    double feedbackGain = 0.00001;
    int numberAdaptiveIterations = 9890;//fixed value
    int adaptiveFilterLength = 26;
    int predictionDistance = 1;
    
    double signalScale = 0;
    double noiseScale = 87.5;
    int bpFilterLength = 128;//Must be &lt;= 128.
    
    int rmsAveragingLength = 9890;//fixed value
    
    if(args.length == 6){
      //Get and save command-line parameters.
      feedbackGain = Double.parseDouble(args[0]);
      adaptiveFilterLength = Integer.parseInt(args[1]);
      predictionDistance = Integer.parseInt(args[2]);
      signalScale = Double.parseDouble(args[3]);
      noiseScale = Double.parseDouble(args[4]);
      bpFilterLength = Integer.parseInt(args[5]);
      if(bpFilterLength &gt; 128){
        //Make sure this value is not greater than 128.
        bpFilterLength = 128;
        System.out.println(
                          "bpFilterLength must be &lt;= 128");
        System.out.println("Using bpFilterLength = 128");
      }//end if
    }else{
      System.out.println(
                      "Using default program parameters.");
    }//end else
    
    //Create an array object to store the bandpass filter
    // coefficients.
    double[] bpFilterOperator = new double[bpFilterLength];
       
    //Instantiate a new object of the <span lang="en-us"></span>Adapt09 class.
    Adapt09 thisObject = new Adapt09();
    
    //Prepare the bandpass filter,which is a truncated
    // sinusoid with a frequency of one-eighth of the
    // sampling frequency.
    for(int cnt = 0;cnt &lt; bpFilterLength;cnt++){
      bpFilterOperator[cnt] = thisObject.getCosine(cnt);
    }//end for loop
    
    //Invoke the method named process.
    thisObject.process(feedbackGain,
                       numberAdaptiveIterations,
                       rmsAveragingLength,
                       adaptiveFilterLength,
                       signalScale,
                       noiseScale,
                       bpFilterOperator,
                       predictionDistance);

    //Display program parameters at the end of the run.
    System.out.println("\nfeedbackGain: " + feedbackGain);
    System.out.println("numberAdaptiveIterations: " 
                               + numberAdaptiveIterations);
    System.out.println("adaptiveFilterLength: " 
                                   + adaptiveFilterLength);
    System.out.println("predictionDistance: " 
                                     + predictionDistance);
    System.out.println("signalScale: " + signalScale);
    System.out.println("noiseScale: " + noiseScale);
    System.out.println("bpFilterLength: " 
                                         + bpFilterLength);
    System.out.println("rmsAveragingLength: " 
                                     + rmsAveragingLength);

  }//end main
  //-----------------------------------------------------//
  
  //This is the primary adaptive processing and plotting
  // method for the program.
  void process(double feedbackGain,
               int numberAdaptiveIterations,
               int rmsAveragingLength,
               int adaptiveFilterLength,
               double signalScale,
               double noiseScale,
               double[] bpFilterOperator,
               int predictionDistance){

    //Display the bandpassFilterOperator
    //First instantiate a plotting object.
    PlotALot01 bpFilterPlotObj = new PlotALot01(
           "Noise Filter Operator",
           (bpFilterOperator.length * 2) + 8,148,70,2,0,0);

    //Feed the data to the plotting object.
    for(int cnt = 0;cnt &lt; bpFilterOperator.length;cnt++){
      bpFilterPlotObj.feedData(40*bpFilterOperator[cnt]);
    }//end for loop
    
    //Cause the graph to be displayed on the computer
    // screen in the upper left corner.
    bpFilterPlotObj.plotData(0,0);
    
    //Now compute and plot the frequency response of the
    // bandpass filter.
    
    //Instantiate a plotting object for two channels of
    // frequency response data.  One channel is for
    // the amplitude and the other channel is for the
    // phase.
    PlotALot03 bpFilterFreqPlotObj = new PlotALot03(
            "Noise Filter Freq Response",264,148,35,2,0,0);
                   
    //Compute the frequency response and feed the results
    // to the plotting object.
    displayFreqResponse(
               bpFilterOperator,bpFilterFreqPlotObj,128,0);
                       
    //Cause the frequency response data stored in the
    // plotting object to be displayed on the screen in
    // the middle position.
    bpFilterFreqPlotObj.plotData(0,148);

    //Instantiate an array object that will be used as a
    // delay line for the signal plus white noise data in
    // order to convolve the samples with the bandpass
    // filter.
    double[] whiteNoiseDelayLine = 
                       new double[bpFilterOperator.length];
    
    //Instantiate an array object that will be used as a
    // delay line for the filtered signal plus noise data.
    // This delay line is used to obtain a target sample
    // advanced in time relative to the data that is used
    // to predict the target.  The target sample is
    // advanced in time by a number of samples equal to
    // predictionDistance.
    double[] signalPlusNoiseDelayLine = 
                        new double[predictionDistance + 1];
    
    //Instantiate a plotting object for four channels of
    // time-series data at 230 samples per page.
    int sampPerPage = 230;
    PlotALot05 timePlotObj = new PlotALot05(
                         "Time-Domain Adaptive Data",
                         (2*sampPerPage + 8),148,25,2,0,0);

    //Declare and initialize working variables.
    double output = 0;
    double err = 0;
    double target = 0;
    double input = 0;
    double signal = 0;
    double whiteNoise = 0;
    boolean adaptOn;
    double targetSumSq = 0;
    double errSumSq = 0;

    //Instantiate an object to handle the adaptive behavior
    // of the program.
    AdaptEngine02 adapter = new AdaptEngine02(
                        adaptiveFilterLength,feedbackGain);

    //Perform the specified number of iterations.  This is
    // the sum of the specified number of adaptive
    // iterations plus the non-adaptive iterations that are
    // used to compute the percent error after the adaptive
    // update process is disabled.
    for(int cnt = 0;
       cnt &lt; numberAdaptiveIterations + rmsAveragingLength;
                                                    cnt++){
      
      //The following variable is used to control whether
      // or not the adapt method of the adaptive engine
      // updates the filter coefficients when it is called.
      // The filters are updated when this variable is
      // true and are not updated when this variable is
      // false.
      adaptOn = true;
      
      //Get and scale the next sample of white noise data
      // from a random number generator. Before scaling by
      // noiseScale, the values are uniformly distributed
      // from -1.0 to 1.0.
      whiteNoise = noiseScale*(2*(random() - 0.5));
      
      //Get and scale the next sample of signal.  The
      // signal is a pure tone with a frequency equal to
      // one-eighth of the sampling frequency.  Before
      // scaling by signalScale, the peak-to-peak value
      // is 2.
      signal = signalScale * getCosine(cnt);
      
      //Insert the signal plus white noise data into the
      // delay line that will be used to convolve the 
      // signal plus white noise data with the bandpass
      // filter.
      double signalPlusNoise = whiteNoise + signal;
      flowLine(whiteNoiseDelayLine,signalPlusNoise);
      
      //Declare a variable to receive the filtered signal
      // plus noise sample.
      double filteredSignalPlusNoise = 0;
    
      //Apply the bandpass filter operator to the signal
      // plus white noise data.  If the filter length is 1,
      // bypass the filtering operation and use the raw
      // signal plus white noise.
      if(bpFilterOperator.length == 1){
        filteredSignalPlusNoise = signalPlusNoise;
      }else{
        filteredSignalPlusNoise = reverseDotProduct(
           whiteNoiseDelayLine,
           bpFilterOperator)/(bpFilterOperator.length/2.0);
      }//end else
                   
      //Insert the filtered signal plus noise into the
      // delay line that is used to obtain a time-advanced
      // sample of the target.
      flowLine(
         signalPlusNoiseDelayLine,filteredSignalPlusNoise);

      //Declare a variable that will be populated with the
      // results returned by the adapt method of the
      // adaptive engine.
      AdaptiveResult result = null;
      
      //Disable adaptive updates when the specified number
      // of adaptive iterations has been performed.
      if(cnt &gt; numberAdaptiveIterations){
        adaptOn = false;
      }//end if
      
      //Establish the appropriate input values and perform
      // the adaptive updates to the adaptive filter
      // coefficients.
      input = signalPlusNoiseDelayLine[0];//historical samp
      target = 
              signalPlusNoiseDelayLine[predictionDistance];
      result = adapter.adapt(input,target,adaptOn);

      //Get and save adaptive results.
      output = result.output;
      err = result.err;
      
      //Compute values that will be used later to compute
      // the percent error.  This computation is performed
      // only after adaptive updates have been disabled.
      if(!adaptOn){
        //Accumulate the sum of the squares of the target
        // and error values.
        targetSumSq += target * target;
        errSumSq += err * err;
      }//end if
    
      //Feed the time series data to the plotting object.
      // Plot only two pages of data after adaptive updates
      // are disabled.
      if(cnt &lt;= numberAdaptiveIterations + 2*sampPerPage){
        timePlotObj.feedData(input,target,output,err);
      }//end if

    }//End for loop on required number of iterations.
   
    //Compute and display the mean square values
    double rmsTarget = 
                      sqrt(targetSumSq/rmsAveragingLength);
    double rmsError = sqrt(errSumSq/rmsAveragingLength);
    System.out.println("\nRMS target: " + rmsTarget);
    System.out.println("RMS error: " + rmsError);
    System.out.println(
         "Percent error: " + 100.0*(rmsError)/(rmsTarget));
    
    //Cause the data stored in the plotting object to be
    // plotted.
    timePlotObj.plotData(0,296);

  }//end process method
  //-----------------------------------------------------//
  
  //This method simulates a tapped delay line. It receives
  // a reference to an array and a value.  It discards the
  // value at index 0 of the array, moves all the other
  // values by one element toward 0, and inserts the new
  // value at the top of the array.
  void flowLine(double[] line,double val){
    for(int cnt = 0;cnt &lt; (line.length - 1);cnt++){
      line[cnt] = line[cnt+1];
    }//end for loop
    line[line.length - 1] = val;
  }//end flowLine
  //-----------------------------------------------------//
 
  void displayFreqResponse(
     double[] filter,PlotALot03 plot,int len,int zeroTime){

    //Create the arrays required by the Fourier Transform.
    double[] timeDataIn = new double[len];
    double[] realSpect = new double[len];
    double[] imagSpect = new double[len];
    double[] angle = new double[len];
    double[] magnitude = new double[len];
    
    //Copy the filter into the timeDataIn array
    System.arraycopy(filter,0,timeDataIn,0,filter.length);

    //Compute DFT of the filter from zero to the folding
    // frequency and save it in the output arrays.
    ForwardRealToComplex01.transform(timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude,
                                     zeroTime,
                                     0.0,
                                     0.5);

    //Find the absolute peak value.  Begin with a negative
    // peak value with a large magnitude and replace it
    // with the largest magnitude value.
    double peak = -9999999999.0;
    for(int cnt = 0;cnt &lt; magnitude.length;cnt++){
      if(peak &lt; abs(magnitude[cnt])){
        peak = abs(magnitude[cnt]);
      }//end if
    }//end for loop

    //Normalize to 20 times the peak value
    for(int cnt = 0;cnt &lt; magnitude.length;cnt++){
      magnitude[cnt] = 20*magnitude[cnt]/peak;
    }//end for loop

    //Now feed the normalized data to the plotting
    // object.
    for(int cnt = 0;cnt &lt; magnitude.length;cnt++){
      plot.feedData(magnitude[cnt],angle[cnt]/20);
    }//end for loop
    
  }//end displayFreqResponse
  //-----------------------------------------------------//
  
  //This method receives two arrays and treats each array
  // as a vector. The two arrays must have the same length.
  // The program reverses the order of one of the vectors
  // and returns the vector dot product of the two vectors.
  double reverseDotProduct(double[] v1,double[] v2){
    if(v1.length != v2.length){
      System.out.println("reverseDotProduct");
      System.out.println("Vectors must be same length.");
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    
    double result = 0;
    
    for(int cnt = 0;cnt &lt; v1.length;cnt++){
      result += v1[cnt] * v2[v1.length - cnt - 1];
    }//end for loop

    return result;
  }//end reverseDotProduct
  //-----------------------------------------------------//
  
  //This method returns the values of a cosine function
  // sampled eight samples per cycle.
  double getCosine(int index){
    int cnt = index%8;
    if(cnt == 0){
      return 1.0;
    }else if(cnt == 1){
      return 0.7071067811865476;
    }else if(cnt == 2){
      return 0;
    }else if(cnt == 3){
      return -0.7071067811865476;
    }else if(cnt == 4){
      return -1.0;
    }else if(cnt == 5){
      return -0.7071067811865476;
    }else if(cnt == 6){
      return 0;
    }else if(cnt == 7){
      return 0.7071067811865476;
    }//end else
    return 0;//Make the compiler happy.
  }//end getCosine
  //-----------------------------------------------------//
}//end class Adapt09<br><br><b><font face="Courier New,Courier"><a href="#Listing_14">Listing 14</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p></p>

<hr  size="3" width="100%">
<p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
Java adaptive filtering convolution filter frequency spectrum LMS amplitude 
phase time-delay linear DSP impulse decibel log10 DFT transform bandwidth signal 
noise real-time dot-product vector time-series prediction identification inverse 
noise cancellation</p>
<p>-end- </p>
</body>
</html>