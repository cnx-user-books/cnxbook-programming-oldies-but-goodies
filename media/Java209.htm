<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="AUTHOR" content="Richard G. Baldwin">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>... in Java by Richard G Baldwin</title>
</head>

<body bgcolor="#FFFFFF">
<!--start-->
<h3 align="center"><b><i>Richard G Baldwin (512) 223-4758, </i></b><a
href="mailto:baldwin@austin.cc.tx.us"><b><i>baldwin@austin.cc.tx.us</i></b></a><b><i>,
</i></b><a href="http://www2.austin.cc.tx.us/baldwin/"><b><i>http://www2.austin.cc.tx.us/baldwin/</i></b></a></h3>

<h2 align="center"><b>Swing, </b><font color="#000000"><b><!--title--></b>Simplified
Lists in Swing<!--endTitle--></font></h2>

<p>Java Programming, Lecture Notes # 209, Revised 12/16/98. </p>

<ul>
    <li><a href="#Preface">Preface</a></li>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Sample Program">Sample Program</a></li>
    <li><ul>
            <li><a href="#Interesting Code Fragments">Interesting
                Code Fragments</a></li>
            <li><a href="#Program Listing">Program Listing</a></li>
        </ul>
    </li>
</ul>

<hr>

<h2 align="center"><a name="Preface"></a><font color="#FF0000">Preface</font></h2>

<p>Students in Prof. Baldwin's <b><u>Advanced Java Programming</u></b>
classes at ACC will be responsible for knowing and understanding
all of the material in this lesson beginning with the Spring
semester of 1999. </p>

<p align="left">This lesson was originally written on October 4,
1998, using the JDK 1.1.6 download package along with Swing
1.0.3. The lesson was upgraded to JDK 1.2 on 12/16/98. The
purpose of this lesson is to illustrate the use of simplified
lists in Swing which largely (but not completely) ignore the <i>Model-Delegate</i>
paradigm. </p>

<h2 align="center"><a name="Introduction"></a><font
color="#FF0000"><b>Introduction</b></font></h2>

<p>You may have read that Swing components are designed around a
modified version of Model-View-Control (MVC) paradigm in which
the <i>view</i> and the <i>control</i> are combined into an
object called a <i>delegate</i>.&nbsp; Delegates represent the
model to the user (as a view normally does) and also translate
user input into the model (as a control normally does).&nbsp; As
such, the Swing approach is based on a <i>model-delegate</i>
paradigm instead of a true MVC paradigm. </p>

<p>You may also have read that Swing gives you the ability to
control how widgets look, how they&nbsp; respond to input, and in
some cases, how their data is represented. </p>

<p>All of this is true, and unfortunately, can sometimes lead to
confusion.&nbsp; But, the fact that you <u>can</u> do all of
these things doesn't mean that you <u>must</u> do them.&nbsp; I
will discuss the implementation and use of the <i>model-delegate</i>
paradigm in detail in subsequent lessons.&nbsp; The primary
purpose of this lesson is to teach you how to largely ignore the <i>model-delegate</i>
paradigm and use the Swing <b>JList</b> component in a simple and
effective way. </p>

<p align="left">As is my practice, I will use a sample program as
a teaching aid. </p>

<h2 align="center"><a name="Sample Program"></a><font
color="#FF0000">Sample Program</font></h2>

<p>The name of this program is <b>SwingList01.java </b>and a
complete listing appears near the end of this lesson.&nbsp; It
would probably help if you would compile and run it at this point
so you can view it on the screen while I discuss it. </p>

<p>The purpose of this program is to show you how to use the
Swing <b>JList</b> component in a simple and effective way.&nbsp;
The sample program in this lesson allows you to largely (but not
completely) ignore the complexities of the <b>JList</b> class
introduced by the <i>model-delegate</i> paradigm. </p>

<p>The program illustrates three different ways to create and
populate a list using the <b>JList</b> object: </p>

<ul>
    <li>Using an array to populate the list</li>
    <li>Using a Vector object to populate the list</li>
    <li>Populate the list by adding one element at a time</li>
</ul>

<p>The program also illustrates the use of the <b>ListSelectionListener</b>
interface to instantiate listener objects that listen for the
selection of elements in the list, retrieve the values of those
elements, and display the values. </p>

<p>Selection of elements (under Windows 95) is accomplished using
the mouse or arrow keys and various combinations of the Shift and
Ctrl keys. </p>

<p>When the program starts, four scrollable lists appear in a <b>JFrame</b>
on the screen.&nbsp;On my screen, the four lists appear in the
top left, top right, bottom left, and bottom right of the <strong>JFrame</strong>
object. However, this layout may differ depending on the overall
size and shape of the frame, so I will refer to these four lists
as &nbsp;<strong>listA</strong>, <strong>listB</strong>, <strong>listC</strong>,
and <strong>displayList</strong> respectively. (If you change the
shape of the frame to make it short and wide, the four lists will
appear in a row from left to right, and if you change the shape
of the frame to make it tall and narrow, the four lists will
appear in a column from top to bottom.)</p>

<p>The list at the top left (<strong>listA</strong>) was
populated at startup by passing an array of data to the
constructor. </p>

<p><strong>listA</strong> allows you to select one element at a
time.&nbsp; It has a selection listener registered on it to
process your selection.&nbsp; The listener causes your selection
to be displayed in the list on the bottom right (<strong>displayList</strong>).
</p>

<p><strong>listA</strong> was allowed to establish its own width
based on the length of the longest element used to populate the
list when it was instantiated. </p>

<p>The list at the top right (<strong>listB</strong>) was
populated at startup by passing a <b>Vector</b> object containing
data to the constructor. </p>

<p><strong>listB</strong> allows you to select one contiguous
group of elements at a time.&nbsp; The elements that you select
are displayed in <strong>displayList</strong>. </p>

<p><strong>listB</strong> was also allowed to establish its own
width based on the length of the longest element used to populate
the list when it was instantiated. </p>

<p>The list on the bottom left (<strong>listC</strong>) was
constructed by instantiating an empty list and populating it by
adding elements one at a time. </p>

<p><strong>listC</strong> allows virtually unlimited selection
capability.&nbsp; The elements that you select are displayed in <strong>displayList</strong>.
</p>

<p>The width of <strong>listC</strong> was specified by invoking
the <b>setFixedCellWidth()</b> method on the list. </p>

<p>The list on the bottom right (<strong>displayList</strong>)
was also constructed by instantiating an empty list and adding
one element at a time.&nbsp; At startup, it contains only one
element.&nbsp; However, <strong>displayList</strong> is used to
display selection results for the other lists, so its contents
change depending how you make selections in the other
lists.&nbsp; Whenever you make a new selection in any of the
other lists, the&nbsp;previous information is removed from <strong>displayList</strong>
and replaced by new information.&nbsp; Thus, <strong>displayList</strong>
illustrates the process of updating a list at runtime. </p>

<p><strong>displayList</strong> does not have a selection
listener, so making selections in <strong>displayList</strong>
will have no effect (other than the visual indication that a
selection has been made). </p>

<p><strong>displayList</strong> was also allowed to establish its
own width based on the length of the longest element used to
populate the list when it was instantiated.&nbsp; Later on, if
you select elements from another list that are too long to fit in
this list, you will see a horizontal scroll bar appear
automatically. </p>

<p>The height of each of the four lists was specified by invoking
the <b>setVisibleRowCount()</b> method on the list.&nbsp; When
the number of elements in the list is too great to fit in the
available vertical space, a vertical scroll bar appears
automatically. </p>

<p align="left">This program was tested using JDK 1.1.6 and Swing
1.0.3 under Win95. It was also tested using JDK 1.2.</p>

<h3 align="center"><a name="Interesting Code Fragments"></a><font
color="#FF0000">Interesting Code Fragments</font></h3>

<p>This program, named <b>SwingList01</b>, is fairly repetitious,
so I will try to avoid repeating the discussion of similar code
fragments.&nbsp; You can view all of the code in the complete
listing of the program that appears later in this lesson. </p>

<p>The first fragment shows the beginning of the controlling
class along with the declaration of some instance variables that
are used later in the program.&nbsp; I included the fragment here
simply to acquaint you with the names of these variables. You
will note that the names of four of these variables correspond to
the names by which I referred to the four lists in the above
discussion (<strong>listA</strong>, etc.).</p>

<p>The fragment also contains a <b>main()</b> method that makes
it possible to run the program as an application.&nbsp; The main
method simply instantiates an object of the controlling class and
the constructor takes over from there. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>public class <b>SwingList01</b> extends JFrame{
&nbsp; String testDirectory = &quot;c:/jnk&quot;;
&nbsp; JScrollPane scrollPaneA;
&nbsp; JScrollPane scrollPaneB;
&nbsp; JScrollPane scrollPaneC;
&nbsp; JScrollPane displayScrollPane;

&nbsp; JList <strong>listA</strong>;
&nbsp; JList <strong>listB</strong>;
&nbsp; JList <strong>listC</strong>;
&nbsp; JList <strong>displayList</strong>;

&nbsp; MyListSelectionListener listSelectionListenerA;
&nbsp; MyListSelectionListener listSelectionListenerB;
&nbsp; MyListSelectionListener listSelectionListenerC;

&nbsp; JPanel panelA = new JPanel();
&nbsp; JPanel panelB = new JPanel();
&nbsp; JPanel panelC = new JPanel();
&nbsp; JPanel displayPanel = new JPanel();
&nbsp;&nbsp;
&nbsp; //The following is a reference to the top-level JFrame
&nbsp; // which contains everything else.
&nbsp; SwingList01 thisObj;
&nbsp;&nbsp;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public static void <b>main</b>(String args[]) {
&nbsp;&nbsp;&nbsp; //Instantiate the top-level JFrame object.
&nbsp;&nbsp;&nbsp; new SwingList01();
&nbsp; }//end main</pre>
        </td>
    </tr>
</table>

<p>The next fragment shows the beginning of the constructor which
includes the instantiation of the <b>JList</b> object that
appears in the top left corner of the outer frame (<strong>listA</strong>).&nbsp;
The important thing to note is that this version of the <b>JList</b>
constructor allows you to populate the list using data from an
array when you construct the list. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp; public SwingList01 () {//constructor

&nbsp;&nbsp;&nbsp; String[] <b>data</b> = {&quot;ax&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;};
&nbsp;&nbsp;&nbsp; <b>listA = new JList(data);</b></pre>
        </td>
    </tr>
</table>

<p>As with all other AWT and Swing components, simply
instantiating an object doesn't cause it to become visible and
usable.&nbsp; A little more work is required to cause the list to
appear on the screen.&nbsp; There are probably several ways to do
this.&nbsp; I elected to place the list in a scroll pane, place
the scroll pane in a panel, and place the panel in the main <b>JFrame</b>
object.&nbsp; The first two of these three steps are shown in the
next fragment.&nbsp; The panel is added to the frame later in the
program. </p>

<p>In case you aren't familiar with the use of <b>JScrollPane</b>
class, it has several constructors.&nbsp; This particular
constructor is easy to use.&nbsp; Simply pass a reference to the
list to the constructor when you instantiate the scroll
pane.&nbsp; This causes the list to become scrollable. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp; scrollPaneA = <b>new JScrollPane(listA)</b>;
&nbsp;&nbsp;&nbsp; panelA.<b>add</b>(scrollPaneA);</pre>
        </td>
    </tr>
</table>

<p>The next fragment is standard <i>Delegation Event Model</i>
material.&nbsp; I included it here simply for completeness.&nbsp;
This fragment instantiates a new <b>ListSelectionListener</b>
object and registers it on the <b>JList</b> object. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; listSelectionListenerA = <b>new MyListSelectionListener()</b>;
&nbsp;&nbsp;&nbsp; listA.<b>addListSelectionListener</b>(listSelectionListenerA);</pre>
        </td>
    </tr>
</table>

<p>The next fragment specifies the height of the list in rows of
data by invoking the <b>setVisibleRowCount()</b> method, and
passing the desired number of visible rows as a parameter. </p>

<p>The fragment also specifies that only one element can be
selected at a time by invoking the <b>setSelectionMode()</b>
method on the list and passing a symbolic constant as a
parameter.&nbsp; There are three such symbolic constants defined
in the <b>ListSelectionModel</b> interface.&nbsp; You can view
all three in the complete listing of the program later. </p>

<p>One of the other symbolic constants specifies that a single
contiguous group of elements can be selected at a time.&nbsp; The
third symbolic constant specifies that the selection
possibilities are virtually unlimited. </p>

<p>This is one place where our simple program must touch on the
complexities of the <i>model-delegate</i> paradigm. </p>

<p>The selection rules for a <b>JList</b> object are always
controlled by a separate object that implements the <b>ListSelectionModel</b>
interface.&nbsp; I will discuss this in detail in a subsequent
lesson.&nbsp; For the time being, just accept the fact that the
symbolic constants are defined in the <b>ListSelectionModel</b>
interface. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp; listA.<b>setVisibleRowCount</b>(5);
&nbsp;&nbsp;&nbsp; listA.<b>setSelectionMode</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>ListSelectionModel</b>.<b>SINGLE_SELECTION</b>);</pre>
        </td>
    </tr>
</table>

<p>As I mentioned earlier, the list is placed in a scroll pane,
which is placed in a panel, which is placed in the outer <b>JFrame</b>
object.&nbsp; The next fragment invokes the <b>getPreferredScrollableViewportSize()</b>
method on the list and uses the returned information to set the
size of the panel to match the size of the scroll pane. </p>

<p>Finally, the panel is added to the outer <b>JFrame</b>
object.&nbsp; If you aren't familiar with the <b>getContentPane()</b>
method, you should go back and review an earlier lesson that
discusses the use of panes with <b>JFrame</b> objects. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp; Dimension prefSize =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listA.<b>getPreferredScrollableViewportSize()</b>;
&nbsp;&nbsp;&nbsp; panelA.<b>setBounds</b>(0,0,prefSize.width,prefSize.height);

&nbsp;&nbsp;&nbsp; getContentPane().<b>add</b>(panelA);</pre>
        </td>
    </tr>
</table>

<p>At this point, the first <b>JList</b> object appears in the
outer frame, fully populated and ready to use. </p>

<p>The code to instantiate and populate the remaining three list
objects is very similar, so I will only show and discuss code
that is different. </p>

<p>The list in the upper right (<strong>listB</strong>) is
populated by passing a <b>Vector</b> object to the <b>Jlist</b>
constructor.&nbsp; First, however, it is necessary to populate
the <b>Vector</b> object.&nbsp; I populated the object with all
of the file and directory names in the root of the C-drive on my
machine.&nbsp; Since that is not the topic of discussion here, I
will omit any further discussion of that code.&nbsp; You can view
the code in the complete program listing. </p>

<p>The name of the <b>Vector</b> object is <b>theResults</b>.&nbsp;
The next fragment shows the instantiation and population of the
list by passing the vector object to the constructor for the <b>JList</b>
object.&nbsp; Once this statement executes, a fully populated <b>JList</b>
object exists.&nbsp; A reference to the list is assigned to the
reference variable named <b>listB</b>. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB = new JList(<b>theResults</b>);</pre>
        </td>
    </tr>
</table>

<p>The code to display this list in a scroll pane is essentially
the same as for the previous list, so I won't discuss it further.
</p>

<p>The next fragment instantiates and populates the list shown in
the bottom left of the frame (<strong>listC</strong>).&nbsp; As
you can see, this code is considerably different from the code
for the previous two lists. </p>

<p>This fragment instantiates an empty list and adds elements to
it, one element at a time. </p>

<p>First let me mention the portion of this code that should be
fairly obvious.&nbsp; Earlier, I told you that the width of this
list was set to a fixed width.&nbsp; That was accomplished by
invoking the <b>setFixedCellWidth()</b> method on the <b>JList</b>
object. </p>

<p>Now for the code that's not so obvious.&nbsp; I promised you
at the beginning of this lesson that we could &quot;largely&quot;
avoid the complexities of the <i>model-delegate</i>
paradigm.&nbsp; I didn't promise you that we could completely
avoid those complexities. </p>

<p><strong>IMPORTANT</strong>:&nbsp; The data for every <b>JList</b>
object is managed by a separate object that implements the <b>ListModel</b>
interface. </p>

<p>You can define your own data management class to use for this
purpose, and I will show you how to do that in a subsequent
lesson. </p>

<p>There are four overloaded constructors for the <b>JList</b>
class.&nbsp; Two of those constructors are the two that we used
to construct the two previous lists.&nbsp; Those two
automatically link the <b>JList</b> object to a suitable <b>ListModel</b>
object. </p>

<p>One of the four constructors instantiates the <b>JList</b>
object without linking it to a <b>ListModel</b> object, and you
have to come back and establish that link later in the
program.&nbsp; This lesson <u>doesn't illustrate</u> the use of
that constructor. </p>

<p>The fourth constructor is the one that I used here.&nbsp; This
constructor allows you to instantiate a <b>JList</b> object and
link it to a <b>ListModel</b> object by passing a reference to a <b>ListModel</b>
object as a parameter to the constructor. </p>

<p>There is a skeleton class named <b>AbstractListModel</b> that
implements the <b>ListModel</b> interface.&nbsp; (For
convenience, you might decide to extend this class, instead of
implementing the <b>ListModel</b> interface if you are creating
your own data model.) </p>

<p>There is a fairly complete class named <b>DefaultListModel</b>
that extends the <b>AbstractListModel</b> class, thereby
implementing the <b>ListModel</b> interface through inheritance. </p>

<p>In this fragment, I elected to use a <b>DefaultListModel</b>
object as the data model for my list.&nbsp; Therefore, I
instantiated a new object of this class and passed it as a
parameter to the <b>JList</b> constructor to instantiate my list
object. </p>

<p><strong>IMPORTANT</strong>:&nbsp; To manipulate the data in
the list, you actually manipulate the data in the data model and
the data is displayed as though it belongs to the list (the list
behaves as a <em>view</em> on the model). </p>

<p>Therefore, to add elements to the list, I invoked the <b>getModel()</b>
method on the list to get a reference to the model, and then
invoked the <b>addElement()</b> method on that reference to add
new elements to the list. Note the requirement for downcasting
the value returned from <strong>getModel()</strong>.</p>

<p>Repetitious code was omitted for brevity. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp; listC = new JList(new <b>DefaultListModel</b>());
&nbsp;&nbsp;&nbsp; listC.<b>setFixedCellWidth</b>(100);//set width of cells

&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.<b>getModel</b>()).<b>addElement</b>(&quot;Tom&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Dick&quot;);
&nbsp;&nbsp;&nbsp; //Code to add more elements omitted for brevity</pre>
        </td>
    </tr>
</table>

<p>Beyond this, the code to display this list in the frame is
essentially the same as the previous lists, so I won't discuss it
further. </p>

<p>After this, I created a list referred to by a reference
variable named <b>displayList</b> and placed a single element in
that list.&nbsp; The code was essentially the same as for the
previous list except that I did not register a selection listener
on this list.&nbsp; I won't discuss that code here.&nbsp; You can
view it in the full program listing.&nbsp; There is also some
additional code there to manage the outer frame object which I
won't discuss. </p>

<p>That brings us to the definition of the listener class used to
instantiate selection listener objects.&nbsp; This class
definition is shown in the next fragment.&nbsp; Much of this is
standard <em>Delegation Event Model</em> material, but there are
a couple of statements that are peculiar to <b>JList</b>
processing, so I will show and discuss it here. </p>

<p>To begin with, selection events occur when you select an
element using either an arrow key or the mouse.&nbsp; Although it
isn't obvious here, (with JDK1.1.6/Swing1.0.3 for Win95) when you
select an element with the mouse, you actually get two events in
succession.&nbsp; The first occurs when you press the mouse
button and the second occurs when you release the mouse
button.&nbsp; You need to be aware of this because it could cause
confusion, depending on what you plan to do in response to the
events. </p>

<p>This code fragment uses standard event processing code to get
a reference to the source list, and then invokes the <b>getSelectedValues()</b>
method on the source to get an array of objects that constitute
the elements that were selected to trigger the event in the first
place. </p>

<p>My objective was to display the selection information from any
of the first three lists in the fourth, or lower right list (<strong>displayList</strong>).&nbsp;
My approach was to remove all existing elements from <strong>displayList</strong>
when an event occurs, and then add new elements to the list
representing the selection information from one of the other
lists. </p>

<p>The code is pretty straightforward except for the fact that
again, to remove or add elements to the list, I actually had to
remove and add them to the data model, not directly to the
list.&nbsp; This required that I invoke the <b>getModel()</b>
method on the list to get a reference to the data model.&nbsp;
Using that reference, I removed, and then added elements to the
data model, which caused them to appear in the list. </p>

<p>This code first displays the number of elements selected, and
then displays the elements themselves. </p>

<p>Some downcasting was also required which always leads to ugly
code. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp; class MyListSelectionListener&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements <b>ListSelectionListener</b>{
&nbsp;&nbsp;&nbsp; public void <b>valueChanged</b>(<b>ListSelectionEvent</b> e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JList theList = (JList)e.<b>getSource</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object[] selValues = theList.<b>getSelectedValues</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(selValues != null){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.<b>getModel</b>()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>removeAllElements</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.<b>getModel</b>()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>addElement</b>(&quot;Number:&quot; + <b>selValues.length</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; selValues.length; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.<b>getModel</b>()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>addElement</b>(&quot;Items: &quot; + <b>selValues[cnt]</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end valueChanged()
&nbsp; }//end class MyListSelectionListener</pre>
        </td>
    </tr>
</table>

<p align="left">The code in the program that was not highlighted
in the fragments above can be viewed in the complete listing of
the program that follows in the next section. </p>

<h3 align="center"><a name="Program Listing"></a><font
color="#FF0000">Program Listing</font></h3>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>/*File SwingList01.java
Rev 12/16/98
The purpose of this program is to illustrate the use&nbsp;
the Swing JList component in a simplified manner.
The sample programs in this lesson allow you to largely
ignore the complexities of the JList class introduced
by the model-delegate paradigm.

The program illustrates three different ways to create
and populate a list:&nbsp;&nbsp;
1.&nbsp; Using an array
2.&nbsp; Using a Vector
3.&nbsp; Adding one element at a time

It also illustrates the use of the ListSelectionListener
interface to instantiate listener objects that monitor
for the selection of an element in the list, retrieve the
value of the element, and display that value.

When the program starts, four scrollable lists appear on
the screen.&nbsp; The list at the top left was populated at
startup by passing an array of data to the constructor.

This list allows you to select one element at a time.&nbsp; It
has a selection listener registered on to process your
selection.&nbsp; Your selection is displayed in the list on
the bottom right.

This list was allowed to establish its own width based on
the length of longest element used to populate the list
when it was instantiated.

The list at the top right was populated at startup by
passing a Vector object containing data to the constructor.

This list allows you to select one contiguous group of
elements at a time time.&nbsp; The elements that you select are
displayed in the list on the bottom right.

This list was also allowed to establish its own width based
on the length of the longest element used to populate the
list when it was instantiated.

The list on the bottom left was constructed by&nbsp;
instantiating an empty list and populating it by adding&nbsp;
elements one at a time.

This list allows virtually unlimited selection.&nbsp; The
elements that you select are displayed in the list on the
bottom right.

The width of this list was specified by invoking the&nbsp;
setFixedCellWidth() method on the list.

The list on the bottom right was also constructed by
instantiating an empty list and adding one element at a
time.&nbsp; At startup, it contains only one element.&nbsp; However,
this list is used to display selection results for the
other lists, so its contents change with time depending
how you make selections in the other lists.&nbsp; Whenever
your make a new selection in any of the lists, the&nbsp;
previous information is removed and replaced by new
information.&nbsp; Thus, this list illustrates the process
of updating a list at runtime.

This list does not have a selection listener, so making
selection in this list will have no effect.

This list was also allowed to establish its own width based
on the length of the longest element used to populate the
list when it was instantiated.&nbsp; Later on, if you select
elements from the list at the top right that are too long
to fit in the list, you will see horizontal scroll bars
automatically appear.

The height of all four lists was specified by invoking the
listC.setVisibleRowCount() method on the list.&nbsp; When the
number of elements in the list is too great to fit in the
available vertical space, vertical scroll bars&nbsp;
automatically appear.

The program runs under JDK 1.1.6 but won't run under
Microsoft jview when compiled using jvc.

See the program named SwingCombo01.java for a similar
program that illustrates the use of a JComboBox component.

Tested using JDK 1.1.6 and Swing 1.0.3 under Win95. Also
tested using JDK 1.2 under Win95.
**********************************************************/
import java.io.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
//import com.sun.java.swing.*;//jdk 1.1 version
//import com.sun.java.swing.tree.*;//jdk 1.1 version
//import com.sun.java.swing.event.*;//jdk 1.1 version
import javax.swing.*;//jdk 1.2 version
import javax.swing.tree.*;//jdk 1.2 version
import javax.swing.event.*;//jdk 1.2 version

//=======================================================//
public class SwingList01 extends JFrame{
&nbsp; String testDirectory = &quot;c:/jnk&quot;;
&nbsp; JScrollPane scrollPaneA;
&nbsp; JScrollPane scrollPaneB;
&nbsp; JScrollPane scrollPaneC;
&nbsp; JScrollPane displayScrollPane;

&nbsp; JList listA;
&nbsp; JList listB;
&nbsp; JList listC;
&nbsp; JList displayList;

&nbsp; MyListSelectionListener listSelectionListenerA;
&nbsp; MyListSelectionListener listSelectionListenerB;
&nbsp; MyListSelectionListener listSelectionListenerC;

&nbsp; JPanel panelA = new JPanel();
&nbsp; JPanel panelB = new JPanel();
&nbsp; JPanel panelC = new JPanel();
&nbsp; JPanel displayPanel = new JPanel();
&nbsp;&nbsp;
&nbsp; //The following is a reference to the top-level JFrame
&nbsp; // which contains everything else.
&nbsp; SwingList01 thisObj;
&nbsp;&nbsp;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public static void main(String args[]) {
&nbsp;&nbsp;&nbsp; //Instantiate the top-level JFrame object.
&nbsp;&nbsp;&nbsp; new SwingList01();
&nbsp; }//end main
&nbsp; //-----------------------------------------------------//

&nbsp; public SwingList01 () {//constructor
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; getContentPane().setLayout(new FlowLayout());

&nbsp;&nbsp;&nbsp; //Populate and display listA using an array as input
&nbsp;&nbsp;&nbsp; String[] data = {&quot;ax&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;};
&nbsp;&nbsp;&nbsp; listA = new JList(data);

&nbsp;&nbsp;&nbsp; scrollPaneA = new JScrollPane(listA);

&nbsp;&nbsp;&nbsp; panelA.add(scrollPaneA);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; listSelectionListenerA = new MyListSelectionListener();
&nbsp;&nbsp;&nbsp; listA.addListSelectionListener(listSelectionListenerA);
&nbsp;&nbsp;&nbsp; listA.setVisibleRowCount(5);
&nbsp;&nbsp;&nbsp; //Allow selection of one list index at a time.
&nbsp;&nbsp;&nbsp; listA.setSelectionMode(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListSelectionModel.SINGLE_SELECTION);

&nbsp;&nbsp;&nbsp; //Get size of list and adjust JPanel accordingly
&nbsp;&nbsp;&nbsp; Dimension prefSize =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listA.getPreferredScrollableViewportSize();
&nbsp;&nbsp;&nbsp; panelA.setBounds(0,0,prefSize.width,prefSize.height);

&nbsp;&nbsp;&nbsp; getContentPane().add(panelA);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //-----------------
&nbsp;&nbsp;&nbsp; //Populate and display listB using a Vector as input
&nbsp;&nbsp;&nbsp; Vector theResults = new Vector();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Populate a Vector with the files and directories in
&nbsp;&nbsp;&nbsp; // the root directory
&nbsp;&nbsp;&nbsp; String dir = &quot;c:/&quot;;
&nbsp;&nbsp;&nbsp; String[] fileList = new File(dir).list();//dir listing

&nbsp;&nbsp;&nbsp; //Loop and process each file in the directory
&nbsp;&nbsp;&nbsp; for(int fileCnt = 0;fileCnt&lt;fileList.length;fileCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(new File(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir + &quot;/&quot; + fileList[fileCnt]).isDirectory()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theResults.addElement(&quot;dir: &quot; + fileList[fileCnt]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theResults.addElement(&quot;file: &quot; + fileList[fileCnt]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; if(theResults != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB = new JList(theResults);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrollPaneB = new JScrollPane(listB);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panelB.add(scrollPaneB);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listSelectionListenerB =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyListSelectionListener();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.addListSelectionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listSelectionListenerB);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.setVisibleRowCount(6);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Allow selection of one contiguous range of indices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at a time.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.setSelectionMode(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListSelectionModel.SINGLE_INTERVAL_SELECTION);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get size of list and adjust JPanel accordingly
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefSize = listB.getPreferredScrollableViewportSize();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panelB.setBounds(0,0,prefSize.width,prefSize.height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getContentPane().add(panelB);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; //-----------------
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a list by adding elements one at a time.
&nbsp;&nbsp;&nbsp; listC = new JList(new DefaultListModel());
&nbsp;&nbsp;&nbsp; listC.setFixedCellWidth(100);//set width of cells

&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Tom&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Dick&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Harry&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Sue&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Mary&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Bill&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Andy&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Alice&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Fred&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Jane&quot;);
&nbsp;&nbsp;&nbsp; ((DefaultListModel)listC.getModel()).addElement(&quot;Willy&quot;);

&nbsp;&nbsp;&nbsp; scrollPaneC = new JScrollPane(listC);

&nbsp;&nbsp;&nbsp; panelC.add(scrollPaneC);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; listSelectionListenerC = new MyListSelectionListener();
&nbsp;&nbsp;&nbsp; listC.addListSelectionListener(listSelectionListenerC);
&nbsp;&nbsp;&nbsp; listC.setVisibleRowCount(7);
&nbsp;&nbsp;&nbsp; //Allow selecttion of one or more contiguous ranges&nbsp;
&nbsp;&nbsp;&nbsp; // of indices at a time.
&nbsp;&nbsp;&nbsp; listC.setSelectionMode(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);

&nbsp;&nbsp;&nbsp; //Get size of list and adjust JPanel accordingly
&nbsp;&nbsp;&nbsp; prefSize = listC.getPreferredScrollableViewportSize();
&nbsp;&nbsp;&nbsp; panelC.setBounds(0,0,prefSize.width,prefSize.height);

&nbsp;&nbsp;&nbsp; getContentPane().add(panelC);
&nbsp;&nbsp;&nbsp; //-----------------

&nbsp;&nbsp;&nbsp; //Create a list to display selections in
&nbsp;&nbsp;&nbsp; displayList = new JList(new DefaultListModel());

&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.getModel()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addElement(&quot;Display Selections Here&quot;);

&nbsp;&nbsp;&nbsp; displayScrollPane = new JScrollPane(displayList);

&nbsp;&nbsp;&nbsp; displayPanel.add(displayScrollPane);

&nbsp;&nbsp;&nbsp; displayList.setVisibleRowCount(7);

&nbsp;&nbsp;&nbsp; //Get size of list and adjust JPanel accordingly
&nbsp;&nbsp;&nbsp; prefSize =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayList.getPreferredScrollableViewportSize();
&nbsp;&nbsp;&nbsp; displayPanel.setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,prefSize.width,prefSize.height);
&nbsp;&nbsp;&nbsp; getContentPane().add(displayPanel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //-----------------


&nbsp;&nbsp;&nbsp; //Save a reference to the top-level JFrame object
&nbsp;&nbsp;&nbsp; // in an instance variable for later use.
&nbsp;&nbsp;&nbsp; thisObj = this;
&nbsp;&nbsp;&nbsp; setTitle(&quot;Copyright 1998, R.G.Baldwin&quot;);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; setSize(400,350);
&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //An anonymous inner class to terminate the program
&nbsp;&nbsp;&nbsp; // when the
&nbsp;&nbsp;&nbsp; // user clicks the close button on the frame.
&nbsp;&nbsp;&nbsp; this.addWindowListener(new WindowAdapter() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}
&nbsp;&nbsp;&nbsp; });
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; //=====================================================//
&nbsp;&nbsp;
&nbsp; //Inner class to monitor for selection events on the
&nbsp; // JList object.&nbsp; I get multiple events when
&nbsp; // I make a selection. This appears to be the result of&nbsp;
&nbsp; // a mouse down followed by a mouse up.
&nbsp; class MyListSelectionListener&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements ListSelectionListener{
&nbsp;&nbsp;&nbsp; public void valueChanged(ListSelectionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JList theList = (JList)e.getSource();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object[] selValues = theList.getSelectedValues();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(selValues != null){

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This is where the code should be placed to take
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the required action based on the selected values
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the selection information in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // named displayList.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.getModel()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; removeAllElements();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.getModel()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addElement(&quot;Number:&quot; + selValues.length);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; selValues.length; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DefaultListModel)displayList.getModel()).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addElement(&quot;Items: &quot; + selValues[cnt]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end valueChanged()
&nbsp; }//end class MyListSelectionListener
}//end class SwingList01</pre>
        </td>
    </tr>
</table>

<p>-end- <!--end--> </p>
</body>
</html>
