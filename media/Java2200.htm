<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
<h2>Java API for XML Processing (JAXP), Getting Started</h2>
<p><i>Baldwin begins by reviewing the salient aspects of XML.&nbsp;
Then he
</i><i>shows you how to (a) use JAXP, DOM, and an input XML file to
create a Document object that represents the XML file, (b) recursively
traverse the DOM tree, getting information about each node in the tree
along the way, and (c) use the information about the nodes to create a
new XML file that represents the Document object.</i></p>
<p><b>Published:</b>&nbsp; October 21, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2200</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#General%20Background%20Information">General
Background Information on XML</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p><font color="#ff0000"><b>What is JAXP?</b></font><br>
</p>
<p>As the name implies, the Java API for XML Processing (JAXP) is an
API
provided by Sun designed to help you write programs for processing XML
documents.&nbsp; JAXP is very important for many reasons, not the least
of which is the fact that it is a critical part of the Java Web
Services Developer Pack (Java WSDP).&nbsp; According to Sun,<br>
</p>
<div style="margin-left: 40px;"><span style="font-style: italic;">"The
Java WSDP is an all-in-one download containing key technologies to
simplify building of Web services using the Java 2 Platform."</span><br>
</div>
<p>This is the first lesson in a series designed to initially help you
understand how to use JAXP, and to eventually help you understand how
to use the Java WSDP.<br>
</p>
<p><font color="#ff0000"><b>What is XML?</b></font></p>
If you have been around Information Technology (IT) for the past
several years, it is doubtful that you have escaped hearing about
the&nbsp;e<b>X</b>tensible <b>M</b>arkup <b>L</b>anguage (<b>XML</b>).&nbsp;
However, if you are like many of the professional programmers who
enroll in my Java courses, you may not yet know much about XML.<br>
<br>
I will not attempt to teach XML in this series of tutorial
lessons. &nbsp; Rather, I will assume that you already understand
XML.&nbsp; I will teach you how to use JAXP to write programs for
creating and processing XML documents.<br>
<br>
Regarding XML, let me simply refer you to numerous tutorial lessons on
XML that I have previously published at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>&nbsp;and <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a></font>.&nbsp;
However, as a convenience to you, I will review many of the salient
aspects of XML later in this document under <a
 href="#General%20Background%20Information">General Background
Information on XML</a>.<br>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different listings and figures while
you
are reading about them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain
a consolidated index of my Java tutorial lessons, and sometimes they
are difficult to locate there.&nbsp; You will find a consolidated index
at <font color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font>
</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General Background Information
on
XML</a></font></h2>
<p><font color="#ff0000"><b>Purpose of this section</b></font><br>
</p>
<p>As mentioned earlier, the purpose of this section is to review the
salient aspects of XML for those who are unfamiliar with the
topic.&nbsp; Those of you who already know about XML can skip ahead to
the <a href="#Preview">Preview</a> section.&nbsp; Those of you who are
just getting your feet wet in XML <i>(and may have found the XML water
to be a little deep)</i> should continue reading this section. </p>
<p> </p>
<p><b><font color="#ff0000">Jargon</font></b> </p>
<p>Computer people are the world's worst at inventing new jargon.&nbsp;
XML people seem to be the worst of the worst in this regard. </p>
<p>Go to an XML convention and everything that you hear will be X-this,
X-that, X-everything.&nbsp; Sometimes I get dizzy just trying to keep
the
various X's separated from one another.&nbsp; In this explanation
of XML, I will try to either avoid the use of jargon, or will explain
the jargon the first time I use it.<br>
<br>
<font color="#ff0000"><b>So, just what is XML?</b></font><br>
</p>
<p>There are many definitions and descriptions for XML.&nbsp; I like
the
one given in Figure 1.<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> XML gives us a way to create and maintain <b>structured
documents</b> in <b>plain text</b> that can be <b>rendered</b> in a
variety of different ways.
      <p>A primary objective of XML is to separate content from
presentation.</p>
      <b>Figure 1</b> </td>
    </tr>
  </tbody>
</table>
<b><font color="#ff0000"><br>
What do I mean by a "structured document?"</font></b>
<p>I will answer this question by providing an example.&nbsp; A book is
typically a structured document. </p>
<p>In its simplest form, a book may be composed of chapters.&nbsp; The
chapters may be composed of sections.&nbsp; The sections may contain
illustrations and tables.&nbsp; The tables are composed of rows and
columns. </p>
<p>Thus, it should be possible to draw a hierarchical diagram that
illustrates the structure of a book, and most people who are familiar
with books will probably recognize it as such. </p>
<p><b><font color="#ff0000">What do I mean by "plain text?"</font></b> </p>
<p>Characters such as the letters of the alphabet and punctuation marks
are represented in the computer by numeric values, similar to a simple
substitution code that a child might devise. </p>
<p><b><font color="#ff0000">ASCII is an encoding scheme</font></b> </p>
<p>For example in one popular encoding scheme (ASCII), the upper-case
version of the character "A" is represented by the numeric value 65, a
"B" is represented by the value 66, a "C" is represented by 67, etc. </p>
<p>The actual correspondence between the characters and the specific
numeric values representing the characters has been described by
several different encoding schemes over the years. </p>
<p><b><font color="#ff0000">ASCII is also an organization</font></b> </p>
<p>One of the most common and enduring schemes for encoding characters
is a scheme that was devised many years ago by an organization known
as the <i>American Standards Committee on Information Interchange</i>.
</p>
<p>Given the initials of the organization, this encoding scheme is
commonly known as the ASCII code. </p>
<p>Figure 2 contains a quotation from one <a
 href="http://wuecon.wustl.edu/%7Ehyperjrn/samples.htm">author</a>
regarding the ASCII code <i>(or plain text).&nbsp;</i></p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> "This stands for American Standards Committee on Information
Interchange. What it means in practice is plain text, that is to say
text which is readable directly without using any special software.
The advantage of ASCII is that it is a lowest common denominator which
can be displayed on any platform. The disadvantage is that it is rather
limited and somewhat boring. The text cannot display bold, italics or
underlined fonts, and there is no scope for graphics or hypertext.
However,
it is simple, ... and is almost idiot-proof as a means of information
exchange. To see a short example of ASCII click <a
 href="http://wuecon.wustl.edu/%7Ehyperjrn/ascii.htm">HERE</a>, or to
see a journal article in ASCII click <a
 href="ftp://scorpio.gold.ac.uk/pub/jbe/vol2/dreyfus.txt">HERE</a>."<br>
      <br>
      <b>Figure 2</b> </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">XML is not confined to the ASCII code</font></b>
</p>
<p>XML is not confined to the use of the ASCII encoding scheme. Several
different encoding schemes can be used. </p>
<p>However, all of them have been selected to make it possible to read
a raw XML document without the requirement for any special software <i>(other
than perhaps a text editor or the DOS type command).</i> </p>
<p><b><font color="#ff0000">What is a raw XML document?</font></b> </p>
<p>A raw XML document is the string of sequential characters that makes
up the document, before any specific rendering has been applied to the
document. </p>
<p><b><font color="#ff0000">What do I mean by "rendering?"</font></b> </p>
<p>In modern computer jargon, <i>rendering</i> typically means to
present something for human consumption. </p>
<p><b><font color="#ff0000">Rendering a drawing</font></b> </p>
<p>For example, in a computer, drawings and images are nothing more or
less than sets of numbers and possibly formulas.&nbsp; Those numbers
and formulas, taken at face value, usually mean very little to most
human observers. </p>
<p><b><font color="#ff0000">Recognition by a human observer</font></b> </p>
<p>When we speak of rendering a drawing or an image, we usually mean
that we are going to present it in a way that makes it look like a
drawing or an image to a human observer. In other words, we convert the
numbers and formulas that comprise the drawing to a set of colored dots
<i>(pixels) </i>that a human observer will recognize as a drawing. </p>
<p><b><font color="#ff0000">Rendering a document</font></b> </p>
<p>When we speak of rendering a document, we usually mean that we are
going to present it in a way that a human will recognize it as a book,
a newspaper, or some other document style that can be read by the human
observer. </p>
<p><b><font color="#ff0000">Passing information through typography</font></b>
</p>
<p>Rendering, in this case, often means to present some of the material
in <b>boldface</b>, some of the material in <i>Italics</i>, some of
the material <u>underlined</u>, some of the material in <font
 color="#00cc00">color</font>, etc.&nbsp; <i>(For example, when you
view this document using an HTML browser, it is rendered to show <b>boldface</b>,
Italics, <font color="#009900">color</font>, etc.)</i> </p>
<p><b><font color="#ff0000">To separate presentation from content</font></b>
</p>
<p>Raw XML doesn't exhibit any of these presentation properties, such
as <b>boldface</b>, <i>Italics,</i> or <font color="#3333ff">color</font>.&nbsp;
Remember,
a main objective of XML is to separate presentation from content.&nbsp;
XML provides only the content.&nbsp; The presentation of that content
must come from somewhere else. </p>
<p><b><font color="#ff0000">Consider a newspaper</font></b> </p>
<p>These days, there are at least two different ways to render a
newspaper. One way is to print the information <i>(daily news),</i>
mostly in black and white, on large sheets of low-grade paper commonly
known as newsprint. This is the rendering format that ends up on my
driveway each
morning. </p>
<p><b><font color="#ff0000">My online newspaper</font></b> </p>
<p>Another way to render a newspaper is to present the information on a
computer screen, usually in full color, with the information content
trying
to fight its way through dozens of animated advertisements. </p>
<p><b><font color="#ff0000">USA Today</font></b> </p>
<p>For example, <a href="http://www.usatoday.com/">here </a>is the
sort of rendering format that <a href="http://www.usatoday.com/">USA
Today</a> provides for the online version of its newspaper.&nbsp; Most
of you are probably already familiar with the newsprint rendering of
that well known newspaper. </p>
<p><b><font color="#ff0000">The news doesn't change</font></b> </p>
<p>The base information for the newspaper doesn't <i>(or shouldn't)</i>
change for the newsprint and online renderings. After all, news is news
and the content of the news shouldn't depend on how it is presented.
What does change is the manner in which that information is presented. </p>
<p>A newspaper is a structured document consisting of pages, columns,
etc., which could be maintained using XML. </p>
<p><b><font color="#ff0000">The great promise of XML</font></b> </p>
<p>When the information content of a newspaper is created and
maintained in
XML, that same information content can be rendered on newsprint paper,
on
your computer screen, on your call phone, or potentially in other
formats without having to rewrite the information content. </p>
<p><b><font color="#ff0000">Not necessarily boring</font></b> </p>
<p>If you visit the above <a
 href="ftp://scorpio.gold.ac.uk/pub/jbe/vol2/dreyfus.txt">link</a> to
the journal article rendered solely in ASCII, you will probably agree
that from a presentation viewpoint it is pretty boring <i>(no offense
intended to the author of the article).</i> </p>
<p>However, XML documents created and maintained in plain text need not
necessarily be boring. </p>
<p><b><font color="#ff0000">When you combine a rendering engine with
XML ...</font></b> </p>
<p>It is possible to apply a rendering engine <i>(such as <a
 href="http://www.w3.org/TR/xsl/">XSL)</a></i> to the XML content and
to render that content in rich and exciting ways.&nbsp; <i>(XSL is an
acronym for the Extensible Stylesheet Language, and </i><i>is an
advanced topic that I will be covering in future lessons in this series</i><i>.)</i>
</p>
<p><b><font color="#ff0000">Separating content from presentation</font></b>
</p>
<p>XML is responsible for maintaining the content, independent of
presentation. </p>
<p>A rendering engine, such as XSL, is responsible for rendering that
content in ways that are appropriate for the application.<i></i> </p>
<p><b><font color="#ff0000">Achieving Structure</font></b> </p>
<p>So, just how does XML use plain text to create and maintain
structure? </p>
<p>Consider the following simple structure that represents a
book.&nbsp; <i>(This
book certainly wasn't written by me, because it is much too brief.)</i>
</p>
<p>The book described by the structure in Figure 3 has two chapters
with some
text in each chapter.&nbsp;<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>Begin Book<br><br>  Begin Chapter 1<br>    Text for Chapter 1<br>  End Chapter 1<br><br>  Begin Chapter 2<br>    Text for Chapter 2<br>  End Chapter 2<br><br>End Book</pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">A simple example</font></b> </p>
<p>A real book obviously has a lot more structure than this.&nbsp; For
example, a typical book will probably have a <i>Forward</i> or a <i>Preface</i>.&nbsp;
A typical book will usually have a <i>Table of Contents</i>. </p>
<p>Breaking the structure down further produces paragraphs within the
text, words within the paragraphs, etc.&nbsp; Also, a book will
frequently have an <i>Alphabetical Index</i>. </p>
<p>However, I am trying to keep this example as simple as possible, so
I
left those things out. </p>
<p><b><font color="#ff0000">A primary objective</font></b> </p>
<p>In the earlier description, I told you<i> "A primary objective of
XML is to separate content from presentation."</i> </p>
<p>This separation, and the fact that the XML document is maintained in
<i>plain text</i>, makes it possible to share the same physical
document among different computers in a way that they all
understand.&nbsp; <i>(This is often not true, for example, for
documents that are maintained in the proprietary formats of word
processing software.)</i> </p>
<p><b><font color="#ff0000">Many different computers and operating
systems</font></b> </p>
<p>Sharing of a document among different computers is no small
accomplishment. Over the years, dozens of different types of computers
have been built, operating under different operating systems, and
running thousands of different programs. </p>
<p>As a result, the modern computer world is often like being on an
island where everyone speaks a different language. </p>
<p><b><font color="#ff0000">A common language for structured documents</font></b>
</p>
<p>XML attempts to rectify this situation by providing a common
language for
structured documents. </p>
<p><b><font color="#ff0000">What Does XML Contribute?</font></b> </p>
<p>I am going to ease into the technical details later.&nbsp; At this
point, suffice it to say that XML provides a definition of a simple
scheme by which the structure and the content of a document can be
established. </p>
<p><b><font color="#ff0000">Even I can understand an XML document</font></b>
</p>
<p>The resulting physical document is so simple that any computer <i>(and
most humans)</i> can read it with only a modest amount of preparation. </p>
<p>You will sometimes see XML referred to as a "meta" language. </p>
<p><b><font color="#ff0000">What does meta mean?</font></b> </p>
<p>In computer jargon, the term meta is often used to identify
something that
provides information about other information. </p>
<p><b><font color="#ff0000">Stock and bond price information</font></b>
</p>
<p>For example, consider the listings of stock prices, bond prices, and
mutual fund prices that commonly appear in most daily newspapers. </p>
<p>The various tables on the page provide information about the bid and
ask prices for the various stock, bond, and mutual fund instruments. </p>
<p><b><font color="#ff0000">What you need is meta information</font></b>
</p>
<p>But, how do you read those charts?&nbsp; How do you extract
information from the charts?&nbsp; You need some information about the
information contained in the charts.&nbsp; You need some meta
information. </p>
<p><b><font color="#ff0000">Stock and bond meta information</font></b> </p>
<p>Usually somewhere on the page, you will find an explanation as to
how to
interpret the information presented throughout the remainder of the
page. </p>
<p>You could probably think of the information contained in the
explanation as meta information. It provides information about other
information. </p>
<p><b><font color="#ff0000">What about the alphabetical index in a book?</font></b>
</p>
<p><font color="#000000">Is the alphabetical index of a book a form of
meta information?&nbsp; Probably so.</font> </p>
<p><font color="#000000">For example, the alphabetical index can tell
you if the book contains information about XML or other topics of
interest to you.&nbsp; If so, it will tell you where in the book you
can find that information.</font> </p>
<p><font color="#000000">The index can also tell you where to find
information about <i>elements</i> and <i>attributes</i> that I will
discuss later.&nbsp; So, yes, in my opinion, the alphabetical index in
a book provides meta information.</font> </p>
<p><b><font color="#ff0000">So, why might people refer to XML as a meta
language?</font></b> </p>
<p>If you write a book and maintain its content in XML, XML doesn't
tell you
how to structure the document that represents your book. </p>
<p><b><font color="#ff0000">XML provides a set of rules for structuring</font></b>
</p>
<p>Rather, XML provides you with a set of rules that you can use to
establish your own structure and content when you create the document
that represents your book. </p>
<p>XML is not the language that you use to establish the structure and
content of your book.&nbsp; Rather, XML tells you how to create your
own language for creating structure and maintaining content. </p>
<p>It is up to you to decide how you will use those rules to define
your own
language for establishing the structure and content of your book. </p>
<p><b><font color="#ff0000">Invent your own language</font></b> </p>
<p>You might say that XML is a language that provides information about
a new language that you are free to invent. </p>
<p><b><font color="#ff0000">Does everyone use a different language?</font></b>
</p>
<p>As it turns out, different groups of people having common interests
have gotten together and have used XML to invent a common language by
which the persons in the group can create, maintain, and exchange
document structure in their areas of interest. </p>
<p><b><font color="#ff0000">The Chemical Markup Language</font></b> </p>
<p>For example, a group of <a
 href="http://www.ch.ic.ac.uk/omf/cml/doc/dtd/index.html">chemists</a>
has gotten together and has used the XML rules to invent a common
language by which they create and exchange structured documents on
chemistry.
</p>
<p><b><font color="#ff0000">MathML</font></b> </p>
<p>Similarly, a group of <a
 href="http://www.w3.org/1999/07/REC-MathML-19990707/appendixA.html">mathematicians</a>
has gotten together and has invented a common language by which they
create and exchange structured documents on mathematics. </p>
<p><b><font color="#ff0000">XML is easily transported</font></b> </p>
<p>If you follow the rules for creating an XML document, the document
that you create can easily be transported among various computers and
rendered in a variety of different ways. </p>
<p><b><font color="#ff0000">Two different renderings</font></b> </p>
<p>For example, you might want to have two different renderings of your
book. One rendering might be in conventional printed format and the
other rendering might be in an online format. </p>
<p><b><font color="#ff0000">No requirement to modify the XML source
document</font></b> </p>
<p>The use of XML makes it practical to render your book in two or more
different ways without any requirement to modify the original document
that
you produce. </p>
<p>This leads to the name: e<b>X</b>tensible <b>M</b>arkup <b>L</b>anguage
or <b>XML</b>. </p>
<p><b><font color="#ff0000">Applying XML</font></b> </p>
<p>Now let's look at a couple of sample XML documents, either of which
might reasonably represent the simple book presented earlier. </p>
<p>The first sample XML document is shown in Listing 1.</p>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br>&lt;book&gt;<br>  &lt;chap&gt;<br>    Text for Chapter 1<br>  &lt;/chap&gt;<br><br>  &lt;chap&gt;<br>    Text for Chapter 2<br>  &lt;/chap&gt;<br>&lt;/book&gt;<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This example shows typical XML syntax. </p>
<p><b><font color="#ff0000">Compare with earlier book description</font></b>
</p>
<p>If you compare this example with the informal book example given
earlier in Figure 3, you should see a one-to-one correspondence between
the <i>"elements"</i> in this XML document and the informal
description of the book presented earlier. </p>
<p><b><font color="#ff0000">An improved example</font></b> </p>
<p>Listing 2 shows a modest improvement over the XML code in Listing 1,
by including an <i>"attribute"</i> named <b>number</b> in each of the
chapter elements.&nbsp; This attribute contains the chapter number and
is part of the information that defines the structure of the book.&nbsp;</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br>&lt;book&gt;<br>  &lt;chap <b>number="1"</b>&gt;<br>    Text for Chapter 1<br>  &lt;/chap&gt;<br><br>  &lt;chap <b>number="2"</b>&gt;<br>    Text for Chapter 2<br>  &lt;/chap&gt;<br>&lt;/book&gt;<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The book represented by the XML code in Listing 2 has two chapters
with some text in each chapter.&nbsp; This XML code contains an <i>attribute</i>
that describes the chapter number in each chapter <i>element</i>. </p>
<p>Now consider a new jargon word: <i>tag</i>. </p>
<p><b><font color="#ff0000">What is a tag?</font></b> </p>
<p>The common jargon for XML items <i>(such as those shown in Figure 4)</i>
enclosed in angle brackets is <i>tag</i>.&nbsp; <i>(You may be
familiar with this jargon based on HTML experience.)&nbsp;</i></p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>&lt;book&gt;</b><br></pre>
      <pre><b>Figure 4</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">Start tags and end tags</font></b> </p>
<p>The tag shown in Figure 4 is often referred to as a <i>start tag</i>
or a <i>beginning tag</i>. </p>
<p>The tag shown in Figure 5 is often referred to as an <i>end tag</i>.
<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>&lt;/book&gt;</b><br></pre>
      <pre><b>Figure 5</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">The end tag contains a slash</font></b> </p>
<p>What is the difference between a <i>start</i> tag and an <i>end</i>
tag?&nbsp; In this case, the <i>start tag</i> and the <i>end tag</i>
differ only in that the end tag contains a slash character. </p>
<p><b><font color="#ff0000">Sometimes there are other differences</font></b>
</p>
<p>However, the start tag can also contain optional <i>attributes</i>
as discussed
below.&nbsp; <i>(There is also another form where the start tag and
end tag
are combined into something often called an empty element.)</i> </p>
<p><b><font color="#ff0000">What is an element?</font></b> </p>
<p>It is time to learn the meaning of the jargon <i>element, content, </i>and
<i>attribute.</i><br>
</p>
<p>Using widely accepted XML jargon, I will call the sequence of
characters in Figure 6 an <a
 href="http://www.w3.org/TR/PR-xml.html#sec-starttags">element</a>. </p>
<p>An element begins with a <i>start tag</i> and ends with an <i>end
tag</i> and includes everything in between.&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>&lt;chap <font color="#3333ff">number="1"</font>&gt;<font
 color="#009900">Text for Chapter 1</font>&lt;/chap&gt;<br></pre>
      <pre><b>Figure 6</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">Color coded for clarity</font></b> </p>
<p>I used artificial color coding in Figure 6 to make it easier to
refer to
the different parts of the element. </p>
<blockquote>
  <p><i>(Note however, that because an XML document is maintained in </i><i>plain
text, the characters in an XML document do not have color properties.)</i>
  </p>
</blockquote>
<p><b><font color="#ff0000">What is the content?</font></b> <br>
</p>
<p>The characters in between the tags <i>(rendered in green in Figure
6)</i> constitute the <a href="http://www.ucc.ie/xml/#FAQ-TERMS">content</a>.&nbsp;
<i>(For more information on content, use your browser to search for the
word content in <a href="http://www.ucc.ie:8080/cocoon/xmlfaq">The XML
FAQ</a>.)</i> </p>
<p><b><font color="#ff0000">What is an attribute?</font></b> </p>
<p>The characters rendered in blue in Figure 6 constitute an attribute.
</p>
<p><b><font color="#ff0000">To recap&nbsp;</font></b><b><font
 color="#ff0000">so you will remember it</font></b> </p>
<p>An element consists of a <i>start tag</i> and an <i>end tag</i>
with the content being sandwiched in between the two tags.&nbsp; The <i>content</i>
is part of the <i>element</i>. </p>
<p><b><font color="#ff0000">May include optional attributes</font></b> </p>
<p>The <i>start tag</i> may contain optional <i>attributes</i>.&nbsp;
In this
example, a single <i>attribute</i> provides the number value for the
chapter.&nbsp;
The start tag can contain any number of attributes, including none. </p>
<p><b><font color="#ff0000">Tell me more about attributes</font></b> </p>
<p>The term <i>attribute</i> is a commonly used term in computer
science and
usually has about the same meaning, regardless of whether the
discussion revolves
around XML, Java programming, or database management. </p>
<p><b><font color="#ff0000">Attributes belong to things, or things have
attributes</font></b> </p>
<p>A chapter in a book is a thing.&nbsp; A chapter has a number.&nbsp;
In this example, the chapter number is an attribute of the chapter
element. </p>
<p>An apple has a color, red or green.&nbsp; An apple also has a taste,
sweet or sour. </p>
<p>A dog has a size, small, medium, or large. </p>
<p>In the above statements, <i>number, color, taste, </i>and<i> size</i>
are
attributes.&nbsp; Those attributes have values like <i>red, green,
sweet, sour, small, medium, </i>and<i> large</i>. </p>
<p>As you can see, attributes are a very common part of the world in
which we live and work. </p>
<p><b><font color="#ff0000">People have attributes</font></b> </p>
<p>A person also has attributes, and each attribute has a value. </p>
<p>Figure 7 contains a list of some of the attributes <i>(along with
their values)</i> that might be used to describe a person.&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>name="Joe"<br>height="84"<br>weight="176"<br>complexion="pale"<br>sex="male"<br>training="Java programmer"<br>degree="Masters"<br></pre>
      <pre><b>Figure 7</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Obviously, there are many more attributes that could be used to
describe a person. </p>
<p><b><font color="#ff0000">The importance of an attribute depends on
the context</font></b> </p>
<p>The decision as to which of many possible attributes are important
depends on the context in which the person is being considered. </p>
<p><b><font color="#ff0000">Attributes for basketball players</font></b>
</p>
<p>For example, if the person is being considered in the context of
being a candidate for an all male basketball team, the <i>height,
weight,</i> and <i>sex</i> attributes of a person will probably be
important considerations. </p>
<p><b><font color="#ff0000">Attributes for programmers</font></b> </p>
<p>On the other hand, if the person is being considered in the context
of being a candidate for employment as a programmer, the <i>height,
weight, </i>and<i> sex </i>attributes should not be important at all,
but the <i>training</i> and <i>degree</i> attributes might be very
important. </p>
<p><b><font color="#ff0000">Why does XML use attributes?</font></b> </p>
<p>Earlier in this lesson, I suggested that the most common <i>modern </i>use
of the word <i>rendering</i> means to present something for human
consumption.&nbsp; Usually, but not always, that refers to visual
consumption.&nbsp; <i>(My grandmother used to render fat to make soap,
but that is not modern usage of the term.)</i> </p>
<p><b><font color="#ff0000">Multiple renderings for the same document</font></b>
</p>
<p>I gave an example of a newspaper that can either be rendered on
newsprint paper, or can be rendered on a computer screen. </p>
<p><b><font color="#ff0000">What is a rendering engine?</font></b> </p>
<p>If the newspaper <i>(structured document)</i> is created and
maintained as an XML document, then some sort of computer program <i>(often
referred to as a rendering engine)</i> will probably be used to <i>render</i>
it into the desired presentation format. </p>
<p><b><font color="#ff0000">What about rendering our book?</font></b> </p>
<p>Our book could also be rendered in a variety of different ways. </p>
<p>Regardless of how the book is rendered, it will probably be useful
to separate and number the chapters. </p>
<p>The value of the <i>number</i> attribute for each <i>chapter </i>element
could be used by the rendering engine to present the chapter number for
a specific rendering. </p>
<p><b><font color="#ff0000">Chapter numbers may be rendered differently</font></b>
</p>
<p>In some renderings, the number might appear on an otherwise blank
page that begins a new chapter.&nbsp; This is common in printed books,
but is not common in online presentations. </p>
<p>In a different rendering, the chapter number might appear in the
upper right or left-hand corner of each page. </p>
<p><b><font color="#ff0000">Separation of content from presentation</font></b>
</p>
<p>To reiterate, one of the most important characteristics of XML <i>(as
opposed to <a href="http://www.w3.org/MarkUp/">HTML</a>) </i>is that
XML separates
content from presentation. </p>
<p>The XML document contains information about structure and
content.&nbsp; It does not contain presentation information <i>(as
does HTML).</i> </p>
<p><b><font color="#ff0000">Presentation of XML requires a rendering
engine</font></b> </p>
<p>The presentation of an XML document requires the use of a rendering
engine of some sort to render the XML document in a particular
presentation style. </p>
<p><b><font color="#ff0000">IE 5.0 (and later) contains a rendering
engine</font></b> </p>
<p>As an example of rendering, IE 5.0 <i>(and later versions)</i>
contains a rendering engine for XML.&nbsp; When provided with an XML
document and no rendering instructions, IE will render the XML document
in a default format similar to that shown in Figure 8.<br>
</p>
<p align="center"><img src="java2200a.gif"
 alt="Fig 8 IE Rendering of XML file" width="371" height="509"> <br>
</p>
<p align="center">Figure 8 IE Rendering of XML File<br>
</p>
<p> This default rendering of an XML document is designed to emphasize
the tree structure of an XML document.&nbsp; With the IE default
rendering, the nodes in the tree can be collapsed and expanded by
clicking the - and + symbols on the left, much as you can collapse and
expand the nodes in Windows Explorer <i>(File Manager).</i><br>
</p>
<p>When provided with an XML document and appropriate rendering
instructions <i>(such as an XSLT document),</i> IE can transform XML
data into HTML data and render it in the browser window in different
formats. </p>
<p><b><font color="#ff0000">What is an XSLT document?</font></b> </p>
<p>I will have a lot to say about the Extensible Stylesheet Language <i>(XSL),</i>
and stylesheet transformations <i>(XSLT)</i> in future lessons. </p>
<p><b><font color="#ff0000">Attributes may be useful in rendering</font></b>
</p>
<p>Now getting back to attributes, they provide information about XML
elements that may be useful to the rendering engine. </p>
<p>If the attribute values for an element are not important in a
particular presentation context, the rendering engine for that context
will simply ignore them.&nbsp; If they are important in a particular
context, the rendering engine will use them.<br>
</p>
<blockquote><i>(The default IE rendering engine makes no use of
attributes, but does display them along with the other information in
the XML document.)</i></blockquote>
<p> </p>
<p><font color="#ff0000"><b>Elements, content, etc.</b></font><br>
</p>
<p>So far in this lesson, I have introduced <i>tags</i>, <i>elements</i>,
<i>content</i> and <i>attributes</i>.&nbsp; I have discussed <i>tags</i>
and <i>attributes</i> in detail.&nbsp; Now let's continue the
discussion with particular emphasis on <i>elements</i> and <i>content</i>.
</p>
<p><b><font color="#ff0000">What is meant by content?</font></b> </p>
<p>You already know about <i>start tags</i> and <i>end tags</i>.&nbsp;
You also know that an element consists of a <i>start tag</i> <i>(with
optional attributes),</i> an <i>end tag</i>, and the <i>content</i>
in between as shown in Figure 9.<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>&lt;chapter <font color="#3333ff">number="1"</font>&gt;<font
 color="#009900">Content for Chapter 1</font>&lt;/chapter&gt;<br></pre>
      <pre><b>Figure 9</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>In Figure 9, the optional attribute is colored blue and the content
is colored green.<br>
</p>
<blockquote>
  <p><i>(Recall however, that because an XML document is maintained in </i><i>plain
text, the characters in an XML document do not have color
properties.&nbsp; I used color in this lesson simply to aid in the
explanation.)</i> </p>
</blockquote>
<p><b><font color="#ff0000">Elements can be nested</font></b> </p>
<p>Elements can be nested inside other elements in the construction of
the XML document as shown in Figure 10.&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><font color="#3333ff">&lt;book&gt;</font><br>  <font
 color="#009900">&lt;chapter number="1"&gt;</font>Content for Chapter 1<br>  <font
 color="#009900">&lt;/chapter&gt;<br>  &lt;chapter number="2"&gt;</font>Content for Chapter 2<br>  <font
 color="#009900">&lt;/chapter&gt;</font><br><font color="#3333ff">&lt;/book&gt;</font><br></pre>
      <pre><b>Figure 10</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">Color coding and indentation</font></b> </p>
<p>In Figure 10, the tags belonging to the <i>book</i> element are
shown in
blue while the tags belonging to the <i>chapter</i> elements are shown
in
green. </p>
<p>I also provided artificial indentation to make it easier to see that
two <i>chapter</i> elements are nested inside a single <i>book</i>
element. </p>
<p><b><font color="#ff0000">Indentation is common</font></b> </p>
<p>Such indentation is common in the presentation of raw XML data for
human consumption.&nbsp; For example, the default rendering of an XML
document by IE is an indented tree structure as shown in Figure 8. </p>
<p><b><font color="#ff0000">Identify the elements</font></b> </p>
<p>The <i>book</i> element consists of its <i>start tag</i>, its <i>end
tag</i>, and everything in between <i>(including nested elements),</i>
as shown in Figure 11.</p>
<p> </p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><font color="#3333ff">&lt;book&gt;</font><br>  ...<br><font
 color="#3333ff">&lt;/book&gt;</font><br></pre>
      <pre><b>Figure 11</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Each <i>chapter</i> element consists of its <i>start tag</i>, its <i>end
tag</i>, and everything in between, as shown in Figure 12.</p>
<p> </p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>  <font color="#009900">&lt;chapter number="1"&gt;</font><br>    ...<br>  <font
 color="#009900">&lt;/chapter&gt;</font></pre>
      <pre><b>Figure 12</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">Content of the book element</font></b> </p>
<p>In this case, the two <i>chapter</i> elements form the <i>content</i>
of
the <i>book</i> element. </p>
<p><b><font color="#ff0000">So, what is an element?</font></b> </p>
<p>The <i>element</i> is the fundamental unit of information in an XML
document.&nbsp; Most XML processing programs <i>(such as rendering
engines)</i> depend on this fundamental unit of information in order to
do their job. </p>
<p><b><font color="#ff0000">An XML document is an element</font></b> </p>
<p>The entire XML document is an <i>element.&nbsp; </i>As shown in
Listing 2, the entire XML document consists of the <i>book</i>
element.&nbsp; It is often referred to as the <i>root</i> element. </p>
<p>To be of much use, an XML document must have other elements nested
inside the root element.&nbsp; For example, a nested <i>element</i>
can define some type of information, such as <i>chapter</i> in our
book example. Other possibilities would be <i>table</i> elements and <i>appendix</i>
elements. </p>
<p><b><font color="#ff0000">Meta information</font></b> </p>
<p>Through the use of attributes, the <i>element</i> often defines
information about the information provided by the XML document <i>(sometimes
referred to as meta information).</i> </p>
<p>In our book example, the <i>number</i> attribute provides the
chapter number
for each of the <i>chapter</i> elements. In effect, the chapter number
is
information about the information contained in the chapter. </p>
<p><b><font color="#ff0000">The content</font></b> </p>
<p>Sandwiched in between the <i>start tag</i> and the <i>end tag</i>
of an element, we find the information (<i>content</i>) that the XML
document is designed to convey. </p>
<p><b><font color="#ff0000">So, what are elements good for?</font></b> </p>
<p>By using a well-defined structure <i>(based on XML elements)</i> to
create and maintain your document, you make it much easier to write
computer programs that can be used to render, and otherwise process
your document. </p>
<p><b><font color="#ff0000">Writing programs to process XML documents</font></b>
</p>
<p> </p>
<p>At some point, you might want to visit one of my earlier articles
entitled <i>"What is SAX, Part 1."</i><br>
</p>
<blockquote><i>(You will find a link to that article at <a
 href="http://www.dickbaldwin.com">www.dickbaldwin.com</a>.)</i></blockquote>
<p> </p>
<p>That article describes how to write computer programs <i>(using the
Java programming language)</i> that decompose an XML document into its <i>elements</i>
for some useful purpose. </p>
<p>In those articles, I explain that SAX supports an event-based
approach to XML document processing.&nbsp; <i>(If you have a
background in event-driven programming, such as Java or Visual Basic,
you will like the SAX approach.)</i> </p>
<p><b><font color="#ff0000">Parsing events</font></b> </p>
<p>An event-based approach reports parsing events <i>(such as the
start and </i><i>end</i> of elements) to the program using <i>callbacks</i>.&nbsp;
The program implements and registers event handlers <i>(callback
methods)</i> for the different events. </p>
<p>Code in the event handlers is designed to achieve the objective of
the program.&nbsp; </p>
<p><b><font color="#ff0000">Not critical to understanding XML</font></b>
</p>
<p>I will have a great deal more to say about processing XML documents
using SAX in future lessons. I realize that a discussion of
event-driven programming for the processing of XML documents might not
be classified as <i>"information for Getting Started with JAXP."</i>&nbsp;
It is not even critical
for an understanding of XML. </p>
<p>However, it is a good way to illustrate the benefits provided by XML
elements.&nbsp;
Don't worry too much about SAX at this at this point.&nbsp; Just keep
studying,
and at some point in the future, it will fall into place. </p>
<p><b><font color="#ff0000">What we have learned so far?</font></b> </p>
<p>So far in this lesson, I have introduced you to <i>tags</i>, <i>elements</i>,
<i>content</i>, and <i>attributes</i>.&nbsp; I have discussed <i>tags,
attributes, </i>and <i>elements</i> in detail. Now, I will discuss
content in detail. </p>
<p><b><font color="#ff0000">What is content?</font></b> </p>
<p>Of the four terms mentioned above, content is the easy one.&nbsp;
Sandwiched in between the <i>start tag</i> and the <i>end tag</i> of
an element, we find the information <i>(content)</i> that the XML
document is designed to convey. </p>
<p>This is where we put the information for which the document was
created. </p>
<p><b><font color="#ff0000">An XML newspaper</font></b> </p>
<p>For example, if the XML document is being used for creation and
maintenance of material for a newspaper, the content is the news. </p>
<p><b><font color="#ff0000">A Java programming textbook</font></b> </p>
<p>If the XML document is being used for creation and maintenance of a
Java programming textbook, the content contains the information about
Java programming that we want to present to the student. </p>
<p><b><font color="#ff0000">Tags, attributes, and elements define
structure</font></b> </p>
<p>The content is the raw information. The tags, attributes, and
elements define the structure into which we insert that information. </p>
<p><b><font color="#ff0000">Why do we need structure?</font></b> </p>
<p>One of the primary objectives of XML is to separate content from
presentation. </p>
<p>If we insert the raw material as content into a structure defined by
the tags, elements, and attributes, then that raw material can be
presented <i>(rendered)</i> in a variety of ways.&nbsp; It can also be
searched in a variety of ways that can produce results that are more
meaningful
than simple keyword searches. </p>
<p><b><font color="#ff0000">Same content, different renderings</font></b>
</p>
<p>For example, an XML document can be used to represent a newspaper. </p>
<p>Then that document can be presented as an ordinary hard copy
newspaper by printing the content on newsprint in a format defined by
the structure.&nbsp; Typically, we would use a rendering engine
designed for that purpose. </p>
<p>The same XML document can be used to present the same information in
a completely different rendering on a computer screen. Again, we would
probably use a rendering engine designed for that purpose. </p>
<p><b><font color="#ff0000">Rendering engine formats the content</font></b>
</p>
<p>In both cases, the rendering engine would examine the structure
defined by the tags, elements, and attributes and would then format and
present the news <i>(content)</i> in a format appropriate for the
presentation media being used. </p>
<p><b><font color="#ff0000">What does the future hold for XML?</font></b>
</p>
<p>Obviously, I believe that XML has a very bright future.&nbsp;
Otherwise, I wouldn't be making the kind of substantial investment in
time and energy that I am making in order to understand XML. </p>
<p>I base this belief on the fact that many large companies, including
Microsoft and IBM have adopted XML as an important part of their
future. </p>
<p><b><font color="#ff0000">XML will grease the skids of electronic
commerce</font></b> </p>
<p>For example, here are some of the things that Simon Phipps, IBM's
chief XML and Java evangelist had to say in his keynote speech at the <i>Software
Development East</i> conference a few years ago.&nbsp;<br>
</p>
<blockquote><i>"Because it allows companies to share information with
customers or business partners without first negotiating technical
details, Extensible Markup Language (XML) will grease the skids of
electronic business
and become the assumed data format at the end of 2001."</i><br>
</blockquote>
<p><b><font color="#ff0000">XML provides vendor independence</font></b>
</p>
<p>Phipps went on to say:&nbsp;</p>
<blockquote>
  <p><i>"Other successful Internet technologies let people run their
systems without having to take into account another company's own
computer systems, notably TCP/IP for networking, Java for programming,
and Web browsers for content delivery. XML fills the data formatting
piece of the puzzle." </i></p>
  <p><i>"These technologies do not create dependencies. It means you
can build solutions that are completely agnostic about the platforms
and software that you use."</i></p>
</blockquote>
<p><b><font color="#ff0000">XML can reduce system costs</font></b> </p>
<p>In the speech, entitled <i>"Escaping Entropy Death"</i> Phipps
noted that users are reaching the point where the cost of simply owning
some systems is exceeding the value they provide.&nbsp;</p>
<blockquote>
  <p><i>"The key benefit to IT managers that adopt XML and other
non-proprietary standards is that they will greatly reduce the cost of
maintaining a computer's systems and will allow them to extend existing
systems." </i></p>
  <p><i>"In the next decade, you can't just ask when can you have [a
new application]. You also have to ask how much will it cost to own."</i></p>
</blockquote>
<p><b><font color="#ff0000">No more vendor-imposed standards</font></b>
</p>
<p>According to Phipps:&nbsp;</p>
<blockquote>
  <p><i>"The solution, interestingly enough, is not constant
innovation. You have to redeem the best of the parts you have and
combine them with the best of the future."</i><br>
  </p>
</blockquote>
<p>Phipps contended that the IT industry has moved on from the era of <i>"vendor-imposed
standards."</i> </p>
<p>This is an interesting observation by a representative from
IBM.&nbsp; I grew up on computers during an era when IBM was the vendor
who imposed the standards. </p>
<p>Some would say that the role of imposing standards has now been
assumed by Microsoft <i>(much to the dismay of IBM management).</i> </p>
<p><b><font color="#ff0000">What about Microsoft and XML?</font></b> </p>
<p>Microsoft is making a huge investment in XML.&nbsp; As mentioned
earlier, Microsoft's IE browser currently supports XML documents, XSL
stylesheets, and XSL transforms.</p>
<blockquote>
  <p><i>(You can find links to several articles that I have previously
written discussing the rendering of XML documents using XSLT at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a>.)</i> </p>
</blockquote>
<p>In addition, many aspects of Microsoft's latest MS.NET product
depend extensively
on XML.<br>
</p>
<p><b><font color="#ff0000">The XSL Debugger from Microsoft</font></b> </p>
<p>XSL is complex <i>(much more complex than XML).</i>&nbsp; Designing
an XSL stylesheet, to be used by a rendering engine to properly render
an XML document, can be a daunting task. </p>
<p>To help us in that regard, Microsoft has developed an XSL debugger,
and has made it freely available for downloading.&nbsp; As of the date
of this writing, the debugger can be downloaded from <a
 href="http://www.vbxml.com/xsldebugger/">http://www.vbxml.com/xsldebugger/</a>.
&nbsp; I will discuss the use of this debugger in future lessons that
discuss the creation of XML processing programs using XSLT and JAXP. </p>
<p><b><font color="#ff0000">Check out XML in MS Word</font></b> </p>
<p>If you happen to have a copy of Microsoft Word around, use it to
create a simple HTML file.&nbsp; Load that file into your HTML browser
and view the source.&nbsp; When you do, you will find XML appearing at
various locations in the control information created by Word in that
HTML document. </p>
<p><b><font color="#ff0000">What we have learned so far?</font></b> </p>
<p>So far in this lesson, I have discussed <i>tags</i>, <i>elements</i>,
<i>content</i>, and <i>attributes</i> in detail.&nbsp; I have also
presented a short sales pitch designed to convince you of the
importance of XML. </p>
<p>Now we are ready to move on to a new set of topics:&nbsp; <i>valid</i>
documents, <i>well-formed</i> documents, and the <i>DTD</i>. </p>
<p><b><font color="#ff0000">What is a DTD?</font></b> </p>
<p>The quotation in Figure 13 was extracted from <a
 href="http://www.ucc.ie:8080/cocoon/xmlfaq">The XML FAQ</a>.<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> "A DTD is usually a file (or several files to be used
together) which contains a formal definition of a particular type of
document. This sets out what names can be used for elements, where
they may occur, and how they all fit together. For example, if you want
a document type to describe &lt;LIST&gt;s which contain &lt;ITEM&gt;s,
part of your DTD would contain something like&nbsp;
      <p>&nbsp;&nbsp;&nbsp;&nbsp; &lt;!ELEMENT item (#pcdata)&gt;&nbsp;
      </p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp; &lt;!ELEMENT list (item)+&gt;&nbsp; </p>
      <p>This defines items containing text, and lists containing
items.&nbsp; </p>
It's a formal language which lets processors
automatically parse a document and identify where every element comes
and how they relate to each other, so that stylesheets, navigators,
browsers, search engines, databases, printing routines, and other
applications
can be used."<br>
      <br>
      <b>Figure 13</b> </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">DTDs can be very complicated</font></b> </p>
<p>I included the above quotation to emphasize one important point &#8211;
DTDs are, or can be, very complicated. </p>
<p>The reality is that the creation of a DTD of any significance is a
very complex task. </p>
<p><b><font color="#ff0000">Don't panic</font></b> </p>
<p>However, despite their complexity, many of you will never need to
worry about having to create DTDs for the following two reasons: </p>
<ul>
  <li>XML does not require the use of a DTD.</li>
  <li> Even when it is necessary to use a DTD, someone else may have
already created it for you.</li>
</ul>
Many "standard" DTDs have already been developed and are available for
your use without any requirement for you to develop them.
<p><b><font color="#ff0000">The three amigos</font></b> </p>
<p>An XML document has two very close friends, one of which is
optional. </p>
<p>I'm going to refer to them as three files just so I will have
something to call them <i>(but they don't have to be separate physical
files).</i> </p>
<p><b><font color="#ff0000">One file contains the content</font></b> </p>
<p>One file contains the content of the document <i>(words, pictures,
etc.).</i>&nbsp; This is the part that the author wants to expose to
the client. This file contains the XML code that I have been discussing
up to this point. </p>
<p>This is the file that is composed of elements, having start tags,
end tags,
attributes, and content.&nbsp; For convenience, the file name often has
an
extension of xml, although that is not a requirement. </p>
<p><b><font color="#ff0000">A second file contains the DTD</font></b> </p>
<p>A second file contains the DTD, which meets the above definition
that was
extracted from the <a href="http://www.ucc.ie/xml/">FAQ</a>.&nbsp;
This file
is optional.<br>
</p>
<blockquote><i>(Note that a modern alternative to the DTD is often
called a schema.&nbsp; A schema, when it is available, serves the same
purpose as a DTD, but is often more powerful.&nbsp; I will have more to
say about schema in future lessons.)</i><br>
</blockquote>
<p> </p>
<p><b><font color="#ff0000">A third file contains a stylesheet</font></b>
</p>
<p>A third file contains a stylesheet, which establishes how the
content <i>(that
optionally conforms to the DTD)</i> is to be rendered on the output
device
for a particular application. </p>
<p>This file defines how the author wants the material to be presented
to the client. </p>
<p><b><font color="#ff0000">Rendering the XML document</font></b> </p>
<p>Different stylesheets are often used with the same XML data to cause
that data to be rendered in different ways.&nbsp; For example a tag
with an attribute of "red" might cause something to be presented bright
red according to one stylesheet and dull red according to another
stylesheet.&nbsp; <i>(It might even be presented as some shade of
green according to still another stylesheet, but that wouldn't be a
very good design.)</i> </p>
<p><b><font color="#ff0000">DTD is optional, stylesheet is not</font></b>
</p>
<p>With XML, the DTD is optional but the stylesheet <i>(or some
processing mechanism that substitutes for a stylesheet)</i> is
required.&nbsp; At least that is true if the XML document is ever to be
rendered for the
benefit of a client. </p>
<p><b><font color="#ff0000">Something must provide rendering
specifications</font></b> </p>
<p>Remember, XML separates content from presentation.<br>
</p>
<blockquote><b>There is no presentation information in the XML document
itself</b>. </blockquote>
<p>Therefore, rendering specifications must be provided to make it
possible to render the content of the XML document in the manner
intended by the author. </p>
<p><b><font color="#ff0000">A stylesheet is typical, but not required</font></b>
</p>
<p>Typically, the rendering specifications are contained in a
stylesheet.&nbsp; The stylesheet is used by a rendering engine to
render the XML document according to the specifications in the
stylesheet. </p>
<p>However, it is possible that the specifications could be hard-coded
into a program written specifically for the purpose of rendering the
XML document.&nbsp; In that case, a stylesheet might not be required. </p>
<p><b><font color="#ff0000">Rendering XML with XSL and MS IE</font></b>
</p>
<p>As mentioned earlier, I have published several articles that deal
with using IE to render XML using stylesheets written in XSL.&nbsp; You
will find links to those articles at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a>. </p>
<p>Now back to the DTD. </p>
<p><b><font color="#ff0000">A DTD can be very complex</font></b> </p>
<p>Again, according to <a href="http://www.ucc.ie:8080/cocoon/xmlfaq">The
XML FAQ</a>,&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>"... the design and construction of a DTD can be a complex
and non-trivial task, so XML has been designed so it can be used either
      <b>with or without</b> a DTD.&nbsp; DTDless&nbsp; operation means
you can invent markup without&nbsp; having to define it formally.&nbsp;
      <p>To make this work, a DTDless file in effect 'defines&#8217; its own
markup, informally, by the existence and location of elements where you
create them.&nbsp; </p>
      <p>But when an XML application such as a browser encounters a
DTDless file, it needs to be able to understand the document structure
as it reads it, because it has no DTD to tell it what to expect, so
some changes have been made to the rules."</p>
      <b>Figure 14</b> </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">What does this really mean?</font></b> </p>
<p>It means that it is possible to create and process an XML document
without the requirement for a DTD.&nbsp; A little later, I will discuss
this possibility in connection with the term <i>well-formed</i>. </p>
<p><b><font color="#ff0000">In the meantime...</font></b> </p>
<p>You don't always have the luxury of avoiding the DTD.&nbsp; In some
situations, you may be required to create an XML document that meets
specifications that someone else has defined. </p>
<p><b><font color="#ff0000">Hopefully, a DTD will be available</font></b>
</p>
<p>Ideally, in those cases, the person who defined the specifications
has also created a DTD and can provide it to you for your use. </p>
<p><b><font color="#ff0000">A&nbsp;valid document</font></b> </p>
<p>Here is a new term -- a <i>valid</i> XML document. </p>
<p>In the normal sense of the word, if something is not <i>valid,</i>
that usually means that it is not any good.&nbsp; However, that is not
the case for XML. </p>
<p><b><font color="#ff0000">An <i>invalid</i> XML document can be a
good XML
document</font></b> </p>
<p>An <i>invalid</i> XML document can be a perfectly good and useful
XML document.&nbsp;
A very large percentage of useful XML documents are not valid XML
documents.
</p>
<p><b><font color="#ff0000">So, what is a valid XML document?</font></b>
</p>
<p>Drum roll please!!!&nbsp; Without further delay, a <i>valid</i> XML
document is one that conforms to an existing DTD in every respect. </p>
<p><b><font color="#ff0000">For example...</font></b> </p>
<p>Unless the DTD allows an element with the name <i>"color"</i>, an
XML document
containing an element with that name is not valid according to that DTD
<i>(but
it might be valid according to some other DTD).</i> </p>
<p><b><font color="#ff0000">Validity is not a requirement of XML</font></b>
</p>
<p>Many very useful XML documents are not valid, simply because they
were not constructed according to an existing DTD. </p>
<p>To make a long story short, validation against a DTD can often be
very useful, but may not be required. </p>
<p><b><font color="#ff0000">A&nbsp;well-formed document</font></b> </p>
<p>Here is another new term -- a <i>well-formed</i> document. </p>
<p>The concept of being well-formed was introduced as a requirement of
XML, to deal with the situation where a DTD is not available <i>(an
invalid document).</i> </p>
<p>Again, according to <a href="http://www.ucc.ie:8080/cocoon/xmlfaq">The
XML FAQ</a>,&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>"For example, HTML's &lt;IMG&gt; element is defined as
'EMPTY': it doesn't have an end-tag. Without a DTD, an XML application
would have no way to know whether or not to expect an end-tag for an
element, so the concept of '<b><i>well-formed'</i></b> has been
introduced.
      <p>This makes the start and end of every element, and the
occurrence of EMPTY elements completely unambiguous."</p>
      <b>Figure 15</b> </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">What is an HTML &lt;IMG&gt; tag?</font></b>
</p>
<p>Although you may not know anything about the HTML &lt;IMG&gt; tag,
you do know about <i>start tags</i> and <i>end tags</i> from previous
discussion in this article. </p>
<p>Although HTML is related to XML <i>(a distant cousin that combines
content and presentation in the same document),</i> HTML documents are
not required to be well-formed. </p>
<p>The quotation in Figure 15 refers to the use of a <i>start</i> tag <i>(&lt;IMG&gt;)</i>
in HTML that doesn't require an <i>end</i> tag.&nbsp; If used in that
manner in an XML document, the document would not be well-formed. </p>
<p><b><font color="#ff0000">All XML documents must be well-formed</font></b>
</p>
<p>XML documents need not be valid.&nbsp; However:<b><br>
</b></p>
<blockquote><b>All XML documents must be well-formed</b>. </blockquote>
<p><b><font color="#ff0000">What does it mean to be well-formed?</font></b>
</p>
<p>For a rigorous definition of a well-formed document, see <a
 href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-well-formed">http://www.w3.org/TR/2000/REC-xml-20001006#sec-well-formed</a>.<br>
</p>
<p>From a somewhat less rigorous viewpoint, XML documents must adhere
to the
following rules to be <a
 href="http://www.developerfusion.com/show/1704/2/">well-formed</a>. </p>
<ul>
  <li>Every start-tag must have a matching end-tag.&nbsp; All elements
that can contain character data must have both start and end
tags.&nbsp; <i>(Empty elements have a different requirement, which I
will discuss later.)</i> </li>
  <li>Tags can't overlap.&nbsp; In other words, all elements must be
properly nested.&nbsp; If one element contains another element, the
entire second element must be defined inside the start and end tags of
the first element.</li>
  <li>XML documents can have only one root element. </li>
  <li>Element names must obey XML naming conventions </li>
  <li>XML is case sensitive </li>
  <li>XML will keep white space in your text </li>
</ul>
<p><b><font color="#ff0000">What is <i>character data?</i></font></b> </p>
<p>Although not rigorously true, for purposes of this discussion, let's
just say that the <i>content</i> that we discussed in an earlier
section comprises character data. </p>
<p><b><font color="#ff0000">Other requirements</font></b> </p>
<p>All attribute values must be in quotes <i>(apostrophes or double
quotes).</i>&nbsp; You already know about attributes.&nbsp; I discussed
them earlier in this lesson. </p>
<p>You can surround the value with apostrophes <i>(single quotes)</i>
if the
attribute value contains a double quote.&nbsp; Conversely, an attribute
value
that is surrounded by double quotes can contain apostrophes. </p>
<p><b><font color="#ff0000">Dealing with empty elements</font></b> </p>
<p> </p>
<p><font color="#000000">We must also deal with empty elements.&nbsp;
Empty elements are those that don't contain any character data.&nbsp; </font>You
can deal with empty elements by writing them in either of the two ways
shown in Figure 16.</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> <b><font face="Arial Narrow"><font size="-1">&lt;book&gt;&lt;/book&gt;</font></font></b>
      <p><b><font face="Arial Narrow"><font size="-1">&lt;book/&gt;</font></font></b></p>
      <b>Figure 16</b> </td>
    </tr>
  </tbody>
</table>
<p>You will recognize the format of the first line as simply writing a
start tag followed immediately by an end tag with nothing in
between.&nbsp; The format of the second line in Figure 16 has a slash
at the end of the word book. </p>
<p><b><font color="#ff0000">The second format is preferable</font></b> </p>
<p>This is the first time in this lesson that I have mentioned the
second format, which is actually preferable. </p>
<p>One reason the second format is preferable is that because of word
wrap and other causes, you could end up with the first format in Figure
16 being converted to that shown in Figure 17.</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> <b><font face="Arial Narrow"><font size="-1">&lt;book&gt;</font></font></b>
      <br>
      <b><font face="Arial Narrow"><font size="-1">&lt;/book&gt;</font></font></b><br>
      <br>
      <b>Figure 17</b> </td>
    </tr>
  </tbody>
</table>
<p><b><font color="#ff0000">Really not empty</font></b> </p>
<p>Once this happens, although the element may look empty to you, it
really isn't empty.&nbsp; Rather it contains whatever characters are
used by that platform to represent a <i>newline</i> character
sequence. </p>
<p>Typically a newline is either a carriage return character, a line
feed character, or a combination of the two.&nbsp; While these
characters are not visible, their presence will cause an element to be <i>not
empty.</i> </p>
<p>If an element is supposed to be empty, but it is not really empty,
this can cause problems when the XML file is processed. </p>
<p><b><font color="#ff0000">The preferred approach</font></b> </p>
<p>So, to reiterate, the preferred approach for representing an empty
element is as shown by the second line in Figure 16. </p>
<p><b><font color="#ff0000">Empty element can contain attributes</font></b>
</p>
<p>Note that an empty element can contain one or more attributes inside
the start tag, as shown in by the example in Figure 18.</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td> <b><font face="Arial Narrow"><font size="-1">&lt;book
author="baldwin" price="$9.95" /&gt;</font></font></b><br>
      <br>
      <b>Figure 18</b> </td>
    </tr>
  </tbody>
</table>
<p><font color="#000000">Again, note the slash character at the end.</font>
</p>
<p><b><font color="#ff0000">Another rule: &nbsp;No markup characters
are allowed</font></b>
</p>
<p>For a document to be well-formed, it must not have markup characters
<font face="Arial Narrow">(<b>&lt;</b>, <b>&gt;</b>, or <b>&amp;</b>)</font>
in the text data. </p>
<p><b><font color="#ff0000">What is a markup character?</font></b> </p>
<p>Since the <b><font face="Arial Narrow">&lt;</font> </b>character
represents the beginning of a new tag, if it were included in the text
data, it would cause the processor to become confused.&nbsp; Similarly,
because the <b>&gt;</b> character represents the end of a tag,
inclusion of
that character in the text data can also cause problems. &nbsp;The
solution to this problem <i>(entities, as described below)</i> also
makes it necessary
to exclude the <b><font face="Arial Narrow">&amp;</font></b> character
from the text data. </p>
<p><b><font color="#ff0000">The solution</font></b> </p>
<p>If you need for your text to include the <b><font
 face="Arial Narrow">&lt;</font></b> character, the <b>&gt;</b>
character, or the <b><font face="Arial Narrow">&amp;</font></b>
character, you can represent them
using <b><font face="Arial Narrow">&amp;lt;</font></b>&nbsp;<b><font
 face="Arial Narrow">&amp;gt;</font></b> and <b><font
 face="Arial Narrow">&amp;amp;</font></b> instead. &nbsp;<i>(Note that
I purposely
omitted the use of a comma in this list of entities to avoid having a
comma
become confused with the required syntax for an entity, which always
begins
with an ampersand and always ends with a semicolon.)</i> </p>
<p><b><font color="#ff0000">Entities</font></b> </p>
<p>According to the prevailing jargon, these are called entities.&nbsp;
You insert them into your text in place of the prohibited characters. </p>
<p>Entities always start with an ampersand character and end with a
semicolon.&nbsp; It is that combination of characters that the
processor uses to distinguish them from ordinary text.<br>
</p>
<p><font color="#ff0000"><b>Other common entities</b></font><br>
</p>
<p>Although it may not be necessary for well-formedness, it is also
common practice to use an entity to represent the quotation mark
character (") by the entity <b>&amp;quot;</b>. &nbsp;It is also
possible to use an entity to
represent many other characters, including characters that don't appear
on
a standard English-language keyboard.<br>
</p>
<ul>
</ul>
<b><font color="#ff0000">Recap of validity and well-formed requirements</font></b>
<p>Valid XML files are those which have <i>(or refer to)</i> a DTD and
which conform to the DTD in all respects. </p>
<p>XML files must be well-formed, but there is no requirement for them
to be valid.&nbsp; Therefore, a DTD is not required, in which case
validity is impossible to establish. </p>
<p>If XML documents do have or refer to a DTD, they must conform to it,
which makes them valid. </p>
<p><b><font color="#ff0000">Why use a DTD if it is not required?</font></b>
</p>
<p>There are several reasons to use a DTD, in spite of the fact that
XML doesn't
require one. </p>
<p><b><font color="#ff0000">Enforcing format specifications</font></b> </p>
<p>Suppose, for example, that you have been charged with publishing a
weekly newsletter, and you intend to produce the newsletter as an XML
file. </p>
<p>Suppose also that you occasionally have a guest editor who produces
the newsletter on your behalf. </p>
<p><b><font color="#ff0000">Establish format specifications</font></b> </p>
<p>You will probably establish a set of format specifications for your
newsletter and you will need to publish those specifications for the
benefit
of the guest editors. </p>
<p><b><font color="#ff0000">No guarantee of compliance</font></b> </p>
<p>However, simply publishing a document containing format
specifications does not ensure that the guest editors will comply with
the specifications. </p>
<p><b><font color="#ff0000">Use a DTD to enforce format specifications</font></b>
</p>
<p>You can enforce the format specifications by also establishing a DTD
that matches the specifications. </p>
<p>Then, if either you, or one of your guest editors produces an XML
document that doesn't meet the specifications, the XML processor that
you use to render your newsletter into its final form will notify you
that the document is not valid. </p>
<p><b><font color="#ff0000">Improved parser diagnostic data</font></b> </p>
<p>Another reason that I have found a DTD to be useful is the
following. </p>
<p>I am occasionally called upon to write a Java program that will
parse and
process an XML document in some fashion. </p>
<p>My experience is that the parsers that I have used are much more
effective in identifying XML structural problems when the XML document
has a DTD than when it doesn't. </p>
<p>By this I mean that often the diagnostic information provided by the
parser is more helpful when the XML document has a DTD. </p>
<p>This tends to make it easier to repair the document because a
validating parser does a better job of isolating the problem. </p>
<p><font color="#ff0000"><b>More than you wanted to know</b></font><br>
</p>
<p>And that is probably more than you ever wanted to know about
XML.&nbsp; Now it's time to terminate this review of XML and get to the
meat of this series of tutorial lessons - using Java JAXP to process
XML documents.<br>
</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>Having taken a very long detour to help the XML newcomers catch up
with everyone else, I will now get back on track and begin discussing
JAXP.</p>
<p><font color="#ff0000"><b>XML by itself isn't very useful</b></font><br>
</p>
<p>In reality, an XML document is simply a text document constructed
according to a certain set of rules and containing information that the
author of the document may want to expose to a client.&nbsp; <i>(The
client
could be a human, or could be another computer.)</i><br>
</p>
<p>Taken by itself, the XML document isn't worth much, particularly in
those cases where the client is a human.&nbsp; To be very useful, the
XML document must be combined with a program that is designed to do
something useful with that document.&nbsp; In other words, in order for
an XML document to be useful to you, you need access to a program that
can process that document to your satisfaction.<br>
</p>
<p><font color="#ff0000"><b>DOM and SAX</b></font><br>
</p>
Regardless of the intended result, many XML processing programs often
begin by applying a software construct called a <i>parser </i>to the
XML document. &nbsp; The parser performs several different functions.
&nbsp;One important function is quality control.&nbsp; A non-validating
parser will test the XML document to confirm that it is
well-formed.&nbsp; A validating parser will confirm well-formedness,
and will also test
the XML document to confirm that it conforms to the specified DTD or
schema.<br>
<br>
Two of the most common types of parsers are:<br>
<ul>
  <li>A parser based on the <i>Document Object Model</i> otherwise
known as<a href="http://www.w3.org/DOM/"> DOM</a>.</li>
  <li>A parser based on the <i>Simple API for XML,</i> otherwise known
as <font color="#000000"><a href="http://www.megginson.com/SAX/">SAX</a>.</font></li>
</ul>
I will have a great deal more to say about DOM and SAX in future
lessons. &nbsp; For purposes of this lesson, I need to provide a brief
introduction to DOM because I will use a DOM-based parser in the sample
program to be discussed later.<br>
<p><font color="#ff0000"><b>Brief introduction to DOM</b></font><br>
</p>
<p>An XML document can be viewed as a tree structure where the elements
constitute the nodes in the tree.&nbsp; Some of the nodes have child
nodes and some do not.<br>
</p>
<blockquote><i>(Usually those nodes that have no children are referred
to as leaf nodes.&nbsp; This notation is based on the concept of a
physical tree where the root subdivides into trunk, limbs, branches,
twigs, and finally leaves.&nbsp; However, the leaves don't
subdivide.&nbsp; Leaves on a physical tree don't have children.)</i><br>
</blockquote>
<p> </p>
<p><font color="#ff0000"><b>An example of a tree structure</b></font><br>
</p>
<p>Referring back to the XML document in Listing 1, the element named <b>book</b>
could be viewed as the root of a tree structure.&nbsp; It has two
children, which are the elements named <b>chap</b>.&nbsp; Each of the
elements named chap has a child, which is the text shown in Listing
1.&nbsp; The text forms the leaves of this tree.<br>
</p>
<p><font color="#ff0000"><b>A tree structure in memory</b></font><br>
</p>
<p>A DOM parser can be used to create a tree structure in memory, which
represents an XML document.&nbsp; In Java, that tree structure is
encapsulated in an object of the interface type <b>Document</b>.&nbsp;
<b>Document</b> declares numerous methods.&nbsp; <b>Document </b>is
also a subinterface of <b>Node</b>, and inherits many method
declarations from <b>Node</b>.<br>
</p>
<p><font color="#ff0000"><b>Many operations are possible</b></font><br>
</p>
<p>Given an object of type <b>Document</b>, there are many methods
that can be invoked on the object to perform a variety of
operations.&nbsp; For example, it is possible to move nodes from one
location in the tree to another location in the tree, thus rearranging
the structure of the XML document represented by the <b>Document</b>
object.&nbsp; It is also possible to delete nodes, and to insert new
nodes.&nbsp; As you will see in the sample program in this lesson, it
is also possible to recursively traverse the
tree, extracting information about the nodes along the way.<br>
</p>
<p><font color="#ff0000"><b>I will show you ...</b></font><br>
</p>
<p>In this lesson, I will show you how to:<br>
</p>
<ul>
  <li>Use JAXP, DOM, and an input XML file to create a <b>Document </b>object
that represents the XML file.</li>
  <li>Recursively traverse the DOM tree, getting information about each
node in the tree along the way.</li>
  <li>Use the information about the nodes to create a new XML
file that represents the <b>Document </b>object.</li>
</ul>
<p>The <b>Document</b> object represents the original XML file and the
DOM tree is not modified in this example.&nbsp; The final XML file
represents the unmodified <b>Document</b> object, which represents the
original XML file.&nbsp; Therefore, the final XML file will be
functionally equivalent to the original XML file.<br>
</p>
<p><font color="#ff0000"><b>Nothing fancy intended</b></font><br>
</p>
<p>This sample program is not intended to do anything fancy.&nbsp;
Rather, it is intended simply to help you take the first small step
into the fascinating world of Java, JAXP, and XML.<br>
</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
In total, this sample program consists of a class named <b>Dom02.java</b>,
a class named <b>Dom02Writer.java</b>, and an XML file named <b>Dom02.xml</b>.
&nbsp; I will discuss these files in fragments.&nbsp; Complete listings
of the three files are shown beginning with Listing 28 near the end of
the lesson.<br>
<br>
<font color="#ff0000"><b>The XML file named Dom02.xml</b></font><br>
<br>
I will begin my discussion with the XML file named <b>Dom02.xml</b>.
&nbsp; A listing of this file begins in Listing 3.<br>
<br>
An XML file always starts with a prolog, which is the part of the XML
document that precedes the XML data. The minimal prolog, shown in
Listing 3, contains a declaration that identifies the document as an
XML document.<br>
<blockquote><i>(Note that the declaration may also contain additional
information that is not included in this simple XML document.)</i><br>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The root element</b></font><br>
<br>
The root element of this XML document is named <b>bookOfPoems</b>.
&nbsp;An abbreviated form of the root element, <i>(with all of its
content removed)</i>, is<b> </b>shown in Listing 4.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;bookOfPoems&gt;<br>  ...<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Children of the root element</b></font><br>
<br>
As shown in Listing 5, the root element contains two child elements
named <b>poem</b>.&nbsp; <i>(For clarity, I eliminated the content of
each of the <b>poem</b> elements in Listing 5.)</i><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;bookOfPoems&gt;<br>  &lt;poem <font color="#009900">PoemNumber="1" DumAtr="dum val"</font>&gt;<br>    ...<br>  &lt;/poem&gt;<br><b>  <font
 color="#ff0000">&lt;?processor ProcInstr="Dummy"?&gt;</font><br>  <font
 color="#3333ff">&lt;!--Comment--&gt;</font></b><br>  &lt;poem <font
 color="#009900">PoemNumber="2" DumAtr="dum val"</font>&gt;<br>    ...<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Processing instructions and comments</b></font><br>
<br>
Listing 5 also shows a <b>processing instruction</b> <i>(colored red
for identification),</i> and a <b>comment</b> <i>(colored blue for
identification).</i> &nbsp; <br>
<br>
Comments are <i>(or may be)</i> ignored by XML processors.&nbsp;
Processing instructions are intended to provide instructions to XML
processors.&nbsp; Depending on the overall design, some XML processors
may pay attention to some processing instructions and ignore
others.&nbsp;
For example, a given XML document may be processed by two or more
processors
for different purposes.&nbsp; The document may contain different
processing
instructions for the different XML processors.<br>
<br>
<font color="#ff0000"><b>Attributes of the poem element</b></font><br>
<br>
Listing 5 also shows that each of the <b>poem</b> elements have two
attributes <i>(colored green for identification):</i><br>
<ul>
  <li>PoemNumber</li>
  <li>DumAtr</li>
</ul>
<font color="#ff0000"><b>Content of the first poem element</b></font><br>
<br>
Listing 6 shows the content of the first <b>poem</b> element <i>(colored
blue for identification).</i><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  &lt;poem <font color="#009900">PoemNumber="1" DumAtr="dum val"</font>&gt;<br><font
 color="#3333ff">    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;</font><br>  &lt;/poem&gt;<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
As you can see from Listing 6, the content of the first <b>poem</b>
element consists of a sequence of four elements named <b>line</b>.&nbsp;
The content of each of the <b>line</b> elements is the text that
constitutes one line in the poem.&nbsp; When this XML document is
converted to a DOM tree, each of the text lines will constitute one
leaf node in the tree.<br>
<br>
<font color="#ff0000"><b>Content of the second poem element</b></font><br>
<br>
Listing 7 shows the content of the second <b>poem</b> element.&nbsp;
There is nothing new here, except for the indication that I could never
make a living as a poet.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  &lt;poem <font color="#009900">PoemNumber="2" DumAtr="dum val"</font>&gt;<br><font
 color="#3333ff">    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;</font><br>  &lt;/poem&gt;<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The entire XML document</b></font><br>
<br>
Listing 8 shows the entire XML document with the same color coding as
above, so that you can identify all the parts, and view them in context:<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;bookOfPoems&gt;<br>  &lt;poem <font color="#009900">PoemNumber="1" DumAtr="dum val"</font>&gt;<br><font
 color="#3333ff">    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;</font><br>  &lt;/poem&gt;<br>  <font
 color="#ff0000">&lt;?processor ProcInstr="Dummy"?&gt;</font><br>  <font
 color="#3333ff">&lt;!--Comment--&gt;</font><br>  &lt;poem <font
 color="#009900">PoemNumber="2" DumAtr="dum val"</font>&gt;<br><font
 color="#3333ff">    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;</font><br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote><i>It is important to note that although I have presented
this XML document with different colors to identify the different
parts,
there is no color in an actual XML document.&nbsp; Recall from the
earlier
discussion that one of the most important aspects of XML documents is
that they exist in plain text, which doesn't include attributes such
as boldface, Italics, underline, or color.&nbsp; This makes XML
documents
easily transportable among different kinds of computers and different
operating systems.</i><br>
</blockquote>
<font color="#ff0000"><b>The class named Dom02</b></font><br>
<br>
The controlling class for this program is named <b>Dom02</b>.&nbsp; I
will discuss this class in fragments.&nbsp; As mentioned earlier, a
complete listing of the class is provided in Listing 28 near the end
of the lesson.<br>
<br>
This class, when executed in conjunction with the class named <b>Dom02Writer</b>:<br>
<ul>
  <li>Creates a <b>Document</b> object using JAXP, DOM, and the input
XML file named <b>Dom02.xml</b>.</li>
  <li>Traverses the DOM tree, getting information about each element <i>(each
node in the tree).</i></li>
  <li>Uses the information describing the nodes to create an output XML
file that represents the <b>Document</b> object <i>(and is
functionally equivalent to the input XML file).</i></li>
</ul>
<font color="#ff0000"><b>Why not identical?</b></font><br>
<br>
By now you may be wondering why I used the weasel words "functionally
equivalent" instead of saying that the output XML file is identical
to the input XML file.&nbsp; This has to do with the topic of
whitespace,
which is a fairly complex topic in XML.&nbsp; <i>(I will have much
more
to say about whitespace in future lessons.)</i><br>
<br>
For now, suffice it to say that much of the whitespace in Listing 8 <i>(newlines,
indentation, etc.) </i>was put there for cosmetic reasons.&nbsp; For
reasons that I won't attempt to explain in this simple example, some of
that cosmetic whitespace is not reflected in the output XML file.<br>
<br>
<font color="#ff0000"><b>Input and output file names</b></font><br>
<br>
The names of the input and output XML files are provided to this
program by command-line arguments when the program is executed.&nbsp;
The name of the input file is the first argument, and the name of the
output file is the second argument.<br>
<br>
<font color="#ff0000"><b>DocumentBuilder and Document objects</b></font><br>
<br>
The program creates a DOM parser object, of type <b>DocumentBuilder</b>,
based on JAXP.&nbsp; This object, along with its <b>parse</b> method,
is used to create a <b>Document</b> object <i>(DOM tree)</i> that
represents the input XML file.<br>
<br>
<font color="#ff0000"><b>Traverse the tree</b></font><br>
<br>
The <b>Document</b> object's reference is passed to the <b>writeXmlFile</b>
method of an anonymous object of the <b>Dom02Writer</b> class, which
traverses the tree and produces the output XML file representing that
tree.&nbsp; As you will see, this is by far the most complex part of
the entire operation. &nbsp;<i>(In the next lesson, I will show you how
to accomplish the same thing with less complexity.)</i><br>
<br>
<font color="#ff0000"><b>Miscellaneous comments about the program</b></font><br>
<br>
The program was tested using Sun's SDK 1.4.2 under WinXp along
with the file named <b>Dom02.xml</b> described above.<br>
<br>
No effort was made to provide meaningful information about errors and
exceptions. &nbsp; The topic of providing such meaningful information,
particularly regarding parsing errors is fairly complex, and will be
addressed in a future lesson.<br>
<br>
<font color="#ff0000"><b>Import directives</b></font><br>
<br>
Because the primary purpose of this lesson is to get you started using
JAXP, I will highlight the first three import directives, and
the classes that they represent, in Listing 9.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre><b>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br>import org.w3c.dom.Document;</b><br><br>import java.io.File;<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Steps for creating a Document object</b></font><br>
<br>
As you will see when we get into the code, creating a <b>Document</b>
object involves three steps:<br>
<ol>
  <li>Create a <b>DocumentBuilderFactory </b>object</li>
  <li>Use the&nbsp;<b>DocumentBuilderFactory </b>object to create a <b>DocumentBuilder
    </b>object</li>
  <li>Use the <b>DocumentBuilder </b>object to create a <b>Document</b>
object</li>
</ol>
Both the <b>DocumentBuilderFactory</b> class and the <b>DocumentBuilder</b>
class belong to the <b>javax.xml.parsers</b> package.&nbsp; As of this
writing, this package is part of J2SE 1.4.2.<br>
<br>
<font color="#ff0000"><b>The DocumentBuilderFactory Class</b></font><br>
<br>
According to Sun, the <b>DocumentBuilderFactory </b>class<br>
<blockquote><i>"Defines a factory API that enables applications to
obtain a parser that produces DOM object trees from XML documents."</i><br>
</blockquote>
The <b>DocumentBuilderFactory </b>class extends <b>Object</b>,
and defines about fifteen methods, one of which is a static method
named
<b>newInstance</b>. &nbsp;As is often the case with factory objects,
the
<b>newInstance</b> method is used to create an object of the class.<br>
<br>
The class also defines the <b>newDocumentBuilder</b> instance method,
which is used to create objects of the <b>DocumentBuilder</b> class,
discussed in the next section.<br>
<blockquote><i>(Note that although the quotation from Sun in the next
section uses the terminology </i><i>DocumentBuilderFactory.newDocumentBuilder
method</i><i>, the </i><i>newDocumentBuilder</i><i> method is an
instance method and is not a static or class method.)</i><br>
</blockquote>
<font color="#ff0000"><b>The DocumentBuilder Class</b></font><br>
<br>
According to Sun, the <b>DocumentBuilder</b> class<br>
<blockquote><i>"Defines the API to obtain DOM Document instances from
an
XML document. Using this class, an application programmer can obtain a
Document from XML.</i><br>
  <br>
  <i>An instance of this class can be obtained from the
DocumentBuilderFactory.newDocumentBuilder method. Once an instance of
this class is obtained, XML can be parsed from a variety of input
sources. These input sources are InputStreams, Files, URLs, and SAX
InputSources.</i><i>"</i><br>
</blockquote>
This class also extends <b>Object</b>, and defines about ten methods,
which include several overloaded versions of the <b>parse</b> instance
method.&nbsp; When the <b>parse</b> method is invoked and passed an
input source containing XML, the method returns a <b>Document</b>
object <i>(DOM tree)</i> that represents the XML.<br>
<br>
The code in this program will pass the file named <b>Dom02.xml</b> to
the parse method, thus producing a DOM tree that represents the XML
contained in that file.<br>
<br>
<font color="#ff0000"><b>The Document interface</b></font><br>
<br>
<b>Document</b> is an interface in the <b>org.w3c.dom</b> package,
which extends the <b>Node</b> interface belonging to the same package.
&nbsp;Thus, when we invoke the <b>parse</b> method described above,
the method returns a reference to an object instantiated from a class
that implements the <b>Document</b> interface.&nbsp; The reference is
returned as type <b>Document</b>, not as the name of the class from
which
the object was actually instantiated.<br>
<blockquote><i>(Because <b>Document </b>extends <b>Node</b>, that
object
could also be treated as type <b>Node </b>when appropriate.)</i><br>
</blockquote>
<font color="#ff0000"><b>Don't know and don't care</b></font><br>
<br>
As is often the case in situations like this, we don't know, and
usually don't care about the actual name of the class from which the
<b>Document</b> object was instantiated, so long as the class correctly
implements the methods declared in <b>Document</b> and <b>Node</b>.<br>
<br>
<font color="#ff0000"><b>What does Sun have to say?</b></font><br>
<br>
Sun has this to say about a <b>Document</b> object:<br>
<blockquote><i>"The Document interface represents the entire HTML or
XML
document. Conceptually, it is the root of the document tree, and
provides
the primary access to the document's data."</i><br>
</blockquote>
Sun describes a <b>Node</b> as follows:<br>
<blockquote><i>"The Node interface is the primary datatype for the
entire Document Object Model. It represents a single node in the
document tree. While all objects implementing the Node interface expose
methods for
dealing with children, not all objects implementing the Node interface
may have children. For example, Text nodes may not have children, and
adding children to such nodes results in a DOMException being raised.</i>"<br>
</blockquote>
<font color="#ff0000"><b>Methods of Document and Node</b></font><br>
<br>
The <b>Document</b> and <b>Node</b> interfaces declare a large
number of methods, which make it possible to manipulate and perform
operations on the DOM tree structure encapsulated in the <b>Document</b>
object.&nbsp; We will see several of those methods being used in the
class named <b>Dom02Writer</b>, as it traverses to tree to create an
output XML file that represents
the tree.<br>
<br>
<font color="#ff0000"><b>The File class</b></font><br>
<br>
The fourth import directive in Listing 9 imports the <b>File</b>
class. &nbsp; I will assume that you already know all you need to know
about this class.&nbsp; If not, see my tutorial lessons on file I/O at
<a href="http://www.dickbaldwin.com">www.DickBaldwin.com</a>.<br>
<br>
<font color="#ff0000"><b>Enough talk, let's see some code</b></font><br>
<br>
Listing 10 shows the beginning of the class named <b>Dom02</b>, and
the <b>main</b> method for that class.&nbsp;
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>Dom02</b>{<br><br>  public static void <b>main</b>(String argv[]) {<br>    if (argv.length != 2) {<br>      System.err.println(<br>        "usage: java Dom02 fileIn fileOut");<br>      System.exit(0);<br>    }//end if<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 10 simply checks to confirm that the user entered
the correct number of command-line arguments, and terminates with an
error message if not true.<br>
<br>
Recall that argv[0] should contain the name of the input XML file and
argv[1] should contain the name of the output XML file.<br>
<br>
<font color="#ff0000"><b>A DocumentBuilderFactory object</b></font><br>
<br>
The code in Listing 11 creates and configures an object of type <b>DocumentBuilderFactory</b>,
which is capable of producing objects of
type <b>DocmentBuilder</b>.&nbsp; Objects of type <b>DocumentBuilder</b>
are, in turn, capable of producing objects of type <b>Document</b>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object<br>      factory.setValidating(false);<br>      factory.setNamespaceAware(false);<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Configuration</b></font><br>
<br>
An object of the <b>DocumentBuilderFactory</b> class provides several
methods <i>(such as <b>setValidating</b>),</i> which can be used to
control the behavior of <b>DocumentBuilder</b> objects produced by the
factory object. &nbsp; For example, if you want the want the parser
that will be produced by this and the following code to be a validating
parser, you must invoke the <b>setValidating</b> method at this point,
passing <b>true</b> as a parameter.<br>
<blockquote><i>(Note that the <b>validating</b> and <b>namespaceAware</b>
properties are false by default, so inclusion of the corresponding
statement in Listing 11 didn't accomplish anything, other than to
illustrate the location and use of these methods.)</i><br>
</blockquote>
<font color="#ff0000"><b>Get a DocumentBuilder (parser) object</b></font><br>
<br>
As described earlier, the code in Listing 12 invokes the <b>newDocumentBuilder</b>
method on the factory object produced in Listing 11, to produce a <b>DocumentBuilder</b>
object.&nbsp; That object's reference is saved in the local variable
named <b>builder</b>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The object produced by the code in Listing 12, is the kind of object
that is commonly referred to in the XML literature as an XML parser.<br>
<blockquote><i>(Thus, it would have been equally appropriate to save
the
object's reference in a variable named parser.)</i><br>
</blockquote>
<font color="#ff0000"><b>Create a Document object</b></font><br>
<br>
The code in Listing 13 invokes the <b>parse</b> method on the <b>DocumentBuilder</b>
<i>(parser)</i> object to parse the XML file whose name and path were
provided by the user as the first command-line argument <i>(argv[0]).</i><br>
<br>
Since this is a non-validating parser, the <b>parse</b> method
will confirm that the XML is well-formed.&nbsp; <i>(The parser will
not
attempt to validate the XML.)</i>&nbsp; If the XML is not well-formed,
the <b>parse</b> method will throw an exception.&nbsp; If the XML is
well-formed, the <b>parse</b> method will create an<b></b> object that
represents the XML in a DOM tree, and return that object's reference
as the interface type <b>Document</b>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      Document document = builder.<b>parse</b>(<br>                              new File(argv[0]));<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 13 saves the <b>Document</b> object's reference in
the local variable named <b>document</b>.<br>
<br>
<font color="#ff0000"><b>Process the DOM tree</b></font><br>
<br>
At this point, the DOM tree represents the XML in the input file.
&nbsp;The methods of the <b>Document</b> and <b>Node</b> interfaces
could be used to perform a variety of operations on that tree, such as
moving nodes, deleting nodes, inserting new nodes, modifying text
nodes, etc. &nbsp;Having performed such operations, the program could
then create a new XML file that represents the modified DOM tree.<br>
<br>
In this simple program, however, we won't modify the DOM tree.&nbsp;
Rather, we will simply create a new XML file that represents the
unmodified DOM tree. &nbsp; Thus, the output XML file should be
functionally equivalent to the input XML file.<br>
<br>
<font color="#ff0000"><b>Create the output file</b></font><br>
<br>
This program will invoke a method named <b>writeXmlFile</b> on
an anonymous object of the <b>Dom02Writer</b> class to create the
output file, whose name and path were provided by the user as the
second command-line argument. &nbsp; The <b>writeXmlFile</b> method is
invoked by the code in Listing 14, passing the <b>Document</b>
object's reference as a parameter to the method.<br>
<br>
The <b>writeXmlFile </b>method will recursively traverse the DOM tree
represented by the <b>Document</b> object.&nbsp; Along the way,
it will extract information about each of the nodes and use this
information to construct the elements in the output XML file.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      new Dom02Writer(argv[1]).<br>                          writeXmlFile(document);<br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br>} // class Dom02<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The catch block</b></font><br>
<br>
Listing 14 also contains the <b>catch</b> block that receives control
if any of the code in the <b>try</b> block beginning in Listing 11
throws an error or an exception.<br>
<br>
As mentioned earlier, the code in this <b>catch</b> block makes no
attempt to provide meaningful information in the event of an error or
an exception. &nbsp; The code to provide meaningful information in the
event of parsing errors can be rather complex, and is a topic that will
be covered in a future lesson.<br>
<br>
<font color="#ff0000"><b>End of the Dom02 class</b></font><br>
<br>
The code in Listing 14 also signals the end of the <b>Dom02</b> class,
and the <b>main</b> method belonging to that class.<br>
<br>
<font color="#ff0000"><b>The Dom02Writer class</b></font><br>
<br>
This class provides a utility method named <b>writeXmlFile</b>, which
receives a <b>Document </b>object's reference as a parameter and
writes an output XML file that matches the information encapsulated in
the
<b>Document </b>object.<br>
<br>
The output file is created by recursively traversing the DOM tree
encapsulated in the <b>Document</b> object, identifying each of the
nodes in that tree, and converting each node to text in an XML format.<br>
<br>
No effort is made to insert spaces and line breaks to make the
output cosmetically pleasing.&nbsp; Also, nothing is done to eliminate
cosmetic whitespace that may exist in the <b>Document </b>object.<br>
<br>
The name of the output XML file is established as a parameter to the
constructor for the class.<br>
<br>
<font color="#ff0000"><b>Testing</b></font><br>
<br>
This class was briefly tested using SDK 1.4.2 and WinXP. Note
however that this class has not been thoroughly tested. If you use the
class for a critical application, be sure to test it thoroughly before
using it.<br>
<br>
<font color="#ff0000"><b>The class definition</b></font><br>
<br>
The beginning of the <b>Dom02Writer</b> class, including an instance
variable and the constructor is shown in Listing 15.&nbsp; <i>(See the
complete listing near the end of the lesson for the required import
directives.)</i><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class Dom02Writer {<br>  private PrintWriter out;<br><br>  public Dom02Writer(String xmlFile) {<br>    try {<br>      out = new PrintWriter(<br>                  new FileOutputStream(xmlFile));<br>    }catch (Exception e) {<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The constructor</b></font><br>
<br>
The constructor is very straightforward, having nothing to do with JAXP
or XML.&nbsp; The purpose of the constructor is to receive the output
file name as an incoming parameter and to establish an output stream
of type <b>PrintWriter</b> that is used to write information to the
output file.<br>
<br>
If this code is unfamiliar to you, you can learn about Java stream I/O
at<font color="#000000"><a href="http://www.dickbaldwin.com/">
www.DickBaldwin.com</a></font>.<br>
<br>
<font color="#ff0000"><b>The writeXmlFile method</b></font><br>
<br>
Listing 16 shows the entire method named <b>writeXmlFile</b>, which
converts an incoming <b>Document</b> object to an output XML file.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void <b>writeXmlFile</b>(Document document){<br>    try {<br>      <b>writeNode</b>(document);<br>    }catch (Exception e) {<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }//end writeXmlFile()<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
This method is also straightforward.&nbsp; All that it does is
pass the <b>Document</b> object's reference to a recursive method
named
<b>writeNode</b>.<br>
<br>
<b><font color="#ff0000">What does this mean?</font></b><br>
<br>
Recall that I told you earlier that, according to Sun,<br>
<blockquote><i>"The Document interface represents the entire ... XML
document. Conceptually, it is the root of the document tree, ..."</i><br>
</blockquote>
Recall also that when discussing a <b>Document</b> object, I told you <br>
<blockquote><i>"Because <b>Document </b>extends <b>Node</b>, that
object could
also be treated as type <b>Node </b>when appropriate."</i><br>
</blockquote>
We're now going to put all of that to the test.&nbsp; In effect, the <b>Document</b>
object <i>is a</i> <b>Node</b>, which represents
the root node of the DOM tree, and we can pass its reference to the
method named <b>writeNode</b>, which requires an incoming parameter of
type
<b>Node</b>. &nbsp; <br>
<br>
<font color="#ff0000"><b>Recursion</b></font><br>
<br>
Here is where things get a little more complicated, particularly if you
don't have a strong background in recursive algorithms.&nbsp;
The <b>writeNode</b> method implements a recursive algorithm.<br>
<blockquote><i>(Typically at a time like this, I would tell you that if
you don't understand recursion, you could visit my web site where you
will find tutorial lessons that explain recursion.&nbsp; However, I
have just realized that despite the fact that I have published several
hundred lessons on OOP and Java, I have never published a lesson that
concentrates on
the implementation of recursion in Java.&nbsp; Therefore, the best that
I can do at this point is to tell you to fire up your Google search
engine
and search for the keywords Java and recursion.&nbsp; You will probably
find many sites that deal with recursion in Java.)</i><br>
</blockquote>
<font color="#ff0000"><b>The writeNode method</b></font><br>
<br>
The <b>writeNode</b> method, which begins in Listing 17, is invoked
recursively to convert <b>Node</b> data to XML format and to write the
XML format data to the output file.<br>
<br>
The method begins by executing code designed to avoid the infamous <b>NullPointerException</b>
that occurs when the incoming reference
fails to refer to an actual object of type <b>Node</b>.&nbsp; In this
event, the program will abort gracefully with a message appearing on
the standard error device.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void <b>writeNode</b>(Node node) {<br>    if (node == null) {<br>      System.err.println(<br>                  "Nothing to do, node is null");<br>      return;<br>    }//end if<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Process the node based on its type</b></font><br>
<br>
The code in Listing 18 invokes the <b>getNodeType</b> method to
determine the type of the node whose reference was received an incoming
parameter. &nbsp; According to Sun, this method returns a <b>short</b>
value representing the type of the node.&nbsp; <i>(Why did I treat it
as type <b>int</b>? &nbsp;Just an oversight I suppose.)</i><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    int type = node.getNodeType();<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The Sun documentation shows that the <b>Node</b> interface defines
final static variables that represent the following types <i>(variables
defined in an interface are implicitly final):</i><br>
<ul>
  <li>ATTRIBUTE_NODE </li>
  <li>CDATA_SECTION_NODE </li>
  <li>COMMENT_NODE </li>
  <li>DOCUMENT_FRAGMENT_NODE </li>
  <li>DOCUMENT_NODE </li>
  <li>DOCUMENT_TYPE_NODE </li>
  <li>ELEMENT_NODE </li>
  <li>ENTITY_NODE </li>
  <li>ENTITY_REFERENCE_NODE </li>
  <li>NOTATION_NODE </li>
  <li>PROCESSING_INSTRUCTION_NODE </li>
  <li>TEXT_NODE</li>
</ul>
These values will be used in a <b>switch</b> statement to identify the
type of incoming node, and to take appropriate action regarding
the information written in the output XML file.&nbsp; <i>(Note
however,
that this simple test case was not designed to test all possibilities
in
the above list.)</i><br>
<br>
<font color="#ff0000"><b>Process the Document node</b></font><br>
<br>
I will discuss each case in the <b>switch</b> statement separately.
&nbsp; Listing 19 shows the code that is executed when the incoming <b>Node</b>
object is type <br>
DOCUMENT_NODE.<br>
<br>
<pre></pre>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    switch (type) {<br>      case Node.<b>DOCUMENT_NODE</b>: {<br>        out.print("&lt;?xml version=\"1.0\"?&gt;");<br><br>        //Get and write the root element of the<br>        // Document.  Note that this is a<br>        // recursive call.<br>        writeNode(<br>          ((Document)node).getDocumentElement());<br>        out.flush();<br>        break;<br>      }//end case Node.DOCUMENT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 19 begins by writing the required line in the XML
file that indicates that the file contains XML data.&nbsp; This is
required as the first line in an XML file.<br>
<br>
<font color="#ff0000"><b>The getDocumentElement method</b></font><br>
<br>
Then the code in Listing 19 downcasts the <b>Node</b> object's
reference to type <b>Document</b> and invokes the <b>getDocumentElement</b>
method on that reference.&nbsp; Here is what Sun has to say about this
method:<br>
<blockquote><i>"This is a convenience attribute that allows direct
access to the child node that is the root element of the document. For
HTML documents, this is the element with the tagName "HTML"."</i><br>
</blockquote>
For the XML file being processed in this example, this will be the
element named <b>bookOfPoems</b>.<br>
<blockquote><i>(Although I'm not certain, I suspect that the
documentation author intended to say convenience method instead of </i><i>convenience
attribute.)</i><br>
</blockquote>
<font color="#ff0000"><b>An object of interface type Element</b></font><br>
<br>
The&nbsp;<b>getDocumentElement</b> method returns a reference to
an object of the interface type <b>Element</b>, which is a
subinterface
of the <b>Node</b> interface.<br>
<br>
Here is what Sun has to say about objects of type <b>Element</b>:<br>
<blockquote><i>"The Element interface represents an element in an HTML
or XML document. Elements may have attributes associated with them;
since the Element interface inherits from Node, the generic Node
interface attribute attributes may be used to retrieve the set of all
attributes for an element. There are methods on the Element interface
to retrieve either an Attr
object by name or an attribute value by name. In XML, where an
attribute
value may contain entity references, an Attr object should be retrieved
to examine the possibly fairly complex sub-tree representing the
attribute
value."</i><br>
</blockquote>
The interface declares about fifteen methods, which make it possible to
perform various operations on an <b>Element</b> object.<br>
<br>
<font color="#ff0000"><b>A recursive call to the writeNode method</b></font><br>
<br>
The code in Listing 19 gets the <b>Element</b> object, <i>(which
is also a <b>Node</b> object)</i> corresponding to the root element of
the XML document and passes that object's reference, recursively, to
the
<b>writeNode</b> method.<br>
<br>
When the <b>writeNode</b> method ultimately returns, the code in
Listing 19 flushes the output buffer to ensure that all data that has
been written to the output buffer is actually written to the output
file.<br>
<blockquote><b>Important:&nbsp; The statement that reads </b><b>out.flush
and all of the remaining code in this method will not be executed until
the recursive call to </b><b>writeNode() returns.</b><br>
</blockquote>
In effect, the code for the <b>DOCUMENT_NODE</b> case in the <b>writeNode</b>
method <i>(Listing 19)</i> simply gets the object in the DOM tree
corresponding to the root element in the XML document and passes it
recursively to
the <b>writeNode</b> method.&nbsp; This causes the information
corresponding to the root element to be written to the output file.<br>
<br>
<font color="#ff0000"><b>Node type ELEMENT_NODE</b></font><br>
<p>Listing 20 shows the beginning of the code in the switch case where
the node type is ELEMENT_NODE.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case Node.ELEMENT_NODE: {<br>        out.print('&lt;');//begin the start tag<br>        out.print(node.getNodeName());<br><br><b><font
 face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 20 is simple enough.<br>
<ul>
  <li>Begin the case clause for type ELEMENT_NODE.</li>
  <li>Write a left angle bracket ("&lt;") into the output file to begin
the tag for the element.</li>
  <li>Get and write the name of the node immediately following the left
angle bracket.</li>
</ul>
<font color="#ff0000"><b>The Attr interface</b></font><br>
<br>
An element can have none, one, or more attributes.&nbsp; The <b>Attr </b>interface
extends the <b>Node </b>interface.&nbsp; Here is part of what Sun has
to say about the <b>Attr </b>interface:<br>
<blockquote><i>"The Attr interface represents an attribute in an
Element
object. Typically the allowable values for the attribute are defined in
a
document type definition. </i><br>
  <br>
  <i>Attr objects inherit the Node interface, but since they are
not actually child nodes of the element they describe, the DOM does not
consider them part of the document tree. Thus, the Node attributes
parentNode,
previousSibling, and nextSibling have a null value for Attr objects.
The DOM takes the view that attributes are properties of elements
rather
than having a separate identity from the elements they are associated
with; this should make it more efficient to implement such features as
default attributes associated with all elements of a given type.
Furthermore,
Attr nodes may not be immediate children of a DocumentFragment.
However,
they can be associated with Element nodes contained within a
DocumentFragment.
In short, users and implementors of the DOM need to be aware that Attr
nodes have some things in common with other objects inheriting the Node
interface, but they also are quite distinct.</i><i></i>"<br>
</blockquote>
<font color="#ff0000"><b>Process the attributes, if any</b></font><br>
<br>
Continuing with the case for node type ELEMENT_NODE, the code in
Listing 21 gets the attributes, if any, belonging to the element and
writes them into the output file in the correct XML format.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        //Get attributes into an array<br>        Attr attrs[] = getAttrArray(<br>                           node.getAttributes());<br><br>        //Process attributes in the array.<br>        for (int i = 0; i &lt; attrs.length; i++){<br>          Attr attr = attrs[i];<br>          out.print(' ');//write a space<br>          out.print(attr.getNodeName());<br>          out.print("=\"");//write ="<br>          //Convert &lt;,&gt;,&amp;, and quotation char to<br>          // entities and write the text<br>          // containing the entities.<br>          out.print(<br>                  strToXML(attr.getNodeValue()));<br>          out.print('"');//write closing quote<br>        }//end for loop<br>        out.print('&gt;');//write end of start tag<br><br><b><font
 face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>Get attributes into an array object</b></font><br>
<br>
The code begins by invoking the <b>getAttrArray</b> method, <i>(which
is defined later in this class),</i> to get the attributes and to store
them in an array object of type<b> Attr</b>. I will explain the&nbsp;<b>getAttrArray</b>
method later.&nbsp; For now, suffice it to say that the <b>getAttrArray</b>
method returns a reference to an array object of type <b>Attr</b>
where each element in the array represents one of the attributes
associated
with the node being processed.<br>
<br>
<font color="#ff0000"><b>Process the attributes, if any</b></font><br>
<br>
With one exception, the code to process the array, getting the name and
value of each attribute and writing them into the output XML file is
straightforward. All it really amounts to is invoking the <b>getNodeName</b>
and <b>getNodeValue</b> methods to get the name and the value of the
attribute, and then creating the correct sequence of text, spaces, and
punctuation characters.&nbsp; For the case where the node is of type <b>Attr</b>,
these two methods simply return strings.<br>
<br>
<font color="#ff0000"><b>The strToXML method</b></font><br>
<br>
The exception mentioned above has to do with the call to the method
named <b>strToXML</b>. This method is used to replace extraneous angle
brackets, ampersands, and quotation marks in the text with the
corresponding
XML entities. I will explain the inner workings of this method later in
this lesson.<br>
<br>
<font color="#ff0000"><b>Nested elements</b></font><br>
<br>
At this point, we must deal with the possibility that this node may
have children, and must process them if they exist.&nbsp; This is
accomplished by the code in Listing 22, where we are still dealing with
the switch
case of node type ELEMENT_NODE.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        NodeList children = node.getChildNodes();<br><br>        if (children != null) {//nested elements<br>          int len = children.getLength();<br>          //Iterate on NodeList of child nodes.<br>          for (int i = 0; i &lt; len; i++) {<br>          //Write each of the nested elements<br>          // recursively.<br>          <b>writeNode</b>(children.item(i));<br>          }//end for loop<br>        }//end if<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Listing 22 begins by invoking the <b>getChildNodes </b>method on
the current node to get an object of type <b>NodeList </b>containing
a collection of the children of this node.<br>
<br>
The items in the <b>NodeList </b>object are accessible via an
integral index, starting from 0, via a method named <b>item</b>.&nbsp;
The <b>item</b> method takes an integral index as a parameter, and
returns a reference to an object of type <b>Node</b>.<br>
<br>
A <b>NodeList</b> object also provides a method named <b>getLength</b>,
which returns the number of nodes in the list. <br>
<br>
<font color="#ff0000"><b> Getting the nodes in the list</b></font><br>
<br>
The <b>getChildNodes </b>method returns an empty list if there are no
children. <i>(If there are children, <b>getLength</b> returns a value
greater than zero.)</i><br>
<br>
Assuming that you are comfortable with recursion, the code in Listing
22 is straightforward:<br>
<ul>
  <li>Invoke <b>getLength </b>to get the number of nodes.</li>
  <li>Use a <b>for </b>loop to iterate on each of the nodes.</li>
  <li>Make a recursive call inside the <b>for </b>loop to the <b>writeNode
    </b>method to process each child node.</li>
</ul>
That ends the processing for the switch case ELEMENT_NODE.<br>
<br>
<font color="#ff0000"><b>Entity reference nodes</b></font><br>
<br>
The code in Listing 23 is the code for the switch case
ENTITY_REFERENCE_NODE.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case Node.ENTITY_REFERENCE_NODE:{<br>        out.print('&amp;');<br>        out.print(node.getNodeName());<br>        out.print(';');<br>        break;<br>      }//end case Node.ENTITY_REFERENCE_NODE<br><br><b><font
 face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 23 sandwiches the name of a node of type
ENTITY_REFERENCE_NODE between an ampersand and a semicolon and writes
the combination into
the output file. This produces an entity reference in the output XML
file.<br>
<br>
Briefly, an entity reference is a reference to something that has been
defined elsewhere. Since this lesson is not intended to teach you about
entities, I will drop it at that. The sample XML file used to test this
program didn't contain any entity references, so this code has not been
tested.<br>
<br>
<font color="#ff0000"><b>Text nodes</b></font><br>
<br>
The code in Listing 24 handles the following switch cases:<br>
<ul>
  <li>CDATA_SECTION_NODE</li>
  <li>TEXT_NODE</li>
</ul>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case Node.CDATA_SECTION_NODE:<br>      case Node.TEXT_NODE: {<br>        //Eliminate &lt;,&gt;,&amp; and quotation marks and<br>        // write to output file.<br>        out.print(strToXML(node.getNodeValue()));<br>        break;<br>      }//end case Node.TEXT_NODE<br><br><b><font
 face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Without getting into the technical XML details as to why, a block of
text can be represented by either of two node types:<br>
<ul>
  <li>CDATA_SECTION_NODE</li>
  <li>TEXT_NODE</li>
</ul>
<i>(The sample XML file that I used to test this program contained only
the second type.)</i><br>
<br>
The processing for this type of node, shown in Listing 24, is very
simple:<br>
<ul>
  <li>Get the value of the node, which contains the actual text.</li>
  <li>Invoke the <b>strToXML</b> method to replace angle brackets,
ampersands, and quotation marks with entities.</li>
  <li>Write the modified text to the output file.</li>
</ul>
Note, however, that by replacing angle brackets, ampersands, and
quotation marks with entities, the code in Listing 24 essentially
converts CDATA into PCDATA. &nbsp;In some cases, that may not be
desirable, so this may not be the best approach for dealing with CDATA.<br>
<br>
<font color="#ff0000"><b>Processing instruction nodes</b></font><br>
<br>
The code in Listing 25 is the code for switch case
PROCESSING_INSTRUCTION_NODE<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case Node.PROCESSING_INSTRUCTION_NODE:{<br>        out.print("&lt;?");<br>        out.print(node.getNodeName());<br>        String data = node.getNodeValue();<br>        if (data != null &amp;&amp; data.length() &gt; 0){<br>          out.print(' ');//write space<br>          out.print(data);<br>        }//end if<br>        out.print("?&gt;");<br>        break;<br>      }//end Node.PROCESSING_INSTRUCTION_NODE<br>    }//end switch<br><br><b><font
 face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Based on what you have learned up to this point, the processing of this
node type in Listing 25 should be straightforward.&nbsp; In this
case, the <b>getNodeName</b> method returns a string corresponding to
the target of the processing instruction.&nbsp; The <b>getNodeValue</b>
method returns a string consisting of the <i>"entire content excluding
the target."</i><br>
<br>
The target string is written into the output XML file preceded by
"&lt;?".<br>
<br>
If the string returned by <b>getNodeValue</b> is not null and has a
length greater than zero, that string is then written into the output
file preceded by a space.<br>
<br>
Finally the characters "?&gt;" are written into the output file
completing the processing instruction.<br>
<br>
<font color="#ff0000"><b>Close the element</b></font><br>
<br>
There is one more thing that needs to be done before exiting the
<b>writeNode</b> method being used to process a node. As shown in
Listing
26, if the node being processed is an element, the end tag for the
element
needs to be created and written to the output file. That is
accomplished
in a straightforward manner in Listing 26.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Now write the end tag for element nodes<br>    if (type == Node.ELEMENT_NODE) {<br>      out.print("&lt;/");<br>      out.print(node.getNodeName());<br>      out.print('&gt;');<br><br>    }//end if<br><br>  }//end writeNode(Node)<br><br><b><font
 face="Courier New,Courier">Listing 26</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Listing 26 also signals the end of the <b>writeNode</b> method.<br>
<b><br>
<font color="#ff0000"> Utility methods</font></b><br>
<br>
That brings us to some utility methods that are invoked by the code
discussed above.<br>
<br>
<font color="#ff0000"><b>The strToXML method</b></font><br>
<br>
The purpose of the <b>strToXML</b> method, shown in Listing 27, is to
modify and return a <b>String </b>object replacing angle brackets,
ampersands, and quotation marks with XML entities.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private String strToXML(String s) {<br>    StringBuffer str = new StringBuffer();<br><br>    int len = (s != null) ? s.length() : 0;<br><br>    for (int i = 0; i &lt; len; i++) {<br>      char ch = s.charAt(i);<br>      switch (ch) {<br>        case '&lt;': {<br>          str.append("&amp;lt;");<br>          break;<br>        }//end case '&lt;'<br>        case '&gt;': {<br>          str.append("&amp;gt;");<br>          break;<br>        }//end case '&gt;'<br>        case '&amp;': {<br>          str.append("&amp;amp;");<br>          break;<br>        }//end case '&amp;'<br>        case '"': {<br>          str.append("&amp;quot;");<br>          break;<br>        }//end case '"'<br>        default: {<br>          str.append(ch);<br>        }//end default<br>      }//end switch<br>    }//end for loop<br><br>    return str.toString();<br><br>  }//end strToXML()<br><br><b><font
 face="Courier New,Courier">Listing 27</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The method receives a <b>String</b> object's reference as an incoming
parameter. &nbsp; It replaces the &lt;,&gt;,&amp;, and quotation mark
characters in that string with XML entities, and returns the modified
string.<br>
<br>
The code in Listing 27 is completely straightforward, and shouldn't
require further explanation.<br>
<br>
<font color="#ff0000"><b>The getAttrArray method</b></font><br>
<br>
In the earlier discussion of attribute elements, I promised to provide
a further discussion of the <b>getAttrArray</b> method shown in
Listing 28. &nbsp; Briefly, this method converts a <b>NamedNodeMap</b>
into an
array object of type <b>Attr</b>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private Attr[] getAttrArray(<br>                             NamedNodeMap attrs){<br>    int len = (attrs != null) ?<br>                           attrs.getLength() : 0;<br>    Attr array[] = new Attr[len];<br>    for (int i = 0; i &lt; len; i++) {<br>      array[i] = (Attr)attrs.item(i);<br>    }//end for loop<br><br>    return array;<br>  }//end getAttrArray()<br><br>} // end class Dom02Writer<br><br><b><font
 face="Courier New,Courier">Listing 28</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The getAttributes method</b></font><br>
<br>
Backtracking a bit, the code in Listing 21 invokes the <b>getAttributes</b>
method on the node, and passes the returned value as a parameter to the
<b>getAttrArray</b> method shown in Listing 28.<br>
<br>
The <b>getAttributes </b>method returns a reference to an object
of type <b>NamedNodeMap</b> containing the attributes of the node <i>(if
it is an <b>Element</b>)</i> and null otherwise.<br>
<br>
Thus, the <b>getAttrArray </b>method shown in Listing 28 receives an
incoming parameter of type <b>NamedNodeMap</b>, which may be null.<br>
<br>
<font color="#ff0000"><b>The NamedNodeMap interface</b></font><br>
<br>
Here is part of what Sun has to say about a <b>NamedNodeMap</b> object:<br>
<blockquote><i>"Objects implementing the NamedNodeMap interface are
used
to represent collections of nodes that can be accessed by name. ...
Objects
contained in an object implementing NamedNodeMap may also be accessed
by
an ordinal index, but this is simply to allow convenient enumeration of
the
contents of a NamedNodeMap, and does not imply that the DOM specifies
an
order to these Nodes."</i><br>
</blockquote>
A <b>NamedNodeMap</b> object provides several methods, which can
be used to<br>
<ul>
  <li>Get the number of items in the collection.</li>
  <li>Access the items in the collection.</li>
  <li>Remove items from the collection.</li>
  <li>Add items to the collection.</li>
</ul>
<font color="#ff0000"><b>The method named item</b></font><br>
<br>
The code in Listing 28 takes advantage of the fact that <i>"</i><i>Objects
contained in an object implementing NamedNodeMap may also be accessed
by an ordinal index,</i><i> ..."&nbsp; </i>This is accomplished by
invoking the method named <b>item</b> on the <b>NamedNodeMap</b>
object, passing
an ordinal index as a parameter.<br>
<br>
Given this information, the process for converting a <b>NamedNodeMap</b>
object into an array object of type <b>Attr</b>, as implemented by the
<b>getAttrArray</b> method in Listing 28, is relatively straightforward:<br>
<ul>
  <li>Get required length for the array.</li>
  <li>Instantiate the new array object of the proper length.</li>
  <li>Use a <b>for </b>loop and the <b>item</b> method to extract
each item from the <b>NamedNodeMap </b>object and use it to populate
the array object.</li>
  <li>Return the array object.</li>
</ul>
<font color="#ff0000"><b>End of class Dom02Writer</b></font><br>
<br>
The code in Listing 28 also signals the end of the class definition for
the class named <b>Dom02Writer</b>.<br>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code from Listings 28, 29, and 30 into
your text editor, compile it, and execute it.&nbsp; Experiment with it,
making changes, and observing the results of your changes.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this first lesson on Java JAXP, I began by providing a brief
description of JAXP and XML.&nbsp; Then I reviewed the salient aspects
of XML for those who need to catch up on XML technology.</p>
<p>Following that, I provided a brief discussion of the Document Object
Model (DOM) and the Simple API for XML (SAX).&nbsp; I discussed how a
DOM object represents an XML document as a tree structure in
memory.&nbsp; I explained that once you have the tree structure in
memory, there are many operations that you can perform to create,
manipulate, and/or modify the structure. &nbsp;Then you can convert
that modified tree structure into a new XML document.<br>
</p>
<p>Using two sample Java class files, I showed you how to:<br>
</p>
<ul>
  <li>Use JAXP, DOM, and an input XML file to create a <b>Document </b>object
that represents the XML file.</li>
  <li>Recursively traverse the DOM tree, getting information about each
node in the tree along the way.</li>
  <li>Use the information about the nodes to create a new XML file that
represents the <b>Document </b>object.</li>
</ul>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>What I did not do in this lesson, <i>(but will do in a future
lesson),</i> is to show you how to modify the tree structure for
purposes of creating a modified XML file.<br>
</p>
<p>The things that you learned about traversing the tree structure and
getting information about each node in the tree will serve you well in
the future. &nbsp; However, if all you need to do is to write an output
XML file that represents the DOM, there is an easier way to do that
using Extensible Stylesheet Language Transformations (XSLT).&nbsp; That
will be the primary topic of the next lesson.<br>
</p>
<p>In this lesson, I didn't show you how to write code that produces
meaningful output in the event of a parser error or exception.&nbsp; I
will also cover that topic in the next lesson.<br>
</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the two Java classes and the XML document
discussed in this lesson are shown in Listings 28, 29, and 30 below.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Dom02.java<br>Copyright 2003 R.G.Baldwin<br><br>This program and the class named Dom02Writer used<br>by this program shows you how to:<br><br>1. Create a Document object using JAXP, DOM, and<br>   an input XML file.<br>2. Traverse the DOM tree getting information<br>   about each element.<br>3. Use the information describing the elements to<br>   create an XML file that represents the<br>   Document object.<br><br>The input XML file name is provided by the user<br>as the first command-line argument.  The output<br>XML file name is provided by the user as the<br>second command-line argument.<br><br>The program requires access to the following<br>class file:<br>  Dom02Writer.class<br><br>The program instantiates a DOM parser object<br>based on JAXP.  The parser is non-validating<br>and is not namespace aware.<br><br>The program uses the parse() method of the parser<br>object to parse an XML file specified on the<br>command line.  The parse method returns an object<br>of type Document that represents the parsed XML<br>file.<br><br>The program passes the Document object to a<br>method named writeXmlFile() on an object of a<br>class named Dom02Writer.  The purpose of this<br>method and this class is to write an XML file<br>that represents the information contained in the<br>Document object.<br><br>Tested using JDK 1.4.2 and WinXP with an XML<br>file that reads as follows:<br><br>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br>When viewed with an editor that restores most of<br>the cosmetic XML structure, the output file looks<br>like the following (note that the comment from<br>the input XML file is missing in the output<br>XML file):<br><br>&lt;?xml version="1.0"?&gt;&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br><br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><br>Note.  No effort was made to provide meaningful<br>information about errors and exceptions.  This is<br>a complex topic that will be covered in a<br>subsequent sample program.<br>************************************************/<br><br>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br>import java.io.File;<br>import org.w3c.dom.Document;<br><br>public class Dom02 {<br><br>  public static void main(String argv[]) {<br>    if (argv.length != 2) {<br>      System.err.println(<br>        "usage: java Dom02 fileIn fileOut");<br>      System.exit(0);<br>    }//end if<br><br>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects<br>      DocumentBuilderFactory factory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Configure the factory object<br>      factory.setValidating(false);<br>      factory.setNamespaceAware(false);<br><br>      //Get a DocumentBuilder (parser) object<br>      DocumentBuilder builder =<br>                    factory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      Document document = builder.parse(<br>                              new File(argv[0]));<br><br>      //Use an anonymous object of the<br>      // Dom02Writer class to traverse the<br>      // Document object, extracting information<br>      // about each of the nodes, and using that<br>      // information to write an output XML<br>      // file that represents the Document<br>      // object.<br>      new Dom02Writer(argv[1]).<br>                          writeXmlFile(document);<br>    }catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br>} // class Dom02<br><br><b><font
 face="Courier New,Courier">Listing 28</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Dom02Writer.java<br>Copyright 2003 R.G.Baldwin<br><br>This class provides a utility method named<br>writeXmlFile() that receives a DOM Document<br>object as a parameter and writes an output XML<br>file that matches the information contained in<br>the Document object.<br><br>The output file is created by recursively<br>traversing the Document object, identifying each<br>of the nodes in that object, and converting each<br>node to text in an XML format.<br><br>No effort is made to insert spaces and line<br>breaks to make the output cosmetically pleasing.<br>Also, nothing is done to eliminate cosmetic<br>whitespace that may exist in the Document object.<br><br>The name of the XML file is established as a<br>parameter to the constructor for the class.<br><br>A cosmetically pleasing view of the output file<br>can be obtained by opening the output file in<br>IE 5.0 or later.<br><br>Briefly tested using JDK 1.4.2 and WinXP.  Note<br>however that this class has not been thoroughly<br>tested. If you use it for a critical application,<br>test it thoroughly before using it.<br>************************************************/<br><br>import java.io.PrintWriter;<br>import java.io.FileOutputStream;<br><br>import org.w3c.dom.*;<br><br>public class Dom02Writer {<br>  private PrintWriter out;<br><br>  //-------------------------------------------//<br><br>  public Dom02Writer(String xmlFile) {<br>    try {<br>      out = new PrintWriter(<br>                  new FileOutputStream(xmlFile));<br>    }catch (Exception e) {<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }//end constructor<br>  //-------------------------------------------//<br><br>  //This method converts an incoming Document<br>  // object to an output XML file<br>  public void writeXmlFile(Document document){<br>    try {<br>      //Write the contents of the Document object<br>      // into an ontput file in XML file format.<br>      writeNode(document);<br>    }catch (Exception e) {<br>      e.printStackTrace(System.err);<br>    }//end catch<br>  }//end writeXmlFile()<br>  //-------------------------------------------//<br><br>  //This method is used recursively to convert<br>  // node data to XML format and to write the XML<br>  // format data to the output file.<br>  public void writeNode(Node node) {<br>    if (node == null) {<br>      System.err.println(<br>                  "Nothing to do, node is null");<br>      return;<br>    }//end if<br><br>    //Process the node based on its type.<br>    int type = node.getNodeType();<br><br>    switch (type) {<br>      //Process the Document node<br>      case Node.DOCUMENT_NODE: {<br>        //Write a required line for an XML<br>        // document.<br>        out.print("&lt;?xml version=\"1.0\"?&gt;");<br><br>        //Get and write the root element of the<br>        // Document.  Note that this is a<br>        // recursive call.<br>        writeNode(<br>          ((Document)node).getDocumentElement());<br>        out.flush();<br>        break;<br>      }//end case Node.DOCUMENT_NODE<br><br>      //Write an element with attributes<br>      case Node.ELEMENT_NODE: {<br>        out.print('&lt;');//begin the start tag<br>        out.print(node.getNodeName());<br><br>        //Get and write the attributes belonging<br>        // to the element.  First get the<br>        // attributes in the form of an array.<br>        Attr attrs[] = getAttrArray(<br>                           node.getAttributes());<br><br>        //Now process all of the attributes in<br>        // the array.<br>        for (int i = 0; i &lt; attrs.length; i++){<br>          Attr attr = attrs[i];<br>          out.print(' ');//write a space<br>          out.print(attr.getNodeName());<br>          out.print("=\"");//write ="<br>          //Convert &lt;,&gt;,&amp;, and quotation char to<br>          // entities and write the text<br>          // containing the entities.<br>          out.print(<br>                  strToXML(attr.getNodeValue()));<br>          out.print('"');//write closing quote<br>        }//end for loop<br>        out.print('&gt;');//write end of start tag<br><br>        //Deal with the possibility that there<br>        // may be other elements nested in this<br>        // element.<br>        NodeList children = node.getChildNodes();<br>        if (children != null) {//nested elements<br>          int len = children.getLength();<br>          //Iterate on NodeList of child nodes.<br>          for (int i = 0; i &lt; len; i++) {<br>          //Write each of the nested elements<br>          // recursively.<br>          writeNode(children.item(i));<br>          }//end for loop<br>        }//end if<br>        break;<br>      }//end case Node.ELEMENT_NODE<br><br>      //Handle entity reference nodes<br>      case Node.ENTITY_REFERENCE_NODE:{<br>        out.print('&amp;');<br>        out.print(node.getNodeName());<br>        out.print(';');<br>        break;<br>      }//end case Node.ENTITY_REFERENCE_NODE<br><br>      //Handle text<br>      case Node.CDATA_SECTION_NODE:<br>      case Node.TEXT_NODE: {<br>        //Eliminate &lt;,&gt;,&amp; and quotation marks and<br>        // write to output file.<br>        out.print(strToXML(node.getNodeValue()));<br>        break;<br>      }//end case Node.TEXT_NODE<br><br>      //Handle processing instruction<br>      case Node.PROCESSING_INSTRUCTION_NODE:{<br>        out.print("&lt;?");<br>        out.print(node.getNodeName());<br>        String data = node.getNodeValue();<br>        if (data != null &amp;&amp; data.length() &gt; 0){<br>          out.print(' ');//write space<br>          out.print(data);<br>        }//end if<br>        out.print("?&gt;");<br>        break;<br>      }//end Node.PROCESSING_INSTRUCTION_NODE<br>    }//end switch<br><br>    //Now write the end tag for element nodes<br>    if (type == Node.ELEMENT_NODE) {<br>      out.print("&lt;/");<br>      out.print(node.getNodeName());<br>      out.print('&gt;');<br><br>    }//end if<br><br>  }//end writeNode(Node)<br>  //-------------------------------------------//<br><br>  //The following methods are utility methods<br><br>  //This method inserts entities in place<br>  // of &lt;,&gt;,&amp;, and quotation mark<br>  private String strToXML(String s) {<br>    StringBuffer str = new StringBuffer();<br><br>    int len = (s != null) ? s.length() : 0;<br><br>    for (int i = 0; i &lt; len; i++) {<br>      char ch = s.charAt(i);<br>      switch (ch) {<br>        case '&lt;': {<br>          str.append("&amp;lt;");<br>          break;<br>        }//end case '&lt;'<br>        case '&gt;': {<br>          str.append("&amp;gt;");<br>          break;<br>        }//end case '&gt;'<br>        case '&amp;': {<br>          str.append("&amp;amp;");<br>          break;<br>        }//end case '&amp;'<br>        case '"': {<br>          str.append("&amp;quot;");<br>          break;<br>        }//end case '"'<br>        default: {<br>          str.append(ch);<br>        }//end default<br>      }//end switch<br>    }//end for loop<br><br>    return str.toString();<br><br>  }//end strToXML()<br>  //-------------------------------------------//<br><br>  //This method converts a NamedNodeMap into an<br>  // array of type Attr<br>  private Attr[] getAttrArray(<br>                             NamedNodeMap attrs){<br>    int len = (attrs != null) ?<br>                           attrs.getLength() : 0;<br>    Attr array[] = new Attr[len];<br>    for (int i = 0; i &lt; len; i++) {<br>      array[i] = (Attr)attrs.item(i);<br>    }//end for loop<br><br>    return array;<br>  }//end getAttrArray()<br><br>  //-------------------------------------------//<br><br>} // end class Dom02Writer<br><br><b><font
 face="Courier New,Courier">Listing 29</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 30</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<hr size="3" width="100%" align="center">
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and XML. In addition to the many platform and/or language independent
benefits of Java and C# applications, he believes that a combination
of Java, C#, and XML will become the primary driving force in the
delivery of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects, and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com/">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology to real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
