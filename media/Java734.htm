<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Wireless Home Security and Java</h2>
<i>Learn how to write a Java program that will automatically set the 
WEP, WPA, or WPA2 encryption key on a wireless router on an unattended scheduled 
basis.</i>
<p><b>Published:</b>&nbsp; June 13, 2006<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 734</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
    <ul>
	<li> <a href="#Sockets15">The Sockets15 Class</a></li>
	<li> <a href="#Sockets14">The Sockets14 Class</a></li>
	<li> <a href="#Sockets10">The Sockets10 Class</a></li>
	<li> <a href="#Sockets11">The Sockets11 Class</a></li>
	<li> <a href="#The_Sockets11a_Class">The Sockets11a Class</a></li>
	<li> <a href="#Sockets12">The Sockets12 Class</a></li>
	<li> <a href="#Sockets13">The Sockets13 Class</a></li>
	</ul>
  <li> <a href="#Run%20the%20program">Run the Programs</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Good_Network_Practice">Good Network Practice</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listing</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> There are many good reasons for learning to write Java programs that 
communicate with network servers, particularly HTTP servers.</p>
<p> <font color="#FF0000"><b>Cleaning up your bookmark library</b></font></p>
<p> For example, in the earlier lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3592906">Using Java to Clean Up Your 
Bookmark Library</a>, I showed you how to write a Java program that will help you to 
identify the broken links in your bookmark <i>(Favorites)</i> library so that 
you can either delete or repair them.</p>
<p> Basically, the program in that
<a href="http://www.developer.com/java/other/article.php/3592906">earlier</a> 
lesson cycles 
through your bookmark library, attempting to contact the servers listed there to 
download the headers for the specified resources.&nbsp; It then interprets those 
headers providing you with information that you can use to clean up the library.</p>
<p> <font color="#FF0000"><b>Setting the encryption key in your wireless router</b></font></p>
<p> In this lesson, I will show you how to write a Java program that makes it 
very easy to modify the encryption key in your wireless router, either manually 
or on an automated scheduled basis.</p>
<p> The premise is that if it is easy for you to change the encryption key, you 
may be inclined to change it more frequently.&nbsp; If you change the encryption 
key more frequently, this <b>may</b> <i>(and I emphasize the word <b>may</b>)</i> cause your 
home or small office wireless network to be more secure.</p>
<blockquote>
	<p><i>(On the other hand, because I am not a security expert and don't have 
	a full understanding of all of the ramifications of wireless network 
	security, it is entirely possible that this may make your wireless network 
	less secure.&nbsp; Please pay careful attention to the disclaimer that 
	follows.)</i></p>
</blockquote>
<p> <i><font color="#FF0000"><b><a name="A_disclaimer">A disclaimer</a></b></font></i></p>
<p> <i>I am not a security expert.&nbsp; My expertise is in the area of Java 
programming.&nbsp;  
The programs in this lesson are provided for educational purposes only.&nbsp; There 
is no suggestion that these programs are suitable for any purpose other than 
education in the area of Java programming.&nbsp; If you use the programs for 
any purpose whatsoever, you are doing so at your own risk.&nbsp; I will accept 
no responsibility for any outcome that you may experience.</i></p>
<p> <font color="#FF0000"><b>What can you expect from this lesson?</b></font></p>
<p> My goal in this lesson is to teach you how to write HTTP client programs in 
Java, which communicate with HTTP servers, and which deal with the following 
HTTP/1.0 and/or HTTP/ 1.1 features:</p>
<ul>
	<li>Standard 
	<a href="http://httpd.apache.org/docs/1.3/howto/auth.html#basic">basic authentication</a></li>
	<li>Nonstandard authentication</li>
	<li><a href="http://www.io.com/~maus/HttpKeepAlive.html">Keep-alive</a> features</li>
	<li><a href="http://www.wdvl.com/Internet/Protocols/HTTP/Request.html">GET</a> 
	and <a href="http://www.jmarshall.com/easy/http/#headmethod">HEAD</a> methods with query strings</li>
	<li><a href="http://www.jmarshall.com/easy/http/#postmethod">POST</a> 
	methods with formatted message bodies</li>
</ul>
<p> Regardless of whether or not you elect to use the program for setting the 
encryption key on your wireless router, the lesson should still teach you quite 
a lot about writing Java programs to communicate with HTTP servers.</p>
<p> <font color="#FF0000"><b>Seven sample programs</b></font></p>
<p> I will provide and explain seven sample programs, each designed to illustrate 
certain HTTP programming concepts.&nbsp; One of the programs will be designed to 
run against an HTTP server on the World Wide Web.&nbsp; The other five will be 
designed to run against the HTTP server that is built into a typical wireless 
router.&nbsp; <i>(Such HTTP servers are used by the router administrator to 
configure and manage the router.)</i></p>
<p> <font color="#FF0000"><b>Packet sniffing</b></font></p>
<p> Along the way, I will teach you a little about packet sniffing and show you 
how to eavesdrop on conversations between HTTP servers and HTTP clients.</p>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different listings and figures while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>In particular, I recommend that you review the lessons referred to in the
<a href="#References">References</a> section in preparation for understanding 
the material in this lesson.
</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>Typically, in tutorial lessons that involve one or two large programs, 
this is the place where I explain in detail what you can expect to find in each of the programs.&nbsp; However, this lesson will 
explain seven relatively small programs.&nbsp; To keep the level of confusion 
down, it will probably be better for me to defer the detailed technical 
discussion until we get to the sections where I explain the code for the programs.</p>
<p><font color="#FF0000"><b>Topics covered by the programs</b></font></p>
<p>The following list provides a very brief summary description of each of the 
seven programs:</p>
<ul>
	<li><b>Sockets15:</b>&nbsp; Illustrates general communication between an 
	HTTP client and an HTTP/1.1 server, which doesn't require authentication.&nbsp; 
	Also shows how to cause the server to forego <i>keep-alive</i> and to close 
	the connection at the end of each response by the server.</li>
	<li><b>Sockets14:</b>&nbsp; Illustrates basic authentication using a Linksys 
	WRT54G wireless router as the experimental platform.</li>
	<li><b>Sockets10:&nbsp; </b>Shows how to automatically install a new WEP 
	encryption key on a Linksys WRT54G wireless router requiring basic 
	authentication.</li>
	<li><b>Sockets11:</b>&nbsp; Shows how to automatically install a new WPA or 
	WPA2 shared encryption key on two different versions of a Linksys WRT54G 
	wireless router, one that supports WPA2, and one that does not support WPA2 
	but does support WPA.</li>
	<li><b>Sockets11A</b>:&nbsp; A stand alone, non-network program that 
	generates and displays the same encryption key generated by <b>Sockets11</b> 
	for any particular data.</li>
	<li><b>Sockets12:&nbsp; </b>Illustrates the authentication methodology on a 
	Belkin 54G wireless router using the custom scheme provided by that router 
	for that purpose.&nbsp; Note that this is completely different from the 
	basic authentication methodology used on the Linksys WRT54G router.</li>
	<li><b>Sockets13:&nbsp; </b>Shows how to automatically install a new WEP 
	encryption key on a Belkin 54G wireless router requiring custom 
	authentication.</li>
</ul>
<p><font color="#FF0000"><b>Packet sniffing</b></font></p>
<p>Sprinkled throughout the discussions of these programs will be a discussion 
of the use of the <a href="http://www.ethereal.com/">Ethereal Network Protocol 
Analyzer</a> program to discover exactly what is required to automate the normally 
manual process of installing encryption keys in these wireless routers.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
Complete listings of all of the programs are provided beginning in Listing 49 
near the end of the lesson.<p>I will discuss the programs in fragments in the 
sections that follow.</p>
<h3>The <a name="Sockets15">Sockets15</a> Class</h3>
<p>A complete listing of this program is provided in Listing 49 near the end of 
the lesson.</p>
<p>The program named <b>Sockets15</b> illustrates general communication between a program and an 
HTTP/1.1server, which doesn't require authentication.&nbsp; It also illustrates 
how to cause the server to forego the <i>keep-alive</i> feature and to close the 
connection at the end of each response message.</p>
<p>In operation, this programs attempts to get the headers for two different 
resources from the same server.&nbsp; The server that was used for the testing of this 
program normally implements keep-alive by default.&nbsp; Although the use of the 
keep-alive feature can improve network efficiency, programming an HTTP client 
program to support the keep-alive feature can be a very difficult task.&nbsp; 
Therefore, this program instructs the server to forego the keep-alive feature 
and to close the connection following the transmission of the response to each 
client request.</p>
<p>Sample output from the program is shown in the comments at the beginning of 
the program in Listing 49.&nbsp; In addition, I will show you portions of that 
output in the discussion that follows.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As is my custom, I will explain this program by discussing important parts of 
the program in fragments.&nbsp; The first such fragment is shown in Listing 1.</p>
<p>Listing 1 shows the beginning of the class including the declaration of three 
instance variables and the initialization of one of them.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sockets15{

  final String server = "www.austincc.edu";
  boolean closedFlag;
  SocketWrapper socketWrapper;<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The instance variable named <b>server</b> is initialized to contain the name 
of the server that I used to test this program.&nbsp; However, you could test 
the program against any HTTP/1.1 server that doesn't require authentication, and 
which implements keep-alive by default.</p>
<p><font color="#FF0000"><b>What is keep-alive anyway?</b></font></p>
<p>The original HTTP protocol was a simple request/response protocol.&nbsp; 
Using this simple protocol, the following steps occur during each request/response 
cycle:</p>
<ul>
	<li>The client establishes a socket connection with the server.</li>
	<li>The client sends a request for a resource to the server.</li>
	<li>The server either delivers the resource back to the client or sends an 
	error message.</li>
	<li>The server disconnects.</li>
</ul>
<p>While this is a very simple protocol to implement, it is also slow.&nbsp; Often, more 
time is required to make and break the connection than is required to exchange 
the request and the response.</p>
<p><font color="#FF0000"><b>The protocol was enhanced</b></font></p>
<p>As a result, somewhere along the way, the protocol was enhanced to make it possible for 
the client to send a sequence of requests to the server during a single 
connection, and for the server to send a sequence of matching responses back to 
the client during the same connection.&nbsp; This is generally referred to as 
<i><b>keep-alive</b></i>, and I will discuss some of the technical manifestations 
of the feature later.</p>
<p><font color="#FF0000"><b>Examples of complexity</b></font></p>
<p>While the advent of keep-alive can greatly improve the efficiency of the 
communications between the client and the server, it also causes the client 
program to be considerably more complex.&nbsp; For example, the client may send 
a request for resources A and B to the server before learning from the server 
that resource A is not available but resource B is available and is being 
delivered.&nbsp; However, resource B may be of no value to the client without 
resource A.</p>
<p>In addition, there is no guarantee that the server will support keep-alive 
over the long haul.&nbsp; The server may simply decide on its own to switch from 
keep-alive operation to the older request/response format after the client has 
already sent a long sequence of requests.&nbsp; The client program must be able to take issues like that into account and to make the necessary 
adjustments.</p>
<p><font color="#FF0000"><b>Can disable keep-alive</b></font></p>
<p>As a result, the HTTP/1.1 protocol makes it possible for client programs that 
don't have the ability to support keep-alive to instruct the server to revert 
back to the simple request/response form of the protocol by including a specific 
instruction in the request headers.&nbsp; As you will see shortly, this simple 
HTTP client program does not support keep-alive operation, and it does provide 
such an instruction to the server.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method is shown in its entirety in Listing 2.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    new Sockets15().doIt();
  }//end main<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>main</b> method simply instantiates an object of the class and invokes 
the instance method named <b>doIt</b> on that object.</p>
<p><font color="#FF0000"><b>The method named doIt</b></font></p>
<p>The method named <b>doIt</b> is the primary processing method for the class 
named <b>Sockets15</b>.</p>
<blockquote>
	<p><i>(In fact, the primary processing method for each of the seven sample 
	programs discussed in this lesson will be named <b>doIt</b>.)</i></p>
</blockquote>
<p>The method named <b>doIt</b> for the class named <b>Sockets15</b> begins in Listing 3.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void doIt(){

    socketWrapper = <b>getSocket</b>(server);<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 3 invokes the <b>getSocket</b> method to get a socket, 
which is connected to the specified server, on port 80.&nbsp; Port 80 is 
the standard HTTP port.&nbsp; The <b>getSocket </b>method also gets input and output streams 
on the socket that can be used to communicate with the server.&nbsp; References 
to the <b>Socket</b> object as well as the input and output stream objects are 
returned encapsulated in an object of the simple wrapper class named <b>
SocketWrapper</b>.</p>
<p><font color="#FF0000"><b>The SocketWrapper class</b></font></p>
<p>The <b>SocketWrapper</b> class is shown in its entirety in Listing 4.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  class <b>SocketWrapper</b>{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>An object of this class is used to encapsulate the references to the three 
objects described above, making it easy to return three values from the<b> 
getSocket</b> method.&nbsp; An object of the class consists of nothing more than 
three encapsulated instance variables, which will be populated with references 
to the three objects.</p>
<p><font color="#FF0000"><b><a name="The_getSocket_method">The getSocket method</a></b></font></p>
<p>The <b>getSocket</b> method begins in Listing 5.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  SocketWrapper <b>getSocket</b>(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
<br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of the<b> getSocket </b>method is to get a new <b>Socket</b> object connected to a server on port 80 along with input and output stream objects that can be used to communicate with the server 
by way of the connected socket.</p>
<p>References to the <b>Socket</b> object and the two stream objects are returned in a wrapper object of type
<b>SocketWrapper</b>.</p>
<blockquote>
	<p><i>(The <b>getSocket</b> method will be used in six of the programs 
	provided in this lesson.&nbsp; Therefore, I will explain it only once in 
	conjunction with the class named <b>Sockets15</b> and will simply refer to 
	it in the discussions of the other five programs.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Port 80</b></font></p>
<p>Listing 5 begins by declaring a variable named <b>port</b> and initializing 
it with the value of the standard HTTP port.</p>
<blockquote>
	<p><i>(Much of the background material that you will need to know in order 
	to understand the programs in this lesson, such as the standard HTTP port, 
	was provided in my earlier lessons.&nbsp; This includes lessons that are referred to 
	in the <a href="#References">References</a> section.)</i></p>
</blockquote>
<p>Then the code in Listing 5 instantiates a new empty object of the <b>
SocketWrapper</b> class, to be populated later with references to the three 
objects.</p>
<p><font color="#FF0000"><b>A new Socket object</b></font></p>
<p>Finally, Listing 5 instantiates a new <b>Socket</b> object that is connected 
to the specified server on port 80.&nbsp; When the constructor returns the 
connection will have been established.&nbsp; In the event that it is not 
possible to establish the connection, the constructor will throw an exception.&nbsp; 
As you will see later, this will cause the program to abort printing a stack 
trace in the process.</p>
<p><font color="#FF0000"><b>Get an input stream</b></font></p>
<p>Listing 6 gets an input stream object used later for reading the response sent by the server.&nbsp; 
The reference to the stream object is saved in the wrapper object of type <b>
SocketWrapper</b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The syntax for creating input and output streams in Java is rather 
complicated.&nbsp; You can read more about that syntax in my earlier lessons 
referred to in the <a href="#References">References</a> section.</p>
<p><font color="#FF0000"><b>Get an output stream</b></font></p>
<p>Listing 7 gets an eight-bit byte output stream object on the socket, <i>
(which will autoflush)</i>, and saves the reference to the stream object in the 
wrapper object.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>What does Sun have to say?</b></font></p>
<p>Sun has this to say about the <b>PrintStream</b> class:</p>
<blockquote>
	<p><i>&quot;All characters printed by a <b>PrintStream</b> are converted into 
	bytes using the platform's default character encoding. The <b>PrintWriter</b> 
	class should be used in situations that require writing characters rather 
	than bytes.&quot;</i></p>
</blockquote>
<p>I initially tried using an output stream of the <b>PrintWriter</b> class, <i>
(which delivers sixteen-bit character data instead of eight-bit byte data)</i>.&nbsp; 
When I began testing one of the later programs that uses the POST method to post 
data to the server, I discovered that the program did not work properly using 
the<b> PrintWriter </b>class.&nbsp; In order to cause the POST method to work properly, it was 
necessary for me to revert back to the <b>PrintStream</b> class that delivers 
eight-bit byte data instead of 16-bit character data.</p>
<p>Listing 7 returns a reference to the populated <b>SocketWrapper</b> object, 
which signals the end of the <b>getSocket</b> method.</p>
<p><font color="#FF0000"><b>Returning to the doIt method ...</b></font></p>
<p>Returning now to the discussion of the <b>doIt</b> method, Listing 8 displays 
a message informing the user that the program is going to invoke the <b>HEAD</b> 
method on the server.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    System.out.println("**Send initial HEAD command**");<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Invoke the HEAD method on the server</b></font></p>
<p><a name="Listing_9">Listing 9</a> uses the output stream to invoke the <i><b>
HEAD</b></i> method on the server.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    socketWrapper.outputStream.println("HEAD / HTTP/1.1");
    socketWrapper.outputStream.println("Host: " + server);
    //Ask the server to close the connection following the
    // response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here.
    socketWrapper.outputStream.println();<br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The HEAD method</b></font></p>
<p>The HEAD method is one of several methods that a client can invoke on a 
server.&nbsp; This lesson will discuss the following methods:</p>
<ul>
	<li>HEAD</li>
	<li>GET</li>
	<li>POST</li>
</ul>
<p><font color="#FF0000"><b>HTTP transactions</b></font></p>
<p>According to <a href="http://www.jmarshall.com/easy/http/">HTTP Made Really 
Easy</a>, </p>
<blockquote>
	<p><i>&quot;Like most network protocols, HTTP uses the client-server model: An 
	HTTP client opens a connection and sends a request message to an HTTP 
	server; the server then returns a response message, usually containing the 
	resource that was requested. After delivering the response, the server 
	closes the connection (making HTTP a stateless protocol, i.e. not 
	maintaining any connection information between transactions).&quot;</i></p>
</blockquote>
<p>Note that the above statement doesn't necessarily take the <i>keep-alive</i> 
feature that was introduced in version HTTP/1.1 into account.&nbsp; That's OK 
for us, however, because we are going to prevent the use of the keep-alive 
feature in these programs.</p>
<p><font color="#FF0000"><b>Format of request and response messages</b></font></p>
<p>According to the <a href="http://www.jmarshall.com/easy/http/">same source</a>, the <i>request</i> and <i>response</i> messages 
are similar consisting of:</p>
<ul>
	<li>An initial line</li>
	<li>Zero or more header lines <i>(at least one header line is required in an 
	HTTP/1.1 request message)</i></li>
	<li>A blank line consisting of a carriage return <i>(0x0D)</i> followed by a 
	line feed <i>(0x0A)</i>, often referred to as a CRLF, on a line by itself.</li>
	<li>An optional message body <i>(such as query data or query output)</i></li>
</ul>
<p>Because this lesson is mostly concerned with the creation and transmission of 
request messages <i>(as opposed to the creation or interpretation of response 
messages)</i> I will concentrate mostly on the format of requests.</p>
<blockquote>
	<p><i>(On the other hand, the earlier lesson entitled 
	<a href="http://www.developer.com/java/other/article.php/3592906">Using Java to 
	Clean Up Your Bookmark Library</a> is very concerned with the interpretation of 
	response messages.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The initial request line</b></font></p>
<p>The initial request line is very similar for HEAD, GET, and POST request 
messages.&nbsp; It has three parts as shown in Figure 1.</p>






<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>HEAD <font color="#FF0000">/path to requested resource</font> <font color="#0000FF">HTTP/x.x</font></b><br></pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The method</b></font></p>
<p>The first part of the initial request line is the name of the method to be 
invoked on the server <i>(HEAD in the case of Figure 1)</i>.&nbsp; This part is 
shown in black in Figure 1.&nbsp; Method names are always specified in 
uppercase.</p>
<p><font color="#FF0000"><b>The requested resource</b></font></p>
<p>The second part of the initial request line <i>(shown in red in Figure 1)</i> 
consists of a forward slash character followed by the path to the requested 
resource.</p>
<p>As I understand it, for the HEAD and GET methods, the requested resource 
specifies data that is to be sent by the server to the client.&nbsp; For the 
POST method, the requested resource names a script or program that is to be 
executed on the server to consume the POST data that will be sent later.</p>
<p>The GET method attempts to send the entire requested resource back to the 
client.&nbsp; The HEAD method attempts to send only the headers associated 
with the requested resource to the client.&nbsp; <i>(I will have more to say 
about headers later.)</i></p>
<p><font color="#FF0000"><b>The HTTP version</b></font></p>
<p>The third part of the initial request line <i>(shown in blue in Figure 1)</i>, 
specifies the HTTP version in the format shown, <i>(such as HTTP/1.0 or HTTP/1.1)</i>.&nbsp; 
This part is always in uppercase characters.</p>
<p><font color="#FF0000"><b>The case in point</b></font></p>
<p>Referring back to <a href="#Listing_9">Listing 9</a>, the first line requests 
that the server execute the HEAD method using HTTP version 1.1, applying that 
method to a specified resource whose name is blank.&nbsp; The use of a blank 
resource <i>(a forward slash followed by a blank character)</i> requests that 
the server use whichever resource it considers to be the default.</p>
<blockquote>
	<p><i>(In the early days of the web, the default resource was often a file 
	named index.html, but that seems to be less the case now.&nbsp; In many 
	cases, the default resource is the so-called &quot;home page&quot; for the server.)</i></p>
</blockquote>
<p>Because the requested method in <a href="#Listing_9">Listing 9</a> is HEAD, the client is requesting that only the 
headers for the requested resource be delivered and not the entire resource.</p>
<p><font color="#FF0000"><b>The request headers</b></font></p>
<p>The initial request line in <a href="#Listing_9">Listing 9</a> is followed by two header lines, which 
in turn are followed by the required blank line <i>(CRLF)</i>.</p>
<p>Many different header lines are possible.&nbsp; For example, 
<a name="Figure_2">Figure 2</a> shows a 
request sent by a Firefox browser to <a href="http://www.dickbaldwin.com">
http://www.dickbaldwin.com</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>GET / HTTP/1.1
Host: <a href="http://www.dickbaldwin.com">www.dickbaldwin.com</a>
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US;
 rv:1.7.10) Gecko/20050716 Firefox/1.0.6
Accept: text/xml,application/xml,application/xhtml+xml,text
/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Cookie: (cookie content deleted by Baldwin)<br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Captured using the Ethereal program</b></font></p>
<p>The material in Figure 2 was captured using the
<a href="http://www.ethereal.com/">Ethereal</a> 
program.&nbsp; <i>(Note that line breaks were manually inserted into Figure 2 to force the 
material to fit into this narrow publication format.)</i></p>
<p>I'm not going to try to teach you how to use the
<a href="http://www.ethereal.com/">Ethereal</a> program.&nbsp; Rather, I will 
simply refer you to the
<a href="http://www.ethereal.com/docs/eug_html_chunked/">Ethereal User's 
Guide</a>.&nbsp; There are many ways to view data that has been captured.&nbsp; 
As a hint, I will tell you that it is often convenient to save captured data to a text 
file and then to view the text file using a typical text editor program such as 
Notepad.&nbsp; That is how I was able to reproduce the material shown in Figure 
2.</p>
<p><font color="#FF0000"><b>Getting back to header lines ...</b></font></p>
<p>Header lines are intended to provide information about the request or the 
response.&nbsp; Generally, they are formatted as follows:</p>
<ul>
	<li>Each header resides on a separate line terminated by a CRLF.</li>
	<li>The information is provided in a <i>name:value</i> format with the name 
	and the value separated by a colon.</li>
	<li>The header name is not case sensitive.</li>
	<li>Any number of space or tab characters may follow the colon.</li>
	<li>A header may be continued onto the next line by beginning the 
	continuation line with a space or a tab character.</li>
</ul>
<p>Once again, according to <a href="http://www.jmarshall.com/easy/http/">HTTP 
Made Really Easy</a>:</p>
<blockquote>
	<p><i>&quot;HTTP&nbsp;1.0 defines 16 headers, though none are required.</i></p>
	<p><i>&nbsp;HTTP&nbsp;1.1 
	defines 46 headers, and one (<b><tt>Host:</tt></b>) is required in 
	requests.&quot;</i></p>
</blockquote>
<p>Thus, the first header line in <a href="#Listing_9">Listing 9</a> and 
<a href="#Figure_2">Figure 2</a> is the required <b>
Host:</b> header line, specifying the name of the server to which the request is 
directed.</p>
<p><font color="#FF0000"><b>Disabling keep-alive</b></font></p>
<p>As mentioned earlier, this program does not support the keep-alive feature 
that is <i>(apparently)</i> the default operating mode for HTTP/1.1 servers.&nbsp; 
Therefore, the second header line in <a href="#Listing_9">Listing 9</a>, 
beginning with <i>
<b>Connection:</b></i> is a request <i>(or instruction)</i> to the server to close the connection following 
the response to the request.&nbsp; This makes it possible for the program to 
operate in a simple request/response <i>ping-pong</i> mode, which is much less 
complex than trying 
to support the <i>keep-alive</i> operating mode.</p>
<p><font color="#FF0000"><b>Supporting keep-alive</b></font></p>
<p>The Firefox browser, on the other hand, is happy to support keep-alive.&nbsp; 
<a href="#Figure_2">Figure 2</a> shows two different header lines associated with the keep-alive 
feature.&nbsp; I'm confident that if you are interested, you can find more 
information about those header lines using <a href="http://www.google.com/">
Google</a>.</p>
<p><font color="#FF0000"><b>The required blank line</b></font></p>
<p>The second header line in <a href="#Listing_9">Listing 9</a> is followed by the required blank line 
consisting of a CRLF.</p>
<blockquote>
	<p><i>(Invoking the <b>println</b> method with no 
parameters produces the correct CRLF byte stream on a Windows system.&nbsp; I 
don't know if that is the case for all operating systems.&nbsp; If not, you can 
get the same result by invoking the <b>print</b> method and printing the 
hexadecimal character values 0x0D and 0x0A.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The captured request</b></font></p>
<p>Using <a href="http://www.ethereal.com/">Ethereal</a> to capture the 
conversation <i>(and deleting the non-readable characters involved in the 
conversation)</i> produces the request text shown in <a name="Figure_3">Figure 3</a>.&nbsp; This is 
the request that was sent from the client <i>(this program)</i> to the server.&nbsp; 
<i>(Figure 3 includes the required blank line.)</i></p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>HEAD / HTTP/1.1 
Host: www.austincc.edu
Connection: close<br></pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The captured response</b></font></p>
<p>The server response to the above request is shown in Figure 4.&nbsp; <i>(A 
line break was manually inserted into <a name="Figure_4">Figure 4</a> to force the material to 
fit into 
this narrow publication format.)</i></p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>HTTP/1.1 200 OK</b>
Date: Tue, 20 Dec 2005 14:36:21 GMT
Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10-1.
dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
X-Powered-By: PHP/4.3.10-1.dotdeb.0
<b>Connection: close</b>
Content-Type: text/html; charset=iso-8859-1

<b>Figure 4</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Perhaps the most interesting parts of the response are the initial response 
line and the header line that begins with the word Connection, both of which are 
highlighted in boldface in Figure 4.</p>
<p><font color="#FF0000"><b>HTTP/1.1 200 OK</b></font></p>
<p>According to <a href="http://www.jmarshall.com/easy/http/">HTTP Made Really 
Easy</a>, the status code value of 200 in the initial response line tells us:</p>
<blockquote>
	<i>&quot;The request succeeded, and the resulting resource (e.g. file or script 
output) is returned in the message body.&quot;</i></blockquote>
<p>Of course, since this is a HEAD request, there is no output other than the 
header lines.&nbsp; Had the request been a GET request, however, there would 
most likely have been quite a lot of output.</p>
<p><font color="#FF0000"><b>Connection: close</b></font></p>
<p>The header line in the response in <a href="#Figure_4">Figure 4</a> that begins with the word <b><i>Connection</i></b> 
tells us that the server is acknowledging our special request and that the 
connection will be closed at the end of the response.&nbsp; This tells us that 
in order to send another request to the server, we will need to get another 
socket object connected to the server.</p>
<p><font color="#FF0000"><b>Returning to the doIt method ...</b></font></p>
<p>The next statement in the <b>doIt</b> method, shown in Listing 10, invokes 
the local method named <b>print</b> to display up to fifteen lines of server response.&nbsp; 
The <b>print</b>&nbsp;method also gets and returns information about the closing of the connection.&nbsp; 
That information is saved in the variable named <b>closedFlag</b> to be used 
later.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    closedFlag = <b>print</b>(15,socketWrapper.inputStream);<br><br><b><font face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The <a name="print_method_1">print method</a></b></font></p>
<p>The <b>print</b> method is shown in its entirety in Listing 11.&nbsp; The purpose of this method is to get and display a specified number of lines of the server response.&nbsp; In the process, the method checks to determine if the server closed the 
connection at the end of its response.&nbsp; The method returns a boolean value indicating whether or not the server closed the connection.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  boolean print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "dummy";
    boolean closedFlag = false;
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);

        if(line.contains("Connection: close")){
          //The server closed the connection at the end of
          // the response.
          closedFlag = true;
        }//end if
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return closedFlag;
    
  }//end local method named print<br><br><b><font face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>print</b> method is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>Returning once more to the doIt method ...</b></font></p>
<p>Listing 12 begins by displaying a message.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    System.out.println("\n**Send another HEAD command.**");
    
    if(closedFlag){
      System.out.println("**Must get new socket**");
      socketWrapper = getSocket(server);
    }else{
      System.out.println(
                 "**Synchronization error, terminating**");
      System.exit(1);
    }//end else<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then the code in Listing 12 confirms that the connection was properly closed by the server at the end of the previous response.</p>
<ul>
	<li>If the connection was properly closed, the code in Listing 12 gets a new
	<b>Socket</b> connection with the server.</li>
	<li>If the connection was not closed, the code in Listing 12 displays an 
	error message and terminates the program.</li>
</ul>
<p>The comments at the beginning of Listing 49 show the result of both 
possibilities.</p>
<p><font color="#FF0000"><b>Invoke the HEAD method for a different resource</b></font></p>
<p><a name="Listing_13">Listing 13</a> invokes the HEAD method on the server to request that the headers 
be provided for a different resource.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    socketWrapper.outputStream.println(
                      "HEAD <b>/baldwin/index.html</b> HTTP/1.1");
    socketWrapper.outputStream.println("Host: " + server);
    socketWrapper.outputStream.println(
                                      "User-Agent: Dummy");
    //Ask the server to close the connection following the 
    // response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here
    socketWrapper.outputStream.println();

    //Print 15 lines of server response data.
    print(15,socketWrapper.inputStream);

    System.out.println("\n**End program output**");<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In this case, the resource is not blank.&nbsp; In other words, the client 
program is not requesting the default resource from the server.&nbsp; Rather the 
client program is requesting the headers for the file specified by the following 
path:</p>
<p><b>/baldwin/index.html</b></p>
<p><font color="#FF0000"><b>The captured request</b></font></p>
<p>The captured request information for this part of the conversation is shown in
<a name="Figure_5">Figure 5</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>HEAD /baldwin/index.html HTTP/1.1
Host: www.austincc.edu
User-Agent: Dummy
Connection: close<br></pre>
      <pre><b>Figure 5</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that I added a dummy header in Figure 5 that I didn't put in
<a href="#Figure_3">Figure 3</a>.&nbsp; As far as I know, unlike the other two 
header lines in Figure 5, the <b><i>User-Agent</i></b> header line is for 
information purposes only, and the server will take no special action based on 
that header line.&nbsp; Thus, it is really of no consequence, except perhaps 
that it may irritate the webmaster at the server end if she is keeping 
statistics on the different clients that communicate with her server.</p>
<p><font color="#FF0000"><b>What about the other two header lines?</b></font></p>
<p>You already know about the purpose and the result of the <i><b>Connection</b>
</i>header line, so what about the <b><i>Host</i></b> header line?&nbsp; As I 
indicated earlier, this is the only header line that is required for HTTP/1.1.&nbsp;
<i>(No header lines are required for HTTP/1.0.)</i></p>
<p>Figure 6 shows the response headers that would be received from this particular server if 
the <b><i>Host</i></b> header line is omitted.&nbsp; The most important item in 
Figure 6 is the boldface first line indicating unhappiness on the part of the 
server.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>HTTP/1.1 400 Bad Request</b>
Date: Tue, 20 Dec 2005 15:36:38 GMT
Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10-1.
dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
Connection: close
Content-Type: text/html; charset=iso-8859-1<br></pre>
      <pre><b>Figure 6</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(Once again, a line break was manually inserted into Figure 6 to force 
	the material to fit into this narrow publication format.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A captured response to a correct request</b></font></p>
<p>Figure 7 shows the server response to the correct client request shown in
<a href="#Figure_5">Figure 5</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>HTTP/1.1 200 OK
Date: Tue, 20 Dec 2005 14:36:21 GMT
Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10-1.
dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
<b>Last-Modified: Sat, 30 Jul 2005 00:31:16 GMT
ETag: &quot;16f8002-eda-42eaca54&quot;
Accept-Ranges: bytes
Content-Length: 3802</b>
Connection: close
Content-Type: text/html; charset=iso-8859-1<br></pre>
      <pre><b>Figure 7</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Additional information</b></font></p>
<p>Figure 7 shows several information items <i>(highlighted in boldface)</i> 
regarding this specific requested resource that were not included in the 
response of <a href="#Figure_4">Figure 4</a> when the request was for the default resource.&nbsp; Often, 
this information, <i>(particularly the date on which the resource was last 
modified and possibly the length of the resource)</i>, is what a client that 
invokes the HEAD method is looking for.&nbsp; For example, the client may 
compare that date with the date on a local copy of the resource and then invoke 
the GET method to download the entire resource if the version on the server is 
newer than the local copy.</p>
<p><font color="#FF0000"><b>Close the socket</b></font></p>

<p>Although this is probably unnecessary and redundant, the code in Listing 14 
closes the socket before ending the program just in case it hasn't been closed 
by the server.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{
      //Close the socket
      socketWrapper.socket.close();
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt<br><br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>And that brings us to the end of the program named <b>Sockets15</b>.&nbsp; 
Hopefully, you will have learned something new about HTTP communications in 
this section.&nbsp; The discussions of the other programs in the following 
sections will build upon this material.</p>
<h3>The <a name="Sockets14">Sockets14</a> Class</h3>
<p>A complete listing of this class is provided in Listing 50 near the end of 
the lesson.&nbsp; The purpose of the class is to illustrate <i>
<a href="http://httpd.apache.org/docs/1.3/howto/auth.html#basic">basic 
authentication</a></i>.</p>
<p>In order to avoid dealing with the complexities of keep-alive, the program 
asks the server to close the connection at the end of each response.</p>
<p>The class was tested and determined to authenticate properly with J2SE 5.0, 
WinXP, and a very recent Linksys WRT54G wireless router that supports WEP, WPA, 
and WPA2 encryption.</p>
<blockquote>
	<p><i>(This version of the router can be identified by the inclusion of SES 
	on the front panel.)</i></p>
</blockquote>
<p>The class was also determined to authenticate properly with a recent Linksys 
WRT54G wireless router that supports WEP and WPA encryption, but does not 
support WPA2 encryption.</p>
<blockquote>
	<p><i>(Note that both of these wireless routers have the same model number, 
	WRT54G.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The class definition for Sockets14</b></font></p>
<p>The class definition begins in Listing 15.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sockets14{

  final String server = "192.168.1.1";

  StateWrapper stateWrapper;
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets14().doIt();
  }//end main
  //-----------------------------------------------------//<br><br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that in this case, the server is specified by its IP address rather than 
by a domain name.&nbsp; <i>(I discuss the difference between the two in some of 
the lessons referred to in the <a href="#References">References</a> section.)</i></p>
<p>Listing 15 also shows the <b>main</b> method, which instantiates an object of 
the class and invokes the method named <b>doIt</b> on that object.</p>
<p><font color="#FF0000"><b>The doIt method</b></font></p>
<p>This <b>doIt</b> method will attempt a login on the administrator panel for 
the router using the administrator's user name and password.&nbsp; The <b>doIt</b> 
method begins in Listing 16.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void doIt(){

    final String adminUserPwd = "OmFkbWlu";<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The constant named <b>adminUserPwd</b> is initialized to contain the administrator password expressed in 
base64 format.&nbsp; The use of base64 encoding is a
<a href="http://frontier.userland.com/stories/storyReader$2159">requirement</a> 
of standard HTTP Basic Authentication.</p>
<blockquote>
	<p><i>(See my earlier lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3386271">
	Understanding Base64 Data</a> for an explanation of base64 encoding.&nbsp; Also see
	<a href="http://www.motobit.com/util/base64-decoder-encoder.asp">http://www.motobit.com/util/base64-decoder-encoder.asp</a> for an online base64 encoder/decoder 
	that you can use to easily encode and decode string data.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does OmFkbWlu mean?</b></font></p>
<p>The base64 value of <b>OmFkbWlu</b> given in Listing 16 is the value required for the default administrator username and password for a 
Linksys WRT54G wireless router.</p>
<blockquote>
	<p><i>(For example, go to
	<a href="http://www.motobit.com/util/base64-decoder-encoder.asp">
	http://www.motobit.com/util/base64-decoder-encoder.asp</a> and use the 
	decoder that you will find there to decode the base64 value of <b>OmFkbWlu</b> 
	and see what you get.&nbsp; You should get <b>:admin</b>.)</i></p>
</blockquote>
<p>For a Linksys WRT54G wireless router, the default username is 
blank and the default password is <b>admin</b>.&nbsp; Basic authentication 
requires the base64 value to be the encoded version of the concatenation of the 
username and the password separated by a colon.&nbsp; Since the default username is 
blank and the default password is <i>admin</i>, the base64 value given in Listing 16 is the encoded version of <b>:admin</b>.&nbsp;
<i>(Note the leading colon.)</i></p>
<p><font color="#FF0000"><b>Get a Socket object</b></font></p>
<p>The statement in Listing 17 invokes the <b>getSocket</b> method to get a <b>
Socket</b> object connected to the specified server on port 80.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    socketWrapper = getSocket(server);<br><br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is the same <a href="#The_getSocket_method">getSocket</a> method that was discussed <a href="#The_getSocket_method">
earlier</a>.&nbsp; The statement in Listing 17 also gets input and output streams that can be used to communicate with the server.</p>
<p><font color="#FF0000"><b>Send initial GET command</b></font></p>
<p>The code in <a name="Listing_18">Listing 18</a> displays a message on the screen and then invokes the
<i><b>GET</b> </i>method on the server, requesting that the default resource be 
downloaded in its entirety.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    System.out.println("**Send initial GET command**");

    socketWrapper.outputStream.println("<b>GET / HTTP/1.1</b>");
    socketWrapper.outputStream.println("Host: " + server);
    socketWrapper.outputStream.println(
                          "User-Agent: Dummy Header Line");
    //Ask the server to close the connection following
    // the response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here.
    socketWrapper.outputStream.println();<br><br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(Recall that the main difference between the HEAD method and the GET 
	method is that 
	invocation of the HEAD method requests only the headers for the specified 
	resource whereas invocation of the GET method requests the entire specified 
	resource.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Three header lines</b></font></p>
<p>The statement that invokes the GET method in <a href="#Listing_18">Listing 18</a> is followed by the 
same three header lines and the blank line that you saw in <i>
<a href="#Listing_13">Listing 13</a> (except 
that the dummy value given to the <b>User-Agent</b> is different.)</i>.</p>
<blockquote>
	<p><i>(If the default resource for the server were not a protected resource, 
	the server would respond by sending that resource to the client.&nbsp; However, that is 
	not the case here.&nbsp; The administrator panel for the Linksys router is a 
	protected resource.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The captured request</b></font></p>
<p>The code in Listing 18 resulted in the request shown in <a name="Figure_8">Figure 8</a>, as captured 
by the <a href="http://www.ethereal.com/">Ethereal</a> program.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>GET / HTTP/1.1 
Host: 192.168.1.1
User-Agent: Dummy Header Line
Connection: close<br></pre>
      <pre><b>Figure 8</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display the response</b></font></p>
<p>Listing 19 invokes the <b>print</b> method to display up to fifteen lines of 
the server response.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    stateWrapper = print(15,socketWrapper.inputStream);<br><br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>print</b> method in this class is very similar to the version that was 
discussed <a href="#print_method_1">earlier</a>.&nbsp; The only real difference 
between the two is that the earlier version monitored the response lines to 
determine if the server closed the connection following the response.&nbsp; This 
version does that also.&nbsp; In addition, this version also monitors the response lines 
to determine if authentication is required.</p>
<p><font color="#FF0000"><b>New code in the print method</b></font></p>
<p>You can view the entire <b>print</b> method in Listing 50.&nbsp; Listing 20 
shows the code in the <b>print</b> method that monitors for the requirement to 
authenticate the user.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>//This is code from the <b>print</b> method, not the doIt method.

        if(line.contains("401")){
          //Authentication is required
          stateWrapper.authFlag = true;
        }//end if<br><br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you will see shortly, if the server responds with a status code value of
<b>401</b>, that means that the requested resource is protected and the user 
must provide proper authentication credentials in order to gain access to the 
resource.&nbsp; The code in Listing 20 simply monitors for the substring 401 in 
the response.</p>
<blockquote>
	<p><i>(Upon reflection during the writing of this lesson, I realized that it would be 
	possible for the server to deliver an unprotected resource containing the 
	substring 401.&nbsp; That would cause the program to falsely conclude that 
	authentication is required.&nbsp; I should have confirmed that the line 
	containing the 
	substring 401 was the first line of the response before reaching that 
	conclusion.&nbsp; This is a bug in the program.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Another difference</b></font></p>
<p>Another difference between this version of the <b>print</b> method and the
<a href="#print_method_1">earlier</a> version has to do with how the results are 
returned.&nbsp; In the <a href="#print_method_1">earlier</a> version, only one 
return value was required.&nbsp; In this version, two return values are 
required:</p>
<ul>
	<li>One value for authentication information</li>
	<li>One value for connection closing status </li>
</ul>
<p>Therefore, in this version, the two values are encapsulated in an object of the 
simple
<b>StateWrapper</b> class and a reference to that object is returned.</p>
<p><font color="#FF0000"><b>The response</b></font></p>
<p>Figure 9 shows the text returned by the server in the Linksys WRT54G wireless 
router when a request is 
made for the default resource as shown in <a href="#Figure_8">Figure 8</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>HTTP/1.0 401 Unauthorized</b>
Server: httpd
Date: Thu, 01 Jan 1970 00:00:29 GMT
<b>WWW-Authenticate: Basic realm="WRT54G"</b>
Content-Type: text/html
Connection: close

&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;401 Unauthorized&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY BGCOLOR="#cc9999"&gt;&lt;H4&gt;401 Unauthorized&lt;/H4&gt;
Authorization required.
&lt;/BODY&gt;&lt;/HTML&gt;<br></pre>
      <pre><b>Figure 9</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>HTTP/1.0 401 Unauthorized</b></font></p>
<p>Regarding the <b>401 Unauthorized</b> response,
<a href="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#Code401">
one resource</a> has this to say:</p>
<blockquote>
	<p><i>&quot;The request requires user <b>authentication</b>. The response must 
	include a <b>WWW-Authenticate</b> header field ... containing a challenge 
	applicable to the requested resource. The client may repeat the request with 
	a suitable <b>Authorization</b> header field ...&quot;</i></p>
</blockquote>
<p>Thus, the inclusion of the 401 status code indicates that the user must be 
authenticated before gaining access to the protected resource.&nbsp; This would 
cause a typical browser to display a form into which the user could enter the 
username and the password.&nbsp; The form would also provide a<b> Submit</b> 
button, by which the user could cause the request to be retransmitted to the 
server with authentication credentials included in the request.</p>
<p><font color="#FF0000"><b>What about the Basic realm?</b></font></p>
<p>Here is some of what the folks at
<a href="http://httpd.apache.org/docs/1.3/howto/auth.html#basic">Apache</a> have 
to say about the system in general and the realm in particular:</p>
<blockquote>
	<p><i>&quot;When a ... resource has been protected using <b>basic authentication</b>, 
	Apache sends a 401 Authentication Required header with the response ... to 
	notify the client that user credentials must be supplied ...</i></p>
	<p><i>... the client's browser, ... will ask the user to supply a username 
	and password to be sent to the server. ... If the username is in the 
	approved list, and if the password supplied is correct, the resource will be 
	returned to the client.</i></p>
	<p><i>... <b><a name="each_request">each request</a> will be treated in the same way</b>, even though 
	they are from the same client. ... every resource which is requested ... 
	will have to supply authentication credentials ... to receive the resource.</i></p>
	<p><i>... the browser takes care of the details ... you only have to type in 
	your username and password one time per browser session...</i></p>
	<p><i>... other information will be passed back to the client. ... [the 
	server] sends a name which is ... the protected area of the web site. <b>
	This is called the realm</b>.... The client browser caches the username and 
	password that you supplied, and stores it along with the authentication 
	realm ... if other resources are requested from the same realm, the same 
	username and password can be returned to authenticate that request without 
	requiring the user to type them in again.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>A very important conclusion</b></font></p>
<p>This leads us to an important conclusion.&nbsp; Since the Linksys WRT54G 
router requires authentication simply to view the default page, this tells us 
that we will be required to send authentication credentials with every request 
that we send to the Linksys router for any resource whatsoever.</p>
<blockquote>
	<p><i>(Later you will see that this is not the case for a Belkin 54G router.&nbsp; 
	The server in the Belkin 54G router will deliver the default page, 
	containing lots of routine information, without a requirement for 
	authentication.&nbsp; It is only when the user needs to make changes to the 
	router configuration that authentication is required.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A new request with authentication</b></font></p>
<p>On the strength of web research and packet capture using the
<a href="http://www.ethereal.com/">Ethereal</a> program, I concluded that in 
order to access the default resource on the Linksys WRT54G router, I would need to send 
the request shown in the captured data in <a name="Figure_10">Figure 10</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>GET / HTTP/1.1 
Host: 192.168.1.1
User-Agent: Dummy
<b>Authorization: Basic OmFkbWlu</b>
Connection: close<br></pre>
      <pre><b>Figure 10</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note the inclusion of the boldface header that begins with the word <b>
Authorization</b>, followed by a space and the word <b>Basic</b>, followed in 
turn by another space and the base64-encoded user name and password.</p>
<p><font color="#FF0000"><b>Correct Authentication Request Header?</b></font></p>
<p>According to <a href="http://frontier.userland.com/stories/storyReader$2159">
this web resource</a>, </p>
<blockquote>
	<p><i>&quot;Upon receipt of the server's 401 response, your web browser prompts 
	you for the username and password associated with that realm. The 
	Authentication header of your browser's follow-up request again contains the 
	token &quot;Basic&quot; and the <b>base64-encoded</b> concatenation of the username, a colon, 
	and the password.</i></p>
	<p><i>Authorization: Basic [base64-username:password]</i></p>
	<i>The server base64-decodes the credentials and compares them against his 
	username-password database. If it finds a match, you are in.&quot;</i></blockquote>
<p><font color="#FF0000"><b>The response</b></font></p>
<p>Sending the request with the authentication credentials shown in
<a href="#Figure_10">Figure 10</a> caused the server to respond as shown in 
<a name="Figure_11">Figure 11</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>1: HTTP/1.0 200 Ok
2: Server: httpd
3: Date: Thu, 01 Jan 1970 00:00:33 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
10:
11: &lt;!--
12: *******************************************************
13: *   Copyright 2003, CyberTAN  Inc.  All Rights Reserved
14: *******************************************************
15:<br></pre>
      <pre><b>Figure 11</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Figure 11 shows only the first fifteen lines of the response with the line 
numbers being inserted by the program.&nbsp; Also, the long lines were truncated 
to force the material to fit into this narrow publication format.</p>
<p>As you can see, lines 11 through 15 contain the beginning of the HTML code 
describing the default home page for the Linksys router.</p>
<p><font color="#FF0000"><b>What about HTTP/1.0 200 Ok?</b></font></p>
<p>According to
<a href="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#Code200">
this web resource</a>,</p>
<blockquote>
	<p><i>200 OK</i></p><i>The request has succeeded. The information returned with the 
	response is dependent on the method used in the request, as follows: 
	</i> 
	<p><i>GET an entity corresponding to the requested resource is sent in the 
	response; </i> </p>
	<p><i>HEAD the response must only contain the header information and no 
	Entity-Body; </i> </p>
	<p><i>POST an entity describing or containing the result of the action.</i></p>
</blockquote>
<p>Since the GET method was used in Figure 10, and a specific resource was not 
specified, the information returned with the response was an entity 
corresponding to the default home page for the server.&nbsp; If you were to view 
this page with a regular browser, you would see that it is the main page used by 
the administrator for setting configuration parameters for the wireless router.</p>
<p><font color="#FF0000"><b>The remaining code</b></font></p>

<p>Listing 21 shows the remaining code in the <b>doIt</b> method.&nbsp; Note in 
particular the boldface code that causes the authentication credentials to be 
sent with a new request for the default server resource.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if(stateWrapper.authFlag){
      System.out.println("**Authorization required**");

      if(stateWrapper.closedFlag){
        System.out.println("**Must get new socket**");
        socketWrapper = getSocket(server);
      }else{
        System.out.println(
                 "**Synchronization error, terminating**");
        System.exit(1);
      }//end else
     
      System.out.println("\n**Re-send the GET command "
                               + "with authentication.**");
      socketWrapper.outputStream.println("GET / HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                                      "User-Agent: Dummy");
      socketWrapper.outputStream.println(
                   <b>"Authorization: Basic " + adminUserPwd)</b>;
      //Ask the server to close the connection following
      // the response.
      socketWrapper.outputStream.println(
                                      "Connection: close");
      //The following CRLF is required here
      socketWrapper.outputStream.println();

      //Print 15 lines of server response data.
      print(15,socketWrapper.inputStream);
    }//end if on authFlag

    System.out.println("\n**End program output**");
      
    try{
      //Close the socket
      socketWrapper.socket.close();
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt<br><br><b><font face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Knowing what you know now, there should be no mystery as to how the code 
shown in Listing 21 produced the results shown in <a href="#Figure_10">Figure 10</a> and 
<a href="#Figure_11">Figure 11</a>.</p>
<p><font color="#FF0000"><b>All is not perfect however</b></font></p>
<p>Although this program properly authenticates with the server for two 
different relatively new versions of the Linksys WRT54G wireless router, despite 
many hours spent doing web research and pouring over
<a href="http://www.ethereal.com/">Ethereal</a> capture dumps, I was unable to 
cause the program to properly authenticate with two other Linksys routers.</p>
<p>One of the problem routers was an old Linksys BEFW11S4 
802.11B wireless router.&nbsp; The other problem router was an old Linksys BEFSR41Cable router.&nbsp; The same 
symptoms were exhibited by both of the older Linksys routers.&nbsp; They 
wouldn't close the connection following the 401 message response even when requested to 
do so.&nbsp; Then they ignored a following GET command containing the 
authentication request header.</p>
<p><font color="#FF0000"><b>Old routers work OK with a standard browser</b></font></p>
<p>Both of the older routers authenticate properly when operated using a Firefox 
browser or an Internet Explorer browser.&nbsp; I finally gave up and concluded 
that there is something that the browsers know how to do to make the older 
routers happy that I 
was unable to identify from either the web research or the
<a href="http://www.ethereal.com/">Ethereal</a> dumps.</p>
<p><font color="#FF0000"><b>You may need to customize the programs</b></font></p>
<p>The important message here is that unless you are using a Linksys WRT54G 
router, you shouldn't necessarily expect the programs in this lesson to work 
perfectly correctly with your router.&nbsp; Depending on the specifics of your router, 
you may have to download the <a href="http://www.ethereal.com/">Ethereal</a> 
program <i>(or some similar program)</i> and examine the dumps of captured 
conversations between your browser and your router to determine how to customize 
these programs to make them compatible with your router.</p>
<p>And that is probably more than you ever wanted to know about HTTP basic 
authentication.</p>
<h3>The <a name="Sockets10">Sockets10</a> Class</h3>
<p>A complete listing of this class is provided in Listing 51 near the end of 
this lesson.</p>
<p>This class can be used to connect to a Linksys WRT54G wireless router <i>
(with or without SES/WPA2)</i> to change the WEP key.</p>
<p>The program installs a ten-character hexadecimal WEP key in the router.&nbsp; 
It would be a simple matter to modify the program to cause it to install a 
26-character WEP key instead.</p>
<p>Note that for simplicity, this class uses some deprecated methods.&nbsp; Note 
also that for simplicity, it asks the server to forego the use of keep-alive.</p>
<p>The new key is displayed on the screen along with some other information.&nbsp; 
When the program terminates successfully, the new WEP key shown on the screen has been installed in the 
wireless router.</p>
<p>This class was tested with J2SE 5.0, WinXP, and two different versions of the 
Linksys WRT54G wireless router.</p>
<p><font color="#FF0000"><b>What have we learned so far?</b></font></p>
<p>We have learned that we can disable keep-alive operation on the server by 
including the following line in the request headers:</p>
<p><b>Connection: close</b></p>
<p><font color="#FF0000"><b>Authentication</b></font></p>
<p>We have learned that we can satisfy the authentication requirements of the 
Linksys server by including the following line in the request headers:</p>
<p><b><a name="Authorization:_Basic_OmFkbWlu">Authorization: Basic OmFkbWlu</a></b></p>
<p>where <b>OmFkbWlu</b> is the base64 encoded version of the concatenated 
username and password with the two being separated by a colon.&nbsp; The default user name and password are<b> :admin</b> where the default 
username is blank.</p>
<blockquote>
	<p><i>(Hopefully you have changed the default user name and password on your 
	wireless router.&nbsp; You can encode your username and password at
	<a href="http://www.motobit.com/util/base64-decoder-encoder.asp">
	http://www.motobit.com/util/base64-decoder-encoder.asp</a> and use the 
	result to replace the encoded value shown
	<a href="#Authorization:_Basic_OmFkbWlu">above</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Each individual request must be authenticated</b></font></p>
<p>We have learned that with basic authentication, <a href="#each_request">each 
request</a> must be separately authenticated because the HTTP protocol is a 
stateless protocol.&nbsp; As a result, if we already know that the resource that 
we are requesting is protected using basic authentication, then there is no need 
for us to go through the <i>&quot;401 Unauthorized&quot;</i> drill just to be notified by 
the server that the resource is protected.&nbsp; Rather, we can skip all of that 
and start the process by requesting the resource of interest and including the
<a href="#Authorization:_Basic_OmFkbWlu">authentication credentials</a> in the 
request headers.</p>
<p><font color="#FF0000"><b>The resource of interest</b></font></p>
<p>By paying careful attention to what was going on when I manually set the WEP 
password using a browser, and by using the <a href="http://www.ethereal.com/">
Ethereal</a> program to confirm my observations, I determined that the resource 
of interest for setting the WEP password in a Linksys WRT54G wireless router is:</p>
<p><b>/apply.cgi</b></p>
<p><font color="#FF0000"><b>Must invoke the POST method</b></font></p>
<p>Also, by using the <a href="http://www.ethereal.com/">Ethereal</a> program to 
monitor the conversation when I manually set the WEP key, I determined that the 
method invocation that is required to set the key is:</p>
<p><b>POST /apply.cgi HTTP/1.1</b></p>
<p><font color="#FF0000"><b>The body of the POST message</b></font></p>
<p>Finally, by using the <a href="http://www.ethereal.com/">Ethereal</a> program 
to intercept, capture, and analyze the conversation <i>(and this is where the
<a href="http://www.ethereal.com/">Ethereal</a> program is indispensable)</i>, I 
concluded that the syntax of the body of the POST message used to set the WEP 
key is as shown in Figure 12.&nbsp; <i>(Line breaks were manually inserted into 
Figure 12 to force the material to fit into this narrow publication format.)</i></p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>submit_button=WL_WPATable&amp;change_action=&amp;submit_type=&amp;actio
n=Apply&amp;security_mode_last=&amp;wl_wep_last=&amp;security_mode2=wep
&amp;wl_key=1&amp;wl_WEP_key=&amp;wl_wep=restricted&amp;wl_wep_bit=64&amp;wl_pa
ssphrase=&amp;generateButton=Null&amp;wl_key1=<b>a4cb6e0679</b>&amp;wl_key2=&amp;w
l_key3=&amp;wl_key4=<br></pre>
      <pre><b>Figure 12</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The new WEP key is shown in boldface in Figure 12.</p>
<p><font color="#FF0000"><b>Figuring it all out</b></font></p>
<p>Perhaps it should have been possible for me to analyze the source code for 
the web page containing the form that is used to change the WEP key and to 
determine the format shown in Figure 12 without the help of the
<a href="http://www.ethereal.com/">Ethereal</a> program.&nbsp; However, I have 
neither the patience nor the HTML skills to pull that off.</p>
<p>Unless you have such patience and HTML skills, it will probably be necessary 
for you to use a similar program for analyzing your router if it is not a 
Linksys WRT54G router.</p>
<p><font color="#FF0000"><b>Writing the program</b></font></p>
<p>Once I realized that I knew all of the things that I have discussed above, it 
was a simple matter to write the Java program to automatically change the WEP 
key.&nbsp; A discussion of that program follows.</p>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The beginning of the class definition is shown in Listing 22.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sockets10{
  
  String server = "192.168.1.1";
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets10().doIt();
  }//end main
  //-----------------------------------------------------//<br><br><b><font face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing new in Listing 22.&nbsp; It shows the declaration of a 
couple of instance variables and the <b>main</b> method.&nbsp; </p>
<p><font color="#FF0000"><b>The doIt method</b></font></p>
<p>The <b>doIt</b> method begins in Listing 23.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void doIt(){
    String wepKey = getWepKey();

    System.out.println("New WEP key: " + wepKey);<br><br><b><font face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Get and display the new WEP key</b></font></p>
<p>Listing 23 invokes the method named <b>getWepKey</b> to get a new 
ten-character hexadecimal WEP key based on the current date and a random number 
generator.</p>
<p><font color="#FF0000"><b>The method named getWepKey</b></font></p>
<p>This method generates a ten-character hexadecimal key based on the current 
date and a random number generator.</p>
<p>The algorithm will generate the same key every time it is run on a given 
date, but will generate different keys on different dates.</p>
<p>You can easily modify this algorithm to come up with a different recipe for 
the key.&nbsp; </p>
<p>Also, you can easily modify this method to cause it to generate a 
26-character hexadecimal key instead of a ten-character key.</p>
<blockquote>
	<p><i>(If you do 
that, you will need to make some changes to the body of the POST message in the
	<b>doIt</b> 
method to cause that message to accommodate 26-character keys.)</i></p>
</blockquote>
<p>Note that for simplicity involving dates, this method uses some deprecated 
methods.</p>
<p>The <b>getWepKey</b> method begins in <a name="Listing_24">Listing 24</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  String getWepKey(){
    final int bias = 12345;//a secret value
    final int lim = 8;//another secret value
<br><b><font face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two secret values</b></font></p>
<p>The code in Listing 24 declares and initializes the secret values for two 
constants that impact the overall security of the WEP key that is generated.&nbsp; 
If you use this class for your own purposes, you should change these 
two values.</p>
<p><font color="#FF0000"><b>Get the current date</b></font></p>
<p>Listing 25 begins by instantiating a <b>Date</b> object that encapsulates the 
current date and time according to the system clock.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
<br><b><font face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>For this algorithm, we want to use the current date but we don't want to use the 
current time.&nbsp; 
In particular, if this algorithm is executed on different computers on the same 
date, we 
want the algorithm to produce the same key on both machines.&nbsp; We don't want 
that result to be influenced by the fact that the algorithm is executed at 
different times within the same date on the two machines.</p>
<p>The code in Listing 25 manipulates the <b>Date</b> object, ending up with a
<b>Date</b> object in which the time has been set to zero.&nbsp; Thus, the 
object contains the date only.</p>
<p><font color="#FF0000"><b>Instantiate a pseudorandom number generator</b></font></p>
<p>An instance of the<b> Random </b>class is used to generate a stream of 
pseudorandom numbers.&nbsp; A seed is passed to the constructor for the class 
when the object is instantiated.&nbsp; 
If two instances of <b>Random</b> are created with the same seed, and the same 
sequence of method calls is made on each object, they will generate and return 
identical sequences of numbers.&nbsp; Conversely, if the two instances are 
created with different seeds, they will generate and return different sequences 
of numbers.</p>
<p><font color="#FF0000"><b>An object of the class Random</b></font></p>
<p>Listing 26 instantiates an object of the class <b>Random</b> using a seed 
that is based on the current date as modified by a secret value named <b>bias</b> known 
only to you.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
<br><b><font face="Courier New,Courier">Listing 26</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Unless an attacker knows the secret value, the probability is extremely low 
that he will be able to instantiate a <b>Random</b> object that 
generates and returns the same sequence of numbers as your object.</p>
<p>On the other hand, if you install the algorithm using the same secret value on two or more machines and 
ascertain that the system clocks are showing the same dates on all of the 
machines, they will 
all produce the same sequence of numbers on any given date.</p>
<p><font color="#FF0000"><b>Advance the random sequence</b></font></p>
<p>Listing 27 advances through the random sequence of numbers by discarding the 
first <b>n</b> numbers, where <b>n</b> is another secret value named <b>lim</b> known only to you.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt();
    }//end for loop
<br><b><font face="Courier New,Courier">Listing 27</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, if you install the algorithm on two or more machines as described 
above, and use the same secret value for <b>n</b> on each of the machines, the 
same quantity of random numbers will be discarded on all machines, causing all 
of the machines to be in synchronism once the numbers are discarded.</p>
<blockquote>
	<p><i>(The use of two secret values is probably redundant.&nbsp; It may be 
	just as secure to use only one secret value.&nbsp; It just feels better to 
	use two of them.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Get a random number</b></font></p>
<p>Finally, Listing 28 gets the actual random number that will be used to 
generate the hexadecimal key.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    long val = randomGen.nextLong();
<br><b><font face="Courier New,Courier">Listing 28</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The random number will be a 64-bit <b>long</b> value.&nbsp; However, it is 
possible that it may have leading bits with a value of zero.&nbsp; This is 
undesirable.&nbsp; Because the <b>long</b> value is maintained in two's 
complement format, one way to guarantee that there are no leading zero bits is to 
force the value to be a negative value.&nbsp; In this case, 
the first bit will always have a value of 1.</p>
<p><font color="#FF0000"><b>Make it negative</b></font></p>
<p>Listing 29 forces the <b>long</b> value to be negative, thus guaranteeing 
that there is a 1 in the first bit position.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if(val == 0)val = -1;
    if(val &gt; 0) val = -val;
<br><b><font face="Courier New,Courier">Listing 29</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Extract a ten-character hexadecimal substring</b></font></p>
<p>Listing 30 converts the <b>long</b> value to a <b>String</b> of sixteen 
hexadecimal characters, and then extracts the first ten characters from the 
string.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    String stringInProgress = 
                     Long.toHexString(val).substring(0,10);

    return stringInProgress;
    
  }//end getWepKey<br><br><b><font face="Courier New,Courier">Listing 30</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(This is another place where you could change the recipe.&nbsp; For 
	example, you could extract and return the middle ten characters instead of 
	the first ten characters.)</i></p>
</blockquote>
<p>Listing 30 returns the hexadecimal string to be used as the new WEP key.&nbsp; 
</p>
<p>Listing 30 also signals the end of the <b>getWepKey</b> method.</p>
<p><font color="#FF0000"><b><a name="Just_how_secure_is_this_scheme">Just how secure is this scheme?</a></b></font></p>
<p>My concept is to have this program running automatically on a scheduled basis 
in the middle of the night on a machine that is connected to the router
by a cable.</p>
<blockquote>
	<p><b><i>(Never run this program on a machine that has a wireless connection 
	to the router.&nbsp; If you do, you will simply be broadcasting the new WEP 
	key.&nbsp; Keep in mind however, that the router has a built-in wireless 
	access point, and that raises the question that I will pose below.)</i></b></p>
</blockquote>
<p>Running the program in the automatic mode will cause a new WEP key to be 
installed on the wireless router each time the program is run.</p>
<p><font color="#FF0000"><b>Once again, just how secure is this scheme?</b></font></p>
<p>With regard to the question regarding the security of the scheme, I don't 
have the expertise to answer that question.&nbsp; <i>(See the earlier
<a href="#A_disclaimer">disclaimer</a>.)</i>&nbsp; I will simply teach you how 
to write the program.&nbsp; It will be up to you to do the necessary research to 
decide for yourself whether or not you should use it.</p>
<p>The real question is the following, and it is a question for which I don't 
know the answer.&nbsp; If you know the answer, I will be interested in hearing 
from you via email.&nbsp; </p>
<blockquote>
	<p><i>The real question is, if you use a computer connected by cable to a 
	router that has a built-in wireless access point, is it possible for the 
	communications between that computer and the router that are conducted via 
	cable to be intercepted by another computer on a wireless basis using a 
	packet sniffing program?</i></p>
</blockquote>
<p>If the answer to that question is yes, then the scheme isn't secure at all, 
and you probably shouldn't use it.</p>
<p><font color="#FF0000"><b>A local program on each machine</b></font></p>
<p>My scheme also has a simplified <i>(strictly local)</i> version <i>(see 
Sockets11a, for example)</i> of the 
program with the same algorithm installed on all of the other machines in the 
wireless network.&nbsp; When the users of those machines come to work in the 
morning, they will run the local version of the program on their machines to 
learn the new encryption key for the day.&nbsp; Then they will connect to the wireless 
router by typing in the new key on their machine when the encryption key is requested.</p>
<blockquote>
	<p><i>(If they were connected to the router on a wireless basis when the key 
	was changed, they <a href="#successfully_connected">should have been disconnected</a> automatically by the router.&nbsp; 
	In other words, as far as the router is concerned, if they were connected 
	using the old key, they are no longer authorized to maintain a connection 
	unless they can provide the new encryption key.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Alternatives to a local program</b></font></p>
<p>Encryption key management is one of the most difficult aspects of security.&nbsp; 
If having a local version of the program on each machine in the network is a 
concern <i>(and it might be in a small office environment but probably not in 
a home)</i>, there are a couple of other alternatives that might work.</p>
<p><font color="#FF0000"><b>Using Public Key Cryptography</b></font></p>
<p>One alternative would be to update the program to cause it to use
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography</a> and to
<a href="http://www.developer.com/java/other/article.php/3553521">send an email 
message</a> with an encrypted version of the new wireless router encryption key 
to each employee each time it is changed.&nbsp; I believe that this would be a 
pretty good approach.&nbsp; With this approach, the two secret values could be 
changed frequently by the network administrator without her having to install a 
recompiled version of the program on each machine.&nbsp; Then, even if an 
ex-employee were to know the algorithm, he wouldn't know the secret values necessary to 
use it.</p>
<p><font color="#FF0000"><b>Printing a list of encryption keys</b></font></p>
<p>A second alternative would be to write a simple program containing the same 
algorithm by which the network administrator could print the key for every day 
of the month in advance and distribute a copy to each employee at the beginning 
of the month.&nbsp; Of course, those employees would need to keep the list 
locked in their desks.</p>
<blockquote>
	<p><i>(Somehow this sounds like the worst approach of all.&nbsp; Some 
	employees would probably post the list on the side of a file 
cabinet in their office using refrigerator magnets to keep it in place.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>I am not a network security expert</b></font></p>
<p>As I mentioned early in this lesson, I am not a security expert.&nbsp; 
However, this scheme looks to me like a reasonable way to easily change the encryption key on a daily basis to keep the attackers off balance.&nbsp; 
Unless the attackers can crack the encryption key within 24 hours, this should 
prevent them from being able to break into the wireless network.</p>
<p><font color="#FF0000"><b>And then I learn the truth ...</b></font></p>
<p>I will probably receive a flood of email messages after publication of 
this lesson showing me that this scheme can easily be cracked by a ten-year old 
kid with a hand calculator.</p>
<p><font color="#FF0000"><b>More on this scheme later, let's get back to the program</b></font></p>
<p>Listing 31 picks back up in the <b>doIt</b> method where the new WEP key has 
been generated and it is time to install it in the wireless router.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    final String adminUserPwd = "OmFkbWlu";<br><br><b><font face="Courier New,Courier">Listing 31</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 31 declares and initializes the constant that contains the 
administrator username and password in base64 format.&nbsp; There's nothing new 
here.</p>
<p><font color="#FF0000"><b>Get a Socket object</b></font></p>

<p>Listing 32 gets a new <b>Socket</b> object connected to the server on port 
80.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{
      socketWrapper = getSocket(server);
      
      System.out.println("POST /apply.cgi HTTP/1.1");<br><br><b><font face="Courier New,Courier">Listing 32</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 32 also displays a message to the effect that a POST is about ready 
to begin.</p>
<p><font color="#FF0000"><b>Send the POST request</b></font></p>

<p><a name="Listing_33">Listing 33</a> sends the POST request followed by three header lines and a blank 
line as required.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.outputStream.println(
                               "<b>POST /apply.cgi HTTP/1.1</b>");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                   "Authorization: Basic " + adminUserPwd);
      socketWrapper.outputStream.println(
                                    "<b>Content-Length: 252</b>");
      //The following CRLF is required here.
      socketWrapper.outputStream.println();<br><br><b><font face="Courier New,Courier">Listing 33</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The new material here is the format of the POST request and the header line 
that specifies the length of the message body that is to follow, shown in 
boldface in Listing 33.</p>
<blockquote>
	<p><i>(I believe that I determined experimentally that the header line that 
	specifies the length of the message body is required.&nbsp; This is another 
	place where the <a href="http://www.ethereal.com/">Ethereal</a> program 
	comes in extremely handy.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Post the new WEP key</b></font></p>

<p><a name="Listing_34">Listing 34</a> posts the new WEP key on the server just as though a human user 
filled in the form and clicked the <b>Submit</b> button.</p>
<p>This syntax was captured from the actual data stream produced by a browser 
using the <a href="http://www.ethereal.com/">Ethereal</a> program.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.outputStream.print(
        "submit_button=WL_WPATable"
        + "&change_action="
        + "&submit_type="
        + "&action=Apply"
        + "&security_mode_last="
        + "&wl_wep_last="
        + "&security_mode2=wep"//WEP security mode
        + "&wl_key=1"//Default is key 1
        + "&wl_WEP_key="
        + "&wl_wep=restricted"
        + "&wl_wep_bit=64"//64-bit WEP key
        + "&wl_passphrase="//Passphrase is blank
        + "&generateButton=Null"//Passphrase is not used
        + "&wl_key1=" + <b>wepKey</b> //Value for Key 1
        + "&wl_key2="//Blank key
        + "&wl_key3="//Blank key
        + "&wl_key4=");//Blank key
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);<br><br><b><font face="Courier New,Courier">Listing 34</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A LF without a CR</b></font></p>
<p>Note that this statement calls the <b>print</b> method instead of the <b>
println</b> method, and then adds a
<b>
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/spsdk11/Intro_Chapter/method_syntax.asp">LF</a></b> without a <b>
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/spsdk11/Intro_Chapter/method_syntax.asp">CR</a></b> at the end.</p>
<blockquote>
	<p><i>(In doing the backup research for this lesson, I probably spent more 
	time trying to discover that the POST message body must end with a LF 
	instead of a CRLF than on any other topic.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The remainder of the doIt method</b></font></p>
<p>The remaining code in the <b>doIt</b> method is shown in Listing 35.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Display fifteen lines of server response data.
      print(15,socketWrapper.inputStream);

      System.out.println("End POST operation");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt<br><br><b><font face="Courier New,Courier">Listing 35</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing new in Listing 35.</p>
<p><font color="#FF0000"><b>Upgrade to a WPA or WPA2 encryption key</b></font></p>
<p>Now that you know how to write a Java program that will automatically 
generate and install a new ten-character hexadecimal WEP key on a Linksys WRT54G 
wireless router, it is time to learn how to generate and install a WPA or WPA2 
encryption key on the router for improved security.</p>
<blockquote>
	<p><i>(I will let you research the difference between
	<a href="http://www.openxtra.co.uk/articles/wpa-vs-wep.php">WEP, WPA</a>, 
	and <a href="http://www.openxtra.co.uk/articles/wpa-vs-80211i.php">WPA2</a> 
	encryption keys and the security differences among them on your own.)</i></p>
</blockquote>
<p>Remember, however, that before you can use either a WPA key or a WPA2 key on 
the wireless router, all of the computers on your wireless network must be able 
to support such a key.&nbsp; For example, I still have a machine on my home 
network running Windows 98.&nbsp; Although Windows 98 does support the use of a 
WEP key, as near as I can tell, Windows 98 won't support the use of a WPA key.&nbsp; 
As a result, I'm still running my home network using a WEP key <i>(but I change 
it every night on a random basis)</i>.</p>
<h3>The <a name="Sockets11">Sockets11</a> Class</h3>
<p>A complete listing of this class is provided in Listing 52 near the end of 
the lesson.</p>
<p>This class can be used to connect to a Linksys WRT54G wireless router <i>
(with or without SES/WPA2)</i> to change the WPA shared key.</p>
<p>The router requires that the WPA key be 63 characters or less.&nbsp; This 
class generates a fifteen-character WPA key based on the current date and a 
random number generator.&nbsp; The class could be easily modified to extend the 
length of the key up to 63 characters if you choose to do so.</p>
<p><font color="#FF0000"><b>Different behavior for different versions</b></font></p>
<p>When this class is used with an older Linksys router that doesn't support 
WPA2 but does support WPA, the class sets the configuration to <i>WPA Pre-Shared Key and TKIP</i>.&nbsp; 
</p>
<p>When used with a newer router that supports WPA2, the class sets the 
configuration to <i>WPA2 Personal and TKIP+AES</i>.</p>
<p>For simplicity, this class uses some deprecated methods.</p>
<p><font color="#FF0000"><b>The new key is displayed</b></font></p>
<p>The new key is displayed on the screen.&nbsp; When the program terminates 
successfully, 
the new WPA key shown on the screen has been installed in the wireless router.</p>
<p>The class was tested using J2SE 5.0, WinXP, and two different versions of a 
Linksys WRT54G wireless router, one that supports WPA2 and one that doesn't.</p>
<p><font color="#FF0000"><b>A complete listing of the class</b></font></p>
<p>As mentioned above, a complete listing of the class is provided in Listing 52.&nbsp; 
This class is very similar to the class that I explained under
<a href="#Sockets10">The Sockets10 Class</a>.&nbsp; Therefore, I won't bore you 
by repeating the explanation for code that is essentially the same.&nbsp; 
Rather, I will highlight the code that is different between the two classes.</p>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The class definition begins in Listing 36.&nbsp; The first new code occurs at 
the point where the method named <b>getWpaKey</b> is called to generate and 
return the WPA key.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sockets11{
  
  final String server = "192.168.1.1";
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets11().doIt();
  }//end main
  //-----------------------------------------------------//

  //This is the main processing method in the class.  
  void doIt(){
    //Get a fifteen-character key based on the date
    // and a random number generator.
    String wpaSharedKey = <b>getWpaKey()</b>;
    System.out.println("New key: " + wpaSharedKey);<br><br><b><font face="Courier New,Courier">Listing 36</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The method named getWpaKey</b></font></p>

<p>The method named <b>getWpaKey</b> begins in Listing 37.&nbsp; This method 
generates a 15-character key in the form ccc.ccc.ccc.ccc based on the current 
date and a random number generator.</p>
<p>The characters range from the character <b>0</b> <i>(<a href="http://www.lookuptables.com/">ASCII</a> 
value 48)</i> through the character <b>z</b> <i>(<a href="http://www.lookuptables.com/">ASCII</a> 
value 122)</i> inclusive.</p>
<p>The algorithm will generate the same key every time that it is run on a given 
date, but will generate different keys on different dates.</p>
<p>You can easily modify this algorithm to come up with a different recipe for 
the key, or a longer key using the same general recipe, or both.</p>
<p>Note that for simplicity, this method uses some deprecated methods in the 
handling of dates.</p>
<p><font color="#FF0000"><b>The method code</b></font></p>
<p>The <b>getWpaKey</b> method begins in Listing 37.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  String getWpaKey(){
    int bias = 12345;//a secret value
    int lim = 8;//another secret value
    
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
    
    //Instantiate a random number generator seeded by the
    // date and the first secret value given above.
    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
    
    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt(123);
    }//end for loop
<br><b><font face="Courier New,Courier">Listing 37</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 37 is essentially the same as the code that I explained 
earlier beginning in <a href="#Listing_24">Listing 24</a>.</p>
<p><font color="#FF0000"><b>Construct sequence of twelve characters</b></font></p>

<p>Listing 38 constructs a sequence of twelve characters using sequential random values between 48 and 122 inclusive.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    StringBuffer stringInProgress = new StringBuffer();
    while(stringInProgress.length() &lt; 12){
      int val = randomGen.nextInt(123);
      if(val &gt; 47){
        stringInProgress.append((char)val);
      }//end if
    }//end while loop
<br><b><font face="Courier New,Courier">Listing 38</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As mentioned earlier, the character values represent the characters from <b>0</b> through 
<b>z</b> when viewed 
according to an ASCII collating sequence.</p>
<p><font color="#FF0000"><b>Insert periods every third character</b></font></p>

<p>This method assumes that a user may be required to manually enter the WPA key 
when setting up a wireless connection on a client computer.&nbsp; To make this 
task easier, Listing 39 inserts a period every third character.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    stringInProgress.insert(9,'.');
    stringInProgress.insert(6,'.');
    stringInProgress.insert(3,'.');
    
    return stringInProgress.toString();
    
  }//end getWpaKey<br><br><b><font face="Courier New,Courier">Listing 39</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(In most cases, it should be possible for the user to copy the key and paste 
it into the form used to set up the wireless connection.&nbsp; In those cases, 
the code to insert the periods should be eliminated, and the length of the key 
should be significantly increased for improved security.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Getting back to the doIt method ...</b></font></p>

<p>The code in Listing 40 is essentially the same as the code that I explained 
in conjunction with the class named <a href="#Sockets10">Sockets10</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //The following constant contains the administrator
    // password expressed in base64.
    // See http://www.motobit.com/util/base64-decoder
    // -encoder.asp for an online base64 encoder/decoder.
    //The following value is for the default administrator
    // username and password for a Linkys wireless router
    // where the user name is blank and the password is
    // admin. The user name and the password must be
    // separated by a colon.  Since the username is blank,
    // this is the base64 representation of :admin
    final String adminUserPwd = "OmFkbWlu";
    
    try{
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);
      
      //Set up to post the data to the server.
      System.out.println("POST /apply.cgi HTTP/1.1");
      
      socketWrapper.outputStream.println(
                               "POST /apply.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                   "Authorization: Basic " + adminUserPwd);
<br><br><b><font face="Courier New,Courier">Listing 40</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the content length</b></font></p>

<p>The code in Listing 41 differs from the code that I explained earlier in the 
following way.&nbsp; The code that I explained in conjunction with the class 
named <a href="#Sockets10">Sockets10</a> was based on the assumption of a 
fixed-length ten-character hexadecimal key.&nbsp; </p>
<blockquote>
	<p><i>(Recall that the choices for the length of a WEP key are exclusively 
	ten characters and 26 characters.&nbsp; I assumed that you were not likely 
	to modify the program to generate a 26-characteter key.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.outputStream.println("Content-Length: "
                          + (<b>183 + wpaSharedKey.length()</b>));
      //The following CRLF is required here.
      socketWrapper.outputStream.println();<br><br><b><font face="Courier New,Courier">Listing 41</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 41 assumes that you are very likely to modify the program 
to increase the key length because it is so easy to do.&nbsp; Therefore, the 
code in Listing 41 takes the length of the key into account when setting the 
content length for the POST message.&nbsp; Obviously this code could easily be 
retrofitted into the code for the WEP key in <a href="#Listing_33">Listing 33</a>.</p>
<p><font color="#FF0000"><b>Post the data to the server</b></font></p>

<p>Listing 42 shows the message body for the POST message.&nbsp; As before, the 
actual syntax was captured using the <a href="http://www.ethereal.com/">Ethereal</a> program.&nbsp; </p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      socketWrapper.outputStream.print(
        "submit_button=WL_WPATable"
        + "&change_action="
        + "&submit_type="
        + "&action=Apply"
        + "&security_mode_last="
        + "&wl_wep_last="
        + "&security_mode2=wpa2_personal"//WPA2 Personal
        + "&wl_crypto=tkip%2Baes"//TKIP+AES
        + "&wl_wpa_psk=" + wpaSharedKey
        + "&wl_wpa_gtk_rekey=3600");//Renewal @ 3600 sec
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);<br><br><b><font face="Courier New,Courier">Listing 42</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, the POST message body for the WPA key is somewhat shorter 
than the POST message body for the WEP key shown in <a href="#Listing_34">
Listing 34</a>.&nbsp; This is because the Linksys data entry form for a WPA key 
is simpler than the data entry form for a WEP key.</p>
<p><font color="#FF0000"><b>The remainder of the code</b></font></p>

<p>Listing 43 shows the remaining code in the <b>doIt</b> method.&nbsp; This 
code is essentially the same as the code that I explained earlier.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Display fifteen lines of server response data.
      print(15,socketWrapper.inputStream);

      System.out.println("End POST operation");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt<br><br><b><font face="Courier New,Courier">Listing 43</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h3><a name="The_Sockets11a_Class">The Sockets11a 
Class</a></h3>
<p>Now I am going to describe how you might implement this
<a href="#Just_how_secure_is_this_scheme">scheme</a> in a home or small office 
network under Windows XP Professional.&nbsp; Before you do so, make certain that 
you read the <a href="#A_disclaimer">disclaimer</a> that I provided earlier.</p>
<p><font color="#FF0000"><b>A simplified local version of the program</b></font></p>
<p>Listing 53 provides a class named <b>Sockets11a</b>, which is a simplified 
version of the class named <b>Sockets11</b>.&nbsp; The <b>Sockets11a</b> 
class is designed to compute and display the WPA key for a given date using the 
same algorithm as in <b>Sockets11</b>.&nbsp; It has no network connection but runs as a local Java application.</p>
<p><font color="#FF0000"><b>You have two computers on your network</b></font></p>
<p>Assume that you have two computers in your home network.&nbsp; Let's call 
them <i>Computer A</i> and <i>Computer B</i>.</p>
<blockquote>
	<p><i>(This procedure should work for any number of computers on the network 
	provided one of them is connected to the wireless router via a cable.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Computer A is connected via cable</b></font></p>
<p>Computer A is a computer that you have connected to the wireless 
router using a cable.&nbsp; The main purpose for keeping Computer A on the 
network is to use it as a disk backup machine and possibly as a file or print 
server.&nbsp; You install the program 
named <b>Sockets11</b> on this machine and schedule it to run at 1:00 am each 
morning.</p>
<blockquote>
	<p><i>(See the earlier lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3564211">
	Consolidating Email using Java, Part 2</a> to learn how to schedule Java 
	programs to run automatically at preset times under Windows XP.)</i></p>
</blockquote>
<p><b>Never run the program named Sockets11 on a computer that is connected to 
the wireless router using a wireless connection.&nbsp; If you do, you will be 
broadcasting your new WPA key to anyone who may be listening.</b></p>
<p><font color="#FF0000"><b>Computer B has a wireless connection</b></font></p>
<p>Computer B is a laptop computer, running Windows XP, with a wireless network interface card installed.&nbsp; 
You routinely use this computer to communicate with the Internet via your 
Linksys WRT54G wireless router.&nbsp; You install the program named <b>
Sockets11a</b> on Computer B.</p>
<p><font color="#FF0000"><b>The time sequence</b></font></p>
<p>Assume that you successfully used Computer B to communicate with the Internet 
via the Linksys WRT54G wireless router on Monday.&nbsp; At 1:00 am on Tuesday morning, the WPA password on the wireless 
router is automatically changed by the program named <b>Sockets11 </b>running on 
Computer A.</p>
<p>Assume that you keep Computer B running during the night so that it will 
perform a complete virus scan.&nbsp; When you get up on Tuesday morning, Windows 
XP may still be showing that Computer B is <a name="successfully_connected">successfully connected</a> to the wireless 
network.&nbsp; However, when you attempt to connect to
<a href="http://www.google.com/">Google</a>, you get a message from the browser 
telling you that the browser could not find the requested page or words to that 
effect.&nbsp; This is because you originally connected to the wireless router on 
Monday using a WPA key that is no longer valid.</p>
<p><font color="#FF0000"><b>Re-establish the wireless connection</b></font></p>
<p>You need to re-establish the wireless connection using the new WPA key.&nbsp; 
You can accomplish that by performing the following steps:</p>
<ul>
	<li>First run the program named <b>Sockets11a</b> on Computer B and note the 
	key value that is displayed.&nbsp; Just leave the command-line screen on the 
	desktop because you are going to copy the new key from it and paste it into 
	a Windows text field later.</li>
	<li>Open the <b>Start</b> menu, select <b>Connect To</b>, and right click on
	<b>Wireless Network Connection</b>.&nbsp; Select <b>Properties</b> in the 
	popup menu.&nbsp; This should open the <b>Wireless Network Connection 
	Properties</b> dialog.</li>
	<li>Select the <b>Wireless Networks</b> tab.&nbsp; Remove the wireless 
	network from the list of preferred networks on the basis of the network SSID
	<i>(name)</i>.</li>
	<li>Click the <b>Add</b> button.&nbsp; This should expose the <b>Wireless 
	network properties</b> dialog.</li>
	<li>Enter the network name in the SSID field if it isn't already there.</li>
	<li>Select <b>WPA-PSK</b> for <b>Network Authentication</b>.</li>
	<li>Select <b>AES</b> for <b>Data encryption</b> if your router supports 
	WPA2.&nbsp; Select <b>TKIP</b> if your router doesn't support WPA2.</li>
	<li>Copy the new network key from the command-line screen and paste it into 
	the two text fields that require the key.</li>
	<li>Click the <b>OK</b> button to close the <b>Wireless network properties</b> 
	dialog.</li>
	<li>Click the <b>OK</b> button to close the <b>Wireless Network Connection 
	Properties</b> dialog.&nbsp; Your wireless network icon in the system tray 
	should now be showing that you have been disconnected from the wireless 
	router.</li>
	<li>Open the <b>Start</b> menu, select <b>Connect To</b>, and right click on
	<b>Wireless Network Connection</b> again.&nbsp; This time select <b>View 
	Available Wireless Networks</b> on the popup menu.&nbsp; <i>(You can also 
	get there from the wireless icon in the system tray.)</i></li>
	<li>Highlight the wireless network associated with your Linksys wireless 
	router and click the <b>Connect</b> button.</li>
	<li>Paste the new key into the two required text fields on the <b>Wireless 
	Connection Dialog</b> if requested and click the <b>Connect</b> button on 
	that dialog.&nbsp; After a few seconds, the <b>Wireless Network Dialog</b> 
	as well as the wireless icon in the system tray should show that you are 
	connected to the wireless router.</li>
	<li>Now go back and confirm that you can successfully connect to
	<a href="http://www.google.com/">Google</a> via the Internet.</li>
</ul>
<p><font color="#FF0000"><b>Congratulations</b></font></p>
<p>If the stingy neighbor in the apartment next door has been trying to crack 
your WPA key so that he can piggy back onto your Internet connection and avoid 
having to pay for a connection of his own <i>(or possibly for more malicious 
reasons)</i> he will now have to start all over because the WPA key has changed.&nbsp; 
And it will change once every twenty-four hours if you use these two programs to 
implement the procedure described above.</p>
<p><font color="#FF0000"><b>Not as complicated as it looks</b></font></p>
<p>The above procedure looks complicated, but it is actually quite easy to 
perform once you get used to it.&nbsp; In addition, there are several shortcuts 
that you will probably discover to shorten the procedure.&nbsp; However, I have 
described the long procedure that I believe will always work because some 
shortcuts may work some of the time but not all of the time.</p>
<p><font color="#FF0000"><b>What if you don't have a Linksys WRT54G wireless 
router?</b></font></p>
<p>Then you will simply have to take what you have learned in this lesson and 
write a version of the program that is compatible with your wireless router.&nbsp; 
Once you have done that, the procedure described above should still work just 
fine with your program.</p>
<h3>The <a name="Sockets12">Sockets12</a> Class</h3>
<p>Now for something really different.&nbsp; I don't actually use a Linksys 
WRT54G wireless router in my home network.&nbsp; Rather, I use an older Belkin 54G, which, with rebates, was the cheapest one that I could find several 
years ago when I decided to upgrade my home network to support wireless.</p>
<p>The Belkin router supports both WEP and WPA.&nbsp; However, as I mentioned 
earlier, because I still have a computer on my network running Windows 98, I 
haven't been able to implement the more-secure WPA, because it appears to be 
incompatible with Windows 98.</p>
<p>The program required to set the encryption key in the Belkin router is much 
different from the program required to set the encryption key in the Linksys 
router.</p>
<p><font color="#FF0000"><b>No basic authentication</b></font></p>
<p>The biggest difference between the two routers is the mechanism by which the 
administrator establishes credentials that allow her to modify the router 
configuration parameters.</p>
<p>When you connect to the Linksys router with your browser, the first and only 
thing that you see is the basic authentication login screen.&nbsp; Until you 
enter an acceptable username and password, you are not allowed to see anything 
else.</p>
<p>When you connect to the Belkin router with your browser, you immediately see 
the router's home page that displays a great deal of information about 
the router configuration.</p>
<blockquote>
	<p><i>(That is probably not so good because an attacker who manages to crack 
	your encryption key and connect to your router can learn a great deal about 
	the router configuration even if he doesn't know the administrator 
	password.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>You will need to log in</b></font></p>
<p>Near the top of that screen is a note that reads:</p>
<blockquote>
	<p><i>&quot;You will need to log in before you can change any settings.&quot;</i></p>
</blockquote>
<p>On the left side of the screen is a list of more than twenty options for 
setting the router configuration.</p>
<p>As mentioned above, a great deal of information is displayed in the center of 
the screen, including MAC addresses, IP addresses, SSID, etc.</p>
<blockquote>
	<p><i>(This is another good reason for trying to make certain that the 
	neighbor can't crack the encryption key.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Click to Login</b></font></p>
<p>Near the very top of the screen are three hyperlinks that read:</p>
<p><b>Home | Help | Login</b></p>
<p>When you point to the <b>Login</b> link with your mouse, the browser displays the 
link as <b>login.html</b>.&nbsp; In other words, clicking that link will cause 
the file named <b>login.html</b> to be downloaded and displayed by your browser.</p>
<p>When the <b>login.html</b> file is displayed by your browser, there is a 
single text field for entry of a password along with a <b>Clear</b> button and a
<b>Submit</b> button.&nbsp; There is no concept of a username relative to 
authentication on the Belkin router.</p>
<p><font color="#FF0000"><b>Study the HTML source code</b></font></p>
<p>If you are willing to study the source code for the HTML page, you can 
determine that clicking the <b>Submit</b> button will invoke the GET method on the 
server, requesting the resource named <b>login.cgi</b>, and passing three 
parameters as a query string.</p>
<blockquote>
	<p><i>(However it is much easier to get that information through the use of 
	the <a href="http://www.ethereal.com/">Ethereal</a> program.)</i></p>
</blockquote>
<p>Once you have logged in with an acceptable password, you can select any of 
the options on the left side of the screen, including the option entitled <b>Wireless Security</b>.</p>
<p><font color="#FF0000"><b>The Wireless Security page</b></font></p>
<p>The <b>Wireless Security</b> page allows you to select one of the following 
<b>Security 
Mode</b> options:</p>
<ul>
	<li>Disabled</li>
	<li>WPA-PSK (no server)</li>
	<li>128bit WEP</li>
	<li>64bitWEP</li>
	<li>WPA (with Radius Server)</li>
</ul>
<p>Depending on the <b>Security Mode</b> that you select, the data entry form will 
change to become appropriate for the data required for that <b>Security Mode</b>.&nbsp; 
The program that I will describe later is based on a <b>Security Mode</b> selection of 
<i>64bit WEP</i>.</p>
<p>In addition to the normal data entry fields for WEP security, this page 
provides a <b>Submit</b> button labeled <b>Apply Changes</b>.</p>
<p><font color="#FF0000"><b>Examine the HTML source code</b></font></p>
<p>Once again, by examining the source code for the HTML page, it can be 
determined that clicking the <b>Submit</b> button will invoke the POST method on the 
server, requesting the resource named <b>postapply.cgi</b>, and passing a very 
large number of parameters in the body of the POST message.</p>
<blockquote>
	<p><i>(Also, once again, it is much easier to determine this through the use of 
the <a href="http://www.ethereal.com/">Ethereal</a> program, particularly with 
regard to the format of the body of the POST message.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The Logout hyperlink</b></font></p>
<p>At this point, the <b>Login</b> hyperlink has changed to a <b>Logout</b> 
hyperlink.&nbsp; Pointing to the <b>Logout</b> hyperlink with the mouse indicates 
that 
the associated resource is named <b>logout.cgi</b>.&nbsp; Clicking the <b>Logout</b> 
link returns you to the initial home page.</p>
<p><font color="#FF0000"><b>Login is persistent</b></font></p>
<p>Somehow, the router keeps track of the fact that the administrator is logged 
in and won't allow another login to occur until the first one logs out or the 
current login expires.</p>
<blockquote>
	<p><i>(A configuration parameter that must be set along with the 
	administrator password is a parameter named <b>Login Timeout</b>.)</i></p>
</blockquote>
<p>I don't know how the server keeps track of the fact that the administrator is 
currently logged in.&nbsp; Initially I suspected that it was done using cookies, 
but I didn't write any support for cookies in my program and it still works 
fine.</p>
<p><font color="#FF0000"><b>The Sockets12 class</b></font></p>
<p>The first class that I will explain 
illustrates the procedure for logging in and logging out of a Belkin 54G router, without any attempt to 
set the encryption key.&nbsp; A complete listing of this class is shown in 
Listing 54.</p>
<p>I'm going to begin by showing you the screen output produced by the program 
named <b>Sockets12</b>.&nbsp; That output is shown in <a name="Figure_13">Figure 13</a>.</p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>**Login**
**Display 9 lines of the server's response**
1: <b>HTTP/1.0 200 Ok</b>
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 15:32:34 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Login done**

**Logout**
**Display 9 lines of the server's response**
1: <b>HTTP/1.0 200 Ok</b>
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 15:32:39 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Logout done**
**End program output**<br></pre>
      <pre><b>Figure 13</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"> <b>HTTP/1.0 200 Ok</b></font></p>
<p>To make a long story short, the two server response message lines highlighted in 
boldface that read <b>HTTP/1.0 200 Ok</b> demonstrate that the program was 
successful in logging in and then logging out of the server as an administrator.</p>
<p>Much of the code in this class is very similar to code that I 
have already explained in this lesson.&nbsp; Therefore, I won't repeat that 
explanation.</p>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The class definition for the class named <b>Sockets12</b> begins in Listing 
44.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Sockets12{
  
  String server = "192.168.2.1";
  SocketWrapper socketWrapper;
  //Administrator password.  Note that this is not
  // expressed in Base64 as is the case with basic
  // authentication.
  <b>final String adminUserPwd = "admin"</b>;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets12().doIt();
  }//end main
  //-----------------------------------------------------//<br><br><b><font face="Courier New,Courier">Listing 44</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The only thing that is new in Listing 44 is the fact that this login 
methodology does not require the administrator password to be expressed in 
base64 as is the case with HTTP basic authentication.</p>
<p><font color="#FF0000"><b>The doIt method</b></font></p>
<p>The method named <b>doIt</b> begins in Listing 45.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void doIt(){

    try{
      System.out.println("\n**Login**");
      
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);

      //Send the login command
      socketWrapper.outputStream.println("<b>GET /login.cgi?"
        + "page=login"
        + "&logout=2"
        + "&pws=" + adminUserPwd</b> + " HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();<br><br><b><font face="Courier New,Courier">Listing 45</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Login involves the GET method</b></font></p>
<p>The thing that is new about Listing 45 is that the actual login occurs as a 
result of invoking the GET method on the server, requesting a resource named <b>
login.cgi</b>, and passing three parameters to the resource as a 
<a href="http://en.wikipedia.org/wiki/Query_string">query string</a>.</p>
<p>I was able to capture the syntax for this request using the
<a href="http://www.ethereal.com/">Ethereal</a> program.&nbsp; Given my limited 
knowledge of HTML, I would have been hard pressed to figure it out otherwise.</p>
<p><font color="#FF0000"><b>Display the response</b></font></p>
<p>Listing 46 invokes the local <b>print</b> method to get and to display up to 
nine lines of server response data.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      System.out.println(
           "**Display 9 lines of the server's response**");
      <b>print</b>(9,socketWrapper.inputStream);
      System.out.println("\n**Login done**");<br><br><b><font face="Courier New,Courier">Listing 46</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This produced the top half of the output shown in <a href="#Figure_13">Figure 
13</a> with the line numbers being inserted by the <b>print</b> method.</p>
<p><font color="#FF0000"><b>The logout code</b></font></p>

<p>Listing 47 shows the code that is used to logout from the router.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Now log out from the router.

      System.out.println("\n**Logout**");
      
      //Get a new Socket object and I/O streams.
      socketWrapper = getSocket(server);

      //Send the logout command
      socketWrapper.outputStream.println(
                               "<b>GET /logout.cgi HTTP/1.1</b>");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);
      System.out.println("\n**Logout done**");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
    System.out.println("**End program output**");
  }//end doIt<br><br><b><font face="Courier New,Courier">Listing 47</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Knowing what you now know, there is nothing in Listing 47 that should require 
further explanation.</p>
<p><font color="#FF0000"><b>Setting the WEP key</b></font></p>
<p>Now it is time for us to examine the code used to set the WEP key on the 
Belkin router.&nbsp; We will accomplish that using the class named <b>Sockets13</b>.</p>
<h3><b>The <a name="Sockets13">Sockets13</a> Class</b></h3>
<p>A complete listing of the <b>Sockets13</b> class is provided in Listing 55.&nbsp; This class can be used to connect to a Belkin 54G wireless router and to change the WEP key.&nbsp; The 
class installs a ten-character hexadecimal WEP key in the router.&nbsp; It would be a simple matter to modify the program to cause
<br>
it to install a 26-character WEP key.</p>
<p>Much of the code in the class named <b>Sockets13</b> is very 
similar to code previously explained in this lesson.&nbsp; I won't repeat that 
explanation here.&nbsp; Rather, I will concentrate on the code that is 
different.</p>
<p><font color="#FF0000"><b>The output</b></font></p>
<p>Once again, I am going to begin by showing you the output produced by this 
program.&nbsp; That output is shown in Figure 14</p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b>New WEP key: e0d5ae876d</b>

**Login**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:24 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Login done**

**Post new WEP key**
**Display 9 lines of the server's response**
<b>1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:28 GMT
4: Content-Type: text/html
5: Connection: close
6:
7: &lt;html lang="en"&gt;&lt;head&gt;&lt;title&gt;Wireless Broadband Router&lt;/
title&gt;&lt;/head&gt;&lt;body bgcolor=white&gt;&lt;p&gt;&lt;font size=3 face=arial
&gt;&lt;p&gt;&lt;font size=2 face=arial&gt;&lt;p&gt;&lt;p&gt;&lt;font size=0 face=arial&gt;&lt;
/b&gt;&lt;/font&gt;&lt;br&gt;&lt;script&gt; timer = setTimeout('location.replace
("wireless_encrypt_64.html")', 0) &lt;/script&gt; &lt;p&gt;&lt;/body&gt;&lt;/htm
l&gt;</b>

**WEP key post is done**

**Logout**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:34 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Logout done**
**End program output**<br></pre>
      <pre><b>Figure 14</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The new material</b></font></p>
<p>The new material is shown in boldface in Figure 14.&nbsp; This new material 
consists of:</p>
<ul>
	<li>The display of the new WEP key at the beginning of the output.</li>
	<li>Nine lines of server response data, resulting from the invocation of the 
	POST method to install the new WEP key.&nbsp; This material appears near the 
	middle of Figure 14.</li>
</ul>
<p>As you can see, the server response to the invocation of the POST method 
began with <b>HTTP/1.0 200 Ok</b>, indicating that the server was happy with the 
process.&nbsp; In addition, a physical examination of the <b>Wireless Security</b> page 
using a browser confirmed that the WEP key was properly installed.</p>
<p><font color="#FF0000"><b>The new code</b></font></p>
<p>The new code for the class named <b>Sockets13</b> is shown in Listing 48.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Send the post command

      socketWrapper.outputStream.println(
                           "POST <b>/postapply.cgi</b> HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                                    "<b>Content-Length: 386</b>");
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      //Post the data to the server as though a user 
      // clicked the submit button.  This syntax was 
      // captured from the actual data stream produced
      // by a browser using the Ethereal program.
      //Note that this statement calls the print method
      // instead of the println method, and then adds a LF
      // without a CR at the end.
      socketWrapper.outputStream.print(
        "page=wireless_enc64"
        + "&logout=2"
        + "&generate_flag=1"
        + "&webpage=wireless_encrypt_64.html"
        + "&wl0_wep=wep"
        + "&wl0_key1=" + <b>wepKey</b>
        + "&wl0_key2="
        + "&wl0_key3="
        + "&wl0_key4="
        + "&wl0_auth_mode=disabled"
        + "&wl0_wep_mode=64"
        + "&wl0_wep64_manual=1"
        + "&action=Apply"
        + "&wl0_sec_mode=64"
        + "&wl0_key=1"
        + "&ENC11=" + <b>wepKey</b>.substring(0,2)
        + "&ENC12=" + <b>wepKey</b>.substring(2,4)
        + "&ENC13=" + <b>wepKey</b>.substring(4,6)
        + "&ENC14=" + <b>wepKey</b>.substring(6,8)
        + "&ENC15=" + <b>wepKey</b>.substring(8,10)
        + "&ENC21=&ENC22=&ENC23=&ENC24=&ENC25="
        + "&ENC31=&ENC32=&ENC33=&ENC34=&ENC35="
        + "&ENC41=&ENC42=&ENC43=&ENC44=&ENC45=");
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);<br><br><b><font face="Courier New,Courier">Listing 48</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There are no new concepts in Listing 48, only new details such as:</p>
<ul>
	<li>The name of the requested resource in the invocation of the POST method.</li>
	<li>The syntax of and the information contained in the body of the POST 
	message.</li>
</ul>
<p>The most interesting items are highlighted in boldface in Listing 48.</p>
<p>I would have found it very difficult to construct the body of the POST 
message without the help of the <a href="http://www.ethereal.com/">Ethereal</a> 
program.</p>
<p><font color="#FF0000"><b>That's all folks</b></font></p>
<p>And that is probably a lot more than you ever wanted to know about the topics 
covered in this lesson.<br>
</p>
<center>
<h2><a name="Run the program"></a>Run the Programs</h2>
</center>
<p>I encourage you to copy the code from the classes in the section entitled
<a href="#Complete Program Listings">Complete Program Listings</a>.&nbsp; 
Compile the code and execute it if you have a compatible wireless router.&nbsp; Experiment with 
the code, making
changes, and observing the results of your changes.&nbsp; If you don't have a 
compatible wireless router, modify the code to make it compatible with your 
wireless router.</p>
<p>Above all, however, pay attention to the <a href="#A_disclaimer">disclaimer</a> 
that I provided earlier</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you how to write a Java program that will 
automatically set the WEP, WPA, or WPA2 encryption key on a wireless router on 
an unattended scheduled basis.&nbsp; Hopefully in the process, I also taught you 
quite a bit about writing Java programs that will successfully communicate with 
HTTP servers.</p>
<p>Lest you forget, I will remind you one more time that I am not a security 
expert.&nbsp; My expertise is in the area of Java programming.&nbsp; The programs in this 
lesson are provided for educational purposes only.&nbsp; There is no suggestion that 
these programs are suitable for any purpose other than education in the area of 
Java programming.&nbsp; If you use the programs for any purpose whatsoever, you are 
doing so at your own risk.&nbsp; I will accept no responsibility for any outcome that 
you may experience.</p>
<h2 align="center"><a name="Good_Network_Practice">Good Network Practice</a></h2>
<p>Whether or not you decide, <i>(despite my <a href="#A_disclaimer">
disclaimer</a>)</i>, to implement these ideas in hopes of improving your home or 
small office wireless network security, there are some other things that 
you should consider doing.</p>
<p><font color="#FF0000"><b>Suggestions from
CWNA Guide to Wireless LANS</b></font></p>
<p>The following ideas were generally 
taken from the textbook entitled
<a href="http://www.course.com/catalog/product.cfm?category=Networking&subcategory=Wireless Networking&isbn=0-619-21579-8">
CWNA Guide to Wireless LANS</a>, Second Edition, by Mark Ciampa.</p>
<ul>
	<li>Use the highest level of authentication and encryption supported by your 
	wireless router and the computers on your network.&nbsp; Above all, make 
	sure that authentication and encryption are not disabled as is often the 
	default at installation time.</li>
	<li>Disable the <b>Wireless SSID Broadcast</b> on your router.&nbsp; While this won't 
	prevent serious attackers from finding your wireless router, it will 
	discourage casual eavesdroppers.</li>
	<li>Change the <b>SSID</b> on your wireless router from its default to some more 
	cryptic name.&nbsp; This will prevent attackers from finding your wireless 
	router simply by entering the well-known SSIDs for different brands of 
	wireless routers.</li>
	<li>Enable the <b>Wireless MAC Filter</b> feature.&nbsp; While this won't prevent the 
	really serious attacker from breaking into your wireless network, it will 
	force them to expend quite a lot of effort to do so.&nbsp; Hopefully that 
	will cause them to search for an easier target at someone else's house.</li>
</ul>
<p><font color="#FF0000"><b>My suggestions</b></font></p>
<p>And in addition to those suggestions from Ciampa, my suggestions are:</p>
<ul>
	<li>Use a 
	<a href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/windows_password_tips.mspx">strong encryption key</a> by avoiding common words and phrases, 
	birthdays, children's names, mother's maiden name, etc, and by mixing upper 
	case characters, lower case characters, numbers, and special characters 
	whenever possible.</li>
	<li><a href="http://www.mrwebb.com/password-protection.shtml">Change the encryption key often</a>.&nbsp; The breaking of strong encryption 
	keys generally requires the intercept of and analysis of large amounts of 
	traffic.&nbsp; By changing the encryption key often, you eliminate the 
	opportunity for the attacker to intercept a large amount of traffic 
	involving the use of the same encryption key. </li>
</ul>
<p><b><font color="#FF0000">Physical security</font></b></p>
<p>And don't forget physical security for the router, particularly in a small 
office environment.&nbsp; With many wireless routers, if an attacker can gain 
access to the equipment long enough to press the reset button <i>(about ten seconds)</i>, 
the router will revert to its default operational configuration which typically 
includes no security at all.</p>
<h2 align="center"><a name="References">References</a></h2>
<p><a href="http://www.dickbaldwin.com/java/Java550.htm">550</a> Network 
Programming - General Information&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java552.htm">552</a> Network 
Programming - The InetAddress Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java554.htm">554</a> Network 
Programming - The URL Class and the URLEncoder Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java556.htm">556</a> Network 
Programming - The URLConnection Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java560.htm">560</a> Network 
Programming - Sockets&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java562.htm">562</a> Network 
Programming - Server Sockets&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java564.htm">564</a> Network 
Programming - Datagram Clients&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java566.htm">566</a> Network 
Programming - Datagram Servers&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java568.htm">568</a> Network 
Programming - Stubs, Skeletons, and Remote Objects<br>
<a href="http://www.dickbaldwin.com/java/Java060.htm">060</a><font color="#000000"> 
Input and Output Streams&nbsp;</font><br>
<a href="http://www.developer.com/java/other/article.php/3386271">2188</a> 
Understanding Base64 Data<br>
<a href="http://www.developer.com/java/ent/article.php/3447491">727</a> Public 
Key Cryptography 101 Using Java&nbsp;<br>
<a href="http://www.developer.com/java/other/article.php/3553521">2400</a> 
Consolidating Email using Java<br>
<a href="http://www.developer.com/java/other/article.php/3564211">2402</a> 
Consolidating Email using Java, Part 2 <br>
<a href="http://www.developer.com/java/other/article.php/3557116">2404</a> 
Uploading Old Email to Gmail using Java <br>
<a href="http://www.developer.com/java/other/article.php/3592906">2410</a> Using Java to Clean Up 
Your Bookmark Library</p>
<p>Also see <a href="http://www.dickbaldwin.com/toc.htm">
http://www.dickbaldwin.com/toc.htm</a>.&nbsp; </p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listing</h2>
</center>
Complete listings of the programs discussed in this lesson are provided below. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets15.java Copyright 2006, R.G.Baldwin

Illustrates communication between a program and an HTTP/1.1
server, which doesn't require authentication.

Also illustrates how to cause the server to forego keep-
alive and close the connection at the end of each response.

This class attempts to get the headers for two different
resources from the same server.  Here is the output when
the server, which normally implements keep-alive by 
default, responds properly to the request to close the 
connection at the end of the response.  Note that line 
breaks were manually inserted to force the material to fit 
into this narrow publication format.

**Send initial HEAD command**
1: HTTP/1.1 200 OK
2: Date: Mon, 19 Dec 2005 15:18:24 GMT
3: Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10
-1.dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
4: X-Powered-By: PHP/4.3.10-1.dotdeb.0
5: Connection: close
6: Content-Type: text/html; charset=iso-8859-1
7:

**Send another HEAD command.**
**Must get new socket**
1: HTTP/1.1 200 OK
2: Date: Mon, 19 Dec 2005 15:18:25 GMT
3: Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10
-1.dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
4: Last-Modified: Sat, 30 Jul 2005 00:31:16 GMT
5: ETag: "16f8002-eda-42eaca54"
6: Accept-Ranges: bytes
7: Content-Length: 3802
8: Connection: close
9: Content-Type: text/html; charset=iso-8859-1
10:

**End program output**


Here is the output that would be produced if the server
failed to respond to the request to close the connection
following the first response.  Once again, line breaks were
manually inserted to force the material to fit into this
narrow publication format.

**Send initial HEAD command**
1: HTTP/1.1 200 OK
2: Date: Mon, 19 Dec 2005 15:22:03 GMT
3: Server: Apache/1.3.26 (Unix) Debian GNU/Linux PHP/4.3.10
-1.dotdeb.0 mod_ssl/2.8.9 OpenSSL/0.9.6c mod_perl/1.26
4: X-Powered-By: PHP/4.3.10-1.dotdeb.0
5: Content-Type: text/html; charset=iso-8859-1
6:

**Send another HEAD command.**
**Synchronization error, terminating**

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets15{

  final String server = "www.austincc.edu";
  boolean closedFlag;
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets15().doIt();
  }//end main
  //-----------------------------------------------------//
  
  void doIt(){
    //Get a socket, connected to the specified server on
    // port 80, the HTTP port.  Also get input and output
    // streams that can be used to communicate with the
    // server.
    socketWrapper = getSocket(server);

    System.out.println("**Send initial HEAD command**");
    socketWrapper.outputStream.println("HEAD / HTTP/1.1");
    socketWrapper.outputStream.println("Host: " + server);
    //Ask the server to close the connection following the
    // response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here.
    socketWrapper.outputStream.println();

    //Display fifteen lines of server response.  Get
    // information about closing of the connection in the
    // process.
    closedFlag = print(15,socketWrapper.inputStream);

    System.out.println("\n**Send another HEAD command.**");
    
    //Confirm that the connection was properly closed by
    // the server at the end of the previous response.
    // Otherwise, terminate with a synchronization error.
    if(closedFlag){
      System.out.println("**Must get new socket**");
      socketWrapper = getSocket(server);
    }else{
      System.out.println(
                 "**Synchronization error, terminating**");
      System.exit(1);
    }//end else

    socketWrapper.outputStream.println(
                      "HEAD /baldwin/index.html HTTP/1.1");
    socketWrapper.outputStream.println("Host: " + server);
    socketWrapper.outputStream.println(
                                      "User-Agent: Dummy");
    //Ask the server to close the connection following the 
    // response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here
    socketWrapper.outputStream.println();

    //Print 15 lines of server response data.
    print(15,socketWrapper.inputStream);

    System.out.println("\n**End program output**");
      
    try{
      //Close the socket
      socketWrapper.socket.close();
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get and display a
  // specified number of lines of the server response. In
  // the process, the method checks to determine if the
  // server closed the connection at the end of its
  // response. The method returns a boolean value
  // indicating whether or not the server closed the
  // connection.
  boolean print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "dummy";
    boolean closedFlag = false;
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);

        if(line.contains("Connection: close")){
          //The server closed the connection at the end of
          // the response.
          closedFlag = true;
        }//end if
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return closedFlag;
    
  }//end local method named print
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//
}//end class Sockets15
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 49</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets14.java Copyright 2006, R.G.Baldwin

The purpose of this class is to illustrate basic 
authentication.

The class works properly with a very recent Linksys WRT54G 
wireless router with SES/WPA2.  It also works properly with
a recent Linksys WRT54G wireless router without SES/WPA2.

The class does not work properly with an old Linksys 
BEFW11S4 802.11B wireless router or an old Linksys BEFSR41 
Cable router.  The same symptoms are exhibited for both of 
the older Linksys routers.  They don't close the connection
following the 401 message response even when requested to 
do so.  Then they ignore a following GET command containing
the Authorization header line.  However, those two boxes do
work properly with a standard commercial browser, so there
is something that a browser knows how to do that this
class doesn't do.

The class also does not work properly with a Belkin 54G
wireless router.  However, that is to expected because the
Belkin router requires a completely different 
authentication scheme.

Note that in order to avoid dealing with the complexities 
of keep-alive, the program asks the server to close the 
connection at the end of each response.

Typical output resulting from the running of the program
with a Linksys WRT54G wireless router with SES/WPA2 is 
shown below.  Note that the width of the output was 
manually truncated to force it to fit into this narrow
publication format.

**Send initial GET command**
1: HTTP/1.0 401 Unauthorized
2: Server: httpd
3: Date: Thu, 01 Jan 1970 00:00:29 GMT
4: WWW-Authenticate: Basic realm="WRT54G"
5: Content-Type: text/html
6: Connection: close
7:
8: &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;401 Unauthorized&lt;/TITLE&gt;&lt;/HEAD&gt;
9: &lt;BODY BGCOLOR="#cc9999"&gt;&lt;H4&gt;401 Unauthorized&lt;/H4&gt;
10: Authorization required.
11: &lt;/BODY&gt;&lt;/HTML&gt;
**Authorization required**
**Must get new socket**

**Re-send the GET command with authentication.**
1: HTTP/1.0 200 Ok
2: Server: httpd
3: Date: Thu, 01 Jan 1970 00:00:33 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
10:
11: &lt;!--
12: *******************************************************
13: *   Copyright 2003, CyberTAN  Inc.  All Rights Reserved
14: *******************************************************
15:
**Print terminated on line count.**


Here is the output produced by a Linksys BEFSR41 cable 
router.  Note that line breaks were manually inserted to
force the material to fit into this narrow publication
format.  Also note that this output terminated on a
synchronization error.

**Send initial GET command**
1: HTTP/1.1 401 Authorization Required
2: WWW-Authenticate: Basic realm="Linksys BEFSR41/BEFSR11/B
EFSRU31"
3: Server: Linksys BEFSR41/BEFSR11/BEFSRU31 ver1.36
4: Content-type: text/html
5: Expires: Thu, 13 Dec 1969 10:29:00 GMT
6: Pragma: no-cache
7: Content-length: 339
8:
9: &lt;html&gt;&lt;head&gt;&lt;title&gt;401 Authorization Required&lt;/title&gt;&lt;/h
ead&gt;&lt;body bgcolor=red text=white&gt;&lt;h1&gt;401 Authorization Requ
ired&lt;/h1&gt;This server could not verify that you are authoriz
ed to access. Either you supplied the wrong credentials(e.g
., bad password), or your browser doesn't understand how to
 supply the credentials required.&lt;/body&gt;&lt;/html&gt;
**Authorization required**
**Synchronization error, terminating**

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets14{

  final String server = "192.168.1.1";

  StateWrapper stateWrapper;
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets14().doIt();
  }//end main
  //-----------------------------------------------------//
  
  void doIt(){
    //The following constant contains the administrator
    // password expressed in base64.
    // See http://www.motobit.com/util/base64-decoder
    // -encoder.asp for an online base64 encoder/decoder.
    //The following value is for the default administrator
    // username and password for a Linksys wireless router
    // where the user name is blank and the password is
    // admin. The user name and the password must be
    // separated by a colon.  Since the username is blank,
    // this is the base64 representation of :admin
    final String adminUserPwd = "OmFkbWlu";

    //Get a socket, connected to the specified server on
    // port 80, the HTTP port.  Also get input and output
    // streams that can be used to communicate with the
    // server.
    socketWrapper = getSocket(server);
 
    System.out.println("**Send initial GET command**");
    socketWrapper.outputStream.println("GET / HTTP/1.1");
    socketWrapper.outputStream.println("Host: " + server);
    socketWrapper.outputStream.println(
                          "User-Agent: Dummy Header Line");
    //Ask the server to close the connection following
    // the response.
    socketWrapper.outputStream.println(
                                      "Connection: close");
    //The following CRLF is required here.
    socketWrapper.outputStream.println();

    //Display fifteen lines of server response.  Get
    // information about the requirement for authentication
    // and the closing of the connection in the process.
    stateWrapper = print(15,socketWrapper.inputStream);

    if(stateWrapper.authFlag){
      System.out.println("**Authorization required**");

      if(stateWrapper.closedFlag){
        System.out.println("**Must get new socket**");
        socketWrapper = getSocket(server);
      }else{
        System.out.println(
                 "**Synchronization error, terminating**");
        System.exit(1);
      }//end else
     
      System.out.println("\n**Re-send the GET command "
                               + "with authentication.**");
      socketWrapper.outputStream.println("GET / HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                                      "User-Agent: Dummy");
      socketWrapper.outputStream.println(
                   "Authorization: Basic " + adminUserPwd);
      //Ask the server to close the connection following
      // the response.
      socketWrapper.outputStream.println(
                                      "Connection: close");
      //The following CRLF is required here
      socketWrapper.outputStream.println();

      //Print 15 lines of server response data.
      print(15,socketWrapper.inputStream);
    }//end if on authFlag

    System.out.println("\n**End program output**");
      
    try{
      //Close the socket
      socketWrapper.socket.close();
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt
  //-----------------------------------------------------//

  //This class is used to wrap two boolean values that
  // specify whether the server requires authentication and
  // whether the server closed the connection following the
  // previous response.
  class StateWrapper{
    boolean authFlag = false;
    boolean closedFlag = false;
  }//end StateWrapper
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get and display a
  // specified number of lines of the server response. In
  // the process, the method checks to determine if the
  // server requires authentication and if the server
  // closed the connection at the end of its response. The
  // method returns two boolean values in a simple wrapper
  // object containing the answers to those two questions.
  StateWrapper print(
                 int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "";
    StateWrapper stateWrapper = new StateWrapper();
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);
        if(line.contains("401")){
          //Authentication is required
          stateWrapper.authFlag = true;
        }//end if
        
        if(line.contains("Connection: close")){
          //The server closed the connection at the end of
          // the response.
          stateWrapper.closedFlag = true;
        }//end if
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return stateWrapper;
    
  }//end local method named print
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//
}//end class Sockets14
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 50</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets10.java Copyright 2005, R.G.Baldwin

This program can be used to connect to a Linksys WRT54G 
wireless router (with or without SES/WPA2) to change 
the WEP key.  The program installs a ten-character 
hexadecimal WEP key in the router.  It would be a simple
matter to modify the program to cause it to install a 
26-character WEP key.

Note:  for simplicity, this class uses some deprecated
methods.

The new key is displayed on the screen.  The screen output
for a typical run with a Linksys WRT54G wireless router
with SES/WPA2 is shown below.  Note that the width of the 
output was manually truncated to force it to fit into this 
narrow publication format.

New WEP key: a4cb6e0679
POST /apply.cgi HTTP/1.1
1: HTTP/1.0 200 Ok
2: Server: httpd
3: Date: Sun, 18 Dec 2005 20:32:00 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
10:
11: &lt;!--
12: *******************************************************
13: *   Copyright 2003, CyberTAN  Inc.  All Rights Reserved
14: *******************************************************
15:
**Print terminated on line count.**
End POST operation

When the program terminates, the new WEP key shown above
has been installed in the wireless router.

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets10{
  
  String server = "192.168.1.1";
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets10().doIt();
  }//end main
  //-----------------------------------------------------//
  
  //This is the main processing method in the program.
  void doIt(){
    //Get a ten-character hexadecimal WEP key based on the
    // date and a random number generator.
    String wepKey = getWepKey();
    //Display the new WEP key.
    System.out.println("New WEP key: " + wepKey);

    //The following constant contains the administrator
    // password expressed in base64.
    // See http://www.motobit.com/util/base64-decoder
    // -encoder.asp for an online base64 encoder/decoder.
    //The following value is for the default administrator
    // username and password for a Linkys wireless router
    // where the user name is blank and the password is
    // admin. The user name and the password must be
    // separated by a colon.  Since the username is blank,
    // this is the base64 representation of :admin
    final String adminUserPwd = "OmFkbWlu";
    
    try{
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);
      
      //Set up to post the data to the server.
      System.out.println("POST /apply.cgi HTTP/1.1");
      
      socketWrapper.outputStream.println(
                               "POST /apply.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                   "Authorization: Basic " + adminUserPwd);
      socketWrapper.outputStream.println(
                                    "Content-Length: 252");
      //The following CRLF is required here.
      socketWrapper.outputStream.println();
      
      //Post the data to the server as though a user 
      // clicked the submit button.  This syntax was 
      // captured from the actual data stream produced
      // by a browser using the Ethereal program.
      //Note that this statement calls the print method
      // instead of the println method, and then adds a LF
      // without a CR at the end.
      socketWrapper.outputStream.print(
        "submit_button=WL_WPATable"
        + "&change_action="
        + "&submit_type="
        + "&action=Apply"
        + "&security_mode_last="
        + "&wl_wep_last="
        + "&security_mode2=wep"//WEP security mode
        + "&wl_key=1"//Default is key 1
        + "&wl_WEP_key="
        + "&wl_wep=restricted"
        + "&wl_wep_bit=64"//64-bit WEP key
        + "&wl_passphrase="//Passphrase is blank
        + "&generateButton=Null"//Passphrase is not used
        + "&wl_key1=" + wepKey //Value for Key 1
        + "&wl_key2="//Blank key
        + "&wl_key3="//Blank key
        + "&wl_key4=");//Blank key
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);
        
      //Display fifteen lines of server response data.
      print(15,socketWrapper.inputStream);

      System.out.println("End POST operation");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//

  //The purpose of this method is to get and display a
  // specified number of lines of the server response.
  void print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "";
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end local method named print
  //-----------------------------------------------------//
  //This method generates a 10-character hexadecimal key
  // based on the current date and a random number
  // generator.The algorithm will generate the same key
  // every time it is run on a given date, but will
  // generate different keys on different dates.
  //You can easily modify this algorithm to come up with
  // a different recipe for the key.  Alternately, you can
  // modify this method to cause it to generate a
  // 26-character hexadecimal key instead of a
  // ten-character key.  If you do that, you will need to
  // make some changes to the post command in the doIt
  // method to cause it to accommodate 26-character keys.
  //Note:  for simplicity, this method uses some deprecated
  // methods.
  String getWepKey(){
    //The following two secet values can be modified by the
    // user to customize this key generator for a specific
    // user.
    final int bias = 12345;//a secret value
    final int lim = 8;//another secret value
    
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
    
    //Instantiate a random number generator seeded by the
    // date and the first secret value given above.
    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
    
    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt();
    }//end for loop
    
    //Construct a sequence of ten hexadecimal characters
    // using a random long negative value.
    long val = randomGen.nextLong();
    //Guarantee a 1 in the first bit position
    if(val == 0)val = -1;
    if(val &gt; 0) val = -val;
    //Get a ten-character substring from the 16 hexadecimal
    // characters that describe the negative long value.
    String stringInProgress = 
                     Long.toHexString(val).substring(0,10);

    return stringInProgress;
    
  }//end getWepKey
  
}//end class Sockets10
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 51</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets11.java Copyright 2005, R.G.Baldwin

This program can be used to connect to a Linksys WRT54G 
wireless router (with or without SES/WPA2) to change 
the WPA shared key.  The router requires that the key be
63 characters or less.

When used with an older router that doesn't support WPA2, 
the program sets the configuration to a WPA Pre-Shared Key
and TKIP.

When used with a newer router that supports WPA2, the 
program sets the configuration to WPA2 Personal and 
TKIP+AES.

Note:  for simplicity, this class uses some deprecated
methods.

The new key is displayed on the screen.  The screen output
for a typical run with a Linksys WRT54G wireless router
with SES/WPA2 is shown below.  Note that the width of the 
output was manually truncated to force it to fit into this 
narrow publication format.

New key: w&lt;e.TwF.d`Q.1wu
POST /apply.cgi HTTP/1.1
1: HTTP/1.0 200 Ok
2: Server: httpd
3: Date: Sun, 18 Dec 2005 21:17:28 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
10:
11: &lt;!--
12: *******************************************************
13: *   Copyright 2003, CyberTAN  Inc.  All Rights Reserved
14: *******************************************************
15:
**Print terminated on line count.**
End POST operation

When the program terminates, the new WPA key shown above
has been installed in the wireless router.

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets11{
  
  final String server = "192.168.1.1";
  SocketWrapper socketWrapper;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets11().doIt();
  }//end main
  //-----------------------------------------------------//

  //This is the main processing method in the class.  
  void doIt(){
    //Get a fifteen-character key based on the date
    // and a random number generator.
    String wpaSharedKey = getWpaKey();
    System.out.println("New key: " + wpaSharedKey);
    
    //The following constant contains the administrator
    // password expressed in base64.
    // See http://www.motobit.com/util/base64-decoder
    // -encoder.asp for an online base64 encoder/decoder.
    //The following value is for the default administrator
    // username and password for a Linkys wireless router
    // where the user name is blank and the password is
    // admin. The user name and the password must be
    // separated by a colon.  Since the username is blank,
    // this is the base64 representation of :admin
    final String adminUserPwd = "OmFkbWlu";
    
    try{
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);
      
      //Set up to post the data to the server.
      System.out.println("POST /apply.cgi HTTP/1.1");
      
      socketWrapper.outputStream.println(
                               "POST /apply.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                   "Authorization: Basic " + adminUserPwd);
      socketWrapper.outputStream.println("Content-Length: "
                          + (183 + wpaSharedKey.length()));
      //The following CRLF is required here.
      socketWrapper.outputStream.println();
      
      //Post the data to the server as though a user 
      // clicked the submit button.  This syntax was 
      // captured from the actual data stream produced
      // by a browser using the Ethereal program.
      //Note that this statement calls the print method
      // instead of the println method, and then adds a LF
      // without a CR at the end.
      socketWrapper.outputStream.print(
        "submit_button=WL_WPATable"
        + "&change_action="
        + "&submit_type="
        + "&action=Apply"
        + "&security_mode_last="
        + "&wl_wep_last="
        + "&security_mode2=wpa2_personal"//WPA2 Personal
        + "&wl_crypto=tkip%2Baes"//TKIP+AES
        + "&wl_wpa_psk=" + wpaSharedKey
        + "&wl_wpa_gtk_rekey=3600");//Renewal @ 3600 sec
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);
        
      //Display fifteen lines of server response data.
      print(15,socketWrapper.inputStream);

      System.out.println("End POST operation");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end doIt
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//

  //The purpose of this method is to get and display a
  // specified number of lines of the server response.
  void print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "";
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end local method named print
  //-----------------------------------------------------//
  
  //This method generates a 15-character key in the form
  // ccc.ccc.ccc.ccc based on the current date and a
  // random number generator.  The characters range from
  // 0 (48) through z (122) inclusive.  The algorithm will
  // generate the same key every time it is run on a given
  // date, but will generate different keys on different
  // dates.
  //You can easily modify this algorithm to come up with
  // a different recipe for the key, or a longer key using
  // the same general recipe.
  //Note:  for simplicity, this method uses some deprecated
  // methods.
  String getWpaKey(){
    int bias = 12345;//a secret value
    int lim = 8;//another secret secret value
    
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
    
    //Instantiate a random number generator seeded by the
    // date and the first secret value given above.
    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
    
    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt(123);
    }//end for loop
    
    //Construct a sequence of twelve characters using
    // sequential random values between 48 and 122
    // inclusive according to the ASCII collating sequence.
    StringBuffer stringInProgress = new StringBuffer();
    while(stringInProgress.length() &lt; 12){
      int val = randomGen.nextInt(123);
      if(val &gt; 47){
        stringInProgress.append((char)val);
      }//end if
    }//end while loop
    
    //Insert periods every third character to make it
    // easier to manually enter the key on client machines.
    // This increases the length of the key to 15 total
    // characters including the periods.
    stringInProgress.insert(9,'.');
    stringInProgress.insert(6,'.');
    stringInProgress.insert(3,'.');
    
    return stringInProgress.toString();
    
  }//end getWpaKey
  
}//end class Sockets11
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 52</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets11a.java Copyright 2005, R.G.Baldwin

The purpose of this program is to generate a WPA key that 
matches the WPA key produced by the program named Sockets11
when both programs are run on the same date.

This is a local stand-alone program that doesn't 
communicate with a network in any way.

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.util.*;

class Sockets11a{
  
  public static void main(String[] args){
    new Sockets11a().doIt();
  }//end main
  //-----------------------------------------------------//

  //This is the main processing method in the class.  
  void doIt(){
    //Get a fifteen-character key based on the date
    // and a random number generator.
    String wpaSharedKey = getWpaKey();
    System.out.println("New key: " + wpaSharedKey);
  }//end doIt
  //-----------------------------------------------------//

  //This method generates a 15-character key in the form
  // ccc.ccc.ccc.ccc based on the current date and a
  // random number generator.  The characters range from
  // 0 (48) through z (122) inclusive.  The algorithm will
  // generate the same key every time it is run on a given
  // date, but will generate different keys on different
  // dates.
  //You can easily modify this algorithm to come up with
  // a different recipe for the key, or a longer key using
  // the same general recipe.
  //Note:  for simplicity, this method uses some deprecated
  // methods.
  String getWpaKey(){
    int bias = 12345;//a secret value
    int lim = 8;//another secret secret value
    
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
    
    //Instantiate a random number generator seeded by the
    // date and the first secret value given above.
    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
    
    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt(123);
    }//end for loop
    
    //Construct a sequence of twelve characters using
    // sequential random values between 48 and 122
    // inclusive according to the ASCII collating sequence.
    StringBuffer stringInProgress = new StringBuffer();
    while(stringInProgress.length() &lt; 12){
      int val = randomGen.nextInt(123);
      if(val &gt; 47){
        stringInProgress.append((char)val);
      }//end if
    }//end while loop
    
    //Insert periods every third character to make it
    // easier to manually enter the key on client machines.
    // This increases the length of the key to 15 total
    // characters including the periods.
    stringInProgress.insert(9,'.');
    stringInProgress.insert(6,'.');
    stringInProgress.insert(3,'.');
    
    return stringInProgress.toString();
    
  }//end getWpaKey
  
}//end class Sockets11a
<br><br><b><font face="Courier New,Courier">Listing 53</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets12.java Copyright 2006, R.G.Baldwin

This class illustrates the methodology for logging in and
logging out on a Belkin 54G wireless router.  Note that
this is completely different from the basic authentication
used on the Linksys WRT54G router.

Typical output from the program follows:

**Login**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 15:32:34 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Login done**

**Logout**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 15:32:39 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Logout done**
**End program output**

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets12{
  
  String server = "192.168.2.1";
  SocketWrapper socketWrapper;
  //Administrator password.  Note that this is not
  // expressed in Base64 as is the case with basic
  // authentication.
  final String adminUserPwd = "admin";
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Sockets12().doIt();
  }//end main
  //-----------------------------------------------------//
  
  void doIt(){

    try{
      System.out.println("\n**Login**");
      
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);

      //Send the login command
      socketWrapper.outputStream.println("GET /login.cgi?"
        + "page=login"
        + "&logout=2"
        + "&pws=" + adminUserPwd + " HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);
      System.out.println("\n**Login done**");

      //Now log out from the router.

      System.out.println("\n**Logout**");
      
      //Get a new Socket object and I/O streams.
      socketWrapper = getSocket(server);

      //Send the logout command
      socketWrapper.outputStream.println(
                               "GET /logout.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);
      System.out.println("\n**Logout done**");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
    System.out.println("**End program output**");
  }//end doIt
  //-----------------------------------------------------//

  //The purpose of this method is to get and display a
  // specified number of lines of the server response.
  void print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "";
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end local method named print
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//
}//end class Sockets12
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 54</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p>&nbsp;</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sockets13.java Copyright 2006, R.G.Baldwin

This program can be used to connect to a Belkin 54G 
wireless router to change the WEP key.  The program 
installs a ten-character hexadecimal WEP key in the router.
It would be a simple matter to modify the program to cause 
it to install a  26-character WEP key.

The new key is displayed on the screen.  A typical output
produced by this program follows.  Note that line breaks
were manually inserted to force the material to fit into
this narrow publication format.

New WEP key: e0d5ae876d

**Login**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:24 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Login done**

**Post new WEP key**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:28 GMT
4: Content-Type: text/html
5: Connection: close
6:
7: &lt;html lang="en"&gt;&lt;head&gt;&lt;title&gt;Wireless Broadband Router&lt;/
title&gt;&lt;/head&gt;&lt;body bgcolor=white&gt;&lt;p&gt;&lt;font size=3 face=arial
&gt;&lt;p&gt;&lt;font size=2 face=arial&gt;&lt;p&gt;&lt;p&gt;&lt;font size=0 face=arial&gt;&lt;
/b&gt;&lt;/font&gt;&lt;br&gt;&lt;script&gt; timer = setTimeout('location.replace
("wireless_encrypt_64.html")', 0) &lt;/script&gt; &lt;p&gt;&lt;/body&gt;&lt;/htm
l&gt;

**WEP key post is done**

**Logout**
**Display 9 lines of the server's response**
1: HTTP/1.0 200 Ok
2: Server: micro_httpd
3: Date: Fri, 02 Jan 1970 19:54:34 GMT
4: Cache-Control: no-cache
5: Pragma: no-cache
6: Expires: 0
7: Content-Type: text/html
8: Connection: close
9:
**Print terminated on line count.**

**Logout done**
**End program output**

Tested using J2SE 5.0 and WinXP.
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets13{
  
  String server = "192.168.2.1";
  SocketWrapper socketWrapper;
  //Administrator password.  Note that this is not
  // expressed in Base64 as is the case with basic
  // authentication.
  final String adminUserPwd = "admin";
  //-----------------------------------------------------//
  public static void main(String[] args){
    new Sockets13().doIt();
  }//end main
  //-----------------------------------------------------//
  
  void doIt(){
 
    //Get a ten-character WEP key based on the date and a
    // random number generator.
    String wepKey = getWepKey();
    System.out.println("New WEP key: " + wepKey);
    
    try{
      System.out.println("\n**Login**");
      
      //Get a Socket object connected to the specified
      // server on port 80.  Also get input and output
      // streams on the Socket object in the process.
      socketWrapper = getSocket(server);

      //Send the login command
      socketWrapper.outputStream.println("GET /login.cgi?"
        + "page=login"
        + "&logout=2"
        + "&pws=" + adminUserPwd + " HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);
      System.out.println("\n**Login done**");
      

      System.out.println("\n**Post new WEP key**");
      //Get a Socket object along with I/O streams.
      socketWrapper = getSocket(server);

      //Send the post command
      socketWrapper.outputStream.println(
                           "POST /postapply.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      socketWrapper.outputStream.println(
                                    "Content-Length: 386");
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      //Post the data to the server as though a user 
      // clicked the submit button.  This syntax was 
      // captured from the actual data stream produced
      // by a browser using the Ethereal program.
      //Note that this statement calls the print method
      // instead of the println method, and then adds a LF
      // without a CR at the end.
      socketWrapper.outputStream.print(
        "page=wireless_enc64"
        + "&logout=2"
        + "&generate_flag=1"
        + "&webpage=wireless_encrypt_64.html"
        + "&wl0_wep=wep"
        + "&wl0_key1=" + wepKey
        + "&wl0_key2="
        + "&wl0_key3="
        + "&wl0_key4="
        + "&wl0_auth_mode=disabled"
        + "&wl0_wep_mode=64"
        + "&wl0_wep64_manual=1"
        + "&action=Apply"
        + "&wl0_sec_mode=64"
        + "&wl0_key=1"
        + "&ENC11=" + wepKey.substring(0,2)
        + "&ENC12=" + wepKey.substring(2,4)
        + "&ENC13=" + wepKey.substring(4,6)
        + "&ENC14=" + wepKey.substring(6,8)
        + "&ENC15=" + wepKey.substring(8,10)
        + "&ENC21=&ENC22=&ENC23=&ENC24=&ENC25="
        + "&ENC31=&ENC32=&ENC33=&ENC34=&ENC35="
        + "&ENC41=&ENC42=&ENC43=&ENC44=&ENC45=");
      //The following LF is required here without a CR.
      socketWrapper.outputStream.print(0x0a);

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);

      System.out.println("\n**WEP key post is done**");

      //Now log out from the router.

      System.out.println("\n**Logout**");
      
      //Get a new Socket object and I/O streams.
      socketWrapper = getSocket(server);

      //Send the logout command
      socketWrapper.outputStream.println(
                               "GET /logout.cgi HTTP/1.1");
      socketWrapper.outputStream.println(
                                        "Host: " + server);
      //The following CRLF is required.
      socketWrapper.outputStream.println();

      System.out.println(
           "**Display 9 lines of the server's response**");
      print(9,socketWrapper.inputStream);
      System.out.println("\n**Logout done**");

      //Close the socket
      socketWrapper.socket.close();

    }//end try
    catch(Exception e){
      e.printStackTrace();
    }//end catch
    System.out.println("**End program output**");
  }//end doIt
  //-----------------------------------------------------//

  //The purpose of this method is to get and display a
  // specified number of lines of the server response.
  void print(int lineLimit,BufferedReader inputStream){
    int lineCnt = 0;
    String line = "";
    try{
      while(((line = inputStream.readLine()) != null) 
                               && (lineCnt++ &lt; lineLimit)){
        System.out.println(lineCnt + ": " + line);
      }//end while
      if(lineCnt &gt;= lineLimit){
        System.out.println(
                    "**Print terminated on line count.**");
      }//end if
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
  }//end local method named print
  //-----------------------------------------------------//
  
  //This class is used to wrap three objects used in
  // socket communications.
  class SocketWrapper{
    //This is a reference to the Socket object itself.
    Socket socket;
    //This is an eight-bit stream used to send commands to
    // the server.
    PrintStream outputStream;
    //This is a 16-bit stream used to receive the server
    // response lines.
    BufferedReader inputStream;
  }//end SocketWrapper
  //-----------------------------------------------------//
  
  //The purpose of this method is to get a new Socket
  // object connected to a server on port 80 along with
  // input and output stream objects that can be used to
  // communicate with the server.  References to the
  // Socket object and the two stream objects are
  // returned in a simple wrapper object of type 
  // SocketWrapper.
  SocketWrapper getSocket(String server){
    int port = 80;
    SocketWrapper socketWrapper = new SocketWrapper();
    try{
      //Get a socket, connected to the specified server
      // on the specified port.
      socketWrapper.socket = new Socket(server,port);
      
      //Get an input stream for reading the response sent
      // by the server.
      socketWrapper.inputStream = 
                  new BufferedReader(new InputStreamReader(
                   socketWrapper.socket.getInputStream()));

      //Get an 8-bit output stream to the socket that will
      // autoflush.  Note that a 16-bit Unicode output 
      // stream apparently won't work for the posted
      // content.
      socketWrapper.outputStream = new PrintStream(
              socketWrapper.socket.getOutputStream(),true);
    }catch(Exception e){
      e.printStackTrace();
    }//end catch
    
    return socketWrapper;
  }//end getSocket
  //-----------------------------------------------------//
  //This method generates a 10-character hexadecimal key
  // based on the current date and a random number
  // generator.The algorithm will generate the same key
  // every time it is run on a given date, but will
  // generate different keys on different dates.
  //You can easily modify this algorithm to come up with
  // a different recipe for the key.  Alternately, you can
  // modify this method to cause it to generate a
  // 26-character hexadecimal key instead of a
  // ten-character key.  If you do that, you will need to
  // make some changes to the post command in the main
  // method to cause it to accommodate 26-character keys.
  //Note:  for simplicity, this method uses some deprecated
  // methods.
  static String getWepKey(){
    int bias = 12345;//a secret value
    int lim = 8;//another secret secret value
    
    //Get the current date and time
    Date dateTime = new Date();
    
    //Eliminate the time preserving only the date in a new
    // object of type Date.
    int year = dateTime.getYear();
    int month = dateTime.getMonth();
    int date = dateTime.getDay();
    Date dateOnly = new Date(year,month,date);
    
    //Instantiate a random number generator seeded by the
    // date and the first secret value given above.
    Random randomGen = 
                     new Random(dateOnly.getTime() + bias);
    
    //Advance the random number generator by a number of
    // cycles equal to the second secret value given above.
    for(int cnt = 0;cnt &lt; lim;cnt++){
      randomGen.nextInt(123);
    }//end for loop
    
    //Construct a sequence of ten hexadecimal characters
    // using a random long negative value.
    long val = randomGen.nextLong();
    //Guarantee a 1 in the first bit position
    if(val == 0)val = -1;
    if(val &gt; 0) val = -val;
    //Get a ten-character substring from the 16 hexadecimal
    // characters that describe the negative long value.
    String stringInProgress = 
                     Long.toHexString(val).substring(0,10);

    return stringInProgress;
    
  }//end getWepKey
  
}//end class Sockets13
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 55</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p></p>
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java wireless security network router encryption key packet keep-alive 
connection authenticate socket server input output stream GET HEAD POST http 
header request response WEP WPA WPA2 base64 random pseudorandom hexadecimal 
Linksys Belkin WRT54G 802.11G 802.11B</p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
