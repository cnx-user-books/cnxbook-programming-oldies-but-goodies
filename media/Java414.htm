<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Processing Image Pixels, Applying Image Convolution in Java, Part 2</h2>
    <i>Part 2 of this lesson teaches you how to design copying filters, smoothing filters, sharpening 
filters, 3D embossing filters, and edge detection filters, and how to apply 
those filters to images.</i>
<p><b>Published:</b>&nbsp; April 4, 2006<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 414</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Background_Information">Background Information</a></li>

  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a><li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
	<li><a href="#References">References</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>Part of a series</b></font></p>
<p>This lesson is one in a series designed to teach you how to use Java to 
create special effects with images by directly manipulating the pixels in the 
images.&nbsp; The first lesson in the series was entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; The previous lesson was Part 
1 of this two-part lesson.</p>
<p>This is Part 2 of the two-part lesson.&nbsp; You are strongly encouraged to review 
the first part of this lesson entitled 
<a href="http://www.developer.com/java/ent/article.php/3590351">Processing Image 
Pixels, Applying Image Convolution in Java, Part 1</a> before continuing with this lesson.</p>
<p>The primary objective of this lesson is to teach you how to integrate 
much of what you have already learned about Digital Signal Processing <i>(DSP)</i> and Image 
Convolution into Java programs that can be used to experiment with, and 
to understand the effects of a wide variety of image-convolution operations.</p>
<p>Part 1 of this lesson showed you how to design copying filters, smoothing 
filters, sharpening filters, 3D embossing filters, and edge detection filters, 
and how to apply those filters to images.&nbsp; The results of numerous 
experiments using filters of the types listed above were presented.&nbsp; This 
part of the lesson explains the code required to perform the experiments that 
were presented in Part 1.</p>
<p><font color="#FF0000"><b>You will need a driver program</b></font></p>
<p>The lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> provided and explained a 
class named <b>
ImgMod02a</b> that makes it easy to:</p>
<ul>
	<li>Manipulate and modify the pixels that belong to an image.</li>
	<li>Display the processed image along with the original image.</li>
</ul>
<p><b>ImgMod02a</b> serves as a driver that controls the execution of a second 
program that actually processes the pixels.&nbsp; It displays the original and processed images in the standard 
format shown in <a name="Figure_1">Figure 1</a>.</p>
<p></p>
<table border="1" cols="1" bgcolor="#ccffff">
	<tbody>
		<tr>
			<td>
			<pre><img border="0" src="java414ah03.jpg" width="310" height="476"><br></pre>
			<pre><b>Figure 1</b></pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Get the class and the interface</b></font></p>
<p>The 
image-processing programs that I will explain in this lesson run under the control of <b>
ImgMod02a</b>.&nbsp; 
	In order to 
compile and run the programs that I will provide in this lesson, you will need to go to the lessons entitled 
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> and  
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> to get copies of the class 
named <b>ImgMod02a</b> and the interface named <b>ImgIntfc02</b></p>

<p><b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<p>I particularly recommend that you study the lessons referred to in the
<a href="#References">References</a> section of this lesson.</p>
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p><font color="#FF0000"><b>A three-dimensional array of pixel data as type int</b></font></p>
<p>The driver program named <b>ImgMod02a</b>:</p>
<ul>
	<li>Extracts the pixels from an image file.</li>
	<li>Converts the pixel data to type <b>int.</b></li>
	<li>Stores the pixel data in a three-dimensional array of type <b>int</b> that is 
	well suited for processing.</li>
	<li>Passes the three-dimensional array object's reference to a method in an 
	object instantiated from an 
	image-processing class.</li>
	<li>Receives a reference to a three-dimensional array object containing 
	processed pixel data from the image-processing method.</li>
	<li>Displays the original image and the processed image in a stacked display 
	as shown in <a href="#Figure_1">Figure 1</a>.</li>
	<li>Makes it possible for the user to provide new input data to the 
	image-processing method, invoking the image-processing method repeatedly 
	in order to create new displays showing the newly-processed image along with the 
	original image.</li>
</ul>
<p>The manner in which that is accomplished was explained in earlier lessons.</p>
<p><font color="#FF0000"><b>A grid of colored pixels</b></font></p>
<p>Each three-dimensional array object represents one image consisting of a 
grid of colored pixels.&nbsp; The pixels in the grid are arranged in rows 
and columns when they are rendered.&nbsp; One of the dimensions of the array represents rows.&nbsp; 
A second dimension represents columns.&nbsp; The third dimension represents the color 
<i>(and transparency)</i> of 
the pixels.</p>
<p><font color="#FF0000"><b>Convolution in one dimension</b></font></p>
<p>The earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3484591">Convolution 
and Frequency Filtering in Java</a> taught you about performing convolution in 
one dimension.&nbsp; In that lesson, I showed you how to apply a convolution 
filter to a 
sampled time series in one dimension.&nbsp; As you may recall, the mathematical 
process in one dimension involves the following steps:</p>
<ul>
	<li>Register the n-point convolution filter with the first <b>n</b> samples in 
	the time series.</li>
	<li>Compute an output value, which is the sum of the products of the 
	convolution filter coefficient values and the corresponding time series values.</li>
	<li>Optionally divide the sum of products output value by the number of 
	filter coefficients.</li>
	<li>Move the convolution filter one step forward, registering it with the 
	next <b>n</b> samples in the time series and compute the next output value as a sum 
	of products.</li>
	<li>Repeat this process until all samples in the time series have been 
	processed.</li>
</ul>
<p><font color="#FF0000"><b>Convolution in two dimensions</b></font></p>
<p>Convolution in two dimensions involves essentially the same steps except that 
in this case we are dealing with three different 3D sampled surfaces and a 3D convolution 
filter surface instead of a simple sampled time series.</p>
<blockquote>
	<p><i>(There is a red surface, a green surface, and a blue surface, each of 
	which must be processed.&nbsp; Each surface has width and height 
	corresponding to the first two dimensions of the 3D surface.&nbsp; In 
	addition, each sampled value that represents the surface can be different.&nbsp; 
	This constitutes the third dimension of the surface.&nbsp; There is also an 
	alpha or transparency surface that could be processed, but the programs in 
	this lesson don't process the alpha surface.&nbsp; Similarly, the 
	convolution filter surface has three dimensions corresponding to width, height, 
	and the values of the coefficients in the operator.&nbsp; Don't be confused 
	by the dimensions of the array object containing the surface or the 
	convolution filter and the dimensions of the surface or the convolution 
	filter.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Steps in the processing</b></font></p>
<p>Basically, the steps involved in processing one of the three surfaces to 
produce one output surface consist of:</p>
<ul>
	<li>Register the 2D aspect <i>(width and height)</i> of the convolution 
	filter with the first 2D area centered on the first row of samples on the 
	input surface.</li>
	<li>Compute a point for the output surface, by computing the sum of the 
	products of the convolution filter values and the corresponding input 
	surface values.</li>
	<li>Optionally divide the sum of products output value by the number of 
	filter coefficients.</li>
	<li>Move the convolution filter one step forward along the row, 
	registering it with the next 2D area on the surface and compute the next point 
	on the output surface as a sum of products.&nbsp; When that row has been 
	completely processed, move the convolution filter to the beginning of the 
	next row, registering with the corresponding 2D area on the input surface 
	and compute the next point for the output surface.</li>
	<li>Repeat this process until all samples in the surface have been 
	processed.</li>
</ul>
<p><font color="#FF0000"><b>Repeat once for each color surface</b></font></p>
<p>Repeat the above set of steps three times, once for each of the three color 
surfaces.</p>
<p><font color="#FF0000"><b>Watch out for the edges</b></font></p>
<p>Special care must be taken to avoid 
having the edges of the convolution filter extend outside the boundaries of 
the input surface.</p>
<p><font color="#FF0000"><b>Testing</b></font></p>
<p>All of the code in this lesson was tested 
using J2SE 5.0 and WinXP</p>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p>There are a rather large number of classes involved in producing the 
experimental results described in the first part of this lesson, which was 
entitled <a href="http://www.developer.com/java/ent/article.php/3590351">
Processing Image Pixels, Applying Image Convolution in Java, Part 1</a>.</p>
<p>Some of those classes have already 
been discussed in detail in earlier lessons.&nbsp; For retrieval of the source 
code for those classes, I will simply refer you to the earlier lessons referred 
to in the <a href="#References">References</a> section of this lesson.</p>
<blockquote>
	<p><i>(As an alternative, you can probably just go to
	<a href="http://www.google.com/">Google</a> and enter the name of the class 
	along with the keywords Baldwin and java and find the lessons online.)</i></p>
</blockquote>
<p>Some of the classes are updated versions of classes discussed in earlier 
lessons.&nbsp; In those cases, I will provide some, but not very much 
discussion of the new version of the class.&nbsp; For the most part, I will 
simply refer you to the lesson containing the earlier version for the 
discussion.</p>
<p>Some of the classes are new to this lesson.&nbsp; I will discuss and explain 
those classes in detail.</p>
<p><font color="#FF0000"><b>The class named Graph08</b></font></p>
<p>I will begin with the class named <b>Graph08</b>.&nbsp; A complete listing of 
this class is provided in <a href="#Listing_28">Listing 28</a> near the end of this lesson.</p>
<p>This is an updated version of the earlier plotting class named <b>Graph03</b>.&nbsp; 
The update allows the user to plot up to eight functions instead of only 5 as is 
the case with <b>Graph03</b>.</p>
<blockquote>
	<p><i>(<a name="Figure_2">Figure 2</a> shows a sample of the plotting 
	format produced by the class named <b>Graph08</b>.)</i></p>
</blockquote>
<p></p>
<table border="1" cols="1" bgcolor="#ccffff">
	<tbody>
		<tr>
			<td>
			<pre><img border="0" src="java414aa1.jpg" width="409" height="431"><br></pre>
			<pre><b>Figure 2</b></pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The use of this class requires the use of a corresponding interface named.&nbsp;
<b>GraphIntfc08</b>.&nbsp; This interface, which is provided in 
<a href="#Listing_29">Listing 29</a>,&nbsp;is an update to the earlier interface named
<b>GraphIntfc01</b>.</p>
<p><b>Graph03</b> and <b>GraphIntfc01</b> were explained in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3487996">Convolution and Matched Filtering in Java</a>.&nbsp; 
Because of the similarity between <b>Graph08</b> and <b>Graph03</b>, I will 
simply refer you to that explanation, and won't repeat the explanation here.</p>
<p><font color="#FF0000"><b>The Dsp041 class</b></font></p>
<p>This class is new to this lesson.&nbsp; A detailed description of the class 
was provided in <a href="http://www.developer.com/java/ent/article.php/3590351">
Processing Image Pixels, Applying Image Convolution in Java, Part 1</a> of this lesson in the section entitled 
<a href="http://www.developer.com/java/ent/article.php/3590351#Preview">Preview</a>.</p>
<p>This class must be run under control of the class named <b>Graph08</b>.&nbsp; 
To run this class as a program, enter the following command at the command line 
prompt:</p>
<p><font face="Arial Narrow"><b>java Graph08 Dsp041</b></font></p>
<p>I will explain this class in fragments.&nbsp; The source code for the class 
is provided in its entirety in <a href="#Listing_30">Listing 30</a> near the end of the lesson.</p>
<p>This class illustrates the application of a convolution filter to signals 
having a known waveform displaying the results in the format shown in
<a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The class definition for the class named <b>Dsp041</b> begins in 
<a name="Listing_1">Listing 1</a>.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>class <b>Dsp041</b> implements <b>GraphIntfc08</b>{
&nbsp; //Establish length for various arrays
&nbsp; int filterLen = 200;
&nbsp; int signalLen = 400;
&nbsp; int outputLen = signalLen - filterLen;
&nbsp; //Ignore right half of signal, which is all zeros, when
&nbsp; // computing the spectrum.
&nbsp; int signalSpectrumPts = signalLen/2;
&nbsp; int filterSpectrumPts = outputLen;
&nbsp; int outputSpectrumPts = outputLen;
&nbsp;

&nbsp; //Create arrays to store different types of data.
&nbsp; double[] signal = new double[signalLen];
&nbsp; double[] filter = new double[filterLen];
&nbsp; double[] output = new double[outputLen];
&nbsp; double[] spectrumA = new double[signalSpectrumPts];
&nbsp; double[] spectrumB = new double[filterSpectrumPts];
&nbsp; double[] spectrumC = new double[outputSpectrumPts];<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Note that the class implements the interface named <b>GraphIntfc08</b>.&nbsp; 
This is a requirement for any class that is to be run under control of the class 
named <b>Graph08</b>.</p>
<p>The code in <a href="#Listing_1">Listing 1</a> declares variables and creates array objects.&nbsp; The 
code is straightforward and shouldn't require further explanation.</p>
<p><font color="#FF0000"><b>The constructor for the class named Dsp041</b></font> </p>
<p>The constructor begins in <a name="Listing_2">Listing 2</a>.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp; public Dsp041(){//constructor
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //This is a single impulse filter that simply copies
&nbsp;&nbsp;&nbsp; // the input to the output.
&nbsp;&nbsp;&nbsp; filter[0] = 1;

/*
&nbsp;&nbsp;&nbsp; //This is a high-pass filter with an output that is
&nbsp;&nbsp;&nbsp; // proportional to the slope of the signal.&nbsp; In
&nbsp;&nbsp;&nbsp; // essence,the output approximates the first derivative
&nbsp;&nbsp;&nbsp; // of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -1.0;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;

&nbsp;&nbsp;&nbsp; //This is a high-pass filter with an output that is
&nbsp;&nbsp;&nbsp; // proportional to the rate of change of the slope of
&nbsp;&nbsp;&nbsp; // the signal. In essence, the output approximates the
&nbsp;&nbsp;&nbsp; // second derivative of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -0.5;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;
&nbsp;&nbsp;&nbsp; filter[2] = -0.5;

&nbsp;&nbsp;&nbsp; //This is a relatively soft high-pass filter, which
&nbsp;&nbsp;&nbsp; // produces a little blip in the output each time the
&nbsp;&nbsp;&nbsp; // slope of the signal changes.&nbsp; The size of the blip
&nbsp;&nbsp;&nbsp; // is roughly proportional to the rate of change of the
&nbsp;&nbsp;&nbsp; // slope of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -0.2;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;
&nbsp;&nbsp;&nbsp; filter[2] = -0.2;

&nbsp;&nbsp;&nbsp; //This is a low-pass smoothing filter.&nbsp; It approximates
&nbsp;&nbsp;&nbsp; // a four-point running average or integration of the
&nbsp;&nbsp;&nbsp; // signal.
&nbsp;&nbsp;&nbsp; filter[0] = 0.250;
&nbsp;&nbsp;&nbsp; filter[1] = 0.250;
&nbsp;&nbsp;&nbsp; filter[2] = 0.250;
&nbsp;&nbsp;&nbsp; filter[3] = 0.250;
*/<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Enable and disable code</b></font><br>
<br>
An object of the class named <b>Dsp041</b> applies a one-dimensional convolution 
filter to a signal with a known waveform and displays the results in the format 
shown in <a href="#Figure_2">Figure 2</a>.&nbsp; By enabling and disabling code 
using comments, you can create and save a convolution filter having given set of 
coefficient values.&nbsp; Then you can recompile the class and rerun the program to see the effect of the filter on the 
signal.</p>
<p>Several predefined filter waveforms are provided in <a href="#Listing_2">Listing 2</a>.&nbsp; 
Obviously, you can modify the code in <a href="#Listing_2">Listing 2</a> to create a filter of your own 
design.</p>
<p><font color="#FF0000"><b>Create a signal time series</b></font></p>
<p><a href="#Listing_3">Listing 3</a> creates a signal time series containing four distinct waveforms.&nbsp; 
These waveforms consist of all positive values riding on a positive non-zero 
baseline:</p>
<ul>
	<li>An impulse.</li>
	<li>A rectangular pulse.</li>
	<li>A triangular pulse with a large slope.</li>
	<li>A triangular pulse with a smaller <a name="Listing_3">slope</a>.</li>
</ul>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; //First create a baseline in the signal time series.
&nbsp;&nbsp;&nbsp; //Modify the following value and recompile the class
&nbsp;&nbsp;&nbsp; // to change the baseline.
&nbsp;&nbsp;&nbsp; double baseline = 10.0;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; signalLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal[cnt] = baseline;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now add the pulses to the signal time series.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //First add an impulse.
&nbsp;&nbsp;&nbsp; signal[20] = 75;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a rectangular pulse.
&nbsp;&nbsp;&nbsp; signal[30] = 75;
&nbsp;&nbsp;&nbsp; signal[31] = 75;
&nbsp;&nbsp;&nbsp; signal[32] = 75;
&nbsp;&nbsp;&nbsp; signal[33] = 75;
&nbsp;&nbsp;&nbsp; signal[34] = 75;
&nbsp;&nbsp;&nbsp; signal[35] = 75;
&nbsp;&nbsp;&nbsp; signal[36] = 75;
&nbsp;&nbsp;&nbsp; signal[37] = 75;
&nbsp;&nbsp;&nbsp; signal[38] = 75;
&nbsp;&nbsp;&nbsp; signal[39] = 75;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a triangular pulse with a large slope.
&nbsp;&nbsp;&nbsp; signal[50] = 10;
&nbsp;&nbsp;&nbsp; signal[51] = 30;
&nbsp;&nbsp;&nbsp; signal[52] = 50;
&nbsp;&nbsp;&nbsp; signal[53] = 70;
&nbsp;&nbsp;&nbsp; signal[54] = 90;
&nbsp;&nbsp;&nbsp; signal[55] = 70;
&nbsp;&nbsp;&nbsp; signal[56] = 50;
&nbsp;&nbsp;&nbsp; signal[57] = 30;
&nbsp;&nbsp;&nbsp; signal[58] = 10;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a triangular pulse with a smaller slope.
&nbsp;&nbsp;&nbsp; signal[70] = 10;
&nbsp;&nbsp;&nbsp; signal[71] = 20;
&nbsp;&nbsp;&nbsp; signal[72] = 30;
&nbsp;&nbsp;&nbsp; signal[73] = 40;
&nbsp;&nbsp;&nbsp; signal[74] = 50;
&nbsp;&nbsp;&nbsp; signal[75] = 60;
&nbsp;&nbsp;&nbsp; signal[76] = 70;
&nbsp;&nbsp;&nbsp; signal[77] = 80;
&nbsp;&nbsp;&nbsp; signal[78] = 90;
&nbsp;&nbsp;&nbsp; signal[79] = 80;
&nbsp;&nbsp;&nbsp; signal[80] = 70;
&nbsp;&nbsp;&nbsp; signal[81] = 60;
&nbsp;&nbsp;&nbsp; signal[82] = 50;
&nbsp;&nbsp;&nbsp; signal[83] = 40;
&nbsp;&nbsp;&nbsp; signal[84] = 30;
&nbsp;&nbsp;&nbsp; signal[85] = 20;
&nbsp;&nbsp;&nbsp; signal[86] = 10;<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The signal created by the code in <a href="#Listing_3">Listing 3</a> is shown in the first graph at 
the top of <a href="#Figure_2">Figure 2</a>.</p>
<p>Obviously, you could replace the waveforms created by <a href="#Listing_3">Listing 3</a> with signal 
waveforms of your own design if you elect to do so.&nbsp; Just remember that if 
you are using this program to investigate the application of convolution to 
image color data, all color values in an image are positive.</p>
<p><font color="#FF0000"><b>Apply the convolution filter to the signal</b></font></p>
<p><a name="Listing_4">Listing 4</a> invokes the method named <b>convolve</b> to apply the convolution 
filter to the signal.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; convolve(signal,filter,output);<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>You will find a complete listing of the method named <b>convolve</b> in 
<a href="#Listing_30">Listing 30</a>.</p>
<p>The code in the method named <b>convolve</b> emulates a one-dimensional version of the 2D image convolution 
scheme used in <b>ImgMod032</b> with respect to normalization and scaling.&nbsp; 
That normalization scheme was explained in an earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3579206">Processing 
Image Pixels, Understanding Image Convolution in Java</a>, and 
is also explained in detail in the comments in <a href="#Listing_30">Listing 30</a>.&nbsp; While the 
normalization process is rather long and tedious, it is also straightforward and 
shouldn't require an explanation beyond the comments in <a href="#Listing_30">Listing 30</a>.</p>
<p>Aside from the normalization and scaling code, the actual convolution process 
implemented in the method named <b>convolve</b> has been explained in earlier 
lessons referred to in the <a href="#References">References</a> section.&nbsp; 
Therefore, it shouldn't be necessary to provide a detailed explanation of the 
method named <b>convolve</b>.</p>
<p><font color="#FF0000"><b>Compute Discrete Fourier Transform of signal</b></font></p>
<p><a name="Listing_5">Listing 5</a> invokes the method named <b>dft</b> to compute and save the 
Discrete Fourier Transform <i>(DFT)</i> of the signal expressed in decibels.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; //Ignore right half of signal which is all zeros.
&nbsp;&nbsp;&nbsp; dft(signal,signalSpectrumPts,spectrumA);<br><br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The computation of the DFT has been explained in several earlier lessons 
explained in the <a href="#References">References</a> section.&nbsp; Also, there 
are extensive comments provided with the <b>dft</b> method in 
<a href="#Listing_30">Listing 30</a>.&nbsp; 
Therefore, I won't repeat that explanation here.</p>
<p>The results of the DFT computation on the signal are shown in the fourth 
graph in <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>Compute the amplitude frequency response of the 
filter</b></font></p>
<p><a name="Listing_6">Listing 6</a> computes and saves the DFT of the convolution filter expressed in db.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; dft(filter,filterSpectrumPts,spectrumB);<br><br><b><font face="Courier New,Courier">Listing 6</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Note that the convolution filter is embedded in a long time series having zero values.&nbsp; This causes the output of the DFT to be finely sampled and produces a smooth curve for the frequency response of the convolution filter.</p>
<p>The results of the DFT computation on the convolution filter are shown in the 
fifth graph in <a href="#Figure_2">Figure 2</a>.</p>
<p><font color="#FF0000"><b>Compute the spectrum of the filtered output</b></font></p>
<p><a name="Listing_7">Listing 7</a> computes and saves the DFT of the filtered output expressed in decibels.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; dft(output,outputSpectrumPts,spectrumC);
&nbsp; }//end constructor<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The results of the DFT computation on the filtered output are shown in the 
sixth graph in <a href="#Figure_2">Figure 2</a>.</p>
<p><a href="#Listing_7">Listing 7</a> also signals the end of the constructor.</p>
<p><font color="#FF0000"><b>Plot the results</b></font></p>
<p>All of the time series and frequency domain functions have now been produced and saved.&nbsp; They may be retrieved and plotted by invoking the 
method named <b>getNmbr</b> and the methods named <b>f1</b> through <b>f6</b> 
shown in <a href="#Listing_30">Listing 30</a>.&nbsp; These methods are invoked by the object of the class 
named <b>Graph08</b> for the purpose of producing the graphic output in the 
format shown in <a href="#Figure_2">Figure 2</a>.</p>
<p>The purpose of these methods is simply to scale and return the data to be 
plotted.&nbsp; They are straightforward and shouldn't require an explanation 
beyond the comments provided in <a href="#Listing_30">Listing 30</a>.</p>
<p><font color="#FF0000"><b>The ImgMod33 class and the ImgMod33a class</b></font></p>
<p>These two classes are new to this lesson.&nbsp; A detailed description of the 
two classes was provided in the 
<a href="http://www.developer.com/java/ent/article.php/3590351#Preview">Preview</a> section of
<a href="http://www.developer.com/java/ent/article.php/3590351">Part 1</a> of this lesson.</p>
<p>It is recommended that you read the material in that 
section before attempting to understand the program code in this section.</p>
<p><font color="#FF0000"><b>Program listings</b></font></p>
<p>A complete listing of the class named <b>ImgMod33</b> is provided in 
<a href="#Listing_31">Listing 
31</a>.&nbsp; 
A complete listing of the class named <b>ImgMod33a</b> is provided in 
<a href="#Listing_32">Listing 
32</a>.</p>
<body>

<p><font color="#FF0000"><b>The two classes are very similar</b></font></p>
<p>The two classes are the same except that <b>ImgMod33a</b> uses the class 
named <b>ImgMod32a</b> to perform the 2D convolution whereas <b>ImgMod33</b> 
uses the class named <b>ImgMod32</b> to perform the 2D convolution.&nbsp; As a 
result, I will explain <b>ImgMod33</b>, but will not explain <b>ImgMod33a</b>.&nbsp; 
However, I will explain the differences between <b>ImgMod32</b> and <b>ImgMod32a</b> 
later in the lesson.</p>

</body>
<p><font color="#FF0000"><b>A general purpose 2D image convolution capability</b></font></p>
<p>Each of these classes provides a general purpose 2D image convolution and 
color filtering capability in Java, wherein the convolution filter is provided 
to the program by way of a text file.</p>
<p><font color="#ff0000"><b>Running the program</b></font></p>
<p>Both classes are designed to be driven by the class named <b>ImgMod02a</b>.&nbsp; </p>
<blockquote>
	<p><i>(The class named <b>ImgMod02a</b> was explained in the earlier lesson 
	entitled <a href="http://www.developer.com/java/other/article.php/3441391">
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</a>.)</i></p>
</blockquote>
<p>The image file to be processed by convolution is specified on the 
command line.&nbsp; Convolution filters are provided as text files.</p>
<p>Enter one of the following at the command line to run one of these programs
<i>(where <b>ImageFileName</b> is the name of a .gif or .jpg file, including the 
extension):</i></p>
<b>
<pre><font size="3">java ImgMod02a ImgMod33 ImageFileName
java ImgMod02a ImgMod33a ImageFileName</font></pre>
</b>
<p><font color="#FF0000"><b>Specify the filter file</b></font></p>
<p>Then enter the name of a file containing a 2D convolution filter in the <b>
TextField</b> that appears in the interactive control panel shown in 
<a name="Figure_3">Figure 3</a>.</p>
<p></p>
<table border="1" cols="1" bgcolor="#ccffff">
	<tbody>
		<tr>
			<td>
			<pre><img border="0" src="java414aa3.jpg" width="461" height="126"><br></pre>
			<pre><b>Figure 3</b></pre></td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Click the <b>
Replot</b> button on the <b>Frame</b> shown in <a href="#Figure_1">Figure 1</a> to cause the 
convolution filter to be applied to the image and the filtered result to be 
displayed.</p>
<blockquote>
	<p><i>(See <a href="#Figure_1">Figure 1</a> for an example of the Frame 
	containing the original image, the processed image, and the Replot button.&nbsp; 
	See comments at the beginning of the method named <b>getFilter</b> in the 
	class named <b>ImgMod33</b> for a description and an example of the required 
	format for the file containing the 2D convolution filter.)</i></p>
</blockquote>
<p><font color="#ff0000"><b>Wave number data</b></font></p>
<p>Each time you click the <b>Replot</b> button, the following additional 
information is displayed in two separate color contour maps in the format shown 
in <a name="Figure_4">Figure 4</a>:</p>
<ul>
	<li>The convolution filter.</li>
	<li>The wave number response of the convolution filter.</li>
</ul>
<p></p><table border="1" bgcolor="#ccffff"><tr><td>
	<img border="0" src="java414ae06.jpg" width="137" height="180"></td><td>
	<img border="0" src="java414ae07.jpg" width="137" height="180"></td></tr><tr><td colspan="2" ><pre><b>Figure 4</b></b></pre></td></tr></table>
<blockquote>
	<p><i>(Note that the two contour maps do not appear side-by-side as shown in
	<a href="#Figure_4">Figure 4</a>.&nbsp; Rather, they appear on top of one another.&nbsp; You must move 
	the one on the top to see the one on the bottom.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The class definition</b></font></p>
<p>The class definition for the class named <b>ImgMod33</b> begins in 
<a name="Listing_8">Listing 8</a>.&nbsp; 
Note that the class extends <b>Frame</b> and implements <b>ImgIntfc02</b>.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>class <b>ImgMod33</b> extends <b>Frame</b> implements <b>ImgIntfc02</b>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; TextField fileNameField = new TextField("");
&nbsp; Panel rgbPanel = new Panel();
&nbsp; TextField redField = new TextField("1.0");
&nbsp; TextField greenField = new TextField("1.0");
&nbsp; TextField blueField = new TextField("1.0");
&nbsp; Label instructions = new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter Filter File Name and scale factors for " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Red, Green, and Blue and click Replot");<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The class extends <b>Frame</b> so that an object of the class serves as the 
interactive control panel shown in <a href="#Figure_3">Figure 3</a>.&nbsp; The 
class implements the interface named <b>ImgIntfc02</b> to make it possible for 
the class to run under the control of the class named <b>ImgMod02a</b> and to 
display the modified image in the format shown in <a href="#Figure_1">Figure 1</a>.</p>
<p>The code in <a href="#Listing_8">Listing 8</a> simply declares and initializes some instance 
variables.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor for the class named <b>ImgMod33</b> is shown in its entirety 
in <a name="Listing_9">Listing 9</a>.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp; <b>ImgMod33</b>(){//constructor
&nbsp;&nbsp;&nbsp; setLayout(new GridLayout(4,1));
&nbsp;&nbsp;&nbsp; add(new Label("Filter File Name"));
&nbsp;&nbsp;&nbsp; add(fileNameField);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Populate the rgbPanel
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Red"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(redField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Green"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(greenField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Blue"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(blueField);

&nbsp;&nbsp;&nbsp; add(rgbPanel);
&nbsp;&nbsp;&nbsp; add(instructions);
&nbsp;&nbsp;&nbsp; setTitle("Copyright 2005, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setBounds(400,0,460,125);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp; }//end constructor<br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The code in the constructor constructs the interactive control panel 
shown in <a href="#Figure_3">Figure 3</a>.</p>
<p><font color="#FF0000"><b>The method named processImg</b></font></p>
<p>The <b>processImg</b> method begins in <a name="Listing_10">Listing 10</a>.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp; public int[][][] <b>processImg</b>(int[][][] threeDPix,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgRows,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgCols){

&nbsp;&nbsp;&nbsp; //Create an empty output array of the same size as the
&nbsp;&nbsp;&nbsp; // incoming array.
&nbsp;&nbsp;&nbsp; int[][][] output = new int[imgRows][imgCols][4];<br><br><b><font face="Courier New,Courier">Listing 10</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>processImg</b> method must be defined by all classes that implement <b>ImgIntfc02</b>.&nbsp; 
The method is called at the beginning of the run and each time thereafter that the user clicks the
<b>Replot</b> button on the <b>Frame</b> shown in <a href="#Figure_1">Figure 1</a>.</p>
<p>The <b>processImg</b> method gets a 2D convolution filter from a text file, applies it to the incoming 3D array of pixel data and returns a filtered 3D array of pixel data.</p>
<p>The code in <a href="#Listing_10">Listing 10</a> creates an output array object in which to return the 
filtered image data.</p>
<p><font color="#FF0000"><b>Make a working copy</b></font></p>
<p><a name="Listing_11">Listing 11</a> makes a working copy of the 3D pixel array to avoid making permanent changes to the original image data.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; int[][][] working3D = new int[imgRows][imgCols][4];
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; imgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; imgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][1] = threeDPix[row][col][1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][2] = threeDPix[row][col][2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][3] = threeDPix[row][col][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Copy alpha values directly to the output. They
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not processed when the image is filtered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by the convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop<br><br><b><font face="Courier New,Courier">Listing 11</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Get the convolution filter from the file</b></font></p>
<p><a name="Listing_12">Listing 12</a> gets the convolution filter from the specified text file 
containing the filter.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>
&nbsp;&nbsp;&nbsp; //Get the file name containing the filter from the
&nbsp;&nbsp;&nbsp; // textfield.
&nbsp;&nbsp;&nbsp; String fileName = fileNameField.getText();
&nbsp;&nbsp;&nbsp; if(fileName.equals("")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The file name is an empty string. Skip the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution process and pass the input image
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // directly to the output.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = working3D;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a 2D array that is populated with the contents
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file containing the 2D filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filter = getFilter(fileName);<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><a href="#Listing_12">Listing 12</a> gets the name of the file containing the convolution filter from 
the interactive control panel shown in <a href="#Figure_3">Figure 3</a>.&nbsp; If the <b>TextField</b> 
contains an empty string <i>(as is the case the first time the <b>processImg</b> 
method is called)</i> the convolution process is skipped and the input image is 
passed directly to the output.</p>
<p>If the user later enters a valid file name into the <b>TextField</b> and 
clicks the <b>Replot</b> button, causing the <b>processImg</b> method to be 
called again, <a href="#Listing_12">Listing 12</a> invokes the method named <b>getFilter</b> to read the 
convolution filter from the file and to deposit it into the array object 
referred to by <b>filter</b>.</p>
<p><font color="#FF0000"><b>The getFilter method</b></font></p>
<p>The <b>getFilter</b> method is shown in its entirety in <a href="#Listing_31">Listing 
31</a>.&nbsp; 
Although the method is rather long, it is straightforward and shouldn't require 
an explanation beyond the comments provided in the listing.&nbsp; The comments 
also describe the required format for the text file containing the filter 
coefficients.</p>
<p><font color="#FF0000"><b>Plot impulse response and wave number response</b></font></p>
<p><a name="Listing_13">Listing 13</a> plots the impulse response and wave number response of the 2D 
convolution filter as a pair of colored contour maps.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Plot the impulse response and the wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // response of the convolution filter.&nbsp; These items
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not computed and plotted when the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // starts running.&nbsp; Rather, they are computed and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plotted each time the user clicks the Replot
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // button after entering the name of a file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // containing a convolution filter into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TextField.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Begin by placing the impulse response in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // center of a large flat surface with an elevation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of zero.This is done to improve the resolution of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the Fourier Transform, which will be computed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // later.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterRows = filter.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterCols = filter[0].length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cols = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the size of the surface ten pixels larger than
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the convolution filter with a minimum size of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32x32 pixels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterRows &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = numFilterRows + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterCols &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = numFilterCols + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create the surface, which will be initialized to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all zero values.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filterSurface = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Place the convolution filter in the center of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // surface.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numFilterRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numFilterCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filterSurface[row + (rows - numFilterRows)/2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [col + (cols - numFilterCols)/2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the filter and the surface on which it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resides as a 3D plot in a color contour format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(filterSurface,4,true,1);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the 2D Fourier Transform of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Prepare arrays to receive the results of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] real = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imag = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] amp = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Perform the 2D Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(filterSurface,real,imag,amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Ignore the real and imaginary results.&nbsp; Prepare the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude spectrum for more-effective plotting by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shifting the origin to the center in wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the minimum and maximum wave number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values.&nbsp; This is useful because the way that the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave number plots are normalized. it is not
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to infer the flatness or lack thereof of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the wave number surface simply by viewing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plot.&nbsp; The colors that describe the elevations
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // always range from black at the minimum to white at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the maximum, with different colors in between
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // regardless of the difference between the minimum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and the maximum.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double maxValue = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double minValue = Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; rows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; cols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &gt; maxValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &lt; minValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("minValue: " + minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("maxValue: " + maxValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ratio: " + maxValue/minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Generate and display the wave-number response
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // graph by plotting the 3D surface on the computer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // screen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>I'm not going to tell you that the code in <a href="#Listing_13">Listing 13</a> is straightforward.&nbsp; 
It isn't.&nbsp; However, I am going to tell you that everything that results 
from the code in <a href="#Listing_13">Listing 13</a> has been explained in earlier lessons referred to in 
the <a href="#References">References</a> section of this lesson and I'm not 
going to repeat those explanations here.&nbsp; If you don't understand the code 
in <a href="#Listing_13">Listing 13</a>, you simply need to go back and study those earlier lessons.</p>
<p><font color="#FF0000"><b>Perform the convolution</b></font></p>
<p>Finally, we have reached the main objective of the class named <b>ImgMod33</b>.&nbsp; 
<a name="Listing_14">Listing 14</a> invokes the static <b>convolve</b> method of the <b>ImgMod32</b> 
class to convolve the image with the 2D convolution filter.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = ImgMod32.convolve(working3D,filter);
&nbsp;&nbsp;&nbsp; }//end else<br><br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>convolve</b> method of the <b>ImgMod32</b> class was explained in 
detail in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3579206">Processing 
Image Pixels, Understanding Image Convolution in Java</a>.&nbsp; Therefore, I won't repeat 
that explanation here.</p>
<p>The important point is that this class named <b>ImgMod33</b> serves as a 
driver, reading 2D convolution filters from text files, applying the filters to 
images, and causing the raw and processed images to be displayed under control 
of the class named <b>ImgMod02a</b> in the format shown in <a href="#Figure_1">
Figure 1</a>.</p>
<p><a href="#Listing_14">Listing 14</a> also signals the end of the <b>else</b> clause that began in 
<a href="#Listing_12">Listing 12</a>.</p>
<p><font color="#FF0000"><b>Changes for ImgMod33a</b></font></p>
<p><a href="#Listing_14">Listing 14</a> also shows the location of the difference between the classes named <b>ImgMod33</b> 
and <b>ImgMod33a</b>.&nbsp; Whereas the class named <b>ImgMod33</b> invokes the 
static <b>convolve</b> method belonging to the class named <b>ImgMod32</b>, the 
class named <b>ImgMod33a</b> invokes the <b>convolve</b> method belonging to the 
class named <b>ImgMod32a</b>.</p>
<p>These two <b>convolve</b> method differ in the way that they normalize the 
convolution output to produce the required image color format consisting of 
unsigned eight-bit values.&nbsp; I explained the normalization scheme 
implemented by <b>ImgMod32</b> in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3579206">Processing 
Image Pixels, Understanding Image Convolution in Java</a>.&nbsp; I 
will explain the normalization scheme implemented by the class named <b>
ImgMod32a</b> later in this lesson.</p>
<p><font color="#FF0000"><b>Apply color filtering</b></font></p>
<p>Following the completion of the convolution operation, <a name="Listing_15">Listing 15</a> scales the color values in each color plane if the multiplicative 
factor in the corresponding <b>TextField</b> in the interactive control panel 
has a value other than 1.0.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; if(!redField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,1,scale);
&nbsp;&nbsp;&nbsp; }//end if on redField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!greenField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; greenField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,2,scale);
&nbsp;&nbsp;&nbsp; }//end if on greenField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!blueField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blueField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,3,scale);
&nbsp;&nbsp;&nbsp; }//end if on blueField<br><br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The scaling for each color plane is actually performed by invoking the method 
named <b>scaleColorPlane</b>.</p>
<p><font color="#FF0000"><b>The scaleColorPlane method</b></font></p>
<p>The <b>scaleColorPlane</b> method is shown in its entirety in 
<a href="#Listing_31">Listing 
31</a>.&nbsp; 
The code in the method is straightforward and shouldn't require an explanation 
beyond the comments in the listing.</p>
<p><font color="#FF0000"><b>Return the processed image</b></font></p>
<p><a name="Listing_16">Listing 16</a> returns a reference to the array containing the image, which has undergone convolution filtering, 
color filtering, or a combination of the two.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>&nbsp;&nbsp;&nbsp; return output;

&nbsp; }//end processImg method<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
			</td>
		</tr></1.0 0.0
0.0 -1.0ody></table>
<p></p>
<p><a href="#Listing_16">Listing 16</a> also signals the end of the <b>processImg</b> method, and the end 
of the <b>ImgMod33</b> class insofar as this explanation is concerned.&nbsp; 
Once again, however, the class contains a couple of additional methods, which do 
not need to be explained in detail in this lesson.</p>
<p><font color="#FF0000"><b>The class named ImgMod32a</b></font></p>
<p>The class named <b>ImgMod32a</b> is shown in its entirety in 
<a href="#Listing_33">Listing 33</a>.&nbsp; This class is similar to
<b>ImgMod32</b> except that it uses a different normalization scheme when converting convolution results back to eight-bit unsigned values.&nbsp; The
<br>
normalization scheme causes the mean and the RMS of the output to match the mean and the RMS of the input.&nbsp; Then it sets negative values to 0 and sets values greater than 255 to 255.</p>
<p>The class named <b>ImgMod32</b> was explained in detail in the earlier lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3579206">
Processing Image Pixels, Understanding Image Convolution in Java</a>.&nbsp; Much of the code in <b>ImgMod32a</b> is identical to the 
code in <b>ImgMod32</b>.&nbsp; Therefore, I won't repeat the explanation for 
that code.&nbsp; Rather, I will explain the code that differs between the two 
classes in the following sections.</p>
<p><font color="#FF0000"><b>The convolve method</b></font></p>
<p>All of the important changes were made to the static method named <b>convolve</b>.&nbsp; 
I will confine my explanation to that method.&nbsp; The static <b>convolve</b> 
method applies an incoming 2D convolution filter to each color plane in an 
incoming 3D array of pixel data and returns a filtered 3D array of pixel data.</p>
<p>The convolution filter is applied separately to each color plane.</p>
<p>The alpha plane is not modified.</p>
<p><font color="#FF0000"><b>Normalization</b></font></p>
<p>The output is normalized so as to guarantee that the output color values fall 
within the range from 0 to 255.&nbsp; This is accomplished by causing the mean 
and the RMS of the color values in each output color plane to match the mean and 
the RMS of the color values in the corresponding input color plane.&nbsp; Then, 
all negative color values are set to a value of 0 and all color values greater 
than 255 are set to 255.</p>
<p><font color="#FF0000"><b>Computations in type double</b></font></p>
<p>The convolution filter is passed to the method as a 2D array of type <b>
double</b>.&nbsp; All convolution and normalization arithmetic is performed as 
type <b>double</b>.&nbsp; The normalized results are converted to type <b>int</b> 
before returning them to the calling method.</p>
<p>This method does not modify the contents of the incoming array of pixel data.&nbsp; </p>
<p><font color="#FF0000"><b>A dead zone around the perimeter of the image</b></font></p>
<p>An unfiltered dead zone equal to half the filter length is left around the 
perimeter of the filtered image to avoid any attempt to perform convolution 
using data outside the bounds of the image.</p>
<p><font color="#FF0000"><b>The code for the convolve method</b></font></p>
<p>The <b>convolve</b> method begins in <a name="Listing_17">Listing 17</a>.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>  public static int[][][] <b>convolve</b>(
                    int[][][] threeDPix,double[][] filter){
    //Get the dimensions of the image and filter arrays.
    int numImgRows = threeDPix.length;
    int numImgCols = threeDPix[0].length;
    int numFilRows = filter.length;
    int numFilCols = filter[0].length;

    //Display the dimensions of the image and filter
    // arrays.
    System.out.println("numImgRows = " + numImgRows);
    System.out.println("numImgCols = " + numImgCols);
    System.out.println("numFilRows = " + numFilRows);
    System.out.println("numFilCols = " + numFilCols);

    //Make a working copy of the incoming 3D pixel array to
    // avoid making permanent changes to the original image
    // data. Convert the pixel data to type double in the
    // process.  Will convert back to type int when
    // returning from this method.
    double[][][] work3D = intToDouble(threeDPix);
<br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The code in <a href="#Listing_17">Listing 17</a> is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>Display the mean values</b></font></p>
<p><a name="Listing_18">Listing 18</a> invokes the <b>getMean</b> method to get and to display the mean 
value for each incoming color plane.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    //Display the mean value for each color plane.
    System.out.println(
                   "Input red mean: " + getMean(work3D,1));
    System.out.println(
                 "Input green mean: " + getMean(work3D,2));
    System.out.println(
                  "Input blue mean: " + getMean(work3D,3));
<br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The <b>getMean</b> method is shown in its entirety in <a href="#Listing_33">Listing 33</a>.&nbsp; The 
code in the method is straightforward and shouldn't require further explanation.</p>
<p><font color="#FF0000"><b>Remove the mean value</b></font></p>
<p><a name="Listing_19">Listing 19</a> invokes the method named <b>removeMean</b> to get and save the 
mean value for each color plane, and to remove the mean from every color value 
in each color plane.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    double redMean = removeMean(work3D,1);
    double greenMean = removeMean(work3D,2);
    double blueMean = removeMean(work3D,3);
<br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>You can view the <b>removeMean</b> method in <a href="#Listing_33">Listing 33</a>.&nbsp; The code in 
the method is straightforward.</p>
<p><font color="#FF0000"><b>Get, save, and display the RMS value</b></font></p>
<p>The root mean square <i>(RMS)</i> value of a set of color values is simply 
the square root of the sum of the squares of all the color values.</p>
<p><a name="Listing_20">Listing 20</a> invokes the <b>getRms</b> method to get and save the RMS value for 
the color values belonging to each color plane.&nbsp; These values will be used 
later to cause the RMS value for each color plane in the filtered image to match 
the RMS values for each color plane in the original image.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>
    //Get and save the input RMS value for later
    // restoration.
    double inputRedRms = getRms(work3D,1);
    double inputGreenRms = getRms(work3D,2);
    double inputBlueRms = getRms(work3D,3);
    
    //Display the input RMS value
    System.out.println("Input red RMS: " + inputRedRms);
    System.out.println(
                      "Input green RMS: " + inputGreenRms);
    System.out.println("Input blue RMS: " + inputBlueRms);
<br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>Once you know the definition of the RMS value, the code in the <b>getRms</b> 
method is straightforward.&nbsp; You can view the method in its entirety in 
<a href="#Listing_33">Listing 33</a>.</p>
<p><a href="#Listing_20">Listing 20</a> also displays the RMS values for each color plane in the original 
image.</p>
<p><font color="#FF0000"><b>Create and condition the output array object</b></font></p>
<p>I will let the comments in <a name="Listing_21">Listing 21</a> speak for themselves.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    //Create an empty output array of the same size as the
    // incoming array of pixels.
    double[][][] output = 
                     new double[numImgRows][numImgCols][4];
    
    //Copy the alpha values directly to the output array.
    // They will not be processed during the convolution
    // process.
    for(int row = 0;row &lt; numImgRows;row++){
      for(int col = 0;col &lt; numImgCols;col++){
        output[row][col][0] = work3D[row][col][0];
      }//end inner loop
    }//end outer loop
<br><b><font face="Courier New,Courier">Listing 21</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Perform the 2D convolution</b></font></p>
<p>The code in <a name="Listing_22">Listing 22</a> performs the actual 2D convolution.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>//Because of the length of the following statements, and
// the width of this publication format, this format
// sacrifices indentation style for clarity. Otherwise,it
// would be necessary to break the statements into so many
// short lines that it would be very difficult to read
// them.

//Use nested for loops to perform a 2D convolution of each
// color plane with the 2D convolution filter.

for(int yReg = numFilRows-1;yReg &lt; numImgRows;yReg++){
  for(int xReg = numFilCols-1;xReg &lt; numImgCols;xReg++){
    for(int filRow = 0;filRow &lt; numFilRows;filRow++){
      for(int filCol = 0;filCol &lt; numFilCols;filCol++){
        
        output[yReg-numFilRows/2][xReg-numFilCols/2][1] += 
                      work3D[yReg-filRow][xReg-filCol][1] *
                                    filter[filRow][filCol];

        output[yReg-numFilRows/2][xReg-numFilCols/2][2] += 
                      work3D[yReg-filRow][xReg-filCol][2] *
                                    filter[filRow][filCol];

        output[yReg-numFilRows/2][xReg-numFilCols/2][3] += 
                      work3D[yReg-filRow][xReg-filCol][3] *
                                    filter[filRow][filCol];

      }//End loop on filCol
    }//End loop on filRow

    //Divide the result at each point in the output by the
    // number of filter coefficients.  Note that in some
    // cases, this is not helpful.  For example, it is not
    // helpful when a large number of the filter
    // coefficients have a value of zero.
    output[yReg-numFilRows/2][xReg-numFilCols/2][1] = 
           output[yReg-numFilRows/2][xReg-numFilCols/2][1]/
                                   (numFilRows*numFilCols);
    output[yReg-numFilRows/2][xReg-numFilCols/2][2] = 
           output[yReg-numFilRows/2][xReg-numFilCols/2][2]/
                                   (numFilRows*numFilCols);
    output[yReg-numFilRows/2][xReg-numFilCols/2][3] = 
           output[yReg-numFilRows/2][xReg-numFilCols/2][3]/
                                   (numFilRows*numFilCols);

  }//End loop on xReg
}//End loop on yReg
<br><b><font face="Courier New,Courier">Listing 22</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>This is the same code that I explained in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3579206">Processing 
Image Pixels, Understanding Image Convolution in Java</a>.&nbsp; 
Therefore, I won't repeat that explanation here.</p>
<p><font color="#FF0000"><b>Restoring the mean and RMS values</b></font></p>
<p>In an earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a> I explained how 
to modify the width of the color distribution of each color plane in an 
image.&nbsp; The RMS value is a measure of the width of the color 
distribution if the RMS value is computed after the mean has been removed from 
the color values.</p>
<p>Given a set of color values with a zero mean, we can modify the width of the 
color distribution simply by multiplying every color value in the set by the 
same constant.&nbsp; If the constant is greater than 1.0, the width of the 
resulting distribution will be wider.&nbsp; If the constant is less than 1.0, 
the width of the resulting distribution will be narrower.</p>
<p>Our objective here is to adjust the RMS value, and hence the width of the 
color distribution on each color plane, to the RMS value for that color plane in 
the unfiltered image.</p>
<p><font color="#FF0000"><b>Make sure the mean is zero</b></font></p>
<p>Although the mean was removed prior to convolution, it is possible that 
arithmetic inaccuracies during the convolution process could result in a slightly 
non-zero mean in the filtered image.&nbsp; The code in <a name="Listing_23">Listing 23</a> makes certain 
that the mean value is zero before adjusting the RMS value.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    removeMean(output,1);
    removeMean(output,2);
    removeMean(output,3);
<br><b><font face="Courier New,Courier">Listing 23</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><font color="#FF0000"><b>Adjust the RMS value</b></font></p>
<p>The code in <a name="Listing_24">Listing 24</a> makes the adjustment to the RMS value for each color 
plane as described above.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    //Get and save the RMS value of the output for each
    // color plane.
    double outputRedRms = getRms(output,1);
    double outputGreenRms = getRms(output,2);
    double outputBlueRms = getRms(output,3);
    
    //Scale the output to cause the RMS value of the output
    // to match the RMS value of the input
    scaleColorPlane(output,1,inputRedRms/outputRedRms);
    scaleColorPlane(output,2,inputGreenRms/outputGreenRms);
    scaleColorPlane(output,3,inputBlueRms/outputBlueRms);

    //Display the adjusted RMS values.  Should match the
    // input RMS values.
    System.out.println(
                    "Output red RMS: " + getRms(output,1));
    System.out.println(
                  "Output green RMS: " + getRms(output,2));
    System.out.println(
                   "Output blue RMS: " + getRms(output,3));
<br><b><font face="Courier New,Courier">Listing 24</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><a href="#Listing_24">Listing 24</a> also displays the final RMS value for each color plane in the 
filtered image.</p>
<p><font color="#FF0000"><b>Restore the mean value</b></font></p>
<p>The mean value of a set of color values in a color plane can be changed simply by adding the 
same constant to every color value belonging to the color plane.&nbsp; 
<a name="Listing_25">Listing 25</a> restores the mean value for 
each color plane of the filtered output to mean value of the corresponding color 
plane in the unfiltered image.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    addConstantToColor(output,1,redMean);
    addConstantToColor(output,2,greenMean);
    addConstantToColor(output,3,blueMean);

    System.out.println(
                  "Output red mean: " + getMean(output,1));
    System.out.println(
                "Output green mean: " + getMean(output,2));
    System.out.println(
                 "Output blue mean: " + getMean(output,3));<br><br><b><font face="Courier New,Courier">Listing 25</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><a href="#Listing_25">Listing 25</a> also displays the final mean value of each color plane in the 
filtered image.</p>
<p><font color="#FF0000"><b>Guarantee that all color values are within the 
proper range</b></font></p>
<p><a name="Listing_26">Listing 26</a> guarantees that all color values fall within the required range of 
0 to 255 inclusive by setting negative values to zero and setting all values 
greater then 255 to 255.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    //Clip all negative color values at zero and all color
    // values that are greater than 255 at 255.
    clipToZero(output,1);
    clipToZero(output,2);
    clipToZero(output,3);
    
    clipTo255(output,1);
    clipTo255(output,2);
    clipTo255(output,3);<br><br><b><font face="Courier New,Courier">Listing 26</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p>The methods named <b>clipToZero</b> and <b>clipTo255</b> are straightforward.&nbsp; 
They can be viewed in their entirety in <a href="#Listing_33">Listing 33</a>.</p>
<p><font color="#FF0000"><b>Return the filtered image</b></font></p>
<p><a name="Listing_27">Listing 27</a> returns a reference to the array containing the filtered pixels, 
converting the color values from type <b>double</b> to type <b>int</b> in the 
process.</p>
<p></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
	<tbody>
		<tr>
			<td>
			<pre>    return doubleToInt(output);

  }//end convolve method<br><br><b><font face="Courier New,Courier">Listing 27</font></b></pre>
			</td>
		</tr>
	</tbody>
</table>
<p></p>
<p><a href="#Listing_27">Listing 27</a> also signals the end of the static <b>convolve</b> method 
belonging to the class named <b>ImgMod32a</b>.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2><p>I encourage you to copy, compile, and run the programs that are provided in the section named <a href="#Complete_Program_Listings">Complete Program Listings</a>.</p><p><font color="#FF0000"><b>Experiment with different filters and images</b></font></p><p>Experiment with the programs, creating new convolution filters and applying them to your own images.&nbsp; Try to make certain that you understand the results of your experiments.&nbsp; Modify the programs and observe the results of your modifications.</p><p><font color="#FF0000"><b>The required classes</b></font></p><p>The required classes and the instructions for running the programs are provided in the comments at the beginning of the programs.&nbsp; The source code for the classes that are not provided in this lesson can be found in the earlier lessons referred to in the <a href="#References">References</a> section.</p><p>Perhaps the easiest way to find the source code for those classes is to go to <a href="http://www.google.com/">Google</a> and search for the following keywords where <i>className</i> is the name of the class of interest:</p><p><font face="Arial Narrow"><b>java baldwin &quot;class className&quot;</b></font></p><p><font color="#ff0000"><b>Have fun and learn</b></font></p><p>Above all, have fun and use these programs to learn as much as you can about 
image convolution.</p><h2 align="center"><a name="Summary">Summary</a></h2><p>
This is Part 2 of a two-part lesson.&nbsp; In the two parts of this lesson, I have provided you with a general purpose image convolution program.&nbsp; 
In addition, I have walked you through several experiments intended to help you understand why image convolution does what it does.</p>
<p>I also showed you how to design and implement the following types of 
convolution filters:</p>
<ul>
	<li>A simple copy filter</li>
	<li>Smoothing or softening filters</li>
	<li>Sharpening filters</li>
	<li>Embossing filters that produce a 3D-like effect</li>
	<li>Edge detection filters</li>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2><p>Future lessons will show you how to write image-processing programs that 
implement many common special effects as well as a few that aren't so common.&nbsp; 
This will include programs to do the following:</p><ul><li>Deal with the effects of noise in an image.</li><li>Morph one image into another image.</li><li>Rotate an image.</li><li>Change the size of an image.</li><li>Create a kaleidoscope of an image.</li><li>Other special effects that I may dream up or discover while doing the 
	background research for the lessons in this series.</li></ul><h2 align="center"><a name="References">References</a></h2><p>In preparation for understanding the material in this lesson, I recommend 
that you study the material in the following previously-published lessons: </p><ul><li><a href="http://www.dickbaldwin.com/dsp/Dsp00100.htm">100</a>&nbsp;&nbsp; Periodic 
Motion and Sinusoids</li><li><a href="http://www.dickbaldwin.com/dsp/Dsp00104.htm">104</a>&nbsp;&nbsp; Sampled Time 
Series</li><li><a href="http://www.dickbaldwin.com/dsp/Dsp00108.htm">108</a>&nbsp;&nbsp; Averaging 
Time Series</li><li><a href="http://www.developer.com/java/other/article.php/3374611">1478</a> 
Fun with Java, How and Why Spectral Analysis Works</li><li><a href="http://www.developer.com/java/other/article.php/3380031">1482</a> 
Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
Algorithm</li><li><a href="http://www.developer.com/java/other/article.php/3392871">1483</a> 
Spectrum Analysis using Java, Frequency Resolution versus Data Length</li><li><a href="http://www.developer.com/java/other/article.php/3411041">1484</a> 
Spectrum Analysis using Java, Complex Spectrum and Phase Angle</li><li><a href="http://www.developer.com/java/other/article.php/3436341">1485</a> 
Spectrum Analysis using Java, Forward and Inverse Transforms, Filtering in the 
Frequency Domain</li><li><a href="http://www.developer.com/java/other/article.php/3484591">1487</a> 
Convolution and Frequency Filtering in Java</li><li><a href="http://www.developer.com/java/other/article.php/3487996">1488</a> 
Convolution and Matched Filtering in Java</li><li><a href="http://www.developer.com/java/other/article.php/3508706">1489</a> 
Plotting 3D Surfaces using Java </li><li><a href="http://www.developer.com/java/other/article.php/3519441">1490</a> 
2D Fourier Transforms using Java </li><li><a href="http://www.developer.com/java/other/article.php/3526241">1491</a> 
2D Fourier Transforms using Java, Part 2 </li><li><a href="http://www.developer.com/java/data/article.php/3529186">1492</a> 
Plotting Large Quantities of Data using Java</li><li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
Processing Image Pixels using Java, Getting Started</li><li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
Processing Image Pixels using Java, Creating a Spotlight</li><li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
Processing Image Pixels Using Java: Controlling Contrast and Brightness</li><li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
Processing Image Pixels, Color Intensity, Color Filtering, and Color Inversion</li><li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
Processing Image Pixels, Performing Convolution on Images</li><li>
	<a href="http://www.developer.com/java/other/article.php/3579206">410</a> Processing Image Pixels, Understanding Image Convolution in Java</li></li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> Processing Image Pixels, Applying Image Convolution in Java, 
	Part 1</li></ul><h2 align="center"><a name="Complete_Program_Listings">Complete Program Listings</a></h2><p>Complete listings of the programs discussed in this lesson are provided in this section.</p><p><font color="#FF0000"><b>A disclaimer</b></font></p><p>The programs that I am providing and explaining in this series of lessons are 
not intended to be used for high-volume production work.&nbsp; Numerous 
integrated image-processing programs are available for that purpose.&nbsp; In 
addition, the Java Advanced Imaging <i>(JAI)</i> API has a number of built-in special effects if you prefer to write 
your own production image-processing programs using Java.</p><p>The programs that I am providing in this series are intended to 
make it easier for you to develop and experiment with image-processing algorithms and 
to gain a better understanding of how they work, and why they do what they do.</p>
<p><a name="Listing_28">Listing 28</a></p><table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/* File Graph08.java
Copyright 2005, R.G.Baldwin

This is an updated version of Graph03 to allow the user to
plot up to eight functions instead of only 5.

GraphIntfc08 is a corresponding update to the earlier
interface named GraphIntfc01.

Graph03 and GraphIntfc01 were explained in lesson 1488
entitled Convolution and Matched Filtering in Java.

This program is very similar to Graph01 except that it has
been modified to allow the user to manually resize and
replot the frame.

Note:&nbsp; This program requires access to the interface named
GraphIntfc08.

This is a plotting program.&nbsp; It is designed to access a
class file, which implements GraphIntfc08, and to plot up
to eight functions defined in that class file. The plotting
surface is divided into the required number of equally
sized plotting areas, and one function is plotted on
Cartesian coordinates in each area.

The methods corresponding to the functions are named f1,
f2, f3, f4, f5, f6, f7, and f8.

The class containing the functions must also define a
method named getNmbr(), which takes no parameters and
returns the number of functions to be plotted.&nbsp; If this
method returns a value greater than 8, a
NoSuchMethodException will be thrown.

Note that the constructor for the class that implements
GraphIntfc08 must not require any parameters due to the
use of the newInstance method of the Class class to
instantiate an object of that class.

If the number of functions is less than 8, then the absent
method names must begin with f8 and work down toward f1.&nbsp;
For example, if the number of functions is 3, then the
program will expect to call methods named f1, f2, and f3.
It is OK for the absent methods to be defined in the class.
They simply won't be invoked.&nbsp; In fact, because they are
declared in the interface, they must be defined as dummy
methods in the class that implements the interface.

The plotting areas have alternating white and gray
backgrounds to make them easy to separate visually.

All curves are plotted in black.&nbsp; A Cartesian coordinate
system with axes, tic marks, and labels is drawn in red
in each plotting area.

The Cartesian coordinate system in each plotting area has
the same horizontal and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes, correspond to the values
of the extreme edges of the plotting area.

The program also compiles a sample class named junk, which
contains eight methods and the method named getNmbr.&nbsp; This
makes it easy to compile and test this program in a
stand-alone mode.

At runtime, the name of the class that implements the
GraphIntfc08 interface must be provided as a command-line
parameter.&nbsp; If this parameter is missing, the program
instantiates an object from the internal class named junk
and plots the data provided by that class.&nbsp; Thus, you can
test the program by running it with no command-line
parameter.

This program provides the following text fields for user
input, along with a button labeled Graph.&nbsp; This allows the
user to adjust the parameters and replot the graph as many
times with as many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these parameters and then click
the Graph button to cause the eight functions to be
re-plotted according to the new parameters.

Whenever the Graph button is clicked, the event handler
instantiates a new object of the class that implements
the GraphIntfc08 interface.&nbsp; Depending on the nature of
that class, this may be redundant in some cases.&nbsp; However,
it is useful in those cases where it is necessary to
refresh the values of instance variables defined in the
class (such as a counter, for example).

This program uses constants that were first defined in the
Color class of v1.4.0.&nbsp; Therefore, the program requires
v1.4.0 or later to compile and run correctly.

Tested using J2SE 5.0 under WinXP.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph08{
&nbsp; public static void main(String[] args)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{
&nbsp;&nbsp;&nbsp; if(args.length == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pass command-line paramater
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(args[0]);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no command-line parameter given
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(null);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }// end main
}//end class Graph08 definition
//=======================================================//

class GUI extends JFrame implements ActionListener{

&nbsp; //Define plotting parameters and their default values.
&nbsp; double xMin = 0.0;
&nbsp; double xMax = 400.0;
&nbsp; double yMin = -100.0;
&nbsp; double yMax = 100.0;

&nbsp; //Tic mark intervals
&nbsp; double xTicInt = 20.0;
&nbsp; double yTicInt = 20.0;

&nbsp; //Tic mark lengths.&nbsp; If too small on x-axis, a default
&nbsp; // value is used later.
&nbsp; double xTicLen = (yMax-yMin)/50;
&nbsp; double yTicLen = (xMax-xMin)/50;

&nbsp; //Calculation interval along x-axis
&nbsp; double xCalcInc = 1.0;

&nbsp; //Text fields for plotting parameters
&nbsp; JTextField xMinTxt = new JTextField("" + xMin);
&nbsp; JTextField xMaxTxt = new JTextField("" + xMax);
&nbsp; JTextField yMinTxt = new JTextField("" + yMin);
&nbsp; JTextField yMaxTxt = new JTextField("" + yMax);
&nbsp; JTextField xTicIntTxt = new JTextField("" + xTicInt);
&nbsp; JTextField yTicIntTxt = new JTextField("" + yTicInt);
&nbsp; JTextField xCalcIncTxt = new JTextField("" + xCalcInc);

&nbsp; //Panels to contain a label and a text field
&nbsp; JPanel pan0 = new JPanel();
&nbsp; JPanel pan1 = new JPanel();
&nbsp; JPanel pan2 = new JPanel();
&nbsp; JPanel pan3 = new JPanel();
&nbsp; JPanel pan4 = new JPanel();
&nbsp; JPanel pan5 = new JPanel();
&nbsp; JPanel pan6 = new JPanel();

&nbsp; //Misc instance variables
&nbsp; int frmWidth = 408;
&nbsp; int frmHeight = 430;
&nbsp; int width;
&nbsp; int height;
&nbsp; int number;
&nbsp; GraphIntfc08 data;
&nbsp; String args = null;

&nbsp; //Plots are drawn on the canvases in this array.
&nbsp; Canvas[] canvases;

&nbsp; //Constructor
&nbsp; GUI(String args)throws NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{

&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save for use later in the ActionEvent handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.args = args;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the target class using the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // String name of the class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc08)Class.forName(args).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newInstance();
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the test class named junk.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; //Create array to hold correct number of Canvas
&nbsp;&nbsp;&nbsp; // objects.
&nbsp;&nbsp;&nbsp; canvases = new Canvas[data.getNmbr()];

&nbsp;&nbsp;&nbsp; //Throw exception if number of functions is greater
&nbsp;&nbsp;&nbsp; // than 8.
&nbsp;&nbsp;&nbsp; number = data.getNmbr();
&nbsp;&nbsp;&nbsp; if(number &gt; 8){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NoSuchMethodException(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Too many functions.&nbsp; "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "Only 8 allowed.");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Create the control panel and give it a border for
&nbsp;&nbsp;&nbsp; // cosmetics.
&nbsp;&nbsp;&nbsp; JPanel ctlPnl = new JPanel();
&nbsp;&nbsp;&nbsp; ctlPnl.setLayout(new GridLayout(0,4));//?rows x 4 cols
&nbsp;&nbsp;&nbsp; ctlPnl.setBorder(new EtchedBorder());

&nbsp;&nbsp;&nbsp; //Button for replotting the graph
&nbsp;&nbsp;&nbsp; JButton graphBtn =new JButton("Graph");
&nbsp;&nbsp;&nbsp; graphBtn.addActionListener(this);

&nbsp;&nbsp;&nbsp; //Populate each panel with a label and a text field.
&nbsp;&nbsp;&nbsp; // Will place these panels in a grid on the control
&nbsp;&nbsp;&nbsp; // panel later.
&nbsp;&nbsp;&nbsp; pan0.add(new JLabel("xMin"));
&nbsp;&nbsp;&nbsp; pan0.add(xMinTxt);

&nbsp;&nbsp;&nbsp; pan1.add(new JLabel("xMax"));
&nbsp;&nbsp;&nbsp; pan1.add(xMaxTxt);

&nbsp;&nbsp;&nbsp; pan2.add(new JLabel("yMin"));
&nbsp;&nbsp;&nbsp; pan2.add(yMinTxt);

&nbsp;&nbsp;&nbsp; pan3.add(new JLabel("yMax"));
&nbsp;&nbsp;&nbsp; pan3.add(yMaxTxt);

&nbsp;&nbsp;&nbsp; pan4.add(new JLabel("xTicInt"));
&nbsp;&nbsp;&nbsp; pan4.add(xTicIntTxt);

&nbsp;&nbsp;&nbsp; pan5.add(new JLabel("yTicInt"));
&nbsp;&nbsp;&nbsp; pan5.add(yTicIntTxt);

&nbsp;&nbsp;&nbsp; pan6.add(new JLabel("xCalcInc"));
&nbsp;&nbsp;&nbsp; pan6.add(xCalcIncTxt);

&nbsp;&nbsp;&nbsp; //Add the populated panels and the button to the
&nbsp;&nbsp;&nbsp; // control panel with a grid layout.
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan0);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan1);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan2);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan3);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan4);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan5);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan6);
&nbsp;&nbsp;&nbsp; ctlPnl.add(graphBtn);

&nbsp;&nbsp;&nbsp; //Create a panel to contain the Canvas objects.&nbsp; They
&nbsp;&nbsp;&nbsp; // will be displayed in a one-column grid.
&nbsp;&nbsp;&nbsp; JPanel canvasPanel = new JPanel();
&nbsp;&nbsp;&nbsp; canvasPanel.setLayout(new GridLayout(0,1));//?rows 1col

&nbsp;&nbsp;&nbsp; //Create a custom Canvas object for each function to
&nbsp;&nbsp;&nbsp; // be plotted and add them to the one-column grid.
&nbsp;&nbsp;&nbsp; // Make background colors alternate between white and
&nbsp;&nbsp;&nbsp; // gray.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt &lt; number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt]. setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt]. setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] = new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Add the object to the grid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvasPanel.add(canvases[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Add the sub-assemblies to the frame.&nbsp; Set its
&nbsp;&nbsp;&nbsp; // location, size, and title, and make it visible.
&nbsp;&nbsp;&nbsp; getContentPane(). add(ctlPnl,"South");
&nbsp;&nbsp;&nbsp; getContentPane(). add(canvasPanel,"Center");

&nbsp;&nbsp;&nbsp; setBounds(0,0,frmWidth,frmHeight);

&nbsp;&nbsp;&nbsp; if(args == null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph08, Copyright 2005, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Richard G. Baldwin");
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph08/" + args + " Copyright 2005, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "R. G. Baldwin");
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Set to exit on X-button click
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; //Guarantee a repaint on startup.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//

&nbsp; //This event handler is registered on the JButton to
&nbsp; // cause the functions to be replotted.
&nbsp; public void actionPerformed(ActionEvent evt){
&nbsp;&nbsp;&nbsp; //Re-instantiate the object that provides the data
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc08)Class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forName(args).newInstance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; }catch(Exception e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Known to be safe at this point. Otherwise would
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // have aborted earlier.
&nbsp;&nbsp;&nbsp; }//end catch

&nbsp;&nbsp;&nbsp; //Set plotting parameters using data from the text
&nbsp;&nbsp;&nbsp; // fields.
&nbsp;&nbsp;&nbsp; xMin = Double.parseDouble(xMinTxt.getText());
&nbsp;&nbsp;&nbsp; xMax = Double.parseDouble(xMaxTxt.getText());
&nbsp;&nbsp;&nbsp; yMin = Double.parseDouble(yMinTxt.getText());
&nbsp;&nbsp;&nbsp; yMax = Double.parseDouble(yMaxTxt.getText());
&nbsp;&nbsp;&nbsp; xTicInt = Double.parseDouble(xTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; yTicInt = Double.parseDouble(yTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; xCalcInc = Double.parseDouble(xCalcIncTxt.getText());

&nbsp;&nbsp;&nbsp; //Calculate new values for the length of the tic marks
&nbsp;&nbsp;&nbsp; // on the axes.&nbsp; If too small on x-axis, a default
&nbsp;&nbsp;&nbsp; // value is used later.
&nbsp;&nbsp;&nbsp; xTicLen = (yMax-yMin)/50;
&nbsp;&nbsp;&nbsp; yTicLen = (xMax-xMin)/50;

&nbsp;&nbsp;&nbsp; //Repaint the plotting areas
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end actionPerformed
&nbsp; //-----------------------------------------------------//


//This is an inner class, which is used to override the
// paint method on the plotting surface.
class MyCanvas extends Canvas{
&nbsp; int cnt;//object number
&nbsp; //Factors to convert from double values to integer pixel
&nbsp; // locations.
&nbsp; double xScale;
&nbsp; double yScale;

&nbsp; MyCanvas(int cnt){//save obj number
&nbsp;&nbsp;&nbsp; this.cnt = cnt;
&nbsp; }//end constructor

&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){

&nbsp;&nbsp;&nbsp; //Get and save the size of the plotting surface
&nbsp;&nbsp;&nbsp; width = canvases[0].getWidth();
&nbsp;&nbsp;&nbsp; height = canvases[0].getHeight();

&nbsp;&nbsp;&nbsp; //Calculate the scale factors
&nbsp;&nbsp;&nbsp; xScale = width/(xMax-xMin);
&nbsp;&nbsp;&nbsp; yScale = height/(yMax-yMin);

&nbsp;&nbsp;&nbsp; //Set the origin based on the minimum values in x and y
&nbsp;&nbsp;&nbsp; g.translate((int)((0-xMin)*xScale),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((0-yMin)*yScale));
&nbsp;&nbsp;&nbsp; drawAxes(g);//Draw the axes
&nbsp;&nbsp;&nbsp; g.setColor(Color.BLACK);

&nbsp;&nbsp;&nbsp; //Get initial data values
&nbsp;&nbsp;&nbsp; double xVal = xMin;
&nbsp;&nbsp;&nbsp; int oldX = getTheX(xVal);
&nbsp;&nbsp;&nbsp; int oldY = 0;
&nbsp;&nbsp;&nbsp; //Use the Canvas obj number to determine which method
&nbsp;&nbsp;&nbsp; // to invoke to get the value for y.
&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f6(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f7(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f8(xVal));
&nbsp;&nbsp;&nbsp; }//end switch

&nbsp;&nbsp;&nbsp; //Now loop and plot the points
&nbsp;&nbsp;&nbsp; while(xVal &lt; xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int yVal = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get next data value.&nbsp; Use the Canvas obj number to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // determine which method to invoke to get the value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for y.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f6(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal = getTheY(data.f7(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =getTheY(data.f8(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch1

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Convert the x-value to an int and draw the next
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line segment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = getTheX(xVal);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(oldX,oldY,x,yVal);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Increment along the x-axis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xVal += xCalcInc;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save end point to use as start point for next line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // segment.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldX = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = yVal;
&nbsp;&nbsp;&nbsp; }//end while loop

&nbsp; }//end overridden paint method
&nbsp; //-----------------------------------------------------//

&nbsp; //Method to draw axes with tic marks and labels in the
&nbsp; // color RED
&nbsp; void drawAxes(Graphics g){
&nbsp;&nbsp;&nbsp; g.setColor(Color.RED);

&nbsp;&nbsp;&nbsp; //Lable left x-axis and bottom y-axis.&nbsp; These are the
&nbsp;&nbsp;&nbsp; // easy ones.&nbsp; Separate the labels from the ends of the
&nbsp;&nbsp;&nbsp; // tic marks by two pixels.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMin,getTheX(xMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMin,getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMin));

&nbsp;&nbsp;&nbsp; //Label the right x-axis and the top y-axis.&nbsp; These are
&nbsp;&nbsp;&nbsp; // the hard ones because the position must be adjusted
&nbsp;&nbsp;&nbsp; // by the font size and the number of characters.
&nbsp;&nbsp;&nbsp; //Get the width of the string for right end of x-axis
&nbsp;&nbsp;&nbsp; // and the height of the string for top of y-axis
&nbsp;&nbsp;&nbsp; //Create a string that is an integer representation of
&nbsp;&nbsp;&nbsp; // the label for the right end of the x-axis.&nbsp; Then get
&nbsp;&nbsp;&nbsp; // a character array that represents the string.
&nbsp;&nbsp;&nbsp; int xMaxInt = (int)xMax;
&nbsp;&nbsp;&nbsp; String xMaxStr = "" + xMaxInt;
&nbsp;&nbsp;&nbsp; char[] array = xMaxStr.toCharArray();

&nbsp;&nbsp;&nbsp; //Get a FontMetrics object that can be used to get the
&nbsp;&nbsp;&nbsp; // size of the string in pixels.
&nbsp;&nbsp;&nbsp; FontMetrics fontMetrics = g.getFontMetrics();
&nbsp;&nbsp;&nbsp; //Get a bounding rectangle for the string
&nbsp;&nbsp;&nbsp; Rectangle2D r2d = fontMetrics.getStringBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array,0,array.length,g);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get the width and the height of the bounding
&nbsp;&nbsp;&nbsp; // rectangle.&nbsp; The width is the width of the label at
&nbsp;&nbsp;&nbsp; // the right end of the x-axis.&nbsp; The height applies to
&nbsp;&nbsp;&nbsp; // all the labels, but is needed specifically for the
&nbsp;&nbsp;&nbsp; // label at the top end of the y-axis.
&nbsp;&nbsp;&nbsp; int labWidth = (int)(r2d.getWidth());
&nbsp;&nbsp;&nbsp; int labHeight = (int)(r2d.getHeight());

&nbsp;&nbsp;&nbsp; //Label the positive x-axis and the positive y-axis
&nbsp;&nbsp;&nbsp; // using the width and height from above to position
&nbsp;&nbsp;&nbsp; // the labels.&nbsp; These labels apply to the very ends of
&nbsp;&nbsp;&nbsp; // the axes at the edge of the plotting surface.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMax,getTheX(xMax)-labWidth,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMax,getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax)+labHeight);

&nbsp;&nbsp;&nbsp; //Draw the axes
&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(xMin),getTheY(0.0),getTheX(xMax),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(0.0));

&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(0.0),getTheY(yMin),getTheX(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax));

&nbsp;&nbsp;&nbsp; //Draw the tic marks on axes
&nbsp;&nbsp;&nbsp; xTics(g);
&nbsp;&nbsp;&nbsp; yTics(g);
&nbsp; }//end drawAxes

&nbsp; //-----------------------------------------------------//

&nbsp; //Method to draw tic marks on x-axis
&nbsp; void xTics(Graphics g){
&nbsp;&nbsp;&nbsp; double xDoub = 0;
&nbsp;&nbsp;&nbsp; int x = 0;

&nbsp;&nbsp;&nbsp; //Get the ends of the tic marks.
&nbsp;&nbsp;&nbsp; int topEnd = getTheY(xTicLen/2);
&nbsp;&nbsp;&nbsp; int bottomEnd =getTheY(-xTicLen/2);

&nbsp;&nbsp;&nbsp; //If the vertical size of the plotting area is small,
&nbsp;&nbsp;&nbsp; // the calculated tic size may be too small.&nbsp; In that
&nbsp;&nbsp;&nbsp; // case, set it to 10 pixels.
&nbsp;&nbsp;&nbsp; if(topEnd &lt; 5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topEnd = 5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bottomEnd = -5;
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short lines to serve as
&nbsp;&nbsp;&nbsp; // tic marks. Begin with the positive x-axis moving to
&nbsp;&nbsp;&nbsp; // the right from zero.
&nbsp;&nbsp;&nbsp; while(xDoub &lt; xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub += xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative x-axis moving to the left from
&nbsp;&nbsp;&nbsp; // zero
&nbsp;&nbsp;&nbsp; xDoub = 0;
&nbsp;&nbsp;&nbsp; while(xDoub &gt; xMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub -= xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end xTics
&nbsp; //-----------------------------------------------------//

&nbsp; //Method to draw tic marks on y-axis
&nbsp; void yTics(Graphics g){
&nbsp;&nbsp;&nbsp; double yDoub = 0;
&nbsp;&nbsp;&nbsp; int y = 0;
&nbsp;&nbsp;&nbsp; int rightEnd = getTheX(yTicLen/2);
&nbsp;&nbsp;&nbsp; int leftEnd = getTheX(-yTicLen/2);

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short lines to serve as tic
&nbsp;&nbsp;&nbsp; // marks. Begin with the positive y-axis moving up from
&nbsp;&nbsp;&nbsp; // zero.
&nbsp;&nbsp;&nbsp; while(yDoub &lt; yMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub += yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative y-axis moving down from zero.
&nbsp;&nbsp;&nbsp; yDoub = 0;
&nbsp;&nbsp;&nbsp; while(yDoub &gt; yMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub -= yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end yTics
&nbsp; //-----------------------------------------------------//

&nbsp; //This method translates and scales a double y value to
&nbsp; // plot properly in the integer coordinate system. In
&nbsp; // addition to scaling, it causes the positive direction
&nbsp; // of the y-axis to be from bottom to top.
&nbsp; int getTheY(double y){
&nbsp;&nbsp;&nbsp; double yDoub = (yMax+yMin)-y;
&nbsp;&nbsp;&nbsp; int yInt = (int)(yDoub*yScale);
&nbsp;&nbsp;&nbsp; return yInt;
&nbsp; }//end getTheY
&nbsp; //-----------------------------------------------------//

&nbsp; //This method scales a double x value to plot properly
&nbsp; // in the integer coordinate system.
&nbsp; int getTheX(double x){
&nbsp;&nbsp;&nbsp; return (int)(x*xScale);
&nbsp; }//end getTheX
&nbsp; //-----------------------------------------------------//

}//end inner class MyCanvas
//=======================================================//

}//end class GUI
//=======================================================//

//Sample test class.&nbsp; Required for compilation and
// stand-alone testing.
class junk implements GraphIntfc08{
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to process.&nbsp; Must not
&nbsp;&nbsp;&nbsp; // exceed 8.
&nbsp;&nbsp;&nbsp; return 8;
&nbsp; }//end getNmbr

&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; return (x*x*x)/200.0;
&nbsp; }//end f1

&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; return -(x*x*x)/200.0;
&nbsp; }//end f2

&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; return (x*x)/200.0;
&nbsp; }//end f3

&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; return 50*Math.cos(x/10.0);
&nbsp; }//end f4

&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/20.0);
&nbsp; }//end f5

&nbsp; public double f6(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/30.0);
&nbsp; }//end f6
&nbsp;
&nbsp; public double f7(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/5.0);
&nbsp; }//end f7

&nbsp; public double f8(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/2.5);
&nbsp; }//end f8
}//end sample class junk<br><br><b><font face="Courier New,Courier">Listing 28</font></b></pre></td></tr></tbody></table><p>
<a name="Listing_29">Listing 29</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00"><tbody><tr><td><pre>/* File GraphIntfc08.java
Copyright 2005, R.G.Baldwin

This interface must be implemented by classes whose objects
produce data to be plotted by the program named Graph08.

This is an upgrade from GraphIntfc01, designed to handle
eight graphs instead of only five.

Tested using J2SE 5.0 WinXP.
**********************************************************/

public interface GraphIntfc08{
&nbsp; public int getNmbr();
&nbsp; public double f1(double x);
&nbsp; public double f2(double x);
&nbsp; public double f3(double x);
&nbsp; public double f4(double x);
&nbsp; public double f5(double x);
&nbsp; public double f6(double x);
&nbsp; public double f7(double x);
&nbsp; public double f8(double x);
}//end GraphIntfc08<br><br><b><font face="Courier New,Courier">Listing 29</font></b></pre></td></tr></tbody></table><p></p><p>
<a name="Listing_30">Listing 30</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00"><tbody><tr><td><pre>/* File Dsp041.java
Copyright 2005, R.G.Baldwin

This class is loosely based on the class named Dsp040a. The
class named Dsp040a was explained in detail in Lesson 1488
entitled Convolution and Matched Filtering in Java.

The purpose of this class is to make it easy to experiment
with different time series and different convolution
filters.

This class must be run under control of the class named
Graph08. Thus, it requires access to the class named
Graph08 and the interface named GraphIntfc08.&nbsp;

Graph08 and GraphIntfc08 are updates to Graph03 and
GraphIntfc01.&nbsp; The updates allow the user to plot a maximum
of eight graphs instead of a maximum of five graphs as is
the case with Graph03.

Graph03 and GraphIntfc01 were explained in lesson 1488
entitled Convolution and Matched Filtering in Java.

To run this program, enter the following command at the
command line:

java Graph08 Dsp041

Access to the following classes, plus some inner classes
defined in these classes is required to compile and
run this class under control of the class named Graph08:

Dsp041.class
Graph08.class
GraphIntfc08.class
GUI.class

The source code for all of the above classes is provided
either in this file or in lesson 412 entitled Processing
Image Pixels, Applying Image Convolution in Java.

This program illustrates the application of a convolution
filter to signals having a known waveform.&nbsp; In its current
state, five different convolution filters are coded into
the class.&nbsp; Since the class can only apply one convolution
filter at a time, it is necessary to enable and disable the
filters using comments and then recompile the class to
switch from one convolution filter to the other.&nbsp; The five
convolution filters are:

1. A single impulse filter that simply copies the input to
&nbsp;&nbsp; the output.
2. A high-pass filter with an output that is proportional
&nbsp;&nbsp; to the slope of the signal.&nbsp; In essence, the output
&nbsp;&nbsp; approximates the first derivative of the signal.
3. A high-pass filter with an output that is proportional
&nbsp;&nbsp; to the rate of change of the slope of the signal. This
&nbsp;&nbsp; output approximates the second derivative of the signal.
4. A relatively soft high-pass filter, which produces a
&nbsp;&nbsp; little blip in its output each time the slope of the
&nbsp;&nbsp; signal changes.&nbsp; The size of the blip is roughly
&nbsp;&nbsp; proportional to the rate of change of the slope of the
&nbsp;&nbsp; signal.
5. A low-pass smoothing filter.&nbsp; The output approximates a
&nbsp;&nbsp; four-point running average or integration of the signal.

These convolution filters are applied to signal waveforms
having varying slopes.&nbsp; Several interesting results are
displayed.&nbsp; (The filters and the signal waveforms can be
easily modified by modifying that part of the program and
recompiling the program.)

The display contains six graphs and shows the following:
1. The signal waveform as a time series.
2. The convolution filter waveform as a time series.
3. The result of applying the convolution filter to the
&nbsp;&nbsp; signal, including the impulse response of the filter.
4. The amplitude spectrum of the signal expressed in db.
5. The amplitude frequency response of the convolution
&nbsp;&nbsp; filter expressed in db.
6. The amplitude spectrum of the output produced by
&nbsp;&nbsp; applying the convolution filter to the signal.

The convolution algorithm emulates a one-dimensional
version of the 2D image convolution algorithm used in the
class named ImgMod032 with respect to output normalization
and scaling.&nbsp; See an explanation of just what this means in
the comments at the beginning of the convolve method.

In addition to computing and plotting the output from the
convolution process, the class computes and plots several
spectral graphs.

Tested using J2SE 5.0 under WinXP.
**********************************************************/

class Dsp041 implements GraphIntfc08{
&nbsp; //Establish length for various arrays
&nbsp; int filterLen = 200;
&nbsp; int signalLen = 400;
&nbsp; int outputLen = signalLen - filterLen;
&nbsp; //Ignore right half of signal, which is all zeros, when
&nbsp; // computing the spectrum.
&nbsp; int signalSpectrumPts = signalLen/2;
&nbsp; int filterSpectrumPts = outputLen;
&nbsp; int outputSpectrumPts = outputLen;
&nbsp;

&nbsp; //Create arrays to store different types of data.
&nbsp; double[] signal = new double[signalLen];
&nbsp; double[] filter = new double[filterLen];
&nbsp; double[] output = new double[outputLen];
&nbsp; double[] spectrumA = new double[signalSpectrumPts];
&nbsp; double[] spectrumB = new double[filterSpectrumPts];
&nbsp; double[] spectrumC = new double[outputSpectrumPts];

&nbsp; public Dsp041(){//constructor

&nbsp;&nbsp;&nbsp; //Create and save a filter.&nbsp; Change the locations of
&nbsp;&nbsp;&nbsp; // the following comment indicators to enable and/or
&nbsp;&nbsp;&nbsp; // disable a particular filter.&nbsp; Then recompile the
&nbsp;&nbsp;&nbsp; // class and rerun the program to see the effect of
&nbsp;&nbsp;&nbsp; // the newly enabled filter on the signal.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //This is a single impulse filter that simply copies
&nbsp;&nbsp;&nbsp; // the input to the output.
&nbsp;&nbsp;&nbsp; filter[0] = 1;

/*
&nbsp;&nbsp;&nbsp; //This is a high-pass filter with an output that is
&nbsp;&nbsp;&nbsp; // proportional to the slope of the signal.&nbsp; In
&nbsp;&nbsp;&nbsp; // essence,the output approximates the first derivative
&nbsp;&nbsp;&nbsp; // of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -1.0;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;

&nbsp;&nbsp;&nbsp; //This is a high-pass filter with an output that is
&nbsp;&nbsp;&nbsp; // proportional to the rate of change of the slope of
&nbsp;&nbsp;&nbsp; // the signal. In essence, the output approximates the
&nbsp;&nbsp;&nbsp; // second derivative of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -0.5;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;
&nbsp;&nbsp;&nbsp; filter[2] = -0.5;

&nbsp;&nbsp;&nbsp; //This is a relatively soft high-pass filter, which
&nbsp;&nbsp;&nbsp; // produces a little blip in the output each time the
&nbsp;&nbsp;&nbsp; // slope of the signal changes.&nbsp; The size of the blip
&nbsp;&nbsp;&nbsp; // is roughly proportional to the rate of change of the
&nbsp;&nbsp;&nbsp; // slope of the signal.
&nbsp;&nbsp;&nbsp; filter[0] = -0.2;
&nbsp;&nbsp;&nbsp; filter[1] = 1.0;
&nbsp;&nbsp;&nbsp; filter[2] = -0.2;

&nbsp;&nbsp;&nbsp; //This is a low-pass smoothing filter.&nbsp; It approximates
&nbsp;&nbsp;&nbsp; // a four-point running average or integration of the
&nbsp;&nbsp;&nbsp; // signal.
&nbsp;&nbsp;&nbsp; filter[0] = 0.250;
&nbsp;&nbsp;&nbsp; filter[1] = 0.250;
&nbsp;&nbsp;&nbsp; filter[2] = 0.250;
&nbsp;&nbsp;&nbsp; filter[3] = 0.250;
*/
&nbsp;
&nbsp;&nbsp;&nbsp; //Create a signal time series containing four distinct
&nbsp;&nbsp;&nbsp; // waveforms:
&nbsp;&nbsp;&nbsp; //&nbsp; An impulse.
&nbsp;&nbsp;&nbsp; //&nbsp; A rectangular pulse.
&nbsp;&nbsp;&nbsp; //&nbsp; A triangular pulse with a large slope.
&nbsp;&nbsp;&nbsp; //&nbsp; A triangular pulse with a smaller slope.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //First create a baseline in the signal time series.
&nbsp;&nbsp;&nbsp; //Modify the following value and recompile the class
&nbsp;&nbsp;&nbsp; // to change the baseline.
&nbsp;&nbsp;&nbsp; double baseline = 10.0;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; signalLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal[cnt] = baseline;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now add the pulses to the signal time series.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //First add an impulse.
&nbsp;&nbsp;&nbsp; signal[20] = 75;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a rectangular pulse.
&nbsp;&nbsp;&nbsp; signal[30] = 75;
&nbsp;&nbsp;&nbsp; signal[31] = 75;
&nbsp;&nbsp;&nbsp; signal[32] = 75;
&nbsp;&nbsp;&nbsp; signal[33] = 75;
&nbsp;&nbsp;&nbsp; signal[34] = 75;
&nbsp;&nbsp;&nbsp; signal[35] = 75;
&nbsp;&nbsp;&nbsp; signal[36] = 75;
&nbsp;&nbsp;&nbsp; signal[37] = 75;
&nbsp;&nbsp;&nbsp; signal[38] = 75;
&nbsp;&nbsp;&nbsp; signal[39] = 75;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a triangular pulse with a large slope.
&nbsp;&nbsp;&nbsp; signal[50] = 10;
&nbsp;&nbsp;&nbsp; signal[51] = 30;
&nbsp;&nbsp;&nbsp; signal[52] = 50;
&nbsp;&nbsp;&nbsp; signal[53] = 70;
&nbsp;&nbsp;&nbsp; signal[54] = 90;
&nbsp;&nbsp;&nbsp; signal[55] = 70;
&nbsp;&nbsp;&nbsp; signal[56] = 50;
&nbsp;&nbsp;&nbsp; signal[57] = 30;
&nbsp;&nbsp;&nbsp; signal[58] = 10;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add a triangular pulse with a smaller slope.
&nbsp;&nbsp;&nbsp; signal[70] = 10;
&nbsp;&nbsp;&nbsp; signal[71] = 20;
&nbsp;&nbsp;&nbsp; signal[72] = 30;
&nbsp;&nbsp;&nbsp; signal[73] = 40;
&nbsp;&nbsp;&nbsp; signal[74] = 50;
&nbsp;&nbsp;&nbsp; signal[75] = 60;
&nbsp;&nbsp;&nbsp; signal[76] = 70;
&nbsp;&nbsp;&nbsp; signal[77] = 80;
&nbsp;&nbsp;&nbsp; signal[78] = 90;
&nbsp;&nbsp;&nbsp; signal[79] = 80;
&nbsp;&nbsp;&nbsp; signal[80] = 70;
&nbsp;&nbsp;&nbsp; signal[81] = 60;
&nbsp;&nbsp;&nbsp; signal[82] = 50;
&nbsp;&nbsp;&nbsp; signal[83] = 40;
&nbsp;&nbsp;&nbsp; signal[84] = 30;
&nbsp;&nbsp;&nbsp; signal[85] = 20;
&nbsp;&nbsp;&nbsp; signal[86] = 10;

&nbsp;&nbsp;&nbsp; //Convolve the signal with the convolution filter.
&nbsp;&nbsp;&nbsp; // Note, this convolution algorithm emulates a
&nbsp;&nbsp;&nbsp; // one-dimensional version of the 2D image
&nbsp;&nbsp;&nbsp; // convolution algorithm used in ImgMod032 with respect
&nbsp;&nbsp;&nbsp; // to normalization and scaling.
&nbsp;&nbsp;&nbsp; convolve(signal,filter,output);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Compute and save the DFT of the signal, expressed in
&nbsp;&nbsp;&nbsp; // db.
&nbsp;&nbsp;&nbsp; //Ignore right half of signal which is all zeros.
&nbsp;&nbsp;&nbsp; dft(signal,signalSpectrumPts,spectrumA);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Compute and save the DFT of the convolution filter
&nbsp;&nbsp;&nbsp; // expressed in db.
&nbsp;&nbsp;&nbsp; //Note that the convolution filter is added to a long
&nbsp;&nbsp;&nbsp; // time series having zero values.&nbsp; This causes the
&nbsp;&nbsp;&nbsp; // output of the DFT to be finely sampled and produces
&nbsp;&nbsp;&nbsp; // a smooth curve for the frequency response of the
&nbsp;&nbsp;&nbsp; // convolution filter.
&nbsp;&nbsp;&nbsp; dft(filter,filterSpectrumPts,spectrumB);

&nbsp;&nbsp;&nbsp; //Compute and save the DFT of the output expressed in
&nbsp;&nbsp;&nbsp; // decibels.
&nbsp;&nbsp;&nbsp; dft(output,outputSpectrumPts,spectrumC);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //All of the time series have now been produced and
&nbsp;&nbsp;&nbsp; // saved.&nbsp; They may be retrieved and plotted by
&nbsp;&nbsp;&nbsp; // invoking the methods named f1 through f6 below.

&nbsp; }//end constructor

&nbsp; //-----------------------------------------------------//
&nbsp; //The following nine methods are required by the
&nbsp; // interface named GraphIntfc08.&nbsp; They are invoked by the
&nbsp; // plotting class named Graph08.
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to process. Must not
&nbsp;&nbsp;&nbsp; // exceed 6.
&nbsp;&nbsp;&nbsp; return 6;
&nbsp; }//end getNmbr
&nbsp; //-----------------------------------------------------//
&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; //This version of this method returns the signal.
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; signal.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Scale for display and return.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return signal[index] * 1.0;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f1
&nbsp; //-----------------------------------------------------//
&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; //Return the convolution filter.
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; filter.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Scale for display and return.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return filter[index] * 50.0;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f2
&nbsp; //-----------------------------------------------------//
&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; //Return convolution output.
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; output.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Scale for display and return.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output[index] * 1.0;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f3
&nbsp; //-----------------------------------------------------//
&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; //Return frequency spectrum of the signal.
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; spectrumA.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust peak amplitude for display and return.&nbsp; With
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this scaling, 100 vertical units in the plot
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produced by Graph08 represents 25 decibels.&nbsp; In
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // addition, the db values are adjusted to cause the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // maximum value to be plotted at 100 units above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spectrumA[index] * 4.0 + 100;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f4
&nbsp; //-----------------------------------------------------//
&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; //Return frequency response of convolution filter.
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; spectrumB.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust peak amplitude for display and return. See
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comments in f4.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spectrumB[index] * 4.0 + 100;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f5
&nbsp; //-----------------------------------------------------//
&nbsp; public double f6(double x){
&nbsp;&nbsp;&nbsp; //Return frequency spectrum of the output.
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index &lt; 0 || index &gt; spectrumC.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust peak amplitude for display and return. See
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comments in f4.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spectrumC[index] * 4.0 + 100;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end f6
&nbsp; //-----------------------------------------------------//
&nbsp; public double f7(double x){
&nbsp;&nbsp;&nbsp; //This method is not used but must be defined.
&nbsp;&nbsp;&nbsp; return 0.0;
&nbsp; }//end f7
&nbsp; //-----------------------------------------------------//
&nbsp; public double f8(double x){
&nbsp;&nbsp;&nbsp; //This method is not used but must be defined.
&nbsp;&nbsp;&nbsp; return 0.0;
&nbsp; }//end f8
&nbsp; //-----------------------------------------------------//

&nbsp; //This method computes and returns the amplitude spectrum
&nbsp; // of an incoming time series.&nbsp; The amplitude spectrum is
&nbsp; // computed as the square root of the sum of the squares
&nbsp; // of the real and imaginary parts.&nbsp; It is converted to
&nbsp; // decibels and the amplitude spectrum in db is returned.
&nbsp; //Returns a number of points in the frequency domain
&nbsp; // equal to the number of samples in the incoming time
&nbsp; // series. This is for convenience only and is not a
&nbsp; // requirement of a DFT.
&nbsp; //Deposits the frequency data in an array whose
&nbsp; // reference is received as an incoming parameter.
&nbsp; public void dft(double[] data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dataLen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] spectrum){
&nbsp;&nbsp;&nbsp; double twoPI = 2*Math.PI;

&nbsp;&nbsp;&nbsp; //Set the frequency increment to the reciprocal of the
&nbsp;&nbsp;&nbsp; // data length.&nbsp; This is a convenience only, and is not
&nbsp;&nbsp;&nbsp; // a requirement of the DFT algorithm.
&nbsp;&nbsp;&nbsp; double delF = 1.0/dataLen;
&nbsp;&nbsp;&nbsp; //Outer loop interates on frequency values.
&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; dataLen;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double freq = i*delF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double real = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double imag = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Inner loop iterates on time- series points.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=0; j &lt; dataLen; j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real += data[j]*Math.cos(twoPI*freq*j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag += data[j]*Math.sin(twoPI*freq*j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spectrum[i] = Math.sqrt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real*real + imag*imag);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Convert the amplitude spectrum to decibels.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set zero and negative values to -Double.MAX_VALUE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // before converting to log values. Shouldn't be any
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // negative values. May be some zero values. An
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude value of 0 should result in negative
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // infinity decibels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(spectrum[cnt] &lt;= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spectrum[cnt] = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(spectrum[cnt] &gt; 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Ignore zero and negative values. Convert positive
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values to log base 10.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spectrum[cnt] = 20*Math.log10(spectrum[cnt]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //The amplitude spectrum has now been converted to db.
&nbsp;&nbsp;&nbsp; // Normalize the peak to zero db.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get the max value.
&nbsp;&nbsp;&nbsp; double max = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(spectrum[cnt] &gt; max)max = spectrum[cnt];
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Subtract the max from every value
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spectrum[cnt] -= max;
&nbsp;&nbsp;&nbsp; //System.out.print(spectrum[cnt] + " ");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end dft
&nbsp; //-----------------------------------------------------//
&nbsp; //This method applies an incoming convolution filter
&nbsp; // to an incoming set of data and deposits the filtered
&nbsp; // data in an output array whose reference is received as
&nbsp; // an incoming parameter.
&nbsp; //This convolution algorithm emulates a one-dimensional
&nbsp; // version of the 2D image convolution algorithm used in
&nbsp; // the class named ImgMod032 with respect to
&nbsp; // normalization and scaling.
&nbsp; //There are two major differences between this algorithm
&nbsp; // and the 2D algorithm.&nbsp; First, this algorithm flips the
&nbsp; // convolution filter end-for-end whereas the 2D
&nbsp; // algorithm does not flip the convolution filter.
&nbsp; // Thus, the 2D algorithm requires that the convolution
&nbsp; // operator be flipped before it is passed to the method.
&nbsp; // Second, whereas the 2D algorithm normalizes the output
&nbsp; // data so as to guarantee that the output values range
&nbsp; // from 0 to 255 inclusive, this algorithm normalizes the
&nbsp; // output data so as to guarantee that the output values
&nbsp; // range from 0 to 100 inclusive.&nbsp; This difference is of
&nbsp; // no practical significance other than to cause the
&nbsp; // output values to be plotted on a scale that is
&nbsp; // somewhat easier to interpret.
&nbsp; //Both algorithms assume that the incoming data consists
&nbsp; // of all positive values (as is the case with color
&nbsp; // values) with regard to the normalization rationale.
&nbsp; // However, that is not a technical requirement.
&nbsp; //The algorithm begins by computing and saving the mean
&nbsp; // value of the incoming data.&nbsp; Then it makes a copy of
&nbsp; // the incoming data, removing the mean in the process.
&nbsp; // (The copy is made simply to avoid modifying the
&nbsp; // original data.)&nbsp; Then the method applies the
&nbsp; // convolution filter to the copy of the incoming data
&nbsp; // producing an output time series with a zero mean
&nbsp; // value.
&nbsp; //Then the method adds the&nbsp; original mean value to the
&nbsp; // output values causing the mean value of the output
&nbsp; // to be the same as the mean value of the input.
&nbsp; //Following this, the method computes the minimum value
&nbsp; // of the output and checks to see if it is negative.&nbsp; If
&nbsp; // so, the minimum value is subtracted from all output
&nbsp; // values, causing the minimum value of the output to be
&nbsp; // zero.&nbsp; Otherwise, no adjustment is made on the basis
&nbsp; // of the minimum value.
&nbsp; //Then the method computes the maximum value and checks
&nbsp; // to see if the maximum value is greater than 100.&nbsp; If
&nbsp; // so, all output values are scaled so as to cause the
&nbsp; // maximum output value to be 100.&nbsp; Otherwise, no
&nbsp; // adjustment is made on the basis of the maximum value.
&nbsp; public&nbsp; void convolve(double[] data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] operator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] output){
&nbsp;&nbsp;&nbsp; int dataLen = data.length;
&nbsp;&nbsp;&nbsp; double[] temp = new double[dataLen];
&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Get, save, and remove the mean value.
&nbsp;&nbsp;&nbsp; //Copy the data into a temporary array, removing the
&nbsp;&nbsp;&nbsp; // mean value in the process.
&nbsp;&nbsp;&nbsp; double sum = 0;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += data[cnt];
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; double mean = sum/dataLen;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[cnt] = data[cnt] - mean;
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Apply the convolution filter to the copy of the
&nbsp;&nbsp;&nbsp; // data, dealing with the index reversal required
&nbsp;&nbsp;&nbsp; // to flip the operator end-for-end.
&nbsp;&nbsp;&nbsp; int operatorLen = operator.length;
&nbsp;&nbsp;&nbsp; for(int i = 0;i &lt; dataLen-operatorLen;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[i] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = operatorLen-1;j &gt;= 0;j--){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[i] += temp[i+j]*operator[j];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Restore the original mean value to the output.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen-operatorLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[cnt] += mean;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Find the minimum value in the output.
&nbsp;&nbsp;&nbsp; double min = Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen-operatorLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(output[cnt] &lt; min){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min = output[cnt];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; System.out.println("Output min: " + min);

&nbsp;&nbsp;&nbsp; //If the minimum value is negative, subtract it from
&nbsp;&nbsp;&nbsp; // all of the output values to ensure that the output
&nbsp;&nbsp;&nbsp; // minimum is zero.
&nbsp;&nbsp;&nbsp; if(min &lt; 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen-operatorLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[cnt] -= min;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Find the maximum value in the output.
&nbsp;&nbsp;&nbsp; double max = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen-operatorLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(output[cnt] &gt; max){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max = output[cnt];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; System.out.println("Output max: " + max);

&nbsp;&nbsp;&nbsp; //If the maximum value is greater than 100, scale all
&nbsp;&nbsp;&nbsp; // of the output values to ensure that the output
&nbsp;&nbsp;&nbsp; // maximum is 100.
&nbsp;&nbsp;&nbsp; if(max &gt; 100.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; dataLen-operatorLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[cnt] *= 100.0/max;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }//end if

&nbsp; }//end convolve method
}//end class Dsp041
//=======================================================//
<br><br><b><font face="Courier New,Courier">Listing 30</font></b></pre></td></tr></tbody></table><p></p><p></p><p>
<a name="Listing_31">Listing 31</a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00"><tbody><tr><td><pre>/*File ImgMod33.java
Copyright 2005, R.G.Baldwin

This class provides a general purpose 2D image convolution
and color filtering capability in Java. The class is
designed to be driven by the class named ImgMod02a.&nbsp;

The image file is specified on the command line. The name
of a file containing the 2D convolution filter is provided
via a TextField after the program starts running.
Multiplicative factors, which are applied to the individual
color planes are also provided through three TextFields
after the program starts running.

Enter the following at the command line to run this
program:

java ImgMod02a ImgMod33 ImageFileName

where ImageFileName is the name of a .gif or .jpg file,
including the extension.

Then enter the name of a file containing a 2D convolution
filter in the TextField that appears on the screen.&nbsp; Click
the Replot button on the Frame that displays the image
to cause the convolution filter to be applied to the image.
You can modify the multiplicative factors in the three
TextFields labeled Red, Green, and Blue before clicking the
Replot button to cause the color values to be scaled by
the respective multiplicative factors.&nbsp; The default
multiplicative factor for each color plane is 1.0.

When you click the Replot button, the image in the top of
the Frame will be convolved with the filter, the color
values in the color planes will be scaled by the
multiplicative factors, and the filtered image will appear
in the bottom of the Frame.

Each time you click the Replot button, two additional
graphs are produced that show the following information
in a color contour map fomat:
1.&nbsp; The convolution filter.
2.&nbsp; The wave number response of the convolution filter.

Because the GUI that contains the TextField for entry of
the convolution filter file name also contains three
additional TextFields that allow for the entry of
multiplicative factors that are applied to the three color
planes, it is possible to implement color filtering in
addition to convolution filtering.&nbsp; To apply color
filtering, enter new multiplicative scale factors into
the TextFields for Red, Green, and Blue and click the
Replot button.

Once the program is running, different convolution filters
and different color filters can be successively applied to
the same image, either separately or in combination, by
entering the name of each new filter file into the
TextField and/or entering new color multiplicative factors
into the respective color TextFields and then clicking the
Replot button

See comments at the beginning of the method named getFilter
for a description and an example of the required format for
the file containing the 2D convolution filter.

This program requires access to the following class files
plus some inner classes that are defined inside the
following classes:

ImgIntfc02.class
ImgMod02a.class
ImgMod29.class
ImgMod30.class
ImgMod32.class
ImgMod33.class

Tested using J2SE 5.0 and WinXP
**********************************************************/
import java.awt.*;
import java.io.*;

class ImgMod33 extends Frame implements ImgIntfc02{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; TextField fileNameField = new TextField("");
&nbsp; Panel rgbPanel = new Panel();
&nbsp; TextField redField = new TextField("1.0");
&nbsp; TextField greenField = new TextField("1.0");
&nbsp; TextField blueField = new TextField("1.0");
&nbsp; Label instructions = new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter Filter File Name and scale factors for " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Red, Green, and Blue and click Replot");
&nbsp; //-----------------------------------------------------//

&nbsp; ImgMod33(){//constructor
&nbsp;&nbsp;&nbsp; setLayout(new GridLayout(4,1));
&nbsp;&nbsp;&nbsp; add(new Label("Filter File Name"));
&nbsp;&nbsp;&nbsp; add(fileNameField);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Populate the rgbPanel
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Red"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(redField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Green"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(greenField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Blue"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(blueField);

&nbsp;&nbsp;&nbsp; add(rgbPanel);
&nbsp;&nbsp;&nbsp; add(instructions);
&nbsp;&nbsp;&nbsp; setTitle("Copyright 2005, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setBounds(400,0,460,125);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//

&nbsp; //This method is required by ImgIntfc02.&nbsp; It is called at
&nbsp; // the beginning of the run and each time thereafter that
&nbsp; // the user clicks the Replot button on the Frame
&nbsp; // containing the images.
&nbsp; //The method gets a 2D convolution filter from a text
&nbsp; // file, applies it to the incoming 3D array of pixel
&nbsp; // data and returns a filtered 3D array of pixel data.&nbsp;
&nbsp; public int[][][] processImg(int[][][] threeDPix,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgRows,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgCols){

&nbsp;&nbsp;&nbsp; //Create an empty output array of the same size as the
&nbsp;&nbsp;&nbsp; // incoming array.
&nbsp;&nbsp;&nbsp; int[][][] output = new int[imgRows][imgCols][4];

&nbsp;&nbsp;&nbsp; //Make a working copy of the 3D pixel array to avoid
&nbsp;&nbsp;&nbsp; // making permanent changes to the original image data.
&nbsp;&nbsp;&nbsp; int[][][] working3D = new int[imgRows][imgCols][4];
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; imgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; imgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][1] = threeDPix[row][col][1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][2] = threeDPix[row][col][2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][3] = threeDPix[row][col][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Copy alpha values directly to the output. They
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not processed when the image is filtered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by the convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop

&nbsp;&nbsp;&nbsp; //Get the file name containing the filter from the
&nbsp;&nbsp;&nbsp; // textfield.
&nbsp;&nbsp;&nbsp; String fileName = fileNameField.getText();
&nbsp;&nbsp;&nbsp; if(fileName.equals("")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The file name is an empty string. Skip the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution process and pass the input image
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // directly to the output.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = working3D;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a 2D array that is populated with the contents
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file containing the 2D filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filter = getFilter(fileName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Plot the impulse response and the wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // response of the convolution filter.&nbsp; These items
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not computed and plotted when the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // starts running.&nbsp; Rather, they are computed and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plotted each time the user clicks the Replot
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // button after entering the name of a file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // containing a convolution filter into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TextField.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Begin by placing the impulse response in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // center of a large flat surface with an elevation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of zero.This is done to improve the resolution of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the Fourier Transform, which will be computed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // later.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterRows = filter.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterCols = filter[0].length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cols = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the size of the surface ten pixels larger than
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the convolution filter with a minimum size of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32x32 pixels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterRows &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = numFilterRows + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterCols &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = numFilterCols + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create the surface, which will be initialized to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all zero values.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filterSurface = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Place the convolution filter in the center of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // surface.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numFilterRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numFilterCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filterSurface[row + (rows - numFilterRows)/2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [col + (cols - numFilterCols)/2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the filter and the surface on which it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resides as a 3D plot in a color contour format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(filterSurface,4,true,1);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the 2D Fourier Transform of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Prepare arrays to receive the results of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] real = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imag = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] amp = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Perform the 2D Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(filterSurface,real,imag,amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Ignore the real and imaginary results.&nbsp; Prepare the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude spectrum for more-effective plotting by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shifting the origin to the center in wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the minimum and maximum wave number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values.&nbsp; This is useful because the way that the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave number plots are normalized. it is not
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to infer the flatness or lack thereof of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the wave number surface simply by viewing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plot.&nbsp; The colors that describe the elevations
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // always range from black at the minimum to white at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the maximum, with different colors in between
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // regardless of the difference between the minimum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and the maximum.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double maxValue = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double minValue = Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; rows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; cols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &gt; maxValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &lt; minValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("minValue: " + minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("maxValue: " + maxValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ratio: " + maxValue/minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Generate and display the wave-number response
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // graph by plotting the 3D surface on the computer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // screen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Perform the convolution.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = ImgMod32.convolve(working3D,filter);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Scale output color planes.&nbsp; Color planes will be
&nbsp;&nbsp;&nbsp; // scaled only if the corresponding scale factor in the
&nbsp;&nbsp;&nbsp; // TextField has a value other than 1.0.&nbsp; Otherwise,
&nbsp;&nbsp;&nbsp; // there is no point in consuming computer time to do
&nbsp;&nbsp;&nbsp; // the scaling.
&nbsp;&nbsp;&nbsp; if(!redField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,1,scale);
&nbsp;&nbsp;&nbsp; }//end if on redField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!greenField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; greenField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,2,scale);
&nbsp;&nbsp;&nbsp; }//end if on greenField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!blueField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blueField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,3,scale);
&nbsp;&nbsp;&nbsp; }//end if on blueField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return a reference to the array containing the image,
&nbsp;&nbsp;&nbsp; // which has undergone both convolution filtering and
&nbsp;&nbsp;&nbsp; // color filtering.
&nbsp;&nbsp;&nbsp; return output;

&nbsp; }//end processImg method
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp;
&nbsp; //The purpose of this method is to scale every color
&nbsp; // value in a specified color plane in the int version
&nbsp; // of an image pixel array by a specified scale factor.
&nbsp; // The scaled values are clipped at 255 and 0.
&nbsp; static void scaleColorPlane(int[][][] inputImageArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int plane,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Scale each color value
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double result =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] * scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(result &gt; 255){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 255;//clip large numbers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(result &lt; 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 0;//clip negative numbers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Cast the result to int and put back into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // color plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] = (int)result;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end scaleColorPlane
&nbsp; //-----------------------------------------------------//
&nbsp; /*
&nbsp; The purpose of this method is to read the contents of a
&nbsp;&nbsp; text file and to use those contents to create a 2D
&nbsp;&nbsp;&nbsp; convolution filter by populating a 2D array with the
&nbsp;&nbsp;&nbsp; contents of the text file.

&nbsp; The text file consists of a series of lines with each
&nbsp;&nbsp; line containing a single string of characters.
&nbsp;
&nbsp; Whitespace is allowed before and after the strings on a
&nbsp;&nbsp; line.
&nbsp;
&nbsp; Lines containing empty strings are ignored.
&nbsp;
&nbsp; The file is allowed to contain comments, which must begin
&nbsp; with //
&nbsp;
&nbsp; Comments are displayed on the standard output device.
&nbsp;
&nbsp; Comments in the text file are ignored and do not factor
&nbsp;&nbsp; into the programming comments that follow.
&nbsp;
&nbsp; The first two strings must be convertible to type int and
&nbsp;&nbsp; every other string must be convertible to type double.
&nbsp;
&nbsp; The first string specifies the number of rows in the 2D
&nbsp; filter as type int.
&nbsp;
&nbsp; The second string specifies the number of columns in the
&nbsp; 2D filter as type int.
&nbsp;
&nbsp; The remaining strings specify the filter coefficients as
&nbsp; type double in row-column order.

&nbsp; The total number of strings must be (2 + rows*cols).
&nbsp; Otherwise, the program will throw an exception and abort.

&nbsp; Here are the results for a test file named Filter01.txt.
&nbsp; The file contents are shown below. Note that the comment
&nbsp; indicators are comment indicators in the file and are
&nbsp; not comment indicators in this program.

&nbsp; //File Filter01.txt
&nbsp; //This is a test file, and this is a comment.
&nbsp; //This is a high-pass filter in the wave-number domain.
&nbsp; 3
&nbsp; 3

&nbsp; -1
&nbsp; -1
&nbsp; -1

&nbsp; -1
&nbsp;&nbsp; 8
&nbsp; -1

&nbsp; -1
&nbsp; //This is another comment put here for test purposes.
&nbsp; //There is whitespace following the next item.
&nbsp; -1
&nbsp; -1

&nbsp; The text output produced by the method for this input
&nbsp; file is shown below.

&nbsp; //File Filter01.txt
&nbsp; //This is a test file, and this is a comment.
&nbsp; //This is a high-pass filter in the wave-number domain.
&nbsp; //This is another comment put here for test purposes.
&nbsp; //There is whitespace following the next item.
&nbsp; -1.0 -1.0 -1.0
&nbsp; -1.0 8.0 -1.0
&nbsp; -1.0 -1.0 -1.0
&nbsp; */
&nbsp; double[][] getFilter(String fileName){
&nbsp;&nbsp;&nbsp; double[][] filter = new double[0][0];
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(fileName));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cols = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((data = inData.readLine()) != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(data.startsWith("//")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display and ignore comments.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{//Not a comment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!data.equals("")){//ignore empty strings
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(count == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get row dimension value. Trim whitespace in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = Integer.parseInt(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else if(count == 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get column dimension value. Trim whitespace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = Integer.parseInt(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create a new array object to be populated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with the remaining contents of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Populate the filter array with the contents
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file. Trim whitespace in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row = (count-3)/cols;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col = (count-3)%cols;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double.parseDouble(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on empty strings
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else, not a comment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while data != null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();//Close the input stream.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the filter coefficient values in a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rectangular array format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int outCnt = 0;outCnt &lt; rows;outCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int inCnt = 0;inCnt &lt; cols;inCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(filter[outCnt][inCnt] + " ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println();//new line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; return filter;//Return the filter.
&nbsp; }//end getFilter
&nbsp; //-----------------------------------------------------//
}//end class ImgMod33<br><br><b><font face="Courier New,Courier">Listing 31</font></b></pre></td></tr></tbody></table><p></p>
	<p><a name="Listing_32">Listing 32</a></p><table border="1" cols="1" width="482" bgcolor="#ffff00">
		<tbody>
			<tr>
				<td>
				<pre>/*File ImgMod33a.java
Copyright 2005, R.G.Baldwin

This class is identical to ImgMod33 except that it calls
ImgMod32a instead of ImgMod32.

This class provides a general purpose 2D image convolution
and color filtering capability in Java. The class is
designed to be driven by the class named ImgMod02a.&nbsp;

The image file is specified on the command line. The name
of a file containing the 2D convolution filter is provided
via a TextField after the program starts running.
Multiplicative factors, which are applied to the individual
color planes are also provided through three TextFields
after the program starts running.

Enter the following at the command line to run this
program:

java ImgMod02a ImgMod33a ImageFileName

where ImageFileName is the name of a .gif or .jpg file,
including the extension.

Then enter the name of a file containing a 2D convolution
filter in the TextField that appears on the screen.&nbsp; Click
the Replot button on the Frame that displays the image
to cause the convolution filter to be applied to the image.
You can modify the multiplicative factors in the three
TextFields labeled Red, Green, and Blue before clicking the
Replot button to cause the color values to be scaled by
the respective multiplicative factors.&nbsp; The default
multiplicative factor for each color plane is 1.0.

When you click the Replot button, the image in the top of
the Frame will be convolved with the filter, the color
values in the color planes will be scaled by the
multiplicative factors, and the filtered image will appear
in the bottom of the Frame.

Each time you click the Replot button, two additional
graphs are produced that show the following information
in a color contour map fomat:
1.&nbsp; The convolution filter.
2.&nbsp; The wave number response of the convolution filter.

Because the GUI that contains the TextField for entry of
the convolution filter file name also contains three
additional TextFields that allow for the entry of
multiplicative factors that are applied to the three color
planes, it is possible to implement color filtering in
addition to convolution filtering.&nbsp; To apply color
filtering, enter new multiplicative scale factors into
the TextFields for Red, Green, and Blue and click the
Replot button.

Once the program is running, different convolution filters
and different color filters can be successively applied to
the same image, either separately or in combination, by
entering the name of each new filter file into the
TextField and/or entering new color multiplicative factors
into the respective color TextFields and then clicking the
Replot button

See comments at the beginning of the method named getFilter
for a description and an example of the required format for
the file containing the 2D convolution filter.

This program requires access to the following class files
plus some inner classes that are defined inside the
following classes:

ImgIntfc02.class
ImgMod02a.class
ImgMod29.class
ImgMod30.class
ImgMod32a.class
ImgMod33a.class

Tested using J2SE 5.0 and WinXP
**********************************************************/
import java.awt.*;
import java.io.*;

class ImgMod33a extends Frame implements ImgIntfc02{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; TextField fileNameField = new TextField("");
&nbsp; Panel rgbPanel = new Panel();
&nbsp; TextField redField = new TextField("1.0");
&nbsp; TextField greenField = new TextField("1.0");
&nbsp; TextField blueField = new TextField("1.0");
&nbsp; Label instructions = new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter Filter File Name and scale factors for " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Red, Green, and Blue and click Replot");
&nbsp; //-----------------------------------------------------//

&nbsp; ImgMod33a(){//constructor
&nbsp;&nbsp;&nbsp; setLayout(new GridLayout(4,1));
&nbsp;&nbsp;&nbsp; add(new Label("Filter File Name"));
&nbsp;&nbsp;&nbsp; add(fileNameField);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Populate the rgbPanel
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Red"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(redField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Green"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(greenField);
&nbsp;&nbsp;&nbsp; rgbPanel.add(new Label("Blue"));
&nbsp;&nbsp;&nbsp; rgbPanel.add(blueField);

&nbsp;&nbsp;&nbsp; add(rgbPanel);
&nbsp;&nbsp;&nbsp; add(instructions);
&nbsp;&nbsp;&nbsp; setTitle("Copyright 2005, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setBounds(400,0,460,125);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//

&nbsp; //This method is required by ImgIntfc02.&nbsp; It is called at
&nbsp; // the beginning of the run and each time thereafter that
&nbsp; // the user clicks the Replot button on the Frame
&nbsp; // containing the images.
&nbsp; //The method gets a 2D convolution filter from a text
&nbsp; // file, applies it to the incoming 3D array of pixel
&nbsp; // data and returns a filtered 3D array of pixel data.&nbsp;
&nbsp; public int[][][] processImg(int[][][] threeDPix,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgRows,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgCols){

&nbsp;&nbsp;&nbsp; //Create an empty output array of the same size as the
&nbsp;&nbsp;&nbsp; // incoming array.
&nbsp;&nbsp;&nbsp; int[][][] output = new int[imgRows][imgCols][4];

&nbsp;&nbsp;&nbsp; //Make a working copy of the 3D pixel array to avoid
&nbsp;&nbsp;&nbsp; // making permanent changes to the original image data.
&nbsp;&nbsp;&nbsp; int[][][] working3D = new int[imgRows][imgCols][4];
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; imgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; imgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][1] = threeDPix[row][col][1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][2] = threeDPix[row][col][2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working3D[row][col][3] = threeDPix[row][col][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Copy alpha values directly to the output. They
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not processed when the image is filtered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by the convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col][0] = threeDPix[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop

&nbsp;&nbsp;&nbsp; //Get the file name containing the filter from the
&nbsp;&nbsp;&nbsp; // textfield.
&nbsp;&nbsp;&nbsp; String fileName = fileNameField.getText();
&nbsp;&nbsp;&nbsp; if(fileName.equals("")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The file name is an empty string. Skip the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution process and pass the input image
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // directly to the output.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = working3D;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a 2D array that is populated with the contents
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file containing the 2D filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filter = getFilter(fileName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Plot the impulse response and the wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // response of the convolution filter.&nbsp; These items
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are not computed and plotted when the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // starts running.&nbsp; Rather, they are computed and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plotted each time the user clicks the Replot
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // button after entering the name of a file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // containing a convolution filter into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TextField.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Begin by placing the impulse response in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // center of a large flat surface with an elevation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of zero.This is done to improve the resolution of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the Fourier Transform, which will be computed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // later.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterRows = filter.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numFilterCols = filter[0].length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cols = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the size of the surface ten pixels larger than
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the convolution filter with a minimum size of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32x32 pixels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterRows &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = numFilterRows + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(numFilterCols &lt; 22){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = 32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = numFilterCols + 10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create the surface, which will be initialized to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all zero values.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] filterSurface = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Place the convolution filter in the center of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // surface.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numFilterRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numFilterCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filterSurface[row + (rows - numFilterRows)/2]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [col + (cols - numFilterCols)/2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the filter and the surface on which it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resides as a 3D plot in a color contour format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(filterSurface,4,true,1);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the 2D Fourier Transform of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // convolution filter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Prepare arrays to receive the results of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] real = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imag = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] amp = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Perform the 2D Fourier transform.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(filterSurface,real,imag,amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Ignore the real and imaginary results.&nbsp; Prepare the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude spectrum for more-effective plotting by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shifting the origin to the center in wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and display the minimum and maximum wave number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values.&nbsp; This is useful because the way that the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave number plots are normalized. it is not
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to infer the flatness or lack thereof of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the wave number surface simply by viewing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plot.&nbsp; The colors that describe the elevations
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // always range from black at the minimum to white at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the maximum, with different colors in between
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // regardless of the difference between the minimum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and the maximum.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double maxValue = -Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double minValue = Double.MAX_VALUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; rows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; cols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &gt; maxValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(amp[row][col] &lt; minValue){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minValue = amp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("minValue: " + minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("maxValue: " + maxValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ratio: " + maxValue/minValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Generate and display the wave-number response
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // graph by plotting the 3D surface on the computer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // screen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Perform the convolution.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = ImgMod32a.convolve(working3D,filter);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Scale output color planes.&nbsp; Color planes will be
&nbsp;&nbsp;&nbsp; // scaled only if the corresponding scale factor in the
&nbsp;&nbsp;&nbsp; // TextField has a value other than 1.0.&nbsp; Otherwise,
&nbsp;&nbsp;&nbsp; // there is no point in consuming computer time to do
&nbsp;&nbsp;&nbsp; // the scaling.
&nbsp;&nbsp;&nbsp; if(!redField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,1,scale);
&nbsp;&nbsp;&nbsp; }//end if on redField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!greenField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; greenField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,2,scale);
&nbsp;&nbsp;&nbsp; }//end if on greenField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(!blueField.getText().equals(1.0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blueField.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaleColorPlane(output,3,scale);
&nbsp;&nbsp;&nbsp; }//end if on blueField
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return a reference to the array containing the image,
&nbsp;&nbsp;&nbsp; // which has undergone both convolution filtering and
&nbsp;&nbsp;&nbsp; // color filtering.
&nbsp;&nbsp;&nbsp; return output;

&nbsp; }//end processImg method
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp;
&nbsp; //The purpose of this method is to scale every color
&nbsp; // value in a specified color plane in the int version
&nbsp; // of an image pixel array by a specified scale factor.
&nbsp; // The scaled values are clipped at 255 and 0.
&nbsp; static void scaleColorPlane(int[][][] inputImageArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int plane,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Scale each color value
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double result =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] * scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(result &gt; 255){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 255;//clip large numbers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(result &lt; 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = 0;//clip negative numbers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Cast the result to int and put back into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // color plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] = (int)result;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end scaleColorPlane
&nbsp; //-----------------------------------------------------//
&nbsp; /*
&nbsp; The purpose of this method is to read the contents of a
&nbsp;&nbsp; text file and to use those contents to create a 2D
&nbsp;&nbsp;&nbsp; convolution filter by populating a 2D array with the
&nbsp;&nbsp;&nbsp; contents of the text file.

&nbsp; The text file consists of a series of lines with each
&nbsp;&nbsp; line containing a single string of characters.
&nbsp;
&nbsp; Whitespace is allowed before and after the strings on a
&nbsp;&nbsp; line.
&nbsp;
&nbsp; Lines containing empty strings are ignored.
&nbsp;
&nbsp; The file is allowed to contain comments, which must begin
&nbsp; with //
&nbsp;
&nbsp; Comments are displayed on the standard output device.
&nbsp;
&nbsp; Comments in the text file are ignored and do not factor
&nbsp;&nbsp; into the programming comments that follow.
&nbsp;
&nbsp; The first two strings must be convertible to type int and
&nbsp;&nbsp; every other string must be convertible to type double.
&nbsp;
&nbsp; The first string specifies the number of rows in the 2D
&nbsp; filter as type int.
&nbsp;
&nbsp; The second string specifies the number of columns in the
&nbsp; 2D filter as type int.
&nbsp;
&nbsp; The remaining strings specify the filter coefficients as
&nbsp; type double in row-column order.

&nbsp; The total number of strings must be (2 + rows*cols).
&nbsp; Otherwise, the program will throw an exception and abort.

&nbsp; Here are the results for a test file named Filter01.txt.
&nbsp; The file contents are shown below. Note that the comment
&nbsp; indicators are comment indicators in the file and are
&nbsp; not comment indicators in this program.

&nbsp; //File Filter01.txt
&nbsp; //This is a test file, and this is a comment.
&nbsp; //This is a high-pass filter in the wave-number domain.
&nbsp; 3
&nbsp; 3

&nbsp; -1
&nbsp; -1
&nbsp; -1

&nbsp; -1
&nbsp;&nbsp; 8
&nbsp; -1

&nbsp; -1
&nbsp; //This is another comment put here for test purposes.
&nbsp; //There is whitespace following the next item.
&nbsp; -1
&nbsp; -1

&nbsp; The text output produced by the method for this input
&nbsp; file is shown below.

&nbsp; //File Filter01.txt
&nbsp; //This is a test file, and this is a comment.
&nbsp; //This is a high-pass filter in the wave-number domain.
&nbsp; //This is another comment put here for test purposes.
&nbsp; //There is whitespace following the next item.
&nbsp; -1.0 -1.0 -1.0
&nbsp; -1.0 8.0 -1.0
&nbsp; -1.0 -1.0 -1.0
&nbsp; */
&nbsp; double[][] getFilter(String fileName){
&nbsp;&nbsp;&nbsp; double[][] filter = new double[0][0];
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(fileName));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cols = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((data = inData.readLine()) != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(data.startsWith("//")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display and ignore comments.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{//Not a comment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!data.equals("")){//ignore empty strings
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(count == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get row dimension value. Trim whitespace in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = Integer.parseInt(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else if(count == 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get column dimension value. Trim whitespace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = Integer.parseInt(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create a new array object to be populated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with the remaining contents of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter = new double[rows][cols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Populate the filter array with the contents
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file. Trim whitespace in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row = (count-3)/cols;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col = (count-3)%cols;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double.parseDouble(data.trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on empty strings
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else, not a comment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while data != null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();//Close the input stream.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the filter coefficient values in a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rectangular array format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int outCnt = 0;outCnt &lt; rows;outCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int inCnt = 0;inCnt &lt; cols;inCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(filter[outCnt][inCnt] + " ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println();//new line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; return filter;//Return the filter.
&nbsp; }//end getFilter
&nbsp; //-----------------------------------------------------//
}//end class ImgMod33a<br><br><b><font face="Courier New,Courier">Listing 32</font></b></pre></td></tr></tbody></table><p></p>
	<p><a name="Listing_33">Listing 33</a></p><table border="1" cols="1" width="482" bgcolor="#ffff00">
		<tbody>
			<tr>
				<td>
				<pre>/*File ImgMod32a.java
Copyright 2005, R.G.Baldwin

This class is similar to ImgMod32 except that it uses a
different normalization scheme when converting convolution
results back to eight-bit unsigned values.&nbsp; The
normalization scheme causes the mean and the RMS of the
output to match the mean and the RMS of the input.&nbsp; Then it
sets negative values to 0 and sets values greater than 255
to 255.

This class provides a general purpose 2D image convolution
capability in the form of a static method named convolve.

The convolve method that is defined in this class receives
an incoming 3D array of image pixel data of type int
containing four planes. The format of this image data is
consistent with the format for image data used in the
program named ImgMod02a.

The planes are identified as follows:
0 - alpha or transparency data
1 - red color data
2 - green color data
3 - blue color data

The convolve method also receives an incoming 2D array of
type double containing the weights that make up a 2D
convolution filter.

The pixel values on each color plane are convolved
separately with the same convolution filter.&nbsp;

The results are normalized so as to cause the filtered
output to fall within the range from 0 to 255.

The values on the alpha plane are not modified.

The method returns a filtered 3D pixel array in the same
format as the incoming pixel array.&nbsp; The returned array
contains filtered values for each of the three color
planes.

The method does not modify the contents of the incoming
array of pixel data.

An unfiltered dead zone equal to half the filter length is
left around the perimeter of the filtered image to avoid
any attempt to perform convolution using data outside the
bounds of the image.

Although this class is intended to be used to implement 2D
convolution in other programs, a main method is provided so
that the class can be tested in a stand-alone mode.&nbsp; In
addition, the main method ilustrates the relationship
between convolution in the image domain and the
wave-number spectrum of the raw and filtered image.

When run as a stand-alone program, this class displays raw
surfaces, filtered surfaces, and the Fourier Transform of
both raw and filtered surfaces.&nbsp; See the details in the
comments in the main method.&nbsp; The program also displays
some text on the command-line screen.

Execution of the main method in this class requires access
to the following classes, plus some inner classed defined
within these classes:

ImgMod29.class - Displays 3D surfaces
ImgMod30.class - Provides 2D Fourier Transform
ImgMod32a.class - This class

Tested using J2SE 5.0 and WinXP
**********************************************************/

class ImgMod32a{
&nbsp; //The primary purpose of this main method is to test the
&nbsp; // class in a stand-alone mode.&nbsp; A secondary purpose is
&nbsp; // to illustrate the relationship between convolution
&nbsp; // filtering in the image domain and the spectrum of the
&nbsp; // raw and filtered images in the wave-number domain.
&nbsp;
&nbsp; //The code in this method creates a nine-point
&nbsp; // convolution filter and applies it to three&nbsp; different
&nbsp; // surfaces.&nbsp; The convolution filter has a dc response of
&nbsp; // zero with a high response at the folding wave numbers.
&nbsp; // Hence, it tends to have the characteristic of a
&nbsp; // sharpening or edge-detection filter.&nbsp;

&nbsp; //The three surfaces consist of:
&nbsp; // 1. A single impulse
&nbsp; // 2. A 3x3 square
&nbsp; // 3. A 5x5 square
&nbsp;
&nbsp; //The three surfaces are constructed on what ordinarily
&nbsp; // is considered to be the color planes in an image.
&nbsp; // However, in this case, the surfaces have nothing in
&nbsp; // particular to do with color.&nbsp; They simply&nbsp; represent
&nbsp; // three surfaces on which it is convenient to
&nbsp; // synthetically construct 3D shapes that are useful for
&nbsp; // testing and illustrating the image convolution
&nbsp; // concepts.&nbsp; But, in order to be consistent with the
&nbsp; // concept of color planes, the comments in the main
&nbsp; // method frequently refer to the values as color values.
&nbsp;
&nbsp; //In addition to the display of some text material on the
&nbsp; // command-line screen, the program displays twelve
&nbsp; // different graphs.&nbsp; They are described as follows:
&nbsp;
&nbsp; //The following surfaces are displayed:
&nbsp; // 1. The impulse
&nbsp; // 2. The raw 3x3 square
&nbsp; // 3. The raw 5x5 square
&nbsp; // 4. The filtered impulse
&nbsp; // 5. The filtered 3x3 square
&nbsp; // 6. The filtered 5x5 square
&nbsp;
&nbsp; // In addition, a 2D Fourier Transform is computed and
&nbsp; // the results are displayed for the following surfaces:
&nbsp; // 1. The impulse
&nbsp; // 2. The 3x3 square input
&nbsp; // 3. The 5x5 square input
&nbsp; // 4. The filtered impulse
&nbsp; // 5. The filtered 3x3 square
&nbsp; // 6. The filtered 5x5 square
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a 2D convolution filter having nine weights in
&nbsp;&nbsp;&nbsp; // a square.
&nbsp;&nbsp;&nbsp; double[][] filter = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {-1,-1,-1},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {-1, 8,-1},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {-1,-1,-1}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; //Create synthetic image pixel data.&nbsp; Use a surface
&nbsp;&nbsp;&nbsp; // that is sufficiently large to produce good
&nbsp;&nbsp;&nbsp; // resolution in the 2D Fourier Transform.&nbsp; Zero-fill
&nbsp;&nbsp;&nbsp; // those portions of the surface that don't describe
&nbsp;&nbsp;&nbsp; // the shapes of interest.
&nbsp;&nbsp;&nbsp; int rowLim = 31;
&nbsp;&nbsp;&nbsp; int colLim = 31;
&nbsp;&nbsp;&nbsp; int[][][] threeDPix = new int[rowLim][colLim][4];

&nbsp;&nbsp;&nbsp; //Place a single impulse in the red plane 1
&nbsp;&nbsp;&nbsp; threeDPix[3][3][1] = 255;
&nbsp;
&nbsp;&nbsp;&nbsp; //Place a 3x3 square in the green plane 2
&nbsp;&nbsp;&nbsp; threeDPix[2][2][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][3][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][4][2] = 255;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[3][2][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][3][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][4][2] = 255;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[4][2][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][3][2] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][4][2] = 255;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Place a 5x5 square in the blue plane 3
&nbsp;&nbsp;&nbsp; threeDPix[2][2][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][3][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][4][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][5][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[2][6][3] = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[3][2][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][3][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][4][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][5][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[3][6][3] = 255;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[4][2][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][3][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][4][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][5][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[4][6][3] = 255;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[5][2][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[5][3][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[5][4][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[5][5][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[5][6][3] = 255;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; threeDPix[6][2][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[6][3][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[6][4][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[6][5][3] = 255;
&nbsp;&nbsp;&nbsp; threeDPix[6][6][3] = 255;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Perform the convolution.
&nbsp;&nbsp;&nbsp; int[][][] output = convolve(threeDPix,filter);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //All of the remaining code in the main method is used
&nbsp;&nbsp;&nbsp; // to display material that is used to test and to
&nbsp;&nbsp;&nbsp; // illustrate the convolution process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Remove the mean values from the filtered color planes
&nbsp;&nbsp;&nbsp; // before plotting and computing spectra.

&nbsp;&nbsp;&nbsp; //First convert the color values from int to double.
&nbsp;&nbsp;&nbsp; double[][][] outputDouble = intToDouble(output);
&nbsp;&nbsp;&nbsp; //Now remove the mean color value from each plane.
&nbsp;&nbsp;&nbsp; removeMean(outputDouble,1);
&nbsp;&nbsp;&nbsp; removeMean(outputDouble,2);
&nbsp;&nbsp;&nbsp; removeMean(outputDouble,3);

&nbsp;&nbsp;&nbsp; //Convert the raw image data from int to double
&nbsp;&nbsp;&nbsp; double[][][] rawDouble = intToDouble(threeDPix);

&nbsp;&nbsp;&nbsp; //Get and plot the raw red plane 1.&nbsp; This is an input
&nbsp;&nbsp;&nbsp; // to the filter process.
&nbsp;&nbsp;&nbsp; //Get the plane of interest.
&nbsp;&nbsp;&nbsp; double[][] temp = getPlane(rawDouble,1);
&nbsp;&nbsp;&nbsp; //Generate and display the graph by plotting the 3D
&nbsp;&nbsp;&nbsp; // surface on the computer screen.
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);

&nbsp;&nbsp;&nbsp; //Get and display the 2D Fourier Transform of plane 1.
&nbsp;&nbsp;&nbsp; //Get the plane of interest.
&nbsp;&nbsp;&nbsp; temp = getPlane(rawDouble,1);
&nbsp;&nbsp;&nbsp; //Prepare arrays to receive the results of the Fourier
&nbsp;&nbsp;&nbsp; // transform.
&nbsp;&nbsp;&nbsp; double[][] real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; double[][] imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; double[][] amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; //Perform the 2D Fourier transform.
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; //Ignore the real and imaginary results.&nbsp; Prepare the
&nbsp;&nbsp;&nbsp; // amplitude spectrum for more-effective plotting by
&nbsp;&nbsp;&nbsp; // shifting the origin to the center in wave-number
&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; //Generate and display the graph by plotting the 3D
&nbsp;&nbsp;&nbsp; // surface on the computer screen.
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);
&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Get and plot the filtered plane 1.&nbsp; This is the
&nbsp;&nbsp;&nbsp; // impulse response of the convolution filter.
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,1);
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and display the transform of filtered plane 1.
&nbsp;&nbsp;&nbsp; // This is the transform of the impulse response of
&nbsp;&nbsp;&nbsp; // the convolution filter.
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,1);
&nbsp;&nbsp;&nbsp; real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; shiftedAmplitudeSpect = ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);


&nbsp;&nbsp;&nbsp; //Get and plot the raw green plane 2.&nbsp; This is another
&nbsp;&nbsp;&nbsp; // input to the filter process.
&nbsp;&nbsp;&nbsp; temp = getPlane(rawDouble,2);
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);

&nbsp;&nbsp;&nbsp; //Get and display the transform of plane 2.
&nbsp;&nbsp;&nbsp; temp = getPlane(rawDouble,2);
&nbsp;&nbsp;&nbsp; real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; shiftedAmplitudeSpect = ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and plot the filtered plane 2.
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,2);
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and display the transform of filtered plane 2.
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,2);
&nbsp;&nbsp;&nbsp; real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; shiftedAmplitudeSpect = ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);


&nbsp;&nbsp;&nbsp; //Get and plot the raw blue plane 3.&nbsp; This is another
&nbsp;&nbsp;&nbsp; // input to the filter process.
&nbsp;&nbsp;&nbsp; temp = getPlane(rawDouble,3);
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);

&nbsp;&nbsp;&nbsp; //Get and display the transform of plane 3.
&nbsp;&nbsp;&nbsp; temp = getPlane(rawDouble,3);
&nbsp;&nbsp;&nbsp; real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; shiftedAmplitudeSpect = ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);
&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Get and plot the filtered plane 3.
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,3);
&nbsp;&nbsp;&nbsp; new ImgMod29(temp,4,true,1);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and display the transform of filtered plane 3
&nbsp;&nbsp;&nbsp; temp = getPlane(outputDouble,3);
&nbsp;&nbsp;&nbsp; real = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; imag = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; amp = new double[rowLim][colLim];
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(temp,real,imag,amp);
&nbsp;&nbsp;&nbsp; shiftedAmplitudeSpect = ImgMod30.shiftOrigin(amp);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,4,true,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end main
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to extract a color plane
&nbsp; // from the double version of an image and to return it
&nbsp; // as a 2D array of type double.&nbsp; This is useful, for
&nbsp; // example, for performing Fourier transforms on the data
&nbsp; // in a color plane.
&nbsp; //This method is used only in support of the operations
&nbsp; // in the main method.&nbsp; It is not required for performing
&nbsp; // the convolution.
&nbsp;
&nbsp; public static double[][] getPlane(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] threeDPixDouble,int plane){
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int numImgRows = threeDPixDouble.length;
&nbsp;&nbsp;&nbsp; int numImgCols = threeDPixDouble[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create an empty output array of the same
&nbsp;&nbsp;&nbsp; // size as a single plane in the the incoming array of
&nbsp;&nbsp;&nbsp; // pixels.
&nbsp;&nbsp;&nbsp; double[][] output =new double[numImgRows][numImgCols];

&nbsp;&nbsp;&nbsp; //Copy the values from the specified plane to the
&nbsp;&nbsp;&nbsp; // double array converting them to type double in the
&nbsp;&nbsp;&nbsp; // process.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threeDPixDouble[row][col][plane];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end loop on col
&nbsp;&nbsp;&nbsp; }//end loop on row
&nbsp;&nbsp;&nbsp; return output;
&nbsp; }//end getPlane
&nbsp; //-----------------------------------------------------//

&nbsp; //The purpose of this method is to get and remove the
&nbsp; // mean value from a specified color plane in the double
&nbsp; // version of an image pixel array.&nbsp; The method returns
&nbsp; // the mean value that was removed so that it can be
&nbsp; // saved by the calling method and restored later.
&nbsp; static double removeMean(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray,int plane){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Compute the mean color value
&nbsp;&nbsp;&nbsp; double sum = 0;
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += inputImageArray[row][col][plane];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double mean = sum/(numImgRows*numImgCols);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Remove the mean value from each pixel value.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] -= mean;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp; return mean;
&nbsp; }//end removeMean
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to get and return the
&nbsp; // mean value from a specified color plane in the double
&nbsp; // version of an image pixel array.
&nbsp; static double getMean(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray,int plane){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Compute the mean color value
&nbsp;&nbsp;&nbsp; double sum = 0;
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += inputImageArray[row][col][plane];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double mean = sum/(numImgRows*numImgCols);
&nbsp;&nbsp;&nbsp; return mean;
&nbsp; }//end getMean
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to add a constant to
&nbsp; // every color value in a specified color plane in the
&nbsp; // double version of an image pixel array.&nbsp; For example,
&nbsp; // this method can be used to restore the mean value to a
&nbsp; // color plane that was removed earlier.
&nbsp; static void addConstantToColor(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int plane,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double constant){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Add the constant value to each color value
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] + constant;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end addConstantToColor
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to scale every color
&nbsp; // value in a specified color plane in the double version
&nbsp; // of an image pixel array by a specified scale factor.
&nbsp; static void scaleColorPlane(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray,int plane,double scale){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Scale each color value
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] * scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end scaleColorPlane
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to convert an image pixel
&nbsp; // array (where the pixel values are represented as type
&nbsp; // int) to an image pixel array where the pixel values
&nbsp; // are reprented as type double.
&nbsp; static double[][][] intToDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[][][] inputImageArray){
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][][] outputImageArray =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[numImgRows][numImgCols][4];
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][0] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][1] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][3] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp; return outputImageArray;
&nbsp; }//end intToDouble
&nbsp; //-----------------------------------------------------//

&nbsp; //The purpose of this method is to convert an image pixel
&nbsp; // array (where the pixel values are represented as type
&nbsp; // double) to an image pixel array where the pixel values
&nbsp; // are reprented as type int.
&nbsp; static int[][][] doubleToInt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray){
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int[][][] outputImageArray =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new int[numImgRows][numImgCols][4];
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][0] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)inputImageArray[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][1] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)inputImageArray[row][col][1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)inputImageArray[row][col][2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputImageArray[row][col][3] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)inputImageArray[row][col][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp; return outputImageArray;
&nbsp; }//end doubleToInt
&nbsp; //-----------------------------------------------------//

&nbsp; //The purpose of this method is to clip all negative
&nbsp; // color values in a plane to a value of 0.
&nbsp; static void clipToZero(double[][][] inputImageArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int plane){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Do the clip
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(inputImageArray[row][col][plane] &lt; 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end clipToZero
&nbsp; //-----------------------------------------------------//
&nbsp; //The purpose of this method is to clip all color values
&nbsp; // in a plane that are greater than 255 to a value
&nbsp; // of 255.
&nbsp; static void clipTo255(double[][][] inputImageArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int plane){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp; //Do the clip
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(inputImageArray[row][col][plane] &gt; 255){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane] = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end clipTo255
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //The purpose of this method is to get and return the
&nbsp; // RMS value from a specified color plane in the double
&nbsp; // version of an image pixel array.
&nbsp; static double getRms(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][][] inputImageArray,int plane){
&nbsp;&nbsp;&nbsp; int numImgRows = inputImageArray.length;
&nbsp;&nbsp;&nbsp; int numImgCols = inputImageArray[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Compute the RMS color value
&nbsp;&nbsp;&nbsp; double sumSq = 0;
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumSq += (inputImageArray[row][col][plane]*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImageArray[row][col][plane]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double mean = sumSq/(numImgRows*numImgCols);
&nbsp;&nbsp;&nbsp; double rms = Math.sqrt(mean);
&nbsp;&nbsp;&nbsp; return rms;
&nbsp; }//end getRms
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //This method applies an incoming 2D convolution filter
&nbsp; // to each color plane in an incoming 3D array of pixel
&nbsp; // data and returns a filtered 3D array of pixel data.
&nbsp; //The convolution filter is applied separately to each
&nbsp; // color plane.
&nbsp; //The alpha plane is not modified.
&nbsp; //The output is normalized so as to guarantee that the
&nbsp; // output color values fall within the range from 0
&nbsp; // to 255.&nbsp; This is accomplished by causing the mean and
&nbsp; // the RMS of the color values in each output color plane
&nbsp; // to match the mean and the RMS of the color values in
&nbsp; // the corresponding input color plane.&nbsp; Then, all
&nbsp; // negative color values are set to a value of 0 and all
&nbsp; // color values greater than 255 are set to 255.
&nbsp; //The convolution filter is passed to the method as a 2D
&nbsp; // array of type double.&nbsp; All convolution and
&nbsp; // normalization arithmetic is performed as type double.
&nbsp; //The normalized results are converted to type int before
&nbsp; // returning them to the calling method.
&nbsp; //This method does not modify the contents of the
&nbsp; // incoming array of pixel data.
&nbsp; //An unfiltered dead zone equal to half the filter length
&nbsp; // is left around the perimeter of the filtered image to
&nbsp; // avoid any attempt to perform convolution using data
&nbsp; // outside the bounds of the image.
&nbsp; public static int[][][] convolve(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[][][] threeDPix,double[][] filter){
&nbsp;&nbsp;&nbsp; //Get the dimensions of the image and filter arrays.
&nbsp;&nbsp;&nbsp; int numImgRows = threeDPix.length;
&nbsp;&nbsp;&nbsp; int numImgCols = threeDPix[0].length;
&nbsp;&nbsp;&nbsp; int numFilRows = filter.length;
&nbsp;&nbsp;&nbsp; int numFilCols = filter[0].length;

&nbsp;&nbsp;&nbsp; //Display the dimensions of the image and filter
&nbsp;&nbsp;&nbsp; // arrays.
&nbsp;&nbsp;&nbsp; System.out.println("numImgRows = " + numImgRows);
&nbsp;&nbsp;&nbsp; System.out.println("numImgCols = " + numImgCols);
&nbsp;&nbsp;&nbsp; System.out.println("numFilRows = " + numFilRows);
&nbsp;&nbsp;&nbsp; System.out.println("numFilCols = " + numFilCols);

&nbsp;&nbsp;&nbsp; //Make a working copy of the incoming 3D pixel array to
&nbsp;&nbsp;&nbsp; // avoid making permanent changes to the original image
&nbsp;&nbsp;&nbsp; // data. Convert the pixel data to type double in the
&nbsp;&nbsp;&nbsp; // process.&nbsp; Will convert back to type int when
&nbsp;&nbsp;&nbsp; // returning from this method.
&nbsp;&nbsp;&nbsp; double[][][] work3D = intToDouble(threeDPix);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the mean value for each color plane.
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Input red mean: " + getMean(work3D,1));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Input green mean: " + getMean(work3D,2));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Input blue mean: " + getMean(work3D,3));
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Remove the mean value from each color plane.&nbsp; Save
&nbsp;&nbsp;&nbsp; // the mean values for later restoration.
&nbsp;&nbsp;&nbsp; double redMean = removeMean(work3D,1);
&nbsp;&nbsp;&nbsp; double greenMean = removeMean(work3D,2);
&nbsp;&nbsp;&nbsp; double blueMean = removeMean(work3D,3);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and save the input RMS value for later
&nbsp;&nbsp;&nbsp; // restoration.
&nbsp;&nbsp;&nbsp; double inputRedRms = getRms(work3D,1);
&nbsp;&nbsp;&nbsp; double inputGreenRms = getRms(work3D,2);
&nbsp;&nbsp;&nbsp; double inputBlueRms = getRms(work3D,3);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the input RMS value
&nbsp;&nbsp;&nbsp; System.out.println("Input red RMS: " + inputRedRms);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Input green RMS: " + inputGreenRms);
&nbsp;&nbsp;&nbsp; System.out.println("Input blue RMS: " + inputBlueRms);

&nbsp;&nbsp;&nbsp; //Create an empty output array of the same size as the
&nbsp;&nbsp;&nbsp; // incoming array of pixels.
&nbsp;&nbsp;&nbsp; double[][][] output =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[numImgRows][numImgCols][4];
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Copy the alpha values directly to the output array.
&nbsp;&nbsp;&nbsp; // They will not be processed during the convolution
&nbsp;&nbsp;&nbsp; // process.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numImgRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numImgCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col][0] = work3D[row][col][0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop

//Because of the length of the following statements, and
// the width of this publication format, this format
// sacrifices indentation style for clarity. Otherwise,it
// would be necessary to break the statements into so many
// short lines that it would be very difficult to read
// them.

//Use nested for loops to perform a 2D convolution of each
// color plane with the 2D convolution filter.

for(int yReg = numFilRows-1;yReg &lt; numImgRows;yReg++){
&nbsp; for(int xReg = numFilCols-1;xReg &lt; numImgCols;xReg++){
&nbsp;&nbsp;&nbsp; for(int filRow = 0;filRow &lt; numFilRows;filRow++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int filCol = 0;filCol &lt; numFilCols;filCol++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][1] +=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work3D[yReg-filRow][xReg-filCol][1] *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[filRow][filCol];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][2] +=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work3D[yReg-filRow][xReg-filCol][2] *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[filRow][filCol];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][3] +=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work3D[yReg-filRow][xReg-filCol][3] *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filter[filRow][filCol];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//End loop on filCol
&nbsp;&nbsp;&nbsp; }//End loop on filRow

&nbsp;&nbsp;&nbsp; //Divide the result at each point in the output by the
&nbsp;&nbsp;&nbsp; // number of filter coefficients.&nbsp; Note that in some
&nbsp;&nbsp;&nbsp; // cases, this is not helpful.&nbsp; For example, it is not
&nbsp;&nbsp;&nbsp; // helpful when a large number of the filter
&nbsp;&nbsp;&nbsp; // coefficients have a value of zero.
&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][1] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][1]/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numFilRows*numFilCols);
&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][2] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][2]/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numFilRows*numFilCols);
&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][3] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[yReg-numFilRows/2][xReg-numFilCols/2][3]/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numFilRows*numFilCols);

&nbsp; }//End loop on xReg
}//End loop on yReg

&nbsp;&nbsp;&nbsp; //Return to the normal indentation style.

&nbsp;&nbsp;&nbsp; //Remove any mean value resulting from computational
&nbsp;&nbsp;&nbsp; // inaccuracies.&nbsp; Should be very small.
&nbsp;&nbsp;&nbsp; removeMean(output,1);
&nbsp;&nbsp;&nbsp; removeMean(output,2);
&nbsp;&nbsp;&nbsp; removeMean(output,3);

&nbsp;&nbsp;&nbsp; //Get and save the RMS value of the output for each
&nbsp;&nbsp;&nbsp; // color plane.
&nbsp;&nbsp;&nbsp; double outputRedRms = getRms(output,1);
&nbsp;&nbsp;&nbsp; double outputGreenRms = getRms(output,2);
&nbsp;&nbsp;&nbsp; double outputBlueRms = getRms(output,3);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Scale the output to cause the RMS value of the output
&nbsp;&nbsp;&nbsp; // to match the RMS value of the input
&nbsp;&nbsp;&nbsp; scaleColorPlane(output,1,inputRedRms/outputRedRms);
&nbsp;&nbsp;&nbsp; scaleColorPlane(output,2,inputGreenRms/outputGreenRms);
&nbsp;&nbsp;&nbsp; scaleColorPlane(output,3,inputBlueRms/outputBlueRms);

&nbsp;&nbsp;&nbsp; //Display the adjusted RMS values.&nbsp; Should match the
&nbsp;&nbsp;&nbsp; // input RMS values.
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output red RMS: " + getRms(output,1));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output green RMS: " + getRms(output,2));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output blue RMS: " + getRms(output,3));

&nbsp;&nbsp;&nbsp; //Restore the original mean value to each color plane.
&nbsp;&nbsp;&nbsp; addConstantToColor(output,1,redMean);
&nbsp;&nbsp;&nbsp; addConstantToColor(output,2,greenMean);
&nbsp;&nbsp;&nbsp; addConstantToColor(output,3,blueMean);

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output red mean: " + getMean(output,1));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output green mean: " + getMean(output,2));
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Output blue mean: " + getMean(output,3));
&nbsp;
&nbsp;&nbsp;&nbsp; //Guarantee that all color values fall within the range
&nbsp;&nbsp;&nbsp; // from 0 to 255.

&nbsp;&nbsp;&nbsp; //Clip all negative color values at zero and all color
&nbsp;&nbsp;&nbsp; // values that are greater than 255 at 255.
&nbsp;&nbsp;&nbsp; clipToZero(output,1);
&nbsp;&nbsp;&nbsp; clipToZero(output,2);
&nbsp;&nbsp;&nbsp; clipToZero(output,3);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; clipTo255(output,1);
&nbsp;&nbsp;&nbsp; clipTo255(output,2);
&nbsp;&nbsp;&nbsp; clipTo255(output,3);

&nbsp;&nbsp;&nbsp; //Return a reference to the array containing the
&nbsp;&nbsp;&nbsp; // filtered pixels.&nbsp; Convert the color
&nbsp;&nbsp;&nbsp; // values to type int before returning.
&nbsp;&nbsp;&nbsp; return doubleToInt(output);

&nbsp; }//end convolve method
&nbsp; //-----------------------------------------------------//
}//end class ImgMod32a<br><br><b><font face="Courier New,Courier">Listing 33</font></b></pre></td></tr></tbody></table><p></p>
	<p></p><p></p><p></p><p></p><p></p><hr size="3" width="100%" align="center"><p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p><h4><a name="About_the_author">About the author</a></h4><p><b><a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i> </p><p><i>Richard has participated in numerous consulting projects and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.dickbaldwin.com">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p><p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p><p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p><p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i> </p><p><b>Keywords</b><br>Java pixel convolution filter smooth blur image jpg gif color linear DSP 3D 
2D</p><p>-end- </p></body>
</html>