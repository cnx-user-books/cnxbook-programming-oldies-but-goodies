<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Reflection and the Method Class - I<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 260, Revised 02/11/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#reflection, summary of classes">Reflection, Summary of Classes</a></li>

<li><a href="#reflection, an overview">Reflection, An Overview</a></li>

<ul><li><a href="#member interface">Member Interface</a></li>

<li><a href="#field class">Field Class</a></li>

<li><a href="#method class">Method Class</a></li>

<li><a href="#constructor class">Constructor Class</a></li>

<li><a href="#other new capabilities">Other New Capabilities</a></li>

<li><a href="#the model for reflection">The Model for Reflection</a></li>

<li><a href="#the modifier class">The Modifier Class</a></li>

<li><a href="#security">Security</a></li>

<li><a href="#data conversion">Data Conversion</a></li>

<li><a href="#packaging">Packaging</a></li></ul>

<li><a href="#sample program">Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#program listing">Program Listing</a></li></ul></ul>

<hr width="100%"><center><h2><a name="preface"></a><font color="#ff0000">Preface</font></h2></center>
Students in Prof. Baldwin's <b><u>Advanced Java Programming</u></b> classes
at ACC are responsible for knowing and understanding all of the material
in this lesson.
<center><h2><a name="introduction"></a><b><font color="#ff0000">Introduction</font></b></h2></center>
This is the first in a series of planned lessons on <i>reflection.</i>

<p>One of the Java features introduced in JDK 1.1 is <i>reflection</i>.
According to the documentation for JDK 1.1:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"<i>(Reflection)</i> Enables Java code to discover information about
the <i>fields</i>, <i>methods </i>and <i>constructors </i>of loaded classes,
and to use reflected fields, methods, and constructors to operate on their
underlying counterparts on objects, within security restrictions. The API
accommodates applications that need access to either the public members
of a target object (based on its runtime class) or the members declared
by a given class."</td></tr></table><i>Reflection </i>has many potential uses, one of which is to support the
design of advanced forms of adapters for use in event processing. This
generally requires the ability to discover information about the <i>methods</i>
of loaded classes and to invoke methods as a result of that discovery process.

<p>During this course of study, I plan to introduce you to the use of <i>reflection</i>
for <i>fields</i>, <i>methods</i>, and <i>constructors</i>, but in the
beginning we will emphasize <i>methods</i>.

<p><u>Subsequent lessons</u> will discuss the <u>other aspects</u> of <i>reflection
</i>including the new capabilities for handling arrays.
<center><h2><a name="reflection, summary of classes"></a><font color="#ff0000">Reflection,
Summary of Classes</font></h2></center>
There are about <u>eight classes and interfaces</u> involved in <i>reflection</i>,
and each of those classes has <u>numerous methods</u> and in some cases
fields.

<p>The major classes and interfaces involved in <i>reflection </i>along
with their fields and methods are listed below.

<p>A quick review of this material will indicate that a large part of the
<u>difficulty</u> in using <i>reflection </i>is simply figuring out <u>which</u>
classes and methods to use for <u>what</u> purpose and <u>when</u> to use
them.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.Class&nbsp;</h4>

<ul><h4>
Methods&nbsp;</h4>

<ul><li>
toString, forName, newInstance, isInstance, isAssignableFrom, isInterface,
isArray, isPrimitive, getName, getModifiers, getClassLoader, getSuperclass,
getInterfaces, getComponentType, getDeclaringClass, getClasses, getFields,
getMethods, getConstructors, getField, getMethod, getConstructor, getDeclaredClasses,
getDeclaredFields, getDeclaredMethods, getDeclaredConstructors, getDeclaredField,
getDeclaredMethod, getDeclaredConstructor&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
interface java.lang.reflect.Member&nbsp;</h4>

<ul><h4>
Fields&nbsp;</h4></ul>

<ul><ul><li>
PUBLIC, DECLARED&nbsp;</li></ul>

<h4>
Methods&nbsp;</h4>

<ul><li>
getDeclaringClass, getName, getModifiers&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.Field&nbsp;</h4>

<ul><h4>
Methods&nbsp;</h4>

<ul><li>
getDeclaringClass, getName, getModifiers, getType, equals, hashCode, toString,
get, getBoolean, getByte, getChar, getShort, getInt, getLong, getFloat,
getDouble, set, setBoolean, setByte, setChar, setShort, setInt, setLong,
setFloat, setDouble&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.Method&nbsp;</h4>

<ul><h4>
Methods&nbsp;</h4>

<ul><li>
getDeclaringClass, getName, getModifiers, getReturnType, getParameterTypes,
getExceptionTypes, equals, hashCode, toString, invoke&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.Constructor&nbsp;</h4>

<ul><h4>
Methods&nbsp;</h4>

<ul><li>
getDeclaringClass, getName, getModifiers, getParameterTypes, getExceptionTypes,
equals, hashCode, toString, newInstance&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.Array&nbsp;</h4>

<ul><h4>
Methods&nbsp;</h4>

<ul><li>
newInstance, newInstance, getLength, get, getBoolean, getByte, getChar,
getShort, getInt, getLong, getFloat, getDouble, set, setBoolean, setByte,
setChar, setShort, setInt, setLong, setFloat, setDouble&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.Modifier&nbsp;</h4>

<ul><h4>
Fields&nbsp;</h4>

<ul><li>
PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, VOLATILE, TRANSIENT,
NATIVE, INTERFACE, ABSTRACT&nbsp;</li></ul>

<h4>
Methods&nbsp;</h4>

<ul><li>
isPublic, isPrivate, isProtected, isStatic, isFinal, isSynchronized, isVolatile,
isTransient, isNative, isInterface, isAbstract, toString&nbsp;</li></ul></ul></td></tr></table>
.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><h4>
class java.lang.reflect.InvocationTargetException&nbsp;</h4>

<ul><h4>
Constructors&nbsp;</h4>

<ul><li>
InvocationTargetException, InvocationTargetException&nbsp;</li></ul>

<h4>
Methods&nbsp;</h4>

<ul><li>
getTargetException&nbsp;</li></ul></ul></td></tr></table>
.
<center><h2><a name="reflection, an overview"></a><font color="#ff0000">Reflection,
An Overview</font></h2></center>
The <b>Core Reflection API</b> supports introspection on classes and objects
<u>currently in the Virtual Machine</u>.

<p>Depending on security policy, this API can be used to:
<ul><li>
construct <u>new</u> class instances and new arrays</li>

<li>
access and <u>modify</u> fields of objects and classes</li>

<li><u>invoke methods</u> on objects and classes</li>

<li>
access and <u>modify</u> elements of arrays</li></ul>
The Core Reflection API defines a new interface named <b>Member</b> and
five new classes including the following three:
<ul><li>
Field</li>

<li>
Method</li>

<li>
Constructor</li></ul>

<center><h3><a name="member interface"></a><font color="#ff0000">Member Interface</font></h3></center><font color="#000000">The <b>Member</b> interface is a member of the package
<i>java.lang.reflect</i>. It declares three important methods that are
<i>implemented</i> by several of the classes in the API.</font><ul><li><font color="#000000"><b>getDeclaringClass()</b> - Returns a <b>Class </b>object
representing the class or interface that declares a member or constructor.</font></li>

<li><font color="#000000"><b>getName()</b> - Returns the name of a member or
constructor, as a <b>String</b>.</font></li>

<li><font color="#000000"><b>getModifiers()</b> - Returns the Java language
modifiers (<i>public, final, abstract,</i> etc.) for this member or constructor,
encoded in an integer. The <b>Modifier </b>class provides methods that
can be used to decode the modifier values returned by this method.</font></li></ul><font color="#000000">.</font><center><h3><a name="field class"></a><font color="#ff0000">Field Class</font></h3></center>
The <b>Field</b> class is contained in the package <i>java.lang.reflect</i>.
It is a <i>public final</i> class that <i>extends</i> the <b>Object</b>
class and <i>implements</i> the <b>Member</b> interface. Because it implements
the <b>Member</b> interface, it defines the three methods listed above
(in addition to others that are not interface methods).

<p>An object of the <b>Field</b> class provides information about, and
access to a single field of a class or interface. This may be a class variable
or an instance variable.

<p><b>Field</b> objects can only be created by the Java Virtual Machine.

<p>The Java class named <b>Class</b> is not a new class. However, it was
upgraded significantly to support reflection. There are a variety of methods
in the <b>Class</b> class that will return a <b>Field</b> object.

<p>Note that a <b>Field</b> permits widening conversions to occur during
a <i>set</i> or <i>get</i> operation, but throws an <b>IllegalArgumentException</b>
if a narrowing conversion would occur.
<center><h3><a name="method class"></a><font color="#ff0000">Method Class</font></h3></center>
The <b>Method</b> class is a member of the package <i>java.lang.reflect</i>.
It is a <i>public final</i> class that <i>extends</i> the <b>Object</b>
class and <i>implements </i>the <b>Member</b> interface.

<p>An object of the <b>Method</b> class provides information about, as
well as access to a single method of a class or an interface. The reflected
method can be an <i>abstract</i> method, a class method, or an instance
method.

<p>Objects of the <b>Method</b> class can only be instantiated by the Java
Virtual Machine. There are several methods in the upgraded <b>Class</b>
class that return references to <b>Method</b> objects. As mentioned earlier,
our first investigation of the reflection API will emphasize the <b>Method</b>
class.

<p>As with a <b>Field</b>, a <b>Method</b> permits widening conversions
to occur when matching the actual parameters to invoke with the formal
parameters of the method being invoked. An <b>IllegalArgumentException</b>
will be thrown if a narrowing conversion would occur.
<center><h3><a name="constructor class"></a><font color="#ff0000">Constructor Class</font></h3></center>
The <b>Constructor</b> class is a member of the package <i>java.lang.reflect</i>.
It is a <i>public final</i> class that <i>extends</i> the <b>Object</b>
class and <i>implements </i>the <b>Member</b> interface.

<p>A <b>Constructor</b> object provides information about, and access to
a single constructor of a class. The object may be used to create and initialize
a new instance of the class that declares the reflected constructor (provided
that the class can be instantiated).

<p>The <b>newInstance()</b> method of the <b>Constructor</b> class is used
to instantiate new instances of the class (new objects). This version of
the <b>newInstance()</b> method is more powerful than its counterpart in
the <b>Class</b> class because this version is not confined to the use
of constructors without arguments.

<p>The <b>Constructor</b> class cannot be instantiated directly, but several
methods of the <b>Class</b> class can be used to obtain a reference to
a <b>Constructor</b> object.

<p>As with <b>Field</b> and <b>Method</b>, a <b>Constructor</b> permits
widening conversions to occur when matching the actual parameters to the
<b>newInstance()</b> method with the formal parameters of the underlying
constructor. An <b>IllegalArgumentException</b> will be thrown if a narrowing
conversion would occur.
<center><h3><a name="other new capabilities"></a><font color="#ff0000">Other New Capabilities</font></h3></center>
In addition to the three new classes and the interface described above,
the reflection API also provides:
<ul><li><u>New methods</u> of the class named <b>Class </b>which may be used used
for the construction of new instances of the <b>Field</b>, <b>Method</b>,
and <b>Constructor </b>classes listed above</li>

<li>
A <u>new class</u> named <b>Array </b>that provides methods to <u>dynamically</u>
construct and access Java arrays.</li>

<li>
Another <u>new class</u> named <b>Modifier </b>that helps <u>decode</u>
Java language modifier information about classes and their members.</li>

<li>
A new class named <b>InvocationTargetException</b> that wraps exceptions
thrown when an attempt is made to invoke a method or a constructor for
delivery to the code that attempted the invocation.</li></ul>
Generally speaking, the reflection methods deal only with objects. If you
need to deal with primitive types, you will need to wrap them in a standard
Java wrapper.

<p>There are also some <u>additions</u> to the <b>java.lang</b> package
that support reflection.
<ul><li>
Two <u>new classes</u> named <b>Byte </b>and <b>Short </b>have been added.
Instances of these classes can serve as <u>object wrappers</u> for primitive
values of type <b>byte </b>and <b>short</b>, respectively.</li>

<li><u>New objects</u> that are instances of the class <b>Class </b>were added
to represent the primitive Java types: boolean, byte, char, short, int,
long, float, and double, and the keyword void, <u>at run-time</u>.</li>

<li>
A new <u>placeholder</u> class named <b>Void </b>was added to hold a reference
to the <b>Class </b>object representing the keyword <b>void</b>.</li></ul>

<center><h3><a name="the model for reflection"></a><b><font color="#ff0000">The Model
for Reflection</font></b></h3></center><u>As mentioned earlier, only</u> the JVM can create instances of <b>Field</b>,
<b>Method</b>, and <b>Constructor </b>because they are all <b>final</b>.
Objects of these classes created by the JVM can be used to:
<ul><li>
get <u>reflective information</u> about the underlying member or constructor</li>

<li><u>get</u> and <u>set</u> field values</li>

<li><u>invoke</u> methods on objects or classes</li>

<li>
create <u>new instances</u> of classes</li></ul>
The new <b>Array </b>class provides static methods for <u>creating new
arrays</u>, and for <u>getting</u> and <u>setting</u> the elements of arrays.
<center><h3><a name="the modifier class"></a><b><font color="#ff0000">The Modifier
Class</font></b></h3></center>
It is not possible to instantiate objects of the class named <b>Modifier</b>.
This class provides <u>class methods to decode modifiers</u> for classes
and members (private, protected, etc.) that are returned by the methods
of other classes.
<center><h3><a name="security"></a><b><font color="#ff0000">Security</font></b></h3></center>
It is recommended that you review the information on the Security Model
for the Core Reflection API to learn the details.

<p>In general, according to the JDK 1.1 documentation:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"standard Java language access control checks -- for <i>protected</i>,
<i>default </i>(package) access, and <i>private </i>classes and members
-- will normally occur when the individual reflected members are used to
operate on the underlying members of objects, that is, to get or set field
values, to invoke methods, or to create and initialize new objects."</td></tr></table>
.
<center><h3><a name="data conversion"></a><b><font color="#ff0000">Data Conversion</font></b></h3></center>
Certain methods, such as methods for getting and setting field and array
component values, perform automatic data conversions between values of
primitive types and objects of class types.

<p>There are two types of automatic data conversions.
<ul><li><u>Wrapping</u> conversions convert from values of primitive types to objects
of class types.</li>

<li><u>Unwrapping</u> conversions convert objects of class types to values
of primitive types.</li></ul>
In addition, field access and method invocation permit <i>widening conversions</i>
on primitive and reference types as defined in The Java Language Specification,
section 5.

<p>The rules for conversions are:
<ul><li>
A primitive value is <u>automatically wrapped</u> in an object when it
is <u>retrieved</u> via <b>Field.get</b> or <b>Array.get</b>, or when it
is returned by a method invoked via <b>Method.invoke</b>.</li>

<li>
An object value is <u>automatically unwrapped</u> when <u>supplied as a
parameter</u> in a context that requires a value of a primitive type. These
contexts are:</li>

<ul><li><b>Field.set</b>, where the underlying field has a primitive type</li>

<li><b>Array.set</b>, where the underlying array has a primitive element type</li>

<li><b>Method.invoke</b> or <b>Constructor.newInstance</b>, where the corresponding
formal parameter of the underlying method or constructor has a primitive
type</li></ul></ul>
The eight wrapper classes have names like <b>java.lang.Boolean</b> which
correspond to the primitive types of the same name.

<p>A method that is declared <b>void </b>returns the special reference
<b>null </b>when it is invoked via <b>Method.invoke</b>.

<p>The same widening conversions may be performed at run-time as are permitted
in method invocation contexts at compile time. These conversions are defined
in The Java Language Specification, section 5.3.

<p>Conversions may be performed at runtime
<ul><li>
when a value is <u>retrieved</u> from a field or an array via the methods
of <b>Field </b>and <b>Array</b></li>

<li>
when a value is <u>stored</u> into a field or an array via the methods
of <b>Field </b>and <b>Array</b></li>

<li>
when an unwrapped actual parameter value is converted to the type of its
corresponding formal parameter during method or constructor invocation
via <b>Method.invoke</b> or <b>Constructor.newInstance</b></li></ul>

<center><h3><a name="packaging"></a><b><font color="#ff0000">Packaging</font></b></h3></center>
The Core Reflection API is in a new subpackage of java.lang named java.lang.reflect.
<center><h2><a name="sample program"></a><font color="#ff0000">Sample Program</font></h2></center>
As mentioned earlier, we will begin our study of reflection by emphasizing
the use of the <b>Method</b> class. Subsequent lessons will deal with the
<b>Field, Constructor, </b>and <b>Array</b> classes. We will pick up the
other classes, such as the <b>Modifier</b> class along the way.

<p>The purpose of this program is to demonstrate the use of most of the
methods of the <b>Method </b>class

<p>A test class named <b>TstCls </b>is defined which contains two methods
named <b>setFlds()</b> and <b>showFlds()</b>. <u>These methods are not
necessarily designed to make sense</u>. Rather, they are designed to be
good test cases for the methods of the <b>Method </b>class. For example,
one of the methods throws some exceptions that make no operational sense
at all.

<p>A <b>Class </b>object is created to represent the <b>TstCls </b>class.

<p>This <b>Class </b>object is used to create an array of <b>Method </b>objects
where each <b>Method </b>objects represents one of the methods of the class.

<p>A loop iterates on the array of <b>Method </b>objects, using each object
in the array to obtain and display information about the method such as:
<i>name, declaring class, modifiers, return type, hash code, </i>etc.

<p>For each method, an array of <b>Class </b>objects is created where each
object in the array represents one of the parameters to the method. A loop
is used to iterate on this array displaying information about each parameter.

<p>Also, for each method, an array of <b>Class </b>objects is created where
each object in the array represents an <i>exception </i>that is thrown
by the method. A loop is used to iterate on this array displaying information
about each different type of <i>exception </i>that the method throws.

<p>Then a blank line is displayed, and the program goes back to the top
of the outer loop and displays information about the next method.

<p>One important method that this program does not invoke on the objects
of type <b>Method </b>is the <b>invoke()</b> method. The <b>invoke()</b>
method can be used in conjunction with an object of type <b>Method </b>to
invoke a method on a target object. The <b>invoke()</b> method will be
the topic of one or more subsequent lessons..

<p>This program was tested using JDK 1.1.3 under Win95.

<p>The output from the program is shown later in the lesson.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
First we define a test class that can be investigated using the methods
of the <b>Method </b>class. As mentioned before, this class isn't necessarily
designed to make sense. Rather, it is designed to exercise the methods
of the Method class.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>TstCls</b>{
&nbsp; String strFld;
&nbsp; Date dteFld;
&nbsp;&nbsp;
&nbsp; public final void <b>setFlds</b>(String strFld, Date dteFld){
&nbsp;&nbsp;&nbsp; this.strFld = strFld;
&nbsp;&nbsp;&nbsp; this.dteFld = dteFld;
&nbsp; }//end setFlds

&nbsp; protected void <b>showFlds</b>()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throws </b>InterruptedException,ClassNotFoundException{
&nbsp;&nbsp;&nbsp; System.out.println(strFld);
&nbsp; }//end showFlds
}//end TstCls</pre></td></tr></table>
The entire remainder of the program is contained in the <b>main()</b> method
of the controlling class. Because of its length, we will need to break
it into sections and discuss the different sections individually.

<p>Note also that because of some exceptions that can be thrown, almost
all of the <b>main()</b> method is wrapped in a <b>try</b> block followed
by a <b>catch</b> block. That is standard <i>try/catch</i> methodology
and you can see how it is done in the complete program listing at the end
of the lesson. Therefore, we won't discuss it further in this section of
the lesson.

<p>The next interesting code fragment is a list of local variables that
are used within the program. I show them here just so that you can become
familiar with their names.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; Class theClass;&nbsp;&nbsp;&nbsp; //Various kinds of data are
&nbsp;&nbsp;&nbsp; Method[] theMthds; // stored in these variables
&nbsp;&nbsp;&nbsp; Class[] theParams;
&nbsp;&nbsp;&nbsp; Class[] theExceps;</pre></td></tr></table>
Our next interesting code fragment instantiates an object of the class
<b>Class</b> that represents the class named <b>TstCls</b>. Notice that
we did not directly instantiate an object of the <b>Class</b> class using
the <b>new</b> operator. Rather, we used the <b>forName()</b> method of
the <b>Class</b> class to obtain the <b>Class</b> object.

<p>Following this, we use the <b>Class</b> object, along with the <b>getDeclaredMethods()</b>
methods of the <b>Class</b> class to create an array of <b>Method</b> references
and we assign that array to the reference variable declared earlier named
<b>theMethods</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = Class.<b>forName</b>("TstCls");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theMthds = theClass.<b>getDeclaredMethods</b>();</pre></td></tr></table>
Each element of the array named <b>theMthds</b> contains a reference to
one <b>Method</b> object for every method in our class (so it should have
two elements).

<p>Note that there are subtle differences between similar sounding methods
in the <b>Class</b> class (such as <b>getDeclaredMethods</b> and <b>getMethods</b>)
and you must read the documentation very carefully to make certain that
you know what you are getting. For example, <b>getMethods()</b> only provides
a <b>Method</b> object for <b>public</b> methods.

<p>It is difficult to break the code up at this point in a way that makes
sense. What we have is nested loops. The outer loop iterates on the array
of <b>Method</b> objects extracting various kinds of information. Some
of the types of information that is extracted is single-valued, and some
of it is multi-valued. Therefore, it is necessary for us to produce arrays
inside the outer loop in some cases and to iterate on each of those arrays
to properly display the information.

<p>I am still going to present this code in chunks, and if you get lost,
you can look in the complete program listing at the end of the lesson to
see how it all fits together.

<p>The next interesting code fragment includes the beginning of the outer
loop and several statements that extract and display single-valued information
about a specific method. Remember that this loop iterates once for each
different method in the class under investigation.

<p>For the most part, the name of the method being invoked indicates the
type of information that is extracted and displayed about the method. I
have highlighted the critical method names to make them easy for you to
spot. You can compare this code with the output from the program that will
be presented later.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(int i = 0; i &lt; theMthds.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Method: " + <b>theMthds</b>[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Name: " + theMthds[i].<b>getName</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Declaring Class: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theMthds[i].<b>getDeclaringClass</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Modifiers: " + <b>Modifier.toString(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theMthds[i].getModifiers()</b>));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Return Type: " + theMthds[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getReturnType</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "hashCode: " + theMthds[i].<b>hashCode</b>());</pre></td></tr></table>
There is one statement here having to do with <i>modifiers</i> that may
not be intuitive. <i>Modifiers</i> are things like <i>public, private,
abstract, </i>etc. As you are aware, they can exist in various combinations.

<p>The method named <b>getModifiers()</b> returns an <b>int</b> where the
existence of each possible modifier is encoded into a single bit in the
<b>int</b> value. The <b>Modifier</b> class provides about a dozen methods
that can be used to decode the <b>int</b> value to determine which set
of <i>modifiers</i> it represents. All but one of those methods tests to
see if the <b>int</b> value includes a bit for a specific single <i>modifier.</i>
However, the overridden <b>toString()</b> method of the <b>Modifier</b>
class produces a <b>String</b> that is a list of all the <i>modifiers</i>
represented by the <b>int</b> value.

<p>The next interesting code fragment gets into the realm of extracting
multi-valued information about the method. This fragment has to do with
the method parameters. Obviously each method can have none, one, or more
parameters.

<p>The <b>getParameterTypes()</b> method of the <b>Method</b> class returns
one reference to a <b>Class</b> object for every parameter in the formal
argument list for the method. It does that by returning an array of references
of type <b>Class</b>. We assign the returned array to a previously-declared
reference variable of the <b>Class[]</b> type.

<p>Then we use a loop to iterate on this array to display the type of each
of the parameters in the formal argument list. If the length of the array
is zero, we display the string "Param: none".
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theParams = theMthds[i].<b>getParameterTypes</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theParams.length != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0; j &lt; theParams.length;j++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; Param: " + j + " " + theParams[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println("&nbsp; Param: none");</pre></td></tr></table>
Just as each method can have multiple parameters, each method can also
throw multiple exceptions. The method of the <b>Method</b> class named
<b>getExceptionTypes()</b> also returns an array of <b>Class</b> references
where each reference is to a&nbsp;<b> Class</b> object that represents
the exception. Again, we assign this array of references to a pre-defined
reference variable of type <b>Class[]</b> and then iterate on that array
to extract and display information about the exceptions thrown by the method.

<p>If the length of the array is zero, we simply display the string "Excep:
none".
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theExceps = theMthds[i].<b>getExceptionTypes</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Exceptions");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theExceps.length != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0; j &lt; theExceps.length;j++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; Excep: " + j + " " + theExceps[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println("&nbsp; Excep: none");</pre></td></tr></table>
Following this, we display a blank line and go back to the top of the loop
to see if there are more methods to be examined. Then we throw in a couple
of <i>catch</i> blocks that are needed to deal with exceptions that may
have been thrown, and that is the end of the program.

<p>The output produced by running this program is shown below. Manual line
breaks were inserted in some cases to force the material to fit on the
page.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td bgcolor="#00ffff"><pre>Method: public final void&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TstCls.setFlds(java.lang.String,java.util.Date)
Name: setFlds
Declaring Class: class TstCls
Modifiers: public final
Return Type: void
hashCode: 152758476
Parameters
&nbsp; Param: 0 class java.lang.String
&nbsp; Param: 1 class java.util.Date
Exceptions
&nbsp; Excep: none

Method: protected void TstCls.showFlds()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws java.lang.InterruptedException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.lang.ClassNotFoundException
Name: showFlds
Declaring Class: class TstCls
Modifiers: protected
Return Type: void
hashCode: -1159789721
Parameters
&nbsp; Param: none
Exceptions
&nbsp; Excep: 0 class java.lang.InterruptedException
&nbsp; Excep: 1 class java.lang.ClassNotFoundException</pre></td></tr></table>
So there you have it, a major introduction to the reflection API. In the
next lesson, we will start looking at how you might use the <b>invoke()</b>
method of the <b>Method</b> class to do some pretty interesting things,
including the design of more sophisticated <i>adapters</i> for dealing
with events.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>

<table border bgcolor="#ffff80" ><tr><td><pre>/*File Reflections03.java Copyright 1998, R.G.Baldwin

The purpose of this program is to demonstrate most of the
methods of the java.lang.reflect.Method class

This program was tested using JDK 1.1.3 under Win95.
**********************************************************/
import java.lang.reflect.*;
import java.util.*;
//=======================================================//

//Define a test class that can be investigated using the
// methods of the Method class.&nbsp; This class isn't&nbsp;
// necessarily designed to make sense.&nbsp; Rather, it is
// designed to exercise the methods of the Method class.
class TstCls{
&nbsp; String strFld;
&nbsp; Date dteFld;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public final void setFlds(String strFld, Date dteFld){
&nbsp;&nbsp;&nbsp; this.strFld = strFld;
&nbsp;&nbsp;&nbsp; this.dteFld = dteFld;
&nbsp; }//end setFlds
&nbsp; //-----------------------------------------------------//

&nbsp; protected void showFlds()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws InterruptedException,ClassNotFoundException{
&nbsp;&nbsp;&nbsp; System.out.println(strFld);
&nbsp; }//end showFlds
&nbsp; //-----------------------------------------------------//
}//end TstCls
//=======================================================//

class Reflections03 {

&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public static void main(String[] args) {
&nbsp;&nbsp;&nbsp; Class theClass;&nbsp;&nbsp;&nbsp; //Various kinds of data are
&nbsp;&nbsp;&nbsp; Method[] theMthds; // stored in these variables
&nbsp;&nbsp;&nbsp; Class[] theParams;
&nbsp;&nbsp;&nbsp; Class[] theExceps;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create a Class object for class named TstCls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = Class.forName("TstCls");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create an array containing Method objects
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // describing all of the methods in the class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // named TstCls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theMthds = theClass.getDeclaredMethods();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Iterate on the array of Method objects, extracting
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and displaying information about each of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // methods described by those objects.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; theMthds.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Method: " + theMthds[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Name: " + theMthds[i].getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Declaring Class: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theMthds[i].getDeclaringClass());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Modifiers: " + Modifier.toString(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theMthds[i].getModifiers()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Return Type: " + theMthds[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getReturnType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "hashCode: " + theMthds[i].hashCode());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create an array of Class objects describing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameters of this method.&nbsp; Iterate on the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // array and describe each parameter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theParams = theMthds[i].getParameterTypes();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theParams.length != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0; j &lt; theParams.length;j++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; Param: " + j + " " + theParams[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println("&nbsp; Param: none");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create an array of Class objects describing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exceptions thrown by this method.&nbsp; Iterate on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the array and describe each exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theExceps = theMthds[i].getExceptionTypes();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Exceptions");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theExceps.length != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0; j &lt; theExceps.length;j++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; Excep: " + j + " " + theExceps[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println("&nbsp; Excep: none");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display a blank line and then describe the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // next method in the array of methods.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println();//blank line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop on i
&nbsp;&nbsp;&nbsp; }//end try block
&nbsp;&nbsp;&nbsp; catch(ClassNotFoundException e){}
&nbsp;&nbsp;&nbsp; catch(SecurityException e){}
&nbsp; }//end main()
}//end Reflections03</pre></td></tr></table>
-end-<!--end--></body></html>