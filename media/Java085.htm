<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Swing, New Event Types in Swing<!--endtitle--></b></h2></center>
&nbsp;
<br>Java Programming, Lecture Notes # 85, Revised 06/15/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#new event types in swing">New Event Types in Swing</a></li>

<li><a href="#sample program 1">Sample Program 1</a></li>

<ul><li><a href="#interesting code fragments for sample program 1">Interesting
Code Fragments for Sample Program 1</a></li>

<li><a href="#program listing for sample program 1">Program Listing for Sample
Program 1</a></li></ul>

<li><a href="#sample program 2">Sample Program 2</a></li>

<ul><li><a href="#interesting code fragments for sample program 2">Interesting
Code Fragments for Sample Program 2</a></li>

<li><a href="#program listing for sample program 2">Program Listing for Sample
Program 2</a></li></ul></ul>

<hr width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
classes at ACC are responsible for knowing and understanding all of the
material in this lesson.
<br>&nbsp;
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
Although event handling using <b>Swing</b> components is the same as event
handling using <b>AWT</b> components, the <b>Swing</b> classes provide
a number of new event types.

<p>This lesson will briefly discuss all of the new event types, and will
provide two different sample programs that illustrate event handling with
one of the new event types.

<p>One of the sample programs will also illustrate the important new aspect
of <b>Swing</b> wherein every component is also a container.&nbsp; In this
case, we will build a pyramid of <b>Swing JButton</b> objects where each
<b>JButton</b> object is contained in the one below it with the bottom
<b>JButton</b> object being contained in a <b>JFrame</b> object.

<p>We will then illustrate how these <b>JButton</b> objects respond to
action events and ancestor events.&nbsp; Action events come to us from
the <b>AWT</b> whereas ancestor events are new to <b>Swing</b>.
<br>&nbsp;
<center><h2><a name="new event types in swing"></a><font color="#ff0000">New Event
Types in Swing</font></h2></center>
One of the easiest ways to identify the new event types in <b>Swing</b>
is to take a look at the listener interfaces defined in <b>Swing</b>.&nbsp;
Another way is to take a look at the event classes defined in&nbsp; <b>Swing</b>.

<p>The following table shows a list of the listener interfaces defined
in the <b>com.sun.java.swing.event</b> package of <b>Swing 1.0.1.</b><br>&nbsp;
<table border bgcolor="#66ffff" ><tr><td><menu><li><font color="#000000">AncestorListener&nbsp;</font></li>

<li><font color="#000000">CaretListener&nbsp;</font></li>

<li><font color="#000000">CellEditorListener</font></li>

<li><font color="#000000">ChangeListener&nbsp;</font></li>

<li><font color="#000000">DocumentEvent&nbsp;</font></li>

<li><font color="#000000">DocumentListener&nbsp;</font></li>

<li><font color="#000000">HyperlinkListener&nbsp;</font></li>

<li><font color="#000000">InternalFrameListener&nbsp;</font></li>

<li><font color="#000000">ListDataListener&nbsp;</font></li>

<li><font color="#000000">ListSelectionListener&nbsp;</font></li>

<li><font color="#000000">MenuListener&nbsp;</font></li>

<li><font color="#000000">PopupMenuListener&nbsp;</font></li>

<li><font color="#000000">TableColumnModelListener&nbsp;</font></li>

<li><font color="#000000">TableModelListener&nbsp;</font></li>

<li><font color="#000000">TreeExpansionListener&nbsp;</font></li>

<li><font color="#000000">TreeModelListener&nbsp;</font></li>

<li><font color="#000000">TreeSelectionListener&nbsp;</font></li>

<li><font color="#000000">UndoableEditListener&nbsp;</font></li></menu></td></tr></table>
&nbsp;
<br>The following table shows a list of the event classes defined in the
<b>com.sun.java.swing.event</b> package of <b>Swing 1.0.1</b>.

<p>You might note that there is not an obvious one-to-one correspondence
between listener interfaces and event types in every case.&nbsp; Obviously,
if all of the listener interfaces and all of the event classes are included
on these two lists, every event class must correspond to an event listener
interface in some way.

<p>I will leave it as an exercise for the student to dig into the documentation
and figure out how the event classes relate to the listener interfaces.
<br>&nbsp;
<table border bgcolor="#66ffff" ><tr><td><menu><li>
AncestorEvent&nbsp;</li>

<li>
CaretEvent&nbsp;</li>

<li>
ChangeEvent&nbsp;</li>

<li>
EventListenerList&nbsp;</li>

<li>
HyperlinkEvent&nbsp;</li>

<li>
InternalFrameAdapter&nbsp;</li>

<li>
InternalFrameEvent&nbsp;</li>

<li>
ListDataEvent&nbsp;</li>

<li>
ListSelectionEvent&nbsp;</li>

<li>
MenuEvent&nbsp;</li>

<li>
PopupMenuEvent&nbsp;</li>

<li>
TableColumnModelEvent&nbsp;</li>

<li>
TableModelEvent&nbsp;</li>

<li>
TreeExpansionEvent&nbsp;</li>

<li>
TreeModelEvent&nbsp;</li>

<li>
TreeSelectionEvent&nbsp;</li>

<li>
UndoableEditEvent&nbsp;</li></menu></td></tr></table>
&nbsp;
<br>The two sample programs that follow in this lesson illustrate the <b>AncestorEvent</b>
class and the <b>AncestorListener</b> interface.
<br>&nbsp;
<center><h2><a name="sample program 1"></a><font color="#ff0000">Sample Program 1</font></h2></center>
This program illustrates the use of <b>getContentPane()</b> to add a <b>JButton</b>
to a <b>JFrame</b>.

<p>It also illustrates use of <b>AncestorListener</b> on a <b>JButton</b>.

<p>Running the program and moving the resulting <b>JFrame</b> on the screen
produced the following output.&nbsp; Note that line breaks were manually
added to this presentation to make the lines fit in this format.

<p>Note also that this output doesn't seem to provide a good match for
the descriptions and names of two of the methods in the JavaSoft documentation.
This will be discussed in more detail later.
<br>&nbsp;
<table border bgcolor="#66ffff" ><tr><td><pre>Make JFrame visible
ancestorAdded method invoked
Event source: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
Ancestor: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
Parent: com.sun.java.swing.JPanel[null.contentPane,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.JRootPane$1]
Component: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
ID value: 1
ancestorMoved method
ancestorMoved method</pre></td></tr></table>
&nbsp;
<br>The program was tested using JDK 1.1.6 and Swing 1.0.1 under Win95.
<br>&nbsp;
<center><h3><a name="interesting code fragments for sample program 1"></a><font color="#ff0000">Interesting
Code Fragments for Sample Program 1</font></h3></center>
We will begin with the import statements that highlight the requirement
to import the <b>Swing</b> packages.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>import java.awt.*;
import java.awt.event.*;
<b>import com.sun.java.swing.*;
import com.sun.java.swing.event.*;</b></pre></td></tr></table>
&nbsp;
<br>The <b>main() </b>method in the controlling class is extremely simple,
but we will include it here for continuity.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>public class SwingEvent10 {
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; GUI gui = new GUI();//instantiate a GUI
&nbsp; }//end main
}//end class SwingEvent10</pre></td></tr></table>
&nbsp;
<br>That brings us to the class named <b>GUI</b> from which we will instantiate
our graphical user interface object and display it on the screen. As you
can see below, the constructor for out <b>GUI</b> object is pretty straightforward.

<p>We begin by instantiating a <b>Swing</b> object of type <b>JFrame</b>,
setting its size, giving it a title, etc. We also add a <b>WindowListener</b>
to terminate the program when the user closes the <b>JFrame</b> object.

<p>Then we instantiate a <b>Swing</b> object of type <b>JButton</b> and
register an <b>AncestorListener</b> object on the button.&nbsp; We will
discuss the class from which the listener was instantiated shortly.

<p>After this, we add the <b>JButton</b> object to the to the <b>JFrame</b>
object named <b>displayWindow</b> by first invoking the<b> getContentPane()</b>
method and then invoking the <b>add()</b> method on the content pane.&nbsp;
We will discuss this further following the listing of the fragment.

<p>Finally, we display a message and make the <b>JFrame</b> object visible
and that concludes the constructor.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>class GUI {
&nbsp; public GUI(){//constructor
&nbsp;&nbsp;&nbsp; JFrame displayWindow = new JFrame();
&nbsp;&nbsp;&nbsp; displayWindow.setSize(300,300);
&nbsp;&nbsp;&nbsp; displayWindow.setTitle("Copyright 1998, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; displayWindow.addWindowListener(new WProc1());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; JButton theButton = new JButton("Button");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; theButton.addAncestorListener(new MyAncestorListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; displayWindow.getContentPane().add(theButton);

&nbsp;&nbsp;&nbsp; System.out.println("Make JFrame visible");
&nbsp;&nbsp;&nbsp; displayWindow.setVisible(true);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor</pre></td></tr></table>
&nbsp;
<br>Now what about this <b>getContentPane()</b> method.&nbsp; This is something
that doesn't exist in the <b>AWT</b>.

<p>In short, in the <b>AWT</b>, we add components to, and otherwise manipulate,
the client area of a <b>Frame</b> object directly.

<p>However, in <b>Swing</b>, some "panes" are automatically placed in the
client area of a <b>JFrame</b> object, and we add components to, and otherwise
manipulate, those panes instead of manipulating the client area of the
<b>JFrame</b> object directly.

<p>Rather than to try to explain this in my own words, I am simply going
to provide a quotation from the JavaSoft documentation for the <b>JFrame</b>
object, <b>Swing</b>, Version 1.0.1. Note that the following wording is
the copyrighted property of JavaSoft. The emphasis was added by me.
<br>&nbsp;
<br>&nbsp;
<table border cols=1 bgcolor="#66ffff" ><tr><td>public class <b>JFrame</b>&nbsp;
<br>extends <b>Frame</b>&nbsp;
<br>implements WindowConstants, Accessible, RootPaneContainer&nbsp;

<p>An extended version of <b>java.awt.Frame</b> that adds support for interposing
input and painting behavior in front of the frames children (see glassPane),
support for special children that are managed by a <b>LayeredPane</b> (see
rootPane) and for <b>Swing</b> <b>MenuBars</b>.&nbsp;

<p>The <b>JFrame</b> class is slightly incompatible with <b>java.awt.Frame</b>.
<b>JFrame</b> contains a <b>JRootPane</b> <u>as it's only child</u>. The
<b>contentPane</b> <u>should be the parent of any children of the JFrame</u>.
This is different than <b>java.awt.Frame</b>, e.g. to add a child to an
<b>AWT</b> Frame you'd write:&nbsp;

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame.add(child);&nbsp;
<br>&nbsp;

<p>However using <b>JFrame</b> you need to add the child to the <b>JFrames</b><b>contentPane</b> instead:&nbsp;

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>frame.getContentPane().add(child);</b>&nbsp;
<br>&nbsp;

<p>The same is true for setting LayoutManagers, removing components, listing
children, etc. All these methods should normally be sent to the <b>contentPane()</b>
instead of the <b>JFrame</b> itself. The <b>contentPane()</b> will always
be non-null. Attempting to set it to null will cause the <b>JFrame</b>
to throw an exception. The default <b>contentPane()</b> will have a <b>BorderLayout</b>
manager set on it.&nbsp;

<p>Please see the <b>JRootPane</b> documentation for a complete description
of the contentPane, glassPane, and layeredPane properties.&nbsp;

<p><b>Warning</b>: serialized objects of this class will not be compatible
with future swing releases. The current serialization support is appropriate
for short term storage or RMI between Swing1.0 applications. It will not
be possible to load serialized Swing1.0 objects with future releases of
Swing. The JDK1.2 release of Swing will be the compatibility baseline for
the serialized form of Swing objects.&nbsp;</td></tr></table>
&nbsp;
<br>For the time being, and for this simple example, this all boils down
to a requirement to insert the method call

<p><b>getContentPane();</b>

<p>between the reference to the <b>JFrame</b> object and calls to <b>add()</b>,
<b>setLayout()</b>, etc.&nbsp; For more complex programs, the ramifications
could be more significant.

<p>Our <b>GUI</b> class has two inner classes.&nbsp; One of those is a
<b>WindowListener</b> class that is used to terminate the program when
the user closes the <b>JFrame</b> object.&nbsp; It is so simple and so
common that I'm not going to show it here.&nbsp; You can see it in the
complete listing of the program that follows later if you are interested.

<p>The second inner class (and these could just as well be implemented
as top-level classes instead of inner classes) is used to instantiate an
<b>AncestorListener</b> object to be registered on the <b>JButton</b> object.

<p>This is a little more interesting.&nbsp; The <b>AncestorListener</b>
interface declares three methods, and as far as I know there is no adapter
for this interface.&nbsp; Therefore, our class that implements the interface
must define all three methods.

<p>A brief description of each of the three methods follows:
<br>&nbsp;
<table border cols=1 bgcolor="#66ffff" ><tr><td><ul><li><b>ancestorAdded(AncestorEvent)</b>&nbsp; -- Called when the source or
one of its ancestors is made visible either by setVisible(true) being called
or by its being added to the component hierarchy.&nbsp;</li>

<li><b>ancestorMoved(AncestorEvent)</b>&nbsp; -- Called when either the source
or one of its ancestors is moved.&nbsp;</li>

<li><b>ancestorRemoved(AncestorEvent)</b>&nbsp; --&nbsp; Called when the source
or one of its ancestors is made invisible either by setVisible(false) being
called or by its being remove from the component hierarchy.&nbsp;</li></ul></td></tr></table>
&nbsp;
<br>As you can see, whenever one of the methods is called, an object of
type <b>AncestorEvent</b> is passed as a parameter.&nbsp; As usual, it
is possible to invoke the methods of the <b>AncestorEvent</b> class and
the classes extended by that class to learn more about the event.

<p>We will define all three of the interface methods (as required) in our
class definition.&nbsp; The following fragment shows only the definition
of the first of the three methods.

<p>When this method is called, it invokes five different methods of the
incoming <b>AncestorEvent</b> object and displays the material returned
from those methods.&nbsp; The output from invoking these methods was shown
earlier in this lesson.

<p>As mentioned earlier, the output doesn't seem to provide a good match
for the descriptions and names of the <b>getAncestor()</b> and <b>getAncestorParent()</b>
methods in the JavaSoft documentation.&nbsp; The output seems to refer
to the <b>JButton</b> object as the ancestor and the <b>JRootPane</b> as
the parent of the ancestor.&nbsp; It would seem from a cursory examination
that the <b>JButton</b> object is a child, not an ancestor, but this must
depend on the interpretation of the class library in some fashion.

<p>In any event, since there isn't any good documentation available to
research this anomaly at the time of this writing, I am simply going to
mark it up as something that needs to be looked into later when better
documentation becomes available.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>&nbsp; class MyAncestorListener implements AncestorListener{
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void <b>ancestorAdded(AncestorEvent</b> e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorAdded method invoked");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " + e.getSource());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Ancestor: " + e.getAncestor());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Parent: " + e.getAncestorParent());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Component: " + e.getComponent());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ID value: " + e.getID());
&nbsp;&nbsp;&nbsp; }//end ancestorAdded()</pre></td></tr></table>
&nbsp;
<br>The final code fragment shows the definitions of the other two methods
of the <b>AncestorListener</b> interface.

<p>If you compile and run this program and observe the output as the program
runs, you will see that the <b>ancestorAdded()</b> method and the <b>ancestorMoved()</b>
method are both called when the <b>JFrame</b> object is made visible.

<p>Following this, whenever the <b>JFrame</b> object is moved on the screen,
the <b>ancestorMoved()</b> method will be called.

<p>Iconifying and then deiconifying the <b>JFrame</b> object also caused
the <b>ancestorMoved()</b> method to be called.

<p>At no time during my experiments was the <b>ancestorRemoved()</b> method
called.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void <b>ancestorRemoved(AncestorEvent</b> e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorRemoved method");
&nbsp;&nbsp;&nbsp; }//end ancestorRemoved()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void <b>ancestorMoved(AncestorEvent</b> e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorMoved method");
&nbsp;&nbsp;&nbsp; }//end ancestorMoved
&nbsp; }//end class MyAncestorListener
&nbsp; //.....................................................//
}//end class GUI definition
//=======================================================//</pre></td></tr></table>
.
<center><h3><a name="program listing for sample program 1"></a><font color="#ff0000">Program
Listing for Sample Program 1</font></h3></center>
This section contains a complete listing of the program.&nbsp; Discussion
of the second program begins immediately following this listing.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>/*File SwingEvent10.java Copyright 1998, R.G.Baldwin
Illustrates use of getContentPane() to add a JButton to
a JFrame.

Illustrates use of AncestorListener on a JButton.

Running the program and moving the resulting JFrame on the
screen produced the following output.&nbsp; Note that line breaks
were manually added to this presentation to make the lines
fit in this format. Note that these outputs don't seem to
provide a good match for the descriptions and names of the
methods in the JavaSoft documentation.

Make JFrame visible
ancestorAdded method invoked
Event source: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
Ancestor: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
Parent: com.sun.java.swing.JPanel[null.contentPane,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.JRootPane$1]
Component: com.sun.java.swing.JButton[,0,0,0x0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid,layout=com.sun.java.swing.OverlayLayout]
ID value: 1
ancestorMoved method
ancestorMoved method

Tested using JDK 1.1.6 and Swing 1.0.1 under Win95.
**********************************************************/
import java.awt.*;
import java.awt.event.*;
import com.sun.java.swing.*;
import com.sun.java.swing.event.*;

public class SwingEvent10 {
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; GUI gui = new GUI();//instantiate a GUI
&nbsp; }//end main
}//end class SwingEvent10
//=======================================================//


//The following class is used to instantiate a&nbsp;
// graphical user interface object.
class GUI {
&nbsp; public GUI(){//constructor
&nbsp;&nbsp;&nbsp; //Create a new JFrame object, set size, title, etc.
&nbsp;&nbsp;&nbsp; JFrame displayWindow = new JFrame();
&nbsp;&nbsp;&nbsp; displayWindow.setSize(300,300);
&nbsp;&nbsp;&nbsp; displayWindow.setTitle("Copyright 1998, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; //Add window listener to terminate the program
&nbsp;&nbsp;&nbsp; displayWindow.addWindowListener(new WProc1());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a JButton object
&nbsp;&nbsp;&nbsp; JButton theButton = new JButton("Button");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Register an AncestorListener object on the JButton
&nbsp;&nbsp;&nbsp; theButton.addAncestorListener(new MyAncestorListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add the JButton to the JFrame using content pane
&nbsp;&nbsp;&nbsp; displayWindow.getContentPane().add(theButton);

&nbsp;&nbsp;&nbsp; System.out.println("Make JFrame visible");
&nbsp;&nbsp;&nbsp; displayWindow.setVisible(true);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //.....................................................//
&nbsp; //Begin inner class definitions
&nbsp; //The following listener is used to terminate the program
&nbsp; // when the user closes the frame.
&nbsp; class WProc1 extends WindowAdapter{
&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp; }//end class WProc1
&nbsp; //.....................................................//

&nbsp; //Define an AncestorListener class
&nbsp; class MyAncestorListener implements AncestorListener{
&nbsp;&nbsp;&nbsp; //Define three methods declared in AncestorListener
&nbsp;&nbsp;&nbsp; // interface.
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorAdded(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorAdded method invoked");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " + e.getSource());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Ancestor: " + e.getAncestor());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Parent: " + e.getAncestorParent());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Component: " + e.getComponent());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ID value: " + e.getID());
&nbsp;&nbsp;&nbsp; }//end ancestorAdded()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorRemoved(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorRemoved method");
&nbsp;&nbsp;&nbsp; }//end ancestorRemoved()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorMoved(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ancestorMoved method");
&nbsp;&nbsp;&nbsp; }//end ancestorMoved
&nbsp; }//end class MyAncestorListener
&nbsp; //.....................................................//
}//end class GUI definition
//=======================================================//</pre></td></tr></table>
.
<br>&nbsp;
<center><h2><a name="sample program 2"></a><font color="#ff0000">Sample Program 2</font></h2></center>
This program further illustrates the use of an <b>AncestorListener</b>
on a <b>JButton</b>.

<p>More importantly, this program illustrates the very important fact that
<b>JButton</b> objects are containers that can contain other objects including
other <b>JButton</b> objects.

<p>This program stacks three <b>JButton</b> objects on top of one another
with the stack of three <b>JButton</b> objects being placed on a <b>JFrame</b>
object. <b>ActionListener</b> objects are registered on each of the buttons
to trap an <b>actionPerformed()</b> event when the button is clicked and
to display the source of the event.

<p><b>AncestorListener</b> objects are also registered on all three of
the <b>JButton</b> objects.

<p>Running the program and carefully clicking each of the three buttons
in succession from the top of the stack to the bottom of the stack, and
then moving the <b>JFrame</b> object on the screen produces the following
output. Note that some blank lines were manually inserted to make it easier
to follow this material.
<br>&nbsp;
<table border bgcolor="#66ffff" ><tr><td><pre>Make JFrame visible
In ancestorAdded method
Event source: First Button
In ancestorAdded method
Event source: Second Button
In ancestorAdded method
Event source: Third Button

In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button

In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button

In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button
In ancestorMoved method
Event source: Third Button

<b>In actionPerformed method
Event source: Third Button
In actionPerformed method
Event source: Second Button
In actionPerformed method
Event source: First Button

</b>In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button</pre></td></tr></table>
&nbsp;
<br>The output produced by clicking the buttons is highlighted in boldface
in the above output.
<br>&nbsp;
<br>This program was tested using JDK 1.1.6 and Swing 1.0.1 under Win95.
<center><h3><a name="interesting code fragments for sample program 2"></a><font color="#ff0000">Interesting
Code Fragments for Sample Program 2</font></h3></center>
&nbsp;The controlling class and the <b>main()</b> method for this program
is the same as the previous program, so it has been omitted for brevity.

<p>Much of the code in the constructor for the GUI class is also the same
as in the previous program so I have deleted it from the following listing
for brevity.

<p>Note the use of <b>getContentPane()</b> when setting the layout manager
as described earlier.

<p>Three JButton objects are instantiated.&nbsp; Then the three buttons
are stacked by adding <b>secondButton</b> to <b>firstButton</b>, and by
adding <b>thirdButton</b> to <b>secondButton</b>.

<p>An <b>AncestorListener</b> object is registered on all three of the
buttons and then an <b>ActionListener</b> object is registered on all three
of the buttons.

<p>The remainder of the constructor was the same as before and was removed
for brevity.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>class GUI {
&nbsp; public GUI(){//constructor
&nbsp;&nbsp;&nbsp; //...snip

&nbsp;&nbsp;&nbsp; displayWindow.getContentPane().setLayout(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FlowLayout());
&nbsp;&nbsp;&nbsp; //...snip

&nbsp;&nbsp;&nbsp; JButton firstButton = new JButton("First Button");
&nbsp;&nbsp;&nbsp; JButton secondButton = new JButton("Second Button");
&nbsp;&nbsp;&nbsp; JButton thirdButton = new JButton("Third Button");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; firstButton.add(secondButton);
&nbsp;&nbsp;&nbsp; secondButton.add(thirdButton);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; firstButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp; secondButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp; thirdButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; firstButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp; secondButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp; thirdButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //...snip
&nbsp; }//end constructor</pre></td></tr></table>
&nbsp;
<br>The <b>AncestorListener</b> class was very similar to the previous
version, so the definition for only one of the methods is shown in the
following fragment.

<p>Note the requirement for downcasting in this version of the method.
This is because invocation of the <b>getSource()</b> method returns an
object of type <b>Object</b> and it must be downcast to type <b>JButton</b>
to be useful in this case.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>&nbsp; class MyAncestorListener implements AncestorListener{
&nbsp;&nbsp;&nbsp; public void ancestorAdded(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In ancestorAdded method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((<b>JButton)e.getSource()).getActionCommand</b>());
&nbsp;&nbsp;&nbsp; }//end ancestorAdded()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //...snip

&nbsp; }//end class MyAncestorListener</pre></td></tr></table>
&nbsp;
<br>Finally we see the <b>ActionListener</b> class that traps action events
on the buttons when they are clicked and presents appropriate output on
the screen.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>&nbsp; class MyActionListener implements ActionListener{
&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In actionPerformed method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)e.getSource()).getActionCommand());
&nbsp;&nbsp;&nbsp; }//end actionPerformed()
&nbsp; }//end class MyActionListener</pre></td></tr></table>
.
<center><h3><a name="program listing for sample program 2"></a><font color="#ff0000">Program
Listing for Sample Program 2</font></h3></center>
This section contains a complete listing of the program.
<br>&nbsp;
<table border bgcolor="#ffff99" ><tr><td><pre>/*File SwingEvent11.java Copyright 1998, R.G.Baldwin
Further illustrates use of AncestorListener on a JButton.
Also see SwingEvent10.java.

Illustrates that JButton objects are containers that&nbsp;
can contain other JButton objects.

This program stacks three JButton objects on top of one
another with the stack of three JButton objects being
placed on a JFrame object.

Running the program and carefully clicking each of the
three buttons in succession from the top of the stack to
the bottom of the stack, and then moving the JFrame object
on the screen produces the following output. Note that
some blank lines were manually inserted to make it easier
to follow this material.

Make JFrame visible
In ancestorAdded method
Event source: First Button
In ancestorAdded method
Event source: Second Button
In ancestorAdded method
Event source: Third Button

In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button

In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button

In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button
In ancestorMoved method
Event source: Third Button

In actionPerformed method
Event source: Third Button
In actionPerformed method
Event source: Second Button
In actionPerformed method
Event source: First Button

In ancestorMoved method
Event source: First Button
In ancestorMoved method
Event source: Second Button
In ancestorMoved method
Event source: Third Button


Tested using JDK 1.1.6 and Swing 1.0.1 under Win95.
**********************************************************/
import java.awt.*;
import java.awt.event.*;
import com.sun.java.swing.*;
import com.sun.java.swing.event.*;

public class SwingEvent11 {
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; GUI gui = new GUI();//instantiate a GUI
&nbsp; }//end main
}//end class SwingEvent11
//=======================================================//

//The following class is used to instantiate a&nbsp;
// graphical user interface object.
class GUI {
&nbsp; public GUI(){//constructor
&nbsp;&nbsp;&nbsp; //Create a new JFrame object, set size, title, etc.
&nbsp;&nbsp;&nbsp; JFrame displayWindow = new JFrame();
&nbsp;&nbsp;&nbsp; displayWindow.setSize(300,100);
&nbsp;&nbsp;&nbsp; displayWindow.setTitle("Copyright 1998, R.G.Baldwin");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Note required use of getContentPane() in following
&nbsp;&nbsp;&nbsp; // statement.
&nbsp;&nbsp;&nbsp; displayWindow.getContentPane().setLayout(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FlowLayout());
&nbsp;&nbsp;&nbsp; //Add window listener to terminate the program
&nbsp;&nbsp;&nbsp; displayWindow.addWindowListener(new WProc1());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create three JButton objects
&nbsp;&nbsp;&nbsp; JButton firstButton = new JButton("First Button");
&nbsp;&nbsp;&nbsp; JButton secondButton = new JButton("Second Button");
&nbsp;&nbsp;&nbsp; JButton thirdButton = new JButton("Third Button");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Stack the three JButton objects on top of one
&nbsp;&nbsp;&nbsp; // another.
&nbsp;&nbsp;&nbsp; firstButton.add(secondButton);
&nbsp;&nbsp;&nbsp; secondButton.add(thirdButton);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Register an AncestorListener object on each JButton
&nbsp;&nbsp;&nbsp; firstButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp; secondButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp; thirdButton.addAncestorListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyAncestorListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Register an ActionListener object on each JButton
&nbsp;&nbsp;&nbsp; firstButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp; secondButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp; thirdButton.addActionListener(new MyActionListener());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Add the JButton to the JFrame using content pane
&nbsp;&nbsp;&nbsp; displayWindow.getContentPane().add(firstButton);

&nbsp;&nbsp;&nbsp; System.out.println("Make JFrame visible");
&nbsp;&nbsp;&nbsp; displayWindow.setVisible(true);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //.....................................................//
&nbsp; //Begin inner class definitions

&nbsp; //The following listener is used to terminate the&nbsp;
&nbsp; // program when the user closes the frame.
&nbsp; class WProc1 extends WindowAdapter{
&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp; }//end class WProc1
&nbsp; //.....................................................//

&nbsp; //Define an AncestorListener class
&nbsp; class MyAncestorListener implements AncestorListener{
&nbsp;&nbsp;&nbsp; //Define three methods declared in AncestorListener
&nbsp;&nbsp;&nbsp; // interface.&nbsp; Note the required downcasting.
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorAdded(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In ancestorAdded method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)e.getSource()).getActionCommand());
&nbsp;&nbsp;&nbsp; }//end ancestorAdded()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorRemoved(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In ancestorRemoved method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)e.getSource()).getActionCommand());
&nbsp;&nbsp;&nbsp; }//end ancestorRemoved()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void ancestorMoved(AncestorEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In ancestorMoved method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)e.getSource()).getActionCommand());

&nbsp;&nbsp;&nbsp; }//end ancestorMoved
&nbsp; }//end class MyAncestorListener
&nbsp; //.....................................................//

&nbsp; //Define an ActionListener class
&nbsp; class MyActionListener implements ActionListener{
&nbsp;&nbsp;&nbsp; public void actionPerformed(ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In actionPerformed method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Event source: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)e.getSource()).getActionCommand());
&nbsp;&nbsp;&nbsp; }//end actionPerformed()
&nbsp; }//end class MyActionListener
&nbsp; //.....................................................//

}//end class GUI definition
//=======================================================//</pre></td></tr></table>
.
<br>-end-<!--end--></body></html>