<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">
<h2>
Plotting Engineering and Scientific Data using Java</h2>
<i>Baldwin shows you how write a generalized plotting program that can be  used to plot engineering and scientific data 
produced by any object that implements a very simple interface.</i><p><b>Published:</b>&nbsp; 
December 17, 2002<br><b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
<p>Java Programming Notes # 1468<ul >
<li>
<a href="#Preface">Preface</a></li>
<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Code</a></li>

<li>
<a href="#Run the program">Run the Program</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listings</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<p>
<font color="#FF0000"><b>Excellent language for engineering computations</b></font></p>
<p>Because of its platform independence, Java provides an excellent programming 
language for engineering and scientific computational experiments, particularly 
where extreme execution speed is not a requirement.&nbsp; Programs developed for 
such experiments on one platform can be successfully executed on a variety of 
platforms without the need to rewrite or recompile.</p>
<p><font color="#FF0000"><b>A large Math library</b></font></p>
<p>Furthermore, because if its inherent simplicity, and the availability of a 
large <b>Math</b> library, Java provides an excellent programming language for 
engineers and scientists who want to do their own programming, but who have no 
desire to become programming experts.&nbsp; The code required to conduct an 
engineering or scientific computational experiment often consists of little more 
than the most rudimentary application of arithmetic in loops using data stored 
in arrays or read from disk files.</p>
<p><font color="#FF0000"><b>Now for the bad news</b></font></p>
<p>However, there is a downside to this happy story.&nbsp; When doing this sort of 
work, it is often very important to see the results of the experiments in the 
form of graphs or plots.&nbsp; Unfortunately, the programming required to 
produce graphical output from simple engineering and scientific computational 
experiments cannot be accomplished using rudimentary programming techniques.&nbsp; 
Rather, to do that job right requires considerable expertise in Java 
programming.</p>
<p><font color="#FF0000"><b>A generalized plotting program</b></font></p>
<p>This lesson develops a generalized plotting program, which is easy to connect 
to other programs, <i>(whether they are simple or complex),</i> in order to 
display the output from those programs in two-dimensional
<a href="http://mathworld.wolfram.com/CartesianCoordinates.html">Cartesian 
coordinates</a>.&nbsp; The plotting program is specifically designed to be 
useful to persons having very little knowledge of Java programming.</p>
<blockquote>
<p><i>(Actually, the lesson develops two very similar plotting programs each 
designed to display the data in a different format.)</i></p>
</blockquote>
<p>
<b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings and figures while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at <font color="#000000">
<a href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>Figure 1 shows a typical display produced by one of the plotting programs that I will 
develop in this lesson.&nbsp; <i>(The other program superimposes all of the 
curves on the same set of axes instead of spacing them vertically as shown in 
Figure 1.)</i></p>
<p align="center"><img border="0" src="java1468a.gif" width="401" height="431"></p>
<p align="center">Figure 1&nbsp; Sample Display</p>
<p>While the plotting program itself is quite complex, the code required to 
produce the data to be plotted can be very simple.&nbsp; For example, because of the use of the Java <b>Math</b> library, only fourteen lines of 
simple Java code were required to produce the data plotted in Figure 1.</p>
<p><font color="#FF0000"><b>The Graph01Demo program</b></font></p>
<p>The data displayed in Figure 1 was produced by a program named <b>Graph01Demo</b>.&nbsp; 
A listing of that program is shown in Listing 37 near the end of the lesson.&nbsp; 
I will explain that program in detail shortly.&nbsp; </p>
<p><font color="#FF0000"><b>A more substantive example</b></font></p>
<p>In addition, I will provide and discuss another sample program, which 
produces and plots data having considerably more engineering and scientific 
significance than the data shown in Figure 1.&nbsp; <i>(This will be a digital 
signal processing (DSP) example).&nbsp; </i>Even in that case, you will see that 
the program that produces the data is much less complex than the program used to 
plot the data.</p>
<p><font color="#FF0000"><b>Using the plotting program with your data</b></font></p>
<p>During the course of this lesson, I will explain everything that you will 
need to know to cause the output from your own engineering and scientific programs to be 
displayed by the plotting program.</p>
<p><font color="#FF0000"><b>The Graph01 program</b></font></p>
<p>The graphical display of the data shown in Figure 1 was produced by my 
generalized plotting program named <b>Graph01</b>.&nbsp; As you will see later, 
this  is a long and fairly complex program.</p>
<p>A listing of the plotting program is shown in Listing 39 near the end of the 
lesson.</p>
<p><font color="#FF0000"><b>User needn't understand the plotting program</b></font></p>
<p>Fortunately, the user of the plotting program doesn't need to understand 
anything about the code that makes up the plotting program.&nbsp; All the user 
needs to understand is the interface to the program, which I will explain later.</p>
<p>However, for those of you who may be interested, I will also discuss and 
explain the plotting 
program later in this lesson.&nbsp; </p>
<p><font color="#FF0000"><b>Plotting format</b></font></p>
<p>As you can see in Figure 1, the plotting program allows for plotting up to 
five independent functions stacked vertically, each with the same vertical and horizontal 
axes.&nbsp; This vertical 
stacking format makes it easy to compare up to five plots at the same points on 
the horizontal axes.</p>
<p>If you need more than five functions, the number of functions can easily be 
increased with a few minor changes to the program.</p>
<blockquote>
  <p><i>(I will also provide, but will not discuss, another version of the 
  program, named Graph02, which superimposes up to five plots on the same 
  coordinate system.&nbsp; In some cases, that is a more useful form of 
  display.&nbsp; You will find a complete listing of this program in Listing 40 
  near the end of the lesson.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Plotting parameters</b></font></p>
<p>As you can also see in Figure 1, a set of text fields and a button on the 
bottom of the frame make it possible for the user to modify the plotting 
parameters and to re-plot the same data with an entirely new set of plotting 
parameters.</p>
<blockquote>
  <p><i>(It is often true that important but subtle pieces of information can 
  only be exposed by viewing the same data with different sets of plotting 
  parameters.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Same data, different parameters</b></font></p>
<p>Figure 2 shows the same data as in Figure 1, but plotted with a different set 
of plotting parameters.</p>
<p align="center"><img border="0" src="java1468b.gif" width="401" height="431"></p>
<p align="center">Figure 2 Sample Display for Same Data with Different Plotting 
Parameters</p>
<p>In the case of Figure 2, the origin was moved to the left, the total expanse of the horizontal 
axis was increased, and the space between the tic marks on the vertical axis was 
increased from 20 units to 50 units.</p>
<blockquote>
  <p><i>(It will help you to see the differences if you will position two 
  browser windows side-by-side while viewing one display in one browser window 
  and viewing the other display in the other browser window.)</i></p>
</blockquote>
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2></center>

<p><font color="#FF0000"><b>Testing the plotting program</b></font><p>I am assuming that you have accomplished the minimal steps required to get 
the Java <a href="http://java.sun.com/j2se/1.4/">SDK</a> that is available from Sun up and running.</p>
<p>To run the plotting program named <b>Graph01</b> in self-test mode, do the 
following:</p>
<ul>
  <li>Copy the code in Listing 39 into a file named <b>Graph01.java</b>.</li>
  <li>Copy the code in Listing 1 into a file named <b>GraphIntfc.java</b>, and 
  put that file in the same directory as the file named <b>Graph01.java</b> 
  above.</li>
  <li>Compile the program named<b> Graph01.java </b>using the Java <a href="http://java.sun.com/j2se/1.4/">SDK</a>.&nbsp; <i>(Note, you must be using SDK version 1.4 or later.)</i></li>
</ul>
At this point, you should be able to execute the program named <b>Graph01</b> in 
self-test mode by entering the following command at the command prompt in the 
same directory where you compiled the program:<p><b>java Graph01</b></p>
<p>If everything has been done correctly up to this point, the display shown in 
Figure 4 should appear on your screen.</p>
<p><font color="#FF0000"><b>Using the plotting program</b></font></p>
<p>To use the plotting program with your own data generator program, do the 
following:</p>
<ul>
  <li>Still working in the same directory, define and compile a data generator class that implements the interface named
<b>GraphIntfc01</b>, shown in Listing 1.</li>
  <li>Start the plotting program named <b>Graph01</b> running by following the 
  instructions that I will provide below.</li>
</ul>
<p><font color="#FF0000"><b>Plotting your data using Graph01</b></font></p>
<p>Assume that your data-generator class is named <b>MyData</b>, and that you 
have successfully compiled it in the same directory as the compiled version of
<b>Graph01</b>.</p>
<p>The next step is to  enter the following command at the command prompt in the 
same directory.&nbsp; <i>(Note that this command differs from the command given 
earlier.&nbsp; This command provides the name of your class as a command-line 
parameter following the name of the plotting program.)</i></p>
<p><b>java Graph01 MyData</b></p>
<p>When you do this, the plotting program should start pulling the 
necessary data from your data-generator program and plotting that data in the 
format shown in Figure 1.</p>
<p><font color="#FF0000"><b>Modifying plotting parameters</b></font></p>
<p>Once all the curves have been plotted, you can change any of the plotting parameter 
values in the text fields at the bottom of the display and press the button 
labeled <b>Graph</b>.&nbsp; When you press the button, the plotting program will 
re-plot your data 
using the new plotting parameters.</p>
<p><font color="#FF0000"><b>The plotting parameters</b></font></p>
<p>Here is the meaning of the plotting-parameter text fields shown in Figure 1:</p>
<ul>
  <li>xMin and xMax - The values of the left and right ends of all horizontal 
  axes.</li>
  <li>yMin and yMax - The values of the bottom and top of the vertical axis in 
  each plotting area.&nbsp; <i>(Note that the different plotting areas are 
  identified by alternating white and gray backgrounds.)</i></li>
  <li>xTicInt - The distance between tic marks on the x-axis.</li>
  <li>yTicInt - The distance between tic marks on the y-axis.</li>
  <li>xCalcInc - The distance between the points on the x-axis where values for 
  y are computed.&nbsp; <i>(Unless your data-generator program is taking too 
  long to run, you should probably leave this set to 1.0 in order to get the 
  best quality plots.)</i></li>
</ul>
<p><font color="#FF0000"><b>The labels on the axes</b></font></p>
<p>Each x-axis has a label at the left end and the right end.&nbsp; Similarly, 
each y-axis has a label at the bottom and the top.&nbsp; These labels represent 
the values at the extreme ends of the axes.&nbsp; For example in Figure 2, the 
label 800 appears at the right end of each x-axis.&nbsp; This is value of the 
x-axis where the axis intersects the border of the frame.</p>
<p><font color="#FF0000"><b>Keep the pixels in mind</b></font></p>
<p>When adjusting the plotting parameters, keep in mind that  the 
total width of each of the plotting areas is slightly less than 400 pixels.</p>
<blockquote>
<p><i>(You can easily increase this to full screen width by changing one value 
in the <b>Graph01</b> program and recompiling the program).</i></p>
</blockquote>
<p>While you can theoretically make the horizontal expanse of the x-axes as wide 
as you wish, because of the pixel limitation, you cannot see details that 
require a resolution of more than 400 points along the x-axis <i>(unless you 
modify the program as described above).</i></p>
<p><font color="#FF0000"><b>The interface named GraphIntfc01</b></font></p>
<p>Regardless of its simplicity or its complexity, there are only two requirements for your data-generator program to operate 
successfully with the plotting program named <b>Graph01</b>:</p>
<ol>
  <li>It must implement the interface named <b>GraphIntfc01</b>.</li>
  <li>It must have a constructor that doesn't require any parameters <i>(the 
  default constructor will satisfy that requirement if you don't need another 
  constructor).</i></li>
</ol>
<p><font color="#FF0000"><b>Implementing GraphIntfc01</b></font></p>
<p>All that is required to implement the interface is to define a class that 
provides a concrete definition for the six methods declared in Listing 1.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public interface GraphIntfc01{
  public int getNmbr();
  public double f1(double x);
  public double f2(double x);
  public double f3(double x);
  public double f4(double x);
  public double f5(double x);
}//end GraphIntfc01

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The getNmbr method</b></font></p>
<p>On several occasions, I have stated that the plotting program can plot up to 
five functions.&nbsp; However, it doesn't have to plot all five functions.&nbsp; 
The plotting program can be used to plot any number of functions from one to five.</p>
<p>The method named <b>getNmbr</b> must return an integer value between 1 and 5 
that specifies the number of functions to be plotted.&nbsp; The plotting program 
uses that value to divide the total plotting surface into the specified 
number of plotting areas, and plots each of the functions named <b>f1</b> 
through <b>fn</b> in one of those 
plotting areas.</p>
<p><font color="#FF0000"><b>The methods named f1, f2, f3, f4, and f5</b></font></p>
<p>As you can see in Listing 1, each of these methods receives a <b>double</b> 
value as an incoming parameter and returns a <b>double</b> value.&nbsp; In 
essence, each of these methods receives a value for x and returns the 
corresponding value for y.</p>
<p><font color="#FF0000"><b>One plotting area per method</b></font></p>
<p>Each of these methods provides the data to be plotted in one plotting area.&nbsp; 
The method named <b>f1</b> provides the data for the top plotting area, the 
method named <b>f2</b> provides the data for the first plotting area down from 
the top, and so forth.</p>
<blockquote>
<p><i>(For example, if the <b>getNmbr</b> method returns a value of 4, the 
method named <b>f5</b> will never be invoked.&nbsp; If <b>getNmbr</b> returns 5, 
the method named <b>f5</b> will be invoked to provide the data for the bottom 
plotting area.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>How does it work?</b></font></p>
<p>Each plotting area contains a horizontal axis.&nbsp; The plotting program 
moves across the horizontal axis in each plotting area one step at a time <i>(moving in incremental 
steps equal to the plotting parameter named xCalcInc).</i></p>
<p>At each step along the way, the plotting program invokes the method 
associated with that plotting area, <i>(f1, f2, etc.),</i> passing the 
horizontal position as a parameter to the method.</p>
<p>The value returned by the method is assumed to be the vertical value 
associated with that horizontal position, and that is the vertical value that is 
plotted for that horizontal position.</p>
<p><font color="#FF0000"><b>Doesn't know and doesn't care</b></font></p>
<p>The plotting program doesn't know, and doesn't care how the method decides on 
the value to return for each value that it receives as an incoming parameter.&nbsp; 
The plotting program simply invokes the methods to get the data, and then plots 
the data.</p>
<p><font color="#FF0000"><b>Computed <i>&quot;on the fly&quot;</i></b></font></p>
<p>For example, the returned values could be computed and returned <i>&quot;on the 
fly,&quot;</i> as is the case in the example named <b>Graph01Demo</b>, which we will look at shortly.</p>
<p><font color="#FF0000"><b>Returned from an array</b></font></p>
<p>On the other hand, the values could have been computed earlier and saved in 
an array, as will be the case in the DSP example that we will look at later.</p>
<p><font color="#FF0000"><b>From a disk file, a database, the internet, etc.</b></font></p>
<p>The returned values could be read from a disk file, obtained from a database 
on another computer, or obtained from any other source such as another computer 
on the internet.</p>
<p>All that matters is that when the plotting program invokes one of the five 
methods named <b>f1</b> through <b>f5</b>, passing a <b>double</b> value as a 
parameter, it expects to receive a <b>double</b> value as a return value, and it 
will plot the value that it receives.</p>
<p><font color="#FF0000"><b>It is up to you</b></font></p>
<p>It is up to you, the author of the data-generator program, to decide how you 
will implement the methods named <b>f1</b> through <b>f5</b>.&nbsp; In some 
cases, the implementation may be simple.&nbsp; In other cases, the 
implementation may be more complex.&nbsp; The first case that we will examine is 
very simple.&nbsp; A subsequent case involving DSP is not so simple.</p>
<p><font color="#FF0000"><b>The class named Graph01Demo</b></font></p>
<p>Although this is a very simple class definition, I am going to break it up 
and discuss it in fragments in order to help you focus your attention on the 
important points.&nbsp; A complete listing of the class definition is shown in 
Listing 37 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Defining data-generator classes</b></font></p>
<p>This class is used to demonstrate how to write data-generator classes that will operate successfully with the program named
<b>Graph01</b>.</p>
<blockquote>
<p><i>(Figure 1 shows the display of the data produced by this class.&nbsp; You 
might want to refer to that figure while examining the code in this class.)</i></p>
</blockquote>
<p>Listing 2 shows the beginning of the class definition, which names the class, 
and specifies that the class implements the interface named <b>GraphIntfc01</b>.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>Graph01Demo</b> 
               implements <b>GraphIntfc01</b>{

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The number of functions to plot</b></font></p>
<p>Listing 3 shows the entire listing of the method named <b>getNmbr</b>.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public int getNmbr(){
    return 5;
  }//end getNmbr

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>
<p>Recall from above that this method must return an integer value between 1 and 
5, which tells the plotting program how many functions to plot.</p>
<p>This demonstration plots all five functions, as shown in Figure 1, so this method returns the value 
5.</p>
<p><font color="#FF0000"><b>The topmost plotting area</b></font></p>
<p>Listing 4 shows the entire method named <b>f1</b>, whose output is plotted in 
the topmost plotting area of the display in Figure 1.&nbsp; <i>(This is the area 
at the top with the white background.)</i></p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f1</b>(double x){
    return -(x*x)/200.0;
  }//end f1

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>
<p>This method receives an incoming parameter known locally as <b>x</b>.&nbsp; 
<i>(In all five methods defined in this class, the computations are performed on 
the fly.)</i>&nbsp; The method computes and returns the negative square of the incoming parameter
<i>(divided by 200).</i>&nbsp; This produces the inverted bowl shape 
at the top of Figure 1.</p>
<p><font color="#FF0000"><b>The top-most plotting area with a gray background</b></font></p>
<p>The curve plotted in the top-most plotting area with the gray background in Figure 
1 is produced by the method named <b>f2</b>, shown in Listing 5.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f2</b>(double x){
    return -(x*x*x)/200.0;
  }//end f2

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>
<p>As before, this function receives an incoming parameter known locally as <b>x</b>.&nbsp; 
The function computes and returns the negative cube of the incoming parameter <i>
(divided by 200).</i>&nbsp; This produces the curve shown in the top-most 
gray area of Figure 1.</p>
<p><font color="#FF0000"><b>The middle white plotting area</b></font></p>
<p>The method named <b>f3</b>, shown in Listing 6, produces the curve shown in 
the center plotting area with the white background in Figure 1.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f3</b>(double <b>x</b>){
    return 100*<b>Math.cos(x</b><b>/10.0)</b>;
  }//end f3

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>
<p>This is a simple cosine curve, which is computed on the fly.&nbsp; Each time 
the method is invoked, the incoming parameter named <b>x</b>, is used to 
calculate the cosine of an angle in radians given by one-tenth the value of <b>x</b>.&nbsp; 
The cosine of that angle is multiplied by 100 and returned.</p>
<blockquote>
<p><i>(Note that the cosine of the angle is computed using a static method of 
the standard Java class named <b>Math</b>.&nbsp; This is the class that contains 
the Java math library.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The bottom-most gray plotting area</b></font></p>
<p>The curve shown in the bottom-most gray plotting area of Figure 1 is produced by 
the method named <b>f4</b>, shown in Listing 7.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f4</b>(double x){
    return 100*Math.sin(x/20.0);
  }//end f4

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>
<p>The body of <b>f4</b> is similar to the body of <b>f3</b>, except that <b>f4</b> 
computes and returns sine values instead of cosine values.&nbsp; Also, the value 
of <b>x</b> is used differently so that the period of the curve produced by <b>
f4</b> is twice the period of the curve produced by <b>f3</b>.</p>
<p><font color="#FF0000"><b>The bottom white plotting area</b></font></p>
<p>Finally, the bottom white plotting area in Figure 1 shows the output produced 
by the method named <b>f5</b>, shown in Listing 8.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f5</b>(double x){
    return 100*(Math.sin(x/20.0)
              *Math.cos(x/10.0));
  }//end f5

}//end sample class Graph01Demo

<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>
<p>This method computes and returns the product of  sine and cosine functions 
identical to those discussed above.</p>
<p><font color="#FF0000"><b>The end of the class definition</b></font></p>
<p>Listing 8 also shows the closing curly brace that signifies the end of the 
class definition for the class named <b>Graph01Demo</b>.</p>
<p><font color="#FF0000"><b>That's all you need to know</b></font></p>
<p>That's really all that you need to know to be able to make effective use of 
the generalized plotting program named <b>Graph01</b>.&nbsp; If you can define 
the methods named <b>f1</b> through <b>f5</b>, which will return the required 
values for your computational experiment, then you can make use of this program 
to plot your data.</p>
<p><font color="#FF0000"><b>A more substantive example</b></font></p>
<p>However, lest you go away believing that this is all too trivial to be 
interesting, I am going to show you another example that is far from trivial.&nbsp; 
In the next example, I will demonstrate two of the most important operations in 
the field commonly referred to as digital signal processing, or DSP for short.</p>
<p>Because many of you are unlikely to be familiar with the techniques and 
terminology involved, the discussion will of necessity be fairly shallow.&nbsp; 
However, I do want to show at least one example of how you can perform 
substantive computational experiments using this approach.</p>
<p><font color="#FF0000"><b>A DSP example</b></font></p>
<p>A DSP example showing convolution filtering and spectral analysis is shown in 
Figure 3.</p>
<p align="center"><img border="0" src="java1468c.gif" width="401" height="431"></p>
<p align="center">Figure 3&nbsp; A Digital Signal Processing (DSP) Example</p>
<p>In the field of DSP, the five individual plots shown in the plotting areas of 
Figure 3 are commonly referred to as traces.&nbsp; I will use that terminology 
in this discussion.</p>
<p><font color="#FF0000"><b>White random noise</b></font></p>
<p>The top trace in the area with the white background shows about 256 samples 
of white random noise.&nbsp; When we get to the code, we will see that this data 
was created using a Java pseudo-random number generator.</p>
<p><font color="#FF0000"><b>A convolution filter</b></font></p>
<p>The second trace from the top shows a 33-point narrow-band convolution 
filter, which is simply a chunk taken out of a sinusoid whose frequency is 
one-fourth the sampling frequency.&nbsp; In other words, the sinusoid is 
represented by four samples per cycle.</p>
<p><font color="#FF0000"><b>The convolution filter output</b></font></p>
<p>The middle trace shows the result of applying the narrow-band convolution 
filter to the white noise.&nbsp; The output from the convolution process was 
amplified to bring it back into 
an appropriate amplitude range for visual analysis.</p>
<p>If you compare the middle trace with the top trace, you will notice that much 
of the high-frequency energy and much of the low-frequency energy has been 
removed.&nbsp; Most of the energy in the middle trace appears to be about the 
same frequency as the frequency of the convolution filter <i>(which is what we 
would expect).</i></p>
<p><font color="#FF0000"><b>Time-domain vs. frequency-domain</b></font></p>
<p>The top three traces represent information in the time domain.&nbsp; The 
bottom two traces represent information in the frequency 
domain.</p>
<blockquote>
<p><i>(Think of the frequency domain as the information that is visible on many 
audio systems, consisting of parallel vertical bars with lights that dance up 
and down.&nbsp; These lights are often associated with a device  referred to as a frequency equalizer.&nbsp; When the music contains a lot of 
drums, or other sounds at the bass end, the lights at the low (usually left) end of the 
frequency spectrum are very active.&nbsp; When the music contains a lot of 
symbols, or sounds at the treble end, the lights at the high (right) end of the 
frequency spectrum are very active.&nbsp; That is a form of real-time spectrum 
analysis.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Frequency spectrum analysis</b></font></p>
<p>The two bottom traces in Figure 3 result from performing frequency spectrum analysis on 
the top trace and the middle trace respectively.</p>
<p><font color="#FF0000"><b>The white noise spectrum</b></font></p>
<p>The trace in the gray area immediately below the center is an estimate of the 
spectral distribution of the white noise in the top trace.&nbsp; The spectrum 
analysis was performed across the frequency range from zero frequency to the 
sampling frequency.</p>
<p>While not perfectly flat, as would be the case for perfectly <i>white</i> 
noise, you can see that the energy appears to be distributed across that entire 
range.</p>
<blockquote>
<p><i>(If we wanted to improve our estimate, we could capture and analyze a much 
longer sample of the white noise.)</i></p>
</blockquote>
<p>If you examine this trace carefully, you might notice that there is a point 
of near symmetry in the middle.&nbsp; The values that you see above that point 
are a mirror-image of the values that you see below that point.&nbsp; <i>(I will 
have more to say about this later.)</i></p>
<p><font color="#FF0000"><b>The filtered noise spectrum</b></font></p>
<p>The bottom trace shows an estimate of the spectral distribution of the 
filtered noise in the center trace.&nbsp; Again, the spectrum analysis was 
performed across the frequency range from zero frequency to the sampling 
frequency.&nbsp; Again also, there is a 
symmetry point in the middle with everything to the right of that point being a 
mirror image of everything to the left of that point.</p>
<p><font color="#FF0000"><b>Two spectral peaks are visible</b></font></p>
<p>Unlike the spectral analysis of the white noise, this spectral analysis shows 
two obvious peaks.&nbsp; One peak appears at one-fourth the sampling frequency, 
and the other peak appears at three-fourths the sampling frequency.</p>
<p>In other words, as we concluded from examining the center trace, the 
filtering process removed much of the energy above and below the design 
frequency of the convolution filter.</p>
<blockquote>
<p><i>(By changing the design frequency of the convolution filter, and repeating 
the process, we could move this peak up or down along the frequency axis.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does the symmetry mean?</b></font></p>
<p>Without getting into a lot of detail at this point, the point of symmetry 
that I identified above is known as the Nyquist folding frequency.</p>
<p>In order to be able to identify the frequency of a sine wave, you must have 
at least two samples per cycle of the sine wave.&nbsp; The Nyquist folding 
frequency is the frequency at which you have exactly two samples per cycle.</p>
<p>As the frequency of the sine wave continues to increase beyond that point, 
without a corresponding change in the sampling frequency, it is impossible to 
determine from the samples so obtained whether the frequency is increasing or 
decreasing.</p>
<p><font color="#FF0000"><b>An ambiguity in the spectrum analysis</b></font></p>
<p>As a result, the spectrum analysis process was unable to determine if the 
peak in the frequency spectrum was below or above the folding frequency.&nbsp; 
Thus, the bottom trace in Figure 3 shows two peaks which are mirror images of 
one another with the folding frequency being half way between the two peaks.</p>
<blockquote>
<p><i>(As a practical matter, when doing spectrum analysis, there is no point in 
computing the values above the folding frequency.&nbsp; I did that here just to 
illustrate that there is a folding frequency, which is equal to one-half the 
sampling frequency.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Let's see some code</b></font></p>
<p>The class used to produce the data displayed in Figure 3 is named <b>Dsp002</b>.&nbsp; 
A complete listing of this class definition is shown in Listing 38 near the end 
of the lesson.</p>
<p>I will break this class up into fragments and briefly discuss it to show how 
you can define significant classes and easily connect them to the generalized 
plotting program named <b>Graph01</b>.</p>
<p>As before, having compiled the class named Dsp002, you would exercise it by 
entering the following at a command prompt:</p>
<p><b>java Graph01 Dsp002</b></p>
<p><font color="#FF0000"><b>Different from the previous example class</b></font></p>
<p>This class differs from the class named <b>Graph01Demo</b> in one very 
significant way.&nbsp; In that class, all the values returned by the methods 
named <b>f1</b> through <b>f5</b> were computed on the fly as the methods were 
called.</p>
<p>In this new class named <b>Dsp002</b>, all the data is generated and stored 
in array objects when an object of the class named <b>Dsp002</b> is 
instantiated.&nbsp; When the methods named <b>f1</b> through <b>f5</b> are 
invoked later, they simply retrieve the data from the array objects and return 
that data to the plotting program.</p>
<p><font color="#FF0000"><b>Basic operation of the program</b></font></p>
<p>As mentioned earlier, this program applies a narrow-band convolution filter to white noise, and then computes the amplitude spectrum of the filtered 
noise using a  Discrete Fourier Transform (DFT) algorithm.&nbsp; The spectrum of the white noise is also computed.&nbsp; 
All of the processing occurs when an object of the class is instantiated, and 
the processed results are saved in arrays.</p>
<p>The input noise, the filter, the filtered output, and the two spectra are deposited in five arrays for later retrieval and display.&nbsp; 
The data in the five arrays are returned by the methods named f1, f2, f3, f4, and f5 respectively.</p>
<p>The values that are returned by the methods are scaled for appropriate display in the plotting areas provided by the program named 
<b>Graph01</b>.</p>
<p><font color="#FF0000"><b>Data and filter lengths</b></font></p>
<p>The code in Listing 9 establishes the data lengths for the white noise, the 
convolution filter, the filtered output, and the spectrum.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class Dsp002 implements GraphIntfc01{
  int operatorLen = 33;
  int dataLen = 256+operatorLen;
  int outputLen =
                 dataLen - operatorLen;
  int spectrumPts = outputLen;

<data.length;
                                cnt++){
      //Get data, scale it, remove the
      // dc offset, and save it.
      data[cnt] = 100*generator.
                       nextDouble()-50;
    }//end for loop

    //Create a convolution operator and
    // save it in the array.
    for(int cnt = 0; cnt < operatorLen;
                                cnt++){
      //Note, the value of the
      // denominator in the argument
      // to the cos method specifies
      // the frequency relative to the
      // sampling frequency.
      operator[cnt] = Math.cos(
                      cnt*2*Math.PI/4);
    }//end for loop

    //Apply the operator to the data
    Convolve01.convolve(data,dataLen,
          operator,operatorLen,output);

    //Compute DFT of the raw data and
    // save it in spectrumA array.
    Dft01.dft(data,spectrumPts,
                            spectrumA);

    //Compute DFT of the filtered data
    // and save it in spectrumB array.
    Dft01.dft(output,spectrumPts,
                            spectrumB);
    //All of the data has now been
    // produced and saved.  It may be
    // retrieved by invoking the
    // following methods named f1
    // through f5.

  }//end constructor

  //---------------------------------//
  //The following six methods are
  // required by the interface named
  // GraphIntfc01.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr
  //---------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    //This version of this method
    // returns the random noise data.
    // Be careful to stay within the
    // array bounds.
    if(index < 0 ||
                index ><dataLen-operatorLen;
                                  i++){
      output[i] = 0;
      for(int j=operatorLen-1;j><dataLen;i++){
      double freq = i*delF;
      double real = 0;
      double imag = 0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0;j<dataLen;j++){
        real += data[j]*Math.cos(
                     2*Math.PI*freq*j);
        imag += data[j]*Math.sin(
                     2*Math.PI*freq*j);
        spectrum[i] = Math.sqrt(
                real*real + imag*imag);
      }//end inner loop
    }//end outer loop
  }//end dft

}//end Dft01

//===================================//

<b><b><font face="Courier New,Courier">Listing 9</font></b></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Create data arrays</b></font></p>
<p>The code in Listing 10 creates the array objects that will be used to store 
the data until it is retrieved by the methods named <b>f1</b> through <b>f5</b>.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  double[] data = new double[dataLen];
  double[] operator =
               new double[operatorLen];
  double[] output =
                 new double[outputLen];
  double[] spectrumA =
               new double[spectrumPts];
  double[] spectrumB =
               new double[spectrumPts];

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Generate and save the white noise</b></font></p>
<p>Most of the hard work is done by the constructor or by methods called by the 
constructor.</p>
<p>The code in Listing 11 generates and saves the white noise in the array 
object named <b>data</b>.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public Dsp002(){//constructor
    Random generator = new Random(
                 new Date().getTime());
    for(int cnt=0;cnt < data.length;
                                cnt++){
      //Get data, scale it, remove the
      // dc offset, and save it.
      data[cnt] = 100*generator.
                       nextDouble()-50;
    }//end for loop

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The random noise generator seed</b></font></p>
<p>Note that by virtue of the way this white noise is being generated, a 
different seed is passed to the constructor for the <b>Random</b> class each 
time an object of the <b>Dsp002</b> class is instantiated.&nbsp; Thus, each new 
object presents different random noise.</p>
<blockquote>
<p><i>(In some cases, this may not be 
desirable and it may be preferable to use the same seed each time an object is 
instantiated.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Create the convolution operator</b></font></p>
<p>The code in Listing 12 creates the 33-point convolution operator, as a 
segment of a cosine wave, and saves it in the designated array.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    for(int cnt = 0; cnt < operatorLen;
                                cnt++){
      operator[cnt] = Math.cos(
                      cnt*2*Math.PI/4);
    }//end for loop

<b><font face="Courier New,Courier">Listing 12</font></b></pre>
</td>
</tr>
</table>
<p>Note that the constant value of 4 in the denominator of the argument to the
<b>cos</b> method specifies the frequency of the cosine wave relative to the 
sampling frequency.&nbsp; <i>(In this case, the frequency of the cosine wave is 
one-fourth the sampling frequency.)</i></p>
<p><font color="#FF0000"><b>Apply the convolution operator</b></font></p>
<p>The code in Listing 13 invokes a static method named <b>convolve</b> in a 
class named <b>Convolve01</b> to apply the convolution operator to the white 
noise and save the filtered result in the appropriate array.&nbsp; I will 
briefly discuss this method later.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    Convolve01.<b>convolve</b>(data,dataLen,
          operator,operatorLen,output);

<b><font face="Courier New,Courier">Listing 13</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Compute the spectrum of the two traces</b></font></p>
<p>The code in Listing 14 invokes a static method named <b>dft</b> of a class 
named <b>Dft01</b> twice in succession to compute the spectra for the white 
noise and the filtered noise, and to save those spectra in the appropriate 
arrays.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    Dft01.<b>dft</b>(data,spectrumPts,
                            spectrumA);

    Dft01.<b>dft</b>(output,spectrumPts,
                            spectrumB);
  }//end constructor

<b><font face="Courier New,Courier">Listing 14</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>All results have been computed and saved</b></font></p>
<p>That is the end of the constructor.&nbsp; At this point, all the results have been computed and saved in the appropriate 
arrays for later retrieval by the methods named <b>f1</b> through <b>f5</b>.</p>
<p>The object is simply setting in 
memory waiting to have its encapsulated data retrieved and plotted.</p>
<p><font color="#FF0000"><b>The getNmbr method</b></font></p>
<p>The <b>getNmbr</b> method for this class is exactly the same as for the class 
discussed earlier.&nbsp; As before, it returns the integer value 5, telling the 
plotting program that there are five plots to be generated.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public int getNmbr(){
    return 5;
  }//end getNmbr

<b><font face="Courier New,Courier">Listing 15</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The method named f1</b></font></p>
<p>The method named <b>f1</b> is representative of all five of the methods named
<b>f1</b> through <b>f5</b> in this class.&nbsp; Therefore, I will discuss only 
the first of the five methods in detail.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public double <b>f1</b>(double x){
    int index = (int)Math.round(x);

    if(index < 0 ||
                index > data.length-1){
      return 0;
    }else{
      return data[index];
    }//end else
  }//end f1

<b><font face="Courier New,Courier">Listing 16</font></b></pre>
</td>
</tr>
</table>
<p>In all five cases, the purpose of the method is to fetch and return a value 
from an array, where the incoming parameter will be converted to an array index.</p>
<p><font color="#FF0000"><b>Convert incoming parameter to an index</b></font></p>
<p>The incoming parameter is received as type <b>double</b>.&nbsp; However, an 
array must be indexed using type <b>int</b>.&nbsp; The first statement in the 
method invokes the <b>round</b> method of the <b>Math</b> class to convert the
<b>double</b> value to the nearest integer.&nbsp; That integer will be used as 
an array index.</p>
<p><font color="#FF0000"><b>Stay within array bounds</b></font></p>
<p>Following this, the method applies some logic to confirm that the index value 
is within the bounds of the array.&nbsp; If not, the method returns the value 0.</p>
<p>If the index is within the array bounds, the method retrieves and returns the 
value stored at that index location in the array.</p>
<p>And that's all there is to it.</p>
<p><font color="#FF0000"><b>Methods f2 through f5</b></font></p>
<p>Except for the scale factors applied to the data before returning it, the 
behavior of the methods named <b>f2</b> through <b>f5</b>, is essentially the 
same as the behavior of the method named <b>f1</b>.&nbsp; In each case, the 
method retrieves, scales, and returns a value previously stored in an array.&nbsp; 
Therefore, I won't discuss these other methods.&nbsp; You can view them in 
Listing 38 near the end of the lesson.</p>
<p>And that ends the definition of the class named <b>Dsp002</b>.</p>
<p><font color="#FF0000"><b>The class named Convolve01</b></font></p>
<p>The entire class named <b>Convolve01</b> is shown in Listing 17.</p>
<p>If you already understand convolution, you will probably find the code in 
this class straightforward.&nbsp; If not, the code will probably still be 
straightforward, but the reason for the code may be obscure.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class Convolve01{
  public static void convolve(
                     double[] data,
                     int dataLen,
                     double[] operator,
                     int operatorLen,
                     double[] output){
    //Apply the operator to the data,
    // dealing with the index
    // reversal required by
    // convolution.
    for(int i=0;
          i < dataLen-operatorLen;i++){
      output[i] = 0;
      for(int j=operatorLen-1;j>=0;
                                  j--){
        output[i] +=
                 data[i+j]*operator[j];
      }//end inner loop
    }//end outer loop
  }//end convolve method
}//end Class Convolve01

<b><font face="Courier New,Courier">Listing 17</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Making a long story short</b></font></p>
<p>To make a long story short, the class named <b>Convolve01 </b>provides a 
static method named <b>convolve</b>, which applies an incoming convolution 
operator to an incoming set of data and deposits the filtered data in an output 
array whose reference is received as an incoming parameter.</p>
<p>This class could easily be broken out and put in a library as a stand-alone 
class, or the <b>convolve</b> method could be added to a class containing a 
variety of DSP methods.</p>
<p><font color="#FF0000"><b>The discrete Fourier transform (DFT)</b></font></p>
<p>The entire class named <b>Dft01</b> is shown in Listing 
18.</p>
<p>As with convolution, if you already understand the discrete Fourier 
transform, you will probably find the code in this class to be straightforward.&nbsp; 
If not, the code will probably still be straightforward, but the reasons for the 
code may be obscure.&nbsp; Since the purpose of this lesson is not to explain 
digital signal processing concepts, I won't attempt to provide a detailed 
explanation for 
the code in this method.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class Dft01{
  public static void dft(
                    double[] data,
                    int dataLen,
                    double[] spectrum){
    //Set the frequency increment to
    // the reciprocal of the data
    // length.  This is convenience
    // only, and is not a requirement
    // of the DFT algorithm.
    double delF = 1.0/dataLen;
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i < dataLen;i++){
      double freq = i*delF;
      double real = 0;
      double imag = 0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j < dataLen; j++){
        real += data[j]*Math.cos(
                     2*Math.PI*freq*j);
        imag += data[j]*Math.sin(
                     2*Math.PI*freq*j);
        spectrum[i] = Math.sqrt(
                real*real + imag*imag);
      }//end inner loop
    }//end outer loop
  }//end dft

<b><font face="Courier New,Courier">Listing 18</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Brief explanation</b></font></p>
<p>Once again, to make a long story short, this class provides a static method named
<b>dft</b>, which computes and returns the amplitude spectrum of an incoming time series.</p>
<p>The amplitude spectrum is computed as the square root of the sum of the squares of the real and imaginary parts.</p>
<p>A DFT algorithm can compute any number of points in the frequency domain.&nbsp; 
In this case, the number of points computed in the frequency domain is equal to the number of samples in the incoming time series, 
which is a fairly common practice.</p>
<p>The method deposits the frequency data in an array whose reference is received as an incoming parameter.</p>
<p>As with convolution, this class could easily be broken out and put in a library as a stand-alone class, or the
<b>dft</b> method could be added to a class containing a variety of DSP methods.</p>
<p><font color="#FF0000"><b>The plotting programs</b></font></p>
<p>Now that you have examined the examples, some of you may be interested in an explanation of the plotting program itself.</p>
<p>If you are interested only in how to use the plotting programs, and are not 
interested in the details of the plotting programs, skip ahead to the section 
entitled <a href="#Run the program">Run the Program</a>.</p>
<p>If you are interested in learning how the plotting programs do what they do, 
keep reading.</p>
<p><font color="#FF0000"><b>Two plotting programs</b></font></p>
<p>Two very similar plotting programs are shown in the listings near the end of 
the lesson.&nbsp; The program named <b>Graph01</b>, shown in Listing 39, can be used to plot 
as many as five separate functions, each in its own plotting area.&nbsp; 
Examples of the display produce by this program are shown in Figures 1, 
2,  3, and 4.&nbsp; I will briefly discuss this program in the paragraphs that 
follow.</p>
<p>The program named <b>Graph02</b>, shown in Listing 40, can also be used to plot 
as many as five 
separate functions.&nbsp; In this case, however, the graphs produced by the functions are 
superimposed in the same plotting area.&nbsp; This is simply an alternative 
display format.&nbsp; I won't discuss any of the 
particulars of this program, but if you understand the program named <b>Graph01</b>, 
you will have no difficulty understanding this program named<b> Graph02 </b>well.</p>
<p><font color="#FF0000"><b>The program named Graph01</b></font></p>
<p>This program is designed to access a class file that implements the interface 
named <b>GraphIntfc01</b>, and to plot up to five functions defined in that 
class file.</p>
<p>The methods in the class corresponding to the functions to be plotted are named
<b>f1</b>, <b>f2</b>, <b>f3</b>, <b>f4</b>, and <b>f5</b>.</p>
<p>As you learned in the earlier discussion, the class containing the functions must
also define a static method named 
<b>getNmbr</b>.&nbsp; This method takes no parameters 
and returns the number of functions to 
be plotted.&nbsp; If this method returns a 
value greater than 5, a <b>NoSuchMethodException</b> will be thrown.</p>
<p><font color="#FF0000"><b>Separate plotting areas</b></font></p>
<p>The overall plotting surface is divided into the required number of equally sized plotting areas.&nbsp; 
One function is plotted on 
Cartesian coordinates in
each plotting area.</p>
<p><font color="#FF0000"><b>A noarg constructor is required</b></font></p>
<p>The constructor for the class
that implements <b>GraphIntfc01</b> must not
require any parameters.&nbsp; This is because the <b>newInstance</b> method of the
<b>Class</b> class is used to instantiate an object, based on a <b>String</b> 
provided as a command-line parameter.&nbsp; The <b>newInstance</b> method can 
only create objects using a noarg constructor.</p>
<p><font color="#FF0000"><b>Some methods may not be invoked</b></font></p>
<p>If the <b>getNmbr</b> method returns a value less
than 5, then the methods that will not be invoked begin with <b>f5</b> and work down toward <b>f1</b>.&nbsp; For example, if the 
value returned by <b>getNmbr</b> is 3, then the program will invoke the methods named <b>f1</b>, <b>f2</b>,
and <b>f3</b>.&nbsp; While the methods named <b>f4</b> and <b>f5</b> must exist 
in order to satisfy the interface, they won't be invoked.&nbsp; Therefore, it 
doesn't matter what those methods return as long as it is type <b>double</b>.</p>
<p><font color="#FF0000"><b>The visual appearance</b></font></p>
<p>As shown in Figure 1, the plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.</p>
<p>All curves are plotted in black.&nbsp; A Cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.</p>
<p>The Cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.</p>
<p>The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.</p>
<p><font color="#FF0000"><b>A test class</b></font></p>
<p>The program also compiles a test
class named <b>junk</b>, which contains the five required
methods plus the method named <b>getNmbr</b>.&nbsp;
This makes it easy to compile and test the program in a stand-alone mode.</p>
<p><font color="#FF0000"><b>Usage instructions</b></font></p>
<p>At runtime,  the name of the class that
implements the <b>GraphIntfc01</b> interface
must be provided as a command-line
parameter.</p>
<p>If the command-line parameter is
missing, the program instantiates an
object from the internal test class named
<b>junk</b> and plots the data provided by
that object.&nbsp; Thus, you can test the program by running it with no
command-line parameter.&nbsp; This will produce the display shown in Figure 4.</p>
<p align="center">
<img border="0" src="java1468d.gif" width="401" height="431"></p>
<p align="center">Figure 4&nbsp; Graphic Display for Self-Test Class</p>
<p>If the command-line parameter is provided, the program instantiates an object 
of the class whose name matches the parameter, and plots the data provided by 
that object.</p>
<p><font color="#FF0000"><b>Plotting parameters</b></font></p>
<p>This program provides the following
text fields for user input, along with
a button labeled <b>Graph</b>.&nbsp; This allows
the user to adjust the parameters and
re-plot the graph as many times as needed with as
many different plotting scales as may be needed:</p>
<ul>
  <li>xMin = minimum x-axis value</li>
  <li>xMax = maximum x-axis value</li>
  <li>yMin = minimum y-axis value</li>
  <li>yMax = maximum y-axis value</li>
  <li>xTicInt = tic interval on x-axis</li>
  <li>yTicInt = tic interval on y-axis</li>
  <li>xCalcInc = calculation interval</li>
</ul>
<p>The user can modify any of these
parameters and then press the <b>Graph</b>
button to cause the five functions
to be re-plotted according to the
new parameters.</p>
<p><font color="#FF0000"><b>A new object</b></font></p>
<p>Whenever the <b>Graph</b> button is pressed,
the event handler for that button instantiates a new
object of the class that implements
the <b>GraphIntfc01</b> interface.</p>
<p>Depending
on the nature of that class, this may
be redundant in some cases.&nbsp; However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).</p>
<blockquote>
<p><i>(I will show you how to eliminate this feature from the plotting program 
if you decide that it is unnecessary for your data.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Requires Java SDK 1.4 or later</b></font></p>
<p>This program uses constants that were
first defined in the <b>Color</b> class of
v1.4.0.&nbsp; Therefore, the program
requires v1.4.0 or later to compile and execute correctly.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will discuss this program in fragments.&nbsp; As mentioned earlier, a 
complete listing of the program is provided in Listing 39 near the end of the lesson.&nbsp; 
You should be able to copy and paste that code into your Java source file, and 
then compile and execute it successfully.</p>
<p><font color="#FF0000"><b>The class named Graph01</b></font></p>
<p>The entire class, including the <b>main</b> method is shown in Listing 19.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class Graph01{
  public static void <b>main</b>(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new <b>GUI</b>(args[0]);
    }else{
      //no command-line parameter given
      new <b>GUI</b>(null);
    }//end else
  }// end main
}//end class Graph01 definition

<b><font face="Courier New,Courier">Listing 19</font></b></pre>
</td>
</tr>
</table>
<p>The primary purpose of <b>main</b> method is to instantiate an object of the 
class named <b>GUI</b>.&nbsp; </p>
<p>In addition, the <b>main</b> method checks to see if the user provided a 
command-line parameter, and if so, passes it along to the constructor for the <b>
GUI</b> class.</p>
<p><font color="#FF0000"><b>The class named GUI</b></font></p>
<p>The beginning of the <b>GUI</b> class is shown in Listing 20.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>GUI</b> extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = -10.0;
  double xMax = 256.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 16.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 400;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;

<b><font face="Courier New,Courier">Listing 20</font></b></pre>
</td>
</tr>
</table>
<p>The code in Listing 20 declares and in some cases initializes several instance variables that are required later to support the plotting process.&nbsp; 
The comments and the names of the variables generally indicate the purpose of 
those variables.</p>
<p><font color="#FF0000"><b>The constructor for the GUI class</b></font></p>
<p>The beginning of the constructor for the GUI class is shown in Listing 21.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

<b><font face="Courier New,Courier">Listing 21</font></b></pre>
</td>
</tr>
</table>
<p>The main purpose of the code in Listing 21 is to instantiated the object that 
will provide the data to be plotted.&nbsp; If the user provided the name of a 
class as a command-line argument, an attempt will be made to create a <b>
newInstance</b> of that class.</p>
<blockquote>
<p><i>(In case you are unfamiliar with this approach, this is one way to create an object 
of a class whose name is specified as a <b>String</b> at runtime.)</i></p>
</blockquote>
<p>Otherwise, the code in Listing 21 will instantiate an object of the test 
class named <b>junk</b> <i>(to be discussed later).</i></p>
<p><font color="#FF0000"><b>Array to hold Canvas objects</b></font></p>
<p>Each of the separate plotting areas in Figure 1 is an object of a class that 
extends the <b>Canvas</b> class.&nbsp; The code in Listing 22 invokes the <b>
getNmbr</b> method on the new object to determine how many functions are to be 
plotted.&nbsp; Then it creates an array object to hold the requisite number of
<b>Canvas</b> objects.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number > 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

<b><font face="Courier New,Courier">Listing 22</font></b></pre>
</td>
</tr>
</table>
<p>Although the limit could easily be increased, this program  is 
currently limited to plotting the output from five functions.&nbsp; The code in Listing 22 
 
checks this limit and throws an exception if an attempt is made to plot 
more than five functions.</p>
<p><font color="#FF0000"><b>Routine GUI construction code</b></font></p>
<p>Although somewhat long and rather tedious, the code in Listing 23 is 
completely straightforward.&nbsp; This code continues with the construction of 
the GUI object, creating text fields, a button, etc.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

<b><font face="Courier New,Courier">Listing 23</font></b></pre>
</td>
</tr>
</table>
<p>Because of the routine nature of the code in Listing 23, I will let the 
comments suffice as an explanation.</p>
<p><font color="#FF0000"><b>The Canvas objects</b></font></p>
<p>If you refer back to Figure 1, you will see that from one to five <b>Canvas</b> 
objects are stacked vertically in the center of a frame.</p>
<p>This is accomplished by placing a <b>JPanel</b> object in the center of the 
frame, and setting the layout manager on the <b>JPanel</b> to <b>GridLayout</b>.&nbsp; 
The grid is defined as having one column and an unspecified number of rows.&nbsp; Then 
one <b>Canvas</b> object is placed in each cell of the grid, beginning at the 
top and working downward from the top, until the required number of <b>Canvas</b> 
objects have been placed in the grid.</p>
<p>This is accomplished by the code in Listing 24.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt < <b>number</b>; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop

<b><font face="Courier New,Courier">Listing 24</font></b></pre>
</td>
</tr>
</table>
<p>The code in Listing 24:</p>
<ul>
  <li>Creates the <b>JPanel</b> object, and sets its layout property to <b>
  GridLayout</b>.</li>
  <li>Creates the requisite number of objects of the <b>MyCanvas</b> class <i>
  (which extends Canvas),</i> setting the background colors of the panels 
  alternately to white and gray.</li>
  <li>Adds the <b>MyCanvas</b> objects to the cells in the grid.&nbsp; <i>(Note 
  that the constructor for each <b>MyCanvas</b> object receives an integer that specifies its 
  position in the stack of <b>MyCanvas</b> objects.&nbsp; We will see how that 
  information is used later.)</i></li>
</ul>
<p><font color="#FF0000"><b>More routine construction code</b></font></p>
<p>The code in Listing 25 is simply more routine code required to:</p>
<ul>
  <li>Finish the 
construction of the <b>GUI</b> object</li>
  <li>Set its location and size on the screen</li>
  <li>Make it visible</li>
</ul>
<p>Once again, I will let the <span lang="en-us"></span>comments serve as the 
explanation for this code.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph01, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();

<b><font face="Courier New,Courier">Listing 25</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Force a repaint</b></font></p>
<p>As you will see later, the actual plotting behavior of this program is defined by the code in an 
overridden version of the <b>paint</b> method in the <b>MyCanvas</b> class.&nbsp; 
I will discuss that code in some detail later.</p>
<p>One way to cause the code in the overridden <b>paint</b> method is to invoke 
the <b>repaint</b> method on a reference to a <b>MyCanvas</b> object.&nbsp; </p>
<p>The code in Listing 26 invokes the <b>repaint</b> method on each <b>MyCanvas</b> 
object in sequence, to guarantee that they are properly painted when the <b>GUI</b> object 
first becomes visible.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    for(int cnt = 0;
                  cnt < number; cnt++){
      canvases[cnt].<b>repaint</b>();
    }//end for loop

  }//end constructor

<b><font face="Courier New,Courier">Listing 26</font></b></pre>
</td>
</tr>
</table>
<p>Similar code will be used again later to cause the graphs to be repainted 
each time the user presses the <b>Graph</b> button in the bottom right corner of 
Figure 1.</p>
<p><font color="#FF0000"><b>End of the constructor</b></font></p>
<p>The code in Listing 26 also ends the constructor for the <b>GUI</b> object.&nbsp; When the constructor 
finishes execution, the GUI appears on the screen with all plotting areas 
properly painted.</p>
<p><font color="#FF0000"><b>Re-plotting the data</b></font></p>
<p>Listing 27 shows the beginning of the event handler that is registered on the 
button to cause the functions to be re-plotted.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

<b><font face="Courier New,Courier">Listing 27</font></b></pre>
</td>
</tr>
</table>
<p>The purpose of the event handler is to cause the functions to be re-plotted 
after the user changes the plotting parameters.</p>
<p><font color="#FF0000"><b>A new object of the target class</b></font></p>
<p>However, the code in Listing 27 goes beyond that.&nbsp; In particular, the 
code in Listing 27 creates a new object from which to get the data that is to be 
plotted.</p>
<p>In some cases, this may be required, depending on the nature of the class 
from which that object is instantiated.&nbsp; In other cases, it may not be 
necessary, and could slow down the re-plotting process.</p>
<p>If your class doesn't contain counters or other variables that need 
to be re-initialized whenever you re-plot, you could probably safely remove or disable the code in 
Listing 27.&nbsp; This will  make the program run faster, although my 
may not be able to see the difference.</p>
<p><font color="#FF0000"><b>The rest of the event handler</b></font></p>
<p>The remaining code in the event handler is shown in Listing 28.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt < number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed

<b><font face="Courier New,Courier">Listing 28</font></b></pre>
</td>
</tr>
</table>
<p>This code is very straightforward.&nbsp; It performs the following actions:</p>
<ul>
  <li>Get new plotting parameters from the text fields.</li>
  <li>Perform some calculations.</li>
  <li>Cause each of the <b>MyCanvas</b> objects to be repainted using the new 
  plotting parameters.</li>
</ul>
<p>Again, I will let the comments provide any necessary explanations.</p>
<p>That brings us to the most interesting part of the program, the extended <b>
Canvas</b> class.</p>
<p><font color="#FF0000"><b>The class named MyCanvas</b></font></p>
<p>The class named <b>MyCanvas</b> is an inner class of the <b>GUI</b> class, 
which is used to override the <b>paint</b> method in each of the plotting areas 
shown in Figure 1.&nbsp; </p>
<blockquote>
<p><i>(Virtually all graphics operations in Java, other than those involving 
standard GUI components, are implemented by overriding the <b>paint</b> method 
on an object.)</i></p>
</blockquote>
<p>The beginning of this class definition is shown in Listing 29.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor

<b><font face="Courier New,Courier">Listing 29</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Floating data vs. pixels</b></font></p>
<p>Most of the calculations in this program are performed on data of type <b>
double</b>.&nbsp; However, graphics operations are ultimately performed in terms 
integer numbers of pixels.&nbsp; The code in Listing 29 declares scale factors used later to 
convert from <b>double</b> values to integer pixel locations.</p>
<p><font color="#FF0000"><b>A simple constructor</b></font></p>
<p>The code in Listing 29 also defines the constructor, whose only purpose is to 
save an integer identifying the position of this object in the vertical stack of <b>
MyCanvas</b> objects.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>The beginning of the overridden <b>paint</b> method for the <b>MyCanvas</b> 
class is shown in Listing 30.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  //Override the paint method
  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);

<b><font face="Courier New,Courier">Listing 30</font></b></pre>
</td>
</tr>
</table>
<p>The code in Listing 30:</p>
<ul>
  <li>Calculates and saves the scale factors for converting from <b>double</b> 
  coordinate values to integer values in pixels.</li>
  <li>Moves the plotting origin to the correct location.</li>
  <li>Invokes a method to draw the axes <i>(in red)</i> on the <b>MyCanvas</b> 
  object.</li>
  <li>Sets the color to black for the remainder of the plotting activity on the 
  object.</li>
</ul>
<p><font color="#FF0000"><b>Get old values</b></font></p>
<p>The plotting process consists of drawing a straight line segment between two 
points.&nbsp; One of the points is defined by a pair of old coordinate values.&nbsp; 
The other point is defined by a pair of new coordinate values.</p>
<p>The code in Listing 31 initializes the beginning point for the plot.&nbsp; 
The initial value for the x-coordinate is the left edge of the plotting area.&nbsp; </p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;

    //Use the Canvas obj number to
    // determine which method to
    // invoke to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch

<b><font face="Courier New,Courier">Listing 31</font></b></pre>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The initial y-coordinate value</b></font></p>
<p>The initial value for the y-coordinate depends on which function is being 
plotted on the <b>MyCanvas</b> object.&nbsp; Recall that each <b>MyCanvas</b> 
object contains an instance variable that identifies its position in the 
vertical stack of <b>MyCanvas</b> objects.&nbsp; The <b>switch</b> statement in 
Listing 31 uses that information  to invoke one of the five methods 
named <b>f1</b> through <b>f5</b>.&nbsp; This gets the correct value for the y-coordinate 
based on the value of the x-coordinate.</p>
<p>The methods named <b>getTheX</b> and <b>getTheY</b> called by the code in 
Listing 31 convert the coordinate values from type <b>double</b> to integer 
values in pixels.</p>
<p>The method named <b>getTheY</b> also changes the sign on the data so that  positive y-values go up the screen rather than down the screen.</p>
<blockquote>
<p><i>(By default, positive vertical coordinate values go down the screen from 
top to bottom in Java.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Plot the points</b></font></p>
<p>The remainder of the overridden <b>paint</b> method is shown in Listing 32.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Now loop and plot the points
    while(xVal < xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1

      //Convert the x-value to an int
      // and draw the next line segment
      int x = getTheX(xVal);
      g.<b>drawLine</b>(oldX,oldY,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method

<b><font face="Courier New,Courier">Listing 32</font></b></pre>
</td>
</tr>
</table>
<p>The code in Listing 32 is relatively straightforward.&nbsp; This code simply 
iterates from the minimum x-value to the maximum x-value, invoking the 
appropriate method <i>(from <b>f1</b> through <b>f5</b>)</i> to get the new y values.&nbsp; 
In the process, it invokes the <b>drawLine</b> method of the <b>Graphics</b> 
class to connect the points.</p>
<p><font color="#FF0000"><b>The drawAxes method</b></font></p>
<p>As it turns out, it is  more difficult to draw and label the axes 
with tic marks than it is to plot the actual data.</p>
<p>The code to accomplish this is shown in Listing 33.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

<b><font face="Courier New,Courier">Listing 33</font></b></pre>
</td>
</tr>
</table>
<p>The code in Listing 33 is fairly complex, particularly with respect to 
putting the labels on the ends of the axes.&nbsp; However, I doubt that many of 
you are interested in the details, so I will let the comments suffice to 
explain the code.</p>
<p><font color="#FF0000"><b>Drawing tic marks</b></font></p>
<p>Listing 34 shows the methods invoked from the code in Listing 33 to actually 
draw the tic marks on the axes.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd < 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub < xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub > xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub < yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub > yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

<b><font face="Courier New,Courier">Listing 34</font></b></pre>
</td>
</tr>
</table>
<p>Again, I am going to let the comments suffice to explain this code.</p>
<p><font color="#FF0000"><b>The getTheX and getTheY methods</b></font></p>
<p>As mentioned earlier,  methods named <b>getTheX</b> and <b>getTheY</b> 
are used to convert coordinate values from  type <b>double</b> to integer 
 
values in pixels.&nbsp; Those two methods are shown in Listing 35.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI

<b><font face="Courier New,Courier">Listing 35</font></b></pre>
</td>
</tr>
</table>
<p>Listing 35 also marks the end of the inner class named <b>MyCanvas</b> and 
the end of the class named <b>GUI</b>.</p>
<p><font color="#FF0000"><b>The test class named junk</b></font></p>
<p>Listing 36 defines a test class named <b>junk</b> that implements the 
interface named <b>GraphIntfc01</b>.</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk

<b><font face="Courier New,Courier">Listing 36</font></b></pre>
</td>
</tr>
</table>
<p>This class defines the methods declared in the interface, and makes it 
possible to test the plotting program in a stand-alone mode without  having access to another class that implements the interface.</p>
<p>Since I discussed the implementation of this interface in some detail earlier 
in the lesson, there should be no need for me to provide further discussion of 
the code in Listing 36.&nbsp; You might note, however, that since the method 
named <b>getNmbr</b> returns the value 4, the method named <b>f5</b> will not be 
invoked by the plotting program.</p>
<center>
<h2>
<a NAME="Run the program"></a>Run the Program</h2></center>
Copy the code for the plotting program from Listing 39 into a Java source file 
named Graph01.java.<p>Copy the code for the interface from Listing 1 into a Java 
source file named <b>GraphIntfc01.java</b>.</p>
<p>Compile and 
run the program named <b>Graph01</b> with no command-line parameters.&nbsp; This should use the 
internal test class named <b>junk </b>discussed earlier to produce the display 
shown in Figure 4.</p>
<p>Once you have the display on your screen, make changes to the plotting 
parameters in the text fields at the bottom and press the button labeled <b>
Graph</b>.&nbsp; When you do, you should see the same functions being re-plotted 
with different plotting parameters.</p>
<p>Once that is successful, copy the code in Listing 37 into a file named <b>
Graph01Demo.java</b>.&nbsp; Copy the code in Listing 38 into a file named <b>
Dsp002.java</b>.<p>Compile these two files.&nbsp; Rerun the plotting program named <b>Graph01</b> 
providing <b>Graph01Demo</b> as a command-line parameter.&nbsp; Also rerun the 
plotting program providing <b>Dsp002</b> as a command-line parameter.&nbsp; 
This should produce displays similar to Figures 1 and 3.</p>
<p>Remember, however, that you must be running Java version 1.4 or later
to successfully compile and execute this program.<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I provided two generalized plotting programs in this lesson.&nbsp; One of the 
programs plots up to five functions in a vertical stack.&nbsp; The other program 
superimposes the plots for up to five functions on the same Cartesian coordinate 
system.</p>
<p>Each of these programs is capable of plotting the data produced by any object 
that implements a simple interface named <b>GraphIntfc01</b>.</p>
<p>I explained the interface named <b>GraphIntfc01.&nbsp; </b>I also explained 
how you can define classes of your own that implement the interface making them 
suitable for being plotted using either of the plotting programs.</p>
<p>I also provided two different sample classes that implement the interface for 
you to use as models as you come up to speed in defining your own classes.</p>
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listings</h2></center>
Complete listings of the programs discussed in this lesson are shown below.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/* File Graph01Demo.java
Copyright 2002, R.G.Baldwin

This class is used to demonstrate how 
to write data-generator classes that
will operate successfully with the
program named Graph01.

Tested using JDK 1.4.0 under Win 2000.
**************************************/
class Graph01Demo 
               implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr

  public double f1(double x){
    //This is a simple x-squared
    // function with a negative
    // sign.
    return -(x*x)/200.0;
  }//end f1

  public double f2(double x){
    //This is a simple x-cubed
    // function
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    //This is a simple cosine
    // function
    return 100*Math.cos(x/10.0);
  }//end f3

  public double f4(double x){
    //This is a simple sine
    // function
    return 100*Math.sin(x/20.0);
  }//end f4

  public double f5(double x){
    //This is function which
    // returns the product of
    // the above sine and cosines.
    return 100*(Math.sin(x/20.0)
                    *Math.cos(x/10.0));
  }//end f5

}//end sample class Graph01Demo

<b><font face="Courier New,Courier">Listing 37</font></b></pre>
</td>
</tr>
</table>
<p>&nbsp;</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/* File Dsp002.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a sample DSP program whose
output is designed to be plotted
by the programs named Graph01 and
Graph02.  This requires that the
class implement GraphIntfc01.  It
also requires a noarg constructor.

This program applies a narrow-band
convolution filter to white noise, and
then computes the amplitude spectrum of
the filtered result using a simple
Discrete Fourier Transform (DFT)
algorithm.  The spectrum of the white
noise is also computed.

The program convolves a 33-point
sinusoidal convolution filter with
wide-band noise, and then computes the
amplitude spectrum of the raw data and
the filtered result.  The processing
occurs when an object of the class is
instantiated.

The input noise, the filter, the
filtered output, and the two spectra
are deposited in five arrays for
later retrieval and display.

The input noise, the filter, the
filtered output, the spectrum of the
noise, and the spectrum of the filtered
result are returned by the methods
named f1, f2, f3, f4, and f5
respectively.

The output values that are returned
are scaled for appropriate display in
the plotting areas provided by the
program named Graph01.

Tested using JDK 1.4.0 under Win 2000.
**************************************/
import java.util.*;

class Dsp002 implements GraphIntfc01{
  //Establish data and spectrum
  // lengths.
  int operatorLen = 33;
  int dataLen = 256+operatorLen;
  int outputLen =
                 dataLen - operatorLen;
  int spectrumPts = outputLen;

  //Create arrays for the data and
  // the results.
  double[] data = new double[dataLen];
  double[] operator =
               new double[operatorLen];
  double[] output =
                 new double[outputLen];
  double[] spectrumA =
               new double[spectrumPts];
  double[] spectrumB =
               new double[spectrumPts];

  public Dsp002(){//constructor
    //Generate and save some wide-band
    // random noise.  Seed with a
    // different value each time the
    // object is constructed.
    Random generator = new Random(
                 new Date().getTime());
    for(int cnt=0;cnt < data.length;
                                cnt++){
      //Get data, scale it, remove the
      // dc offset, and save it.
      data[cnt] = 100*generator.
                       nextDouble()-50;
    }//end for loop

    //Create a convolution operator and
    // save it in the array.
    for(int cnt = 0; cnt < operatorLen;
                                cnt++){
      //Note, the value of the
      // denominator in the argument
      // to the cos method specifies
      // the frequency relative to the
      // sampling frequency.
      operator[cnt] = Math.cos(
                      cnt*2*Math.PI/4);
    }//end for loop

    //Apply the operator to the data
    Convolve01.convolve(data,dataLen,
          operator,operatorLen,output);

    //Compute DFT of the raw data and
    // save it in spectrumA array.
    Dft01.dft(data,spectrumPts,
                            spectrumA);

    //Compute DFT of the filtered data
    // and save it in spectrumB array.
    Dft01.dft(output,spectrumPts,
                            spectrumB);
    //All of the data has now been
    // produced and saved.  It may be
    // retrieved by invoking the
    // following methods named f1
    // through f5.

  }//end constructor

  //---------------------------------//
  //The following six methods are
  // required by the interface named
  // GraphIntfc01.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr
  //---------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    //This version of this method
    // returns the random noise data.
    // Be careful to stay within the
    // array bounds.
    if(index < 0 ||
                index > data.length-1){
      return 0;
    }else{
      return data[index];
    }//end else
  }//end f1
  //---------------------------------//
  public double f2(double x){
    //Return the convolution operator
    int index = (int)Math.round(x);
    if(index < 0 ||
            index > operator.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot
      return operator[index] * 50;
    }//end else
  }//end f2
  //---------------------------------//
  public double f3(double x){
    //Return filtered output
    int index = (int)Math.round(x);
    if(index < 0 ||
              index > output.length-1){
      return 0;
    }else{
      //Scale to approx same p-p as
      // input data
      return output[index]/6;
    }//end else
  }//end f3
  //---------------------------------//
  public double f4(double x){
    //Return spectrum of raw data
    int index = (int)Math.round(x);
    if(index < 0 ||
           index > spectrumA.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot.
      return spectrumA[index]/10;
    }//end else
  }//end f4
  //---------------------------------//
  public double f5(double x){
    //Return the spectrum of the
    // filtered data.
    int index = (int)Math.round(x);
    if(index < 0 ||
           index > spectrumB.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot.
      return spectrumB[index]/100;
    }//end else
  }//end f5

}//end sample class Dsp002
//===================================//

//This class provides a static method
// named convolve, which applies an
// incoming convolution operator to
// an incoming set of data and deposits
// the filtered data in an output
// array whose reference is received
// as an incoming parameter.
//This class could easily be broken out
// and put in a library as a stand-
// alone class, or the convolve method
// could be added to a class containing
// a variety of DSP methods.
class Convolve01{
  public static void convolve(
                     double[] data,
                     int dataLen,
                     double[] operator,
                     int operatorLen,
                     double[] output){
    //Apply the operator to the data,
    // dealing with the index
    // reversal required by
    // convolution.
    for(int i=0;
          i < dataLen-operatorLen;i++){
      output[i] = 0;
      for(int j=operatorLen-1;j>=0;
                                  j--){
        output[i] +=
                 data[i+j]*operator[j];
      }//end inner loop
    }//end outer loop
  }//end convolve method
}//end Class Convolve01
//===================================//

//This class provides a static method
// named dft, which computes and
// returns the amplitude spectrum of
// an incoming time series.  The
// amplitude spectrum is computed as
// the square root of the sum of the
// squares of the real and imaginary
// parts.
//Returns a number of points in the
// frequency domain equal to the number
// of samples in the incoming time
// series.  Deposits the frequency
// data in an array whose reference is
// received as an incoming parameter.
//This class could easily be broken out
// and put in a library as a stand-
// alone class, or the dft method
// could be added to a class containing
// a variety of DSP methods.
class Dft01{
  public static void dft(
                    double[] data,
                    int dataLen,
                    double[] spectrum){
    //Set the frequency increment to
    // the reciprocal of the data
    // length.  This is convenience
    // only, and is not a requirement
    // of the DFT algorithm.
    double delF = 1.0/dataLen;
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i < dataLen;i++){
      double freq = i*delF;
      double real = 0;
      double imag = 0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j < dataLen; j++){
        real += data[j]*Math.cos(
                     2*Math.PI*freq*j);
        imag += data[j]*Math.sin(
                     2*Math.PI*freq*j);
        spectrum[i] = Math.sqrt(
                real*real + imag*imag);
      }//end inner loop
    }//end outer loop
  }//end dft

}//end Dft01

<b><font face="Courier New,Courier">Listing 38</font></b></pre>
</td>
</tr>
</table>
<p>&nbsp;</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/* File Graph01.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.  The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on Cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a static method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.  A
Cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The Cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph01{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph01 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = -10.0;
  double xMax = 256.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 16.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 400;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number > 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt < number; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph01, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();

    //Guarantee a repaint on startup.
    for(int cnt = 0;
                  cnt < number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt < number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor

  //Override the paint method
  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);

    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;
    //Use the Canvas obj number to
    // determine which method to
    // invoke to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch

    //Now loop and plot the points
    while(xVal < xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1

      //Convert the x-value to an int
      // and draw the next line segment
      int x = getTheX(xVal);
      g.drawLine(oldX,oldY,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color RED
  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd < 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub < xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub > xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub < yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub > yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk

<b><font face="Courier New,Courier">Listing 39</font></b></pre>
</td>
</tr>
</table>
<p>&nbsp;</p>
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/* File Graph02.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a modified version of the
program named Graph01.  That program
plots up to five separate curves in
separate plotting areas.  This program
superimposes up to five separate curves
in different colors in the same
plotting area.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a static method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

Each curve is plotted in a different
color.  The correspondence between
colors and function calls is as
follows:

f1: BLACK
f2: BLUE
f3: RED
f4: MAGENTA
f5: CYAN

A Cartesian coordinate system with
axes, tic marks, and labels is drawn in
green.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph02{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph02 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = -10.0;
  double xMax = 325.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 400;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on theCanvas
  Canvas theCanvas;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number > 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a custom Canvas object for
    // all functions to be plotted on.
    theCanvas = new MyCanvas();
    theCanvas.setBackground(
                          Color.WHITE);

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().add(
                       ctlPnl,"South");
    getContentPane().add(
                   theCanvas,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph02, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = theCanvas.getWidth();
    height = theCanvas.getHeight();

    //Guarantee a repaint on startup.
    theCanvas.repaint();

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting area
    theCanvas.repaint();

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  //Override the paint method
  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes

    //Draw each curve in a different
    // color.
    for(int cnt=0; cnt < number;
                                cnt++){

      //Get initial data values
      double xVal = xMin;
      int oldX = getTheX(xVal);
      int oldY = 0;
      //Use the curve number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          oldY= getTheY(data.f1(xVal));
          g.setColor(Color.BLACK);
          break;
        case 1 :
          oldY= getTheY(data.f2(xVal));
          g.setColor(Color.BLUE);
          break;
        case 2 :
          oldY= getTheY(data.f3(xVal));
          g.setColor(Color.RED);
          break;
        case 3 :
          oldY= getTheY(data.f4(xVal));
          g.setColor(Color.MAGENTA);
          break;
        case 4 :
          oldY= getTheY(data.f5(xVal));
          g.setColor(Color.CYAN);
      }//end switch

      //Now loop and plot the points
      while(xVal < xMax){
        int yVal = 0;
        //Get next data value.  Use the
        // curve number to determine
        // which method to invoke to
        // get the value for y.
        switch(cnt){
          case 0 :
            yVal = getTheY(
                        data.f1(xVal));
            break;
          case 1 :
            yVal = getTheY(
                        data.f2(xVal));
            break;
          case 2 :
            yVal = getTheY(
                        data.f3(xVal));
            break;
          case 3 :
            yVal = getTheY(
                        data.f4(xVal));
            break;
          case 4 :
            yVal = getTheY(
                        data.f5(xVal));
        }//end switch1

        //Convert the x-value to an int
        // and draw the next line
        // segment
        int x = getTheX(xVal);
        g.drawLine(oldX,oldY,x,yVal);

        //Increment along the x-axis
        xVal += xCalcInc;

        //Save end point to use as
        // start point for next line
        // segment.
        oldX = x;
        oldY = yVal;
      }//end while loop

    }//end for loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color GREEN
  void drawAxes(Graphics g){
    g.setColor(Color.GREEN);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);

    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd < 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub < xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub > xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub < yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub > yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk

<b><font face="Courier New,Courier">Listing 40</font></b></pre>
</td>
</tr>
</table>
<hr size=3 width="100%" align=center>
<p>Copyright 2002, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.DickBaldwin.com">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring programmers.
He has also published articles in JavaPro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
<p>-end-
<br>&nbsp;
</body>
</html>