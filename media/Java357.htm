<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>An HSB Color-Editing Program for Digital Photos</title>
</head>

<body>

<font size="3" face="arial">
<h2 align="center">An HSB Color-Editing Program for Digital Photos</h2>
<i>Learn more about the HSB color model and how to use that model to adjust the hue, 
saturation, and brightness of your digital photos.</i>
<p><b>Published:</b>&nbsp; March 19, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b> </p>
<p>Java Programming Notes # 357</p>
<ul>
	<li><a href="#Preface">Preface</a>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_from_earlier_lessons">What you have 
		learned from earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul>
		</li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	</li>
	<li><a href="#General Background Information">General background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
		<li><a href="#Software_installation_and_testing">Software installation 
		and testing</a></li>
		<li><a href="#The_HSB_color_model">The HSB color model</a><ul>
			<li><a href="#The_Hue_slider">The Hue slider</a></li>
			<li><a href="#The_Sat_slider">The Sat slider</a></li>
			<li><a href="#The_Bright_slider">The Bright slider</a></li>
		</ul>
		</li>
	</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion and Sample Programs">Discussion and sample code</a><ul>
		<li><a href="#The_program_named_FiveSliderTemplate01">The program named 
		FiveSliderTemlate01</a></li>
		<li><a href="#The_program_named_HsbEdit02">The program named HsbEdit02</a></li>
	</ul>
	</li>
	<li><a href="#Run the program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete Program Listings">Complete program listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center"><center>
<h2><a name="Preface"></a>Preface</h2>
</center>
<h3><a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Edit the color of your digital photos</li>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_from_earlier_lessons">What you have learned 
from earlier lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> in this 
series, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>Many aspects of image processing, including color distance, projecting 
	3D coordinates onto a 2D display plane, and edge detection.</li>
	<li>How to write an animated flocking program.</li>
	<li>How to sharpen or soften your digital photos.</li>
	<li>What the HSB color model is all about.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p>You will learn how to use the HSB color model to adjust the hue, saturation, 
and brightness of your digital photos.</p>
<p>You will also learn about a new template program that I have developed that 
makes it much easier for you to write a variety of different types 
image-processing programs.</p>
<h3><a name="Viewing_tip">Viewing tip</a></h3>
<p>I recommend that you open another copy of this document in a separate browser 
window and use the following links to easily find and view the figures and 
listings while you are reading about them.</p>
<h4><a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Sample screen output from the program 
	named HsbEdit02.</li>
	<li><a href="#Figure_2">Figure 2</a>. The color wheel. </li>
	<li><a href="#Figure_3">Figure 3</a>. Pure colors versus angles on the color 
	wheel. </li>
	<li><a href="#Figure_4">Figure 4</a>. Example of color shifting using the 
	Hue slider.</li>
	<li><a href="#Figure_5">Figure 5</a>. Comparison for different saturation 
	factors. </li>
	<li><a href="#Figure_6">Figure 6</a>. Another saturation demonstration.</li>
	<li><a href="#Figure_7">Figure 7</a>. De-saturating an image.</li>
	<li><a href="#Figure_8">Figure 8</a>. The effect of the brightness slider.</li>
	<li><a href="#Figure_9">Figure 9</a>. Typical screen display from the 
	program named FiveSliderTemplate01.</li>
</ul>
<h4><a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the program named 
	FiveSliderTemplate01. </li>
	<li><a href="#Listing_2">Listing 2</a>. Set the minimum, maximum, and 
	initial value for each slider. </li>
	<li><a href="#Listing_3">Listing 3</a>. Set the tick spacing on the sliders. 
	</li>
	<li><a href="#Listing_4">Listing 4</a>. Set the labels to the left of each 
	slider. </li>
	<li><a href="#Listing_5">Listing 5</a>. Exclude all three buttons from the 
	GUI. </li>
	<li><a href="#Listing_6">Listing 6</a>. Exclude some, but not all of the 
	buttons from the GUI. </li>
	<li><a href="#Listing_7">Listing 7</a>. Set the labels on the buttons. </li>
	<li><a href="#Listing_8">Listing 8</a>. Set the label for the text field. 
	</li>
	<li><a href="#Listing_9">Listing 9</a>. Set the default input file name. 
	</li>
	<li><a href="#Listing_10">Listing 10</a>. Program the ChangeListener on the 
	sliders. </li>
	<li><a href="#Listing_11">Listing 11</a>. Program the event handlers. </li>
	<li><a href="#Listing_12">Listing 12</a>. The method named 
	handleSliderABandC.</li>
	<li><a href="#Listing_13">Listing 13</a>. Source code for the program named 
	FiveSliderTemplate01.</li>
	<li><a href="#Listing_14">Listing 14</a>. Source code for the program named 
	HsbEdit02. </li>
</ul>
<h3 align="left"><a name="Supplementary_material">Supplementary material</a></h3>
<p>I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font color="#000000"><a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000">
<a name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample 
programs that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h3><a name="The_HSB_color_model">The HSB color model</a></h3>
<p>As I explained in an earlier lesson titled <i>The HSB 
Color Model</i> <i>(see <a href="#Resources">Resources</a>)</i>, color is 
tricky.&nbsp; Not only do different individuals perceive color in different 
ways, the same color often looks different to the same person when viewed under 
different lighting conditions, and often looks different when viewed on 
different computer monitors.&nbsp; </p>
<p>There are several different models that are used to describe color in the 
computer world.&nbsp; Fortunately, we have well-defined mathematical ways to define 
color.</p>
<p><font color="#FF0000"><b>Won't make you an expert</b></font></p>
<p>Even if I were qualified to do so, <i>(which I'm not)</i>, I didn't try to 
make you a digital color expert in the earlier lesson.&nbsp; Instead, I briefly 
introduced you to some of the different color models that are in common use 
today.&nbsp; Then I tried to teach you enough about the HSB color model that you 
can understand what you are doing when you use the program that I will explain 
in this lesson <i>(or any other software based on HSB)</i> to edit your digital 
photographs.</p>
<p><font color="#FF0000"><b>What are a color model and a color space?</b></font></p>
<p>As you learned in the earlier lesson, according to Wikipedia, <i>&quot;A <b>
<a href="http://en.wikipedia.org/wiki/Color_model">color model</a></b> is an 
abstract mathematical model describing the way
<a title="Color" href="http://en.wikipedia.org/wiki/Color">colors</a> can be 
represented as
multiples 
of numbers, typically as three or four values or color components. When this 
model is associated with a precise description of how the components are to be 
interpreted (viewing conditions, etc.), the resulting set of colors is called
<a title="Color space" href="http://en.wikipedia.org/wiki/Color_space">color 
space</a>.&quot;</i></p>
<p><font color="#FF0000"><b>Different color models</b></font></p>
<p>Several different color models are commonly used to represent colors in a 
computer.&nbsp; These include:</p>
<ol>
	<li>The hue, saturation, lightness <i>(HSL) </i>model.</li>
	<li>The hue, saturation, value <i>(HSV)</i> model.</li>
	<li>The hue, saturation, brightness <i>(HSB)</i> model.</li>
	<li>The red, green, blue <i>(RGB)</i> model <i>(with a couple of variations)</i>.</li>
</ol>
<p>I am assuming that you are already well versed in the use of the basic RGB 
color model.&nbsp; In this lesson, we will be concerned mainly with model 3 in 
the above list <i>(HSB)</i>.</p>
<p><font color="#FF0000"><b>Why do we need HSB when we already have RGB?</b></font></p>
<p>In case you missed this explanation in the earlier lesson, I will repeat it 
here for your convenience.&nbsp; </p>
<p>The RGB color model is convenient for storing pixel-color data in a 
computer.&nbsp; In addition, it maps very well into the way that color is displayed 
on a color monitor where each pixel consists of three tiny dots, each of which 
can be caused to glow in red, green, or blue.&nbsp; </p>
<p>However, it does not map very well into the way we think and talk about 
color.&nbsp; For example, it is unlikely that you would go into a clothing store and 
tell the clerk that you would like to see a jacket with a red color value of 
0x96<i> (hex)</i>, a green color value of 0x48, and a blue color value of 0x1B.&nbsp;
<i>(Well -- if you are a true computer geek you might, but the clerk probably 
wouldn't know what you are talking about.)</i></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="Burnt_orange">Burnt orange</a></b><br />
  If you were a University of Texas sports fan living in my home town of Austin, 
	TX, you could simply tell the clerk that you would like to see a Texas <i>
	burnt orange</i> jacket and the clerk would know exactly what color you are 
	seeking.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Burnt orange</b></font></p>
<p>On the other hand, you might very well describe the color as orange, not too bright, 
and not too <a name="vivid_or_bold">vivid or bold</a>.&nbsp; In that case, you would be describing the color 
using parameters that are similar to the parameters in the HSB color model.</p>
<p>To a first approximation, <i>orange</i> corresponds to hue, <i>vivid or bold </i> corresponds to saturation, and <i>bright</i> corresponds to brightness.&nbsp; 
In other words, the HSB color model is closer to the way we think and talk about 
colors than the RGB model.</p>
<p><font color="#FF0000"><b>How did I create burnt orange?</b></font></p>
<p>In case you are wondering how I came up with the RGB formula for 
a color that is very close to UT burnt orange <i>(see <a href="#Burnt_orange">
sidebar</a>)</i>, I used the program that I explained in the earlier lesson and 
adjusted the sliders to produce a color that is 
<i>orange, not too bright, and not too vivid or bold</i>.&nbsp; Then I made some 
minor adjustments to the positions of the sliders to produce a color that is very close to the color on a 
University of Texas coffee mug.</p>
<p><font color="#FF0000"><b>Sample screen output</b></font></p>
<p>When you run the program named <b>HsbEdit02</b> that I will explain in this 
lesson, if you set the sliders to the same positions shown in Figure 1, you should get a screen 
output similar to that shown in Figure 1.&nbsp; <i>(The beach scene shown in 
Figure 1 is available as a jpeg file in Ericson's multimedia library.)</i></p>
<p><b><a name="Figure_1">Figure 1</a>. Sample screen output from the program 
named HsbEdit02.</b>
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357a.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357b.jpg" width="328" height="226"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>The HSB color values were modified</b></font></p>
<p>For every pixel in the beach image shown in Figure 1, the hue <i>(color)</i> 
was shifted by 180-degrees.&nbsp; The saturation was increased by a factor of 
2.5, and the brightness was unchanged.</p>
<p><font color="#FF0000"><b>Sliders for hue, saturation, and brightness</b></font></p>
<p>As you can see, there are three sliders on the GUI in Figure 1.&nbsp; These 
sliders make it possible for you to adjust the hue, saturation, and brightness 
of every pixel in the image displayed in the top of Figure 1.&nbsp; </p>
<p>The image shown in the top changes in real time as you move the sliders so 
that you can see the results of your changes immediately.&nbsp; </p>
<p>My next challenge is to help you understand what happens when you move 
the sliders and adjust the HSB properties of the pixels in the image.</p>
<h4><a name="The_Hue_slider">The Hue slider</a></h4>
<p>You learned about the color wheel and the relationship of the color wheel and 
the hue value in the earlier lesson.&nbsp; We will reinforce what you learned in 
that lesson using the material in this lesson.&nbsp; A color wheel, produced as 
the top surface of the HSB cone model in the earlier lesson is shown in Figure 2.</p>
<p><b><a name="Figure_2">Figure 2</a>. The color wheel. </b>
<table border="0" cols="1" bgcolor="#FEFFF0">
	<tr>
		<td>
		<pre><img border="0" src="java357c.jpg" width="409" height="431"></pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Allowable HSB parameter values</b></font></p>
<p>With the Java API, the value for hue can be any value of type <b>float</b>. 
The value for saturation must be a <b>float</b> value between 0.0 and 1.0.&nbsp; 
The value for brightness must also be a <b>float</b> value between 0.0 and 1.0.</p>
<p><font color="#FF0000"><b>Changing the HSB property values</b></font></p>
<p>The purpose of the sliders in Figure 1 is to make it possible for you to 
change the hue, saturation, and brightness values for every pixel in the image 
being processed.&nbsp; When you move a slider, the HSB properties for every 
pixel in the image are changed in the same way.</p>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>I am definitely not an expert in this area.&nbsp; The explanations that 
follow are based on what I have learned and concluded from reading what numerous 
others have written on the web.</p>
<p><font color="#FF0000"><b>Let brightness and saturation be 1.0</b></font></p>
<p>Assume that for a given pixel, the brightness value is 1.0.&nbsp; That being 
the case, the visible color of the pixel must be one of the colors shown in the 
color wheel of Figure 2.&nbsp; <i>(I explained the reasons for that conclusion 
in the earlier lesson and will explain further in conjunction 
with my <a href="#as_a_cone_with_the_pointy">cone</a> discussion later.)</i></p>
<p>Assume that the saturation value for the pixel is also 1.0.&nbsp; In that 
case, the color of the pixel must be one of the colors on the outer 
circumference of the color wheel shown in Figure 2.&nbsp; These are often 
referred to as the pure colors.&nbsp; <i>(I will explain the reason for 
this later as well.)</i></p>
<p><font color="#FF0000"><b>Hue is often described in angular degrees</b></font></p>
<p>Pretend that the color wheel in Figure 2 is the face of a clock for which the
<i>&quot;little hand&quot;</i> has been broken off.&nbsp; Assume that the length of the 
remaining <i>&quot;big hand&quot;</i> is exactly equal to the radius of the color wheel.&nbsp; 
A hue value of zero degrees <i>(or 360 degrees) </i>is represented by the big hand pointing exactly to the 
three-o'clock position.</p>
<p>If you look very carefully at the color wheel in Figure 2, you can see a 
white radial line in the middle of the red area pointing exactly at the 
three-o'clock position.&nbsp; This represents a hue value of zero degrees and 
also represents a hue value of 360 degrees.&nbsp; If the white line was pointing 
directly at the six-o'clock position, that would represent a hue value of 45 
degrees.&nbsp; You should be 
able to extrapolate from there.</p>
<p>The hue slider in Figure 1 is calibrated to extend from 0 to 360.&nbsp; 
Although there is no label that says so, the scale on that slider is intended to 
represent degrees from 0 to 360 inclusive.&nbsp; As the slider is moved from 0 
to 360, our imaginary big hand would make one complete revolution beginning and 
ending at the three-o'clock position.</p>
<p><font color="#FF0000"><b>Pure colors versus angles on the color wheel</b></font></p>
<p>Getting back to the color wheel in Figure 2, the table in Figure 3 shows some 
sample values of the relationship between the hue angle in degrees, the pure 
color on the circumference of the color wheel, and the RGB representation of 
that color in hexadecimal.</p>
<p><b><a name="Figure_3">Figure 3</a>. Pure colors versus angles on the color 
wheel. </b>
<table border="1" cols="1" bgcolor="#EFE9B8">
	<tr>
		<td><b>Angle</b>
      	</td>
		<td><b>Color</b></td>
		<td><b>RGB value</b></td>
	</tr>
	<tr>
		<td>0</td>
		<td>red</td>
		<td>FF0000</td>
	</tr>
	<tr>
		<td>60</td>
		<td>yellow</td>
		<td>FFFF00</td>
	</tr>
	<tr>
		<td>120</td>
		<td>green</td>
		<td>00FF00</td>
	</tr>
	<tr>
		<td>180</td>
		<td>cyan</td>
		<td>00FFFF</td>
	</tr>
	<tr>
		<td>240</td>
		<td>blue</td>
		<td>0000FF</td>
	</tr>
	<tr>
		<td>300</td>
		<td>magenta</td>
		<td>FF00FF</td>
	</tr>
	<tr>
		<td>360</td>
		<td>red</td>
		<td>FF0000</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>The colors are cyclic</b></font></p>
<p>As you can see from Figure 2, the colors are cyclic, starting at red for zero degrees and 
ending up back at red for 360 degrees.</p>
<p>For example, assume that you have a pixel with a hue of 60 degrees, a 
saturation value of 1.0, and a brightness value of 1.0 <i>(yellow)</i>.&nbsp; If 
you add 60 degrees to the hue value, the pixel will turn green.&nbsp; <i>(See 
Figure 4.)</i>&nbsp; If you add 
300 degrees to the hue, the pixel will turn red.</p>
<p>If you add 360 degrees, the color of the pixel won't change, but if you add 
420 degrees, it will turn green, just as if you had added 60 degrees.</p>
<p>Adding a hue value that is not a multiple of 60 degrees will cause the color 
to change to one of the other colors on the circumference of the color wheel in 
Figure 2.</p>
<p><font color="#FF0000"><b>Methods of the Color class</b></font></p>
<p>The <b>Color</b> class has a static method that can be used to convert the 
three values of a color in the HSB model to the three values required by the RGB 
model.&nbsp; Here is some of what Sun has to say about the requirements for the 
three HSB values in order to successfully make the conversion.</p>
<blockquote>
	<p><i>&quot;The <b>saturation</b> and <b>brightness</b> components should be 
	floating-point values between zero and one (numbers in the range 0.0-1.0).</i></p>
	<p><i>The <b>hue</b> component can be any floating-point number. The floor 
	of this number is subtracted from it to create a fraction between 0 and 1. 
	This fractional number is then multiplied by 360 to produce the hue angle in 
	the HSB color model.&quot;</i></p>
</blockquote>
<p>Note in particular the handling of the hue component value.&nbsp; Assume, for 
example that the method is presented with a hue value of 35.5.&nbsp; The method 
will first subtract 35, resulting in a fractional hue value of 0.5.&nbsp; Then 
it will multiply that value by 360 to convert the fractional value into 
degrees.&nbsp; For the case of a hue value of 35.5, this will result in a hue value of 180 degrees.&nbsp; Using that 
value, it will then proceed to convert from HSB to RGB.</p>
<p><font color="#FF0000"><b>Example of color shifting using the hue slider</b></font></p>
<p>Figure 4 shows five examples of what happens to colored pixels when subjected 
to color shifting through the hue slider.</p>
<p><b><a name="Figure_4">Figure 4</a>. Example of color shifting using the Hue 
slider.</b>
<table border="0" bgcolor="#FEFFF0" cellspacing="0" cellpadding="0">
	<tr>
		<td><img border="0" src="java357d1.jpg" width="159" height="180"></td>
		<td><img border="0" src="java357d2.jpg" width="159" height="180"></td>
		<td><img border="0" src="java357d3.jpg" width="159" height="180"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357d4.jpg" width="159" height="180"></td>
		<td><img border="0" src="java357d5.jpg" width="159" height="180"></td>
		<td><img border="0" src="java357d6.jpg" width="159" height="180"></td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>No change in saturation and brightness values</b></font></p>
<p>In Figure 1, the pointers on the saturation and brightness sliders were both 
set to 100.&nbsp; The saturation and brightness values of each pixel were being 
multiplied by 100/100.0 or 1.0.&nbsp; In that case, the saturation and 
brightness values weren't being modified.&nbsp; That was also the case for all 
six images in Figure 4.</p>
<p><font color="#FF0000"><b>Varying the hue</b></font></p>
<p>Going from left to right, top to bottom, the pointer on the hue slider was 
set to the following values when the six consecutive screen shots were taken:</p>
<ul>
	<li>0 degrees</li>
	<li>60 degrees</li>
	<li>120 degrees</li>
	<li>180 degrees</li>
	<li>240 degrees</li>
	<li>300 degrees</li>
</ul>
<p><font color="#FF0000"><b>Track a single pixel</b></font></p>
<p>If you pick any pixel in the upper-left image and add an angular value to its 
hue value, the effect on the color of the pixel is the same as keeping that 
pixel the same distance from the center and rotating it around the center by 
that number of degrees in a counter-clockwise direction.</p>
<p>For example, if you choose the pixel at the very bottom of the lower-case L 
in the word Baldwin in the upper-left image, applying a 180-degree color shift 
by moving the hue pointer to the 180-degree position would cause its color to 
change to the color of the pixel in exactly the same location in the lower-left 
image in Figure 4.&nbsp; Moving the slider to the 300-degree position would 
cause the color of the pixel to change to the color of the pixel in exactly the 
same location in the lower-right image.</p>
<p><font color="#FF0000"><b>Changing colors with the sliders</b></font></p>
<p>Therefore, if a pixel has one of the colors on the color wheel shown in 
Figure 2, you can change the color of that pixel to any color in the color wheel 
that is the same distance from the center of the wheel by keeping the saturation 
and brightness sliders at 100 and manipulating only the hue slider.</p>
<p>You can change it to other colors by moving either or both of the saturation 
and brightness sliders.</p>
<h4><a name="The_Sat_slider">The Sat slider</a></h4>
<p>Saturation may be the most difficult of the three HSB properties to 
understand.</p>
<p><font color="#FF0000"><b>Comparison for different saturation factors</b></font></p>
<p>At this point, I will show you the same image that you saw in Figure 1 
with for some different slider positions.&nbsp; The top image in Figure 5 shows 
the image with the hue slider set to 0, the saturation slider set to 100, and 
the brightness slider set to 100.&nbsp; This is the raw image with no color 
modifications.</p>
<p><b><a name="Figure_5">Figure 5</a>. Comparison for different saturation 
factors</b>.
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357e1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357e2.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357e3.jpg" width="329" height="271"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>Increase the saturation by a factor of 2.5</b></font></p>
<p>The middle image in Figure 5 shows the effect of moving the pointer on the 
saturation slider to 250 without changing the hue slider or the brightness 
slider.&nbsp; This caused the saturation value for every pixel to be 2.5 times 
greater than the original value.&nbsp; <i>(If the result was greater than 1.0, 
it was clipped to 1.0.)</i></p>
<p><font color="#FF0000"><b>The effect of the hue slider</b></font></p>
<p>Note that the saturation and brightness sliders in the middle image in Figure 
5 were the same as the values for those two sliders in Figure 1.&nbsp; Only the 
position of the hue slider was different.&nbsp; By comparing the image in Figure 
1 with middle image in Figure 5, you can see the effect of using the hue slider 
to shift the color for the same values of saturation and brightness.&nbsp; 
Applying a 180 degree color shift in Figure 1 caused the blue sky in Figure 5 to 
become red-orange in Figure 1 and caused the sand color in Figure 5 to become blue in Figure 1.&nbsp; The ocean color in Figure 5 turned red in 
Figure 1, etc.</p>
<p><font color="#FF0000"><b>Result of saturation change only</b></font></p>
<p>By comparing the middle image with the top image in Figure 5, you can see the 
effect of using the saturation slider to increase the saturation values of the 
pixels in the image without changing the hue or the brightness.</p>
<p>The bottom image in Figure 5 shows the effect of moving the pointer on the 
saturation slider to 400 without changing the hue slider or the brightness 
slider.</p>
<p>By comparing the three images going from top to bottom in Figure 5, you can 
see the effect of increasing the saturation factor from 1.0 to 2.5 and then to 
4.0.&nbsp; <i>(My guess is that the saturation value for many of the pixels in 
the bottom image exceeded its maximum allowable limit and was therefore clipped 
to the limit of 1.0.)</i></p>
<p><font color="#FF0000"><b>Let's get some help</b></font></p>
<p>At this point I'm going to enlist some help from another 
excellent website.&nbsp; One of the best explanations of HSV <i>(and hence HSB)</i> 
that I have found is on the web page titled
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a>.&nbsp; I call your attention 
to Figure 9 on that page.</p>
<p><font color="#FF0000"><b>Think of the HSB color model as a cone</b></font></p>
<p>The HSB color model can be described <a name="as_a_cone_with_the_pointy">as a 
cone with the pointed</a> end at the bottom as suggested by Figure 9 on that web 
page.&nbsp; Although that author shows only a small sampling of the colors on 
the top surface of the cone, that surface consists of the entire color wheel shown in 
Figure 2.&nbsp; Note that in both cases, the center of the wheel is white and 
the pure colors described earlier exist at the outer circumference of the wheel.</p>
<p><font color="#FF0000"><b>Many colors are possible</b></font></p>
<p>Every possible HSB color value is represented by a point somewhere within the 
volume of or on the surface of that cone.&nbsp; For example, if the HSB color 
value for brightness is zero, the color is black and is represented by the single point that 
constitutes the very bottom of the cone.&nbsp; <i>(It doesn't matter what the 
hue and saturation values are if the brightness is zero.)</i></p>
<p>If the color values for saturation and brightness are 0.0 and 1.0 
respectively, the color is white and is represented by the point at the center of 
the top surface of the cone.&nbsp; In this case, it doesn't matter what the 
value for hue is.&nbsp; If the saturation value is 0.0, the color of the pixel 
will range from white to black with shades of gray in between depending on the 
value of brightness.</p>
<p><font color="#FF0000"><b>Three dimensions</b></font></p>
<p>The HSB color model has three dimensions:</p>
<ul>
	<li>Hue - rotation around an invisible line that goes from the point at the 
	bottom to the center of the wheel at the top.</li>
	<li>Saturation - distance outward from that invisible line.</li>
	<li>Brightness - distance from the single point at the bottom of the cone 
	upward along that invisible line.</li>
</ul>
<p><font color="#FF0000"><b>What do the sliders do?</b></font></p>
<p>When we use the three sliders in Figure 1 to change the hue, saturation, and 
brightness of a pixel, we cause the program to behave in the following ways:</p>
<ul>
	<li><b>Hue slider:</b>&nbsp; Moving the hue slider rotates the color of the pixel around the center line 
	at a fixed distance from that line on a fixed horizontal plane within the 
	cone.</li>
	<li><b>Saturation slider:</b>&nbsp; Moving the saturation slider moves the color of the pixel along a radial 
	line on the surface of that horizontal plane, from the center line to the 
	outer surface of the cone.</li>
	<li><b>Brightness slider:</b>&nbsp; Moving the brightness slider moves the horizontal plane on which the color 
	resides up and down along the center line.</li>
</ul>
<p><font color="#FF0000"><b>Explained another way</b></font></p>
<p>In other words:</p>
<ul>
	<li>The brightness value of the color determines the vertical elevation of 
	the horizontal plane on which the color resides.&nbsp; When the brightness 
	value is 0.0, the horizontal plane <a name="degenerates_">degenerates </a>to 
	a single black point at the bottom of the cone.&nbsp; When the brightness value is 
	1.0, the horizontal plane is at the upper limit of the cone.&nbsp; In other 
	words, in that case, the horizontal plane is the top surface of the cone.</li>
	<li>The saturation value determines the distance of the color value from the 
	center of the cone with 0.0 being at the center and 1.0 being at the surface 
	of the cone.</li>
	<li>The hue value determines the angle, relative to an angle of zero degrees 
	at pure red, of a radial line on the horizontal plane on which the color 
	value resides.</li>
</ul>
<p><font color="#FF0000"><b>Changing the elevation of the plane</b></font></p>
<p>By moving the brightness slider in Figure 1, you change the vertical 
elevation of the horizontal plane for the color of each pixel in the image.&nbsp;
<i>(Note that the colors of individual pixels are not necessarily on the same 
horizontal plane.)</i></p>
<p>The brightness value for each pixel is multiplied 
by a factor ranging from 0.0 to 2.0.&nbsp; <i>(The multiplicative factor is 1.0 
when the pointer is at the 100 position.)</i>&nbsp; If the multiplication 
results in a new brightness value greater than 1.0, the value is simply set to 
1.0.</p>
<p><font color="#FF0000"><b>Changing the distance from the center</b></font></p>
<p>By moving the saturation slider in Figure 1, you change the distance from the 
center of the cone for the color of each pixel in the image.&nbsp; <i>(Note 
that the colors of individual pixels are not necessarily the same distance from 
the center.)</i></p>
<p>The saturation value for each pixel is multiplied by a 
factor ranging from 0.0 to 4.0.&nbsp; <i>(The multiplicative factor is 1.0 when 
the pointer is at the 100 position.)</i>&nbsp; Once again, if the multiplication 
results in a new saturation value greater than 1.0, the value is simply set to 
1.0.</p>
<p><font color="#FF0000"><b>Changing the hue angle</b></font></p>
<p>By moving the hue slider in Figure 1, you change the angular position of a 
radial line on which the color for each pixel resides.&nbsp; This is an additive change.&nbsp; 
If the addition results in a new hue value greater than 360 degrees, the value 
effectively starts over at zero degrees.&nbsp; In other words, a hue value of 
370 degrees is equivalent to a hue value of 10 degrees.</p>
<p><font color="#FF0000"><b>Another saturation demonstration</b></font></p>
<p>Figure 6 shows another example of moving the saturation slider without 
changing the hue or brightness sliders.&nbsp; In this case, the hue slider was 
set to 0 and the brightness slider was set to 100.&nbsp; The saturation slider 
was set to 100 <i>(a multiplicative factor of 1.0)</i> for the top image in 
Figure 6, so that the colors in the image were not being modified by the 
program.</p>
<p><b><a name="Figure_6">Figure 6</a>. Another saturation demonstration.</b>
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357f1.jpg" width="459" height="112"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357f2.jpg" width="459" height="112"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357f3.jpg" width="459" height="112"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357f4.jpg" width="459" height="112"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>Colors at nine points along the radial line</b></font></p>
<p>The top image in Figure 6 shows the colors at nine points along a radial line 
from the center to the outer edge of the cone on a fixed horizontal plane.&nbsp; 
The angular position of that line was close to zero.&nbsp; As you can see, this 
resulted in the points having the color red.&nbsp; The leftmost square shows the 
color at the center of the cone <i>(white)</i> and the rightmost square shows the color at the 
surface of the cone.</p>
<p><font color="#FF0000"><b>Changing the saturation values</b></font></p>
<p>The bottom three images in Figure 6 show the effect of positioning the slider 
at 200, 300, and 400 respectively.&nbsp; The color of the rightmost square was
<i>fully saturated</i> at the beginning, meaning that its color was at the 
surface of the cone with a saturation value at or near 1.0.&nbsp; Multiplying 
this value by factors of 2, 3, and 4 simply resulted in products that exceeded 
the allowable limit of 1.0, so the new value was set to 1.0.&nbsp; Therefore, 
there is no visible color change as the eye progresses down the right side of 
Figure 6.</p>
<p><font color="#FF0000"><b>Zero multiplied by any number is still zero</b></font></p>
<p>The color of the leftmost square was at the center of the cone at the 
beginning meaning that it had a saturation value at or near 0.0.&nbsp; 
Multiplying this value by factors of 2, 3, and 4 simply resulted in a product at 
or near zero, so there is no visible color change as the eye progresses down the 
left side of Figure 6.</p>
<p><font color="#FF0000"><b>The squares in the middle</b></font></p>
<p>The colors of the squares between the ends of the top image in Figure 6 had 
saturation values greater than 0.0 and less than 1.0.&nbsp; Multiplying these 
values by factors of 2, 3, and 4 resulted in larger saturation values.&nbsp; In 
some cases, the new value probably exceeded the limit and was set to the limit 
at 1.0.&nbsp; As a result, the colors of these squares approach, and sometimes 
reach the fully-saturated level as the eye progresses down Figure 6.&nbsp; The 
multiplication process moves the color value further from the center of the cone 
and closer to the edge of the cone.</p>
<p><font color="#FF0000"><b>De-saturating an image</b></font></p>
<p>Figure 7 shows the effect of setting the saturation slider to 100, 50, and 0 
respectively for the beach scene going from top to bottom.&nbsp; The hue slider 
was set to 0 and the brightness slider was set to 100 in all three cases.</p>
<p><b><a name="Figure_7">Figure 7</a>. De-saturating an image.</b>
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357e1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357g1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357g2.jpg" width="329" height="271"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>Reducing the saturation values for the pixels</b></font></p>
<p>The saturation value for every pixel was multiplied by 0.5 in the middle 
image in Figure 7, and was multiplied by zero in the bottom image.&nbsp; <i>(The 
bottom image would probably be referred to as a de-saturated image, which is a 
grayscale image.)</i></p>
<p><font color="#FF0000"><b>Vivid colors</b></font></p>
<p><a name="A_comparison_of_the_bottom_image_">A comparison of the bottom image
</a>in Figure 7 with the bottom image in Figure 5 should help you to understand 
why I used the term <a href="#vivid_or_bold">vivid or bold</a> earlier.&nbsp; 
The colors in the bottom image of Figure 5 are certainly more vivid than the 
colors in the bottom image of Figure 7.</p>
<h4><a name="The_Bright_slider">The Bright slider</a></h4>
<p>Brightness is probably the easiest of the HSB properties to understand.</p>
<p>The four images in Figure 8 show the beach scene with the hue slider set to 
0, the saturation slider set to 100, and the brightness slider set to values of 
50, 100, 150, and 200 respectively going from top to bottom.</p>
<p><b><a name="Figure_8">Figure 8</a>. The effect of the brightness slider.</b>
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357h1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357e1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357h2.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357h3.jpg" width="329" height="271"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>Making things brighter</b></font></p>
<p>As you can see, the picture becomes brighter and brighter as the position of 
the brightness slider is increased.&nbsp; The brightness value for every pixel 
is multiplied by a factor derived from the position of the slider.&nbsp; The 
multiplicative factors for the four slider positions shown in Figure 8 were 0.5, 
1.0, 1.5, and 2.0.</p>
<p>As with saturation, when the multiplicative product exceeds 1.0, it is simply 
set to 1.0.&nbsp; It appears that may have happened quite often for the bottom 
image in Figure 8.</p>
<p><font color="#FF0000"><b>A black rectangle</b></font></p>
<p>I elected not to show you the result for the brightness slider set to 0, 
because it is nothing but a black rectangle, corresponding to the
<a href="#degenerates_">bottom of the cone</a> that I described earlier.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#FF0000"><b>Two programs</b></font></p>
<p>I will present and explain two different programs in this lesson.&nbsp; In 
the first program named <b>FiveSliderTemplate01</b>, I will introduce you to a 
new template program that is designed to make it easier for you to write 
programs that use multiple sliders and buttons to edit digital photos.</p>
<p>In the second program, named <b>HsbEdit02</b>, I will show you how to begin 
with the template program described above and write a program to do the kind of 
HSB color editing that I explained in the previous section.</p>
<center>
<h2><a name="Discussion and Sample Programs"></a><font color="#000000">
Discussion and sample code</font></h2>
</center>
<h3><a name="The_program_named_FiveSliderTemplate01">The program named 
FiveSliderTemplate01</a></h3>
<p>I showed you how to write a template program for editing digital photos in 
the earlier lesson titled <i>A Slider-Controlled Softening Program for Digital 
Photos (see <a href="#Resources">Resources</a>)</i>.&nbsp; That program was 
limited to a single slider.</p>
<p><font color="#FF0000"><b>A major upgrade</b></font></p>
<p>This program is a major upgrade to the earlier program.&nbsp; This program 
makes it easy for you to create and use up to five sliders, three buttons, and 
their associated labels.&nbsp; In addition, the structure of this program makes 
it much easier for you to configure the sliders, the buttons, and the labels.</p>
<p><font color="#FF0000"><b>Default screen output</b></font></p>
<p>As shown in Figure 9, the program produces a display window for <b>t</b>he <b>Picture</b> 
object being processed plus the following components with associated labels in a 
GUI object that is separate and distinct from the display window:</p>
<ul>
	<li>A text field for entry of an input image file and pathname.</li>
	<li>A Write button for writing backup files during processing.</li>
	<li>Up to five general-purpose sliders with labels and registered change 
	listeners.</li>
	<li>Up to three general-purpose buttons with registered action listeners.</li>
	<li>A shutdown procedure that writes a final output image file.</li>
</ul>
<p><b><a name="Figure_9">Figure 9</a>. Typical screen display from the program 
named FiveSliderTemplate01.</b>
<table bgcolor="#FEFFF0" border="0" cols="1">
	<tr>
		<td><img border="0" src="java357k1.jpg" width="329" height="271"></td>
	</tr>
	<tr>
		<td><img border="0" src="java357k2.jpg" width="328" height="368"></td>
	</tr>
</table>
</p>

<p><font color="#FF0000"><b>Components are easy to eliminate</b></font></p>
<p>Any of the general-purpose sliders and buttons that aren't needed can be 
eliminated from the GUI by setting the values of certain constants at the 
beginning of the program to false.</p>
<p><font color="#FF0000"><b>Concentrate on image-processing logic</b></font></p>
<p>Ideally, by using this template, you will be able to concentrate on 
image-processing logic and not have to deal with the programming details 
involved in the overall program structure.</p>
<p>The template program requires access to Ericson's multimedia library.</p>
<p><font color="#FF0000"><b>Execution speed and smoothness</b></font></p>
<p>The speed and smoothness of programs that you write using this template 
program will depend on a combination of your programming skills and the speed of 
your computer.&nbsp; Note, however that this template program was designed to 
teach programming and image processing concepts.&nbsp; It was not designed to 
compete on a speed or convenience basis with commercially-available photograph 
processing programs such as Adobe's Photoshop Elements.</p>
<p><font color="#FF0000"><b>Backup image files</b></font></p>
<p>A backup file containing the current state of the display is written into the 
directory from which the original image file was read each time the user clicks 
the <b>Write</b> button.&nbsp; The five most recent backup files are saved.&nbsp; 
The backup files are written in bmp format regardless of the format of the 
original image file in order to avoid JPEG compression and preserve picture 
quality.&nbsp; The names of the backup files are the same as the name of the 
original image file except that BAKn is inserted immediately ahead of the 
extension. The term n in the file name is a digit ranging from 0 to 4.&nbsp; The 
value of n rolls over and starts back at 0 when it exceeds 4.</p>
<p><font color="#FF0000"><b>Input image files</b></font></p>
<p>Input files of type jpg, bmp, and png are supported.&nbsp; If the input file 
is in the same directory as the program code, only the name and extension must 
be entered into the text field.&nbsp; Otherwise, a complete path and file name 
with extension must be entered.</p>
<p><font color="#FF0000"><b>Construction of the GUI</b></font></p>
<p>The GUI initially appears in the upper-left corner of the screen.&nbsp; At 
this point, the sliders and the buttons are all disabled.&nbsp; When the user 
enters the name of the input file, a display of the image contained in that file 
appears in the upper-left corner of the screen and the GUI is relocated to a 
position immediately below the display.</p>
<p>When the GUI is relocated, the 
sliders and the buttons are all enabled and the text field is disabled.&nbsp; 
Also, when the GUI is relocated, the width of the GUI is changed to match the 
width of the display unless the width of the display is less than the preferred 
width of the GUI.&nbsp; In that case, the GUI appears at its preferred width.</p>
<p><font color="#FF0000"><b>A demo program</b></font></p>
<p>In addition to serving as a template for future programs, this program also 
demonstrates the use of four sliders in a reasonably meaningful way.&nbsp; The 
fifth slider and the three buttons are demonstrated in a somewhat trivial way.&nbsp;
<i>(They simply cause the computer to beep when they fire an event to prove that 
they are alive.)</i></p>
<p><font color="#FF0000"><b>Configuring the GUI components</b></font></p>
<p>For this demonstration program, each slider ranges from 0 to 100 with the 
initial position of the slider at 100.&nbsp; Many aspects of the configuration of 
the GUI, <i>(including the minimum, maximum, and initial position of each 
slider)</i> can be established by changing the values of constants at the 
beginning of the program.&nbsp; For example, by setting some of the boolean 
constants to false, you can eliminate any combination of the sliders and buttons 
from the GUI.&nbsp; <i>(You cannot eliminate the Write button using this 
approach.)</i></p>
<p>Various text and label values can also be configured in a similar manner.&nbsp; 
Note, however, that configuring the GUI by setting the above-mentioned <b>
boolean</b> constants to false doesn't prevent the objects from being 
instantiated.&nbsp; It simply prevents them from becoming part of the GUI.&nbsp; 
In a production program, you would probably want to eliminate the instantiation 
as well to conserve resources.</p>
<p><font color="#FF0000"><b>Behavior of the demo program</b></font></p>
<p>This demonstration program uses four sliders to process a picture using a 
relatively simple algorithm.&nbsp; By moving the top three sliders in Figure 9, 
you can scale the red, green, and blue color values independently of one 
another.&nbsp; By moving the fourth slider, you can scale all three colors 
together.</p>
<p>Moving the fifth slider simply causes the computer to beep, as does clicking 
any of the three buttons.&nbsp; I left those four components in the GUI in this 
demonstration program for illustration purposes only.</p>
<p><font color="#FF0000"><b>Writing backup files</b></font></p>
<p>Positioning a slider at some point along its range and clicking the <b>Write</b> 
button causes a backup file to be written containing the current state of the 
display.</p>
<p><font color="#FF0000"><b>Terminating the program</b></font></p>
<p>Clicking the large X in the upper-right corner of the display does not 
terminate the program.&nbsp; It simply hides the display, which is of no 
practical use.&nbsp; The program is terminated by clicking the large X in the 
upper-right corner of the GUI.</p>
<p>Before terminating, the program writes an output file containing the final 
state of the display in the same format as the input file.&nbsp; The name of the 
output file is the same as the name of the input file except that the word FINAL 
is inserted immediately ahead of the extension.&nbsp; The final output file and all of the backup files are written into the same directory from which 
the image file was originally read.&nbsp; This program does not modify the 
contents of the input file.</p>
<p><font color="#FF0000"><b>ChangeListener objects</b></font></p>
<p>Separate <b>ChangeListener</b> objects are registered on each of the five 
sliders.&nbsp; In the demo program, each time one of the top four sliders fires a <b>ChangeEvent</b>, 
the event handler creates a new display containing a copy of the original 
picture.</p>
<p><font color="#FF0000"><b>The method named handleSliderABandC</b></font></p>
<p>The handlers for the top three sliders call the method named <b>
handleSliderABandC</b>.&nbsp; This method adjusts all three colors in all of the 
pixels based on the current values of the three sliders.&nbsp; The top slider is 
used to adjust red; the second slider is used to adjust green; and the third 
slider is used to adjust blue.</p>
<p><font color="#FF0000"><b>The method named handleSliderD</b></font></p>
<p>The event handler on the fourth slider calls the method named <b>
handleSliderD</b>.&nbsp; This method adjusts all three colors in all of the 
pixels based on the current value of the fourth slider.</p>
<p>The handler for the fifth slider simply causes the computer to beep to 
demonstrate that it is alive.</p>
<p><font color="#FF0000"><b>Making it easy to write image-processing programs</b></font></p>
<p>The main purpose of this template program is to make it possible for you to 
write image processing programs with a minimum of effort.&nbsp; For many 
different kinds of image processing programs, you should be able to confine most 
of your programming efforts to changing the constants at the beginning of the 
program, inserting code in the existing event listeners, and writing methods 
that are called by those event listeners.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>A complete listing of the program is provided in Listing 13 near the end of 
the lesson.&nbsp; Because of the similarity of this template program to the one 
that I explained in the earlier lesson, I won't explain this program in detail.&nbsp; 
Instead, I will confine my explanation to those aspects of the program that you 
will need to know about to use it effectively.</p>
<p><font color="#FF0000"><b>Beginning of the program named FiveSliderTemplate01</b></font></p>
<p>The program begins in Listing 1.&nbsp; As I mentioned earlier, you can 
configure the GUI by changing the values of constants at the beginning of the 
program.&nbsp; You can control whether or not the sliders and buttons appear in 
the GUI, along with the contents of various labels by changing the contents of 
the constants.</p>
<p><b><a name="Listing_1">Listing 1</a>. Beginning of the program named 
FiveSliderTemplate01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>public class FiveSliderTemplate01 extends JFrame{

  //SLIDERS
  //Change the following boolean values to false to
  // selectively exclude sliders
  private final boolean sliderAPanelInclude = true;
  private final boolean sliderBPanelInclude = true;
  private final boolean sliderCPanelInclude = true;
  private final boolean sliderDPanelInclude = true;
  private final boolean sliderEPanelInclude = true;
</pre>
		</td>
	</tr>
</table>
</p>
<p>For example, you can selectively exclude any of the five sliders from the GUI 
by changing the values of the <b>boolean</b> constants in Listing 1 from true to 
false.</p>
<p><font color="#FF0000"><b>Set the minimum, maximum, and initial value for each 
slider</b></font></p>
<p>You can change the <b>int</b> values in Listing 2 to set the minimum, 
maximum, and initial pointer position for each of the five sliders.&nbsp; If you excluded a slider by setting a <b>boolean</b> constant in Listing 
1 to false, you can simply ignore that slider from that point forward and you 
don't need to do anything to the constants for that slider in Listing 2.</p>
<p><b><a name="Listing_2">Listing 2</a>. Set the minimum, maximum, and initial 
value for each slider. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change the following int values to change the limits
  // and initial positions of the sliders.
  private final int sliderAMin = 0;//minimum
  private final int sliderAMax = 100;//maximum
  private final int sliderAInit = 100;//initial value

  private final int sliderBMin = 0;
  private final int sliderBMax = 100;
  private final int sliderBInit = 100;

  private final int sliderCMin = 0;
  private final int sliderCMax = 100;
  private final int sliderCInit = 100;

  private final int sliderDMin = 0;
  private final int sliderDMax = 100;
  private final int sliderDInit = 100;

  private final int sliderEMin = 0;
  private final int sliderEMax = 100;
  private final int sliderEInit = 100;

</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Set the tick spacing on the sliders</b></font></p>
<p>The sliders move in steps of one unit.&nbsp; For example, if the slider 
extends from 0 at the left end to 200 at the right end, 200 steps are required 
to move the button from one end to the other.&nbsp; You can move the button one 
step at a time by clicking on the slider track.&nbsp; If you drag the button, 
the value of the slider will change by the number of steps traversed.</p>
<p>The tick marks on the sliders are for cosmetic and reference purposes only.&nbsp; 
They have nothing to do with the slider value.&nbsp; </p>
<p>You can change the spacing of 
the tick marks on the sliders by changing the <b>int</b> values in Listing 3.&nbsp; 
You may need to experiment with this for your program.&nbsp; Setting the major 
tick marks too close together can cause the labels on those tick marks to 
overlap.</p>
<p><b><a name="Listing_3">Listing 3</a>. Set the tick spacing on the sliders.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change the following int values to change the tick
  // spacing on the sliders.
  private final int sliderAMajorTickSpacing = 10;
  private final int sliderAMinorTickSpacing = 5;
  private final int sliderBMajorTickSpacing = 10;
  private final int sliderBMinorTickSpacing = 5;
  private final int sliderCMajorTickSpacing = 10;
  private final int sliderCMinorTickSpacing = 5;
  private final int sliderDMajorTickSpacing = 10;
  private final int sliderDMinorTickSpacing = 5;
  private final int sliderEMajorTickSpacing = 10;
  private final int sliderEMinorTickSpacing = 5;

</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>&nbsp;Set the labels to the left of each slider</b></font></p>
<p>If you examine Figure 9, you will see that there is a label to the left of 
each slider.&nbsp; The labels that I applied in Figure 9 were completely generic 
for illustration purposes.&nbsp; However, you can change the labels to make them 
more descriptive by changing the <b>String</b> values in Listing 4.</p>
<p><b><a name="Listing_4">Listing 4</a>. Set the labels to the left of each 
slider. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change these string values to change the labels
  // displayed to the left of the sliders.
  private final String sliderALabel = &quot;sliderA&quot;;
  private final String sliderBLabel = &quot;sliderB&quot;;
  private final String sliderCLabel = &quot;sliderC&quot;;
  private final String sliderDLabel = &quot;sliderD&quot;;
  private final String sliderELabel = &quot;sliderE&quot;;
</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Now you know how to configure the sliders</b></font></p>
<p>That pretty well wraps it up insofar as configuring the sliders is concerned.&nbsp; 
I have assumed that you will always want the tick marks and the labels on those 
tick marks to be painted.&nbsp; If that is not the case, you can prevent them 
from being painted by going into the program and passing a false parameter to 
either or both of the following methods when it is called on a particular 
slider:</p>
<ul>
	<li>setPaintTicks(true)</li>
	<li>setPaintLabels(true)</li>
</ul>
<p><font color="#FF0000"><b>Exclude all three buttons from the GUI</b></font></p>
<p>You can exclude all three of the buttons from the GUI by setting the <b>
boolean</b> value in Listing 5 to false.&nbsp; If you do that, you can simply 
ignore those buttons from that point forward.</p>
<p><b><a name="Listing_5">Listing 5</a>. Exclude all three buttons from the GUI.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //BUTTONS
  //Change the following value to false to exclude all
  // three buttons as a group.
  private final boolean buttonPanelInclude = true;
</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Exclude some, but not all of the buttons from the 
GUI</b></font></p>
<p>You can selectively exclude some or all of the buttons from the GUI by 
leaving the <b>boolean</b> value in Listing 5 true and setting one or more of 
the <b>boolean</b> values in Listing 6 to false.&nbsp; If you exclude a button 
in this manner, you can simply ignore it from that point forward.</p>
<p><b><a name="Listing_6">Listing 6</a>. Exclude some, but not all of the 
buttons from the GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change the following values to false to selectively
  // exclude individual buttons
  private final boolean buttonAInclude = true;
  private final boolean buttonBInclude = true;
  private final boolean buttonCInclude = true;
</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Set the labels on the buttons</b></font></p>
<p>You can change the <b>String</b> values in Listing 7 to change the labels 
that appear on the face of the buttons.&nbsp; As you can see in Figure 9, I 
placed very generic labels on the buttons for illustration purposes.&nbsp; You 
can make those labels more meaningful by changing the strings in Listing 7.</p>
<p><b><a name="Listing_7">Listing 7</a>. Set the labels on the buttons. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change these string values to change the text on the
  // buttons
  private final String buttonALabel = &quot;buttonA&quot;;
  private final String buttonBLabel = &quot;buttonB&quot;;
  private final String buttonCLabel = &quot;buttonC&quot;;
</pre>
		</td>
	</tr>
</table>
</p>
<p>Of course, if you have already excluded a button from the GUI, you don't need 
to do anything about its label.&nbsp; Just ignore the code in Listing 7.</p>
<p><font color="#FF0000"><b>Set the label for the text field</b></font></p>
<p>There is a label to the left of the text field that describes the purpose of 
the text field as being the entry point for the file name.&nbsp; You can change 
that label if you wish by changing the <b>String</b> value in Listing 8.</p>
<p><b><a name="Listing_8">Listing 8</a>. Set the label for the text field. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //MISCELLANEOUS
  //Change this string to change the text to the left of
  // the text field.
  private final JLabel fileNameLabel =
                                new JLabel(&quot;File Name: &quot;);
</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Set the default input file name</b></font></p>
<p>Mainly to make it easier to test the program, I set a default value in the 
text field that is used to enter the file name.&nbsp; You can change that if you 
like by changing the <b>String</b> value in Listing 9.</p>
<p><b><a name="Listing_9">Listing 9</a>. Set the default input file name. </b>

<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  //Change this string to change the path and name of the
  // default input file.
  private final String defaultFileName =
                               &quot;FiveSliderTemplate01.jpg&quot;;</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Program the listeners on the sliders and the buttons</b></font></p>
<p>The template program registers an anonymous <b>ChangeListener</b> object on each 
of the five sliders and an anonymous <b>ActionListener</b> object on each of the three buttons.&nbsp; 
As an example, Listing 10 shows the code for one of those listeners.</p>
<p><b><a name="Listing_10">Listing 10</a>. Program the ChangeListener on the 
sliders. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>    sliderA.addChangeListener(
      new ChangeListener(){
<font color="#0000FF">        <b>public void stateChanged(ChangeEvent e){</b>
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
<b>          </b></font><b><font color="#FF0000">handleSliderABandC();</font></b><font color="#0000FF">
        }//end stateChanged</font>
      }//end new ChangeListener
    );//end addChangeListener</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>Making your program different</b></font></p>
<p>It is likely that you will want the behavior of your program to be different 
from the behavior of the template program when the user moves a slider.&nbsp; In 
that case, you can:</p>
<ul>
	<li>Modify the code in the body of the method named <b>stateChanged</b> <i>
	(shown blue in Listing 10)</i></li>
	<li>Cause the <b>stateChanged</b> method to call a different method than the 
	method named <b>handleSliderABandC</b> <i>(shown red in Listing 10)</i>, or</li>
	<li>Leave the code in Listing 10 intact and modify the code in the method 
	named <b>handleSliderABandC</b> to cause the behavior to suit your needs.&nbsp; 
	</li>
</ul>
<p>That should cover the things that you need to know to make effective use of 
the template program for writing your own image-processing programs using 
sliders and buttons.</p>
<h3><a name="The_program_named_HsbEdit02">The program named HsbEdit02</a></h3>
<p>This is the program that was used to produce the images that you saw in 
Figure 1 through Figure 8.&nbsp; This program was written using the template 
program named <b>FiveSliderTemplate01</b> as a starting point.&nbsp; Various 
constant values were modified at the beginning of the template program to 
configure the program for this intended purpose.&nbsp; In addition, the event 
handlers for three of the sliders were modified to serve the purposes of this 
program.</p>
<p>The purpose of this program is to show you how to perform HSB color editing 
on your digital photos.</p>
<p><font color="#FF0000"><b>Behavior of the program</b></font></p>
<p>The program presents an initial GUI in the upper-left corner of the screen that allows the user to specify an image 
file to be edited.&nbsp; When the user enters the name <i>(and optionally the 
path)</i> of the file to be edited, the user is presented with a display of the 
image being edited and a relocated version of the GUI.&nbsp; The GUI contains three sliders and a <b>
Write</b> button as shown in Figure 1.</p>
<p>The sliders are labeled <b>Hue</b>, <b>Sat</b>, and <b>Bright</b> <i>
(abbreviations for hue, saturation, and brightness)</i>, which are the words 
behind the nomenclature for the HSB color model.</p>
<p>The user can change any combination of hue, saturation, and brightness of the 
image by adjusting the sliders.</p>
<p><font color="#FF0000"><b>Writing backup files</b></font></p>
<p>At any point, the user can click the <b>Write</b> button on the GUI to cause 
the processed image in its current state to be written into a backup file of 
type bmp.<i>&nbsp; (Note 
that only the most recent five backup files are saved.)</i></p>
<p><font color="#FF0000"><b>A final output file</b></font></p>
<p>When the user terminates the program by clicking the large X in the 
upper-right corner of the GUI, the final processed image is written into a final 
output file.&nbsp; The name of the output file is the same as the name of the 
input file except that the word FINAL is inserted immediately ahead of the 
extension.&nbsp; The final output file and all of the backup files are 
written into the same directory from which the image file was originally read.</p>
<p><font color="#FF0000"><b>Ericson's multimedia library is required</b></font></p>
<p>As I explained in the earlier discussion of the template program, access to 
Ericson's multimedia library is required.&nbsp; Also, other considerations that 
I explained in conjunction with the template program apply to this program as 
well.</p>
<p>Even though I mentioned it in conjunction with the discussion of the template 
program, I want to emphasize that this program was designed to teach programming 
and image processing concepts.&nbsp; It was not designed to compete on a speed 
or convenience basis with commercially-available photograph processing programs 
such as Adobe's Photoshop Elements.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>A complete listing of this program is provided in Listing 14 near the end of 
the lesson.&nbsp; I will explain only that code that causes the template program 
to be specialized for this purpose.</p>
<p><font color="#FF0000"><b>Configuring the GUI</b></font></p>
<p>As I mentioned earlier, I configured the GUI by setting the values of certain 
constants at the beginning of the program.&nbsp; You can view those changes in 
Listing 14.</p>
<p><font color="#FF0000"><b>Programming the event handlers</b></font></p>
<p>The <b>ChangeListener</b> class definitions that are registered on the three 
sliders are shown in Listing 11.</p>
<p><b><a name="Listing_11">Listing 11</a>. Program the event handlers. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>    sliderA.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    sliderB.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    sliderC.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener</pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#FF0000"><b>The behavior of all three listeners is the same</b></font></p>
<p>A quick glance at Listing 11 will tell you that the behavior of all three 
listeners is the same.&nbsp; Each event handler creates a new display by copying 
the original picture.&nbsp; Then it calls a method named <b>handleSliderABandC</b> 
where the interesting behavior of the program is controlled.</p>
<p>These anonymous class definitions are the same as in the 
template program.&nbsp; All that I needed to do to modify the behavior of the 
program was to modify the behavior of the method named <b>handleSliderABandC</b>.</p>
<p><font color="#FF0000"><b>An alternative approach</b></font></p>
<p>It is probably worth noting that if I were writing this program from scratch 
instead of adopting a template program, I would probably define a single member 
class that implements the ChangeListener interface and register it on all three 
sliders instead of defining three separate anonymous listener classes.</p>
<p><font color="#FF0000"><b>The method named handleSliderABandC</b> </font></p>
<p>This method makes it possible for the user to perform HSB color editing on a 
digital photo.&nbsp; The method is called each time any one of the hue, 
saturation, or brightness sliders shown in Figure 1 fires a <b>ChangeEvent</b>.</p>
<p>Events are fired when the user moves the buttons on the sliders.</p>
<p>Immediately before this method is called by the anonymous listeners in 
Listing 11, a new display is created.&nbsp; The display contains a copy of the 
original picture.&nbsp; This method operates only on the display.&nbsp; It does 
not modify the original picture.</p>
<p>Each time this method is called, it gets the value of each slider and uses 
those values to modify the corresponding hue, saturation, and brightness 
property for every pixel in the image currently residing in the display.</p>
<p><font color="#FF0000"><b><a name="Processing_steps">Processing steps</a></b></font></p>
<p>Basically, the method does the following for each pixel:</p>
<ol>
	<li>Get the red, green, and blue values from the native RGB color model data 
	for the pixel.</li>
	<li>Convert the RGB values into HSB values.</li>
	<li>Modify the HSB values independently of one another using the current 
	slider values.</li>
	<li>Convert the modified HSB values back into RGB values.</li>
	<li>Use the RGB values to set the modified color into the pixel.</li>
</ol>
<p>The method is synchronized to eliminate potential problems resulting from the 
possibility that the method may be called on two threads concurrently.</p>
<p>The method named <b>handleSliderABandC</b> is shown in its entirety in 
Listing 12.&nbsp; </p>
<p><b><a name="Listing_12">Listing 12</a>. The method named handleSliderABandC</b>.<b>
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>  private synchronized void handleSliderABandC(){
    pixels = display.getPixels();
    float[] hsbvals = new float[3];//HSB pixel values.

    //Process every pixel in the image using the same
    // algorithm.
    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      //Get the red, green, and blue values for the
      // current pixel.
      red = pixels[cnt].getRed();
      green = pixels[cnt].getGreen();
      blue = pixels[cnt].getBlue();

      //Get the three HSB color model values that
      // correspond to the current pixel color expressed
      // in the RGB color model. When the method returns,
      // the three HSB values have been placed in the
      // three-element array referred to by hsbvals in the
      // order hue, saturation, and brightness.
      Color.RGBtoHSB(red,green,blue,hsbvals);

      //Modify the hue value for the pixel based on the
      // current value of the Hue slider. Note that this
      // statement performs addition instead of
      // multiplication.
      hsbvals[0] = (float)(hsbvals[0] +
                           sliderA.getValue()/360.0);//hue

      //Modify the saturation value for the pixel based
      // on the current value of the Sat slider. Note
      // that multiplication is used here.
      hsbvals[1] = (float)(hsbvals[1] *
                    sliderB.getValue()/100.0);//saturation
      //If the computed value is greter than 1.0, clip it
      // at 1.0.
      if(hsbvals[1] &gt; 1.0) hsbvals[1] = (float)1.0;

      //Modify the brightness value for the pixel based
      // on the current value of the Bright slider. Once
      // again, multiplication is used here.
      hsbvals[2] = (float)(hsbvals[2] *
                    sliderC.getValue()/100.0);//brightness
      if(hsbvals[2] &gt; 1.0) hsbvals[2] = (float)1.0;

      //Convert the HSB color values back into RGB color
      // values.
      int color = Color.HSBtoRGB(
                        hsbvals[0],hsbvals[1],hsbvals[2]);

      //Use the RGB color values to set the modified color
      // in the pixel.
      pixels[cnt].setColor(new Color(color));

    }//end for loop

    //Repaint the display.
    display.repaint();

  }//end handleSliderABandC
  //----------------------------------------------------//</pre>
		</td>
	</tr>
</table>
</p>
<p>By the time that you have reached this point in the lesson, the earlier 
explanation of the <a href="#The_HSB_color_model">concepts</a> of HSB pixel 
editing, the brief explanation of the <a href="#Processing_steps">processing 
steps</a>, and the embedded comments in the method should provide a 
sufficient explanation for the behavior this method.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 13 and Listing 14, compile the 
code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain 
why your changes behave as they do. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I provided the code for an upgraded template program for processing images.&nbsp; 
Then I explained the HSB color model and showed you how to write a program to 
adjust the hue, saturation, and brightness of your digital photos.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn how to use affine transforms to scale, 
rotate, and translate <b>Picture</b> objects.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java355.htm">355</a> The HSB Color Model</li>
	<li><a href="http://www.dickbaldwin.com/java/Java356.htm">356</a> The show Method and the PictureFrame Class</li>
</ul>
<center>
<h2><a name="Complete Program Listings"></a>Complete program listings</h2>
</center>Complete listings of the programs discussed in this lesson are shown in 
Listing 13 and Listing 14 below.
<p><b><a name="Listing_13">Listing 13</a>. Source code for the program named 
FiveSliderTemplate01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>/*File FiveSliderTemplate01 Copyright 2009 R.G.Baldwin

This is a template program that takes some of the pain out
of writing image processing programs. The program
produces a display window for a processed Picture object
plus the following components with associated labels in a
GUI object that is separate and distinct from the display
window:

1. A text field for entry of an input image file and path
name.
2. A Write button for writing backup files during
processing.
3. Up to five general-purpose sliders with registered
change listeners.
4. Up to three general-purpose buttons with registered
action listeners.
5. A shutdown procedure that writes a final output image
file.

Any of the general-purpose sliders and buttons that aren't
needed can be eliminated from the GUI by setting the
values of certain constants at the beginning of the
program to false.

Ideally, by using this template, you will be able to
concentrate on image-processing logic and not have to deal
with the programming details involved in the overall
program.

The template program requires access to Ericson's
multimedia library.

The speed and smoothness of programs that you write using
this template program will depend on a combination of your
programming skills and the speed of your computer. Note,
however that this template program was designed to teach
programming and image processing concepts. It was not
designed to compete on a speed or convenience basis with
commercially-available photograph processing programs such
as Adobe's Photoshop Elements.

Backup files containing the current state of the display
are written into the directory from which the original
image file was read. The five most recent backup files are
saved. The backup files are written in bmp format
regardless of the format of the original image file in
order to avoid JPEG compression and preserve picture
quality.  The names of the backup files are the same as
the name of the original image file except that BAKn is
inserted immediately ahead of the extension where n is a
digit ranging from 0 to 4. The value of n rolls over and
starts back at 0 when it exceeds 4.

Input files of type jpg, bmp, png are supported.

If the input file is in the same directory as the program
code, only the name and extension must be entered into the
text field. Otherwise, a complete path and file name with
extension must be entered.

The GUI initially appears in the upper-left corner of the
screen. At this point, the sliders and the buttons are all
disabled. When the user enters the name of the input file,
a display of the image contained in that file appears in
the upper-left corner of the screen and the GUI is
relocated to a position immediately below the display.

When the GUI is relocated to the position immediately
below the display, the sliders and the buttons are all
enabled. and the text field is disabled. The width of the
GUI is changed to match the width of the display unless
the width of the display is less than the preferred width
of the GUI. In that case, the GUI appears at its preferred
width.

This program demonstrates the use of four sliders in a
meaningful way. The fifth slider and the three buttons are
demonstrated in a trivial way. (They simply cause the
computer to beep when they fire an event.)

For this demonstration program, each slider ranges
from 0 to 100 with the initial position of the slider at
100.

As mentioned earlier, many aspects of the configuration of
the GUI can be established by changing the values of
constants at the beginning of the program. For example, by
setting some of the boolean constants to false, you can
eliminate any, all, or any combination of the sliders and
buttons from the GUI. (You cannot eliminate the Write
button using this approach.) Various text and label values
can be configured in a similar manner.

Note, however, that configuring the GUI by setting the
above-mentioned boolean constants to false doesn't prevent
the objects from being instantiated. It simply prevents
them from becoming part of the GUI. In a production
program, you would probably want to eliminate the
instantiation as well to conserve resources.

This demonstration program uses four sliders to process a
picture using a relatively simple algorithm. By moving the
top three sliders, you can scale the red, green, and blue
color values independently of one another. By moving the
fourth slider, you can scale all three colors together.

Moving the fifth slider simply causes the computer to
beep, as does clicking any of the three buttons. I left
those four components in the GUI in this demonstration
program for illustration purposes only.

Positioning a slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display.

Clicking the large X in the upper-right corner of the
display does not terminate the program. It simply hides
the display, which is of no practical use.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension. The final output file
(and all of the backup files) are written into the same
directory from which the image file was originally read.

This program does not modify the contents of the input
file.

Separate ChangeListener objects are registered on each of
the five sliders. Each time one of the top four sliders
fires a ChangeEvent, the event handler creates a new
display containing a copy of the original picture. The
handlers for the top three sliders call the method named
handleSliderABandC. This method adjusts all three colors
in all of the pixels based on the current values of the
three sliders. The top slider is used to adjust red; the
second slider is used to adjust green; and the third
slider is used to adjust blue. The event handler on the
fourth slider calls the method named handleSliderD. This
method adjusts all three colors in all of the pixels based
on the current value of the fourth slider. The handler for
the fifth slider simply causes the computer to beep to
demonstrate that it is alive.

The main purpose of this template program is to make it
possible for you to write image processing programs with a
minimum of effort. For many different kinds of image
processing programs, you should be able to confine most of
your programming efforts to changing the constants at the
beginning of the program, inserting code in the existing
event listeners, and writing methods that are called by
those event listeners.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class FiveSliderTemplate01 extends JFrame{
  //The following constants are used to configure the GUI.
  // You can control whether or not the sliders and
  // buttons appear in the GUI, along with the contents of
  // various labels by changing the contents of the
  // following constants.

  //SLIDERS
  //Change the following boolean values to false to
  // selectively exclude sliders
  private final boolean sliderAPanelInclude = true;
  private final boolean sliderBPanelInclude = true;
  private final boolean sliderCPanelInclude = true;
  private final boolean sliderDPanelInclude = true;
  private final boolean sliderEPanelInclude = true;

  //Change the following int values to change the limits
  // and initial positions of the sliders.
  private final int sliderAMin = 0;//minimum
  private final int sliderAMax = 100;//maximum
  private final int sliderAInit = 100;//initial value

  private final int sliderBMin = 0;
  private final int sliderBMax = 100;
  private final int sliderBInit = 100;

  private final int sliderCMin = 0;
  private final int sliderCMax = 100;
  private final int sliderCInit = 100;

  private final int sliderDMin = 0;
  private final int sliderDMax = 100;
  private final int sliderDInit = 100;

  private final int sliderEMin = 0;
  private final int sliderEMax = 100;
  private final int sliderEInit = 100;

  //Change the following int values to change the tick
  // spacing on the sliders.
  private final int sliderAMajorTickSpacing = 10;
  private final int sliderAMinorTickSpacing = 5;
  private final int sliderBMajorTickSpacing = 10;
  private final int sliderBMinorTickSpacing = 5;
  private final int sliderCMajorTickSpacing = 10;
  private final int sliderCMinorTickSpacing = 5;
  private final int sliderDMajorTickSpacing = 10;
  private final int sliderDMinorTickSpacing = 5;
  private final int sliderEMajorTickSpacing = 10;
  private final int sliderEMinorTickSpacing = 5;

  //Change these string values to change the labels
  // displayed to the left of the sliders.
  private final String sliderALabel = &quot;sliderA&quot;;
  private final String sliderBLabel = &quot;sliderB&quot;;
  private final String sliderCLabel = &quot;sliderC&quot;;
  private final String sliderDLabel = &quot;sliderD&quot;;
  private final String sliderELabel = &quot;sliderE&quot;;


  //BUTTONS
  //Change the following value to false to exclude all
  // three buttons as a group.
  private final boolean buttonPanelInclude = true;

  //Change the following values to false to selectively
  // exclude individual buttons
  private final boolean buttonAInclude = true;
  private final boolean buttonBInclude = true;
  private final boolean buttonCInclude = true;

  //Change these string values to change the text on the
  // buttons
  private final String buttonALabel = &quot;buttonA&quot;;
  private final String buttonBLabel = &quot;buttonB&quot;;
  private final String buttonCLabel = &quot;buttonC&quot;;


  //MISCELLANEOUS
  //Change this string to change the text to the left of
  // the text field.
  private final JLabel fileNameLabel =
                                new JLabel(&quot;File Name: &quot;);

  //Change this string to change the path and name of the
  // default input file.
  private final String defaultFileName =
                               &quot;FiveSliderTemplate01.jpg&quot;;
  //----------------------------------------------------//


  private final JPanel mainPanel = new JPanel();

  private final JPanel northPanel = new JPanel();
  private final JPanel centerPanel = new JPanel();
  private final JPanel southPanel = new JPanel();

  private final JPanel sliderAPanel = new JPanel();
  private final JPanel sliderBPanel = new JPanel();
  private final JPanel sliderCPanel = new JPanel();
  private final JPanel sliderDPanel = new JPanel();
  private final JPanel sliderEPanel = new JPanel();

  private final JPanel buttonPanel = new JPanel();

  private final JButton writeButton =
                                     new JButton(&quot;Write&quot;);
  private final JButton buttonA =
                                new JButton(buttonALabel);
  private final JButton buttonB =
                                new JButton(buttonBLabel);
  private final JButton buttonC =
                                new JButton(buttonCLabel);

  //This text field is preloaded with the name of a test
  // file to make testing and debugging easier.
  private JTextField fileNameField =
                          new JTextField(defaultFileName);

  //Change the int values at the beginning of the program
  // to reconfigure these sliders.
  private final JSlider sliderA =
           new JSlider(sliderAMin,sliderAMax,sliderAInit);
  private final JSlider sliderB =
           new JSlider(sliderBMin,sliderBMax,sliderBInit);
  private final JSlider sliderC =
           new JSlider(sliderCMin,sliderCMax,sliderCInit);
  private final JSlider sliderD =
           new JSlider(sliderDMin,sliderDMax,sliderDInit);
  private final JSlider sliderE =
           new JSlider(sliderEMin,sliderEMax,sliderEInit);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int green = 0;
  private int blue = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = null;
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new FiveSliderTemplate01();
  }//end main method
  //----------------------------------------------------//

  public FiveSliderTemplate01(){//constructor
    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put decorations on the sliders. Change the constants
    // at the beginning of the program to control major
    // and minor tick spacing.
    sliderA.setMajorTickSpacing(sliderAMajorTickSpacing);
    sliderA.setMinorTickSpacing(sliderAMinorTickSpacing);
    sliderA.setPaintTicks(true);
    sliderA.setPaintLabels(true);

    sliderB.setMajorTickSpacing(sliderBMajorTickSpacing);
    sliderB.setMinorTickSpacing(sliderBMinorTickSpacing);
    sliderB.setPaintTicks(true);
    sliderB.setPaintLabels(true);

    sliderC.setMajorTickSpacing(sliderCMajorTickSpacing);
    sliderC.setMinorTickSpacing(sliderCMinorTickSpacing);
    sliderC.setPaintTicks(true);
    sliderC.setPaintLabels(true);

    sliderD.setMajorTickSpacing(sliderDMajorTickSpacing);
    sliderD.setMinorTickSpacing(sliderDMinorTickSpacing);
    sliderD.setPaintTicks(true);
    sliderD.setPaintLabels(true);

    sliderE.setMajorTickSpacing(sliderEMajorTickSpacing);
    sliderE.setMinorTickSpacing(sliderEMinorTickSpacing);
    sliderE.setPaintTicks(true);
    sliderE.setPaintLabels(true);

    //Construct the GUI working generally from the top
    // down.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(northPanel,BorderLayout.NORTH);
    mainPanel.add(centerPanel,BorderLayout.CENTER);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    northPanel.setLayout(new BorderLayout());

    //Add sliders if the constants at the beginning of the
    // program are true.
    if(sliderAPanelInclude)
          northPanel.add(sliderAPanel,BorderLayout.NORTH);
    if(sliderBPanelInclude)
         northPanel.add(sliderBPanel,BorderLayout.CENTER);
    if(sliderCPanelInclude)
          northPanel.add(sliderCPanel,BorderLayout.SOUTH);

    centerPanel.setLayout(new BorderLayout());

    //Add more sliders if the constants at the beginning
    // of the program are true.
    if(sliderDPanelInclude)
         centerPanel.add(sliderDPanel,BorderLayout.NORTH);
    if(sliderEPanelInclude)
        centerPanel.add(sliderEPanel,BorderLayout.CENTER);

    //Add a panel containing from one to three buttons if
    // the constant at the beginning of the program is
    // true.
    if(buttonPanelInclude)
          centerPanel.add(buttonPanel,BorderLayout.SOUTH);

    //Add buttons if the constants at the beginning of the
    // program are true.
    if(buttonAInclude) buttonPanel.add(buttonA);
    if(buttonBInclude) buttonPanel.add(buttonB);
    if(buttonCInclude) buttonPanel.add(buttonC);

    //These components should always be added.
    southPanel.add(writeButton);
    southPanel.add(fileNameLabel);
    southPanel.add(fileNameField);

    sliderAPanel.add(new JLabel(sliderALabel));
    sliderAPanel.add(sliderA);

    sliderBPanel.add(new JLabel(sliderBLabel));
    sliderBPanel.add(sliderB);

    sliderCPanel.add(new JLabel(sliderCLabel));
    sliderCPanel.add(sliderC);

    sliderDPanel.add(new JLabel(sliderDLabel));
    sliderDPanel.add(sliderD);

    sliderEPanel.add(new JLabel(sliderELabel));
    sliderEPanel.add(sliderE);

    //Disable the sliders and the buttons until the
    // user enters the file name.
    sliderA.setEnabled(false);
    sliderB.setEnabled(false);
    sliderC.setEnabled(false);
    sliderD.setEnabled(false);
    sliderE.setEnabled(false);

    buttonA.setEnabled(false);
    buttonB.setEnabled(false);
    buttonC.setEnabled(false);
    writeButton.setEnabled(false);

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();//Set to overall preferred size.
    setVisible(true);

    //Move the focus to the text field to make it easy
    // for the user to enter the name of the input file.
    fileNameField.requestFocus();
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage(&quot;Dick Baldwin&quot;,10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file before any processing is done.
          picture.write(outputPath
                       + &quot;BAK&quot; + writeCounter++ + &quot;.bmp&quot;);

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle(&quot;Copyright 2009, R.G.Baldwin&quot;);

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the sliders and the buttons.
          sliderA.setEnabled(true);
          sliderB.setEnabled(true);
          sliderC.setEnabled(true);
          sliderD.setEnabled(true);
          sliderE.setEnabled(true);

          buttonA.setEnabled(true);
          buttonB.setEnabled(true);
          buttonC.setEnabled(true);

          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + &quot;BAK&quot; + writeCounter++ + &quot;.bmp&quot;);
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on buttonA. This button
    // and this listener are here for future expansion.
    // For demonstration purposes, make the computer beep
    // when the user clicks any of the three buttons.
    buttonA.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//
    //Register an ActionListener on buttonB. This button
    // and this listener are here for future expansion.
    buttonB.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//
    //Register an ActionListener on buttonC. This button
    // and this listener are here for future expansion.
    buttonC.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + &quot;FINAL&quot; + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//

    //Register a ChangeListener object on sliderA.
    //Each time sliderA fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC. You can modify the code in this
    // listener, the listeners for the other sliders, and
    // the listeners for the buttons to customize the
    // behavior of the program to meet your needs.
    sliderA.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on sliderB.
    //Each time sliderB fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC.
    sliderB.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on sliderC.
    //Each time sliderC fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC.
    sliderC.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    //Register a ChangeListener object on sliderD.
    //Each time sliderD fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderD. Note that this is a different
    // method than the method called by the three
    // previous listener objects.
    sliderD.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderD();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    //Register a ChangeListener object on sliderE.
    //Each time sliderE fires a ChangeEvent, this event
    // handler causes the computer to beep solely to
    // demonstrate that the slider is alive. Note that the
    // beep occurs at the end of the slider travel.
    sliderE.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*
  This version of the method named handleSliderABandC is
  designed for illustration purposes only. The method
  is called each time sliderA, sliderB, or sliderC fires
  a ChangeEvent.

  Immediately before this method is called, a new
  display is created as a copy of the original picture.
  This method operates only on the display. Each time
  the method is called, it gets the value of each slider
  and uses that value as a multiplicative factor to
  adjust the corresponding color value in everypixel in
  the current display.

  The value of sliderA is used to adjust the red color.
  The value of sliderB is used to adjust the green
  color, and the value of sliderC is used to adjust the
  blue color.

  Depending on the position of the sliders when the event
  is fired, each color value for every pixel in the
  current display will be set to a value ranging from
  zero to 100 percent of its original value.

  Methods that are written to replace this one in your
  programs should never access the original Picture
  object directly, but should confine their operations
  to the Picture object referred to by the variable
  named display.

  The method is synchronized to eliminate the possiblilty
  that it may be called on two threads concurrently.
  */
  private synchronized void handleSliderABandC(){
    //Adjust the values of the colors based on the current
    // values of sliderA, sliderB, and sliderC.
    pixels = display.getPixels();
    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      red = (int)(pixels[cnt].getRed()
                              * sliderA.getValue()/100.0);
      green = (int)(pixels[cnt].getGreen()
                              * sliderB.getValue()/100.0);
      blue = (int)(pixels[cnt].getBlue()
                              * sliderC.getValue()/100.0);
      pixels[cnt].setColor(new Color(red,green,blue));
    }//end for loop

    display.repaint();

  }//end handleSliderABandC
  //----------------------------------------------------//

  //This method adjusts all three color values for every
  // pixel on the basis of the value of sliderD only.
  //The method is synchronized to eliminate the remote
  // possiblilty that it may be called on two threads
  // concurrently.

  private synchronized void handleSliderD(){
    //Adjust the value of all three colors on the
    // basis of the current value of the sliderD.
    pixels = display.getPixels();
    double scaleFactor = sliderD.getValue()/100.0;

    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      red = (int)(pixels[cnt].getRed() * scaleFactor);
      green = (int)(pixels[cnt].getGreen()* scaleFactor);
      blue = (int)(pixels[cnt].getBlue() * scaleFactor);
      pixels[cnt].setColor(new Color(red,green,blue));
    }//end for loop

    display.repaint();

  }//end handleSliderD
  //----------------------------------------------------//

}//end class FiveSliderTemplate01</pre>
		</td>
	</tr>
</table>
</p>
<p>&nbsp;</p>
<p><b><a name="Listing_14">Listing 14</a>. Source code for the program named 
HsbEdit02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
	<tr>
		<td>
		<pre>/*File HsbEdit02 Copyright 2009 R.G.Baldwin

This program was written using the template program named
FiveSliderTemplate01 as a starting point. See the comments
in that program for detailed information about the
template.

The purpose of the program is to show you how to perform
HSB color editing on your digital photos.

The program allows the user to specify an image file to be
edited. The user is then presented with a display of the
image being edited and a GUI containing three sliders, a
Write button, and a text field for entry of the file name.

The sliders are labeled Hue, Sat, and Bright. The labels
are abbreviations for Hue, Saturation, and Brightness,
which are the words behind the nomenclature for the HSB
color model.

The user can change any combination of hue, saturation,
and brightness of the image by adjusting the sliders.

At any point, the user can click a Write button on the GUI
and write the processed image in its current state into a
backup file. (Note that only the most recent five backup
files are saved.) When the user terminates the program,
the final processed image is written into a final output
file.

The template program requires access to Ericson's
multimedia library.

Input files of type jpg, bmp, png are supported. The input
image file is not modified.

If the input file is in the same directory as the program
files, only the name and extension must be entered into
the text field. Otherwise, a complete path and file name
with extension must be entered.

Note, that this  program was designed to teach
programming and image processing concepts. It was not
designed to compete on a speed or convenience basis with
commercially-available photograph processing programs such
as Adobe's Photoshop Elements.

The GUI initially appears in the upper-left corner of the
screen. At this point, the sliders and the buttons are all
disabled. When the user enters the name of the input file,
a display of the image contained in that file appears in
the upper-left corner of the screen and the GUI is
relocated to a position immediately below the display.

When the GUI is relocated to the position immediately
below the display, the sliders and the buttons are all
enabled. and the text field is disabled. The width of the
GUI is changed to match the width of the display if
possible.

Clicking the large X in the upper-right corner of the
display does not terminate the program. It simply hides
the display, which is of no practical use.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension. The final output file
(and all of the backup files) are written into the same
directory from which the image file was originally read.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class HsbEdit02 extends JFrame{
  //The following constants are used to configure the GUI.
  // You can control whether or not the sliders and
  // buttons appear in the GUI, along with the contents of
  // various labels by changing the contents of the
  // following constants.

  //SLIDERS
  //Change the following boolean values to false to
  // selectively exclude sliders
  private final boolean sliderAPanelInclude = true;
  private final boolean sliderBPanelInclude = true;
  private final boolean sliderCPanelInclude = true;
  private final boolean sliderDPanelInclude = false;
  private final boolean sliderEPanelInclude = false;

  //Change the following int values to change the limits
  // and initial positions of the sliders.
  private final int sliderAMin = 0;//minimum
  private final int sliderAMax = 360;//maximum
  private final int sliderAInit = 0;//initial value

  private final int sliderBMin = 0;
  private final int sliderBMax = 400;
  private final int sliderBInit = 100;

  private final int sliderCMin = 0;
  private final int sliderCMax = 200;
  private final int sliderCInit = 100;

  //The following two sliders are not used.
  private final int sliderDMin = 0;
  private final int sliderDMax = 100;
  private final int sliderDInit = 100;

  private final int sliderEMin = 0;
  private final int sliderEMax = 100;
  private final int sliderEInit = 100;

  //Change the following int values to change the tick
  // spacing on the sliders.
  private final int sliderAMajorTickSpacing = 60;
  private final int sliderAMinorTickSpacing = 10;
  private final int sliderBMajorTickSpacing = 50;
  private final int sliderBMinorTickSpacing = 10;
  private final int sliderCMajorTickSpacing = 50;
  private final int sliderCMinorTickSpacing = 10;
  //The following sliders were not used.
  private final int sliderDMajorTickSpacing = 10;
  private final int sliderDMinorTickSpacing = 5;
  private final int sliderEMajorTickSpacing = 10;
  private final int sliderEMinorTickSpacing = 5;

  //Change these string values to change the labels
  // displayed to the left of the sliders.
  private final String sliderALabel = &quot;Hue&quot;;
  private final String sliderBLabel = &quot;Sat&quot;;
  private final String sliderCLabel = &quot;Bright&quot;;
  //The following two sliders were not used
  private final String sliderDLabel = &quot;sliderD&quot;;
  private final String sliderELabel = &quot;sliderE&quot;;


  //BUTTONS
  //Change the following value to false to exclude all
  // three buttons as a group.
  //None of the three buttons were used.
  private final boolean buttonPanelInclude = false;

  //Change the following values to false to selectively
  // exclude individual buttons
  private final boolean buttonAInclude = true;
  private final boolean buttonBInclude = true;
  private final boolean buttonCInclude = true;

  //Change these string values to change the text on the
  // buttons
  private final String buttonALabel = &quot;buttonA&quot;;
  private final String buttonBLabel = &quot;buttonB&quot;;
  private final String buttonCLabel = &quot;buttonC&quot;;


  //MISCELLANEOUS
  //Change this string to change the text to the left of
  // the text field.
  private final JLabel fileNameLabel =
                                new JLabel(&quot;File Name: &quot;);

  //Change this string to change the path and name of the
  // default input file.
  private final String defaultFileName = &quot;HsbEdit02.jpg&quot;;
  //----------------------------------------------------//

  //Components for construction of the GUI.
  private final JPanel mainPanel = new JPanel();

  private final JPanel northPanel = new JPanel();
  private final JPanel centerPanel = new JPanel();
  private final JPanel southPanel = new JPanel();

  private final JPanel sliderAPanel = new JPanel();
  private final JPanel sliderBPanel = new JPanel();
  private final JPanel sliderCPanel = new JPanel();
  private final JPanel sliderDPanel = new JPanel();
  private final JPanel sliderEPanel = new JPanel();

  private final JPanel buttonPanel = new JPanel();

  private final JButton writeButton =
                                     new JButton(&quot;Write&quot;);
  private final JButton buttonA =
                                new JButton(buttonALabel);
  private final JButton buttonB =
                                new JButton(buttonBLabel);
  private final JButton buttonC =
                                new JButton(buttonCLabel);

  //This text field is preloaded with the name of a test
  // file to make testing and debugging easier.
  private JTextField fileNameField =
                          new JTextField(defaultFileName);

  //Change the int values at the beginning of the program
  // to reconfigure these sliders.
  private final JSlider sliderA =
           new JSlider(sliderAMin,sliderAMax,sliderAInit);
  private final JSlider sliderB =
           new JSlider(sliderBMin,sliderBMax,sliderBInit);
  private final JSlider sliderC =
           new JSlider(sliderCMin,sliderCMax,sliderCInit);
  private final JSlider sliderD =
           new JSlider(sliderDMin,sliderDMax,sliderDInit);
  private final JSlider sliderE =
           new JSlider(sliderEMin,sliderEMax,sliderEInit);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int green = 0;
  private int blue = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = null;
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new HsbEdit02();
  }//end main method
  //----------------------------------------------------//

  public HsbEdit02(){//constructor
    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put decorations on the sliders. Change the constants
    // at the beginning of the program to control major
    // and minor tick spacing.
    sliderA.setMajorTickSpacing(sliderAMajorTickSpacing);
    sliderA.setMinorTickSpacing(sliderAMinorTickSpacing);
    sliderA.setPaintTicks(true);
    sliderA.setPaintLabels(true);

    sliderB.setMajorTickSpacing(sliderBMajorTickSpacing);
    sliderB.setMinorTickSpacing(sliderBMinorTickSpacing);
    sliderB.setPaintTicks(true);
    sliderB.setPaintLabels(true);

    sliderC.setMajorTickSpacing(sliderCMajorTickSpacing);
    sliderC.setMinorTickSpacing(sliderCMinorTickSpacing);
    sliderC.setPaintTicks(true);
    sliderC.setPaintLabels(true);

    sliderD.setMajorTickSpacing(sliderDMajorTickSpacing);
    sliderD.setMinorTickSpacing(sliderDMinorTickSpacing);
    sliderD.setPaintTicks(true);
    sliderD.setPaintLabels(true);

    sliderE.setMajorTickSpacing(sliderEMajorTickSpacing);
    sliderE.setMinorTickSpacing(sliderEMinorTickSpacing);
    sliderE.setPaintTicks(true);
    sliderE.setPaintLabels(true);

    //Construct the GUI working generally from the top
    // down.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(northPanel,BorderLayout.NORTH);
    mainPanel.add(centerPanel,BorderLayout.CENTER);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    northPanel.setLayout(new BorderLayout());

    //Add sliders if the constants at the beginning of the
    // program are true.
    if(sliderAPanelInclude)
          northPanel.add(sliderAPanel,BorderLayout.NORTH);
    if(sliderBPanelInclude)
         northPanel.add(sliderBPanel,BorderLayout.CENTER);
    if(sliderCPanelInclude)
          northPanel.add(sliderCPanel,BorderLayout.SOUTH);

    centerPanel.setLayout(new BorderLayout());

    //Add more sliders if the constants at the beginning
    // of the program are true.
    if(sliderDPanelInclude)
         centerPanel.add(sliderDPanel,BorderLayout.NORTH);
    if(sliderEPanelInclude)
        centerPanel.add(sliderEPanel,BorderLayout.CENTER);

    //Add a panel containing from one to three buttons if
    // the constant at the beginning of the program is
    // true.
    if(buttonPanelInclude)
          centerPanel.add(buttonPanel,BorderLayout.SOUTH);

    //Add buttons if the constants at the beginning of the
    // program are true.
    if(buttonAInclude) buttonPanel.add(buttonA);
    if(buttonBInclude) buttonPanel.add(buttonB);
    if(buttonCInclude) buttonPanel.add(buttonC);

    //These components should always be added.
    southPanel.add(writeButton);
    southPanel.add(fileNameLabel);
    southPanel.add(fileNameField);

    sliderAPanel.add(new JLabel(sliderALabel));
    sliderAPanel.add(sliderA);

    sliderBPanel.add(new JLabel(sliderBLabel));
    sliderBPanel.add(sliderB);

    sliderCPanel.add(new JLabel(sliderCLabel));
    sliderCPanel.add(sliderC);

    sliderDPanel.add(new JLabel(sliderDLabel));
    sliderDPanel.add(sliderD);

    sliderEPanel.add(new JLabel(sliderELabel));
    sliderEPanel.add(sliderE);

    //Disable the sliders and the buttons until the
    // user enters the file name.
    sliderA.setEnabled(false);
    sliderB.setEnabled(false);
    sliderC.setEnabled(false);
    sliderD.setEnabled(false);
    sliderE.setEnabled(false);

    buttonA.setEnabled(false);
    buttonB.setEnabled(false);
    buttonC.setEnabled(false);
    writeButton.setEnabled(false);

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();//Set to overall preferred size.
    setVisible(true);

    //Move the focus to the text field to make it easy
    // for the user to enter the name of the input file.
    fileNameField.requestFocus();
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage(&quot;Dick Baldwin&quot;,10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file before any processing is done.
          picture.write(outputPath
                       + &quot;BAK&quot; + writeCounter++ + &quot;.bmp&quot;);

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle(&quot;Copyright 2009, R.G.Baldwin&quot;);

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the sliders and the buttons.
          sliderA.setEnabled(true);
          sliderB.setEnabled(true);
          sliderC.setEnabled(true);
          sliderD.setEnabled(true);
          sliderE.setEnabled(true);

          buttonA.setEnabled(true);
          buttonB.setEnabled(true);
          buttonC.setEnabled(true);

          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + &quot;BAK&quot; + writeCounter++ + &quot;.bmp&quot;);
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on buttonA. This button
    // and this listener are here for future expansion.
    // For demonstration purposes, make the computer beep
    // when the user clicks any of the three buttons.
    buttonA.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//
    //Register an ActionListener on buttonB. This button
    // and this listener are here for future expansion.
    buttonB.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//
    //Register an ActionListener on buttonC. This button
    // and this listener are here for future expansion.
    buttonC.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + &quot;FINAL&quot; + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//

    //Register a ChangeListener object on sliderA.
    //Each time sliderA fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC. You can modify the code in this
    // listener, the listeners for the other sliders, and
    // the listeners for the buttons to customize the
    // behavior of the program to meet your needs.
    sliderA.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on sliderB.
    //Each time sliderB fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC.
    sliderB.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//
    //Register a ChangeListener object on sliderC.
    //Each time sliderC fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderABandC.
    sliderC.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          handleSliderABandC();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    //This slider not used
    //Register a ChangeListener object on sliderD.
    //Each time sliderD fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // handleSliderD. Note that this is a different
    // method than the method called by the three
    // previous listener objects.
    sliderD.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          getToolkit().getDefaultToolkit().beep();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

    //This slider not used.
    //Register a ChangeListener object on sliderE.
    //Each time sliderE fires a ChangeEvent, this event
    // handler causes the computer to beep solely to
    // demonstrate that the slider is alive. Note that the
    // beep occurs at the end of the slider travel.
    sliderE.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          getToolkit().getDefaultToolkit().beep();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*
  This method makes it possible for the user to perform
  HSB color editing on a digital photo. The method is
  called each time any one of the the Hue, Sat, or Bright
  sliders fires a ChangeEvent. Events are fired when the
  user moves the sliders.

  Immediately before this method is called, a new
  display is created, which is a copy of the original
  picture. This method operates only on the display. It
  does not modify the original picture.

  Each time this method is called, it gets the value of
  each slider and uses that value to modify the
  corresponding hue, saturation, and brightness property
  for every pixel in the image currently residing in the
  display.

  Basically, for each pixel, the method does the
  following:
  1. Gets the red, green, and blue values from the native
  RGB color model data for the pixel.
  2. Converts the RGB values into HSB values.
  3. Modifies the HSB values independently of one another
  using the current slider values.
  4. Converts the modified HSB values back to RGB values.
  5. Uses the RGB values to set the modified color into
  the pixel.

  The method is synchronized to eliminate the possiblilty
  that it may be called on two threads concurrently.
  */
  private synchronized void handleSliderABandC(){
    pixels = display.getPixels();
    float[] hsbvals = new float[3];//HSB pixel values.

    //Process every pixel in the image using the same
    // algorithm.
    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      //Get the red, green, and blue values for the
      // current pixel.
      red = pixels[cnt].getRed();
      green = pixels[cnt].getGreen();
      blue = pixels[cnt].getBlue();

      //Get the three HSB color model values that
      // correspond to the current pixel color expressed
      // in the RGB color model. When the method returns,
      // the three HSB values have been placed in the
      // three-element array referred to by hsbvals in the
      // order hue, saturation, and brightness.
      Color.RGBtoHSB(red,green,blue,hsbvals);

      //Modify the hue value for the pixel based on the
      // current value of the Hue slider. Note that this
      // statement performs addition instead of
      // multiplication.
      hsbvals[0] = (float)(hsbvals[0] +
                           sliderA.getValue()/360.0);//hue

      //Modify the saturation value for the pixel based
      // on the current value of the Sat slider. Note
      // that multiplication is used here.
      hsbvals[1] = (float)(hsbvals[1] *
                    sliderB.getValue()/100.0);//saturation
      //If the computed value is greter than 1.0, clip it
      // at 1.0.
      if(hsbvals[1] &gt; 1.0) hsbvals[1] = (float)1.0;

      //Modify the brightness value for the pixel based
      // on the current value of the Bright slider. Once
      // again, multiplication is used here.
      hsbvals[2] = (float)(hsbvals[2] *
                    sliderC.getValue()/100.0);//brightness
      if(hsbvals[2] &gt; 1.0) hsbvals[2] = (float)1.0;

      //Convert the HSB color values back into RGB color
      // values.
      int color = Color.HSBtoRGB(
                        hsbvals[0],hsbvals[1],hsbvals[2]);

      //Use the RGB color values to set the modified color
      // in the pixel.
      pixels[cnt].setColor(new Color(color));

    }//end for loop

    //Repaint the display.
    display.repaint();

  }//end handleSliderABandC
  //----------------------------------------------------//

}//end class HsbEdit02

</pre>
		</td>
	</tr>
</table>
</p>

<p></p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in 
any form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting 
projects and he frequently provides onsite training at the high-tech companies 
located in and around Austin, Texas.&nbsp; He is the author of Baldwin's 
Programming <a href="http://www.dickbaldwin.com">Tutorials</a>, which have 
gained a worldwide following among experienced and aspiring programmers. He has 
also published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job 
after he earned his Bachelor's degree was doing DSP in the Seismic Research 
Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
In the following years, he applied his programming and DSP expertise to other 
interesting areas including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>

</body>

</html>
