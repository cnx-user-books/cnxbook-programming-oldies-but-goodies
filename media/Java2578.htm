<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Handling Life-Cycle Issues with the MIDlet User Interface</h2>
<p><i>Learn to program MIDlet user interfaces that minimize the MIDlet's memory 
footprint while the MIDlet is paused making consistent use of the MIDlet class 
methods to satisfy the life cycle rules of MIDlets.</i></p>
<p><b>Published:</b>&nbsp; February 26, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2578</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_MIDlet_named_UI01">The MIDlet named UI01</a></li>
		<li><a href="#The_MIDlet_named_SaveState01">The MIDlet named SaveState01</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p>This is one in a series of tutorial lessons designed to teach you how to 
write programs using the Sun Java Wireless Toolkit for CLDC.&nbsp; The first lesson 
was titled <i>Getting Started with MIDlets and the Sun Java Wireless Toolkit for 
CLDC</i>.&nbsp; This is the second part of a lesson titled <i>Introduction to the MIDlet User 
Interface (see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>A MIDlet development framework</b></font></p>
<p>For this lesson, you will need the MIDlet development framework that I 
provided in the earlier lesson titled <i>Capturing Output Produced by Programs 
Running in a Child Process</i> <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>What you learned in the previous part</b></font></p>
<p>In the previous part of this lesson, you learned:</p>
<ul>
	<li>The fundamentals of user interfaces for MIDlets.</li>
	<li>How to instantiate user interface components.</li>
	<li>How to cause them to become visible on the cell phone screen.</li>
	<li>The difference between a Screen and a Display.</li>
	<li>About restrictive constraints and modifier flags.</li>
	<li>About the MIDlet user interface class hierarchy, and </li>
	<li>About the methods of the various classes that can be used to manipulate 
	user input and output.</li>
</ul>
<p><font color="#FF0000"><b>What you will learn in this part</b></font></p>
<p>The sample programs used in the previous part of this lesson <i>(see
<a href="#Resources">Resources</a>)</i> were about as simple as I could make them.&nbsp; 
Those programs made no serious effort to honor the life cycle requirements for 
MIDlets.&nbsp; In this part, you will learn to program MIDlet user interfaces that 
minimize the MIDlet's memory footprint while the MIDlet is paused making 
consistent use of the MIDlet class methods to satisfy the life cycle rules of 
MIDlets.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Cell phone emulator output for MIDlet 
	UI01 in active state.</li>
	<li><a href="#Figure_2">Figure 2</a>. Cell phone emulator output for MIDlet 
	UI01 in paused state.</li>
	<li><a href="#Figure_3">Figure 3</a>. Partial standard output from MIDlet 
	UI01.</li>
	<li><a href="#Figure_4">Figure 4</a>. Partial standard output from MIDlet 
	SaveState01.<b> </b></li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the MIDlet named UI01.</li>
	<li><a href="#Listing_2">Listing 2</a>. The beginning of the startApp method 
	for UI01.</li>
	<li><a href="#Listing_3">Listing 3</a>. The remainder of the startApp method 
	for UI01.</li>
	<li><a href="#Listing_4">Listing 4</a>. The pauseApp method for UI01.</li>
	<li><a href="#Listing_5">Listing 5</a>. The destroyApp method for UI01.</li>
	<li><a href="#Listing_6">Listing 6</a>. The resume method for UI01.</li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the Toggler class for 
	UI01.</li>
	<li><a href="#Listing_8">Listing 8</a>. Beginning of the run method for the 
	Toggler thread.</li>
	<li><a href="#Listing_9">Listing 9</a>. Loop for 2.5 cycles.</li>
	<li><a href="#Listing_10">Listing 10</a>. Signal the MIDlet to enter the 
	active state.</li>
	<li><a href="#Listing_11">Listing 11</a>. Signal the MIDlet to enter the 
	destroyed state.</li>
	<li><a href="#Listing_12">Listing 12</a>. Beginning of the Worker class for 
	UI01.</li>
	<li><a href="#Listing_13">Listing 13</a>. Beginning of the run method for 
	the Worker thread.</li>
	<li><a href="#Listing_14">Listing 14</a>. Worker thread enters an infinite 
	loop.</li>
	<li><a href="#Listing_15">Listing 15</a>. Check the paused flag and behave 
	accordingly.</li>
	<li><a href="#Listing_16">Listing 16</a>. The Worker thread goes to sleep.</li>
	<li><a href="#Listing_17">Listing 17</a>. Code executed when the kill flag 
	is true.</li>
	<li><a href="#Listing_18">Listing 18</a>. Beginning of the class named 
	SaveState01.</li>
	<li><a href="#Listing_19">Listing 19</a>. The pauseApp method for 
	SaveState01.</li>
	<li><a href="#Listing_20">Listing 20</a>. The destroyApp method for 
	SaveState01.</li>
	<li><a href="#Listing_21">Listing 21</a>. Beginning of the Worker class in 
	SaveState01.</li>
	<li><a href="#Listing_22">Listing 22</a>. Beginning of the run method for 
	the Worker class.</li>
	<li><a href="#Listing_23">Listing 23</a>. Loop and take naps while the user 
	edits the TextBox.</li>
	<li><a href="#Listing_24">Listing 24</a>. Take a short nap.</li>
	<li><a href="#Listing_25">Listing 25</a>. The Worker thread dies.</li>
	<li><a href="#Listing_26">Listing 26</a>. The MIDlet program named UI01.</li>
	<li><a href="#Listing_27">Listing 27</a>. The MIDlet program named 
	SaveState01.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>MIDlet testing</b><br>
				The MIDlets in this lesson were tested using a Java SE 6 
				compiler, targeted at a V1.4 virtual machine, and WTK 2.5.2 
				running under Windows XP.
				</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<p>In the previous part of this lesson <i>(see <a href="#Resources">Resources</a>)</i>, I showed you 
the code for two very simple MIDlets that 
were designed specifically to illustrate specific MIDlet programming concepts 
involving the user interface.&nbsp; Those MIDlets made very little effort to 
satisfy the rules for compliance with the life cycle requirements of a MIDlet.</p>
<p>
In this second part of the lesson, I will present and explain two MIDlets that will show how to 
write user interface code while complying with the life cycle requirements of a 
MIDlet.</p>
<p>The second MIDlet will differ from the first.&nbsp; In addition to complying 
with the life cycle requirements, it will also attempt to minimize the memory 
footprint of the MIDlet while the MIDlet is in the paused state.</p>
<h3><a name="The_MIDlet_named_UI01">The MIDlet named UI01</a></h3>
<p>The purpose of this MIDlet program is:</p>
<ul>
	<li>To illustrate a MIDlet user interface using a simple <b>
	TextBox</b> as an example.</li>
	<li>To reinforce consistent use of the MIDlet class methods to satisfy the 
	life cycle rules of MIDlets.</li>
</ul>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>More threads are possible</b><br />
  There may be other active threads as well <i>(such as the garbage collector 
	thread)</i> that are created by the virtual machine.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Three threads</b></font></p>
<p>This MIDlet consists of three threads:&nbsp; One thread is the main MIDlet thread that services the life-cycle methods.</p>
<p>The second thread is a <b>Worker</b> thread that services a <b>TextBox</b> 
object that can be edited by the user while the MIDlet is in the active state, 
but cannot be seen or edited while the MIDlet is in the paused state.&nbsp; The 
user can edit the contents of the <b>TextBox</b> across several active/paused 
MIDlet cycles without losing information in the process.&nbsp; This thread 
displays the contents of the <b>TextBox</b> each time the MIDlet enters the 
paused state, and displays the final contents of the <b>TextBox</b> when the 
MIDlet enters the destroyed state.</p>
<p>The third thread is a <b>Toggler</b> thread.&nbsp; It exists solely to force 
the MIDlet to toggle between the paused state and the active state in order to 
test and exercise the behavior of the <b>Worker</b> thread.&nbsp; After several 
cycles of toggling between the paused and active states, the <b>Toggler</b> 
thread causes the MIDlet to enter the destroyed state.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>A complete listing of this program is presented in Listing 26.&nbsp; As is my 
custom, I will present and explain the MIDlet program in fragments.&nbsp; 
However, before getting into the details of the code, I will show you two screen 
shots of the output from the Sun cell phone emulator when the MIDlet is in 
the active state and the paused state along with a partial listing of the 
standard output from the MIDlet.</p>
<p><font color="#FF0000">
 <b>Cell phone emulator output for MIDlet UI01 in active state</b></font></p>
<p>Figure 1 shows the cell phone emulator output for the MIDlet when it was in 
the active state.&nbsp; As you can see, I entered a portion of my name in the <b>
TextBox</b> before the <b>Toggler</b> thread caused the MIDlet to enter the 
paused state.</p>
<p>
 <b><a name="Figure_1">Figure 1</a>. Cell phone emulator output for MIDlet UI01 
	in active state. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2578b2.jpg" width="312" height="382"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Cell phone emulator output for MIDlet UI01 in paused state</b></font></p>
<p>Figure 2 shows the cell phone emulator output when the MIDlet was in the 
paused state.&nbsp; As you can see, this output completely obscured the output 
shown in Figure 1 because a different <b>TextBox</b> became the <i>current</i>
<b>Displayable</b> object when the MIDlet entered the paused state.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Cell phone emulator output for MIDlet 
	UI01 in paused state. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2578b1.jpg" width="312" height="380"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The fact that the text contents of the <b>TextBox</b> in Figure 2 are gray 
instead of black is a 
visual indication that the text is UNEDITABLE.&nbsp; The Incoming Call message 
on the screen was placed there by the cell phone emulator.&nbsp; Apparently this 
is the standard screen output for the Sun cell phone emulator when a MIDlet is 
in the paused state.</p>
<p><font color="#FF0000"><b>Original TextBox was restored</b></font></p>
<p>A very important aspect of the behavior of the MIDlet is that when the MIDlet 
once again became active, the display shown in Figure 1 returned to the screen.&nbsp; 
The text that was showing when the MIDlet entered the paused state was still 
there and available for editing.</p>
<p><font color="#FF0000">
 <b>Partial standard output from MIDlet UI01</b></font></p>
<p>Figure 3 shows a partial listing of the standard output produced by the 
MIDlet.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Partial standard output from MIDlet UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>OUT: MIDlet Constructed
OUT: MIDlet Started
OUT: Toggler constructed
OUT: Worker constructed
OUT: Toggler Thread Started
OUT: Worker Thread Started
OUT: MIDlet Paused
OUT: Worker awakened from a nap
OUT: <b>TextBox contents: Dick B</b>
OUT: MIDlet Re-Started
OUT: Worker awakened from the pause
OUT: MIDlet Paused
OUT: Worker awakened from a nap
OUT: <b>TextBox contents: Dick Bald</b>
OUT: MIDlet Re-Started
OUT: Worker awakened from the pause
OUT: MIDlet Destroyed
OUT: Toggler dying
OUT: Worker awakened from a nap
OUT: <b>Final TextBox contents: Dick Baldwin</b>
OUT: Worker committing suicide</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Note the boldface text in particular</b></font></p>
<p>Much of the output in Figure 3 will become clear as we examine the code for 
the MIDlet and you see the print statements in the code.&nbsp; At this point, the three lines of text that I manually 
highlighted in boldface are the most important.&nbsp; The first two boldface 
lines of text show the contents of the <b>TextBox</b> each time the MIDlet 
entered the paused state.&nbsp; The third line of boldface text shows the final 
contents of the <b>TextBox</b> object.&nbsp; As you can see, the contents of the <b>TextBox</b> were not lost when the 
MIDlet entered the paused state and I was able to edit the <b>TextBox</b> 
by entering additional characters from my name each time the MIDlet entered the 
active state.</p>
<p><font color="#FF0000"><b>Two Displayable objects</b></font></p>
<p>Basically this MIDlet has two <b>Displayable</b> objects.&nbsp; One is shown 
in Figure 1 and the other is shown in Figure 2.&nbsp; When the MIDlet enters 
the active state, the object shown in Figure 1 becomes the <i>current</i> <b>
Displayable</b> object.&nbsp; When the MIDlet enters the paused state, the 
object shown in Figure 2 becomes the <i>current</i> <b>Displayable</b> object.&nbsp; 
Therefore, the MIDlet is able to toggle between these two objects, making one or 
the other of them visible at any point in time 
with no loss of data.</p>
<p><font color="#FF0000">
<b>Beginning of the MIDlet named UI01</b></font></p>
<p>Listing 1 shows the beginning of the MIDlet named <b>UI01</b> including the 
constructor.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the MIDlet named UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>UI01</b> extends MIDlet{

  //Variables needed only by the MIDlet.
  Worker theWorker;
  boolean running = false;

  //Variables needed by the Worker thread
  boolean paused;//true indicates paused
  boolean kill;//true means time for Worker to die

  //Variables needed by both Worker and Toggler threads
  UI01 theMIDlet;

  public <b>UI01</b>(){//Constructor
    System.out.println("MIDlet Constructed");
    theMIDlet = this;
    paused = true;
    kill = false;
  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 1 is straightforward and shouldn't require any 
explanation beyond the comments that are embedded in the code.</p>
<p><font color="#FF0000">
<b>The beginning of the startApp method for UI01</b></font></p>
<p>The <b>startApp</b> method is called by the cell phone's Application 
Management Software <i>(AMS)</i> each time the state of the MIDlet changes from 
paused to active.&nbsp; The beginning of the <b>startApp</b> method is shown in 
Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. The beginning of the startApp method for 
UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void <b>startApp</b>(){
    if(!running){
      //This is the first time that this method has been
      // called.
      System.out.println("MIDlet Started");
      running = true;
      //Create a new Toggler thread and start it running.
      new Toggler().start();

      //Create a new Worker thread and start it running
      // in an active state.
      paused = false;
      theWorker = new Worker();
      theWorker.start();
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>First transition from paused to active states</b></font></p>
<p>The MIDlet is initially in the paused state when it is launched by the user.&nbsp; The AMS calls the <b>
startApp</b> method to cause the MIDlet to enter the active state.&nbsp; The 
code in Listing 2 is executed the first time the <b>startApp</b> method is called.&nbsp;
<i>(The code in Listing 3 is executed on each subsequent call to the <b>startApp</b> 
method.)</i></p>
<p>The first time the <b>startApp</b> method is called, the code in Listing 2 
instantiates new objects of the <b>Thread</b> classes named <b>Toggler</b> 
and <b>Worker</b> and starts the two new threads running.</p>
<p><font color="#FF0000">
<b>The remainder of the startApp method for UI01</b></font></p>
<p>The remainder of the <b>startApp</b> method is shown in Listing 3.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. The remainder of the startApp method for 
UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    }else{
      //This is not the first time that this method has
      // been called.
      System.out.println("MIDlet Re-Started");
      //Wake the Worker thread up if it is asleep. Set
      // the paused flag to false to tell the worker to
      // get to work.
      paused = false;
      theWorker.interrupt();
    }//end else
  }//end startApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As mentioned earlier, the code in Listing 3 will be executed for each call to 
the <b>startApp</b> method following the first call to the method.</p>
<p><font color="#FF0000"><b>Wake the Worker thread</b></font></p>
<p>As you will see later, the <b>Worker</b> thread will have been put to sleep for a long time period 
when the MIDlet entered the paused state.&nbsp; The code in Listing 3 wakes it 
up by calling the <b>interrupt</b> method on the thread.&nbsp; The code in 
Listing 3 also sets the <b>paused</b> flag to false as a signal to the <b>Worker</b> thread 
that it should now be working and not sleeping because the MIDlet is in the 
active state.&nbsp; <i>(Note, however, that even when the MIDlet is in the active 
state, the <b>Worker</b> thread takes a series of short naps to avoid consuming 
excessive computer resources.)</i></p>
<p><font color="#FF0000">
<b>The pauseApp method for UI01</b></font></p>
<p>The <b>pauseApp</b> method is shown in its entirety in Listing 4.&nbsp; This method is called by the
<b>Toggler</b> thread to cause the MIDlet to enter the paused state. It may also be called by the AMS.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. The pauseApp method for UI01.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void pauseApp(){
    //Tell Worker to go to sleep for a long time the next
    // time it checks the paused flag.
    paused = true;
    //Wake the worker up if it is asleep so that it will
    // check the pause flag quickly.
    theWorker.interrupt();
    System.out.println("MIDlet Paused");
    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Tell the worker to go to sleep for a long time 
period</b></font></p>
<p>The code in Listing 4 sets the <b>paused</b> flag to true as a signal to the
<b>Worker</b> thread.&nbsp; The next 
time the <b>Worker</b> thread wakes up from a short nap and checks the status of 
the <b>paused</b> flag, it will go back to 
sleep for a very long time period.&nbsp; It is not intended that the<b> Worker</b> thread will 
awaken from this long period of sleep of its own accord.&nbsp; Rather, it is 
intended that it will sleep until the MIDlet once again becomes active, at which 
time it will be 
awakened by the <b>startApp</b> method.</p>
<p><font color="#FF0000"><b>Wake up from your nap and check the flag</b></font></p>
<p>Note that the code in Listing 4 calls the <b>interrupt</b> method 
on the <b>Worker</b> thread to wake it up if it is taking a nap.&nbsp; This will 
cause the thread to check the <b>paused</b> flag more quickly than if it were to 
continue napping until it awakens of its own accord.</p>
<p>The code in Listing 4 also calls the <b>notifyPaused</b> method to signal the 
AMS that the MIDlet has entered the paused state.</p>
<p><font color="#FF0000">
<b>The destroyApp method for UI01</b></font></p>
<p>Listing 5 shows a complete listing of the <b>destroyApp</b> method.&nbsp; This method is called by the
<b>Toggler</b> thread to cause the MIDlet to enter the destroyed state.&nbsp; It may also be called by the AMS.&nbsp; The incoming parameter is ignored in this 
implementation of the MIDlet.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. The destroyApp method for UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void destroyApp(boolean unconditional){
    //Tell the Worker to commit suicide the next time it
    // checks the kill flag.
    kill = true;
    //Wake the worker up if it is asleep so that it will
    // check the kill flag quickly.
    theWorker.interrupt();

    System.out.println("MIDlet Destroyed");
    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Time for the Worker thread to die</b></font></p>
<p>The code in Listing 5 sets the <b>kill</b> flag to signal the <b>Worker</b> 
thread that it should die the next time it wakes up from its nap and checks the
<b>kill</b> flag.&nbsp; Then the code purposely wakes the thread up if it is 
napping.&nbsp; Finally, the code in Listing 5 calls the <b>notifyDestroyed</b> 
method to signal the AMS that it is entering the destroyed state.&nbsp; 
Presumably, at this point, the AMS will make the MIDlet object eligible for 
garbage collection following which the MIDlet can again be launched from the 
cell phone keypad.</p>
<p><font color="#FF0000">
<b>The resume method for UI01</b></font></p>
<p>Listing 6 shows the <b>resume</b> method.&nbsp; This method is called by the
<b>Toggler</b> thread to signal the MIDlet that it should request to be returned to the active state.&nbsp; 
If the request is honored by the AMS, it will call the <b>startApp</b> method.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The resume method for UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void resume(){
    resumeRequest();
  }//end resume</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the Toggler class for UI01</b></font></p>
<p>The Beginning of the Toggler class for UI01 including the constructor is 
shown in Listing 7.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the Toggler class for UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class Toggler extends Thread{

    Toggler(){
      System.out.println("Toggler constructed");
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The class named <b>Toggler</b> is a member class.&nbsp; The purpose of an 
object of this class is to cause the MIDlet to toggle between the active state 
and the paused state for a total of 2.5 cycles <i>(3 active periods and 2 paused 
periods)</i>.&nbsp; While the MIDlet is in the paused state, this thread 
displays uneditable text on the cell phone screen as shown in Figure 2.&nbsp; 
The AMS also displays an <i>Incoming Call</i> message during the time that the 
MIDlet is paused.&nbsp; After 2.5 cycles, this thread instructs the MIDlet to 
enter the destroyed state.</p>
<p><font color="#FF0000">
<b>Beginning of the run method for the Toggler thread</b></font></p>
<p>Listing 8 shows the beginning of the <b>run</b> method for the <b>Toggler</b> 
thread.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Beginning of the run method for the 
Toggler thread. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void <b>run</b>(){
      System.out.println("Toggler Thread Started");
      
      //Create an UNEDITABLE TextBox
      TextBox textBox = new TextBox(
                                "Text Display by Toggler",
                                "",//text in TextBox
                                27,//width of TextBox
                                TextField.UNEDITABLE);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Recall that a thread's <b>run</b> method is executed when another thread 
calls the <b>start</b> method on the thread object, as was done in Listing 2.</p>
<p><font color="#FF0000"><b>Create an UNEDITABLE TextBox</b></font></p>
<p>Listing 8 uses the <b>TextBox</b> constructor to create a new <b>TextBox</b> 
object with an empty string and an UNEDITABLE constraint.&nbsp; <i>(The <b>
TextBox</b> will be populated later by calling the <b>setString</b> method on 
the <b>TextBox</b> object.)</i></p>
<p><font color="#FF0000">
<b>Loop for 2.5 cycles</b></font></p>
<p>Listing 9 shows the beginning of a <b>for</b> loop that will loop for five 
iterations <i>(2.5 full cycles with three active periods and two paused periods)</i>. </p>
<p>
<b><a name="Listing_9">Listing 9</a>. Loop for 2.5 cycles. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      for(int cnt = 0;cnt &lt; 5;cnt++){
        if(cnt % 2 != 0){
          //Tell the thread to enter the paused
          // state on odd values of cnt.
          theMIDlet.pauseApp();

          //Now display some uneditable text while the
          // MIDlet is paused.
          //The TextBox must be wide enough to contain all
          // of the text.  Otherwise a
          // java/lang/IllegalArgumentException will be
          // thrown.
          textBox.setString(
                       "UNEDITABLE Toggler text: " + cnt);
          Display.getDisplay(theMIDlet).
                                      setCurrent(textBox);

          //Sleep for two seconds with the MIDlet in the
          // paused state. Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(2000);
          }catch(Exception e){}</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Signal the MIDlet to enter the paused state</b></font></p>
<p>This thread uses the odd versus even value of the <b>for</b> loop counter to 
decide whether to signal the MIDlet to pause or to become active.&nbsp; When the 
value of <b>cnt</b> is odd, the code in Listing 9 calls the <b>pauseApp</b> 
method on the MIDlet thread to signal the MIDlet that it should enter the paused 
state <i>(see Listing 4)</i>.</p>
<p><font color="#FF0000"><b>Populate and display the TextBox and go to sleep</b></font></p>
<p>Then the code in Listing 9 calls the <b>setString</b> method to populate the
<b>TextBox</b> with a string that includes the current value of <b>cnt</b>.&nbsp; 
Then it calls the <b>setCurrent</b> method to cause the <b>TextBox</b> to become 
the visible <b>Displayable</b> object.&nbsp; Following that, the <b>Toggler</b> 
thread sleeps for two seconds and then returns control to the top of the <b>for</b> 
loop.</p>
<p><font color="#FF0000">
<b>Signal the MIDlet to enter the active state</b></font></p>
<p>Listing 10 shows the code that is executed when the value of the loop counter 
is even.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Signal the MIDlet to enter the active 
state. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        }else{//The value of cnt is even.
          theMIDlet.resume();

          //Sleep for four seconds with the MIDlet in the
          // active state.  Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(4000);
          }catch(Exception e){}
        }//end else
      }//end for loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This code calls the <b>resume</b> method on the MIDlet, which causes the 
MIDlet to send a request to the AMS to return it to the active state.&nbsp; If 
the request is honored, the AMS will call the <b>startApp</b> method on the 
MIDlet thread.&nbsp; Note in particular that this code does not call the <b>
startApp</b> method directly but delegates that action to the AMS by way of the 
MIDlet.</p>
<p><font color="#FF0000">
<b>Signal the MIDlet to enter the destroyed state</b></font></p>
<p>Listing 11 shows the code that is executed when the <b>for</b> loop that 
began in Listing 9 terminates.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Signal the MIDlet to enter the destroyed 
state. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      theMIDlet.destroyApp(true);

      //This thread will die at this point.
      System.out.println("Toggler dying");
    }//end run
  }//end class Toggler</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 11 calls the <b>destroyApp</b> method <i>(see Listing 5)</i> to 
signal the MIDlet that it should enter the destroyed state.&nbsp; Then the <b>
Toggler</b> thread's <b>run</b> method terminates, which causes the <b>Toggler</b> 
thread to die a natural death.</p>
<p><font color="#FF0000">
<b>Beginning of the Worker class for UI01</b></font></p>
<p>Listing 12 shows the beginning of the <b>Worker</b> class including the 
constructor.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Beginning of the Worker class for UI01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class Worker extends Thread{
    long nap = 1;//Sleep for one millisecond
    long longSleep = 25000000;//6.94 hours
    long sleepTime = nap;
    String title = "Enter Text";//TextBox title
    int width = 50;//TextBox width.

    Worker(){
      System.out.println("Worker constructed");
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of an object of this member class is to do some work while the 
MIDlet is in the active state and to sleep while the MIDlet is in the paused 
state.&nbsp; An object of this class also sleeps some of the time while the 
MIDlet is in the active state to avoid consuming major computational resources.</p>
<p>The general behavior of this thread is:</p>
<ul>
	<li>Create an empty <b>TextBox</b> when the thread is started.</li>
	<li>Set the title for the <b>TextBox</b>.</li>
	<li>Allow the user to enter text in the <b>TextBox</b> while the MIDlet is 
	in the active state.</li>
	<li>Display the current contents of the <b>TextBox</b> when the MIDlet 
	enters the paused state.</li>
	<li>Display the final contents of the <b>TextBox</b> when the MIDlet is 
	destroyed.</li>
</ul>
<p><font color="#FF0000">
<b>Beginning of the run method for the Worker thread</b></font></p>
<p>The <b>run</b> method for the <b>Worker</b> thread begins in Listing 13.&nbsp;
<i>(Recall that the <b>start</b> method is called on this thread by the <b>
startApp</b> method in Listing 2.)</i></p>
<p>
<b><a name="Listing_13">Listing 13</a>. Beginning of the run method for the 
Worker thread.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void run(){
      System.out.println("Worker Thread Started");
      //Create and display an empty TextBox.
      TextBox textBox = new TextBox(title,
                                    "",//TextBox text
                                    width,
                                    TextField.ANY);
      Display.getDisplay(theMIDlet).setCurrent(textBox);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 13 creates and displays a new empty <b>TextBox</b> object that will 
accept any input characters from the user.</p>
<p><font color="#FF0000">
<b>Worker thread enters an infinite loop</b></font></p>
<p>The worker thread enters an infinite loop in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Worker thread enters an infinite loop. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      while(true){//Enter an infinite loop
        if(kill){//Check the kill flag
          //The kill flag is true.
          //This break will cause the thread to break out
          // of the while loop and die.
          break;
        }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Immediately upon entering the loop, Listing 14 checks to see if the <b>kill</b> 
flag has been set to true by the MIDlet's destroyApp method <i>(see Listing 5)</i>.&nbsp; 
If so, Listing 14 executes a <b>break</b> statement, which causes the <b>while</b> 
loop to terminate.&nbsp; You will see later that the <b>Worker</b> thread dies 
upon termination of the loop.</p>
<p><font color="#FF0000">
<b>Check the paused flag and behave accordingly</b></font></p>
<p>At this point the <b>Worker</b> thread checks the value of the <b>paused</b> 
flag, which is set to true by the <b>pauseApp</b> method <i>(see Listing 4)</i> 
and set to false by the <b>startApp</b> method <i>(see Listing 2 and Listing 3)</i>.&nbsp; 
Depending on the value of the <b>paused</b> flag, the <b>Worker</b> thread will 
either:</p>
<ul>
	<li>Take a short nap to avoid consuming computer resources if the flag is 
	false, or</li>
	<li>Display the contents of the <b>TextBox</b> and go to sleep for a very 
	long time period if the flag is true.</li>
</ul>
<p>The code in Listing 15 performs the check on the <b>paused</b> flag and sets 
the value of a variable named <b>sleepTime</b> to represent either a short nap 
or a very long sleep.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Check the paused flag and behave 
accordingly. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        if(!paused){//Check the paused flag.
          //The MIDlet is not in the paused state. Sleep
          // for a short period of time and allow the
          // user to edit the text in the TextBox. Then
          // loop back around and check the paused flag
          // again.
          sleepTime = nap;
        }else{
          //The MIDlet is in the paused state. Display the
          // text in the TextBox.  Then go to sleep for a
          // very long time.  Will wake when the startApp
          // method calls the interrupt method on the
          // thread.
          System.out.println("TextBox contents: "
                                   + textBox.getString());
          sleepTime = longSleep;
        }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The Worker thread goes to sleep</b></font></p>
<p>In Listing 16, the <b>Worker</b> thread goes to sleep for a period of time 
determined by the value of the variable named <b>sleepTime</b>.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. The Worker thread goes to sleep. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        try{
          Thread.currentThread().sleep(sleepTime);
        }catch(InterruptedException e){
          if(sleepTime == longSleep){
            System.out.println(
                     "Worker awakened from the pause");
          }else{
            System.out.println(
                     "Worker awakened from a nap");
          }//end else

          Display.getDisplay(theMIDlet).setCurrent(
                                                 textBox);
        }//end catch

      }//end while loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If the worker thread wakes of its own accord:</p>
<ul>
	<li>The code in the <b>catch</b> 
block in Listing 16 will be skipped.</li>
	<li>Control will return to the top of the <b>while</b> loop in Listing 14.</li>
	<li>The <b>kill</b> and <b>paused</b> flags will be 
checked again.</li>
	<li>The entire process will be repeated.</li>
</ul>
<p>This is likely to 
happen when the MIDlet is in the active state and the <b>Worker</b> thread is 
taking a series of short naps.</p>
<p>If the <b>interrupt</b> method is called on the <b>Worker</b> thread while it 
is sleeping, the code in the <b>catch</b> block will be executed.&nbsp; This can 
happen as the result of code executed in the life-cycle methods in 
the main MIDlet thread <i>(see Listings 3, 4, and 5)</i>.</p>
<p>When the code in the <b>catch</b> block is executed:</p>
<ul>
	<li>The <b>Worker</b> thread announces that it has been awakened.</li>
	<li>The <b>TextBox</b> belonging to the <b>Worker</b> thread is made the 
	current <b>Displayable</b> object <i>(see the explanation below)</i>.</li>
	<li>Control returns to the top of the <b>while</b> loop and the process is 
	repeated.</li>
</ul>
<p><font color="#FF0000"><b>Making the Worker thread's TextBox the current 
Displayable object</b></font></p>
<p>Recall that in Listing 9, the<b> Toggler</b> thread's <b>TextBox</b> was made 
the current <b>Displayable</b> object.&nbsp; This caused it to be visible on the 
cell phone screen during the entire period that the MIDlet was paused as shown 
in Figure 2.</p>
<p>There are only three cases in which the <b>catch</b> block in Listing 16 will 
be executed:</p>
<ol>
	<li>The MIDlet is entering the paused state <i>(see Listing 4)</i>.</li>
	<li>The MIDlet is entering the destroyed state <i>(see Listing 5)</i>.</li>
	<li>The MIDlet is entering the active state from the paused state <i>(see 
	Listing 3)</i>.</li>
</ol>
<p><font color="#FF0000"><b>The third circumstance is the important one</b></font></p>
<p>For the first two cases listed above, setting the<b> Worker</b> thread's<b> 
TextBox </b>to the current <b>Displayable</b> object is of no consequence.&nbsp; 
However, this code is necessary for the third case where the MIDlet is 
transitioning from the paused state to the active state.</p>
<p>During the paused state, the screen display is as shown in Figure 2.&nbsp; It 
is necessary to set the<b> Worker</b> thread's<b> TextBox</b> to the current <b>
Displayable</b> object to return the display to that shown in Figure 1.</p>
<p><font color="#FF0000"><b>The end of the while loop</b></font></p>
<p>Listing 16 signals the end of the <b>while</b> loop.&nbsp; When the code in 
the <b>catch</b> block has executed, control will return to the top of the <b>
while</b> loop where the <b>kill</b> flag will be tested for true.&nbsp; Recall 
that the value of the <b>kill</b> flag is set to true by the MIDlet's <b>
destroyApp</b> method <i>(see Listing 5)</i>.</p>
<p><font color="#FF0000">
<b>Code executed when the kill flag is true</b></font></p>
<p>The code in Listing 17 is executed when the code in Listing 14 finds the <b>
kill</b> flag to be true and executes a <b>break</b> statement to break out of 
the loop.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Code executed when the kill flag is 
true. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      System.out.println("Final TextBox contents: "
                                   + textBox.getString());
      System.out.println("Worker committing suicide");
    }//end run
  }//end class Worker
  //====================================================//

}//end class UI01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 17 displays the final contents of the <b>Worker</b> thread's <b>
TextBox</b>.&nbsp; Then the <b>run</b> method terminates causing the <b>Worker</b> 
thread to die a natural death.</p>
<p>Listing 17 also signals the end of the <b>Worker</b> class and the end of the 
MIDlet program named <b>UI01</b>.</p>
<h3><a name="The_MIDlet_named_SaveState01">The MIDlet named SaveState01</a></h3>
<p>The purpose of this MIDlet is to:</p>
<ul>
	<li>Introduce the topic of the MIDlet user interface using a simple <b>
	TextBox</b> as an example.</li>
	<li>Illustrate one approach to minimizing the MIDlet's memory footprint 
	while the MIDlet is paused.</li>
	<li>Reinforce consistent use of the MIDlet class methods to satisfy the life 
	cycle rules of MIDlets.</li>
</ul>
<p><font color="#FF0000"><b>Three threads</b></font></p>
<p>As in the MIDlet named <b>UI01</b>, this MIDlet consists of three threads.&nbsp; 
One thread is the main MIDlet thread that services the life-cycle methods.</p>
<p><font color="#FF0000"><b>The second thread</b></font></p>
<p>The second thread is a <b>Worker</b> thread.&nbsp; It services a <b>TextBox</b> 
object that can be edited by the user while the MIDlet is active.&nbsp; When the 
MIDlet enters the paused state, the contents of the <b>TextBox</b> object are 
saved, and the <b>Worker</b> thread object, including the <b>TextBox</b> is made 
eligible for garbage collection.</p>
<p>When the MIDlet re-enters the active state, a new <b>Worker</b> thread, 
including a new <b>TextBox</b> is created.&nbsp; The new <b>TextBox</b> is 
populated with the contents that were saved from the previous <b>TextBox</b>.&nbsp; 
Therefore, the user can edit the contents of the <b>TextBox</b> across several 
active/paused MIDlet cycles without losing information in the process.</p>
<p><font color="#FF0000"><b>The third thread</b></font></p>
<p>The third thread is a <b>Toggler</b> thread, which forces the MIDlet to 
toggle between the paused state and the active state several times in order to 
test and exercise the ability of the <b>Worker</b> thread to release memory when 
the MIDlet enters the paused state, and to restore the state of the <b>Worker</b> 
thread and its <b>TextBox</b> when the MIDlet returns to the active state.</p>
<p>After several cycles of toggling the MIDlet between the paused and active 
states, the <b>Toggler</b> thread causes the MIDlet to enter the destroyed 
state.</p>
<p><font color="#FF0000"><b>The external behavior of the MIDlet</b></font></p>
<p>The external behavior of this MIDlet is very similar to the earlier MIDlet 
named <b>UI01</b>.&nbsp; However, this MIDlet differs from the earlier MIDlet in one very significant way:&nbsp; it relinquishes the memory occupied by 
the <b>Worker</b> thread each time the MIDlet enters the paused state.&nbsp; 
When the MIDlet re-enters the active state, a new <b>Worker</b> thread is 
constructed using the information that was saved earlier.</p>
<p><font color="#FF0000">
 <b>Standard output from the MIDlet named SaveState01</b></font></p>
<p>There is very little difference between the cell phone emulator output 
produced by this MIDlet and the output shown in Figure 1 and Figure 2.&nbsp; 
Therefore, I won't show you screen shots from the cell phone emulator for this 
MIDlet.&nbsp; However, there are some differences in the standard output 
produced by this MIDlet and the earlier MIDlet, so I will show you the standard 
output, which is contained in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Partial standard output from MIDlet 
	SaveState01.</b><table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>OUT: MIDlet Constructed
OUT: MIDlet Started
OUT: Toggler constructed
OUT: Worker constructed
OUT: Toggler Thread Started
OUT: Worker Thread Started
OUT: Worker awakened from a nap
OUT: <b>TextBox contents: Dick B</b>
OUT: Worker dead, eligible for garbage collection.
OUT: MIDlet Paused
OUT: MIDlet Re-Started
OUT: Worker constructed
OUT: Worker Thread Started
OUT: Worker awakened from a nap
OUT: <b>TextBox contents: Dick Bald</b>
OUT: Worker dead, eligible for garbage collection.
OUT: MIDlet Paused
OUT: MIDlet Re-Started
OUT: Worker constructed
OUT: Worker Thread Started
OUT: Worker awakened from a nap
OUT: <b>TextBox contents: Dick Baldwin</b>
OUT: Worker dead, eligible for garbage collection.
OUT: <b>Final TextBox contents: Dick Baldwin</b>
OUT: MIDlet Destroyed</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Note the boldface text</b></font></p>
<p>As before, the most important part of the standard output is the four lines 
of text that I manually highlighted in boldface.&nbsp; These four lines of text 
show the contents of the <b>TextBox</b> at four different points in time as the 
MIDlet cycles between the active and paused states.&nbsp; Each time the MIDlet 
transitioned from the paused state to the active state, the previous contents of 
the <b>TextBox</b> are restored and made available for editing by the user.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As usual, I will present and explain this MIDlet in fragments.&nbsp; A 
complete listing of this MIDlet is shown in Listing 27.&nbsp; Much of the code 
in this MIDlet is similar to or identical to the code that I explained earlier, 
and I won't repeat that explanation here.&nbsp; Rather, I will concentrate on 
explaining the differences between this MIDlet and the previous MIDlet.</p>
<p><font color="#FF0000">
<b>Beginning of the class named SaveState01</b></font></p>
<p>The beginning of the class named <b>SaveState01</b>, including the entire 
method named <b>startApp</b> is shown in Listing 18.&nbsp; For brevity, I 
deleted some of the code from Listing 18 that is identical to the code in the 
previous MIDlet.&nbsp; I also highlighted new code in this MIDlet in boldface.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Beginning of the class named 
SaveState01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class SaveState01 extends MIDlet{

  //Code deleted for brevity

  //Variables needed by the Worker thread
  boolean paused;//true indicates paused
  boolean kill;//true means time for the Worker to die
<b>  String savedText </b>= &quot;&quot;<b>;//TextBox text is saved here.
</b>
  //Code deleted for brevity

  //The following method is called by the AMS to change
  // the state of the MIDlet from paused to active.
  public void startApp(){
    if(!midletRunning){
      //Code deleted for brevity
<b>      //Unlike the previous MIDlet, no Worker thread is
      // created here.</b>
      
    }else{
      //Code deleted for brevity.
<b>      //Unlike the previous MIDlet, there is no requirement
      // to wake a sleeping Worker thread here.</b>
    }//end else

<b>    //Create a new Worker thread and start it running in
    // an active MIDlet state. Note that this code follows
    // the if-else statement.
    paused = false;
    theWorker = new Worker();
    theWorker.start();</b>
  }//end startApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A new instance variable</b></font></p>
<p>The class begins by declaring a new instance variable named <b>savedText</b>.&nbsp; 
It is used by the <b>Worker</b> thread to save the current contents of the <b>
TextBox</b> before the thread 
dies and becomes eligible for garbage collection.&nbsp; Note that this variable 
is initialized to an empty string in Listing 18.</p>
<p><font color="#FF0000"><b>Construct a new Worker thread</b></font></p>
<p>When the MIDlet enters the paused state, the <b>Worker</b> thread dies and 
becomes eligible for garbage collection.&nbsp; Therefore, there is no need for 
the code in the <b>startApp</b> method to wake a sleeping <b>Worker</b> thread.&nbsp; 
Rather, a new <b>Worker</b> thread must be constructed and populated each time 
the <b>startApp</b> method is called as shown by the boldface code at the end of 
the method.</p>
<p>Note however that the <b>Worker</b> thread still takes a series of short naps 
while the MIDlet is active to reduce the consumption of computational resources.&nbsp; 
Therefore, it is still necessary for the <b>pauseApp</b> method and the <b>
destroyApp</b> method to wake the <b>Worker</b> thread from its nap to cause it 
to check the flags more quickly.</p>
<p><font color="#FF0000">
<b>The pauseApp method for SaveState01</b></font></p>
<p>The <b>pauseApp</b> method is shown in Listing 19.&nbsp; This method is called by the
<b>Toggler</b> thread to cause the MIDlet to enter the paused state. It may also be called by the AMS.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. The pauseApp method for SaveState01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void pauseApp(){
    //<b>Tell Worker to die</b> the next time it checks the
    // paused flag.
    paused = true;
    //Wake the worker up if it is asleep so that it will
    // check the paused flag quickly.
    theWorker.interrupt();
    //Delay until the Worker thread dies.
<b>    while(theWorker.isAlive()){}
    //Make the worker object eligible for garbage
    // collection.
    theWorker = null;
    System.out.println(
    	 "Worker dead, eligible for garbage collection.");</b>
    System.out.println("MIDlet Paused");

    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Wait for the Worker thread to die</b></font></p>
<p>The things that are different about this version of the method are 
highlighted in boldface.</p>
<p>To begin with, in this MIDlet, the <b>Worker</b> is expected to die rather 
than to simply go to sleep for a long time when it finds that the <b>paused</b> 
flag has been set to true.</p>
<p>That being the case, the code in Listing 19 delays until it can confirm that 
the <b>Worker</b> thread is dead.&nbsp; Then it sets the reference to the <b>
Worker</b> object to <b>null</b> making the object eligible for garbage 
collection.</p>
<p>Having accomplished that, it prints a message and notifies the AMS that the 
MIDlet is entering the paused state.</p>
<p><font color="#FF0000">
<b>The destroyApp method for SaveState01</b></font></p>
<p>The <b>destroyApp</b> method is shown in Listing 20.&nbsp; This method is called by the
<b>Toggler</b> thread to cause the MIDlet to enter the destroyed state. It may also be called by the AMS.&nbsp;
<i>(The incoming parameter is ignored in this MIDlet.)</i></p>
<p>
<b><a name="Listing_20">Listing 20</a>. The destroyApp method for SaveState01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void destroyApp(boolean unconditional){
    //Tell the Worker to die the next time it checks the
    // kill flag.
    kill = true;
    //Wake the worker up if it is asleep so that it will
    // check the kill flag quickly.
    theWorker.interrupt();

<b>    //Delay until the Worker thread dies to make certain
    // that all of the text entered by the user is stored
    // in savedText.
    while(theWorker.isAlive()){}
    //Make the worker object eligible for garbage
    // collection.
    theWorker = null;
    System.out.println(
    	 "Worker dead, eligible for garbage collection.");

    System.out.println(
                  "Final TextBox contents: " + savedText);</b>

    System.out.println("MIDlet Destroyed");

<b>    //It is assumed that the following method call will
    // cause the AMS to make the MIDlet object eligible
    // for garbage collection, which in turn will make the
    // Toggler object eligible for garbage collection.</b>

    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The rationale for the new code in the <b>destroyApp</b> method is essentially 
the same as the rationale for the new code in the <b>pauseApp</b> method, so it 
shouldn't be necessary for me to explain that rationale again.&nbsp; Note also 
that the method named <b>resume</b> is identical and serves the same purpose in 
the two MIDlets, so I won't include another fragment showing the <b>resume</b> 
method.</p>
<p><font color="#FF0000"><b>The Toggler thread</b></font></p>
<p>There is essentially no difference between the <b>Toggler</b> class in the 
previous MIDlet named <b>UI01</b> and the <b>Toggler</b> class in this MIDlet.&nbsp; Therefore, another 
discussion of the <b>Toggler</b> thread should not be necessary.</p>
<p><font color="#FF0000"><b>The Worker class</b></font></p>
<p>As before, the purpose of an object of the member class named <b>Worker</b> 
is to do some work while the MIDlet is in the active state.&nbsp; However, 
unlike the previous MIDlet, the purpose of a<b> Worker</b> object in this MIDlet 
is to become eligible for garbage collection when the MIDlet enters the paused 
state.</p>
<p>An object of the <b>Worker</b> class also takes short naps while the MIDlet 
is in the active state to avoid consuming excessive computational resources.</p>
<p><font color="#FF0000"><b>Behavior of the Worker thread</b></font></p>
<p>The behavior of the <b>Worker</b> thread is:</p>
<ul>
	<li>Create an empty <b>TextBox</b> when the thread is started.</li>
	<li>Set the title for the <b>TextBox</b>.</li>
	<li>Allow the user to enter text into the <b>TextBox</b> while the MIDlet is 
	in the active state.</li>
	<li>Save the contents of the <b>TextBox</b> when the MIDlet enters the 
	paused state.</li>
	<li>Display the current contents of the <b>TextBox</b> when the MIDlet 
	enters the paused state.</li>
	<li>Make the <b>Worker</b> object eligible for garbage collection when the 
	MIDlet enters the paused state.</li>
	<li>Create a new <b>Worker</b> thread including a <b>TextBox</b> object when 
	the MIDlet enters the active state.&nbsp; Go back to the top.</li>
</ul>
<p>The code in the <b>Worker</b> class in this MIDlet is considerably different 
from the code in the same class in the MIDlet named <b>UI01</b>.&nbsp; Therefore, rather 
than to compare the two, I will simply start from scratch and explain the code 
in this class.</p>
<p><font color="#FF0000">
<b>Beginning of the Worker class in SaveState01</b></font></p>
<p>The <b>Worker</b> class, including the constructor begins in Listing 21.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Beginning of the Worker class in 
SaveState01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class Worker extends Thread{
    long nap = 1;//Sleep for one millisecond
    int width = 50;//TextBox width.
    String title = "Enter Text";//TextBox title
    TextBox textBox<b>;</b>

    Worker(){
      System.out.println("Worker constructed");
    }//end constructor

</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 21 is straightforward and shouldn't require an 
explanation.</p>
<p><font color="#FF0000">
<b>Beginning of the run method for the Worker class</b></font></p>
<p>The <b>run</b> method begins in Listing 22.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Beginning of the run method for the 
Worker class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void <b>run</b>(){
      System.out.println("Worker Thread Started");

      textBox = new TextBox(title,
                            savedText,
                            width,
                            TextField.ANY);
      //Display the new TextBox so the user can edit
      // its contents.
      Display.getDisplay(theMIDlet).setCurrent(textBox);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>After announcing that the thread has been started, Listing 22 creates a new
<b>TextBox</b> and populates it with the text that was saved when the MIDlet 
entered the paused state earlier. That variable was initialized to an empty 
string when the MIDlet was launched so the first time the <b>TextBox</b> is 
created it is empty.</p>
<p><font color="#FF0000">
<b>Loop and take naps while the user edits the TextBox</b></font></p>
<p>The <b>Worker</b> thread enters an infinite loop in Listing 23.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. Loop and take naps while the user edits 
the TextBox. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      while(true){
        if(<b>kill || paused</b>){//Check the flags
          savedText = textBox.getString();
          System.out.println(
                        "TextBox contents: " + savedText);
          break;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The thread loops and takes short naps to avoid consuming excessive 
computer resources while the user edits the <b>TextBox</b>.&nbsp; It checks the 
value of the<b> kil</b>l and <b>paused</b> flags at the beginning of each 
iteration of the loop.&nbsp; Recall that the <b>paused</b> flag is set to true by the <b>pauseApp</b> 
method and the <b>kill</b> flag is set to true by the <b>destroyApp</b> method.&nbsp;
<i>(The same flag could have been used for both, but they were separated to make 
it easier to follow the rationale for the code.)</i></p>
<p>If either flag is found to be true, the <b>Worker</b> thread:</p>
<ul>
	<li>Saves the contents of the <b>TextBox</b>.</li>
	<li>Displays the contents of the <b>TextBox</b>.</li>
	<li>Breaks out of the loop and dies <i>(see Listing 25)</i>.</li>
</ul>
<p><font color="#FF0000">
<b>Take a short nap</b></font></p>
<p>If neither the <b>kill</b> flag nor the <b>paused</b> flag is set, the <b>
Worker</b> thread executes the code in Listing 24.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Take a short nap. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        }else{
          try{
            Thread.currentThread().sleep(nap);
          }catch(InterruptedException e){
            System.out.println(
            	            "Worker awakened from a nap");
          }//end catch
        }//end else

      }//end while loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If control reaches the <b>else</b> clause in Listing 24, the MIDlet is not in 
the paused state and is not being destroyed.&nbsp; The <b>Worker</b> thread 
sleeps for a short period of time to allow the user to edit the text in the <b>
TextBox</b>.&nbsp; Then control goes back to the top of the <b>while</b> loop in 
Listing 23 where the values of the <b>kill</b> and <b>pause</b> flags are 
checked again.</p>
<p><font color="#FF0000">
<b>The Worker thread dies</b></font></p>
<p>This process continues until one or the other of the flags is found to be 
true, at which time control breaks out of the <b>while</b> loop and goes to 
Listing 25.</p>
<p>
<b><a name="Listing_25">Listing 25</a>. The Worker thread dies. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    }//end run
  }//end class Worker
  //====================================================//

}//end class SaveState01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When control reaches Listing 25, the <b>run</b> method terminates and the
<b>Worker</b> thread dies.</p>
<p><font color="#FF0000"><b>Doesn't know and, doesn't care...</b></font></p>
<p>The <b>Worker</b> thread doesn't know and doesn't care whether the MIDlet is 
entering the paused state or the destroyed state.&nbsp; In either case, the 
thread's responsibility is to die so that the reference to the <b>Worker</b> 
object can be set to null making the <b>Worker</b> object eligible for garbage 
collection.&nbsp; Because the contents of the TextBox were saved in Listing 23, 
a new<b> Worker</b> thread can be instantiated and its <b>TextBox</b> can be 
populated with the saved string later if needed.</p>
<p>Listing 25 also signals the end of the <b>Worker</b> class and the end of the 
MIDlet program class.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 26 and Listing 27 and run it in 
the MIDlet development framework that I provided in the earlier lesson titled <i>
Capturing Output Produced by Programs Running in a Child Process</i> <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p>Experiment with the MIDlet 
code, making changes and observing the effects of your changes.&nbsp; See if you 
can explain the effects of your changes.</p>
<p>Don't forget that you will need to download and install the latest version of 
the Sun Java Wireless Toolkit for CLDC <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; As of the date this lesson is being written, the latest version of the toolkit is WTK2.5.2.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this part of this lesson, I</p>
<ul>
	<li>Showed you a MIDlet user interface using a simple <b>TextBox</b> as an 
	example.</li>
	<li>Showed you one approach for minimizing the MIDlet's memory footprint 
	while the MIDlet is paused.</li>
	<li>Reinforced consistent use of the MIDlet class methods to satisfy the 
	life cycle rules of MIDlets.</li>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson you will learn</p>
<ul>
	<li>How to program an <b>Alert</b> for a MIDlet.</li>
	<li>How to add an image to the <b>Alert</b>.</li>
	<li>How to add a <b>Gauge</b> to the <b>Alert</b> to act as a progress or 
	activity meter.</li>
	<li>How to use a <b>Timer</b> to control when an <b>Alert</b> becomes 
	visible on the screen.</li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/sjwtoolkit/download-2_5.html">
	Download</a> Sun Java Wireless Toolkit 2.5 for CLDC Release</li>
	<li><a href="http://en.wikipedia.org/wiki/MIDlet">MIDlet</a>: From 
	Wikipedia, the free encyclopedia</li>
	<li><a href="http://www.scmad.com/j2me-glossary1.php">MIDlet</a>: According 
	to SCMAD Certification Center</li>
	<li><a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html">J2ME 
	Tutorial, Part 1: Creating MIDlets</a> by Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step4">
	Pre-verifying</a> MIDlet code according to Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step7">
	Deploying</a> a MIDlet according to Vikram Goyal</li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/device/device;jsessionid=3F91C410E754F34B1A44DEBCE011ED18">
	The Java ME Device Table</a></span></li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/midp/ttips/getAppProperty/index.html">
	Retrieving MIDlet Attributes</a> by Richard Marejka</span></li>
	<li><a href="http://developers.sun.com/mobility/learn/midp/lifecycle/">
	Learning Path: MIDlet Life Cycle</a></li>
	<li><span class="style2">
	<a href="http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html?page=1">
	When Runtime.exec() won't</a> By </span>Michael C. Daconta</li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration">
	Connected Limited Device Configuration</a> <i>(CLDC)</i> from
	<span class="style2">Wikipedia</span></li>
	<li><span class="style2">
	<a href="http://en.wikipedia.org/wiki/Mobile_Information_Device_Profile">
	Mobile Information Device Profile</a> <i>(MIDP)</i> from Wikipedia</span></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr030/">CLDC 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr139/">CLDC 1.1</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr037/">MIDP 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr118/">MIDP 2.0</a></li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3719111">2570</a> 
	Getting Started with MIDlets and the Sun Java Wireless Toolkit for CLDC</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3721706">2572</a> Capturing Output Produced by Programs Running in a Child Process</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3724381">2574</a> Back to Basics with MIDlets and the Sun Java Wireless Toolkit for 
	CLDC</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3727396">2576</a> Introduction to the MIDlet User Interface, A First Look</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are provided in 
Listing 26 and Listing 27 below.<p>
<b><a name="Listing_26">Listing 26</a>. The MIDlet program named UI01.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*UI01.java
Copyright 2007, R.G.Baldwin
December 13, 2007

The purpose of this MIDlet program is to:

1. Introduce the topic of the MIDlet user interface using
a simple TextBox as an example.

2. Reinforce consistent use of the MIDlet class methods
to satisfy the life cycle rules of MIDlets.

Three threads were purposely constructed and started in
this MIDlet.  The three threads are:

1. The main MIDlet thread that services the life-cycle
methods.

2. A Worker thread that services a TextBox object that can
be edited by the user while the MIDlet is in the active
state, but cannot be seen or edited while the MIDlet is in
the paused state. The user can edit the contents of the
TextBox across several active/paused MIDlet cycles without
losing information in the process. This thread displays
the contents of the TextBox each time the MIDlet enters
the paused state, and displays the final contents of the
TextBox when the MIDlet enters the destroyed state.

3. A Toggler thread. It exists solely to force the MIDlet
to toggle between the paused state and the active state
in order to test and exercise the behavior of the Worker
thread. After several cycles of toggling between the
paused and active states, the Toggler thread causes the
MIDlet to be destroyed.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package UI01;

import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.TextBox;
import javax.microedition.lcdui.TextField;
import javax.microedition.midlet.MIDlet;
import java.lang.Thread;

public class UI01 extends MIDlet{

  //Variables needed only by the MIDlet.
  Worker theWorker;
  boolean running = false;

  //Variables needed by the Worker thread
  boolean paused;//true indicates paused
  boolean kill;//true means time for Worker to die

  //Variables needed by both Worker and Toggler threads
  UI01 theMIDlet;

  public UI01(){//Constructor
    System.out.println("MIDlet Constructed");
    theMIDlet = this;
    paused = true;
    kill = false;
  }//end constructor

  //The following method is called by the AMS to change
  // the state of the MIDlet from paused to active.
  public void startApp(){
    if(!running){
      //This is the first time that this method has been
      // called.
      System.out.println("MIDlet Started");
      running = true;
      //Create a new Toggler thread and start it running.
      new Toggler().start();

      //Create a new Worker thread and start it running
      // in an active state.
      paused = false;
      theWorker = new Worker();
      theWorker.start();

    }else{
      //This is not the first time that this method has
      // been called.
      System.out.println("MIDlet Re-Started");
      //Wake the Worker thread up if it is asleep. Set
      // the paused flag to false to tell the worker to
      // get to work.
      paused = false;
      theWorker.interrupt();
    }//end else
  }//end startApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the paused state. It may also be
  // called by the AMS.
  public void pauseApp(){
    //Tell Worker to go to sleep for a long time the next
    // time it checks the paused flag.
    paused = true;
    //Wake the worker up if it is asleep so that it will
    // check the pause flag quickly.
    theWorker.interrupt();
    System.out.println("MIDlet Paused");
    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the destroyed state. It may also
  // be called by the AMS. The incoming parameter is
  // ignored in this MIDlet.
  public void destroyApp(boolean unconditional){
    //Tell the Worker to commit suicide the next time it
    // checks the kill flag.
    kill = true;
    //Wake the worker up if it is asleep so that it will
    // check the kill flag quickly.
    theWorker.interrupt();

    System.out.println("MIDlet Destroyed");
    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to
  // instruct the MIDlet to request that it be returned
  // to the active state.
  public void resume(){
    resumeRequest();
  }//end resume
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to cause the MIDlet to toggle between
  // the active state and the paused state for a total
  // of 2.5 cycles (3 active periods and 2 paused
  // periods). While the MIDlet is in the paused state,
  // this thread displays uneditable text on the screen.
  // The AMS also displays an Incoming Call message during
  // the time that the MIDlet is paused. After 2.5 cycles,
  // this thread instructs the MIDlet to enter the
  // destroyed state.
  class Toggler extends Thread{

    Toggler(){
      System.out.println("Toggler constructed");
    }//end constructor

    public void run(){
      System.out.println("Toggler Thread Started");
      
      //Create an UNEDITABLE TextBox
      TextBox textBox = new TextBox(
                                "Text Display by Toggler",
                                "",//text in TextBox
                                27,//width of TextBox
                                TextField.UNEDITABLE);
      //Loop for 2.5 cycles
      for(int cnt = 0;cnt &lt; 5;cnt++){
        if(cnt % 2 != 0){
          //Tell the thread to enter the paused
          // state on odd values of cnt.
          theMIDlet.pauseApp();

          //Now display some uneditable text while the
          // MIDlet is paused.
          //The TextBox must be wide enough to contain all
          // of the text.  Otherwise a
          // java/lang/IllegalArgumentException will be
          // thrown.
          textBox.setString(
                       "UNEDITABLE Toggler text: " + cnt);
          Display.getDisplay(theMIDlet).
                                      setCurrent(textBox);

          //Sleep for two seconds with the MIDlet in the
          // paused state. Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(2000);
          }catch(Exception e){}

        }else{//The value of cnt is even.
          //Cause the thread to send a request to
          // the AMS to return it to the active
          // state.  If the request is honored, the
          // AMS will call the startApp method on the
          // thread. Note in particular that this
          // code does not call the startApp method
          // directly but delegates that action to the
          // AMS by way of the MIDlet.
          theMIDlet.resume();

          //Sleep for four seconds with the MIDlet in the
          // active state.  Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(4000);
          }catch(Exception e){}
        }//end else
      }//end for loop

      //Instruct the thread to enter the destroyed state
      // when control exits the loop and reaches this
      // point.
      theMIDlet.destroyApp(true);

      //This thread will die at this point.
      System.out.println("Toggler dying");
    }//end run
  }//end class Toggler
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to do some work while the MIDlet is in
  // the active state and to sleep while the MIDlet is in
  // the paused state.  It also sleeps some while the
  // MIDlet is in the active state to avoid consuming
  // major computational resources.  The work done by the
  // thread is:
  //  - Create an empty TextBox when the thread is
  //    started.
  //  - Set the title for the TextBox.
  //  - Allow the user to enter text in the TextBox while
  //    the MIDlet is in the active state.
  //  - Display the current contents of the TextBox when
  //    the MIDlet enters the paused state.
  //  - Display the final contents of the TextBox when the
  //    MIDlet is destroyed.
  class Worker extends Thread{
    long nap = 1;//Sleep for one millisecond
    long longSleep = 25000000;//6.94 hours
    long sleepTime = nap;
    String title = "Enter Text";//TextBox title
    int width = 50;//TextBox width.

    Worker(){
      System.out.println("Worker constructed");
    }//end constructor

    public void run(){
      System.out.println("Worker Thread Started");
      //Create and display an empty TextBox.
      TextBox textBox = new TextBox(title,
                                    "",//TextBox text
                                    width,
                                    TextField.ANY);
      Display.getDisplay(theMIDlet).setCurrent(textBox);

      while(true){//Enter an infinite loop
        if(kill){//Check the kill flag
          //The kill flag is true.
          //This break will cause the thread to break out
          // of the while loop and die.
          break;
        }//end if

        if(!paused){//Check the paused flag.
          //The MIDlet is not in the paused state. Sleep
          // for a short period of time and allow the
          // user to edit the text in the TextBox. Then
          // loop back around and check the paused flag
          // again.
          sleepTime = nap;
        }else{
          //The MIDlet is in the paused state. Display the
          // text in the TextBox.  Then go to sleep for a
          // very long time.  Will awake when the startApp
          // method calls the interrupt method on the
          // thread.
          System.out.println("TextBox contents: "
                                   + textBox.getString());
          sleepTime = longSleep;
        }//end else

        try{
          Thread.currentThread().sleep(sleepTime);
        }catch(InterruptedException e){
          //Control reaches here when the startApp method
          // calls the interrupt() method on this thread
          // while it is sleeping. Loop back to the top
          // and either terminate or do some work
          // depending on the state of the flags. If the
          // thread wakes up on its own accord, this code
          // will not be executed.
          if(sleepTime == longSleep){
            System.out.println(
                     "Worker awakened from the pause");
          }else{
            System.out.println(
                     "Worker awakened from a nap");
          }//end else

          //Display the TextBox so the user can edit
          // its contents.  This is necessary because the
          // Toggler thread displayed a different Screen
          // while the MIDlet was paused.
          Display.getDisplay(theMIDlet).setCurrent(
                                                 textBox);
        }//end catch

      }//end while loop

      //Control is transferred to here when the kill flag
      // is found to be true and a break is executed
      // inside the while loop.

      //This thread will die at this point.  Before dying,
      // display the final contents of the TextBox.
      System.out.println("Final TextBox contents: "
                                   + textBox.getString());
      System.out.println("Worker committing suicide");
    }//end run
  }//end class Worker
  //====================================================//

}//end class UI01
//======================================================//</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_27">Listing 27</a>. The MIDlet program named SaveState01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*SaveState01.java
Copyright 2007, R.G.Baldwin
December 13, 2007

The purpose of this MIDlet program is to:

1. Introduce the topic of the MIDlet user interface using
a simple TextBox as an example.

2. Illustrate one approach to minimizing the MIDlet's 
memory footprint while the MIDlet is paused.

3. Reinforce consistent use of the MIDlet class methods
to satisfy the life cycle rules of MIDlets.

Three threads were purposely constructed and started in
this MIDlet:

1. The main MIDlet thread that services the life-cycle
methods.

2. A Worker thread. It services a TextBox object that can
be edited by the user while the MIDlet is active. When the
MIDlet enters the paused state, the contents of the 
TextBox object are saved, and the Worker thread is made 
eligible for garbage collection. When the MIDlet re-enters
the active state, a new Worker is created and populated 
with the contents that were saved from the previous 
TextBox.  Therefore, the user can edit the contents of the
TextBox across several active/paused MIDlet cycles without 
losing information in the process.

3. A Toggler thread, which forces the MIDlet
to toggle between the paused state and the active state
in order to test and exercise the ability of the Worker
thread to release memory resources when the MIDlet
enters the paused state, and to restore the state of
the TextBox when the MIDlet returns to the active state.
After several cycles of toggling between the paused and
active states, the Toggler thread causes the MIDlet to
enter the destroyed state.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package SaveState01;

import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.TextBox;
import javax.microedition.lcdui.TextField;
import javax.microedition.midlet.MIDlet;
import java.lang.Thread;

public class SaveState01 extends MIDlet{

  //Variables needed only by the MIDlet.
  Worker theWorker;
  boolean midletRunning = false;

  //Variables needed by the Worker thread
  boolean paused;//true indicates paused
  boolean kill;//true means time for the Worker to die
  String savedText = &quot;&quot;;//TextBox text is saved here.

  //Variables needed by both Worker and Toggler threads
  SaveState01 theMIDlet;

  public SaveState01(){//Constructor
    System.out.println("MIDlet Constructed");
    theMIDlet = this;
    paused = true;
    kill = false;
  }//end constructor

  //The following method is called by the AMS to change
  // the state of the MIDlet from paused to active.
  public void startApp(){
    if(!midletRunning){
      //This is the first time that this method has been
      // called.
      System.out.println("MIDlet Started");
      midletRunning = true;

      //Create a new Toggler object and start it running.
      new Toggler().start();
      
    }else{
      //This is not the first time that this method has
      // been called.
      System.out.println("MIDlet Re-Started");
    }//end else

    //Create a new Worker thread and start it running in
    // an active MIDlet state.
    paused = false;
    theWorker = new Worker();
    theWorker.start();
  }//end startApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the paused state. It may also be
  // called by the AMS.
  public void pauseApp(){
    //Tell Worker to die the next time it checks the
    // paused flag.
    paused = true;
    //Wake the worker up if it is asleep so that it will
    // check the paused flag quickly.
    theWorker.interrupt();
    //Delay until the Worker thread dies.
    while(theWorker.isAlive()){}
    //Make the worker object eligible for garbage
    // collection.
    theWorker = null;
    System.out.println(
    	 "Worker dead, eligible for garbage collection.");
    System.out.println("MIDlet Paused");

    //Tell the AMS that this MIDlet is in the paused
    // state.
    notifyPaused();
  }//end pauseApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to cause
  // the MIDlet to enter the destroyed state. It may also
  // be called by the AMS. The incoming parameter is
  // ignored in this MIDlet.
  public void destroyApp(boolean unconditional){
    //Tell the Worker to die the next time it checks the
    // kill flag.
    kill = true;
    //Wake the worker up if it is asleep so that it will
    // check the kill flag quickly.
    theWorker.interrupt();

    //Delay until the Worker thread dies to make certain
    // that all of the text entered by the user is stored
    // in savedText.
    while(theWorker.isAlive()){}
    //Make the worker object eligible for garbage
    // collection.
    theWorker = null;
    System.out.println(
    	 "Worker dead, eligible for garbage collection.");

    System.out.println(
                  "Final TextBox contents: " + savedText);

    System.out.println("MIDlet Destroyed");

    //It is assumed that the following method call will
    // cause the AMS to make the MIDlet object eligible
    // for garbage collection, which in turn will make the
    // Toggler object eligible for garbage collection.

    //Tell the AMS that the MIDlet is in the destroyed
    // state. It can then be launched again.
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//

  //This method is called by the Toggler thread to
  // instruct the MIDlet to request that it be returned
  // to the active state.
  public void resume(){
    resumeRequest();
  }//end resume
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to cause the MIDlet to toggle between
  // the active state and the paused state for a total
  // of 2.5 cycles (3 active periods and 2 paused
  // periods). While the MIDlet is in the paused state,
  // this thread displays uneditable text on the screen.
  // The AMS also displays an Incoming Call message during
  // the time that the MIDlet is paused. After 2.5 cycles,
  // this thread instructs the MIDlet to enter the
  // destroyed state.
  class Toggler extends Thread{

    Toggler(){
      System.out.println("Toggler constructed");
    }//end constructor

    //Create an UNEDITABLE TextBox
    public void run(){
      System.out.println("Toggler Thread Started");
      TextBox textBox = new TextBox(
                                "Text Display by Toggler",
                                "",//text in TextBox
                                27,//width of TextBox
                                TextField.UNEDITABLE);

      //Loop for 2.5 cycles
      for(int cnt = 0;cnt &lt; 5;cnt++){
        if(cnt % 2 != 0){
          //Tell the MIDlet to enter the paused state on
          // odd values of cnt.
          theMIDlet.pauseApp();

          //Now display some uneditable text while the
          // MIDlet is paused.
          //The TextBox must be wide enough to contain all
          // of the text.  Otherwise a
          // java/lang/IllegalArgumentException will be
          // thrown.
          textBox.setString(
                       "UNEDITABLE Toggler text: " + cnt);
          Display.getDisplay(theMIDlet).
                                      setCurrent(textBox);

          //Sleep for two seconds with the MIDlet in the
          // paused state. Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(2000);
          }catch(Exception e){}

        }else{//The value of cnt is even.
          //Cause the thread to send a request to
          // the AMS to return it to the active
          // state.  If the request is honored, the
          // AMS will call the startApp method on the
          // thread. Note in particular that this
          // code does not call the startApp method
          // directly but delegates that action to the
          // AMS by way of the MIDlet.
          theMIDlet.resume();

          //Sleep for four seconds with the MIDlet in the
          // active state.  Then go back to the top of the
          // loop.
          try{Thread.currentThread().sleep(4000);
          }catch(Exception e){}
        }//end else
      }//end for loop

      //Instruct the MIDlet to enter the destroyed state
      // when control exits the loop and reaches this
      // point.
      theMIDlet.destroyApp(true);

      //This thread will die at this point.
    }//end run
  }//end class Toggler
  //====================================================//

  //This is a member class.  The purpose of an object of
  // this class is to do some work while the MIDlet is in
  // the active state and to become eligible for garbage
  // collection when the MIDlet enters the paused state.
  // It also sleeps some while the MIDlet is in the active
  // state to avoid consuming major computational
  // resources.  The work done by the thread is:
  //  - Create an empty TextBox when the thread is
  //    started.
  //  - Set the title for the TextBox.
  //  - Allow the user to enter text in the TextBox while
  //    the MIDlet is in the active state.
  //  - Save the contents of the TextBox when the MIDlet
  //    enters the paused state.
  //  - Display the current contents of the TextBox when
  //    the MIDlet enters the paused state.
  //  - Make the Worker object eligible for garbage
  //    collection when the MIDlet enters the paused
  //    state.
  //  - Create a new TextBox object when the MIDlet
  //    enters the active state.
  //  - Set the title for the new TextBox object.
  //  - Populate the new TextBox object with the saved
  //    text from the previous TextBox object.
  //  - Allow the user to enter text in the new TextBox
  //    while the MIDlet is in the active state.
  class Worker extends Thread{
    long nap = 1;//Sleep for one millisecond
    int width = 50;//TextBox width.
    String title = "Enter Text";//TextBox title
    TextBox textBox;

    Worker(){
      System.out.println("Worker constructed");
    }//end constructor

    public void run(){
      System.out.println("Worker Thread Started");
      //Create a new TextBox and populate it with the
      // text that was saved when the MIDlet entered
      // the paused state earlier. That variable
      // initially contains an empty string.
      textBox = new TextBox(title,
                            savedText,
                            width,
                            TextField.ANY);
      //Display the new TextBox so the user can edit
      // its contents.
      Display.getDisplay(theMIDlet).setCurrent(textBox);

      //Now loop while the user edits the TextBox contents
      while(true){
        if(kill || paused){//Check the flags
          //Save the contents of the TextBox, display
          // the contents, break out of the loop and die.
          savedText = textBox.getString();
          System.out.println(
                        "TextBox contents: " + savedText);
          break;
        }else{
          //The MIDlet is not in the paused state and is
          // not being destroyed. Sleep for a short period
          // of time and allow the user to edit the text
          // in the TextBox. Then loop back around and
          // check the flags again.
          try{
            Thread.currentThread().sleep(nap);
          }catch(InterruptedException e){
            System.out.println(
            	            "Worker awakened from a nap");
          }//end catch
        }//end else

      }//end while loop

      //Control is transferred to here when the kill flag
      // or the pause flag is found to be true and a break
      // is executed inside the loop. The Worker thread
      // will die when the run method exits.
    }//end run
  }//end class Worker
  //====================================================//

}//end class SaveState01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java J2ME MIDlet &quot;cell phone emulator&quot; &quot;wireless toolkit&quot; WTK MIDP CLDC &quot;MIDlet 
life cycle&quot; Displayable TextBox Ticker TextField </p>
<p>-end- </p>
</body>
</html>
