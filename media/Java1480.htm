<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
<h2>Fun with Java: Biomorphs and Artificial Life<br>
</h2>
<i>Baldwin shows you how to write 
an artificial life program that models selective breeding, sometimes referred to as artificial selection.</i>
<p><b>Published:</b>&nbsp; April 27, 2004
<br>
<b>By <a href="#About%20the%20author">Richard G. Baldwin</a></b>
</p>
<p>Java Programming, Lecture Notes # 1480
</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Programs</a></li>
	<li> <a href="#Run_the_Programs">Run the Programs</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listing</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2><a name="Preface"></a>Preface</h2>
</center>
Programming in Java doesn't have to be dull and boring.&nbsp; In fact, it's 
possible to have a lot of fun while programming in Java.&nbsp; This lesson will 
concentrate on having fun while learning something at the same time.<p>In this lesson, I will show you how to write 
programs that model the selective breeding process, sometimes referred to as <i>artificial selection.</i>&nbsp; This is as opposed to natural selection, sometimes 
referred to as <i>survival of the fittest.</i></p>
<p><b><font color="#ff0000">Viewing tip</font></b>
</p>
<p>You may find it useful to open another copy of this lesson in a
separate
browser window.&nbsp; That will make it easier for you to scroll back
and
forth among the different figures and listings while you are reading
about
them.
</p>
<p><b><font color="#ff0000">Supplementary material</font></b>
</p>
<p>I recommend that you also study the other lessons in my extensive
collection
of online Java tutorials.&nbsp; You will find those lessons published
at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at <a href="http://www.dickbaldwin.com">www.DickBaldwin.com</a>.</font>
</p>
<center>
<h2><a name="Preview"></a><font color="#000000">Preview</font></h2>
</center>
<b><font color="#ff0000"></font></b>
<p><b><font color="#ff0000">Artificial life</font></b></p>
<p>In this lesson, I will present and explain a program that falls in the 
general category of <i>Artificial Life.</i>&nbsp; In the book with the same 
title, Christopher Langton tells us <i>&quot;Artificial Life is the study of man-made 
systems that exhibit behavior characteristics of natural living systems.&quot;</i></p>
<p>I will present and explain three separate programs <i>(three 
man-made systems).</i>&nbsp; The first two programs provide background 
information designed to help you understand the behavior of the more-important third program.</p>
<p>The third program exhibits behavior commonly referred to as <i>evolution.</i>&nbsp; 
In particular, this program exhibits the behavior of <i>artificial selection</i> 
(as opposed to <i>natural selection</i>).&nbsp; Artificial selection makes it 
possible to evolve creatures <i>(such as Dalmation dogs)</i> that accentuate 
certain desirable characteristics <i>(such as black spots on a white coat)</i> 
and suppress other less desirable characteristics <i>(such as a shaggy red 
coat).</i></p><b><font color="#ff0000">Natural selection versus artificial 
selection</font></b><p>For example, the variety of plants, animals, and birds 
that exist on an uninhabited island represent natural selection, sometimes 
referred to as <i>survival of the fittest.&nbsp; </i>A Dalmation dog, on the 
other hand, is probably the result of artificial selection. In other words, over 
a long period of time, people selected certain dogs for breeding to accentuate 
certain characteristics <i>(such as black spots on a white coat)</i> and to 
suppress other characteristics <i>(such as a shaggy red coat).</i> Over time, 
what resulted was a type of dog that we know as the Dalmation.</p>
<p>Those who participated in the process of artificial selection 
resulting in a Dalmation dog may not have known that those characteristics were 
represented by genes that were accentuated or suppressed through selective 
breeding.&nbsp; However, we know <i>(or at least believe)</i> that to be the case now.</p>
<p><b><font color="#ff0000">Selectively breeding Biomorph objects</font></b></p>
<p>The third program that I will present and explain makes it possible for you to selectively breed successive 
generations of artificial creatures known as Biomorph objects.</p>
<blockquote>
	<p><i>(For brevity, I will refer to a Biomorph object as a Biomorph and will 
	refer to multiple Biomorph objects as Biomorphs.)</i></p>
</blockquote>
<p>Each Biomorph is a recursively branching tree consisting of many branches <i>
(stems)</i> of different lengths that branch off in different directions.&nbsp; For example, 
Figure 1 shows nine stages in the growth of a simple Biomorph.</p>
<p align="center"><img border="0" src="java1480a.gif" width="401" height="401"></p>
<p align="center">Figure 1&nbsp; Nine stages in the growth of a Biomorph.</p>
<p><b><font color="#ff0000">Biomorph genes</font></b></p>
<p>Each Biomorph has eight genes that control the size, the number, and 
the angle of the branches.</p>
<p><b><font color="#ff0000">Reproduction</font></b></p>
<p>In the third program that I will present and explain, a single parent in each generation produces 
eight offspring in the next 
generation.&nbsp; </p>
<p>During the creation of each new generation of offspring, one 
of the genes for each of the eight offspring is randomly mutated to produce a 
creature that is similar to, but different from its parent.&nbsp; Thus each of 
the eight siblings in a single generation differs from the parent by the value 
of a single gene.&nbsp; Each of the eight siblings has a mutated value in a different 
gene, so no two offspring are exactly alike.</p>
<p><b><font color="#ff0000">Stage versus generation</font></b></p>
<p>I probably need to explain the difference between the terms <i>stage</i> and
<i>generation.</i>&nbsp; In human or plant terms, <i>stage</i> is somewhat 
analogous to age.&nbsp; For example, many plants grow a set of new branches 
during each growing season.&nbsp; A five year old tree, for example, will 
normally have more branches than a one year old tree.&nbsp; Similarly, a 
five-stage Biomorph will have more branches than a one-stage Biomorph, as 
illustrated in Figure 1.</p>
<p>However, many trees can produce a new generation of offspring at any age, or 
at least at any age beyond some minimum age.&nbsp; The same is true of 
Biomorphs.&nbsp; A Biomorph can become the parent of a new generation of 
Biomorphs at any stage.&nbsp; There is no such thing as puberty in the word of 
Biomorphs.</p>
<p><b><font color="#ff0000">Illustrating stage versus generation</font></b></p>
<p>Figure 1 illustrates the stages in the growth of a Biomorph.&nbsp; </p>
<p>Figure 2 illustrates Biomorph reproduction.&nbsp; The Biomorph in the lower 
right-most corner of Figure 2 was the parent of the eight other Biomorphs shown 
in Figure 2.&nbsp; Thus, the Biomorph in the lower right-most corner represents 
one generation and the eight offspring represent the next generation.</p>
<p align="center"><img border="0" src="java1480b.gif" width="401" height="401"></p>
<p align="center">Figure 2&nbsp; Illustration of Biomorph reproduction</p>
<p>Note how the complexity of the Biomorphs in Figure 1 progresses from least 
complex to most complex as you move from top left to lower right on a line-by-line basis.&nbsp; On the other hand, all of the Biomorphs in Figure 2 are of 
similar complexity, because they are all offspring of the Biomorph in the bottom 
right-most corner in Figure 2.</p>
<p><b><font color="#ff0000">Artificial selection</font></b></p>
<p>In the third program that I will explain in this lesson, you can select one of the offspring from each 
new generation of Biomorphs to become the parent 
of the next generation.&nbsp; Through careful selection, you can accentuate certain characteristics 
of the Biomorph family and suppress other characteristics. By continuing this process through several 
generations, you can cause the resulting Biomorphs to resemble birds, bugs, 
animals, airplanes, human faces, or whatever strikes your fancy.</p>
<blockquote>
	<p><i>(Skipping ahead a bit, <a href="#Figure_10">Figure 10</a> shows the 
	result of using artificial selection to breed a family of Biomorphs that 
	resemble stealth aircraft.)</i></p>
</blockquote>
<p><b><font color="#ff0000">Acknowledgement</font></b></p>
<p>This program is loosely based on Chapter 8 of the book entitled <i>Windows 
Hothouse</i> by Mark Clarkson.&nbsp; That chapter was based on a book and a 
paper published by Richard Dawkins.&nbsp; Dawkins' book is entitled <i>The Blind 
Watchmaker.</i>&nbsp; The paper was entitled <i>The Evolution of Evolvability</i> 
and appeared in the book entitled <i>Artificial Life.</i></p>
<center>
<h2><a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2>
</center>
As mentioned earlier, I will present and explain three different programs in 
this lesson.&nbsp; Only the third program supports the artificial 
selection process.&nbsp; The first two programs are designed to help you to 
understand the third program.<p><b><font color="#ff0000">The Biomorph class</font></b></p>
<p>All three programs make use of a common class named <b>Biomorph</b>.&nbsp; 
Objects instantiated from this class are central to all three programs, so I 
will begin by presenting and explaining the <b>Biomorph</b> class.</p>
<p>This class is used to instantiate a Biomorph object.&nbsp; As mentioned 
earlier, it is based loosely on Chapter 8 of the book entitled <i>Windows 
Hothouse</i> by Mark Clarkson.&nbsp; However, the C++ algorithm presented in 
that book appears to contain several typographical errors.&nbsp; It was necessary for me 
to find and fix those errors when writing a Java version of the algorithm.</p>
<p><b><font color="#ff0000">Construction of the Biomorph</font></b></p>
<p>The constructor for the <b>Biomorph </b>class<b> </b>receives an array of 
eight gene values.&nbsp; <i>(I will discuss the first seven values in the gene array later.)</i>&nbsp; The 
eighth value in the array specifies the number of stages used to construct the <b>
Biomorph</b>.</p>
<blockquote>
	<p><i>(For example, the value of the eighth gene was 1 for the Biomorph 
	shown in the top left-most corner of Figure 1.&nbsp; The value of the eighth 
	gene was 9 for the Biomorph shown in the bottom right-most corner.)</i></p>
</blockquote>
<p><b><font color="#ff0000">Stages of growth</font></b></p>
<p>The Biomorph in the top left-most corner of Figure 1 shows the result of one 
stage of growth for a simple <b>Biomorph</b>.&nbsp; </p>
<p>The Biomorph in the bottom right-most corner of Figure 1 shows the result of 
nine stages of growth for the same simple <b>Biomorph</b>.&nbsp; For this 
Biomorph, the first seven gene values were all 1.0.</p>
<blockquote>
	<p><i>(The gene values are essentially whole numbers, but I treated them as 
	type <b>double</b> instead of type <b>int</b> to avoid the possibility of 
	integer arithmetic problems.)</i></p>
</blockquote>
<p><b><font color="#ff0000">Bifurcating stems</font></b></p>
<p>The first stage of construction produces a single stem as shown by the top 
left-most Biomorph in Figure 1.&nbsp; Each successive stage causes all existing 
stems to bifurcate into two new stems.&nbsp; You can clearly see this 
bifurcation process by examining the three Biomorphs in the top 
row of Figure 1.&nbsp; The left-most Biomorph is a single-stage 
Biomorph.&nbsp; The right-most Biomorph is a three-stage Biomorph, and the one is the 
center of the top row is a two-stage Biomorph.</p>
<p>You can also see this behavior in the fourth and fifth-stage Biomorphs in the 
two left-most positions in the center row.&nbsp; By the time you get to the 
six-stage Biomorph in the right-most position in the center row, however, the 
stems start to overlap and it is more difficult to visually distinguish the bifurcation 
process.</p>
<p><b><font color="#ff0000">Increase by a power of two</font></b></p>
<p>Thus, the number of individual stems belonging to a Biomorph 
increases as a power of two based on the number of stages used in its creation.&nbsp; 
For example, a Biomorph created with two stages contains three 
stems as shown in the center of the top row in Figure 1.&nbsp; A three-stage 
Biomorph contains seven stems as shown by the right-most object in 
the top row of Figure 1.&nbsp; A four-stage Biomorph contains 
fifteen stems, etc.</p>
<blockquote>
	<p><i>(Those of you who are familiar with the binary number system will 
	recognize the series 1, 3, 7, 15, 31, 63, etc. as being values that commonly 
	arise in the binary number system.&nbsp; For example, a four-bit unsigned 
	binary number can contain any of the values from 0 through 15 inclusive.)</i></p>
</blockquote>
<p><b><font color="#ff0000">Arithmetic accuracy</font></b></p>
<p>The algorithm in Clarkson's book is based on the use of integer gene values.&nbsp; 
However, when writing the Java version of the algorithm, I elected to maintain 
all of the data as type <b>double</b> in order to avoid the possibility of 
integer arithmetic problems, particularly when scaling the data for display.&nbsp; 
Values in my version of the algorithm are converted from <b>double</b> to <b>int</b> 
at the very last step before displaying the Biomorph on the 
screen.</p>
<p><b><font color="#ff0000">Gene mutation</font></b></p>
<p>As you will see later when we examine the code for the <b>Biomorph</b> class, 
the constructor receives a random number generator and a count value that are 
used to mutate the genes.</p>
<p>One gene in the array of genes is mutated by a random value of plus or minus 
one whenever the count value is within the range from 0 through 7 inclusive.&nbsp; 
The actual gene that is mutated is the one whose position in the gene array matches 
the count value.&nbsp; If the count value is outside this range, there is no 
gene mutation.</p>
<p><b><font color="#ff0000">Returning the mutated gene array</font></b></p>
<p>A method named <b>getGenes</b> returns the gene array containing the possibly 
mutated gene.&nbsp; This is useful for experiments in <i>artificial selection</i>, such 
as the third program that I will present and explain in this lesson.</p>
<p><b><font color="#ff0000">Scaling the plot for display</font></b></p>
<p>The constructor receives a scale factor that is used to adjust the overall 
size of the picture for each individual Biomorph in an attempt to cause it to fit 
in the allocated plotting area.</p>
<p>Generally speaking, the size of the raw display of a Biomorph increases as the number of stages increases.&nbsp; 
When the scale factor is used later, coordinate values are multiplied by the 
reciprocal of the scale factor.&nbsp; Therefore, it is 
useful to cause the scale factor to increase as the number of stages increases.&nbsp; 
As you will see when you experiment with the second and third programs, 
sometimes even this is not sufficient to keep the size of an individual
Biomorph within the allocated area.</p>
<p><b><font color="#ff0000">Positioning the plot</font></b></p>
<p>The constructor receives a pair of <b>int</b> values that are used to move 
the plotting origin from the default upper-left corner to another location in 
the plotting area.&nbsp; All three programs presented in this lesson position 
the plotting origin at the center of each of the nine individual plotting areas 
shown in Figure 1.</p>
<p><b><font color="#ff0000">Direction of the first stem</font></b></p>
<p>The direction of the first stem displayed for the Biomorph is 
hard-coded to be vertical going up the screen, starting at the origin.</p>
<p><font color="#FF0000"><b>Beginning of the Biomorph class</b></font></p>
<p>As is my custom, I will discuss these three programs in fragments.&nbsp; You will 
find complete listings of the programs in Listing 31, Listing 32, and Listing 33 
near the end of the lesson. </p>
<p>The code fragment in Listing 1 shows the beginning of the <b>Biomorph</b> 
class used in all three programs.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class Biomorph extends Panel{
  double[] xInc = new double[8];
  double[] yInc = new double[8];
  double[] genes;
  double xCoor = 0;//Start drawing here
  double yCoor = 0;//Start drawing here
  int direction = 0;//Initial drawing direction
  double length;
  double scale;
  int xOrigin;
  int yOrigin;<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 1 simply declares some instance variables, initializing some of them.&nbsp; 
The purpose of these variables will become clear in the discussion that follows.</p>
<p><font color="#FF0000"><b>Constructor for the Biomorph class</b></font></p>
<p>The constructor begins in Listing 2.&nbsp; The purpose of each of the 
constructor parameters was discussed in the preceding paragraphs.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  Biomorph(double[] genes,
           Random rGen,
           int cnt,
           double scale,
           int xOrigin,
           int yOrigin){

    this.genes = (double[])genes.clone();
    this.scale = scale;
    this.xOrigin = xOrigin;
    this.yOrigin = yOrigin;<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Save local copies</b></font></p>
<p>The code in Listing 2 saves copies of four of the incoming parameters in 
instance variables.&nbsp; These are parameter values that require access within 
the class but outside the constructor.</p>
<p><font color="#FF0000"><b>Cloning the gene array</b></font></p>
<p>Note in particular that the <b>clone</b> method is used to save a copy of the 
incoming array of gene values.&nbsp; This is necessary to prevent the code from changing gene values in the original gene array passed to 
the constructor.&nbsp; In some cases, the same gene array will be used for 
constructing multiple objects of the <b>Biomorph</b> class, and the construction of 
any one of those objects cannot be allowed to modify the values stored in the 
original gene array.</p>
<p><font color="#FF0000"><b>Mutate a gene</b></font></p>
Listing 3 mutates one of the genes stored in the local copy of the gene array, 
provided that the value of <b>cnt</b> is within the range from 0 through 7 inclusive.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if((cnt>=0) && (cnt<=7)){
      double mutantValue = rGen.nextInt(2)*2-1;
      this.genes[cnt] += mutantValue;
      //Don't allow the eighth gene to go
      // negative
      if(this.genes[7] < 0)this.genes[7] = 0;
    }//end if<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The particular gene that is mutated is specified by the value of <b>cnt</b>.&nbsp; 
If <b>cnt</b> is outside the specified range, no gene mutation takes place.</p>
<p><font color="#FF0000"><b>Mutation changes the gene value</b></font></p>
<p>When mutation does take place, the value of the gene is increased or 
decreased by a value of 1.0.&nbsp; The determination as to whether to increase or 
decrease the value is based on a random number generator.&nbsp; You can examine the 
documentation for the library class named <b>Random</b> if need be to understand how 
this code works.</p>
<p>The code in Listing 3 also ensures that the value of the eighth gene cannot go 
negative.&nbsp; The idea of instantiating a Biomorph where the 
number of stages is negative doesn't make any sense.</p>
<p><font color="#FF0000"><b>The first seven gene values</b></font></p>
This is where things get somewhat complicated.&nbsp; In order for you to 
understand the remaining code in the constructor, I need to explain the meaning 
of the first seven values in the array of genes.&nbsp; For that, I will turn to 
a discussion of the physical drawing process for the Biomorph.<p>
<font color="#FF0000"><b>Branching off in different directions</b></font></p>
<p>Consider the rightmost Biomorph in the top row of Figure 1 as an example.&nbsp; 
When the time comes for a stem to bifurcate into two new stems, they branch off 
in different and somewhat opposite directions.</p>
<p><font color="#FF0000"><b>Eight possible directions</b></font></p>
<p>A new stem can branch off in any one of eight different directions.&nbsp; Two of 
the eight directions are horizontal to the right or to the left.&nbsp; Two of 
the directions are vertical, either up or down.&nbsp; That takes care of four of 
the eight possible directions.</p>
<p>The other four directions are generally neither horizontal nor vertical.&nbsp; 
Considering the first four directions as representing north, south, east, and 
west, the other four directions are generally northeast, northwest, southeast, 
and southwest.&nbsp; I say generally because these directions are not fixed like 
points on the compass.&nbsp; For example, a stem that branches off in a 
northeasterly direction can be horizontal, vertical, or anything in between.&nbsp; 
In other words, the actual direction of a stem that branches off in a 
northeasterly direction can be any direction in the ninety degrees between pure 
north and pure east.</p>
<p><font color="#FF0000"><b>Genes determine the direction of a new stem</b></font></p>
<p>The combined values of a subset of the first seven genes determine the directions that 
the two new stems take when the old stem bifurcates.</p>
<p>For brevity in the following discussion, I will use the following notation to 
represent each of the first 
seven values in the gene array: g0, g1, g2, g3, g4, g5, and 
g6.</p>
<p><font color="#FF0000"><b>Defined by two pairs of coordinates</b></font></p>
<p>As you will see when we examine the code later, each new stem is defined by 
two pairs of coordinates.&nbsp; One pair of coordinates represents the starting 
point of a straight line, which is the same as the point in two-dimensional space where the old 
stem bifurcates.&nbsp; </p>
<p>The second pair of coordinates represents the other end of 
the stem in the same two-dimensional space.</p>
<p><font color="#FF0000"><b>Compute second pair of coordinate values</b></font></p>
<p>The location of the other end of the stem is computed by selecting a pair of 
values from the gene array and scaling those values.</p>
<blockquote>
	<p><i>(In some cases, one of the coordinate values is zero, in which case 
	it isn't necessary to select a value from the gene array.)</i></p>
</blockquote>
<p>The first seven values in the gene array are 
used to determine the end points of every stem.</p>
<p><font color="#FF0000"><b>Relationship between gene values and coordinate 
values</b></font></p>
<p>Figure 3 shows my attempt to represent this relationship in visual form.&nbsp; <i>
(As you can see, I am not a graphics artist.)</i><br>
</p>
<p align="center">
<div align="center">
<table border="1" cols="1" bgcolor="#FFFFFF">
  <tbody>
    <tr>
      <td>
      <div align="center">
      <pre><img border="0" src="java1480c.gif" width="235" height="273"></pre>
      </div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p align="center">
</p>
<p align="center">Figure 3&nbsp; Eight possible stem directions</p>
<p>Figure 3 shows each of the eight possible directions in which a stem can be drawn.&nbsp; 
Those eight directions are numbered from 0 through 7, starting at the top and 
going in a clockwise direction.</p>
<p>Figure 3 also shows how 
values from the gene array are used to specify the end point of a stem to be 
drawn in any of those eight possible directions.</p>
<blockquote>
	<p><i>(For example, the end point of a stem in direction 1 is determined by 
	applying a scale factor to values in the gene array represented by g1 and 
	g2.&nbsp; You will see that this is genes[1] and genes[2].)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Horizontal and vertical stems</b></font></p>
<p>As you can see, the gene values of g0, g3, g6 and -g3 produce horizontal and 
vertical stems of different lengths along directions 0, 2, 4, and 6.</p>
<p>Note that the same absolute value from the gene array, g3, is used to specify the end 
of a stem going in either direction along the horizontal axis <i>(direction 2 
and direction 6).</i>&nbsp; Only the algebraic sign of the value differs.</p>
<p>Also note that the same absolute values from the gene array, g1, and g2, are used to 
specify the end of a stem drawn in either direction 1 or direction 7.&nbsp; 
Again, only the algebraic sign applied to the value of g1 differs between the 
two directions.</p>
<p>Finally, note that the same absolute values from the gene array, g4, and g5, are used 
to specify the end of a stem drawn in either direction 3 or direction 5.&nbsp; 
In this case, a negative sign is applied to g5 for both directions 3 and 5.&nbsp; 
A negative sign is applied to g4 for direction 5.</p>
<p><font color="#FF0000"><b>Horizontal symmetry</b></font></p>
<p>The result is that all Biomorphs are horizontally symmetrical, as shown in 
Figure 1 and Figure 2.</p>
<p><font color="#FF0000"><b>Only seven different gene values are required</b></font></p>
<p>A close examination of Figure 3 shows that only seven different gene values are 
required to specify the end point of any stem regardless of its direction.</p>
<p>As the genes mutate and change values, the lengths of horizontal and vertical 
stems constructed using those gene values also change.</p>
<p>Both the length and 
the angle relative to the horizontal changes for stems drawn along directions 1, 3, 5, 
and 7 as the genes mutate and change values.</p>
<p><font color="#FF0000"><b>Effect of changes in gene values</b></font></p>
<p>The effect of changes in gene values on the shape of the Biomorphs is illustrated in Figure 4.&nbsp; 
This figure shows the generation and display of 
Biomorphs through a controlled set of changes to the values in the gene array.</p>
<p align="center"><img border="0" src="java1480d.gif" width="401" height="401"></p>
<p align="center">Figure 4&nbsp; Biomorphs with controlled changes to the genes.</p>
<p><font color="#FF0000"><b>The baseline Biomorph</b></font></p>
<p>The top left-most Biomorph in Figure 4 was generated using a gene array with 
all ones in the first seven genes and a five in the eighth gene.&nbsp; Thus, it 
is a five-stage Biomorph.</p>
<p><font color="#FF0000"><b>Changes in the gene values</b></font></p>
<p>The next seven Biomorphs, beginning with the Biomorph in the center of the 
top row, were generated by multiplying one, and only one of 
the genes by a factor of three, starting with the first gene and ending with the 
seventh gene.</p>
<blockquote>
	<p align="left"><i>(The ninth Biomorph was a duplicate of the eighth 
	Biomorph, and was included only to balance out the display.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Correlate pictures with gene values</b></font></p>
<p>You should be able to correlate the shapes of the Biomorphs in Figure 4 with the 
information in Figure 3.&nbsp; This should help you to understand why the Biomorphs in Figure 4 
look the way that they do.</p>
<p><font color="#FF0000"><b>Increasing the value of the first gene</b></font></p>
<p>For example, when the value of the first gene 
was multiplied by a factor of three, this had the effect of increasing the value 
of g0 at the top of Figure 3, thus elongating the Biomorph in the vertical 
direction.&nbsp; <i>(See the center Biomorph in the top row of Figure 4.)</i></p>
<p><font color="#FF0000"><b>Increasing the value of the second gene</b></font></p>
<p>When the second gene was multiplied by a factor of three, this had the effect 
of increasing the value of g1 without increasing the value of g2 in Figure 3.&nbsp; 
This tended to stretch the Biomorph horizontally for those stems that had a 
northeasterly and northwesterly direction.&nbsp; <i>(See the right-most Biomorph 
in the first row in Figure 4.)</i></p>
<blockquote>
	<p><i>(For the record, Figure 4 was produced by an unpublished program named 
	Biomorph01x1.&nbsp; I mention this here just in case I need to go back and 
	retrieve the program later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Back to the code</b></font></p>
<p>With that as background information, it is now time to return to an 
explanation of the code in the constructor for the <b>Biomorph</b> class.</p>
<p>Recall that the shorthand notation g0, g1, g2, etc., in Figure 3 actually 
represents values in the gene array given by <b>genes[0]</b>, <b>genes[1]</b>,
<b>genes[2]</b>, etc.</p>
<p><font color="#FF0000"><b>Create and populate two arrays</b></font></p>
<p>The code in Listing 4 populates two arrays referred to by <b>xInc</b> and
<b>yInc</b> on the basis of the values stored in the gene array named <b>genes</b>.</p>
<p>The values in the new array referred to by <b>xInc</b> represent the 
horizontal components of the outer ends of the eight lines shown in Figure 3.</p>
<p>The 
values in the new array referred to by <b>yInc</b> represent the vertical 
components of the outer ends of the eight lines shown in Figure 3.</p>
<p><font color="#FF0000"><b>The coordinates of the ends of the lines</b></font></p>
<p>Taken together, 
the sixteen values in the two new arrays specify the coordinates of the outer ends of each of the eight 
lines shown in Figure 3.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    xInc[0] =  0;
                        yInc[0] =  this.genes[0];
    xInc[1] =  this.genes[1];
                        yInc[1] =  this.genes[2];
    xInc[2] =  this.genes[3];
                        yInc[2] =  0;
    xInc[3] =  this.genes[4];
                        yInc[3] = -this.genes[5];
    xInc[4] =  0;
                        yInc[4] = -this.genes[6];
    xInc[5] = -this.genes[4];
                        yInc[5] = -this.genes[5];
    xInc[6] = -this.genes[3];
                        yInc[6] =  0;
    xInc[7] = -this.genes[1];
                        yInc[7] =  this.genes[2];<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Array indices match direction numbers</b></font></p>
<p>The values stored at index 0 in the two new arrays specify the end of the 
line along direction 0 in Figure 3.</p>
<p>Similarly, each of the direction numbers in 
Figure 3 matches a corresponding index value in the two new arrays.</p>
<p>The coordinate values stored in the two new arrays will be used later, along with a multiplicative scale factor, to compute 
the coordinates of the end points of new stems in the Biomorph object.</p>
<p><font color="#FF0000"><b>The lengths of the stems</b></font></p>
A careful examination of Figure 1 reveals that the length of each new pair of 
stems is shorter than the length of the stem that spawned them.&nbsp; Listing 5 
shows the end of the constructor for the <b>Biomorph</b> class.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    length = this.genes[7];
  }//end constructor<br><br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 5 establishes the length of the first stem belonging to 
the Biomorph.</p>
<p>This initial line length is based on the number of stages to be drawn in the 
construction of the Biomorph.&nbsp; You will see later that the length of each 
new stem is reduced by a value of one relative to the length of the stem that 
spawned it.&nbsp; The algorithm terminates when the length of the stem reaches 
zero.</p>
<blockquote>
	<p><i>(The algorithm actually terminates after the last stem of length is 
	one is drawn.&nbsp; There is no point in attempting to draw a stem with zero 
	length.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The getGenes method</b></font></p>
As I mentioned earlier, a Biomorph has the ability to return a reference to its
<i>(potentially mutated)</i> gene array.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  double[] getGenes(){
    return this.genes;
  }//end getGenes<br><br><b><font face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method to accomplish this is very simple, and is shown in Listing 6.&nbsp; 
I wanted to get that out of the way before getting into the more complex topic 
of the overridden <b>paint</b> method.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
Screen graphics are created in Java by overriding the method named <b>paint</b>.&nbsp; 
When time comes to redraw the screen, the Java virtual machine, in conjunction 
with the operating system causes the overridden <b>paint</b> method to be 
invoked.&nbsp; The code written into the overridden <b>paint</b> method 
determines what gets drawn.<p>The overridden <b>paint</b> method is shown in 
Listing 7.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void paint(Graphics g){
    g.translate(xOrigin,yOrigin);
    <b>drawIt</b>(g,xCoor,yCoor,length,direction,xInc,
                                     yInc,scale);
  }//end paint()<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method appears to be very simple, but looks can be deceiving.</p>
<p><font color="#FF0000"><b>Adjust the plotting origin</b></font></p>
<p>The overridden <b>paint</b> method starts out simple enough.&nbsp; Recall 
that a Biomorph is an object that extends the class named <b>Panel</b>.&nbsp; 
Thus, the code in Listing 7 overrides the <b>paint</b> method inherited from the
<b>Panel</b> class.</p>
<p>By default, all coordinate values in Java are relative to the upper left-most 
corner of the component in which the coordinates are being determined.&nbsp; In 
other words, the plotting origin for a <b>Panel</b> object is the upper 
left-most corner of the panel.</p>
<p>The first statement in Listing 7 translates the plotting origin to a point 
near the center of the panel.&nbsp; You will see later that the actual 
coordinate values of the new origin are based on the overall size of the GUI and 
the number of panels placed in the GUI.</p>
<p><font color="#FF0000"><b>Invoke the drawIt method</b></font></p>
It is the second statement in Listing 7 that is deceivingly simple.&nbsp; This 
statement invokes the method named <b>drawIt</b> to cause the new Biomorph to 
be drawn on the screen.&nbsp; Some of you may find the <b>drawIt</b> method to be 
somewhat complex.<p><font color="#FF0000"><b>Recursion</b></font></p>
<p>If you are skilled in the use of recursion, you will probably find the <b>
drawIt</b> method to be relatively straightforward.&nbsp; However, the method is 
invoked recursively to draw the Biomorph, and those of you who are not skilled 
in the use of recursion may find it more difficult.</p>
<p><font color="#FF0000"><b>The Graphics object</b></font></p>
<p>The <b>paint</b> method always receives a reference to an object of the <b>
Graphics</b> class.&nbsp; As a practical matter, you can think of this object as 
representing the screen on which you are going to draw a picture.&nbsp; When you 
draw a picture on the <b>Graphics</b> object, it appears on the portion of the 
screen that belongs to your Java application.</p>
<p>As you can see in Listing 7, the reference to the <b>Graphics</b> object is 
passed as the first parameter to the <b>drawIt</b> method, giving that method 
the capability to draw pictures on the computer screen.</p>
<p><font color="#FF0000"><b>The drawIt method</b></font></p>
<p>The signature for the <b>drawIt</b> method is shown in Listing 8.&nbsp; As 
mentioned above, the first parameter is a reference to a <b>Graphics</b> object 
that gives the method the ability to draw pictures on the computer screen.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void drawIt(Graphics g,
              double oldX,
              double oldY,
              double len,
              int newDir,
              double[] xInc,
              double[] yInc,
              double scale){<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The oldX and oldY parameters</b></font></p>
<p>The Biomorph is actually constructed while it is being drawn in the <b>drawIt</b> 
method.&nbsp; The construction of the Biomorph consists of the definition of the 
end points of the stems that make up the Biomorph.&nbsp; Each of those stems is 
a straight line segment.</p>
<p>The <b>drawIt</b> method is invoked recursively to draw each stem.</p>
<p>The parameters named <b>oldX</b> and <b>oldY</b> specify the coordinates of 
the starting point of the stem.&nbsp; After the first call to the <b>drawIt</b> 
method, each recursive call to the method passes the coordinates of the end 
point of the current stem in these two parameters.&nbsp; That causes the end of 
one stem to become the starting point for the two stems spawned by that stem.</p>
<p><font color="#FF0000"><b>The length and direction of the line segment</b></font></p>
<p>As mentioned earlier, the length of the line that represents each new stem is 
reduced by one relative to the length of the stem that spawned it through the bifurcation process.&nbsp; Also, as mentioned earlier, 
each stem in the pair of new stems spawned in the bifurcation process go off in 
generally opposite directions.</p>
<p>The fourth and fifth parameters in the <b>drawIt</b> method signature contain the length 
and direction of the new stem.</p>
<p>The direction is specified as an integer according to the direction numbers 
shown in Figure 3.</p>
<p><font color="#FF0000"><b>The end-point arrays</b></font></p>
<p>The sixth and seventh parameters are references to objects that encapsulate 
the arrays containing the end points for lines in each of the eight possible 
directions.</p>
<p>Recall that the coordinate values stored in these two array objects were 
computed by the code in Listing 4 based on the values stored in the gene array.&nbsp; 
Like the gene values, the end-point values do not change during the recursive 
construction of a Biomorph.</p>
<p><font color="#FF0000"><b>The scale factor</b></font></p>
<p>The last parameter shown in Listing 8 is a scale factor that is applied to 
the drawing in an attempt to cause the size of the drawing to fit within 
its allocated space.&nbsp; The overall size of a Biomorph tends to increase as 
more stages are used to construct it.&nbsp; Stated differently, the overall size 
tends to increase as more and more stems are added.</p>
<p>As you will see later, the programs in this lesson cause the scale factor to 
increase as the number of stages increase.&nbsp; The reciprocal of the scale 
factor is used to scale the overall size of the drawing.&nbsp; This is an attempt to cause the size of 
the Biomorph to be appropriate for the allocated space regardless of the number 
of stages used in its construction. </p>
<p><font color="#FF0000"><b>Constraining the direction values</b></font></p>
The new direction value passed to the <b>drawIt</b> method is computed by adding 
a positive or negative integer to the direction value for the stem that spawned 
it.&nbsp; Left unchecked, this could result in negative direction values, or 
direction values that exceed the allowable positive limit of 7.<p>The code in 
Listing 9 constrains the direction value to the range from 0 through 7 
inclusive.&nbsp; Hopefully you understand enough about fundamental Java 
programming that the code in Listing 9 won't be a mystery.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    newDir = (newDir + 8)%8;<br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Compute end points of the new stem</b></font></p>
<p>The code in Listing 10 computes the coordinates of the end point of the new 
stem.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
    double newX = oldX + len * xInc[newDir];
    double newY = oldY + len * yInc[newDir];
<br><b><font face="Courier New,Courier">Listing 10</font></b>
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The stem is drawn as a straight line segment that begins at the coordinates 
given by the parameters <b>oldX</b> and <b>oldY</b>, and ends at the coordinates 
computed in Listing 10.</p>
<p><font color="#FF0000"><b>The genes determine the shape of the Biomorph</b></font></p>
<p>The values of the new coordinates are the product of the length of the new 
stem <i>(received as an incoming parameter),</i> and the coordinate values 
stored in the two arrays discussed earlier.&nbsp; </p>
<p>The value of the new direction is used as an index to retrieve the coordinate 
values from the two arrays.&nbsp; Since the coordinate values in the two arrays 
was computed earlier on the basis of the values of the genes, the values of the 
genes and the length of the stem determine the coordinates of the end of the new 
stem.&nbsp; This explains how the values of the genes ultimately determine the 
shape of the Biomorph, one stem at a time.</p>
<p><font color="#FF0000"><b>Draw the current stem</b></font></p>
<p>The code in Listing 11 invokes the <b>drawLine</b> method of the <b>Graphics</b> 
class to actually draw the stem on the computer screen.&nbsp; If you are 
unfamiliar with this method, you can look it up in the Sun documentation.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    g.drawLine((int)(oldX/scale),
               (int)(-oldY/scale),
               (int)(newX/scale),
               (int)(-newY/scale));<br><br><b><font face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Correct for vertical direction</b></font></p>
<p>By default, positive vertical values are drawn going down the screen.&nbsp; 
This is backwards to what most of us are comfortable with in a Cartesian 
coordinate system where positive vertical values normally go up.</p>
<p>The minus signs in Listing 11 correct for this situation causing positive 
vertical values to be drawn going up the screen.</p>
<p><font color="#FF0000"><b>Make a recursive call to the drawIt method</b></font></p>
Having drawn one stem, it is time to make two recursive calls to the <b>drawIt</b> 
method to implement the bifurcation process and to cause the two stems that 
result from that process to be drawn.&nbsp; This is accomplished by the code in 
Listing 12.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if(len > 1){
      drawIt(g,newX,newY,len-1,newDir+1,xInc,
                                    yInc,scale);
      drawIt(g,newX,newY,len-1,newDir-1,xInc,
                                    yInc,scale);
    }//end if
  }//end drawIt<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The length of the new stem</b></font></p>
<p>Each time a recursive call is made to the <b>drawIt</b> method, the length of 
the stem to be drawn is reduced by one.&nbsp; The code in Listing 12 causes the 
stems to continue bifurcating and drawing new stems for as long as the current 
length is greater than 1.&nbsp; </p>
<p>When the length of the current stem reaches 1, the <b>drawIt</b> method 
returns without bifurcating and drawing any more new stems.</p>
<blockquote>
	<p><i>(It wouldn't make any sense to try to draw a stem whose length is 
	zero.)</i></p>
</blockquote>
<p>That is what terminates the recursion process.</p>
<p><font color="#FF0000"><b>The starting point for the new stem</b></font></p>
<p>Note that the coordinates of the end point for the current stem are passed to 
the <b>drawIt</b> method where they become the coordinates for the starting 
point of the new stem.</p>
<p><font color="#FF0000"><b>The directions of the new stems</b></font></p>
<p>The only difference between the two recursive calls to the <b>drawIt</b> 
method in Listing 12 has to do with the direction parameter.&nbsp; For the first 
call to the <b>drawIt</b> method, the new direction is increased by one relative 
to the current direction.&nbsp; For the second call to the <b>drawIt</b> method, 
the new direction is decreased by one relative to the current direction.</p>
<p>Referring back to Figure 3, for example, we see that if the direction number 
for the current stem is 2, the direction number for one of the new stems will be 
3 and the direction number for the other new stem will be 1.</p>
<p>Similarly, referring both to Figure 3 and Listing 9, we see that if the 
direction number for the current stem is 0, the direction number for one of the 
new stems will be 2 and the direction number for the other new stem will be 7.</p>
<p><font color="#FF0000"><b>Recursive behavior</b></font></p>
<p>A complete explanation of recursive behavior is beyond the scope of this 
lesson.&nbsp; However, it might be useful to provide a visual illustration of 
recursion.</p>
<p>The recursive behavior provided by Listing 12 is quite complex due to the 
fact that two successive statements make recursive calls to the <b>drawIt</b> 
method.&nbsp; That behavior can be greatly simplified by modifying the code in 
Listing 12 to that shown in Listing 13.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if(len > 1){
      drawIt(g,newX,newY,len-1,newDir+1,xInc,
                                    yInc,scale);
<font color="#808080">/*</font>
<font color="#808080">      drawIt(g,newX,newY,len-1,newDir-1,xInc,
                                    yInc,scale);</font>
<font color="#808080">*/</font>
    }//end if
  }//end drawIt<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The second recursive call to the <b>drawIt</b> method has been disabled in 
Listing 13 by turning it into a comment.</p>
<p><font color="#FF0000"><b>The simplified output</b></font></p>
<p>When the program that produced the output shown in Figure 1 is modified in 
the manner shown in Listing 13 and then rerun, the new simplified output is as 
shown in Figure 5.</p>
<p align="center"><img border="0" src="java1480e.gif" width="401" height="401"></p>
<p align="center">Figure 5&nbsp; Nine stages in the growth of a simplified 
Biomorph</p><font color="#FF0000"><b>Compare Figure 5 with Figure 1</b></font><p>
If you compare Figure 5 with Figure 1, you will see that the output in each of 
the nine drawing areas consists only of the successive recursively generated 
stems for which the new direction value is one greater than the old direction 
value.</p>
<p>You will also see that each stem is shorter than the one that spawned it, and 
recursion terminates when the length of the current stem reaches a value of one.</p>
<blockquote>
	<p><i>(Recall that the overall plotting scale factor applied to the drawing 
	in the upper left-most position is greater than the scale factor 
	applied to the drawing in the lower right-most position.&nbsp; Thus a stem 
	length of one unit in the upper left-most position is longer than a stem 
	length of one unit in the lower right-most position.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>End of the Biomorph class</b></font></p>
<p>The code in Listing 12 signals the end of the class named <b>Biomorph</b>, 
from which our Biomorph objects are instantiated.</p>
<p>Now that you understand the <b>Biomorph</b> class, you should have little 
trouble understanding the three programs shown in Listing 31, Listing 32, 
and Listing 33 near the end of the lesson.&nbsp; All three of the programs use 
the <b>Biomorph</b> class to create Biomorph objects.&nbsp; The difference in 
the three programs lies in how they manage the Biomorph objects.</p>
<p><font color="#FF0000"><b>The program named Biomorph01</b></font></p>
<p>As usual, I will explain all three of the programs in fragments.&nbsp; A 
complete listing of the program named <b>Biomorph01</b> is presented in Listing 
31 near the end of the lesson.</p>
<p>The purpose of the program named <b>Biomorph01</b> is to compute and display the first nine stages of growth for a Biomorph based on a simple gene set where each of the seven genes that control the shape of the Biomorph have a fixed value of 1.</p>
<p>The program begins in Listing 14, which declares and initializes two static 
member variables.&nbsp; The variables are declared static to make it possible to 
refer to them from the static <b>main</b> method.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class Biomorph01{
  static double[] genes = new double[8];

  static Random rGen =
                new Random(new Date().getTime());<br><br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first member variable is used later to store the eight genes required by 
the <b>Biomorph</b> class.&nbsp; As you learned earlier, the first seven genes 
control the shape of the Biomorph, while the eighth gene controls the number of 
bifurcating stages used to construct the Biomorph.</p>
<p>The second member variable provides a random number generator.&nbsp; As you 
learned earlier, this random number generator is required by the <b>Biomorph</b> 
class.&nbsp; However, it isn't actually used by this program.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method is shown in its entirety in Listing 15.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void <b>main</b>(String[] args){
    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt]=1;
    }//end for

    genes[7] = 1;

    new GUI(genes,rGen);
  }//end main<br><br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in the <b>main</b> method performs the following tasks:</p>
<ul>
	<li>Populate the gene array with seven fixed gene values of 1.</li>
	<li>Specify the number of stages used to construct the first Biomorph.</li>
	<li>Instantiate an object of the GUI class that will take care of the 
	remaining tasks.</li>
</ul>
<p>This is all relatively straightforward and shouldn't require further 
explanation.</p>
<p>Listing 15 also signals the end of the class named <b>Biomorph01</b>.</p>
<p><font color="#FF0000"><b>The class named GUI</b></font></p>
<p>This class is used to instantiate a graphical user interface object that 
causes the first nine stages of a simple Biomorph to be created and displayed in 
nine grid cells in a <b>Frame</b> object.&nbsp; Figure 1 shows the output 
produced by this class.</p>
<p>The beginning of the <b>GUI</b> class is shown in Listing 16.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class GUI extends Frame{
  Random rGen;
  double[] genes;<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 16 declares instance variables used to store references to the gene 
array object and the random number generator object.</p>
<p><font color="#FF0000"><b>The GUI constructor</b></font></p>
<p>The constructor for the <b>GUI</b> class begins in Listing 17.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public GUI(double[] genes,Random rGen){
    this.rGen = rGen;
    this.genes = genes;<br><br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 17 saves the incoming parameters in the instance 
variables declared in Listing 16.</p>
<p><font color="#FF0000"><b>Set the layout manager</b></font></p>
<p>Listing 18 replaces the default layout manager for the <b>Frame</b> object 
with a layout manager that subdivides the frame into nine grid cells of equal 
size.&nbsp;
<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    setLayout(new GridLayout(3,3));<br><br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>See Figure 1 for an example of the new layout.</p>
<p><font color="#FF0000"><b>Create and display nine Biomorphs</b></font></p>
<p>Listing 19 shows the beginning of a <b>for</b> loop that creates and displays 
the nine stages of growth for a Biomorph using the same genes for each stage.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt = 0; cnt < 9; cnt++){
      Biomorph biomorph =
                        new Biomorph(genes,
                                     rGen,
                                     -1,
                                     genes[7]/8,
                                     66,
                                     66);<br><br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(Actually, the <b>for</b> loop creates and displays nine different 
Biomorphs, with each successive Biomorph being constructed with one more stage 
than the previous Biomorph.)</i></p>
</blockquote>
<p>You already know all about the <b>Biomorph</b> class, so the only discussion 
that should be needed is a discussion of the parameters to the <b>Biomorph</b> 
constructor.</p>
<p><font color="#FF0000"><b>Biomorph constructor parameters</b></font></p>
<p>The first two parameters pass the gene array and the random number generator 
to the <b>Biomorph</b> constructor.</p>
<p>The third parameter value of -1 causes the value of <b>cnt</b> to be <i>out 
of range</i> so that the code in the body of the <b>if</b> statement in Listing 
3 is not executed.&nbsp; As a result, no mutation of the genes takes place.</p>
<p>The scale factor, which is passed as the fourth parameter, is proportional to 
the number of stages used to construct the Biomorph.&nbsp; As described earlier, 
this is an attempt to cause each individual Biomorph shown in Figure 1 to be 
appropriate for the allocated drawing area for that Biomorph.</p>
<p>Finally, the last two parameters cause the plotting origin to be placed in 
the center of the allocated drawing area for each Biomorph.</p>
<p><font color="#FF0000"><b>Setting the background colors</b></font></p>
<p>An object of the class <b>Panel</b> doesn't have a border of any kind.&nbsp; 
Therefore, when two or more <b>Panel</b> object are drawn adjacent to one 
another, it isn't possible to tell where on ends and the other begins unless 
something is done to cause the boundary between the two to be visible.</p>
<p>As shown in Figure 1, the code in Listing 20 causes the background colors of 
adjacent Biomorphs to alternate between yellow and green.&nbsp; This makes it 
easy to recognize the boundary between two Biomorphs.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      if(cnt%2 == 0){
        biomorph.setBackground(Color.YELLOW);
      }else{
        biomorph.setBackground(Color.GREEN);
      }//end else
<br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Add the new Biomorph to the Frame</b></font></p>
<p>Recall that we are still discussing the body of the <b>for</b> loop that 
began in Listing 19.&nbsp; The code in Listing 21 adds the new Biomorph that was 
constructed in Listing 19 to the next grid cell on the frame.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      this.add(biomorph);<br><br><b><font face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Increase the number of stages</b></font></p>
<p>Listing 22 increments the eighth gene in the gene array.&nbsp; This causes 
the number of stages that will be used to construct the next Biomorph to be one 
greater than the number of stages that were used to construct the current 
Biomorph.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      genes[7] += 1;
    }//end for loop<br><br><b><font face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 22 also signals the end of the <b>for</b> loop that began in Listing 
19.</p>
<p><font color="#FF0000"><b>Complete the GUI class definition</b></font></p>
<p>Listing 23 shows the remaining code in the definition of the class named <b>
GUI</b>.&nbsp; This code is completely straightforward and shouldn't require an 
explanation.&nbsp; It is included here only for completeness.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    setTitle("Copyright 2004, R.G.Baldwin");
    setSize(400,400);
    setVisible(true);

    //Instantiate and register a Listener object
    // that will terminate the program when the
    // user closes the Frame
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor

}//end class GUI definition<br><br><b><font face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The program named Biomorph02</b></font></p>
<p>Listing 32 near the end of the lesson presents a complete listing of the 
program named <b>Biomorph02</b>.</p>
<p>The purpose of this program is to compute and display the first nine stages 
of growth for a Biomorph based on a complex gene set where each of the seven 
genes that control the shape of the<br>
Biomorph are obtained from a random number generator.</p>
<p>This program should produce Biomorph objects having different appearances 
each time it is run.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method for this program is shown in Listing 24.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){

<font color="#DD0000"><b>    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt] = rGen.nextInt(7)-3;
    }//end for</b></font>

    genes[7] = 1;

    new GUI(genes,rGen);
  }//end main<br><br><b><font face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The only real difference between this program and the program named <b>
Biomorph01</b> is the code in the <b>main</b> method that is highlighted in red 
boldface in Listing 24.</p>
<p>Recall that the first seven gene values in the program named <b>Biomorph01</b> 
had a value of 1.&nbsp; This program, on the other hand, uses a random number 
generator to create those seven gene values.&nbsp; The purpose is to illustrate 
the variety of ways that the Biomorphs differ when the gene values differ.&nbsp; 
To see those differences, simply compile this program and run it several times in 
succession.&nbsp; Each time you run it, you should see a different set of 
Biomorphs.</p>
<p><font color="#FF0000"><b>Sample outputs</b></font></p>
<p>Three sample outputs from this program are shown in Figure 6, Figure 7, and 
Figure 8.</p>
<p align="center"><img border="0" src="java1480f.gif" width="401" height="401"></p>
<p align="center">Figure 6&nbsp; Biomorphs based on random gene values</p>
<p align="left">I don't know what you think, but the Biomorph in Figure 6 looks 
remarkably like an eagle to me.</p>
<p align="center"><img border="0" src="java1480g.gif" width="401" height="401"></p>
<p align="center">Figure 7&nbsp; Biomorphs based on random gene values</p>
<p align="left">The Biomorph in Figure 7 reminds me of a <i>&quot;daddy longlegs&quot;</i> 
spider hanging from a single strand of its web.</p>
<p align="center"><img border="0" src="java1480h.gif" width="401" height="401"></p>
<p align="center">Figure 8&nbsp; Biomorphs based on random gene values</p>
<p>The Biomorph in Figure 8 makes me think of looking across a pond and seeing 
the reflection of trees or buildings in the pond.</p>
<p><font color="#FF0000"><b>No artificial selection was involved</b></font></p>
<p>No artificial selection was involved in these three samples.&nbsp; These 
images were produced simply by setting the gene values at random and using that 
gene set to produce the Biomorph.&nbsp; I will get into artificial selection in 
the next section.</p>
<p><font color="#FF0000"><b>The program named Biomorph03</b></font></p>
<p>This is the program that provides the <i>artificial selection</i> capability 
described in the <a href="#Preview">Preview</a> section of this lesson.</p>
<p>The behavior of the program has been described in general terms in previous sections 
of this lesson.&nbsp; To use artificial selection to breed a Biomorph having 
desirable characteristics, simply run the program and select the Biomorph that 
you consider to be <i>&quot;best&quot;</i> with the mouse.&nbsp; That Biomorph will become 
the parent of the next generation of Biomorphs.&nbsp; The parent will appear in 
the lower left-most cell in the display and the siblings in the new generation 
will occupy the other eight cells.</p>
<p>Repeat that process until you have bred a generation of Biomorphs that match 
your desired characteristics.</p>
<p><font color="#FF0000"><b>Some results</b></font></p>
<p>I will explain the inner 
workings of the program in the remainder of this lesson.</p>
<p>Before getting into the technical details, let's take a look at some results, 
as shown in Figure 9 and Figure 10.</p>
<p align="center"><img border="0" src="java1480i.gif" width="401" height="401"></p>
<p align="center">Figure 9&nbsp; Starting point for <i>artificial selection</i> 
process</p>
<p align="center"><img border="0" src="java1480j.gif" width="401" height="394"></p>
<p align="center"><a name="Figure_10">Figure 10</a>&nbsp; Stealth aircraft produced through <i>
artificial selection</i></p>
<p><font color="#FF0000"><b>The starting point</b></font></p>
<p>The bottom right-most Biomorph in Figure 9 is the original parent Biomorph 
provided by this program.&nbsp; The other eight Biomorphs shown in Figure 9 are 
the eight offspring that constitute the first new generation.&nbsp; Each of the 
offspring differs from the parent in terms of the value of one gene.&nbsp; Each 
of the offspring has a mutated value in a different gene, so no two offspring 
are exactly alike.</p>
<p>As you can see, 
some of the offspring strongly resemble the parent, while others have little 
resemblance to the parent.&nbsp; It all depends on which gene was mutated.</p>
<p><font color="#FF0000"><b>Several generations later</b></font></p>
<p>Figure 10 shows a parent and eight offspring produced about nine or ten 
generations later.</p>
<p>After a couple of clicks, I noticed something developing that looked a little 
like a stealth aircraft.&nbsp; I decided to emphasize that characteristic, and 
after a few more clicks, the Biomorphs that you see in Figure 10 had evolved.&nbsp; 
If you use your imagination, most of the Biomorphs in Figure 10 look something 
like a stealth aircraft.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will discuss the program named <b>Biomorph03</b> in fragments.&nbsp; A 
complete listing of the program is shown in Listing 33 near the end of the 
lesson.</p>
<p>Much of the code in this program is very similar to code in one or the other 
of the two programs discussed earlier in this lesson.&nbsp; I won't repeat a 
discussion of that code, but rather will emphasize the differences between this 
program and two previous programs.</p>
<p><font color="#FF0000"><b>A mouse listener</b></font></p>
<p>The <b>Biomorph03</b> class begins in Listing 25.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class Biomorph03 <b>implements MouseListener</b>{
  static double[] genes = new double[8];
  static GUI gui;
  static <b>MouseListener listener</b>;
  static Random rGen = new Random(
                           new Date().getTime());<br><br><b><font face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The most significant new thing in Listing 25 is the fact that this class 
implements the <b>MouseListener</b> interface.&nbsp; Thus, an object 
instantiated from this class can be registered on any component capable of 
firing mouse events, <i>(which includes objects of the Biomorph class).</i></p>
<p>In addition to implementing the <b>MouseListener</b> interface, the code in 
Listing 25 also declares a static member variable of type <b>MouseListener</b>.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method begins in Listing 26.&nbsp; The code in Listing 26 
instantiates an object of the <b>Biomorph03</b> class and saves its reference as type <b>
MouseListener</b>.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
  public static void main(String[] args){
    listener = new Biomorph03();

    //Create initial set of genes.
    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt] = 1.0;
    }//end for<br><br><b><font face="Courier New,Courier">Listing 26</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Later on, this <b>MouseListener</b> object will be registered on each of the
<b>Biomorph</b> objects.&nbsp; This will make it possible for the user to use 
the mouse to select one of the nine Biomorphs to serve as the parent 
Biomorph for the next generation.</p>
<p><font color="#FF0000"><b>Initial gene set</b></font></p>
<p>As was the case in the program named <b>Biomorph01</b>, this program causes 
the first seven genes to have an initial value of 1.0.&nbsp; Thus, 
the starting set of genes for this program is always the same.</p>
<blockquote>
	<p><i>(You may also find it interesting to modify this program to use a set 
	of seven random values for the initial set of genes.&nbsp; You can lift that 
	code from the program named <b>Biomorph02.</b>)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A five-stage Biomorph</b></font></p>
<p>The value stored in the eighth gene specifies the number of stages that will 
be used to construct the Biomorph.&nbsp; The code in Listing 27 sets the initial 
value of this gene to 5.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    genes[7] = 5;

    gui = new GUI(genes,listener,rGen);
  }//end main<br><br><b><font face="Courier New,Courier">Listing 27</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Recall, however, that this value can increase or decrease due to mutation of the genes.&nbsp; If 
this value goes to zero, the Biomorph created using that gene set will disappear.&nbsp; 
As you learned earlier, the value of the eighth gene is not allowed to go negative.</p>
<p><font color="#FF0000"><b>A new GUI object</b></font></p>
<p>The code in Listing 27 also instantiates a new <b>GUI</b> object.&nbsp; The 
major difference is that this version passes the <b>MouseListener</b> object's 
reference to the constructor for the <b>GUI</b> object.</p>
<p>Listing 27 also signals the end of the <b>main</b> method.</p>
<p><font color="#FF0000"><b>The MouseListener methods</b></font></p>
<p>Because this class implements the <b>MouseListener</b> interface, it must 
provide concrete definitions of the five methods declared in the interface.&nbsp; 
One of those methods is named <b>mouseClicked</b>.</p>
<p>The definition of the <b>mouseClicked</b> method is shown in Listing 28.&nbsp; 
The purpose of this method is to make it possible for the user to select one of 
the nine Biomorphs to become the parent for the next generation of Biomorphs.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public void mouseClicked(MouseEvent e){
    Biomorph theMorph =
                       (Biomorph)(e.getSource());
    genes = theMorph.getGenes();

    gui.dispose();

    gui = new GUI(genes,listener,rGen);
  }//end mouseClicked<br><br><b><font face="Courier New,Courier">Listing 28</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the mouseClicked method</b></font></p>
<p>The <b>mouseClicked</b> method does the following:</p>
<ul>
	<li>Identify the specific Biomorph object that was selected with the mouse.</li>
	<li>Get and save the mutated gene array belonging to that Biomorph object.&nbsp; 
	This will be the gene array belonging to the parent of the next generation.&nbsp; 
	Each offspring Biomorph in the next generation will have these genes except 
	that each offspring will mutate one gene in the 
	array.</li>
	<li>Dispose of the existing <b>GUI</b> object in preparation for creating a 
	new one that displays the parent and eight offspring in the next generation 
	of Biomorphs.</li>
	<li>Instantiate a new <b>GUI</b> object based on the gene array belonging to 
	the Biomorph that was selected.</li>
</ul>
<p><font color="#FF0000"><b>The remaining MouseListener methods</b></font></p>
<p>Listing 29 defines the remaining four methods declared in the <b>
MouseListener</b> interface as empty methods.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
  public void mousePressed(MouseEvent e){};
  public void mouseReleased(MouseEvent e){};
  public void mouseEntered(MouseEvent e){};
  public void mouseExited(MouseEvent e){};

}//end class Biomorph03
<br><br><b><font face="Courier New,Courier">Listing 29</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 29 also signals the end of the definition of class named <b>
Biomorph03</b>.</p>
<p><font color="#FF0000"><b>The GUI class</b></font></p>
<p>The entire definition for the <b>GUI</b> class is shown in Listing 30.&nbsp; 
This class is used to instantiate a graphical user interface object that 
displays nine Biomorphs in a 3x3 grid.&nbsp; A <b>MouseListener</b> is 
registered on each Biomorph as it is added to the graphical user interface.<br>
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class GUI extends Frame{
  Random rGen;
  Biomorph[] morphs = new Biomorph[9];
  double[] genes;

  //Constructor
  public GUI(double[] genes,
             MouseListener listener,
             Random rGen){
    //Save incoming parameters.
    this.rGen = rGen;
    this.genes = genes;

    //Subdivide the GUI into nine grid cells of
    // equal size.
    setLayout(new GridLayout(3,3));

    //Instantiate nine Biomorph objects.  Add
    // them to the GUI.  They are placed in the
    // grid cells in the GUI from left to right,
    // top to bottom.
    //Register a mouse listener on each Biomorph
    // object.  Set the background color for each
    // Biomorph object to produce alternating
    // green and yellow backgrounds.
    for(int cnt = 0; cnt < 9; cnt++){
      //Instantiate and save a new Biomorph
      // object.  Set the origin to be the center
      // of the grid cell.
      morphs[cnt] = new Biomorph(genes,
                                 rGen,
                                 cnt,
                                 genes[7]/8,
                                 66,
                                 66);

      //Add this Biomorph object to the Frame in
      // the next grid cell.
      this.add(morphs[cnt]);

      //Register a mouse listener on the Biomorph
      // object.<b><font color="#DD0000">
      morphs[cnt].addMouseListener(listener);</font></b>

      //Cause the background colors of the
      // Biomorph objects to alternate between
      // yellow and green so that they will be
      // visually separable in the Frame.
      if(cnt%2 == 0){
        morphs[cnt].setBackground(Color.YELLOW);
      }else{
        morphs[cnt].setBackground(Color.GREEN);
      }//end else
    }//end for loop

    //Finish the GUI and make it visible.
    setTitle("Copyright 2004, R.G.Baldwin");
    setSize(400,400);
    setVisible(true);

    //Instantiate and register a Listener object
    // that will terminate the program when the
    // user closes the Frame
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor

}//end class GUI definition<br><br><b><font face="Courier New,Courier">Listing 30</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Registering the MouseListener</b></font></p>
<p>About the only thing that causes this <b>GUI</b> class to be different from 
the classes with the same name in the previous two programs is the registration 
of the <b>MouseListener</b> object on each <b>Biomorph</b> object as it is added 
to the frame.&nbsp; I highlighted that statement in red boldface so that it will 
be easy for you to find.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Programs</a></h2>
<p>I encourage you to copy the code from the program listings near the end of 
this lesson.&nbsp; Compile and run the programs.&nbsp; 
Experiment with them, improving them as you see fit.</p>
<p>Above all, have fun.<br>
</p>
<center>
<h2><a name="Summary"></a>Summary</h2>
</center>
I showed you how to write 
programs that model the selective breeding process, sometimes referred to as <i>artificial selection.</i>&nbsp; This is as opposed to 
<i>natural selection,</i> sometimes 
referred to as <i>survival of the fittest.</i><p>Whether or not you found these 
programs to be useful, I hope you found them to be fun.&nbsp; Hopefully you 
also learned a few new things about Java programming based on the way that these 
programs are written.</p>
<center>
<h2><a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the three programs explained in this lesson are
provided in <font color="#000000">Listing 31, Listing 32, and Listing 33 below</font>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
/*File Biomorph01.java Copyright 2004,R.G.Baldwin
Revised 4/8/04

The purpose of this program is to compute and
display the first nine stages of growth for a
Biomorph based on a simple gene set where each of
the seven genes that control the shape of the
Biomorph have a fixed value of 1.

This program is loosely based on material in
Chapter 8 of the book entitled Windows Hothouse
by Mark Clarkson.  However, it was necessary for
me to find and fix several typographical errors
in the C++ algorithm presented in that book.

Tested using J2SE 1.4.2 under WinXP.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Biomorph01{
  //Store the genes here.  The first seven genes
  // control the shape of the Biomorph.  The
  // eighth gene specifies the number of stages
  // used to construct the Biomorph.
  static double[] genes = new double[8];

  //This random number generator is required by
  // the Biomorph constructor, but isn't used for
  // any purpose in this program.
  static Random rGen =
                new Random(new Date().getTime());

  public static void main(String[] args){
    //Create 7 fixed gene values.
    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt]=1;
    }//end for
    //Specify the number of stages in the first
    // Biomorph object.
    genes[7] = 1;
    //Instantiate the GUI
    new GUI(genes,rGen);
  }//end main

}//end class Biomorph01

//=============================================//

//The following class is used to instantiate a
// graphical user interface object that causes
// the first nine stages of a Biomorph object to
// be created and displayed in nine grid cells in
// a Frame object.
class GUI extends Frame{
  Random rGen;
  double[] genes;

  //Constructor
  public GUI(double[] genes,Random rGen){
    //Save incoming parameters in local
    // variables.
    this.rGen = rGen;
    this.genes = genes;

    //Subdivide the Frame into nine grid cells.
    setLayout(new GridLayout(3,3));

    //Create and display nine stages of growth
    // for a Biomorph object using the same genes
    // for each stage.  Specify the third
    // parameter value to be negative to prevent
    // the Biomorph constructor from mutating the
    // genes.
    for(int cnt = 0; cnt < 9; cnt++){
      Biomorph biomorph =
                        new Biomorph(genes,
                                     rGen,
                                     -1,
                                     genes[7]/8,
                                     66,
                                     66);
      //Cause the background colors of the
      // Biomorph objects to alternate between
      // yellow and green so that they will be
      // visually separable in the Frame.
      if(cnt%2 == 0){
        biomorph.setBackground(Color.YELLOW);
      }else{
        biomorph.setBackground(Color.GREEN);
      }//end else

      //Add the Biomorph object to the Frame in
      // the next grid cell.
      this.add(biomorph);

      //Increase the number of stages for the
      // next Biomorph object.
      genes[7] += 1;
    }//end for loop

    setTitle("Copyright 2004, R.G.Baldwin");
    setSize(400,400);
    setVisible(true);

    //Instantiate and register a Listener object
    // that will terminate the program when the
    // user closes the Frame
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor

}//end class GUI definition
//=============================================//

//This class is used to instantiate a Biomorph
// object.  It is based loosely on Chapter 8 of
// the book entitled Windows Hothouse by Mark
// Clarkson.  However, the C++ algorithm
// presented in that book contains several
// serious typographical errors.  It was
// necessary for me to find and fix those errors
// when writing a Java version of the algorithm.
//The constructor receives an array of eight gene
// values. The final value in the array specifies
// the number of stages to be used to construct
// the Biomorph object.  The first stage produces
// a single stem.  Each successive stage causes
// all existing stems to bifurcate into two new
// stems.  Thus, the number of stems increases as
// a power of two based on the number of stages.
// For example, a Biomorph created with two
// stages contains three stems.  A three-stage
// Biomorph contains seven stems, a four-stage
// Biomorph contains fifteen stems, etc.
//When writing the Java version of the algorithm,
// I elected to maintain all of the data as type
// double in order to preserve arithmetic
// accuracy.  Values are converted from double to
// int at the very last step before displaying
// the Biomorph on the screen.
//The constructor receives a random number
// generator and a count value that are used to
// mutate a gene in the array of genes by a
// random value of plus or minus one whenever the
// count value is within the range from 0 to 7.
// If the count value is outside this range,
// there is no gene mutation.
//A method named getGenes returns the gene array
// containing the possibly mutated gene.  This is
// useful for experiments in selective breeding.
//The constructor receives a scale factor that is
// used to adjust the overall size of the plot to
// cause it to fit in the allocated plotting
// area.  Generally speaking, the size of the raw
// display of the Biomorph object would increase
// as the number of stages increases.  Therefore,
// it is useful to cause the scale factor to vary
// inversely with the number of stages.
//The constructor receives a pair of int values
// that are used to move the plotting origin
// from the default upper-left corner to another
// location in the plotting area.
//The direction of the first stem displayed for
// the Biomorph object is hard-coded to be
// vertical going up the screen, starting at the
// origin.
class Biomorph extends Panel{
  double[] xInc = new double[8];
  double[] yInc = new double[8];
  double[] genes;
  double xCoor = 0;//Start drawing here
  double yCoor = 0;//Start drawing here
  int direction = 0;//Initial drawing direction
  double length;
  double scale;
  int xOrigin;
  int yOrigin;

  //Constructor
  Biomorph(double[] genes,Random rGen,int cnt,
           double scale,int xOrigin,int yOrigin){

    //Save local copies of incoming parameters.
    this.genes = (double[])genes.clone();
    this.scale = scale;
    this.xOrigin = xOrigin;
    this.yOrigin = yOrigin;

    //Mutate gene at position cnt unless cnt is
    // out of the range from 0 through 7
    // inclusive.
    if((cnt>=0) && (cnt<=7)){
      double mutantValue = rGen.nextInt(2)*2-1;
      this.genes[cnt] += mutantValue;
      //Don't allow the eighth gene to go
      // negative
      if(this.genes[7] < 0)this.genes[7] = 0;
    }//end if

    //Compute incremental ends of lines based on
    // gene values.  Note that the C++ algorithm
    // presented in the Clarkson book appears to
    // contain several errors at this point.
    // Either that, or perhaps I don't fully
    // understand his version of the algorithm.
    xInc[0] =  0;
                        yInc[0] =  this.genes[0];
    xInc[1] =  this.genes[1];
                        yInc[1] =  this.genes[2];
    xInc[2] =  this.genes[3];
                        yInc[2] =  0;
    xInc[3] =  this.genes[4];
                        yInc[3] = -this.genes[5];
    xInc[4] =  0;
                        yInc[4] = -this.genes[6];
    xInc[5] = -this.genes[4];
                        yInc[5] = -this.genes[5];
    xInc[6] = -this.genes[3];
                        yInc[6] =  0;
    xInc[7] = -this.genes[1];
                        yInc[7] =  this.genes[2];


    //Initial line length is based on the number
    // of stages to be drawn.  Line length is
    // reduced by one as each successive stage is
    // drawn.  Algorithm terminates when length
    // reaches zero.
    length = this.genes[7];
  }//end constructor

  double[] getGenes(){
    return this.genes;
  }//end getGenes

  //Override the paint method
  public void paint(Graphics g){
    //Adjust location of the plotting origin
    g.translate(xOrigin,yOrigin);
    //Draw the Biomorph object recursively
    drawIt(g,xCoor,yCoor,length,direction,xInc,
                                     yInc,scale);
  }//end paint()
  //-------------------------------------------//

  void drawIt(Graphics g,double oldX,
              double oldY,double len,int newDir,
              double[] xInc,double[] yInc,
              double scale){
    //Direction values are limited to the range
    // from 0 to 7.
    newDir = (newDir + 8)%8;

    //Compute the end points of the line to be
    // drawn based ultimately on the values in
    // the gene array.
    double newX = oldX + len * xInc[newDir];
    double newY = oldY + len * yInc[newDir];

    //Draw the line.  Correct for the fact that
    // the default direction for positive y is
    // down the screen.
    g.drawLine((int)(oldX/scale),
               (int)(-oldY/scale),
               (int)(newX/scale),
               (int)(-newY/scale));

    //Continue drawing lines recursively until
    // the length of the next line reaches zero.
    // Decrease the length of the line by one for
    // each successive stage.  The values for
    // newX and newY become the incoming oldX and
    // oldY values for the next recursion.  Don't
    // waste time trying to draw a line with zero
    // length.
    if(len > 1){
      drawIt(g,newX,newY,len-1,newDir+1,xInc,
             yInc,scale);
      drawIt(g,newX,newY,len-1,newDir-1,xInc,
             yInc,scale);
    }//end if
  }//end drawIt

}//end class Biomorph
//=============================================//

Listing 31
      </td>
    </tr>
  </tbody>
</table>
</p>
<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
/*File Biomorph02.java Copyright 2004,R.G.Baldwin
Revised 4/8/04

The purpose of this program is to compute and
display the first nine stages of growth for a
Biomorph based on a complex gene set where each
of the seven genes that control the shape of the
Biomorph are obtained from a random number
generator.  This program should produce Biomorph
objects having different appearances each time it
is run.

This program is loosely based on material in
Chapter 8 of the book entitled Windows Hothouse
by Mark Clarkson.  However, it was necessary for
me to find and fix several typographical errors
in the C++ algorithm presented in that book.

Tested using J2SE 1.4.2 under WinXP.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Biomorph02{
  //Store the genes here.  The first seven genes
  // control the shape of the Biomorph.  The
  // eighth gene specifies the number of stages
  // used to construct the Biomorph.
  static double[] genes = new double[8];

  //This random number generator is required by
  // the Biomorph constructor.  In this program,
  // it is used to create the gene set, but is
  // not used otherwise in the construction of
  // the Biomorph objects.
  static Random rGen =
                new Random(new Date().getTime());

  public static void main(String[] args){
    //Create 7 random gene values.  This is the
    // code in this program that is different
    // from the code in the program named
    // Biomorph01.
    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt] = rGen.nextInt(7)-3;
    }//end for
    //Specify the number of stages in the first
    // Biomorph object.
    genes[7] = 1;
    //Instantiate the GUI
    new GUI(genes,rGen);
  }//end main

}//end class Biomorph02

//=============================================//

//The following class is used to instantiate a
// graphical user interface object that causes
// the first nine stages of a Biomorph object to
// be created and displayed in nine grid cells in
// a Frame object.
class GUI extends Frame{
  Random rGen;
  double[] genes;

  //Constructor
  public GUI(double[] genes,Random rGen){
    //Save incoming parameters in local
    // variables.
    this.rGen = rGen;
    this.genes = genes;

    //Subdivide the Frame into nine grid cells.
    setLayout(new GridLayout(3,3));

    //Create and display nine stages of growth
    // for a Biomorph object using the same genes
    // for each stage.  Specify the third
    // parameter value to be negative to prevent
    // the Biomorph constructor from mutating the
    // genes.
    for(int cnt = 0; cnt < 9; cnt++){
      Biomorph biomorph =
                        new Biomorph(genes,
                                     rGen,
                                     -1,
                                     genes[7]/8,
                                     66,
                                     66);
      //Cause the background colors of the
      // Biomorph objects to alternate between
      // yellow and green so that they will be
      // visually separable in the Frame.
      if(cnt%2 == 0){
        biomorph.setBackground(Color.YELLOW);
      }else{
        biomorph.setBackground(Color.GREEN);
      }//end else

      //Add the Biomorph object to the Frame in
      // the next grid cell.
      this.add(biomorph);

      //Increase the number of stages for the
      // next Biomorph object.
      genes[7] += 1;
    }//end for loop

    setTitle("Copyright 2004, R.G.Baldwin");
    setSize(400,400);
    setVisible(true);

    //Instantiate and register Listener object
    // that will terminate the program when the
    // user closes the Frame
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor

}//end class GUI definition
//=============================================//

//This class is used to instantiate a Biomorph
// object.  It is based loosely on Chapter 8 of
// the book entitled Windows Hothouse by Mark
// Clarkson.  However, the C++ algorithm
// presented in that book contains several
// serious typographical errors.  It was
// necessary for me to find and fix those errors
// when writing a Java version of the algorithm.
//The constructor receives an array of eight gene
// values. The final value in the array specifies
// the number of stages to be used to construct
// the Biomorph object.  The first stage produces
// a single stem.  Each successive stage causes
// all existing stems to bifurcate into two new
// stems.  Thus, the number of stems increases as
// a power of two based on the number of stages.
// For example, a Biomorph created with two
// stages contains three stems.  A three-stage
// Biomorph contains seven stems, a four-stage
// Biomorph contains fifteen stems, etc.
//When writing the Java version of the algorithm,
// I elected to maintain all of the data as type
// double in order to preserve arithmetic
// accuracy.  Values are converted from double to
// int at the very last step before displaying
// the Biomorph on the screen.
//The constructor receives a random number
// generator and a count value that are used to
// mutate a gene in the array of genes by a
// random value of plus or minus one whenever the
// count value is within the range from 0 to 7.
// If the count value is outside this range,
// there is no gene mutation.
//A method named getGenes returns the gene array
// containing the possibly mutated gene.  This is
// useful for experiments in selective breeding.
//The constructor receives a scale factor that is
// used to adjust the overall size of the plot to
// cause it to fit in the allocated plotting
// area.  Generally speaking, the size of the raw
// display of the Biomorph object would increase
// as the number of stages increases.  Therefore,
// it is useful to cause the scale factor to vary
// inversely with the number of stages.
//The constructor receives a pair of int values
// that are used to move the plotting origin
// from the default upper-left corner to another
// location in the plotting area.
//The direction of the first stem displayed for
// the Biomorph object is hard-coded to be
// vertical going up the screen, starting at the
// origin.
class Biomorph extends Panel{
  double[] xInc = new double[8];
  double[] yInc = new double[8];
  double[] genes;
  double xCoor = 0;//Start drawing here
  double yCoor = 0;//Start drawing here
  int direction = 0;//Initial drawing direction
  double length;
  double scale;
  int xOrigin;
  int yOrigin;

  //Constructor
  Biomorph(double[] genes,Random rGen,int cnt,
           double scale,int xOrigin,int yOrigin){

    //Save local copies of incoming parameters.
    this.genes = (double[])genes.clone();
    this.scale = scale;
    this.xOrigin = xOrigin;
    this.yOrigin = yOrigin;

    //Mutate gene at position cnt unless cnt is
    // out of the range from 0 through 7
    // inclusive.
    if((cnt>=0) && (cnt<=7)){
      double mutantValue = rGen.nextInt(2)*2-1;
      this.genes[cnt] += mutantValue;
      //Don't allow the eighth gene to go
      // negative
      if(this.genes[7] < 0)this.genes[7] = 0;
    }//end if

    //Compute incremental ends of lines based on
    // gene values.  Note that the C++ algorithm
    // presented in the Clarkson book appears to
    // contain several errors at this point.
    // Either that, or perhaps I don't fully
    // understand his version of the algorithm.
    xInc[0] =  0;
                        yInc[0] =  this.genes[0];
    xInc[1] =  this.genes[1];
                        yInc[1] =  this.genes[2];
    xInc[2] =  this.genes[3];
                        yInc[2] =  0;
    xInc[3] =  this.genes[4];
                        yInc[3] = -this.genes[5];
    xInc[4] =  0;
                        yInc[4] = -this.genes[6];
    xInc[5] = -this.genes[4];
                        yInc[5] = -this.genes[5];
    xInc[6] = -this.genes[3];
                        yInc[6] =  0;
    xInc[7] = -this.genes[1];
                        yInc[7] =  this.genes[2];


    //Initial line length is based on the number
    // of stages to be drawn.  Line length is
    // reduced by one as each successive stage is
    // drawn.  Algorithm terminates when length
    // reaches zero.
    length = this.genes[7];
  }//end constructor

  double[] getGenes(){
    return this.genes;
  }//end getGenes

  //Override the paint method
  public void paint(Graphics g){
    //Adjust location of the plotting origin
    g.translate(xOrigin,yOrigin);
    //Draw the Biomorph object recursively
    drawIt(g,xCoor,yCoor,length,direction,xInc,
                                     yInc,scale);
  }//end paint()
  //-------------------------------------------//

  void drawIt(Graphics g,double oldX,
              double oldY,double len,int newDir,
              double[] xInc,double[] yInc,
              double scale){
    //Direction values are limited to the range
    // from 0 to 7.
    newDir = (newDir + 8)%8;

    //Compute the end points of the line to be
    // drawn based ultimately on the values in
    // the gene array.
    double newX = oldX + len * xInc[newDir];
    double newY = oldY + len * yInc[newDir];

    //Draw the line.  Correct for the fact that
    // the default direction for positive y is
    // down the screen.
    g.drawLine((int)(oldX/scale),
               (int)(-oldY/scale),
               (int)(newX/scale),
               (int)(-newY/scale));

    //Continue drawing lines recursively until
    // the length of the next line reaches zero.
    // Decrease the length of the line by one for
    // each successive stage.  The values for
    // newX and newY become the incoming oldX and
    // oldY values for the next recursion.  Don't
    // waste time trying to draw a line with zero
    // length.
    if(len > 1){
      drawIt(g,newX,newY,len-1,newDir+1,xInc,
             yInc,scale);
      drawIt(g,newX,newY,len-1,newDir-1,xInc,
             yInc,scale);
    }//end if
  }//end drawIt

}//end class Biomorph
//=============================================//

Listing 32</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
/*File Biomorph03.java Copyright 2004,R.G.Baldwin
Revised 04/08/04

This program falls in the general category of
Artificial Life.  The program models
an experiment in the evolutionary concept of
artificial selection as opposed to natural
selection.  For example, the variety of plants,
animals, and birds that exist on on uninhabited
island represent natural selection, sometimes
referred to as survival of the fittest.

A dalmation dog, on the other hand, is probably
the result of artificial selection. In other
words, over a long period of time, people
selected certain dogs for breeding to accentuate
certain characteristics (such as black spots on a
white coat) and to suppress other characteristics
(such as a long red coat).  Over time, what
resulted was a type of dog that we know as the
dalmation dog.  Although those who did that may
not have known that those characteristics were
represented by genes that were accentuated or
suppressed through selective breeding, we know
(or at least believe) that to be the case now.

This program makes it possible for you to
selectively breed successive generations of
artificial creatures known as Biomorph objects.
A single parent in one generation produces eight
offspring in the next generation.

Each Biomorph object is a recursively branching
tree consisting of many limbs of different
lengths that branch off in different directions.
Each such Biomorph object has eight genes that
control the size,the number, and the angle of the
branches.

During the creation of each new generation, one
of the genes for each of the eight offspring is
randomly mutated to produce a creature that is
similar to, but different from its parent.  You
can select one of the offspring from each
generation to become the parent of the next
generation in order to accentuate certain
characteristics and to suppress other
characteristics.  By continuing this process
through a large number of generations, you can
cause the resulting Biomorph objects to resemble
birds, bugs, animals, airplanes,human faces, or
whatever strikes your fancy.

The parent for each generation is displayed as
the ninth Biomorph object.  If you don't like any
of the eight offspring of that parent, you can
select it again and cause it to produce eight
more offspring based on random mutations of the
genes.

This program is loosely based on Chapter 8 of the
book entitled Windows Hothouse by Mark Clarkson.
That chapter was based on a book and a paper
published by Richard Dawkins.  The book was
entitled The Blind Watchmaker.  The paper was
entitled The Evolution of Evolvability and
appeared in the book entitled Artificial Life.

Tested using J2SE 1.4.2 under WinXP.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Biomorph03 implements MouseListener{
  static double[] genes = new double[8];
  static GUI gui;
  static MouseListener listener;
  static Random rGen = new Random(
                           new Date().getTime());

  public static void main(String[] args){
    //An object of this class is a mouse listener
    listener = new Biomorph03();

    //Create initial set of genes.
    for(int cnt = 0; cnt < 7; cnt++){
      genes[cnt] = 1.0;
    }//end for

    //Establish the initial number of stages that
    // will be used to create the first
    // generation of Biomorph objects.  This
    // value, which is contained in the eighth
    // gene can increase or decrease due to
    // mutation of the genes.  If it goes to
    // zero, that Biomorph object will disappear.
    // It is not allowed to go negative.
    genes[7] = 5;

    //Instantiate a new GUI object.
    gui = new GUI(genes,listener,rGen);
  }//end main

  //Define a MouseEvent handler to handle mouse
  // clicks on Biomorph objects.  The mouse is
  // used to select one of nine Biomorph objects
  // to become the parent of the next generation.
  public void mouseClicked(MouseEvent e){
    //Identify the specific Biomorph object that
    // was selected with the mouse.  Get and save
    // the mutated gene array belonging to that
    // object.  This will be the gene array of
    // the parent of the next generation.
    Biomorph theMorph =
                       (Biomorph)(e.getSource());
    genes = theMorph.getGenes();

    //Dispose of the existing GUI object in
    // preparation for creating a new one.
    gui.dispose();

    //Instantiate a new GUI object based on the
    // mutated gene array obtained from the
    // Biomorph object that was selected.
    gui = new GUI(genes,listener,rGen);
  }//end mouseClicked

  //Define remaining methods of the MouseListener
  // interface as empty methods.
  public void mousePressed(MouseEvent e){};
  public void mouseReleased(MouseEvent e){};
  public void mouseEntered(MouseEvent e){};
  public void mouseExited(MouseEvent e){};

}//end class Biomorph03
//=============================================//

//The following class is used to instantiate a
// graphical user interface object that displays
// nine Biomorph objects in a 3x3 grid.
class GUI extends Frame{
  Random rGen;
  Biomorph[] morphs = new Biomorph[9];
  double[] genes;

  //Constructor
  public GUI(double[] genes,
             MouseListener listener,
             Random rGen){
    //Save incoming parameters.
    this.rGen = rGen;
    this.genes = genes;

    //Subdivide the GUI into nine grid cells of
    // equal size.
    setLayout(new GridLayout(3,3));

    //Instantiate nine Biomorph objects.  Add
    // them to the GUI.  They are placed in the
    // grid cells in the GUI from left to right,
    // top to bottom.
    //Register a mouse listener on each Biomorph
    // object.  Set the background color for each
    // Biomorph object to produce alternating
    // green and yellow backgrounds.
    for(int cnt = 0; cnt < 9; cnt++){
      //Instantiate and save a new Biomorph
      // object.  Set the origin to be the center
      // of the grid cell.
      morphs[cnt] = new Biomorph(genes,
                                 rGen,
                                 cnt,
                                 genes[7]/8,
                                 66,
                                 66);

      //Add this Biomorph object to the Frame in
      // the next grid cell.
      this.add(morphs[cnt]);

      //Register a mouse listener on the Biomorph
      // object.
      morphs[cnt].addMouseListener(listener);

      //Cause the background colors of the
      // Biomorph objects to alternate between
      // yellow and green so that they will be
      // visually separable in the Frame.
      if(cnt%2 == 0){
        morphs[cnt].setBackground(Color.YELLOW);
      }else{
        morphs[cnt].setBackground(Color.GREEN);
      }//end else
    }//end for loop

    //Finish the GUI and make it visible.
    setTitle("Copyright 2004, R.G.Baldwin");
    setSize(400,400);
    setVisible(true);

    //Instantiate and register a Listener object
    // that will terminate the program when the
    // user closes the Frame
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end WindowAdapter
    );//end addWindowListener
  }//end constructor

}//end class GUI definition
//=============================================//

//This class is used to instantiate a Biomorph
// object.  It is based loosely on Chapter 8 of
// the book entitled Windows Hothouse by Mark
// Clarkson.  However, the C++ algorithm
// presented in that book contains several
// serious typographical errors.  It was
// necessary for me to find and fix those errors
// when writing a Java version of the algorithm.
//The constructor receives an array of eight gene
// values. The final value in the array specifies
// the number of stages to be used to construct
// the Biomorph object.  The first stage produces
// a single stem.  Each successive stage causes
// all existing stems to bifurcate into two new
// stems.  Thus, the number of stems increases as
// a power of two based on the number of stages.
// For example, a Biomorph created with two
// stages contains three stems.  A three-stage
// Biomorph contains seven stems, a four-stage
// Biomorph contains fifteen stems, etc.
//When writing the Java version of the algorithm,
// I elected to maintain all of the data as type
// double in order to preserve arithmetic
// accuracy.  Values are converted from double to
// int at the very last step before displaying
// the Biomorph on the screen.
//The constructor receives a random number
// generator and a count value that are used to
// mutate a gene in the array of genes by a
// random value of plus or minus one whenever the
// count value is within the range from 0 to 7.
// If the count value is outside this range,
// there is no gene mutation.
//A method named getGenes returns the gene array
// containing the possibly mutated gene.  This is
// useful for experiments in selective breeding.
//The constructor receives a scale factor that is
// used to adjust the overall size of the plot to
// cause it to fit in the allocated plotting
// area.  Generally speaking, the size of the raw
// display of the Biomorph object would increase
// as the number of stages increases.  Therefore,
// it is useful to cause the scale factor to vary
// inversely with the number of stages.
//The constructor receives a pair of int values
// that are used to move the plotting origin
// from the default upper-left corner to another
// location in the plotting area.
//The direction of the first stem displayed for
// the Biomorph object is hard-coded to be
// vertical going up the screen, starting at the
// origin.
class Biomorph extends Panel{
  double[] xInc = new double[8];
  double[] yInc = new double[8];
  double[] genes;
  double xCoor = 0;//Start drawing here
  double yCoor = 0;//Start drawing here
  int direction = 0;//Initial drawing direction
  double length;
  double scale;
  int xOrigin;
  int yOrigin;

  //Constructor
  Biomorph(double[] genes,Random rGen,int cnt,
           double scale,int xOrigin,int yOrigin){

    //Save local copies of incoming parameters.
    this.genes = (double[])genes.clone();
    this.scale = scale;
    this.xOrigin = xOrigin;
    this.yOrigin = yOrigin;

    //Mutate gene at position cnt unless cnt is
    // out of the range from 0 through 7
    // inclusive.
    if((cnt>=0) && (cnt<=7)){
      double mutantValue = rGen.nextInt(2)*2-1;
      this.genes[cnt] += mutantValue;
      //Don't allow the eighth gene to go
      // negative
      if(this.genes[7] < 0)this.genes[7] = 0;
    }//end if

    //Compute incremental ends of lines based on
    // gene values.  Note that the C++ algorithm
    // presented in the Clarkson book appears to
    // contain several errors at this point.
    // Either that, or perhaps I don't fully
    // understand his version of the algorithm.
    xInc[0] =  0;
                        yInc[0] =  this.genes[0];
    xInc[1] =  this.genes[1];
                        yInc[1] =  this.genes[2];
    xInc[2] =  this.genes[3];
                        yInc[2] =  0;
    xInc[3] =  this.genes[4];
                        yInc[3] = -this.genes[5];
    xInc[4] =  0;
                        yInc[4] = -this.genes[6];
    xInc[5] = -this.genes[4];
                        yInc[5] = -this.genes[5];
    xInc[6] = -this.genes[3];
                        yInc[6] =  0;
    xInc[7] = -this.genes[1];
                        yInc[7] =  this.genes[2];


    //Initial line length is based on the number
    // of stages to be drawn.  Line length is
    // reduced by one as each successive stage is
    // drawn.  Algorithm terminates when length
    // reaches zero.
    length = this.genes[7];
  }//end constructor

  double[] getGenes(){
    return this.genes;
  }//end getGenes

  //Override the paint method
  public void paint(Graphics g){
    //Adjust location of the plotting origin
    g.translate(xOrigin,yOrigin);
    //Draw the Biomorph object recursively
    drawIt(g,xCoor,yCoor,length,direction,xInc,
                                     yInc,scale);
  }//end paint()
  //-------------------------------------------//

  void drawIt(Graphics g,double oldX,
              double oldY,double len,int newDir,
              double[] xInc,double[] yInc,
              double scale){
    //Direction values are limited to the range
    // from 0 to 7.
    newDir = (newDir + 8)%8;

    //Compute the end points of the line to be
    // drawn based ultimately on the values in
    // the gene array.
    double newX = oldX + len * xInc[newDir];
    double newY = oldY + len * yInc[newDir];

    //Draw the line.  Correct for the fact that
    // the default direction for positive y is
    // down the screen.
    g.drawLine((int)(oldX/scale),
               (int)(-oldY/scale),
               (int)(newX/scale),
               (int)(-newY/scale));

    //Continue drawing lines recursively until
    // the length of the next line reaches zero.
    // Decrease the length of the line by one for
    // each successive stage.  The values for
    // newX and newY become the incoming oldX and
    // oldY values for the next recursion.  Don't
    // waste time trying to draw a line with zero
    // length.
    if(len > 1){
      drawIt(g,newX,newY,len-1,newDir+1,xInc,
             yInc,scale);
      drawIt(g,newX,newY,len-1,newDir-1,xInc,
             yInc,scale);
    }//end if
  }//end drawIt

}//end class Biomorph
//=============================================//

Listing 33</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<br>
<p>
</p>
<hr size="3" width="100%" align="center">
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and XML. In addition to the many platform and/or language independent
benefits of Java and C# applications, he believes that a combination of
Java, C#, and XML will become the primary driving force in the delivery
of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects, and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com/">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology to real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- <br>
&nbsp;
<br>
</p>
</body>
</html>
