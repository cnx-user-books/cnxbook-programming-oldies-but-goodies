<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">Applying Affine Transforms to Picture Objects</h2>
<i>Learn how to scale, 
rotate, and translate Picture objects.</i><p><b>Published:</b>&nbsp; March 19, 
2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 358</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_so_far">What you have learned from 
		earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_sample_program_named_Java358a">The sample program named 
	Java358a</a><ul>
	<li><a href="#Applying_a_scaling_transform">Applying a scaling transform</a></li>
	<li><a href="#Applying_a_rotation_transform">Applying a rotation transform</a></li>
	<li><a href="#Applying_a_translation_transform">Applying a translation transform</a></li>
</ul>
	</li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_so_far">What you have learned from earlier 
lessons</a></h3>
<p dir="ltr"> If you have studied the <a href="#Resources">earlier lessons</a> in 
this series, you have learned about <b>Turtle</b> objects and their ability to move 
around in a world or a picture and to draw lines as they are moving.&nbsp; You 
have learned all about the <b>World</b> class and you are in the process of learning 
about the <b>Picture</b> class.</p>
<p> The class named <b>SimplePicture</b>, <i>(which is the superclass of the <b>
Picture</b> class)</i>, is a large and complex class that defines almost forty 
methods and several constructors.&nbsp; By learning about some of those 
constructors and methods, you have learned that objects of the <b>Picture</b> 
class are useful for much more than simply serving as living quarters for 
turtles.&nbsp; They are also useful for manipulating images in interesting and 
complex ways.</p>
<p> Near the end of the previous lesson, I told you that there remained thirteen 
methods and constructors of the <b>SimplePicture</b> class that were 
sufficiently interesting or complicated that you would do well to learn about 
them.</p>
<h3> <a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p> I will explain and illustrate the following three methods and one 
constructor from the <b>SimplePicture</b> class in this lesson:</p>
<ul>
	<li>Picture <b>scale</b>(double xFactor, double yFactor)</li>
	<li>Rectangle2D <b>getTransformEnclosingRect</b>(AffineTransform trans</li>
	<li>void <b>copyPicture</b>(SimplePicture sourcePicture)</li>
	<li><b>SimplePicture</b>(SimplePicture copyPicture)</li>
</ul>
<p> The first two methods in the above list involve the application of affine 
transforms to <b>Picture</b> objects.&nbsp; I will also develop and explain two 
additional methods that are patterned after the <b>scale</b> method that apply 
rotation and translation transforms to <b>Picture</b> objects.</p>
<p> <font color="#FF0000"><b>Source code listings</b></font></p>
<p> A complete listing of Ericson's <b>Picture</b> class is provided in 
Listing 22 and a listing of Ericson's <b>SimplePicture</b> class is provided in 
Listing 23.&nbsp; A listing of Ericson's <b>DigitalPicture</b> interface is provided 
in Listing 24.&nbsp; A listing of the main program that I will present and explain in 
this lesson is provided 
in Listing 25.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Before and after the use of the scale 
	method.</li>
	<li><a href="#Figure_2">Figure 2</a>. Before and after the use of the 
	rotatePicture method.</li>
	<li><a href="#Figure_3">Figure 3</a>. Before and after the use of the 
	translatePicture method.</li>
	<li><a href="#Figure_4">Figure 4</a>. Result of copying the rose picture 
	into the beach picture.</li>
	<li><a href="#Figure_5">Figure 5</a>. Result of copying the beach picture 
	into the rose picture.</li>
	<li><a href="#Figure_6">Figure 6</a>. Result of rotation without 
	translation. </li>
	<li><a href="#Figure_7">Figure 7</a>. Result of the wrong order of 
	concatenation. </li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Background color for the 
	SimplePicture class. </li>
	<li><a href="#Listing_2">Listing 2</a>. Background color for the program 
	named Java358a. </li>
	<li><a href="#Listing_3">Listing 3</a>. Beginning of the program named 
	Java358a. </li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the run method of the 
	Runner class. </li>
	<li><a href="#Listing_5">Listing 5</a>. Call the scale method on the Picture 
	object. </li>
	<li><a href="#Listing_6">Listing 6</a>. Beginning of the scale method of the 
	SimplePicture class. </li>
	<li><a href="#Listing_7">Listing 7</a>. Create a new Picture object of the 
	correct size. </li>
	<li><a href="#Listing_8">Listing 8</a>. Draw the current picture on the new 
	Picture object. </li>
	<li><a href="#Listing_9">Listing 9</a>. Make a copy of the original Picture 
	object. </li>
	<li><a href="#Listing_10">Listing 10</a>. The copyPicture method of the 
	SimplePicture class. </li>
	<li><a href="#Listing_11">Listing 11</a>. The program named Java358b.</li>
	<li><a href="#Listing_12">Listing 12</a>. Call the new rotatePicture method. </li>
	<li><a href="#Listing_13">Listing 13</a>. Beginning of the rotatePicture 
	method. </li>
	<li><a href="#Listing_14">Listing 14</a>. Get the required dimensions. </li>
	<li><a href="#Listing_15">Listing 15</a>. The getTransformEnclosingRect 
	method of the SimplePicture class.</li>
	<li><a href="#Listing_16">Listing 16</a>. Prepare a translation transform. </li>
	<li><a href="#Listing_17">Listing 17</a>. Create a concatenated 
	AffineTransform object. </li>
	<li><a href="#Listing_18">Listing 18</a>. Create a new picture and draw the 
	rotated picture in it. </li>
	<li><a href="#Listing_19">Listing 19</a>. Call the translatePicture method. </li>
	<li><a href="#Listing_20">Listing 20</a>. The translatePicture method. </li>
	<li><a href="#Listing_21">Listing 21</a>. An overloaded constructor of the 
	SimplePicture class. </li>
	<li><a href="#Listing_22">Listing 22</a>. Source code for Ericson's Picture 
	class.</li>
	<li><a href="#Listing_23.">Listing 23</a>. Source code for Ericson's 
	SimplePicture class.</li>
	<li><a href="#Listing_24">Listing 24</a>. Source code for Ericson's 
	DigitalPicture interface.</li>
	<li><a href="#Listing_25">Listing 25</a>. Source code for the program named 
	Java358a. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p dir="ltr">As I mentioned earlier, I will explain and illustrate the following 
three methods and one constructor from the <b>SimplePicture</b> class in 
<a name="this_lesson">this 
lesson</a>:</p>
<ul>
	<li>Picture <b>scale</b>(double xFactor, double yFactor)</li>
	<li>Rectangle2D <b>getTransformEnclosingRect</b>(AffineTransform trans</li>
	<li>void <b>copyPicture</b>(SimplePicture sourcePicture)</li>
	<li><b>SimplePicture</b>(SimplePicture copyPicture)</li>
</ul>
<p> The first two methods in the above list involve the application of affine 
transforms to <b>Picture</b> objects.&nbsp; I will also develop and explain two 
additional methods that are patterned after the <b>scale</b> method that apply 
rotation and translation transforms to <b>Picture</b> objects.</p>
<p dir="ltr"><font color="#FF0000"><b>A sample program</b></font></p>
<p dir="ltr">I will present and explain a sample 
program that illustrates the use of the four methods in the above 
<a href="#this_lesson">list</a> along 
with the two new affine-transform related methods that I have developed.</p>
<p dir="ltr"><font color="#FF0000"><b>A scale method</b></font></p>
<p dir="ltr">We 
often think of affine transforms as being useful for:</p>
<ul dir="ltr">
	<li dir="ltr">
	<p dir="ltr">scaling</p></li>
	<li dir="ltr">
	<p dir="ltr">translation</p></li>
	<li dir="ltr">
	<p dir="ltr">rotation</p></li>
</ul>
<p dir="ltr">The <b>SimplePicture</b> class defines a method that can be used to 
create a new <b>Picture</b> object that is a scaled version of an existing <b>
Picture</b> object.&nbsp;&nbsp; When the <b>show</b> method is called on the new
object, the scaled image is displayed in a <b>JFrame</b> object that is 
the correct size for the size of the new <b>Picture</b> object.</p>
<p dir="ltr">For 
example, the bottom image in Figure 1 shows a scaled version of the top image.&nbsp; 
In this case, the <b>Picture</b> object at the top was scaled by a factor of 0.5 
in both dimensions to produce the scaled P<b>icture </b> &nbsp; object shown at the bottom.</p>
<p>
 <b><a name="Figure_1">Figure 1</a>. Before and after the use of the scale 
	method.</b>
<table bgcolor="#ffffff"  border="1" cols="1" id="table8">
<tr><td><img border="0" src="java358a.jpg" width="350" height="285"></td></tr>
<tr><td><img border="0" src="java358b.jpg" width="179" height="157"></td></tr>
</table></p>




<p dir="ltr"><font color="#FF0000"><b>My new rotatePicture method</b></font></p>
<p dir="ltr">However, the <b>SimplePicture</b> class doesn't provide similar 
methods for translation and rotation.&nbsp; One of the new methods that I have 
developed makes it possible to create a new <b>Picture</b> object that contains 
a rotated version of an existing <b>Picture</b> object and correctly sizes the 
new object so that the entire rotated image will show in the picture.</p>
<p dir="ltr">For example, the bottom picture in Figure 2 shows the result of 
calling the new <b>rotatePicture</b> method to rotate the top picture in Figure 
2 clockwise by thirty degrees.&nbsp; <i>(Note that the new <b>rotatePicture</b> 
method always rotates the source picture around its center point.)</i></p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Before and after the use of the 
	rotatePicture method.</b>
<table bgcolor="#ffffff"  border="1" cols="1" id="table9">
<tr><td><img border="0" src="java358a.jpg" width="350" height="285"></td></tr>
<tr><td><img border="0" src="java358c.jpg" width="431" height="420"></td></tr>
</table></p>

<p dir="ltr"><font color="#FF0000"><b>My new translatePicture method</b></font></p>
<p dir="ltr">The other new method that I have developed makes it possible to 
create a new <b>Picture</b> object that contains a translated version of an 
existing <b>Picture</b> object and correctly sizes the new object so that the 
entire translated image will show in the picture.<i>&nbsp; (Only 
translations in positive horizontal and vertical directions are supported.)</i> </p>
<p dir="ltr">For example, the bottom picture in Figure 3 shows the result of 
calling the new <b>translatePicture</b> method to translate the top picture to 
the right by twenty pixels and down by thirty pixels.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Before and after the use of the 
	translatePicture method.</b>
<table bgcolor="#ffffff"  border="1" cols="1" id="table10">
<tr><td><img border="0" src="java358a.jpg" width="350" height="285"></td></tr>
<tr><td><img border="0" src="java358d.jpg" width="370" height="315"></td></tr>
</table></p>

<p dir="ltr"><font color="#FF0000"><b>Reducing the confusion</b></font></p>
<p dir="ltr">Because I 
will be switching back and forth between code fragments extracted from Ericson's
<b>SimplePicture</b> class and code fragments extracted from my sample program, 
things can get confusing.</p>
<p dir="ltr">In an attempt to reduce the confusion, I will 
present code fragments from Ericson's <b>SimplePicture</b> class against the 
background color shown in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Background color for the SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre>I will present code fragments from the SimplePicture class
against this background color.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Similarly, I will present code fragments from my sample program against the 
background color shown in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2.</a> Background color for the program named 
Java358a.</b><table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>I will present code fragments from my sample program
with this background color.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><span style="font-weight: 400"><a name="The_sample_program_named_Java358a">The sample program named Java358a</a></span></h3>
<p>The purpose of this program is to illustrate the use of the following methods 
of the <b>SimplePicture</b> class:</p>
<ul>
	<li>Picture <b>scale</b>(double xFactor, double yFactor)</li>
	<li>Rectangle2D <b>getTransformEnclosingRect</b>( AffineTransform trans)</li>
	<li>void <b>copyPicture</b>(SimplePicture sourcePicture)</li>
</ul>
<p>In addition, the program illustrates the use of the following constructor for 
the <b>SimplePicture</b> class:</p>
<p><b>SimplePicture</b>(SimplePicture copyPicture)</p>
<p><font color="#FF0000"><b>Two new affine-transform related methods</b></font></p>
<p>The program also defines two new methods named <b>rotatePicture</b> and <b>
translatePicture</b> that are patterned after the scale method of the <b>
SimplePicture</b> class.</p>
<p>I will describe the behavior of these two methods later when I explain them.</p>
<p><font color="#FF0000"><b>Behavior of the program</b></font></p>
<p>The program begins by creating and showing a <b>Picture</b> object based on a 
specified image file in the current directory.&nbsp; <i>(See the top picture in 
Figure 1.)</i></p>
<p>Then the program illustrates the use of the <b>scale</b> method of the <b>
SimplePicture</b> class, the new <b>rotatePicture</b> method that is defined in 
this program, and the new t<b>ranslatePicture </b> &nbsp; method that is also 
defined in this program.</p>
<p>The <b>Picture</b> object returned from the <b>scale</b> method is shown in 
the bottom picture of Figure 1.&nbsp; The <b>Picture</b> object returned by the <b>
rotatePicture</b> method is shown in the bottom picture of Figure 2, and the <b>
Picture</b> object returned by the <b>translatePicture</b> method is shown in 
the bottom picture of Figure 3.&nbsp; The original picture is shown in the top 
picture 
for comparison purposes in all three cases.</p>
<p><font color="#FF0000">
<b>Beginning of the program named Java358a</b></font></p>
<p>A complete listing of the program named Java358a is provided in Listing 25 
near the end of the lesson.&nbsp; I will explain the program in fragments.&nbsp; The program begins in 
the fragment shown in Listing 3.&nbsp;
<i>(Remember that the background color in Listing 3 indicates that the code 
fragment was extracted from my sample program named Java358a.)</i></p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of the program named Java358a. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff" id="table11">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 3 simply defines an object of a new class named <b>Runner</b> and 
calls the <b>run</b> method on that object.&nbsp; When the <b>run</b> method 
returns, the <b>main</b> method will terminate causing the program to terminate.</p>
<p><font color="#FF0000">
<b>Beginning of the run method of the Runner class</b></font></p>
<p>The beginning of the <b>run</b> method called in Listing 3 is shown in 
Listing 4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the run method of the Runner 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff" id="table12">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor. Note that the image file is
    // located in the current directory.
    Picture pixA = new Picture("ScaledBeach.jpg");
    pixA.setTitle("pixA");
    pixA.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You have seen code like this before, so no explanation beyond the embedded 
comments should be needed.</p>
<p>A reference to a new <b>Picture</b> object is stored in the reference variable named <b>
pixA</b>.&nbsp; The screen output produced by Listing 4 is shown in the upper 
part of Figure 1.</p>
<h4><a name="Applying_a_scaling_transform">Applying a scaling transform</a></h4>
<p>Listing 5 calls the <b>scale</b> method of the <b>SimplePicture</b> class to 
scale the size of the picture by a factor of 0.5 in both dimensions.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Call the scale method on the Picture 
object. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff" id="table13">
  <tbody>
    <tr>
      <td>
      <pre>
    Picture pixB = pixA.scale(0.5,0.5);
    pixB.setTitle("pixB");
    pixB.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>scale</b> method creates and returns a reference to a new <b>Picture</b> 
object that is a scaled replica of the<b> Picture</b> object on which the method 
is called.&nbsp; The reference to the new <b>Picture</b> object is saved in the reference variable 
named <b>pixB</b>.&nbsp; That reference is used to set a title on the new 
picture and to show it.&nbsp; The bottom picture in Figure 1 shows the scaled 
picture object.</p>
<p><font color="#FF0000">
<b>Beginning of the scale method of the SimplePicture class</b></font></p>
<p>Listing 6 shows the beginning of the <b>scale</b> method of the <b>
SimplePicture</b> class.&nbsp; <i>(Remember that the background color in Listing 
6 indicates that the code fragment was extracted from the SimplePicture class.)</i></p>
<p>
<b><a name="Listing_6">Listing 6</a>. Beginning of the scale method of the 
SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb" id="table14">
  <tbody>
    <tr>
      <td>
      <pre> /**
   * Method to create a new picture by scaling the
   * current picture by the given x and y factors
   * @param xFactor the amount to scale in x
   * @param yFactor the amount to scale in y
   * @return the resulting picture
   */
  public Picture scale(double xFactor, double yFactor){
    // set up the scale tranform
    AffineTransform scaleTransform =
                                    new AffineTransform();
    scaleTransform.scale(xFactor,yFactor);
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Affine transforms</b><br />
  See my earlier lessons titled <font size="3" face="arial"><i>Java 2D Graphics, 
	Simple Affine Transforms</i> and <i>Getting Started with the Turtle Class:&nbsp; 
	Multimedia Programming with Java</i> in <a href="#Resources">Resources</a> 
	for some background information on Affine transforms.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Create the scaling transform object</b></font></p>
<p>Listing 6 instantiates a new object of the <b>AffineTransform</b> class that 
will be used later to transform the picture when the image from the current <b>
Picture</b> object is copied to a new <b>Picture</b> object.</p>
<p><font color="#FF0000"><b>Prepare the Affine Transform object for scaling</b></font></p>
<p>At this point, the new <b>Affine Transform</b> object could be used for a 
variety of different kinds of transformations.&nbsp; Listing 6 calls the <b>scale</b> method 
of the <b>AffineTransform</b> class to prepare the transform to be used for 
scaling.&nbsp; <i>(Simply as a reminder, note that the <b>scale</b> method of 
the <b>AffineTransform</b> class is different from the <b>scale</b> method of 
the <b>SimplePicture</b> class.)</i></p>
<p><font color="#FF0000"><b>Scaling is the simplest of the transform types</b></font></p>
<p>While affine transforms can be somewhat difficult to understand, 
they aren't too difficult to use in Java.&nbsp; Of the three common uses of affine transforms, <i>(scaling, translation, and 
rotation)</i>, scaling is probably the easiest to understand.</p>
<p>Using the 
terminology for the parameters in Listing 6, when the affine transform referred 
to by <b>scaleTransform</b> is applied to an existing picture, the position of every point 
in the picture will be 
moved to the left or to the right, depending on whether <b>xFactor</b> is less 
than or greater than 1.0.&nbsp; In other words, the x-coordinate value for the 
point is multiplied by <b>xFactor</b>.&nbsp; <i>(If <b>xFactor</b> is 1.0, the 
point isn't moved.)</i></p>
<p>Similarly, when the scaling transform is applied to the picture, the position of every point will be moved up or down, depending on 
whether <b>yFactor</b> is less than or greater than 1.0.&nbsp; <i>(The 
y-coordinate value is multiplied by <b>yFactor</b>.)</i></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Mapping colors to screen pixels</b><br />
  S<font size="3" face="arial">ince the number of screen pixels per square inch 
	doesn't 
change as a result of scaling the picture, some&nbsp;&nbsp; of the pixels are discarded when 
the new smaller picture is rendered on the screen in Figure 1.&nbsp; If the 
	scale factor is greater than 1.0, the colors of some screen pixels are 
	duplicated in order to produce a larger picture.&nbsp; Scale factors greater 
	than 1.0 often produce a 
	result that is not very pleasing.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Scale the current picture by 0.5 in both dimensions</b></font></p>
<p>Listing 5 passes values of 0.5 in the call to the <b>scale</b> method for 
both scaling parameters.&nbsp; This causes every x-coordinate and every y-coordinate to be multiplied 
by 0.5 causing the bottom picture in Figure 1 to be half the size of the top 
picture.</p>
<p><font color="#FF0000"><b>Create a new Picture object of the correct size</b></font></p>
<p>While it would be possible for the <b>scale</b> method of the <b>Picture</b> 
class to simply modify the <b>Picture</b> object on which it is called <i>(the current 
picture)</i>, that isn't how the method was designed to behave.&nbsp; Instead, the <b>scale</b> method creates 
and returns a reference to a new <b>Picture</b> object, which is a scaled 
replica of the <b>current</b> Picture object.</p>
<p>Listing 7 creates a new, all-white <b>Picture</b> object that will become the 
scaled replica of the current picture once the image from the current picture is 
drawn on it.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Create a new Picture object of the correct 
size. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb" id="table15">
  <tbody>
    <tr>
      <td>
      <pre>
    Picture result = new Picture(
                           (int) (getWidth() * xFactor),
                           (int) (getHeight() * yFactor));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I explained the constructor used in Listing 7 in an earlier lesson in this 
series.</p>
<p><font color="#FF0000">
<b>Draw the current picture on the new Picture object</b></font></p>
<p>Listing 8 gets a reference to the <i>graphics context</i> of the new <b>
Picture</b> object as type <b>Graphics2D</b>.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Draw the current picture on the new 
Picture object. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb" id="table16">
  <tbody>
    <tr>
      <td>
      <pre>    // get the graphics 2d object to draw on the result
    Graphics graphics = result.getGraphics();
    Graphics2D g2 = (Graphics2D) graphics;

    // draw the current image onto the result image
    // scaled
    g2.drawImage(this.getImage(),scaleTransform,null);

    return result;
  }//end scale method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 8 extracts the image from the current <b>Picture</b> object and draws it 
on the new <b>Picture</b> object, applying the affine transform in the process.</p>
<p>Then Listing 8 returns a reference to the new <b>Picture</b> object, which is 
shown as the bottom picture in Figure 1.</p>
<h4><a name="Applying_a_rotation_transform">Applying a rotation transform</a></h4>
<p>Listing 9 begins by creating a new all-white <b>Picture</b> object that is 
the same size as the original <b>Picture</b> object, shown as the top picture in 
Listing 2.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Make a copy of the original Picture 
object. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff" id="table17">
  <tbody>
    <tr>
      <td>
      <pre>
    Picture pixC = new Picture(
                        pixA.getWidth(),pixA.getHeight());
    pixC.copyPicture(pixA);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 9 calls the <b>copyPicture</b> method of the <b>SimplePicture</b> 
class to copy the image from the original picture <i>(referred to by <b>pixA</b>)</i> 
into the new <b>Picture</b> object <i>(referred to by <b>pixC</b>)</i>.</p>
<p><font color="#FF0000">
<b>The copyPicture method of the SimplePicture class</b></font></p>
<p>The <b>copyPicture</b> method is shown in its entirety in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. The copyPicture method of the 
SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb" id="table18">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method that will copy all of the passed source
  * picture into the current picture object
  * @param sourcePicture  the picture object to copy
  */
 public void copyPicture(SimplePicture sourcePicture){
   Pixel sourcePixel = null;
   Pixel targetPixel = null;

   // loop through the columns
   for (int sourceX = 0, targetX = 0;
        sourceX &LT; sourcePicture.getWidth() &&
        targetX &LT; this.getWidth();
        sourceX++, targetX++)
   {
     // loop through the rows
     for (int sourceY = 0, targetY = 0;
          sourceY &LT; sourcePicture.getHeight() &&
          targetY &LT; this.getHeight();
          sourceY++, targetY++)
     {
       sourcePixel =
                  sourcePicture.getPixel(sourceX,sourceY);
       targetPixel = this.getPixel(targetX,targetY);
       targetPixel.setColor(sourcePixel.getColor());
     }//end inner loop
   }//end outer loop
 }//end copyPicture method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Copy pixels from one picture to another</b></font></p>
<p>Using the terminology from Listing 10, the <b>copyPicture</b> method copies all of the pixels in the <b>sourcePicture</b> into the 
picture on which the method is called <i>(the <b>current picture</b>)</i> by aligning 
the two pictures at their upper-left corners and then copying the pixels.</p>
<p><font color="#FF0000">
<b>The program named Java358b</b></font></p>
<p>Because all of the pictures used in the program named Java358a are the same 
size, that program doesn't provide a very good demonstration of the behavior of 
the <b>copyPicture</b> method.&nbsp; Therefore, I have provided very simple 
additional program named Java358b to demonstrate the behavior of the <b>copyPicture</b> method.</p>
<p>The program named Java358b is&nbsp;&nbsp;&nbsp; shown in its entirety in 
Listing 11.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. The program named Java358b.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table19">
  <tbody>
    <tr>
      <td>
      <pre>//Program Java358b
// Demonstrates the behavior of the copyPicture method.
import java.awt.*;
public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  void run(){
    Picture beach = new Picture("ScaledBeach.jpg");
    Picture rose = new Picture("rose.jpg");
    beach.copyPicture(rose);
//    rose.copyPicture(beach);
    beach.show();
    rose.show();
  }//end run method
}//end Runner class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two Picture objects of different sizes</b></font></p>
<p>This program creates two <b>Picture</b> objects and stores references to the 
two objects in the reference variables named <b>beach</b> and <b>rose</b>.&nbsp; 
The dimensions of the <b>beach</b> picture are larger than the 
dimensions of the <b>rose</b> picture.</p>
<p><font color="#FF0000"><b>Result of copying the rose picture into the beach 
picture</b></font></p>



<p>Then Listing 11 calls the <b>copyPicture</b> method of the <b>SimplePicture</b> 
class to copy the picture of the rose into the picture of the beach.&nbsp; The 
result is shown in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Result of copying the rose picture into 
	the beach picture.</b>
<table bgcolor="#ffffff"  border="1" cols="1">
<tr><td><img border="0" src="java358e.jpg" width="329" height="269"></td></tr>
<tr><td><img border="0" src="java358f.jpg" width="350" height="285"></td></tr>
</table></p>

<p><font color="#FF0000"><b>The sourcePicture and the current picture</b></font></p>
<p>Using the terminology from Listing 10, the <b>sourcePicture</b> in Listing 11 
is the picture of the rose and the <b>current picture</b> is the picture of the 
beach.</p>
<p>As you can see in the bottom picture in Figure 4, the smaller picture of the rose is aligned with 
the upper-left corner of the larger picture of the beach.&nbsp; All of the 
pixels belonging to the picture of the beach that overlap the picture of the 
rose are replaced by pixels from the picture of the rose.&nbsp; However, the 
pixels from the beach picture that are outside the dimensions of the 
rose picture remain unchanged.</p>
<p><font color="#FF0000"><b>Result of copying the beach picture into the rose 
picture</b></font></p>
<p>Note that the call to the <b>copyPicture</b> method is Listing 
11 is followed immediately by a comment that contains another call to the <b>
copyPicture</b> method.&nbsp; If the first call to the <b>copyPicture</b> 
method in Listing 11 is disabled and the comment that follows is enabled as a 
statement, the 
picture of the beach becomes the <b>sourcePicture</b> and the picture of the 
rose becomes the<b> current picture</b>.&nbsp; When this version of the program 
is compiled and executed, it produces the two output pictures shown in Figure 5.</p>



<p>
 <b><a name="Figure_5">Figure 5</a>. Result of copying the beach picture into 
	the rose picture.</b>
<table bgcolor="#ffffff"  border="1" cols="1">
<tr><td><img border="0" src="java358g.jpg" width="350" height="285"></td></tr>
<tr><td><img border="0" src="java358h.jpg" width="329" height="269"></td></tr>
</table></p>

<p><b><font color="#FF0000">Beach picture replaces all pixels in the rose 
picture</font></b></p>
<p>In this case, the picture of the beach is the larger of the two pictures.&nbsp; 
However, the size of the rose picture is not changed.&nbsp; Therefore, 
pixels from the beach picture replace all of the pixels in the rose picture 
causing the bottom picture in Figure 5 to simply be a picture of a smaller 
area of the beach.&nbsp; Once again, the two pictures were aligned at their 
upper-left corner before the copy operation was performed.</p>
<p><font color="#FF0000"><b>Getting back to the source code for copyPicture...</b></font></p>
<p>Getting back to the source code for the <b>copyPicture</b> method in Listing 10, 
and knowing what you now know, you should have no difficulty understanding how 
the code in Listing 10 produces the behavior described above.</p>
<p><font color="#FF0000"><b>Getting back to the program named Java358a...</b></font></p>
<p>You should also have no difficulty understanding that the code in Listing 9 
causes the <b>Picture</b> object referred to by <b>pixC</b> to be an exact 
replica of the original <b>Picture</b> object referred to by <b>pixA</b>, which 
is shown by the top picture in Figure 2.</p>
<p><font color="#FF0000">
<b>Call the new rotatePicture method</b></font></p>




<p>Listing 12 calls the new <b>rotatePicture</b> method to create and return a 
new <b>Picture</b> object that contains the image from <b>pixC</b> rotated by 
30-degrees clockwise around its center and translated to the center of the new
<b>Picture</b> object.&nbsp; <i>(In this case, the reference to the rotated 
picture is stored in the reference variable named <b>pixC</b></i> replacing the 
reference to the non-rotated version of <b>pixC</b><i>.)</i></p>
<p>
<b><a name="Listing_12">Listing 12</a>. Call the new rotatePicture method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>
    pixC = rotatePicture(pixC,30.0);
    pixC.setTitle(&quot;pixC&quot;);
    pixC.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 12 also sets a title on and displays the rotated picture, producing 
the screen output shown in the bottom picture of Figure 2.</p>
<p><font color="#FF0000"><b>The size of the new Picture object</b></font></p>
<p>As you can see in Figure 2, the size of the new <b>Picture</b> object is such 
that each corner of the rotated picture almost touches the edge of the new 
picture just inside the border of the <b>JFrame</b>.&nbsp; <i>(See the earlier 
lesson titled The show Method and the PictureFrame Class:&nbsp; Multimedia 
Programming with Java, in <a href="#Resources">Resources</a> for information 
regarding the part that the <b>JFrame</b> object plays in Figure 2.)</i></p>




<p><font color="#FF0000">
<b>Beginning of the rotatePicture method</b></font></p>
<p>Recall that the <b>rotatePicture</b> method is not defined in the <b>
SimplePicture</b> class.&nbsp; Instead, this is a method that I have developed 
and patterned after the <b>scale</b> method of the <b>SimplePicture</b> class.&nbsp; 
Therefore, I will put the explanation of the <b>run</b> method in Listing 12 on 
the back burner while I explain the method named <b>rotatePicture</b>, which 
begins in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Beginning of the rotatePicture method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>
  public Picture rotatePicture(Picture pix,double angle){

    //Set up the rotation transform
    AffineTransform rotateTransform =
                                    new AffineTransform();
    rotateTransform.rotate(Math.toRadians(angle),
                           pix.getWidth()/2,
                           pix.getHeight()/2);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>rotatePicture </b>method accepts a reference to a <b>Picture</b> 
object, along with a rotation angle in degrees.&nbsp; It creates and returns a 
new <b>Picture</b> object that is of the correct size to contain and display the 
incoming picture after it has been rotated around its center by the specified 
rotation angle and translated to the center of the new Picture object.</p>
<p><font color="#FF0000"><b>A new AffineTransform object</b></font></p>
<p>Listing 13 begins by creating a new <b>AffineTransform</b> object.&nbsp; As 
mentioned earlier in conjunction with Listing 6, the transform object could be 
used to perform a variety of different types of transformations at this point.</p>
<p><font color="#FF0000"><b>Prepare for rotation</b></font></p>
<p>Then Listing 13 calls one of the overloaded <b>rotate</b> methods of the <b>
AffineTransform</b> class to prepare the transform to be used to rotate a 
picture around a specified anchor point.</p>
<p>This version of the <b>rotate</b> method requires three parameters that 
define the angle of rotation in radians along with the horizontal and vertical 
coordinates of the point in the picture <i>(anchor point)</i> around which the 
picture will be rotated.&nbsp; Listing 13 specifies the anchor point to be 
located at the center of the picture.</p>
<p><font color="#FF0000"><b>Get the required dimensions</b></font></p>
<p>As you can see in Figure 2, the required dimensions of the picture that will 
contain the rotated picture will always be different from the dimensions of the 
original picture <i>(unless the rotation angle is zero degrees or is ninety degrees 
for square pictures)</i>.</p>
<p>Listing 14 calls the <b>getTransformEnclosingRect</b> method of the <b>
SimplePicture</b> class to get a reference to an object of the <b>Rectangle2D</b> 
class that is of the correct size to contain the rotated picture.&nbsp; Then 
Listing 14 calls the <b>getWidth</b> and <b>getHeight</b> methods on the 
rectangle to get and save the dimensions of the rectangle.&nbsp; These 
dimensions will be used later to create a new <b>Picture</b> object having the 
same dimensions.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Get the required dimensions. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>

    //Get the required dimensions of a rectangle that will
    // contain the rotated image.
    Rectangle2D rectangle2D =
           pix.getTransformEnclosingRect(rotateTransform);
    int resultWidth = (int)(rectangle2D.getWidth());
    int resultHeight = (int)(rectangle2D.getHeight());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The getTransformEnclosingRect method of the 
SimplePicture class</b></font></p>
<p>This method receives a reference to an <b>AffineTransform</b> object and 
returns a reference to a <b>Rectangle2D</b> object of sufficient size to contain 
the picture resulting from the application of the transform to the picture on 
which the method is called.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. The getTransformEnclosingRect method of the 
SimplePicture class.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb"     >
  <tbody>
    <tr>
      <td>
      <pre>  /**
   * Method to get the coordinates of the enclosing
   * rectangle after this transformation is applied to
   * the current picture
   * @return the enclosing rectangle
   */
  public Rectangle2D getTransformEnclosingRect(
                                   AffineTransform trans){
    int width = getWidth();
    int height = getHeight();
    double maxX = width - 1;
    double maxY = height - 1;
    double minX, minY;
    Point2D.Double p1 = new Point2D.Double(0,0);
    Point2D.Double p2 = new Point2D.Double(maxX,0);
    Point2D.Double p3 = new Point2D.Double(maxX,maxY);
    Point2D.Double p4 = new Point2D.Double(0,maxY);
    Point2D.Double result = new Point2D.Double(0,0);
    Rectangle2D.Double rect = null;

    // get the new points and min x and y and max x and y
    trans.deltaTransform(p1,result);
    minX = result.getX();
    maxX = result.getX();
    minY = result.getY();
    maxY = result.getY();
    trans.deltaTransform(p2,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p3,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p4,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());

    // create the bounding rectangle to return
    rect = new Rectangle2D.Double(
              minX,minY,maxX - minX + 1, maxY - minY + 1);
    return rect;
  }//end getTransformEnclosingRect method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Will leave as an exercise for the student</b></font></p>
<p>The
<b>getTransformEnclosingRect</b> method is long and complex, making heavy use of 
the <b>deltaTransform</b> method of the <b>AffineTransform</b> class.&nbsp; I am 
going to leave it as an exercise for the student to study the <b>AffineTransform</b> 
class in sufficient detail to understand how this method is able to determine 
the required size of the enclosing rectangle.</p>
<p><font color="#FF0000">
 <b>Result of rotation without translation</b></font></p>
<p>Simply rotating the picture around its center won't get the job done.&nbsp; 
If I were to take that approach without also translating the picture to the 
center of the new <b>Picture</b> object, the result would be as shown in Figure 6.&nbsp; <i>(Compare 
Figure 6 with the bottom picture in Figure 2.)</i></p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Result of rotation without translation. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table6" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java358i.jpg" width="431" height="420"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Therefore, in order to do the job correctly, it is also necessary to 
translate the picture an appropriate distance to the right and an appropriate 
distance down the screen to center it in the new <b>Picture</b> object.</p>
<p><font color="#FF0000">
<b>Prepare a translation transform</b></font></p>
<p>Listing 16 begins by creating a new <b>AffineTransform</b> object.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Prepare a translation transform. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>    //Set up the translation transform that will translate
    // the rotated image to the center of the new Picture
    // object.
    AffineTransform translateTransform =
                                    new AffineTransform();
    translateTransform.translate(
                      (resultWidth - pix.getWidth())/2,
                      (resultHeight - pix.getHeight())/2);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 16 calls the <b>translate</b> method of the <b>AffineTransform</b> 
class on the transform object to prepare it for use in translating the picture.</p>
<p>The <b>translate</b> method requires two incoming parameters that specify the 
horizontal and vertical translation distances.&nbsp; In this case, the correct 
translation distances are computed using the width and the height of the picture 
along with the <b>resultWidth</b> and <b>resultHeight</b> values 
computed in Listing 14.</p>
<p><font color="#FF0000"><b>Create a concatenated AffineTransform object</b></font></p>
<p>This is where things get really interesting.&nbsp; One way to accomplish the 
desired result would be to first apply the rotation transform to the current 
picture and then to apply the translation transform to the rotated picture.&nbsp; 
However, that isn't the best way.</p>
<p>It is a characteristic of affine transforms that exactly the same result can 
be obtained by first <i>concatenating</i> the two transforms and then applying 
the resulting single <b>AffineTransform</b> to the picture.&nbsp; The combined 
transform object that I will apply to the picture is created in Listing 17.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Create a concatenated AffineTransform 
object. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>
    translateTransform.concatenate(rotateTransform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 17 calls the <b>concatenate</b> method of the <b>AffineTransform</b> 
class to produce a new transform object in which the picture will first be 
rotated around its center and then translated to the center of the new <b>
Picture</b> object.</p>
<p><font color="#FF0000">
 <b>Result of the wrong order of concatenation</b></font></p>
<p>As simple as this sounds, it is very easy to get it wrong.&nbsp; The ability 
to get the correct 
results depends on getting the order of concatenation correct.&nbsp; For example, 
Figure 7 shows the result of concatenating the two transforms in the wrong order.&nbsp; <i>(This result was produced by reversing the order 
of <b>
translateTransform</b> and <b>rotateTransform</b> in Listing 17 and later 
applying <b>rotateTransform</b> to the picture in place of <b>translateTransform</b>.)</i></p>
<p>If you compare Figure 7 with Figure 2, you should be able to see why it 
isn't correct.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Result of the wrong order of concatenation. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table7" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java358j.jpg" width="431" height="420"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create a new picture and draw the rotated picture in it</b></font></p>
<p>Listing 18 begins by creating a new all-white <b>Picture</b> object of the 
correct size as determined by the code in Listing 14.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Create a new picture and draw the 
rotated picture in it. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>    //Create a new Picture object to contain the results
    // of the transformation.
    Picture result = new Picture(
                                resultWidth,resultHeight);

    //Get the graphics context of the new Picture object,
    // apply the transform to the incoming picture and
    // draw the transformed picture on the new Picture
    // object.
    Graphics2D g2 = (Graphics2D)result.getGraphics();
    g2.drawImage(pix.getImage(),translateTransform,null);

    return result;
  }//end rotatePicture</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 18 draws the image from the current picture into the new <b>
Picture</b> object, applying the combined transform object in the process.&nbsp; 
It returns a reference to the new rotated and translated <b>Picture</b> object.&nbsp; 
This produces the picture shown in the bottom of Figure 2.</p>
<p><font color="#FF0000"><b>Rotation is the most complicated</b></font></p>
<p>As you may have concluded, the use of an <b>AffineTransform</b> object to rotate a 
picture is much more complex than simply scaling a picture, particularly when 
translation is also involved.&nbsp; In that case, the correct order of rotation and 
translation is critical.</p>
<h4><a name="Applying_a_translation_transform">Applying a translation transform</a></h4>
<p>Returning now to the <b>run</b> method, Listing 19 calls the <b>translatePicture</b> method to create and return a new 
<b>Picture</b> object that contains the image from <b>pixA</b> translated by 20 pixels in 
the x-dimension and 30 pixels in the y-dimension</p>
<p>The size of the new <b>Picture</b> 
object is such that there is whitespace above and to the left of the translated 
image <i>(as shown by the bottom picture in Figure 3)</i> where the amount of whitespace equals the space that was vacated by 
translating the image to the right and down.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Call the translatePicture method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
      <pre>
    Picture pixD = translatePicture(pixA,20,30);
    pixD.setTitle("pixD");
    pixD.show();

  }//end run method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 19 sets a title and displays the new translated picture as shown 
by the bottom picture in Figure 3.</p>
<p><font color="#FF0000">
<b>The translatePicture method</b></font></p>
<p>The <b>translatePicture</b> method, shown in its entirety in Listing 20, 
receives a reference to a <b>Picture</b> object along with positive x and y 
translation values.&nbsp; <i>(The method does not support translation in 
negative directions.&nbsp; If either translation value 
is negative, the method simply returns a reference to a copy of the original 
picture.)</i></p>
<p>The <b>translatePicture</b> method creates and returns a new <b>Picture</b> 
object that contains a translated version of the received picture with 
whitespace to the left of and/or above the translated image.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. The translatePicture method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff"     >
  <tbody>
    <tr>
      <td>
<pre>
  public Picture translatePicture(
                         Picture pix,double tx,double ty){
    if((tx &lt; 0.0) || (ty &lt; 0.0)){
      //Negative translation values are not supported.
      // Simply return a reference to a copy of the
      // incoming picture. Note that this constructor
      // creates a new picture by copying the image from
      // an existing picture.
      return new Picture(pix);
    }//end if

    //Set up the tranform
    AffineTransform translateTransform =
                                    new AffineTransform();
    translateTransform.translate(tx,ty);

    //Compute the size of a rectangle that is of
    // sufficient size to contain and display the
    // translated image.
    int pixWidth = pix.getWidth() + (int)tx;
    int pixHeight = pix.getHeight() + (int)ty;

    //Create a new picture object that is the correct
    // size.
    Picture result = new Picture(pixWidth,pixHeight);

    //Get the graphics2D object to draw on the result.
    Graphics2D g2 = (Graphics2D)result.getGraphics();

    //Draw the translated image from pix onto the new
    // Picture object, applying the transform in the
    // process.
    g2.drawImage(pix.getImage(),translateTransform,null);

    return result;
  }//end translatePicture
  //----------------------------------------------------//

}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Only the constructor is new</b></font></p>
<p>The only code in Listing 20 that is significantly different from code that I 
have explained before is the call to the <b>Picture</b> constructor passing a 
reference to a <b>Picture</b> object as a parameter.&nbsp; This constructor 
creates a new <b>Picture</b> object that is a replica of the <b>Picture</b> 
object received as a parameter.</p>
<p><font color="#FF0000">
<b>An overloaded constructor of the SimplePicture class</b></font></p>
<p>This overloaded constructor for the <b>Picture</b> class is shown in Listing 
21.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. An overloaded constructor of the 
SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb"     >
  <tbody>
    <tr>
      <td>
      <pre> /**
  * A Constructor that takes a picture to copy
  * information from
  * @param copyPicture the picture to copy from
  */
 public SimplePicture(SimplePicture copyPicture){
   if (copyPicture.fileName != null){
      this.fileName = new String(copyPicture.fileName);
      this.extension = copyPicture.extension;
   }//end if
   if (copyPicture.title != null)
      this.title = new String(copyPicture.title);
   if (copyPicture.bufferedImage != null){
     this.bufferedImage =
                 new BufferedImage(copyPicture.getWidth(),
                                  copyPicture.getHeight(),
                              BufferedImage.TYPE_INT_RGB);
     this.copyPicture(copyPicture);
   }//end if
 }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>All of the code in Listing 21 is similar to code that I have previously 
explained.&nbsp; Therefore, no further explanation of Listing 21 should be 
required.</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p>Listing 19 signals the end of the <b>run</b> method.&nbsp; Listing 20 signals 
the end of the <b>Runner</b> class, which in turn signals the end of the 
program.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 25, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, you learned how to use three different methods, which in turn use affine 
transforms, to <i>scale</i>, <i>rotate</i>, and <i>translate</i> <b>Picture</b> objects.</p>
<p>I explained and illustrated the following three methods and one overloaded constructor 
from the <b>SimplePicture</b> class in this lesson:</p>
<ul>
	<li>Picture <b>scale</b>(double xFactor, double yFactor)</li>
	<li>Rectangle2D <b>getTransformEnclosingRect</b>(AffineTransform trans</li>
	<li>void <b>copyPicture</b>(SimplePicture sourcePicture)</li>
	<li><b>SimplePicture</b>(SimplePicture copyPicture)</li>
</ul>
<p>The first two methods in the above list involve the application of affine 
transforms to <b>Picture</b> objects.</p>
<p>I also developed and explained two additional methods that are patterned 
after the <b>scale</b> method.&nbsp; These two methods apply rotation and 
translation transforms to <b>Picture</b> 
objects.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, I will complete my explanation of the <b>SimplePicture</b> 
class by explaining and illustrating the following six methods:</p>
<ul>
	<li>Picture <b>getPictureWithHeight</b>(int height)</li>
	<li>Picture <b>getPictureWithWidth</b>(int width)</li>
	<li>Pixel[] <b>getPixels</b>()</li>
	<li>void <b>addMessage</b>(String message, int xPos, int yPos)</li>
	<li>void <b>drawString</b>(String text, int xPos, int yPos)</li>
	<li>boolean <b>loadPictureAndShowIt</b>(String fileName)</li>
</ul>
<p>You will learn how to cause two or more pictures to have the same width or the same 
height and otherwise maintain their individual aspect ratios, how to create 
composite pictures containing side-by-side images, how to draw text on a 
picture, and how to apply the same operation to every pixel in a <b>Picture</b> 
object.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java355.htm">355</a> The HSB Color Model</li>
	<li><a href="http://www.dickbaldwin.com/java/Java356.htm">356</a> The show Method and the PictureFrame Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java357.htm">357</a> An HSB 
	Color-Editing Program for Digital Photos</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 22 through Listing 25 below.
<p>
<b><a name="Listing_22">Listing 22</a>. Source code for Ericson's Picture class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.text.*;

/**
 * A class that represents a picture.  This class inherits
 * from SimplePicture and allows the student to add 
 * functionality to the Picture class.
 *
 * Copyright Georgia Institute of Technology 2004-2005
 * @author Barbara Ericson ericson@cc.gatech.edu
 */
public class Picture extends SimplePicture
{
  ///////////////////// constructors /////////////////////

  /**
   * Constructor that takes no arguments
   */
  public Picture ()
  {
    /* not needed but use it to show students the implicit
     * call to super()
     * child constructors always call a parent constructor
     */
    super();
  }

  /**
   * Constructor that takes a file name and creates the 
   * picture
   * @param fileName the name of the file to create the 
   * picture from
   */
  public Picture(String fileName)
  {
    // let the parent class handle this fileName
    super(fileName);
  }

  /**
   * Constructor that takes the width and height
   * @param width the width of the desired picture
   * @param height the height of the desired picture
   */
  public Picture(int width, int height)
  {
    // let the parent class handle this width and height
    super(width,height);
  }

  /**
   * Constructor that takes a picture and creates a
   * copy of that picture
   */
  public Picture(Picture copyPicture)
  {
    // let the parent class do the copy
    super(copyPicture);
  }

  /**
   * Constructor that takes a buffered image
   * @param image the buffered image to use
   */
  public Picture(BufferedImage image)
  {
    super(image);
  }

  ////////////////////// methods /////////////////////////

  /**
   * Method to return a string with information about this
   * picture.
   * @return a string with information about the picture 
   * such as fileName, height and width.
   */
  public String toString()
  {
    String output = 
      "Picture, filename " + getFileName() +
      " height " + getHeight()
      + " width " + getWidth();
    return output;

  }

} // this } is the end of class Picture, put all new 
  // methods before this</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_23.">Listing 23.</a> Source code for Ericson's SimplePicture class.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre>import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import java.awt.*;
import java.io.*;
import java.awt.geom.*;

/**
 * A class that represents a simple picture.  A simple
 * picture may have an associated file name and a title.
 * A simple picture has pixels, width, and height.  A
 * simple picture uses a BufferedImage to hold the pixels.
 * You can show a simple picture in a PictureFrame (a
 * JFrame).
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class SimplePicture implements DigitalPicture
{

  /////////////////////// Fields /////////////////////////

  /**
   * the file name associated with the simple picture
   */
  private String fileName;

  /**
   * the title of the simple picture
   */
  private String title;

  /**
   * buffered image to hold pixels for the simple picture
   */
  private BufferedImage bufferedImage;

  /**
   * frame used to display the simple picture
   */
  private PictureFrame pictureFrame;

  /**
   * extension for this file (jpg or bmp)
   */
  private String extension;


 /////////////////////// Constructors ////////////////////

 /**
  * A Constructor that takes no arguments.  All fields
  * will be null. A no-argument constructor must be given
  * in order for a class to be able to be subclassed.  By
  * default all subclasses will implicitly call this in
  * their parent's no argument constructor unless a
  * different call to super() is explicitly made as the
  * first line of code in a constructor.
  */
 public SimplePicture()
 {this(200,100);}

 /**
  * A Constructor that takes a file name and uses the
  * file to create a picture
  * @param fileName the file name to use in creating the
  * picture
  */
 public SimplePicture(String fileName)
 {

   // load the picture into the buffered image
   load(fileName);

 }

 /**
  * A constructor that takes the width and height desired
  * for a picture and creates a buffered image of that
  * size.  This constructor doesn't  show the picture.
  * @param width the desired width
  * @param height the desired height
  */
 public  SimplePicture(int width, int height)
 {
   bufferedImage = new BufferedImage(
               width, height, BufferedImage.TYPE_INT_RGB);
   title = "None";
   fileName = "None";
   extension = "jpg";
   setAllPixelsToAColor(Color.white);
 }

 /**
  * A constructor that takes the width and height desired
  * for a picture and creates a buffered image of that
  * size.  It also takes the color to use for the
  * background of the picture.
  * @param width the desired width
  * @param height the desired height
  * @param theColor the background color for the picture
  */
 public  SimplePicture(
                    int width, int height, Color theColor)
 {
   this(width,height);
   setAllPixelsToAColor(theColor);
 }

 /**
  * A Constructor that takes a picture to copy
  * information from
  * @param copyPicture the picture to copy from
  */
 public SimplePicture(SimplePicture copyPicture)
 {
   if (copyPicture.fileName != null)
   {
      this.fileName = new String(copyPicture.fileName);
      this.extension = copyPicture.extension;
   }
   if (copyPicture.title != null)
      this.title = new String(copyPicture.title);
   if (copyPicture.bufferedImage != null)
   {
     this.bufferedImage =
                 new BufferedImage(copyPicture.getWidth(),
                                  copyPicture.getHeight(),
                              BufferedImage.TYPE_INT_RGB);
     this.copyPicture(copyPicture);
   }
 }

 /**
  * A constructor that takes a buffered image
  * @param image the buffered image
  */
 public SimplePicture(BufferedImage image)
 {
   this.bufferedImage = image;
   title = "None";
   fileName = "None";
   extension = "jpg";
 }

 ////////////////////////// Methods //////////////////////

 /**
  * Method to get the extension for this picture
  * @return the extendsion (jpg or bmp)
  */
 public String getExtension() { return extension; }


 /**
  * Method that will copy all of the passed source
  * picture into the current picture object
  * @param sourcePicture  the picture object to copy
  */
 public void copyPicture(SimplePicture sourcePicture)
 {
   Pixel sourcePixel = null;
   Pixel targetPixel = null;

   // loop through the columns
   for (int sourceX = 0, targetX = 0;
        sourceX &LT; sourcePicture.getWidth() &&
        targetX &LT; this.getWidth();
        sourceX++, targetX++)
   {
     // loop through the rows
     for (int sourceY = 0, targetY = 0;
          sourceY &LT; sourcePicture.getHeight() &&
          targetY &LT; this.getHeight();
          sourceY++, targetY++)
     {
       sourcePixel =
                  sourcePicture.getPixel(sourceX,sourceY);
       targetPixel = this.getPixel(targetX,targetY);
       targetPixel.setColor(sourcePixel.getColor());
     }
   }

 }

 /**
  * Method to set the color in the picture to the passed
  * color
  * @param color the color to set to
  */
 public void setAllPixelsToAColor(Color color)
 {
   // loop through all x
   for (int x = 0; x &LT; this.getWidth(); x++)
   {
     // loop through all y
     for (int y = 0; y &LT; this.getHeight(); y++)
     {
       getPixel(x,y).setColor(color);
     }
   }
 }

 /**
  * Method to get the buffered image
  * @return the buffered image
  */
 public BufferedImage getBufferedImage()
 {
    return bufferedImage;
 }

 /**
  * Method to get a graphics object for this picture to
  * use to draw on
  * @return a graphics object to use for drawing
  */
 public Graphics getGraphics()
 {
   return bufferedImage.getGraphics();
 }

 /**
  * Method to get a Graphics2D object for this picture
  * which can be used to do 2D drawing on the picture
  */
 public Graphics2D createGraphics()
 {
   return bufferedImage.createGraphics();
 }

 /**
  * Method to get the file name associated with the
  * picture
  * @return  the file name associated with the picture
  */
 public String getFileName() { return fileName; }

 /**
  * Method to set the file name
  * @param name the full pathname of the file
  */
 public void setFileName(String name)
 {
   fileName = name;
 }

 /**
  * Method to get the title of the picture
  * @return the title of the picture
  */
 public String getTitle()
 { return title; }

 /**
  * Method to set the title for the picture
  * @param title the title to use for the picture
  */
 public void setTitle(String title)
 {
   this.title = title;
   if (pictureFrame != null)
       pictureFrame.setTitle(title);
 }

 /**
  * Method to get the width of the picture in pixels
  * @return the width of the picture in pixels
  */
 public int getWidth(){ return bufferedImage.getWidth(); }

 /**
  * Method to get the height of the picture in pixels
  * @return  the height of the picture in pixels
  */
 public int getHeight(){
  return bufferedImage.getHeight();
 }

 /**
  * Method to get the picture frame for the picture
  * @return the picture frame associated with this
  * picture (it may be null)
  */
 public PictureFrame getPictureFrame()
                                  { return pictureFrame; }

 /**
  * Method to set the picture frame for this picture
  * @param pictureFrame the picture frame to use
  */
 public void setPictureFrame(PictureFrame pictureFrame)
 {
   // set this picture objects' picture frame to the
   // passed one
   this.pictureFrame = pictureFrame;
 }

 /**
  * Method to get an image from the picture
  * @return  the buffered image since it is an image
  */
 public Image getImage()
 {
   return bufferedImage;
 }

 /**
  * Method to return the pixel value as an int for the
  * given x and y location
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @return the pixel value as an integer (alpha, red,
  * green, blue)
  */
 public int getBasicPixel(int x, int y)
 {
    return bufferedImage.getRGB(x,y);
 }

 /**
  * Method to set the value of a pixel in the picture
  * from an int
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @param rgb the new rgb value of the pixel (alpha, red,
  * green, blue)
  */
 public void setBasicPixel(int x, int y, int rgb)
 {
   bufferedImage.setRGB(x,y,rgb);
 }

 /**
  * Method to get a pixel object for the given x and y
  * location
  * @param x  the x location of the pixel in the picture
  * @param y  the y location of the pixel in the picture
  * @return a Pixel object for this location
  */
 public Pixel getPixel(int x, int y)
 {
   // create the pixel object for this picture and the
   // given x and y location
   Pixel pixel = new Pixel(this,x,y);
   return pixel;
 }

 /**
  * Method to get a one-dimensional array of Pixels for
  * this simple picture
  * @return a one-dimensional array of Pixel objects
  * starting with y=0
  * to y=height-1 and x=0 to x=width-1.
  */
 public Pixel[] getPixels()
 {
   int width = getWidth();
   int height = getHeight();
   Pixel[] pixelArray = new Pixel[width * height];

   // loop through height rows from top to bottom
   for (int row = 0; row &LT; height; row++)
     for (int col = 0; col &LT; width; col++)
       pixelArray[row * width + col] =
                                  new Pixel(this,col,row);

   return pixelArray;
 }



 /**
  * Method to load the buffered image with the passed
  * image
  * @param image  the image to use
  */
 public void load(Image image)
 {
   // get a graphics context to use to draw on the
   // buffered image
   Graphics2D graphics2d = bufferedImage.createGraphics();

   // draw the image on the buffered image starting
   // at 0,0
   graphics2d.drawImage(image,0,0,null);

   // show the new image
   show();
 }

 /**
  * Method to show the picture in a picture frame
  */
 public void show()
 {
    // if there is a current picture frame then use it
   if (pictureFrame != null)
     pictureFrame.updateImageAndShowIt();

   // else create a new picture frame with this picture
   else
     pictureFrame = new PictureFrame(this);
 }

 /**
  * Method to hide the picture
  */
 public void hide()
 {
   if (pictureFrame != null)
     pictureFrame.setVisible(false);
 }

 /**
  * Method to make this picture visible or not
  * @param flag true if you want it visible else false
  */
 public void setVisible(boolean flag)
 {
   if (flag)
     this.show();
   else
     this.hide();
 }

 /**
  * Method to open a picture explorer on a copy of this
  * simple picture
  */
 public void explore()
 {
   // create a copy of the current picture and explore it
   new PictureExplorer(new SimplePicture(this));
 }

 /**
  * Method to force the picture to redraw itself.  This is
  * very useful after you have changed the pixels in a
  * picture.
  */
 public void repaint()
 {
   // if there is a picture frame tell it to repaint
   if (pictureFrame != null)
     pictureFrame.repaint();

   // else create a new picture frame
   else
     pictureFrame = new PictureFrame(this);
 }

 /**
  * Method to load the picture from the passed file name
  * @param fileName the file name to use to load the
  * picture from
  */
 public void loadOrFail(
                       String fileName) throws IOException
 {
    // set the current picture's file name
   this.fileName = fileName;

   // set the extension
   int posDot = fileName.indexOf('.');
   if (posDot &gt;= 0)
     this.extension = fileName.substring(posDot + 1);

   // if the current title is null use the file name
   if (title == null)
     title = fileName;

   File file = new File(this.fileName);

   if (!file.canRead())
   {
     // try adding the media path
     file = new File(
                 FileChooser.getMediaPath(this.fileName));
     if (!file.canRead())
     {
       throw new IOException(this.fileName + " could not"
       + " be opened. Check that you specified the path");
     }
   }

   bufferedImage = ImageIO.read(file);
 }


 /**
  * Method to write the contents of the picture to a file
  * with the passed name without throwing errors
  * (THIS MAY NOT BE A VALID DESCRIPTION - RGB)
  * @param fileName the name of the file to write the
  * picture to
  * @return true if success else false
  */
 public boolean load(String fileName)
 {
     try {
         this.loadOrFail(fileName);
         return true;

     } catch (Exception ex) {
         System.out.println("There was an error trying"
                                + " to open " + fileName);
         bufferedImage = new BufferedImage(600,200,
                              BufferedImage.TYPE_INT_RGB);
         addMessage("Couldn't load " + fileName,5,100);
         return false;
     }

 }


 /**
  * Method to load the picture from the passed file name
  * this just calls load(fileName) and is for name
  * compatibility
  * @param fileName the file name to use to load the
  * picture from
  * @return true if success else false
  */
 public boolean loadImage(String fileName)
 {
     return load(fileName);
}

 /**
  * Method to draw a message as a string on the buffered
  * image
  * @param message the message to draw on the buffered
  * image
  * @param xPos  the leftmost point of the string in x
  * @param yPos  the bottom of the string in y
  */
 public void addMessage(
                       String message, int xPos, int yPos)
 {
   // get a graphics context to use to draw on the
   // buffered image
   Graphics2D graphics2d = bufferedImage.createGraphics();

   // set the color to white
   graphics2d.setPaint(Color.white);

   // set the font to Helvetica bold style and size 16
   graphics2d.setFont(new Font("Helvetica",Font.BOLD,16));

   // draw the message
   graphics2d.drawString(message,xPos,yPos);

 }

 /**
  * Method to draw a string at the given location on the
  * picture
  * @param text the text to draw
  * @param xPos the left x for the text
  * @param yPos the top y for the text
  */
 public void drawString(String text, int xPos, int yPos)
 {
   addMessage(text,xPos,yPos);
 }

 /**
   * Method to create a new picture by scaling the
   * current picture by the given x and y factors
   * @param xFactor the amount to scale in x
   * @param yFactor the amount to scale in y
   * @return the resulting picture
   */
  public Picture scale(double xFactor, double yFactor)
  {
    // set up the scale tranform
    AffineTransform scaleTransform =
                                    new AffineTransform();
    scaleTransform.scale(xFactor,yFactor);

    // create a new picture object that is the right size
    Picture result = new Picture(
                           (int) (getWidth() * xFactor),
                           (int) (getHeight() * yFactor));

    // get the graphics 2d object to draw on the result
    Graphics graphics = result.getGraphics();
    Graphics2D g2 = (Graphics2D) graphics;

    // draw the current image onto the result image
    // scaled
    g2.drawImage(this.getImage(),scaleTransform,null);

    return result;
  }

  /**
   * Method to create a new picture of the passed width.
   * The aspect ratio of the width and height will stay
   * the same.
   * @param width the desired width
   * @return the resulting picture
   */
  public Picture getPictureWithWidth(int width)
  {
    // set up the scale tranform
    double xFactor = (double) width / this.getWidth();
    Picture result = scale(xFactor,xFactor);
    return result;
  }

  /**
   * Method to create a new picture of the passed height.
   * The aspect ratio of the width and height will stay
   * the same.
   * @param height the desired height
   * @return the resulting picture
   */
  public Picture getPictureWithHeight(int height)
  {
    // set up the scale tranform
    double yFactor = (double) height / this.getHeight();
    Picture result = scale(yFactor,yFactor);
    return result;
  }

 /**
  * Method to load a picture from a file name and show it
  * in a picture frame
  * @param fileName the file name to load the picture
  * from
  * @return true if success else false
  */
 public boolean loadPictureAndShowIt(String fileName)
 {
   boolean result = true;// the default is that it worked

   // try to load the picture into the buffered image from
   // the file name
   result = load(fileName);

   // show the picture in a picture frame
   show();

   return result;
 }

 /**
  * Method to write the contents of the picture to a file
  * with the passed name
  * @param fileName the name of the file to write the
  * picture to
  */
 public void writeOrFail(String fileName)
                                        throws IOException
 {
   //the default is current
   String extension = this.extension;

   // create the file object
   File file = new File(fileName);
   File fileLoc = file.getParentFile();

   // canWrite is true only when the file exists
   // already! (alexr)
   if (!fileLoc.canWrite()) {
       // System.err.println(
       // "can't write the file but trying anyway? ...");
        throw new IOException(fileName +
        " could not be opened. Check to see if you can"
        + " write to the directory.");
   }

   // get the extension
   int posDot = fileName.indexOf('.');
   if (posDot &gt;= 0)
       extension = fileName.substring(posDot + 1);

   //write the contents of the buffered image to the file
   // as jpeg
   ImageIO.write(bufferedImage, extension, file);

 }

 /**
  * Method to write the contents of the picture to a file
  * with the passed name without throwing errors
  * @param fileName the name of the file to write the
  * picture to
  * @return true if success else false
  */
 public boolean write(String fileName)
 {
     try {
         this.writeOrFail(fileName);
         return true;
     } catch (Exception ex) {
         System.out.println(
                     "There was an error trying to write "
                     + fileName);
         return false;
     }

 }

 /**
  * Method to set the media path by setting the directory
  * to use
  * @param directory the directory to use for the media
  * path
  */
 public static void setMediaPath(String directory) {
   FileChooser.setMediaPath(directory);
 }

 /**
  * Method to get the directory for the media
  * @param fileName the base file name to use
  * @return the full path name by appending
  * the file name to the media directory
  */
 public static String getMediaPath(String fileName) {
   return FileChooser.getMediaPath(fileName);
 }

  /**
   * Method to get the coordinates of the enclosing
   * rectangle after this transformation is applied to
   * the current picture
   * @return the enclosing rectangle
   */
  public Rectangle2D getTransformEnclosingRect(
                                    AffineTransform trans)
  {
    int width = getWidth();
    int height = getHeight();
    double maxX = width - 1;
    double maxY = height - 1;
    double minX, minY;
    Point2D.Double p1 = new Point2D.Double(0,0);
    Point2D.Double p2 = new Point2D.Double(maxX,0);
    Point2D.Double p3 = new Point2D.Double(maxX,maxY);
    Point2D.Double p4 = new Point2D.Double(0,maxY);
    Point2D.Double result = new Point2D.Double(0,0);
    Rectangle2D.Double rect = null;

    // get the new points and min x and y and max x and y
    trans.deltaTransform(p1,result);
    minX = result.getX();
    maxX = result.getX();
    minY = result.getY();
    maxY = result.getY();
    trans.deltaTransform(p2,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p3,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p4,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());

    // create the bounding rectangle to return
    rect = new Rectangle2D.Double(
              minX,minY,maxX - minX + 1, maxY - minY + 1);
    return rect;
  }

 /**
  * Method to return a string with information about this
  * picture
  * @return a string with information about the picture
  */
 public String toString()
 {
   String output =
     "Simple Picture, filename " + fileName +
     " height " + getHeight() + " width " + getWidth();
   return output;
 }

} // end of SimplePicture class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Source code for Ericson's DigitalPicture interface.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.Image;
import java.awt.image.BufferedImage;

/**
 * Interface to describe a digital picture.  A digital
 * picture can have a associated file name.  It can have
 * a title.  It has pixels associated with it and you can
 * get and set the pixels.  You can get an Image from a
 * picture or a BufferedImage.  You can load it from a
 * file name or image.  You can show a picture.  You can 
 * create a new image for it.
 * 
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public interface DigitalPicture 
{
 // get the file name that the picture came from  
 public String getFileName(); 
 
 // get the title of the picture 
 public String getTitle(); 

 // set the title of the picture
 public void setTitle(String title); 

 // get the width of the picture in pixels
 public int getWidth(); 

 // get the height of the picture in pixels
 public int getHeight(); 

 // get the image from the picture
 public Image getImage(); 

 // get the buffered image
 public BufferedImage getBufferedImage(); 

 // get the pixel information as an int   
 public int getBasicPixel(int x, int y); 

 // set the pixel information
 public void setBasicPixel(int x, int y, int rgb); 

 // get the pixel information as an object
 public Pixel getPixel(int x, int y); 

 // load the image into the picture
 public void load(Image image); 

 // load the picture from a file
 public boolean load(String fileName); 

 // show the picture 
 public void show(); 
}</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Source code for the program named 
Java358a. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>/*Program Java358a
Copyright R.G.Baldwin 2009

The purpose of this program is to illustrate the use of
the following methods of the Picture class:

Picture scale(double xFactor, double yFactor)
Rectangle2D getTransformEnclosingRect(
                                    AffineTransform trans)
void copyPicture(SimplePicture sourcePicture)

In addition, the program illustrates the following
constructor for the Picture class:

SimplePicture(SimplePicture copyPicture)

The program defines two methods named rotatePicture and
translatePicture that are patterned after the scale method
of the picture class. Descriptions of the two methods are
provided with comments at the beginning of the method.

The program begins by creating and showing a Picture
object based on a specified image file in the current
directory.

Then the program illustrates the use of the scale method,
the rotatePicture method, and the translatePicture
method in that order. The Picture object returned from
each of these methods is displayed.

Tested using Windows Vista Premium Home edition and
Ericson's multimedia library.
*********************************************************/
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor. Note that the image file is
    // located in the current directory.
    Picture pixA = new Picture("ScaledBeach.jpg");
    pixA.setTitle("pixA");
    pixA.show();

    //Call the scale method on pixA to create a new
    // Picture object that contains a scaled version of
    // pixA, scaled by 0.5 in both dimensions. Show the
    // new scaled picture.
    Picture pixB = pixA.scale(0.5,0.5);
    pixB.setTitle("pixB");
    pixB.show();

    //Create a new Picture object that is a copy of pixA.
    Picture pixC = new Picture(
                        pixA.getWidth(),pixA.getHeight());
    pixC.copyPicture(pixA);
    //Call the rotatePicture method to create and return a
    // new Picture object that contains the image from
    // pixC rotated by 30-degrees clockwise around its
    // center and translated to the center of the new
    // Picture object.
    //The size of the new Picture object is such that each
    // corner of the rotated picture touches the edge of
    // the new Picture just inside the border of the
    // JFrame.
    pixC = rotatePicture(pixC,30.0);
    pixC.setTitle("pixC");
    pixC.show();

    //Call the translatePicture method to create and
    // return a new Picture object that contains the
    // image from pixA translated by 20 pixels in the
    // x-dimension and 30 pixels in the y-dimension.
    // The size of the new Picture object is such that
    // there is white space above and to the left of the
    // translated image where the amount of whitespace
    // equals the space that was vacated by translating
    // the image to the right and down.
    Picture pixD = translatePicture(pixA,20,30);
    pixD.setTitle("pixD");
    pixD.show();

  }//end run method
  //----------------------------------------------------//

  //This method accepts a reference to a Picture object
  // along with a rotation angle in degrees. It creates
  // and returns a new Picture object that is of the
  // correct size to contain and display the incoming
  // picture after it has been rotated around its center
  // by the specified rotation angle and translated to the
  // center of the new Picture object.
  public Picture rotatePicture(Picture pix,double angle){

    //Set up the rotation transform
    AffineTransform rotateTransform =
                                    new AffineTransform();
    rotateTransform.rotate(Math.toRadians(angle),
                           pix.getWidth()/2,
                           pix.getHeight()/2);

    //Get the required dimensions of a rectangle that will
    // contain the rotated image.
    Rectangle2D rectangle2D =
           pix.getTransformEnclosingRect(rotateTransform);
    int resultWidth = (int)(rectangle2D.getWidth());
    int resultHeight = (int)(rectangle2D.getHeight());

    //Set up the translation transform that will translate
    // the rotated image to the center of the new Picture
    // object.
    AffineTransform translateTransform =
                                    new AffineTransform();
    translateTransform.translate(
                      (resultWidth - pix.getWidth())/2,
                      (resultHeight - pix.getHeight())/2);

    //Concatenate the two transforms so that the image
    // will first be rotated around its center and then
    // translated to the center of the new Picture object.
    translateTransform.concatenate(rotateTransform);
    //Create a new Picture object to contain the results
    // of the transformation.
    Picture result = new Picture(
                                resultWidth,resultHeight);

    //Get the graphics context of the new Picture object,
    // apply the transform to the incoming picture and
    // draw the transformed picture on the new Picture
    // object.
    Graphics2D g2 = (Graphics2D)result.getGraphics();
    g2.drawImage(pix.getImage(),translateTransform,null);

    return result;
  }//end rotatePicture
  //----------------------------------------------------//

  //The following method accepts a reference to a Picture
  // object along with positive x and y translation
  // values. It creates and returns a new Picture object
  // that contains a translated version of the original
  // image with whitespace to the left of and/or above the
  // translated image. If either translation value is
  // negative, the method simply returns a reference to a
  // copy of the original picture.
  public Picture translatePicture(
                         Picture pix,double tx,double ty){
    if((tx &lt; 0.0) || (ty &lt; 0.0)){
      //Negative translation values are not supported.
      // Simply return a reference to a copy of the
      // incoming picture. Note that this constructor
      // creates a new picture by copying the image from
      // an existing picture.
      return new Picture(pix);
    }//end if

    //Set up the tranform
    AffineTransform translateTransform =
                                    new AffineTransform();
    translateTransform.translate(tx,ty);

    //Compute the size of a rectangle that is of
    // sufficient size to contain and display the
    // translated image.
    int pixWidth = pix.getWidth() + (int)tx;
    int pixHeight = pix.getHeight() + (int)ty;

    //Create a new picture object that is the correct
    // size.
    Picture result = new Picture(pixWidth,pixHeight);

    //Get the graphics2D object to draw on the result.
    Graphics2D g2 = (Graphics2D)result.getGraphics();

    //Draw the translated image from pix onto the new
    // Picture object, applying the transform in the
    // process.
    g2.drawImage(pix.getImage(),translateTransform,null);

    return result;
  }//end translatePicture
  //----------------------------------------------------//

}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
