<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Graphics, using Java and JDOM with SVG, Part 2</h2>
<p><i>Expand the JDOM/SVG graphics library to include gradients, Bézier
</b>curves, and elliptical arcs.&nbsp; Learn the significance of the word 
Scalable in Scalable Vector Graphics (SVG).&nbsp; Learn how to use JDOM to write 
XHTML output files containing SVG/XML code.&nbsp; Learn how to use JDOM to 
write Java servlets that deliver XHTML output containing SVG/XML code.</i></p><p><b>Published:</b>&nbsp; 
August 14, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2224</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_program_named_Svg17">The program named Svg17</a></li>
		<li><a href="#The_program_named_Svg18">The program named Svg18</a></li>
		<li><a href="#The_program_named_Svg19">The program named Svg19</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#FF0000"><b>Second</b></font><font color="#ff0000"><b> of two 
parts</b></font></p>
<p>This lesson is the second part of two-part tutorial on using Java and JDOM to 
create SVG files.</p>
<p><font color="#ff0000"><b>What you have learned</b></font></p>
<p>In Part 1, you learned a little about JDOM as an alternative to Sun's JAXP 
DOM API.&nbsp; You learned how to create an SVG file using raw JDOM commands, 
and you learned how to write a Java/JDOM/SVG graphics library to reduce the 
effort required to create SVG files using JDOM and Java.</p>
<p> <font color="#FF0000"><b>What you will learn</b></font></p>
<p> In Part 2, you will expand the JDOM/SVG graphics library to include gradients, Bézier
</b>curves, and elliptical arcs.&nbsp; You will learn the significance of the word 
<i>Scalable</i> in Scalable Vector Graphics <i>(SVG)</i>.&nbsp; You will learn how to use JDOM to write 
XHTML output files containing SVG/XML code, and you will learn how to use JDOM to 
write Java servlets that deliver XHTML output containing SVG/XML code.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Graphic output from Svg17.</li>
	<li><a href="#Figure_2">Figure 2</a>. Graphic output from Svg18 and Svg19.</li>
	<li><a href="#Figure_3">Figure 3</a>. Drawing with a Bezier curve and a 
	radial gradient.</li>
	<li><a href="#Figure_4">Figure 4</a>. Bit mapped image enlarged by a factor 
	of four.</li>
	<li><a href="#Figure_5">Figure 5</a>. SVG drawing enlarged by a factor of 
	four.</li>
	<li><a href="#Figure_6">Figure 6</a>. Svg drawing enlarged by a factor of 
	sixteen.</li>
	<li><a href="#Figure_7">Figure 7</a>. Svg drawing enlarged by a factor of 
	sixteen.</li>
	<li><a href="#Figure_8">Figure 8</a>. Bit mapped image enlarged by a factor 
	of sixteen.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Controlling physical and virtual 
	canvas dimensions.</li>
	<li><a href="#Listing_2">Listing 2</a>. Create path data for the background 
	graph paper.</li>
	<li><a href="#Listing_3">Listing 3</a>. Create the path element and add it 
	to the root.</li>
	<li><a href="#Listing_4">Listing 4</a>. The makePath method.</li>
	<li><a href="#Listing_5">Listing 5</a>. Create the defs element.</li>
	<li><a href="#Listing_6">Listing 6</a>. The makeNode method.</li>
	<li><a href="#Listing_7">Listing 7</a>. Create a linear gradient element.</li>
	<li><a href="#Listing_8">Listing 8</a>. The makeLinearGradient method.</li>
	<li><a href="#Listing_9">Listing 9</a>. Create the first of three stop 
	nodes.</li>
	<li><a href="#Listing_10">Listing 10</a>. The makeGradientStop method.</li>
	<li><a href="#Listing_11">Listing 11</a>. Call the makeNode method to draw 
	an ellipse.</li>
	<li><a href="#Listing_12">Listing 12</a>. Define a radial gradient and save 
	it as a child of defs.</li>
	<li><a href="#Listing_13">Listing 13</a>. The makeRadialGradient method.</li>
	<li><a href="#Listing_14">Listing 14</a>. Draw a cubic Bezier curve.</li>
	<li><a href="#Listing_15">Listing 15</a>. Draw an elliptical arc with no 
	rotation.</li>
	<li><a href="#Listing_16">Listing 16</a>. Label the vertical lines of the 
	grid.</li>
	<li><a href="#Listing_17">Listing 17</a>. The makeText method.</li>
	<li><a href="#Listing_18">Listing 18</a>. Label the graphics elements.</li>
	<li><a href="#Listing_19">Listing 19</a>. Write the output file.</li>
	<li><a href="#Listing_20">Listing 20</a>. The namespace URI.</li>
	<li><a href="#Listing_21">Listing 21</a>. Specify DTD information.</li>
	<li><a href="#Listing_22">Listing 22</a>. Create the Document node.</li>
	<li><a href="#Listing_23">Listing 23</a>. Create optional and required 
	elements.</li>
	<li><a href="#Listing_24">Listing 24</a>. Create a paragraph node.</li>
	<li><a href="#Listing_25">Listing 25</a>. Specify the SVG namespace.</li>
	<li><a href="#Listing_26">Listing 26</a>. Scaling the drawing.</li>
	<li><a href="#Listing_27">Listing 27</a>. Create the svg root and attach as 
	a child to body.</li>
	<li><a href="#Listing_28">Listing 28</a>. Create the second paragraph node.</li>
	<li><a href="#Listing_29">Listing 29</a>. Write the output file named 
	Svg18.xhtml.</li>
	<li><a href="#Listing_30">Listing 30</a>. Program code for Svg17.</li>
	<li><a href="#Listing_31">Listing 31</a>. Program code for Svg18.</li>
	
	<li><a href="#Listing_32">Listing 32</a>. Program code for Svg19.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>See the link to Part 1 of this tutorial in <a href="#Resources">Resources</a> 
for background information on JDOM.&nbsp; See numerous previous lessons in this 
series for background information on SVG.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain three programs named <b>Svg17</b>,
<b>Svg18</b>, and <b>Svg19</b>.</p>
<p><font color="#FF0000"><b>Svg17</b></font></p>
<p><b>Svg17</b> will teach you how to expand the Java/JDOM/SVG graphics library 
from the earlier program named <b>Svg16</b> to include the following new 
methods:</p>
<ul>
	<li><b>makeGridString</b> - used with <b>makePath</b> to draw graph paper</li>
	<li><b>makePath</b> - used for a variety of purposes including the drawing 
	of Bézier<b> </b>curves and elliptical arcs.</li>
	<li><b>makeNode</b> - used to create a general node for which a specialized 
	method hasn't been written.</li>
	<li><b>makeLinearGradient</b> - used to define a linear gradient.</li>
	<li><b>makeRadialGradient</b> - used to define a radial gradient.</li>
	<li><b>makeGradientStop</b> - used to control the behavior of linear and 
	radial gradients.</li>
	<li><b>makeText</b> - used to add text to an SVG drawing.</li>
</ul>
<p><font color="#FF0000"><b>The graphic output from Svg17</b></font></p>
<p>The output SVG/XML code from <b>Svg17</b> is written into an SVG file, which 
can be properly rendered by loading the file into Firefox 2.0.0.4.&nbsp; The graphic 
output from <b>Svg17</b> is shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Graphic output from Svg17. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2224a01.jpg" width="472" height="718"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Svg18</b></font></p>
<p><b>Svg18</b> will teach you how to use JDOM to write an output XHTML file 
containing embedded SVG/XML code.&nbsp; The file can be rendered in Firefox 
2.0.0.4 
to produce a scaled down version of the same graphic that is produced by the SVG 
file from <b>Svg17</b> with some additional HTML text inserted into the output.</p>
<p><font color="#FF0000"><b>Svg19</b></font></p>
<p><b>Svg19</b> will teach you how to convert the JDOM program named <b>Svg18</b> 
into a JDOM servlet that will deliver XHTML output with embedded SVG/XML code.&nbsp; 
The servlet can be accessed by Firefox 2.0.0.4 to produce the same graphic that is 
produced by <b>Svg18</b>.</p>
<p><font color="#FF0000"><b>The graphic output from Svg18 and Svg19</b></font></p>
<p>The output graphic produced by <b>Svg18</b> and <b>Svg19</b> is shown in 
Figure 2.&nbsp; Note the overall size of this graphic as compared to the overall 
size of the graphic produced by <b>Svg17</b> in Figure 1.&nbsp; One of the 
advantages of SVG <i>(as compared to bit mapped graphics, for example)</i> is 
the ability to scale the size of the graphic up or down with no loss in the 
quality of the graphic.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Graphic output from Svg18 and Svg19. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2224a02.jpg" width="363" height="685"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Also note the HTML text above and below the image in Figure 2, which is not 
present in the output from <b>Svg17</b> shown in Figure 1.&nbsp; One of the advantages of 
embedding the SVG code in an XHTML file instead of writing it into an SVG file is 
the ability to place the graphic in the 
midst of other HTML elements, such as the HTML text shown in Figure 2.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Svg17">The program named 
Svg17</a></h3>

<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Proper spelling of Bézier's name.</b><br>
				Although <b>Bézier</b> is the proper spelling of <b>Pierre 
				Bézier's </b>name, the use of the special character as the 
				second character in the name makes it very difficult to compose 
				text using a standard computer keyboard.&nbsp; Therefore, to make it 
				easier to compose the remainder of this tutorial, I will take 
				the liberty of spelling it <b>Bezier</b>.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Description of the program</b></font></p>
<p>The program named <b>Svg16</b> began the development of a Java/JDOM/SVG 
graphics library of my own design named <b>JdomSvg</b>.&nbsp; The use of this 
library can eliminate much of the effort involved in writing Java programs to 
produce SVG files using JDOM as an alternative to Sun's JAXP DOM API.&nbsp; The 
purpose of this program is to add the following methods to that graphics library 
and to demonstrate their use.</p>
<ul>
	<li><b>makeGridString</b> - used with <b>makePath</b> to draw graph paper</li>
	<li><b>makePath</b> - used for a variety of purposes including the drawing 
	of Bezier<b> </b>curves and elliptical arcs.</li>
	<li><b>makeNode</b> - used to create a general node for which a specialized 
	method hasn't been written.</li>
	<li><b>makeLinearGradient</b> - used to define a linear gradient.</li>
	<li><b>makeRadialGradient</b> - used to define a radial gradient.</li>
	<li><b>makeGradientStop</b> - used to control the behavior of linear and 
	radial gradients.</li>
	<li><b>makeText</b> - used to add text to an SVG drawing.</li>
</ul>
<p>The program draws the following graphics elements on a background that looks 
like green graph paper <i>(see Figure 1)</i> and writes the output into an SVG 
file that can be rendered using an SVG graphics engine such a Firefox 2.0.0.4:</p>
<ul>
	<li>A rotated ellipse with a linear gradient that changes from yellow to red 
	and back to yellow.</li>
	<li>A rectangle with a radial gradient centered in the upper left corner of 
	the rectangle.</li>
	<li>A filled <i>(blue)</i> cubic Bezier curve with two Bezier segments 
	inside a filled <i>(yellow)</i> polygon.</li>
	<li>A filled <i>(blue)</i> quadratic Bezier curve with two Bezier segments 
	inside a filled <i>(yellow)</i> polyline that is partially transparent.</li>
	<li>A filled <i>(red)</i> elliptical arc with no rotation.</li>
	<li>A filled <i>(red)</i> elliptical arc with a rotation of 45 degrees.</li>
</ul>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>The output file validates at: <a href="http://validator.w3.org/">http://validator.w3.org/</a>&nbsp;&nbsp; 
It was tested using J2SE 6.0, JDOM 1.0, and Firefox 2.0.0.4 running under WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As is my custom, I will present and explain this program in fragments.&nbsp; 
You can view the program in its entirety in Listing 30 near the end of the 
lesson.</p>
<p>Some of the code in this lesson is the same as the code that I explained Part 
1 of this tutorial <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
Usually I won't repeat that explanation in this part of the tutorial.</p>
<p>The program and the main method begin in Listing 1.&nbsp; The code in the 
early portions of the <b>main</b> method is essentially the same as code that I 
have explained in previous lessons.&nbsp; Therefore, that code was deleted from 
Listing 1 for brevity.</p>
<p><font color="#FF0000">
<b>Controlling physical and virtual canvas dimensions</b></font></p>
<p>The expressions for computing the <b>viewBoxWidth</b> and <b>viewBoxHeight</b> 
are useful for those cases where you need to make the height to width ratio of 
the virtual canvas the same as the height to width ratio of the physical canvas.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Controlling physical and virtual canvas 
dimensions. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>Svg17</b>{
  
  public static void <b>main</b>(String[] args){

    //Code deleted for brevity.

    //Physical dimensions of the graphic on the screen.
    int svgWidth = 460;
    int svgHeight = 552;
    
    //Virtual dimensions of the graphic in user units.
    int viewBoxWidth = <b>500</b>;
    int viewBoxHeight = <b>500*svgHeight/svgWidth;</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>With this formulation, the virtual width will always be 500 regardless of the 
physical width, and the virtual height will vary as the physical height varies.&nbsp; 
Note however, that sometimes you may not want to keep these ratios equal.&nbsp; 
For example, it is often desirable to expand the scale on the vertical axis when 
plotting curves.</p>
<p><font color="#FF0000">
<b>Create path data for the background graph paper</b></font></p>
<p>Listing 2 calls the <b>makeGridString</b> method to create the path data for 
drawing the background graph paper in Figure 1.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Create path data for the background graph 
paper. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Code deleted for brevity
  
    //Begin creating graphics elements.

    //Draw light green grid lines every 10 user units on
    // the basis of the virtual dimensions in user units.

    //First create the path data.
    String gridData = JdomSvg.<b>makeGridString</b>(
                           viewBoxWidth,viewBoxHeight,<b>10</b>);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing about the <b>makeGridString</b> method that is peculiar to 
the use of JDOM.&nbsp; The method is essentially the same as a method having the 
same name that I explained in the earlier lesson titled &quot;Drawing grids, Bézier 
curves and elliptical arcs using Java and SVG&quot; <i>(see <a href="#Resources">
Resources</a>)</i>.</p>
<p><font color="#FF0000">
<b>Create the path element and add it to the root</b></font></p>
<p>Listing 3 calls the <b>makePath</b> method to create the JDOM element that 
represents the background grid with the smallest squares in Figure 1.&nbsp; (<i>The 
grid size of 10 virtual units was established by passing a parameter with a 
value of 10 to the <b>makeGridString</b> method in Listing 2.)</i></p>
<p>When the <b>makePath</b> method returns a reference to the path element, the 
code in Listing 3 calls the <b>setAttribute</b> method on the path to set the 
stroke color to the very light green that you see in Figure 1.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Create the path element and add it to the root.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    Element temp;
    temp = JdomSvg.<b>makePath</b>(svg,ns,gridData);
    //Set the color to a very light green.
    temp.<b>setAttribute</b>("stroke","#ccffcc");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Switching back and forth</b></font></p>
<p>From this point forward, I will be switching back and forth between 
statements in the <b>main</b> method and methods in the graphics library.&nbsp; 
I will use the notation shown in the upper left corner of Listing 3 to indicate 
those code fragments that are part of the <b>main</b> method.</p>
<p><font color="#FF0000">
<b>The makePath method</b></font></p>
<p>The <b>makePath</b> method is shown in its entirety in Listing 4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. The makePath method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makePath</b>(Element parent,
                          String namespace,
                          String d){
    Element path  = new Element("path",namespace);
    parent.addContent(path);
    
    //Set default attribute values.
    path.setAttribute("stroke","black");
    path.setAttribute("stroke-width","1");
    path.setAttribute("fill","none");
    
    //Set user specified default values.
    path.setAttribute("d",d);
    return path;
  }//end makePath</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>makePath</b> method constructs and returns a reference to a <b>path</b> 
element as a child of the specified parent node in the specified namespace.&nbsp; 
By default, the stroke is set to black one pixel wide, and the fill is set to 
none.</p>
<blockquote>
	<p><i>(See the method named <b>makeGridString</b> for a utility method that 
	is designed to create the data string for this method for the special case 
	of drawing grids that resemble graph paper.&nbsp; For other cases, simply 
	create a data string that is compatible with the SVG path element.)</i></p>
</blockquote>
<p>As you will recall from the earlier lesson titled &quot;Drawing grids, Bézier 
curves and elliptical arcs using Java and SVG&quot; <i>(see <a href="#Resources">
Resources</a>)</i> a variety of different paths including straight lines, 
polylines, Bezier curves, elliptical arcs, etc., can be constructed depending on 
the contents of the third incoming parameter of type <b>String</b>.</p>
<p>The <b>makePath</b> method is fairly typical of many of the methods in the 
SVG graphic library.&nbsp;&nbsp; It begins by creating the new path element and 
attaching it as a child to the specified parent.&nbsp; Then it calls the <b>
setAttribute</b> method several times in succession to set the default values 
for some of the attributes.&nbsp; Then it calls the <b>setAttribute</b> method 
again to set the user specified attribute values.&nbsp; In this case, there is 
only one user specified attribute, but some of the methods in the library have 
several user specified attribute values.</p>
<p><font color="#FF0000">
<b>Create the defs element</b></font></p>
<p>Listing 5 calls the new <b>makeNode</b> method to create a <b>defs</b> element.&nbsp; 
Recall from an earlier lesson that a <b>defs</b> element serves as a repository 
for definitions in XML code that are referenced by other elements.&nbsp; In this 
program, the <b>defs</b> element is used as a repository for gradient 
definitions.&nbsp; Note for the purpose of a later discussion that Listing 5 
passes null for the fourth parameter to the <b>makeNode</b> method.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Create the defs element. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    //Using the same procedure, draw darker green grid
    // lines every 50 user units and draw them on top of
    // the existing grid lines.

    // Code deleted for brevity.

    Element defs = JdomSvg.<b>makeNode</b>(svg,//parent
                                    ns,//namespace
                                    "defs",
                                    null//no attributes
                                    );</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The makeNode method</b></font></p>
<p>The graphics library contains a number of specialized methods that are 
designed to construct and return specific kinds of elements such as <b>makeLine</b>,
<b>makeCircle</b>, <b>makeEllipse</b>, etc.</p>
<p>In addition, the library contains the <b>makeNode</b> method, the purpose of 
which is to create a general node having any name, and any number of attributes 
with any attribute names and any String values for the attributes, or no 
attributes at all.</p>
<p>The <b>makeNode</b> method is shown in its entirety in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The makeNode method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeNode</b>(Element parent,
                          String namespace,
                          String nodeType,
                          String[] data){

    Element element = new Element(nodeType,namespace);
    parent.addContent(element);
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    //Extract the values from the array and construct
    // each of the attributes and its value.
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first parameter is a reference to the parent node to which this node is 
to be attached so as to become a child of that node.&nbsp; The second parameter 
is a <b>String</b> that specifies the namespace for the element represented by 
the new node.&nbsp; The third parameter is a <b>String</b> that specifies the 
type of the new node.&nbsp; <i>(Looking back at Listing 5, you can see that for 
the case at hand, the type of the new node is &quot;defs.&quot;)</i></p>
<p>The fourth parameter must be a reference to an array object of type <b>
String[]</b>.&nbsp; This array must contain an even number of elements.&nbsp; 
Each pair of elements specifies the name and the value of one attribute, in the 
order name, value, name, value, etc.&nbsp; If there are no attributes, the value 
of this parameter should be null.&nbsp; <i>(Once again, looking back at Listing 
5, the value of the fourth parameter is null for the case at hand.)</i></p>
<p>The method begins by constructing the new element of the specified type in 
the specified namespace and attaching it as a child to the specified parent.</p>
<p>Then the method tests to determine if the value of the fourth parameter is 
null.&nbsp; If so, it simply returns the element that was just constructed.</p>
<p>If the value of the fourth parameter is not null, the method extracts the <b>
String</b> values from the referenced array object in pairs, using the two 
values as parameters in a call to the <b>setAttribute</b> method to set the 
value of the specified attribute to the specified value.</p>
<p>The <b>makeNode</b> method is intended to be used primarily to construct 
elements for which there is no corresponding specialized method in the library.&nbsp; 
However, it can be used to construct any of the SVG elements.</p>
<p><font color="#FF0000">
<b>Create a linear gradient element</b></font></p>
<p>Listing 7 calls the new <b>makeLinearGradient</b> method to create a linear 
gradient element that is a child of the <b>defs</b> element and identified for 
later reference purposes as <b>gradientA</b>.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Create a linear gradient element. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    Element gradientA = JdomSvg.<b>makeLinearGradient</b>(
                                         defs,//parent
                                         ns,//namespace
                                         "gradientA");//id</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although it won't be determined until later in the program, this gradient 
starts with yellow, changes to red, and then changes back to yellow going from 
left to right.&nbsp; This is the gradient that was used to fill the ellipse in 
the upper left of Figure 1.</p>
<p><font color="#FF0000">
<b>The makeLinearGradient method</b></font></p>
<p>The <b>makeLinearGradient</b> method is shown in it entirety in Listing 8.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. The makeLinearGradient method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeLinearGradient</b>(Element parent,
                                    String namespace,
                                    String id){
    Element gradient = 
                  new Element("linearGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method creates a linear gradient node to which <b>stop</b> elements must 
be appended to specify the behavior of the gradient.&nbsp; There are no default 
attribute values and only one user specified attribute named <b>id</b>.&nbsp; 
The id attribute is used to differentiate this gradient node from other gradient 
nodes in the same program scope.&nbsp; The <b>id</b> provides a handle by which 
other elements can reference this gradient.</p>
<p><font color="#FF0000">
<b>Create the first of three stop nodes</b></font></p>
<p>The code in Listing 9 calls the <b>makeGradientStop</b> method to create the 
first of three stop nodes that identify the colors used to produce <b>gradientA</b> 
and specify where the colors begin and end</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Create the first of three stop nodes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main. 
    JdomSvg.<b>makeGradientStop</b>(gradientA,//parent
                             ns,
                             "4%",//start here
                             "yellow");//color</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The makeGradientStop method</b></font></p>
<p>The <b>makeGradientStop</b> method is shown in its entirety in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. The makeGradientStop method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeGradientStop</b>(Element parent,
                                  String namespace,
                                  String offset,
                                  String color){
    Element stopElement = new Element("stop",namespace);
    parent.addContent(stopElement);
    
    stopElement.setAttribute("offset",offset);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>makeGradientStop</b> method creates a gradient stop node in a 
specified namespace and attaches it as a child to a specified parent.&nbsp; <i>
(The node must be attached as a child to a linear gradient node or a radial 
gradient node to be useful.)</i>&nbsp; There are two user specified parameters 
in Listing 10 that specify the color and specify where the color changes in the 
shape being filled with the gradient.</p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Could have called makeEllipse.</b><br />
  Note that I could have called the makeEllipse method, but I wanted to 
demonstrate the use of the more general makeNode method for a graphics element 
that has several attributes.</td></tr></table>
</td>
</tr>
</table>

<p><font color="#FF0000">
<b>Call the makeNode method to draw an ellipse</b></font></p>
<p>
<p>Listing 11 calls the <b>makeNode</b> method to draw an ellipse.&nbsp; The 
ellipse is filled with linear <b>gradientA</b> and rotated by 30 degrees.&nbsp; 
This is the ellipse that appears in the upper left of Figure 1.&nbsp; Note the 
boldface syntax used to specify a gradient as the value for the <b>fill</b> 
attribute.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Call the makeNode method to draw an 
ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>// In main.
    //Code to create two more stop nodes deleted for
    // brevity.

    JdomSvg.<b>makeNode</b>(
            svg,//parent
            ns,
            "ellipse",//node type
            new String[]{"cx","150",
                         "cy","80",
                         "rx","100",
                         "ry","40",
                         "<b>fill","url(#gradientA)</b>",
                         "stroke","blue",
                         "stroke-width","3",
                         "opacity","0.5",
                         "transform","translate(150,80) "
                                   + "rotate(-30) "
                                   + "translate(-150,-80)"
                        }//end array definition
    );//end makeNode method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A comment regarding opacity and gradients</b></font></p>
<p>Setting the <b>opacity</b> attribute value to 0.6 in Listing 11 is of no 
consequence when the output file is rendered using Firefox 1.5 as shown in 
Figure 1.&nbsp; In 
that case, the gradient continues to be totally opaque.&nbsp; However, this is a 
weakness in the Firefox 1.5 rendering engine and is not a limitation of SVG.&nbsp; 
When the file is rendered using an Adobe rendering engine, the gradient is 
partially transparent as it should be for an <b>opacity</b> attribute value of 
0.6.&nbsp; </p>
<p><i>(This problem has been fixed in Firefox 2.0.0.4.&nbsp; If you run this 
program and render the resulting output file in Firefox 2.0.0.4, the grid on the 
graph paper will show through the gradient fill inside the ellipse.)</i></p>
<p><font color="#FF0000">
<b>Define a radial gradient and save it as a child of defs</b></font></p>
<p>Listing 12 calls the <b>makeRadialGradient</b> method to define a gradient 
identified as <b>gradientB</b>.&nbsp; This gradient element provides a radial 
gradient that goes through yellow, red, green, and blue. It is used to fill the 
rectangle in the upper right of Figure 1.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Define a radial gradient and save it as 
a child of defs. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    int rectCornerX = 300;
    int rectCornerY = 10;
    int rectWidth = 150;
    int rectHeight = 150;

    Element gradientB = JdomSvg.<b>makeRadialGradient</b>(
                               defs,//parent
                               ns,//namespace
                               "gradientB",//ID
                               "userSpaceOnUse",
                               rectCornerX,//cx
                               rectCornerY,//cy
                               ((int)(rectWidth*1.2)));//r</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The makeRadialGradient method</b></font></p>
<p>The <b>makeRadialGradient</b> method is shown in its entirety in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The makeRadialGradient method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeRadialGradient</b>(Element parent,
                                    String namespace,
                                    String id,
                                    String gradientUnits,
                                    int cx,//center
                                    int cy,//center
                                    int r  //radius
                                    ){
    Element gradient = 
                  new Element("radialGradient",namespace);
    parent.addContent(gradient);

    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>With the exception of the fourth parameter identified as <b>gradientUnits</b>, 
the code in Listing 13 is straightforward and shouldn't require further 
explanation.</p>
<p>I recommend that you consult the SVG documentation <i>(see
<a href="#Resources">Resources</a>)</i> for more information on the various 
attributes of the radial gradient element.</p>
<p><font color="#FF0000">
<b>Draw a cubic Bezier curve</b></font></p>
<p>Listing 14 calls the <b>makePath</b> method to draw the cubic Bezier curve 
shown at the middle left in Figure 1.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Draw a cubic Bezier curve.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.

    //Code for four calls to the <b>makeGradientStop
    </b>// method deleted for brevity.

    //Draw the rectangle and fill it with gradientB.
    //Call to the <b>makeRect</b> method and the <b>setAttribute
</b>    // method deleted for brevity.

    //Draw a cubic Bezier curve consisting of two Bezier
    // segments.  First draw a polygon that shows the
    // start points, the end points, and the control
    // points for the segments. Fill the polygon with
    // yellow to provide a background color for the 
    // Bezier curve.
    //Call to the <b>makePolygon</b> method deleted for brevity.
    
    //Draw the cubic curve. Note the use of absolute
    // coordinate values only and also the use of the S
    // command. Stroke the curve with red and fill it with
    // blue.
    temp = JdomSvg.<b>makePath</b>(svg,ns,<b>"M180,290 C50,250,"
                    + "150,200,150,300 S250,350,120,310"</b>);
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","blue");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Recall from the earlier lesson titled &quot;Drawing grids, Bézier curves and 
elliptical arcs using Java and SVG&quot; <i>(see <a href="#Resources">Resources</a>)</i> 
that a Bezier curve <i>(either cubic or quadratic)</i> is drawn by drawing a <b>
path</b> with the correct value for the <b>String</b> parameter named <b>d</b>
<i>(see Listing 4)</i>.&nbsp; The string value that produced the cubic Bezier 
curve at the middle left in Figure 1 is shown highlighted in boldface near the 
bottom of Listing 14.</p>
<p><font color="#FF0000">
<b>Draw an elliptical arc with no rotation</b></font></p>
<p>Listing 15 calls the <b>makePath</b> method to draw a red elliptical arc with 
no rotation shown at the bottom left in Figure 1.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Draw an elliptical arc with no rotation. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    //Draw a quadratic Bezier curve consisting of two
    // Bezier segments.  First draw a polyline that shows
    // the start points, the end points, and the control
    // points.  Fill the polyline with yellow color with
    // an opacity attribute value of 0.5.  This allows
    // the grid to show through the filled polyline.
    //Call to the <b>makePolyline</b> method deleted for brevity.
    //Call to the <b>makePath</b> method to draw the quadratic
    // Bezier curve deleted for brevity.

    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with no rotation. Stroke it with
    // yellow and fill it with red.
    temp = JdomSvg.<b>makePath</b>(svg,ns,
                        "<b>M100,500 a70,30 0 1,0 50,-50 z</b>");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Recall from the earlier lesson titled &quot;Drawing grids, Bézier curves and 
elliptical arcs using Java and SVG&quot; <i>(see <a href="#Resources">Resources</a>)</i> 
that an elliptical arc is drawn by drawing a <b>path</b> with the correct value 
for the <b>String</b> parameter named <b>d</b> <i>(see Listing 4)</i>.&nbsp; The 
string value that produced the elliptical arc at the bottom left in Figure 1 is 
shown highlighted in boldface near the bottom of Listing 15.</p>
<p><font color="#FF0000">
<b>Label the vertical lines of the grid</b></font></p>
<p>Listing 16 calls the new <b>makeText</b> method several times in succession
<i>(inside a <b>for</b> loop)</i> to create and position the text labels at the 
bottom of the vertical lines in Figure 1.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Label the vertical lines of the grid. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with a rotation of 45 degrees.
    // Stroke it with yellow and fill it with red.
    //Call to <b>makePath</b> to draw the elliptical arc at 
    // the bottom right in Figure 1 deleted for brevity.


    <b>for</b>(int cnt = 0;cnt &lt; viewBoxWidth;cnt += 50){
      JdomSvg.<b>makeText</b>(
                     svg,ns,cnt,viewBoxHeight - 4,""+cnt);
    }//end for loop

</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The makeText method</b></font></p>
<p>The <b>makeText</b> method is shown in its entirety in Listing 17.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. The makeText method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeText</b>(Element parent,
                          String namespace,
                          int x,
                          int y,
                          String text){
    Element textNode = new Element("text",namespace);
    parent.addContent(textNode);

    textNode.setAttribute("x",""+x);
    textNode.setAttribute("y",""+y);
    
    textNode.addContent(text);

    return textNode;
  }//end makeText</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 17 is reasonably straightforward.&nbsp; The only thing 
that may be unusual is the interpretation of the values for x and y relative to 
the location of the text.&nbsp; It appears from experiments that the bottom left 
corner of the first character in the text string is located at coordinates (x,y) 
when the text is drawn.</p>
<p><font color="#FF0000">
<b>Label the graphics elements</b></font></p>
<p>Listing 18 calls the <b>makeText</b> method to place the label underneath the 
ellipse in the upper left corner of Figure 1.&nbsp; The code to label the 
remaining five graphics elements was deleted from Listing 18 for brevity.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Label the graphics elements. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>//In main.
    //Now label the horizontal lines.    
    //Code to label the horizontal lines deleted for
    // brevity.

    
    //Label each of the graphics elements
    JdomSvg.<b>makeText</b>(svg,ns,50,180,
                          "Ellipse with linear gradient");

    //Code to draw labels under each of the remaining five
    // graphics elements deleted for brevity.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Write the output file</b></font></p>
<p>Listing 19 calls the <b>writePrettyFile</b> method to write the SVG/XML code 
into the output file named <b>Svg17.svg</b>.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Write the output file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Write the output file.
    JdomSvg.writePrettyFile("Svg17.svg",doc);
    //JdomSvg.writeCompactFile("Svg17.svg",doc);
    
  }//end main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>writePrettyFile</b> method was explained in Part 1 of this tutorial <i>
(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p>Listing 19 also signals the end of the <b>main</b> method and the end of the 
explanation of the program named <b>Svg17</b>.</p>
<h3><a name="The_program_named_Svg18">The program named Svg18</a></h3>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>The intended primary purpose of this program was to use JDOM to embed SVG 
code into what would otherwise be a valid XHTML file.</p>
<p>A secondary purpose of this program, in comparison with the earlier program 
named <b>Svg017</b>, was to demonstrate the significance of the use of the word
<i>Scalable</i> in the name Scalable Vector Graphics <i>(SVG)</i>.</p>
<p>The secondary purpose was achieved.&nbsp; However, for the reasons explained 
below, the primary purpose was not completely achieved, because the output XHTML 
file is not valid.</p>
<p><font color="#FF0000"><b>Embedding graphics between HTML elements</b></font></p>
<p>One of the advantages of embedding SVG code in an XHTML document is that it 
then becomes possible to place the graphic in and among other HTML elements.&nbsp; 
That is not possible when creating an SVG file.&nbsp; That capability is 
demonstrated by the program output shown in Figure 2.&nbsp; Figure 2 shows HTML 
text inserted above and below the graphic image that was created by rendering 
the SVG code that was embedded in the XHTML code.</p>
<p><font color="#FF0000"><b>Not a valid XHTML file</b></font></p>
<p>My attempt to create a valid XHTML file using JDOM was not successful because 
the JDOM <b>Element</b> constructor insists on creating an <b>xmlns</b> 
attribute for each child of the root <b>html</b> node.&nbsp; This is true 
regardless of the name of the child node, and even when the constructor version 
is used that doesn't take a namespace as a parameter.&nbsp; Regardless of 
whether that version is used, or the version that takes a namespace as a 
parameter is used by passing null for the namespace, the resulting XML code 
contains the following attribute declaration in all child nodes of the root <b>
html</b> node:</p>
<p><pre><b>xmlns=&quot;&quot;</b></pre></p>
<p>The DTD for XHTML doesn't allow for attributes named <b>xmlns</b> on the <b>
head</b> and <b>body</b> elements.&nbsp;<i> (Note that the <b>xmlns</b> attribute 
is created even if I change the name of the child node from <b>head</b> to <b>joe</b>.)</i>&nbsp; 
This may be a bug in the version of the <b>Element</b> 
constructor that doesn't take a namespace parameter.&nbsp; The behavior of that 
version seems to be the same as passing null for the namespace to the version 
that does take a namespace parameter.&nbsp; Therefore, the output file produced 
by this program is not a valid XHTML file.&nbsp; <i>(Apparently there is 
something about this that I don't understand.)&nbsp; </i>Nonetheless, the output 
file renders very 
successfully in Firefox 2.0.0.4.</p>
<p><font color="#FF0000"><b>The Java/JDOM/SVG graphics library </b></font></p>
<p>The program named <b>Svg16</b> began the development of a Java/JDOM/SVG 
graphics library of my own design named <b>JdomSvg</b>.&nbsp; The use of this 
library eliminates much of 
the effort involved in writing Java programs to produce SVG files using JDOM as 
an alternative to the standard Sun JAXP DOM API.</p>
<p>Several new methods were added to the library in the program named <b>Svg017</b>.&nbsp; Those 
methods were all associated with the creation of SVG/XML code.&nbsp; I added the 
following method to the graphics library in this program:</p>
<p><pre><b>makeXhtmlRoot</b></pre></p>
<p>This method is used to create an ordinary XML root node that doesn't necessarily have 
anything to do with graphics, but rather is required for the creation of an 
XHTML file.</p>
<p><font color="#FF0000"><b>Create some text content</b></font></p>
<p>This program begins by placing the following text content in a paragraph 
element at the beginning of the body element:</p>
<p><pre><b>There is a graphic below here.</b></pre></p>
<p>That text appears above the image in Figure 2.</p>
<p><font color="#FF0000"><b>Create some graphic content</b></font></p>
<p>Then the program draws the following graphics elements on a background that 
looks like graph paper <i>(going from left to right, top to bottom in Figure 2)</i>.</p>
<ul>
	<li>A rotated ellipse with a linear gradient.</li>
	<li>A rectangle with a radial gradient.</li>
	<li>A filled cubic Bezier curve with two Bezier segments inside a filled 
	polygon.</li>
	<li>A filled quadratic Bezier curve with two Bezier segments inside a filled 
	polyline that is partially transparent.</li>
	<li>A filled elliptical arc with no rotation.</li>
	<li>A filled elliptical arc with a rotation of 45 degrees.</li>
</ul>
<p><font color="#FF0000"><b>Some more text content</b></font></p>
<p>After drawing the graphic elements, the program places the following text 
content in a paragraph element below the graphic elements at the end of the body 
element.</p>
<p><pre><b>There is a graphic above here.</b></pre></p>
<p>Finally, the program writes the output into an XHTML file named <b>
Svg18.xhtml</b> that can be rendered using an SVG graphics engine such a Firefox 
2.0.0.4.</p>
<p><font color="#FF0000"><b>The significance of <i>Scalable</i> in Scalable 
Vector Graphics</b></font></p>
<p>You will notice that the output from <b>Svg18</b> shown in Figure 2 is a 
scaled down version of the output from <b>Svg17</b> shown in Figure 1, with HTML 
text inserted before and after the graphic image.&nbsp; The fact 
that the SVG graphic image can be scaled with no loss in quality illustrates the 
significance of the word <i>Scalable</i> in the name Scalable Vector Graphics <i>
(SVG)</i>.</p>
<p>At this point, I am going to take a short side trip and show you some other 
examples that illustrate the significance of the word <i>Scalable</i>, 
particularly in contrast with bit mapped graphics.</p>
<p>Figure 3 shows a small graphic image containing a blue cubic Bezier curve and 
in a yellow background and a radial gradient in a rectangle.&nbsp; This drawing 
was produced using a program similar to <b>Svg17</b>.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Drawing with a Bezier curve and a radial 
	gradient. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b01.jpg" width="117" height="60"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Enlarge the bit mapped image</b></font></p>
<p>I captured the image shown in Figure 3 as a bit mapped JPEG image using a standard screen 
capture program.&nbsp; Then I enlarged the bit mapped image by a factor of four, 
producing the result shown in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Bit mapped image enlarged by a factor of 
	four. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b02.jpg" width="460" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you would expect <i>(if you are familiar with the limitations of bit 
mapped images)</i> the results aren't very pleasing.&nbsp; To make a long story 
short, bit mapped images aren't very scalable, at least insofar as enlargement 
is concerned.</p>
<p><font color="#FF0000"><b>Enlarge the SVG drawing by a factor of four</b></font></p>
<p>Figure 5 shows the result of increasing the size of the SVG drawing by the 
same factor of four.&nbsp; This result shows the significance of the word <i>
Scalable</i> in the name Scalable Vector Graphics <i>(SVG)</i>.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. SVG drawing enlarged by a factor of four. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b03.jpg" width="461" height="230"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Import degradation.</b><br />
There is a small amount of degradation showing in Figure 5.&nbsp; That 
degradation was introduced by the process of capturing the image from the screen 
as a JPEG image and importing it into this document.&nbsp; That degradation did 
	not exist in the original rendered version of the drawing in the Firefox 
	2.0.0.4 
	browser window.</td></tr></table>
</td>
</tr>
</table>

The quality of the scaled image in Figure 5 is excellent.&nbsp; No 
degradation in image quality was introduced by enlarging the SVG drawing.</p>
<p><font color="#FF0000"><b>Enlarge the SVG drawing by a factor of sixteen</b></font></p>
<p>To drive home the point that scaling the SVG drawing does not degrade the 
quality of the drawing, Figure 6 and Figure 7 show captured portions of the 
drawing produced by enlarging the original drawing shown in Figure 3 by a factor of sixteen.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Svg drawing enlarged by a factor of 
	sixteen. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b04.jpg" width="459" height="451"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that because I am limited as to the width of images that I can publish 
on this web site, I was unable to publish the entire enlarged drawing.&nbsp; 
Therefore, it was necessary for me to capture and publish portions of the 
drawing that was enlarged by a factor of sixteen.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Svg drawing enlarged by a factor of 
	sixteen. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b05.jpg" width="456" height="452"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, the small amount of degradation that you can see in Figure 6 and 
Figure 7 did not exist in the original rendering of the drawing in the Firefox 
2.0.0.4 browser window.&nbsp; That degradation was introduced by the process of 
capturing the image from the screen as a JPEG image and importing it into this 
document.</p>
<p><font color="#FF0000"><b>Could continue to enlarge indefinitely</b></font></p>
<p>I could continue this process of enlarging the SVG drawing indefinitely and 
no degradation would be introduced into the drawing.&nbsp; That is the true 
significance of the word <i>Scalable</i> in the name Scalable Vector Graphics <i>
(SVG)</i>.</p>
<p><font color="#FF0000"><b>What about the bit mapped image?</b></font></p>
<p>To drive home the point that bit mapped images are not scalable, Figure 8 shows the result of enlarging the original bit mapped image 
from Figure 3 by a factor of sixteen and capturing a portion of the enlarged 
image for publication in this lesson.</p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Bit mapped image enlarged by a factor of 
	sixteen.</b><table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2224b06.jpg" width="460" height="449"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The image shown in Figure 8 is approximately the same portion of the enlarged 
image as that shown in Figure 6.&nbsp; However, because of the poor quality of 
the enlarged bit mapped image, it was not possible for me to identify and capture the exact same 
portion.</p>
<p>As you can see, bit mapped images are not scalable in the same way that SVG 
drawings are scalable.</p>
<p><font color="#FF0000"><b>Program Testing</b></font></p>
<p>The program was tested using J2SE 6.0, JDOM 1.0, and Firefox 2.0.0.4 running 
under WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will present and explain this program in fragments.&nbsp; You can view the 
program in its entirety in Listing 31 near the end of the lesson.&nbsp; Much of 
the code in this program is the same as, or very similar to code that I have 
explained in this or other lessons.&nbsp; I will skip over that code and won't 
repeat those explanations here.</p>
<p><font color="#FF0000">
<b>The namespace URI</b></font></p>
<p>The program class and the <b>main</b> method both begin in Listing 20.&nbsp; 
This class begins pretty much like the class for the programs named <b>Svg17</b>
<i>(see the listing for <b>Svg17</b> in Listing 30 near the end of the lesson)</i>. 
Both programs begin by creating a <b>String</b> variable that contains a 
namespace URI.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. The namespace URI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>Svg18</b>{
  
  public static void <b>main</b>(String[] args){
    String xns = "<b>http://www.w3.org/1999/xhtml</b>";
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is one major difference, however.&nbsp; The namespace URI for the 
program named <b>Svg17</b> is as follows:</p>
<pre><b>http://www.w3.org/2000/svg</b></pre>
<p>This is different from the namespace URI shown in Listing 20 above.&nbsp; The 
difference is that the namespace for the program named <b>Svg17</b> is 
appropriate for an SVG file, but is not correct for an XHTML file.&nbsp; The 
namespace URI shown in Listing 20 is the correct namespace for an XHTML file.&nbsp;
<i>(<a name="In_fact,_the_SVG_namespace_URI">In fact, the SVG namespace URI</a> 
will also show up <a href="#Specify_the_SVG_namespace">later</a> in this 
program, because this program produces an XHTML file that contains SVG code.)</i></p>
<p><font color="#FF0000">
<b>Specify DTD information</b></font></p>
<p>The program named <b>Svg18</b> continues in Listing 21 by specifying the name of<br>
the element that is constrained by the DTD <i>(the <b>html</b> root element)</i>, the Public ID of the DTD, and the System ID of the DTD.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Specify DTD information. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //For clarity, create strings containing the name of
    // the element that is constrained by the DTD (the
    // html root element), the Public ID of the DTD, and 
    // the System ID of the DTD.
    String dtdConstrainedElement = "html";
    String dtdPublicID = 
                 "-//W3C//DTD XHTML 1.0 Transitional//EN";
    String dtdSystemID = "http://www.w3.org/TR/xhtml1/"
                          + "DTD/xhtml1-transitional.dtd";</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, the approach is the same, but the three values are different from 
the corresponding values for the SVG file that was created in Listing 30.&nbsp; 
The root node for an SVG file is named <b>svg</b>, whereas the root node for an 
XHTML file is named <b>html</b>.&nbsp; Similarly, the DTD information for an 
XHTML file is different from the DTD information for an SVG file.</p>
<p><font color="#FF0000">
<b>Create the Document node</b></font></p>
<p>Following this, the code in Listing 22:</p>
<ul>
	<li>Creates the <b>DocType</b> node based on the correct DTD information for 
	an XHTML file.</li>
	<li>Creates the root node named <b>html</b>, which is the required name for 
	the root node in an XHTML document.</li>
	<li>Creates the <b>Document</b> node on the basis of the root node and the 
	DocType node that are correct for an XHTML document.</li>
</ul>
<p>
<b><a name="Listing_22">Listing 22</a>. Create the Document node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create the DTD declaration node.
    DocType docType = new DocType(
           dtdConstrainedElement,dtdPublicID,dtdSystemID);

    //Create the XHTML root node named html.
    Element html = JdomSvg.<b>makeXhtmlRoot</b>(xns);
    
    //Create the document node.
    Document doc = new Document(html,docType);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that Listing 22 calls the new <b>makeXhtmlRoot</b> method to create the 
XHTML root node named <b>html</b>.&nbsp; This method is very similar to the 
method named <b>makeSvg</b>, so it shouldn't require any explanation beyond the 
embedded comments.</p>
<p><font color="#FF0000"><b>Create optional and required elements</b></font></p>
<p>The root node for an XHTML document must be named <b>html</b>.&nbsp; The <b>
html</b> element must have a child element named <b>body</b>.&nbsp; The <b>html</b> 
element may also have a child element named <b>head</b>, which in turn may have 
a child element named <b>title</b>.&nbsp; <i>(I believe, but am not certain, 
that these latter two elements are optional.)</i></p>
<p>Listing 23 calls the <b>makeNode</b> method that I explained earlier in this 
lesson to create these head, title, and body nodes.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. Create optional and required elements. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element head = JdomSvg.<b>makeNode</b>(html,xns,"head",null);
    Element title = JdomSvg.<b>makeNode</b>(
                                   head,xns,"title",null);
    title.<b>setText</b>("XHTML/SVG Graphic Demo.");
                         
    Element body = JdomSvg.<b>makeNode</b>(html,xns,"body",null);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 23 also calls the <b>setText</b> method to populate the <b>title</b> 
element with text content that describes the program.</p>
<p><font color="#FF0000">
<b>Create a paragraph node</b></font></p>
<p>Listing 24 calls the <b>makeNode</b> method to create a paragraph <i>(<b>p</b>)</i> 
node and attach it to the <b>body</b> node.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Create a paragraph node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element temp = JdomSvg.<b>makeNode</b>(body,xns,"<b>p</b>",null);
    temp.<b>setText</b>("There is a graphic below here.");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 24 calls the <b>setText</b> method to add text content to the <b>
p</b> node.&nbsp; This is the text that appears above the graphic in Figure 2.</p>
<p><font color="#FF0000"><b>Switch your thinking into graphics mode</b></font></p>
<p>Now you need to switch your thinking into graphics mode.&nbsp; At this point, 
the program creates a complete SVG graphic sub-tree with a root named <b>svg</b> 
and attaches it as a child of the <b>body</b> node.&nbsp; In the end, the <b>
body</b> node will have three child nodes.&nbsp; One of them is the <b>p</b> 
node that was created and populated in Listing 24.&nbsp; A second one is another
<b>p</b> node that will be attached to the <b>body</b> node later, and 
represents the HTML text that is visible below the graphic in Figure 2.&nbsp; 
The third child is an <b>svg</b> node, which forms the root of a complete SVG 
graphics sub-tree.</p>
<p><font color="#FF0000">
<b><a name="Specify_the_SVG_namespace">Specify the SVG namespace</a></b></font></p>
<p>The process of attaching an SVG sub-tree as a child of the <b>body</b> node 
begins in Listing 25.&nbsp; This code should look familiar.&nbsp; The single 
statement in Listing 25 creates a <b>String</b> variable containing the SVG 
namespace URI.&nbsp; <i>(I told you <a href="#In_fact,_the_SVG_namespace_URI">
earlier</a> that this was going to happen.)</i></p>
<p>
<b><a name="Listing_25">Listing 25</a>. Specify the SVG namespace. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    String ns = "<b>http://www.w3.org/2000/svg</b>";</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The significance of the word <i>Scalable</i> in 
Scalable Vector Graphics <i>(SVG)</i></b></font></p>
<p>This program creates and displays exactly the same graphics elements that 
were created and displayed by the earlier program named <b>Svg17</b>.&nbsp; 
However, the physical size of the canvas in this program was reduced to 
75-percent of its size in the earlier program for the purpose of demonstrating 
the significance of the word <i>Scalable</i> in the name Scalable Vector 
Graphics <i>(SVG)</i>.&nbsp; </p>
<p>The code that accomplishes the scaling is shown in Listing 26, where a scale 
factor of 0.75 was applied to the canvas dimensions used in the earlier program 
named <b>Svg17</b>.</p>
<p>With SVG, just about any scale factor can be applied to change the physical 
dimensions of the canvas.&nbsp; As long as the pixel granularity of the display 
screen is not a factor, changing the size of the physical dimensions of the 
canvas, and hence the physical size of the graphic images being drawn, will not 
degrade the graphic quality of those images.</p>
<p>
<b><a name="Listing_26">Listing 26</a>. Scaling the drawing. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Physical dimensions of the graphic on the screen.
    int svgWidth = (int)(460*0.75);
    int svgHeight = (int)(552*0.75);

    //Virtual dimensions of the graphic in user units.
    int viewBoxWidth = 500;
    int viewBoxHeight = 500*svgHeight/svgWidth;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 26 also establishes the virtual dimensions of the canvas through the 
use of the <b>viewBox</b> attribute.&nbsp; It is important to note that because 
of the use of virtual dimensions implemented through the use of the <b>viewBox</b>, 
it was not necessary to modify any of the SVG graphics code to accommodate the 
reduction in the overall physical size of the graphics elements.</p>
<p><font color="#FF0000">
<b>Create the svg root and attach as a child to body</b></font></p>
<p>Listing 27 calls the <b>makeSvg</b> method to create the node named <b>svg</b>.&nbsp; 
This node forms the root of a complete SVG graphics sub-tree.&nbsp; Then Listing 
27 attaches that root node as a child of the <b>body</b> node, causing it to 
become the second of three child nodes belonging to the <b>body</b> node.</p>
<p>
<b><a name="Listing_27">Listing 27</a>. Create the svg root and attach as a 
child to body. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create the SVG root element named svg.
    Element svg = JdomSvg.<b>makeSvg</b>(ns,
                                  svgWidth,
                                  svgHeight,
                                  viewBoxWidth,
                                  viewBoxHeight);

    body.<b>addContent</b>(svg);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Write the SVG graphics code</b></font></p>
<p>At this point, the program begins creating actual SVG graphics elements.&nbsp; 
With the exception of the changes in the physical dimensions of the graphic on 
the screen as implemented above, the graphics code in this program is the same 
as the code in the earlier program named <b>Svg017</b>.&nbsp; Therefore, I will 
skip to the end of the graphics code.</p>
<p><font color="#FF0000">
<b>Create the second paragraph node</b></font></p>
<p>Having skipped all of the graphics code that draws the graphic image in 
Figure 2, Listing 28 creates a second <b>p</b> node and attaches it as a child 
of the <b>body</b> node.&nbsp; If you were to examine the XHTML code produced by 
this program, you would see that the first <b>p</b> node occurs at the beginning 
of the <b>body</b> node.&nbsp; This is followed by the <b>svg</b> node, which is 
the root for a complete SVG graphics sub-tree.&nbsp; The <b>svg</b> node is 
followed in turn by the <b>p</b> node that is created and attached to the <b>
body</b> node in Listing 28.</p>
<p>
<b><a name="Listing_28">Listing 28</a>. Create the second paragraph node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create a paragraph element containing text content
    // and place it at the end of the body element.
    temp = JdomSvg.<b>makeNode</b>(body,xns,"p",null);
    temp.<b>setText</b>("There is a graphic above here.");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The result is that the text from the first <b>p</b> node is displayed above 
the graphic image in Figure 2, and the second <b>p</b> node is displayed below 
the graphic image in Figure 2.</p>
<p><font color="#FF0000">
<b>Write the output file</b></font></p>
<p>Listing 28 calls the <b>writePrettyFile</b> method to write the raw SVG/XML 
output to a file named Svg18.xhtml.&nbsp; I explained the <b>writePrettyFile</b> 
method earlier, so no further explanation should be required.</p>
<p>
<b><a name="Listing_29">Listing 29</a>. Write the output file named Svg18.xhtml. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>     //Write the output file. Note that this is an XHTML
     // file and not an SVG file.
    JdomSvg.<b>writePrettyFile</b>("Svg18.xhtml",doc);
    //JdomSvg.writeCompactFile("Svg18.svg",doc);
    
  }//end main

}//end class Svg18</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The end of the program</b></font>.</p>
<p>Listing 28 signals the end of the <b>main</b> method, the end of the class 
named <b>Svg18</b>, and the end of my explanation of the program named <b>Svg18</b>.</p>
<h3><a name="The_program_named_Svg19">The program named Svg19</a></h3>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>The program named <b>Svg18</b> was a stand alone desktop program that used 
JDOM to produce an output XHTML file with embedded SVG/XML code.&nbsp; That SVG 
code can be rendered by loading the file into an SVG graphics engine such as 
Firefox 2.0.0.4.</p>
<p>The purpose of this program is to convert <b>Svg18</b> into a servlet that 
will deliver XHTML code with the same embedded SVG/XML code to a client browser.&nbsp; 
The SVG/XML code should be properly rendered when the servlet is accessed using 
an SVG capable browser such as Firefox 2.0.0.4.</p>
<p><font color="#FF0000"><b>Steps for making the conversion</b></font></p>
<p>In this case, I will not discuss the program in fragments.&nbsp; Rather, I 
will simply present the program in its entirety in Listing 32 and explain the 
steps that were required to</p>
<ul>
	<li>Prepare the server for execution 
of the JDOM servlet.</li>
	<li>Convert the desktop program named <b>Svg18</b> into 
the servlet program named <b>Svg19</b></li>
</ul>
<p>The following steps were required:</p>
<ol>
	<li>Copy the <b>jdom.jar</b> file into the proper location on the server.&nbsp; 
	On my jakarta-tomcat server running as a localhost server, the proper 
	location was:
	<b><br>
	<br>
	C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\lib<br>
	<br>
	</b>This assumes that the servlet class files 
	are copied into:<br>
	<br><b>C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\classes<br>
&nbsp;</b></li>
	<li>Declare the following import directives in <b>Svg19</b>:<br>
	<br><b>import javax.servlet.*;<br>
	import javax.servlet.http.*;<br>
&nbsp;</b></li>
	<li>Declare that the class named <b>Svg19</b> extends the <b>HttpServlet</b> 
	class.<br>
&nbsp;</li>
	<li>Replace the signature for the <b>main</b> method in <b>Svg18</b> with the following 
	signature for the <b>doGet</b> method in <b>Svg19</b>:<br>
	<br><b>public void doGet(HttpServletRequest req,<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpServletResponse res)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ServletException,IOException{<br>
&nbsp;</b></li>
	<li>Execute the following statement to set the content type delivered by the 
	servlet.<br>
	<br><b>res.setContentType(&quot;image/svg+xml&quot;);<br>
&nbsp;</b></li>
	<li>In order to cause the servlet to send the output to the client browser 
instead of writing it to a file, I defined the following new methods and placed 
them in the <b>JdomSvg</b> graphics library class:<br>
	<br><b>writePrettyPrintWriter(PrintWriter out,Document doc)<br>
	writeCompactPrintWriter(PrintWriter out,Document doc)<br>
&nbsp;</b></li>
	<li>Use the following expression to get an output stream to be used by the 
	<b>XMLOutputter</b> object to send the output data to the client browser:<br>
	<br><b>res.getWriter()<br>
	<br>
	</b>Depending on whether I wanted a pretty-print format or a compact format, I 
modified an output statement from the <b>main</b> method of <b>Svg18</b> to 
match one of the following statements:<br>
	<br><b>JdomSvg.writePrettyPrintWriter(res.getWriter(),doc);<br>
	JdomSvg.writeCompactPrintWriter(res.getWriter(),doc);</b></li>
	</ol>
	<p></p>

<p>It was not necessary or me to make any other changes to the program named <b>Svg18</b> 
to convert it into the servlet program.&nbsp; <i>(See the program named <b>Svg18</b> 
for additional comments regarding the program.)</i></p>

	<p><font color="#FF0000"><b>Program testing</b></font></p>
	<p>Having deployed the servlet on my localhost server, I can execute the 
	servlet by starting the server running and accessing the servlet using 
	Firefox 2.0.0.4 at:</p>
<p><b>http://localhost/servlet/Svg19</b></p>
	<p>The program was tested using J2SE 6.0, JDOM 1.0, Firefox 2.0.0.4, and 
jakarta-tomcat-5.0.27 running as a localhost server under WinXP.</p>
<p>That concludes the discussion of the program named <b>Svg19</b>.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
	<p>I encourage you to download and install the JDOM API.&nbsp; Then copy the 
	code from Listing 30 through Listing 32 into your text editor.&nbsp; Compile the code 
	and execute it.&nbsp; Deploy <b>Svg19</b> on a server, being careful to make 
	certain that the server is compatible with JDOM.&nbsp; View the output files 
	in an SVG graphics engine such as Firefox 2.0.0.4.&nbsp; Experiment with the code, 
	making changes, and observing the results of your changes.</p>
	<p>Above all, enjoy the process. Programming, particularly graphics 
	programming, can be fun if you approach it with a positive attitude.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In Part 2 of this two-part tutorial, you learned how to expand the JDOM/SVG 
graphics library to include gradients, Bézier curves, and elliptical arcs.&nbsp; You 
learned about the significance of the word <i>Scalable</i> in Scalable Vector 
Graphics (SVG).&nbsp; You learned how to use JDOM to write XHTML output files 
containing SVG/XML code.&nbsp; Finally, you learned how to use JDOM to write Java 
servlets that deliver XHTML output containing SVG/XML code.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>Future lessons in this series will teach you how to write SVG programs that 
deal with the following SVG topics:</p>
<ul>
	<li>The text element.</li>
	<li>Bit-mapped images in SVG.</li>
	<li>How to create and re-use graphics elements.</li>
	<li>How to use SVG symbols.</li>
	<li>Stroke caps in SVG in comparison with similar caps in Java 2D.</li>
	<li>The switch element in SVG.</li>
	<li>Other features of SVG, such as animation.</li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<p><b>Java 2D Graphics</b><br>
<a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D Graphics, 
Nested Top-Level Classes and Interfaces&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D Graphics, 
The Point2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D Graphics, 
The Graphics2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D Graphics, 
Simple Affine Transforms&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D Graphics, 
The Shape Interface, Part 1&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D Graphics, 
The Shape Interface, Part 2&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D Graphics, 
Solid Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D Graphics, 
Gradient Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D Graphics, 
Texture Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D Graphics, 
The Stroke Interface&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D Graphics, 
The Composite Interface and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D Graphics, 
The Composite Interface, GradientPaint, and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D Graphics, 
The Color Constructors and Transparency<br>
<a href="http://java.sun.com/j2se/1.5.0/docs/guide/2d/spec.html">Java 2D API 
Specification</a><br>
<a href="http://java.sun.com/products/java-media/2D/">Java 2D API</a></p>
<p><b>Java API for XML Processing (JAXP)</b><br>
<a href="http://www.developerva/other/article.php/3099751">2200</a> Java API for 
XML Processing (JAXP), Getting Started<br>
<a href="http://www.developer.com/xml/article.php/3113351">2202</a> Getting 
Started with Java JAXP and XSL Transformations (XSLT)<br>
<a href="http://www.developer.com/java/other/article.php/3292751">2204</a> Java 
JAXP, Exposing a DOM Tree<br>
<a href="http://www.developer.com/java/other/article.php/3313341">2206</a> Java 
JAXP, Implementing Default XSLT Behavior in Java<br>
<a href="http://www.developer.com/java/other/article.php/3361261">2208</a> Java 
JAXP, Writing Java Code to Emulate an XSLT Transformation<br>
<a href="http://www.developer.com/java/data/article.php/3398741">2210</a> Java 
JAXP, Transforming XML to XHTML<br>
<a href="http://www.dickbaldwin.com/tocxml.htm">Links to numerous XML tutorials 
by Richard G. Baldwin</a><br>
<br>
<b>Scalable Vector Graphics (SVG)</b><br>
<a href="http://www.developer.com/java/other/article.php/3655506">2212</a> Java 
JAXP, Creating graphics using Java and SVG<br>
<a href="http://www.developer.com/java/other/article.php/3665131">2214</a> An 
improved approach for creating SVG/XML code and SVG/XML DOM nodes using Java<br>
<a href="http://www.developer.com/java/data/article.php/3676331">2216</a> Using 
Java to produce SVG code in XHTML data<br>
<a href="http://www.developer.com/java/ent/article.php/3684126">2218</a> Writing 
Java servlets to produce XHTML code that references external SVG files<br>
<a href="http://www.developer.com/java/other/article.php/3689251">2220</a> Drawing grids, Bézier curves and elliptical arcs using Java and SVG<br>
<a href="2222%20Graphics,%20using%20Java%20and%20JDOM%20with%20SVG,%20Part%201,%2007/31/07,%20http:/www.developer.com/java/other/article.php/3690511">2222</a> Graphics, using Java and JDOM with SVG, Part 1<br>
<a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a><br>
<a href="http://www.adobe.com/svg/">Adobe SVG Viewer plug-in</a><br>
<a href="https://www6.software.ibm.com/developerworks/education/x-svggraphics/index.html">
Create vector graphics in the browser with SVG</a> by Uche Ogbuji<br>
<a href="http://www.w3schools.com/svg/default.asp">SVG Tutorial</a><br>
<a href="http://www.svgbasics.com/shapes.html">SVG Basics</a><br>
<a href="http://www.carto.net/papers/svg/samples/svg_html.shtml">SVG in HTML 
pages</a></p>
<p><b>Bézier Curves<br>
</b><a href="http://www.moshplant.com/direct-or/bezier/index.html">What's a 
Bézier Curve?</a><br>
<a href="http://en.wikipedia.org/wiki/Bézier_curve">Wikipedia, Bézier curve</a><br>
<a href="http://www.math.ucla.edu/~baker/java/hoefer/Bezier.htm">Bézier Curve 
Demo</a></p>
<p><b>Miscellaneous<br>
</b><a href="http://validator.w3.org/file-upload.html">W3C Markup Validation 
Service</a><br>
<a href="http://www.xmlvalidation.com/">XMLvalidation.com</a><br>
<a href="http://regentsprep.org/Regents/Math/coreflec/reflect.htm">Reflection in 
a Line</a><br>
<a href="http://regentsprep.org/Regents/Math/reflect/Lreflect.htm">An Intuitive 
Notion of Line Reflections</a></p>
<p><b>JDOM</b><br>
<a href="http://www.jdom.org/">JDOM Main Page</a><br>
<a href="http://www-128.ibm.com/developerworks/java/library/j-jdom/">Simplify 
XML programming with JDOM</a><br>
<a href="http://www.topxml.com/tutorials/main.asp?id=jdom">Interactive Java &amp; 
JDOM Online Tutorial</a><br>
<a href="http://www.javaworld.com/javaworld/jw-05-2000/jw-0518-jdom_p.html">Easy 
Java/XML integration with JDOM</a><br>
<a href="http://en.wikipedia.org/wiki/JDOM">Wikipedia, JDOM</a><br>
<a href="http://www.cafeconleche.org/books/xmljava/chapters/ch14.html">Chapter 
14</a> (JDOM) of Elliotte Rusty Harold's book, <i>Processing XML with Java<br>
</i><a href="http://www.cafeconleche.org/books/xmljava/chapters/ch15.html">
Chapter 15</a> (The JDOM Model) of Elliotte Rusty Harold's book, <i>Processing 
XML with Java</i>.</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
30 through Listing 32 below.
<p>
<b><a name="Listing_30">Listing 30</a>. Program code for Svg17. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg17.java,
Copyright 2007, R.G.Baldwin

The program named Svg16 began the development of a
Java/JDOM/SVG graphics library of my own design named
JdomSvg, which eliminates much of the effort involved in 
writing Java programs to produce SVG files using JDOM as 
an alternative to the standard Sun DOM classes and 
methods.

The purpose of this program is add the following methods
to that graphics library and to demonstrate their use.

makeGridString
makePath
makeNode
makeLinearGradient
makeRadialGradient
makeGradientStop
makeText

The program draws the following graphics elements on a 
background that looks like graph paper. and writes the 
output into an SVG file that can be rendered using an SVG 
graphics engine such a Firefox 2.0.0.4:

* A rotated ellipse with a linear gradient.
* A rectangle with a radial gradient.
* A filled cubic Bezier curve with two Bezier segments
  inside a filled polygon.
* A filled quadratic Bezier curve with two Bezier segments
  inside a filled polyline that is partially transparent.
* A filled elliptical arc with no rotation.
* A filled elliptical arc with a rotation of 45 degrees.

The output file validates at: 

http://validator.w3.org/

Tested using J2SE 6.0, JDOM 1.0, and Firefox 2.0.0.4
running under WinXP.
*********************************************************/
import java.io.*;
import org.jdom.*;
import org.jdom.output.XMLOutputter;
import org.jdom.output.Format;
public class Svg17{
  
  public static void main(String[] args){
    //Create a String variable containing the namespace
    // URI to reduce the amount of typing that is required
    // later. Note that the variable name is short and
    // easy to type.
    String ns = "http://www.w3.org/2000/svg";
    
    //For clarity, create strings containing the name of
    // the element that is constrained by the DTD (the
    // root element), the Public ID of the DTD, and the
    // System ID of the DTD.
    String dtdConstrainedElement = "svg";
    String dtdPublicID = "-//W3C//DTD SVG 1.1//EN";
    String dtdSystemID = 
       "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd";

    //Physical dimensions of the graphic on the screen.
    int svgWidth = 460;
    int svgHeight = 552;
    
    //Virtual dimensions of the graphic in user units.
    int viewBoxWidth = 500;
    int viewBoxHeight = 500*svgHeight/svgWidth;

    //Create the SVG root element named svg.
    Element svg = JdomSvg.makeSvg(ns,
                                  svgWidth,
                                  svgHeight,
                                  viewBoxWidth,
                                  viewBoxHeight);

    //Create the DTD declaration node.
    DocType docType = new DocType(
           dtdConstrainedElement,dtdPublicID,dtdSystemID);

    //Create the document node.
    Document doc = new Document(svg,docType);
    
    
    //Begin creating graphics elements.

    //Draw light green grid lines every 10 user units on
    // the basis of the virtual dimensions in user units..
    //First create the path data.
    String gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,10);

    //Create the path element and add it to the root.
    Element temp;
    temp = JdomSvg.makePath(svg,ns,gridData);
    //Set the color to a very light green.
    temp.setAttribute("stroke","#ccffcc");

    //Using the same procedure, draw darker green grid
    // lines every 50 user units and draw them on top of
    // the existing grid lines.
    gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,50);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#99ff99");
  
    //Draw even darker green grid lines every 100 user
    // units.
    gridData = JdomSvg.makeGridString(
                          viewBoxWidth,viewBoxHeight,100);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#22ff22");
    
    //Draw an even darker green border on the perimeter of
    // the grid.
    temp = JdomSvg.makeRect(svg,ns,1,1,
                          viewBoxWidth-2,viewBoxHeight-2);
    temp.setAttribute("stroke","#00ff00");
    temp.setAttribute("stroke-width","2");
    
    //Call the makeNode method to create a defs element
    // that will be the container for gradient
    // definitions.
    Element defs = JdomSvg.makeNode(svg,//parent
                                    ns,//namespace
                                    "defs",
                                    null//no attributes
                                    );
    
    //Define gradientA, which provides a linear gradient
    // that starts with yellow, changes to red, and
    // changes back to yellow going from left to right.
    Element gradientA = JdomSvg.makeLinearGradient(
                                         defs,//parent
                                         ns,//namespace
                                         "gradientA");//id
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientA and specify where the
    // colors begin and end, 
    JdomSvg.makeGradientStop(gradientA,//parent
                             ns,
                             "4%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,  
                             "50%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,
                            "96%",
                            "yellow");

    //Call the makeNode method to draw an ellipse. Fill it
    // with linear gradientA and rotate it by 30 degrees.
    // Note that I could have called the makeEllipse
    // method, but I wanted to demonstrate the use of the
    // more general makeNode method for a graphics element
    // that has several attributes.
    JdomSvg.makeNode(
            svg,//parent
            ns,
            "ellipse",//node type
            new String[]{"cx","150",
                         "cy","80",
                         "rx","100",
                         "ry","40",
                         "fill","url(#gradientA)",
                         "stroke","blue",
                         "stroke-width","3",
                         "opacity","0.5",
                         "transform","translate(150,80) "
                                   + "rotate(-30) "
                                   + "translate(-150,-80)"
                        }//end array definition
    );//end makeNode method
    
    //Note: Setting the opacity attribute value to 0.6 is
    // of no consequence when the output file is rendered
    // using Firefox 2.0.0.4.  The gradient continues to
    // be opaque.  However, this is a weakness in the
    // Firefox rendering engine and is not a limitation of
    // SVG.  When the file is rendered using an Adobe
    // rendering engine, the gradient is partially
    // transparent as it should be.
    
    //Define gradientB, which provides a radial gradient
    // that goes through yellow, red, green, and blue.
    // Use it to fill a rectangle.
    int rectCornerX = 300;
    int rectCornerY = 10;
    int rectWidth = 150;
    int rectHeight = 150;
    Element gradientB = JdomSvg.makeRadialGradient(
                               defs,//parent
                               ns,//namespace
                               "gradientB",//ID
                               "userSpaceOnUse",
                               rectCornerX,//cx
                               rectCornerY,//cy
                               ((int)(rectWidth*1.2)));//r
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientB and to specify where
    // the colors begin and end, 
    JdomSvg.makeGradientStop(gradientB,//parent
                             ns,//namespace
                             "10%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,  
                             "33%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "66%",
                            "green");
                            
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "96%",
                            "blue");
                            
    //Draw the rectangle and fill it with gradientB.
    temp = JdomSvg.makeRect(svg,
                            ns,
                            rectCornerX,
                            rectCornerY,
                            rectWidth,
                            rectHeight);
    temp.setAttribute("fill","url(#gradientB)");

    //Draw a cubic Bezier curve consisting of two Bezier
    // segments.  First draw a polygon that shows the
    // start points, the end points, and the control
    // points for the segments. Fill the polygon with
    // yellow to provide a background color for the 
    // Bezier curve.
    temp = JdomSvg.makePolygon(
                     svg,
                     ns,
                     new int[] {180,290,50,250,150,200,
                                150,400,250,350,120,310});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    
    //Draw the cubic curve. Note the use of absolute
    // coordinate values only and also the use of the S
    // command. Stroke the curve with red and fill it with
    // blue.
    temp = JdomSvg.makePath(svg,ns,"M180,290 C50,250,"
                    + "150,200,150,300 S250,350,120,310");
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","blue");
    
    //Draw a quadratic Bezier curve consisting of two
    // Bezier segments.  First draw a polyline that shows
    // the start points, the end points, and the control
    // points.  Fill the polyline with yellow color with
    // an opacity attribute value of 0.5.  This allows
    // the grid to show through the filled polyline.
    temp = JdomSvg.makePolyline(
                       svg,
                       ns,
                       new int[] {300,300,400,200,500,300,
                                  400,400,300,300});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    temp.setAttribute("opacity","0.5");

    //Draw the quadratic curve. Note the use of relative
    // coordinate values. Stroke the curve with a wide
    // red stroke and fill it with blue.
    temp = JdomSvg.makePath(svg,ns,
              "M300,300 q100,-100,200,0,-100,100,-200,0");

    temp.setAttribute("stroke","red");
    temp.setAttribute("stroke-width","3");
    temp.setAttribute("fill","blue");


    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with no rotation. Stroke it with
    // yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                        "M100,500 a70,30 0 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with a rotation of 45 degrees.
    // Stroke it with yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                       "M350,500 a70,30 45 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Label the grid. First label the vertical lines.
    for(int cnt = 0;cnt &lt; viewBoxWidth;cnt += 50){
      JdomSvg.makeText(
                     svg,ns,cnt,viewBoxHeight - 4,""+cnt);
    }//end for loop

    //Now label the horizontal lines.    
    for(int cnt = 0;cnt &lt; viewBoxHeight;cnt += 50){
      JdomSvg.makeText(svg,ns,3,cnt,""+cnt);
    }//end for loop
  
    //Label each of the graphic elements
    JdomSvg.makeText(svg,ns,50,180,
                          "Ellipse with linear gradient");
    JdomSvg.makeText(svg,ns,270,180,
                        "Rectangle with radial gradient");
    JdomSvg.makeText(svg,ns,100,420,
                                    "Cubic Bezier curve");
    JdomSvg.makeText(svg,ns,280,420,
                         "Quadratic Bezier with opacity");
    JdomSvg.makeText(svg,ns,50,555,
                       "Elliptical arc without rotation");
    JdomSvg.makeText(svg,ns,300,555,
                          "Elliptical arc with rotation");
    
    //End creation of graphics elements.
 
    //Write the output file.
    JdomSvg.writePrettyFile("Svg17.svg",doc);
    //JdomSvg.writeCompactFile("Svg17.svg",doc);
    
  }//end main
  //----------------------------------------------------//

}//end class Svg17
//======================================================//

//This is a graphics library that is designed to eliminate
// much of the effort involved in writing JDOM code to
// create SVG output. The library contains individual
// static methods that are used to construct and return
// many of the standard SVG graphics elements. It also
// contains a method named makeNode that can be used to
// create any graphic element.
//Many of the methods have default attribute values.  If
// you need different attribute values for a particular
// graphic element, you can call the setAttribute method
// on the returned value to change the attribute values 
// after the method returns.
//Many of the methods set the stroke attribute value to
// black and set the stroke-width attribute value to 1
// by default.  If you don't want to be able to see the
// outline of the shape, change the stroke-width attribute
// value to 0 after the method returns.
class JdomSvg{
  //----------------------------------------------------//

  //This method writes the XML code into an output file
  // in pretty-print format. The pretty-print format
  // is less efficient than the compact format, but it
  // is very useful during test and debugging because
  // you can view source in your browser and the XML
  // code will be reasonably well formatted.
  public static void writePrettyFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
               new XMLOutputter(Format.getPrettyFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//
  
  //This method writes the XML code into an output file
  // in whitespace-normalized format. This format is more
  // compact and efficient than the pretty-print format.
  public static void writeCompactFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
              new XMLOutputter(Format.getCompactFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//

  //This method constructs and returns a reference to an
  // SVG root element node named svg with a viewBox
  // attribute to map the virtual dimensions into the
  // physical dimensions of the canvas.
  //By default, the min-x and min-y attribute values of
  // the viewBox are set to 0 0 and the value of the
  // preserveAspectRatio is set to none.
  //The svg element represents the canvas on which
  // various shapes can be drawn. The width and height
  // attribute values of the svg element establish the
  // physical size of the canvas on the screen. The
  // values of the viewBox attribute establish the
  // size of the canvas in "user units."  The
  // dimensions of the viewbox map directly into the
  // dimensions of the canvas.  This makes it possible
  // for the programmer to work in dimensions that are
  // convenient, such as 1000x1000, instead of having
  // to work with less convenient dimensions such as
  // 459x459.
  //Setting the value of the preserveAspectRatio
  // attribute to none prevents the system from
  // attempting to automatically preserve the aspect
  // ratio.  In this case, it is probably a good idea
  // for the programmer to make the ratio of the height
  // and width of the viewbox the same as the ratio of
  // the height and width of the canvas. That way, a
  // circle will look like a circle instead of looking
  // like an ellipse.
  //Note that the root element node does not have a parent
  // like the other nodes. Rather, it is passed as a 
  // parameter to the constructor for the Document node in
  // order to establish its place in the tree.
  public static Element makeSvg(
                      String ns,//namespace URI
                      int svgWidth,//physical screen width
                      int svgHeight,//physical height
                      int vbWidth,//virtual width
                      int vbHeight//virtual height
                      ){
    Element svg = new Element("svg",ns);
    
    //Set default attribute values.
    svg.setAttribute("version","1.1");
    svg.setAttribute("preserveAspectRatio","none");
    String vbMinX = "0 ";
    String vbMinY = "0 ";
    
    //Set user-specified attribute values. Note the 
    // format that is required to construct the attribute
    // value for the viewBox. If you need to call the
    // setAttribute method after this method returns to
    // change the attribute value for the viewBox
    // attribute, you will need to comply with the format
    // requirements for that value.
    svg.setAttribute("width",""+svgWidth);
    svg.setAttribute("height",""+svgHeight);
    svg.setAttribute("viewBox",
             vbMinX + vbMinY + ""+vbWidth + " "+vbHeight);
    
    return svg;
  }//end makeSvg
  //----------------------------------------------------//
  
  //This method constructs and returns a description node
  // for a given namespace and a given parent.
  public static Element makeDescription(
              Element parent,//The parent of this element.
              String nameSpace,//The namespace.
              String text//Text content for this element.
              ){
    Element desc = new Element("desc",nameSpace);
    parent.addContent(desc);
    desc.setText(text);

    return desc;
  }//end makeDescription
  //----------------------------------------------------//
  
  //This method constructs and returns a comment node
  // for a given parent.
  public static Comment makeComment(
              Element parent,//The parent of this element.
              String text//Text content for this element.
              ){
    Comment comment = new Comment(text);
    parent.addContent(comment);

    return comment;
  }//end makeComment
  //----------------------------------------------------//

  //This method constructs and returns a rect node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none. Setting the fill to none has the effect of
  // causing the shape to be totally transparent.
  public static Element makeRect(
                  Element parent,
                  String namespace,
                  int x,//Coordinate of upper-left corner.
                  int y,//Coordinate of upper-left corner.
                  int width,
                  int height
                  ){
    Element rect = new Element("rect",namespace);
    parent.addContent(rect);
    
    //Set default attribute values.
    rect.setAttribute("fill","none");
    rect.setAttribute("stroke","black");
    rect.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    rect.setAttribute("x",""+x);
    rect.setAttribute("y",""+y);
    rect.setAttribute("width",""+width);
    rect.setAttribute("height",""+height);
    
    return rect;
  }//end makeRect
  //----------------------------------------------------//

  //This method constructs and returns an ellipse node for
  // a given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeEllipse(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int rx,//Horizontal radius
                                int ry //Vertical radius
                                ){
    Element ellipse = new Element("ellipse",namespace);
    parent.addContent(ellipse);
    
    //Set default attribute vales
    ellipse.setAttribute("fill","none");
    ellipse.setAttribute("stroke","black");
    ellipse.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    ellipse.setAttribute("cx",""+cx);
    ellipse.setAttribute("cy",""+cy);
    ellipse.setAttribute("rx",""+rx);
    ellipse.setAttribute("ry",""+ry);
    
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This method constructs and returns a polyline node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polyline and a polygon
  // (see below) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  // While you may close a polyline if you cause the
  // coordinates of the last point to match the
  // coordinates of the first point, it is not
  // automatically closed as in the case of a polygon.
  //Be careful if you fill a polyline that is not closed.
  // The results may not be what you expect.
  static Element makePolyline(Element parent,
                              String namespace,
                              int[] points){//See above.
    Element polyline = new Element("polyline",namespace);
    parent.addContent(polyline);

    //Set default attributes
    polyline.setAttribute("stroke","black");
    polyline.setAttribute("stroke-width","1");
    polyline.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + " ";
    }//end for loop
    polyline.setAttribute("points",dataPoints);
    
    return polyline;
  }//end makePolyline
  //----------------------------------------------------//
  
  //This method constructs and returns a polygon node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polygon and a polyline
  // (see above) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  static Element makePolygon(Element parent,
                             String namespace,
                             int[] points){
    Element polygon = new Element("polygon",namespace);
    parent.addContent(polygon);
    
    //Set default attributes.
    polygon.setAttribute("stroke","black");
    polygon.setAttribute("stroke-width","1");
    polygon.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    polygon.setAttribute("points",dataPoints);

    return polygon;
  }//end makePolygon
  //----------------------------------------------------//
  
  //This method constructs and returns a line node for a
  // given parent in a given namespace.  By default,the
  // stroke is black and the stroke-width is 1.
  public static Element makeLine(
                                Element parent,
                                String namespace,
                                int x1,//Start coordinate
                                int y1,//Start coordinate
                                int x2,//End coordinate
                                int y2 //End coordinate
                                ){
    Element line = new Element("line",namespace);
    parent.addContent(line);
    
    //Set default attribute vales
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    
    return line;
  }//end makeLine
  //----------------------------------------------------//
  
  //This method constructs and returns a circle node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeCircle(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int r  //Radius
                                ){
    Element circle = new Element("circle",namespace);
    parent.addContent(circle);
    
    //Set default attribute vales
    circle.setAttribute("fill","none");
    circle.setAttribute("stroke","black");
    circle.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    circle.setAttribute("cx",""+cx);
    circle.setAttribute("cy",""+cy);
    circle.setAttribute("r",""+r);
    
    return circle;
  }//end makeCircle
  //----------------------------------------------------//
  
  //This is a utility method that is used to construct a
  // string that describes a grid pattern consisting of 
  // horizontal and vertical lines at a specified pixel
  // spacing for a rectangular area of a specified width
  // and height. The string is intended to be used as the
  // data string for a call to the method named makePath.
  //There is nothing about this method that is peculiar to
  // the use of JDOM.
  //Note that this method makes use of the special
  // horizontal and vertical lineto commands in an attempt
  // to reduce the download size and the bandwidth
  // requirements for a drawing containing a large number
  // of horizontal and vertical lines in the grid pattern.
  static String makeGridString(
                        int width,int height,int spacing){
    //Construct the data string for the vertical lines.
    String data = "M0,0 ";
    for(int cnt = 0;cnt &lt; width;cnt += spacing){
      data += "v" + height + " M" + cnt + ",0 ";
    }//end for loop
    //Add the final vertical line.
    data += "v" + height + " \n";
    
    //Now add the horizontal lines to the data string.
    data += "M0,0 ";
    for(int cnt = 0;cnt &lt; height;cnt += spacing){
      data += "h" + width + " M0," + cnt + " ";
    }//end for loop
    //Add the final horizontal line.
    data += "h" + width + "\n ";
    
    return data;

  }//end makeGridString
  //----------------------------------------------------//

  //This method returns a reference to a path. By
  // default, the stroke is set to black one pixel wide,
  // and the fill is set to none.
  //See the method named makeGridString for a utility
  // method that is designed to create the data string
  // for this method for the special case of drawing grids
  // that resemble graph paper. For other cases, simply
  // create a data string that is compatible with the SVG
  // path element.
  static Element makePath(Element parent,
                          String namespace,
                          String d){
    Element path  = new Element("path",namespace);
    parent.addContent(path);
    
    //Set default attribute values.
    path.setAttribute("stroke","black");
    path.setAttribute("stroke-width","1");
    path.setAttribute("fill","none");
    
    //Set user specified default values.
    path.setAttribute("d",d);
    return path;
  }//end makePath
  //----------------------------------------------------//
  
  /*The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
  
  The first parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node.
   
  The second parameter is a String that specifies the
   namespace for the element represented by the new node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
   If there are no attributes, the value of this parameter
   should be null.
  
  An example of the recommended usage of the method
   follows:
  Element abc = JdomSvg.makeNode(
                     parent,
                     namespace,
                     "NodeType",
                     new String[]{"name","value",
                                  "name","value",
                                  "name","value"
                                 });//end call to makeNode
  */
  static Element makeNode(Element parent,
                          String namespace,
                          String nodeType,
                          String[] data){

    Element element = new Element(nodeType,namespace);
    parent.addContent(element);
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    //Extract the values from the array and construct
    // each of the attributes and its value.
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//
  
  //This method creates a linear gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes in the same program scope.
  static Element makeLinearGradient(Element parent,
                                    String namespace,
                                    String id){
    Element gradient = 
                  new Element("linearGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient
  //----------------------------------------------------//
  
  //This method creates a radial gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes. See the SVG documentation for more
  // information on the various attributes of the radial
  // gradient element.
  static Element makeRadialGradient(Element parent,
                                    String namespace,
                                    String id,
                                    String gradientUnits,
                                    int cx,//center
                                    int cy,//center
                                    int r  //radius
                                    ){
    Element gradient = 
                  new Element("radialGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient
  //----------------------------------------------------//
  
  //This method creates a gradient stop node to be
  // appended to a linear gradient node or a radial
  // gradient node. See the SVG documentation for more
  // information on the various attributes of the gradient
  // stop element.                          
  static Element makeGradientStop(Element parent,
                                  String namespace,
                                  String offset,
                                  String color){
    Element stopElement = new Element("stop",namespace);
    parent.addContent(stopElement);
    
    stopElement.setAttribute("offset",offset);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop
  //----------------------------------------------------//
  
  //This method returns a reference to a text element
  // node. The x and y parameters specify the location of
  // the lower left corner of the first text character.
  static Element makeText(Element parent,
                          String namespace,
                          int x,
                          int y,
                          String text){
    Element textNode = new Element("text",namespace);
    parent.addContent(textNode);

    textNode.setAttribute("x",""+x);
    textNode.setAttribute("y",""+y);
    
    textNode.addContent(text);

    return textNode;
  }//end makeText
  //----------------------------------------------------//

}//end class JdomSvg
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<b><a name="Listing_31">Listing 31</a>. Program code for Svg18.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg18.java,
Copyright 2007, R.G.Baldwin

The intended primary purpose of this program was to use 
JDOM to embed SVG code into what would otherwise be a 
valid XHTML file.  

A secondary purpose of this program, in comparison with 
the earlier program named Svg017, was to demonstrate the
use of the word Scalable in the name Scalable Vector
Graphics (SVG).

The secondary purpose was achieved.  However, for the
reasons explained below, the primary purpose was not
completely achieved, because the output XHTML file is
not valid.

One of the advantages of embedding SVG code in an 
XHTML document is that it then becomes possible to place 
the graphic in and among other HTML elements.  That is not
possible when creating an SVG file.  That capability is 
demonstrated by this program.

However, my attempt to create a valid XHTML file using 
JDOM was not successful because the JDOM Element 
constructor insists on creating an xmlns attribute for 
children of the root html node. This is true even when 
the version of the constructor is used that doesn't take 
a namespace as a parameter.  Whether that version is used,
or the version that takes a namespace as a parameter is 
used by passing null for the namespace, the resulting XML 
code contains xmlns="". 

The DTD for XHTML doesn't allow for attributes named 
xmlns on the head and body elements. 

Note that the xmlns attribute is created even if I change 
the name of the child element from head to joe. I suspect,
but can't be sure that this is a bug in the version of 
the Element constructor that doesn't take a namespace 
parameter. The behavior of that version seems to be the 
same as passing null for the namespace to the version that
does take a namespace parameter.

Therefore, the output file produced by this program is 
not a valid XHTML file. Nonetheless, it renders very
successfully in Firefox 2.0.0.4.

The program named Svg16 began the development of a
Java/JDOM/SVG graphics library of my own design named
JdomSvg, which eliminates much of the effort involved in 
writing Java programs to produce SVG files using JDOM as 
an alternative to the standard Sun DOM classes and 
methods. Several new methods were added to that library in
the program named Svg017. Those methods were all 
associated with the creation of SVG/XML code.

I added the following method to the graphics library in 
this program:

* makeXhtmlRoot

This method has to do with ordinary XML elements 
that don't necessarily have anything to do with graphics,
but rather are involved in the creation of an XHTML file.

This program begins by placing the following text content 
in a paragraph element at the beginning of the body 
element.

"There is a graphic below here."

Then the program draws the following graphics elements on 
a background that looks like graph paper.

* A rotated ellipse with a linear gradient.
* A rectangle with a radial gradient.
* A filled cubic Bezier curve with two Bezier segments
  inside a filled polygon.
* A filled quadratic Bezier curve with two Bezier segments
  inside a filled polyline that is partially transparent.
* A filled elliptical arc with no rotation.
* A filled elliptical arc with a rotation of 45 degrees.

After drawing the graphic elements, the program places the
following text content in a paragraph element below the 
graphic elements at the end of the body element.

"There is a graphic above here."

Finally, the program writes the output into an XHTML file
named Svg18.xhtml that can be rendered using an SVG 
graphics engine such a Firefox 2.0.0.4.

Tested using J2SE 6.0, JDOM 1.0, and Firefox 2.0.0.4
running under WinXP.
*********************************************************/
import java.io.*;
import org.jdom.*;
import org.jdom.output.XMLOutputter;
import org.jdom.output.Format;
public class Svg18{
  
  public static void main(String[] args){

    //Create a String variable containing the XHTML
    // namespace URI to reduce the amount of typing that 
    // is required later. Note that the variable name is 
    // short and easy to type.
    String xns = "http://www.w3.org/1999/xhtml";
  
    //For clarity, create strings containing the name of
    // the element that is constrained by the DTD (the
    // html root element), the Public ID of the DTD, and 
    // the System ID of the DTD.
    String dtdConstrainedElement = "html";
    String dtdPublicID = 
                 "-//W3C//DTD XHTML 1.0 Transitional//EN";
    String dtdSystemID = "http://www.w3.org/TR/xhtml1/"
                          + "DTD/xhtml1-transitional.dtd";

    //Create the DTD declaration node.
    DocType docType = new DocType(
           dtdConstrainedElement,dtdPublicID,dtdSystemID);

    //Create the XHTML root node named html.
    Element html = JdomSvg.makeXhtmlRoot(xns);
    
    //Create the document node.
    Document doc = new Document(html,docType);

    //Add optional and required elements to the document
    // node, placing text content in the title node, 
    Element head = JdomSvg.makeNode(html,xns,"head",null);
    Element title = JdomSvg.makeNode(
                                   head,xns,"title",null);
    title.setText("XHTML/SVG Graphic Demo.");
                         
    Element body = JdomSvg.makeNode(html,xns,"body",null);

    //Put a paragraph element in the body element.
    Element temp = JdomSvg.makeNode(body,xns,"p",null);
    temp.setText("There is a graphic below here.");

    //Now switch your thinking into graphics programming
    // mode to place a large and fairly complex SVG
    // graphic in the body element.

    //Create a String variable containing the SVG
    // namespace URI to reduce the amount of typing that
    // is required later. Note that the variable name is
    // short and easy to type.
    String ns = "http://www.w3.org/2000/svg";

    //This program creates and displays exactly the same
    // graphics elements that were created and displayed
    // by the earlier program named Svg17.  However, the
    // physical size of the canvas in this program was
    // reduced to 75-percent of its size in the earlier
    // program for the purpose of demonstrating the use of
    // the word "Scalable" in the name Scalable Vector
    // Graphics (SVG).  Note also that because of the use
    // of virtual dimensions implemented through the use
    // of the viewBox, it was not necessary to modify any
    // of the SVG graphics code to accommodate the
    // reduction in the overall physical size of the
    // graphics elements.

    //Physical dimensions of the graphic on the screen.
    int svgWidth = (int)(460*0.75);
    int svgHeight = (int)(552*0.75);
    
    //Virtual dimensions of the graphic in user units.
    int viewBoxWidth = 500;
    int viewBoxHeight = 500*svgHeight/svgWidth;

    //Create the SVG root element named svg.
    Element svg = JdomSvg.makeSvg(ns,
                                  svgWidth,
                                  svgHeight,
                                  viewBoxWidth,
                                  viewBoxHeight);

    //The makeSvg method does not automatically add the
    // new node to a parent for reasons that are explained
    // in the method.  Therefore, it is necessary to add
    // the node to the parent outside of the makeSvg
    // method.
    body.addContent(svg);

    //Begin creating actual graphics elements.  With the
    // exception of the changes in the physical dimensions
    // of the graphic on the screen as implemented above,
    // the graphics code in this program is the same as
    // the code in the earlier program named Svg017.

    //Draw light green grid lines every 10 user units on
    // the basis of the virtual dimensions in user units.
    //First create the path data.
    String gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,10);

    //Create the path element and add it to the root.
    temp = JdomSvg.makePath(svg,ns,gridData);
    //Set the color to a very light green.
    temp.setAttribute("stroke","#ccffcc");

    //Using the same procedure, draw darker green grid
    // lines every 50 user units and draw them on top of
    // the existing grid lines.
    gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,50);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#99ff99");
  
    //Draw even darker green grid lines every 100 user
    // units.
    gridData = JdomSvg.makeGridString(
                          viewBoxWidth,viewBoxHeight,100);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#22ff22");
    
    //Draw an even darker green border on the perimeter of
    // the grid.
    temp = JdomSvg.makeRect(svg,ns,1,1,
                          viewBoxWidth-2,viewBoxHeight-2);
    temp.setAttribute("stroke","#00ff00");
    temp.setAttribute("stroke-width","2");
    
    //Call the makeNode method to create a defs element
    // that will be the container for gradient
    // definitions.
    Element defs = JdomSvg.makeNode(svg,//parent
                                    ns,//namespace
                                    "defs",
                                    null//no attributes
                                    );
    
    //Define gradientA, which provides a linear gradient
    // that starts with yellow, changes to red, and
    // changes back to yellow going from left to right.
    Element gradientA = JdomSvg.makeLinearGradient(
                                         defs,//parent
                                         ns,//namespace
                                         "gradientA");//id
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientA and specify where the
    // colors begin and end, 
    JdomSvg.makeGradientStop(gradientA,//parent
                             ns,
                             "4%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,  
                             "50%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,
                            "96%",
                            "yellow");

    //Call the makeNode method to draw an ellipse. Fill it
    // with linear gradientA and rotate it by 30 degrees.
    // Note that I could have called the makeEllipse
    // method, but I wanted to demonstrate the use of the
    // more general makeNode method for a graphics element
    // that has several attributes.
    JdomSvg.makeNode(
            svg,//parent
            ns,
            "ellipse",//node type
            new String[]{"cx","150",
                         "cy","80",
                         "rx","100",
                         "ry","40",
                         "fill","url(#gradientA)",
                         "stroke","blue",
                         "stroke-width","3",
                         "opacity","0.5",
                         "transform","translate(150,80) "
                                   + "rotate(-30) "
                                   + "translate(-150,-80)"
                        }//end array definition
    );//end makeNode method
    
    //Note: Setting the opacity attribute value to 0.6 is
    // of no consequence when the output file is rendered
    // using Firefox 2.0.0.4.  The gradient continues to
    // be opaque.  However, this is a weakness in the
    // Firefox rendering engine and is not a limitation of
    // SVG.  When the file is rendered using an Adobe
    // rendering engine, the gradient is partially
    // transparent as it should be.
    
    //Define gradientB, which provides a radial gradient
    // that goes through yellow, red, green, and blue.
    // Use it to fill a rectangle.
    int rectCornerX = 300;
    int rectCornerY = 10;
    int rectWidth = 150;
    int rectHeight = 150;
    Element gradientB = JdomSvg.makeRadialGradient(
                               defs,//parent
                               ns,//namespace
                               "gradientB",//ID
                               "userSpaceOnUse",
                               rectCornerX,//cx
                               rectCornerY,//cy
                               ((int)(rectWidth*1.2)));//r
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientB and to specify where
    // the colors begin and end, 
    JdomSvg.makeGradientStop(gradientB,//parent
                             ns,//namespace
                             "10%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,  
                             "33%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "66%",
                            "green");
                            
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "96%",
                            "blue");
                            
    //Draw the rectangle and fill it with gradientB.
    temp = JdomSvg.makeRect(svg,
                            ns,
                            rectCornerX,
                            rectCornerY,
                            rectWidth,
                            rectHeight);
    temp.setAttribute("fill","url(#gradientB)");

    //Draw a cubic Bezier curve consisting of two Bezier
    // segments.  First draw a polygon that shows the
    // start points, the end points, and the control
    // points for the segments. Fill the polygon with
    // yellow to provide a background color for the 
    // Bezier curve.
    temp = JdomSvg.makePolygon(
                     svg,
                     ns,
                     new int[] {180,290,50,250,150,200,
                                150,400,250,350,120,310});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    
    //Draw the cubic curve. Note the use of absolute
    // coordinate values only and also the use of the S
    // command. Stroke the curve with red and fill it with
    // blue.
    temp = JdomSvg.makePath(svg,ns,"M180,290 C50,250,"
                    + "150,200,150,300 S250,350,120,310");
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","blue");
    
    //Draw a quadratic Bezier curve consisting of two
    // Bezier segments.  First draw a polyline that shows
    // the start points, the end points, and the control
    // points.  Fill the polyline with yellow color with
    // an opacity attribute value of 0.5.  This allows
    // the grid to show through the filled polyline.
    temp = JdomSvg.makePolyline(
                       svg,
                       ns,
                       new int[] {300,300,400,200,500,300,
                                  400,400,300,300});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    temp.setAttribute("opacity","0.5");

    //Draw the quadratic curve. Note the use of relative
    // coordinate values. Stroke the curve with a wide
    // red stroke and fill it with blue.
    temp = JdomSvg.makePath(svg,ns,
              "M300,300 q100,-100,200,0,-100,100,-200,0");

    temp.setAttribute("stroke","red");
    temp.setAttribute("stroke-width","3");
    temp.setAttribute("fill","blue");


    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with no rotation. Stroke it with
    // yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                        "M100,500 a70,30 0 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with a rotation of 45 degrees.
    // Stroke it with yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                       "M350,500 a70,30 45 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Label the grid. First label the vertical lines.
    for(int cnt = 0;cnt &lt; viewBoxWidth;cnt += 50){
      JdomSvg.makeText(
                     svg,ns,cnt,viewBoxHeight - 4,""+cnt);
    }//end for loop

    //Now label the horizontal lines.    
    for(int cnt = 0;cnt &lt; viewBoxHeight;cnt += 50){
      JdomSvg.makeText(svg,ns,3,cnt,""+cnt);
    }//end for loop
  
    //Label each of the graphic elements
    JdomSvg.makeText(svg,ns,50,180,
                          "Ellipse with linear gradient");
    JdomSvg.makeText(svg,ns,270,180,
                        "Rectangle with radial gradient");
    JdomSvg.makeText(svg,ns,100,420,
                                    "Cubic Bezier curve");
    JdomSvg.makeText(svg,ns,280,420,
                         "Quadratic Bezier with opacity");
    JdomSvg.makeText(svg,ns,50,555,
                       "Elliptical arc without rotation");
    JdomSvg.makeText(svg,ns,300,555,
                          "Elliptical arc with rotation");
    
    //End creation of graphics elements.
    
 
    //Create a paragraph element containing text content
    // and place it at the end of the body element.
    temp = JdomSvg.makeNode(body,xns,"p",null);
    temp.setText("There is a graphic above here.");
 
     //Write the output file. Note that this is an XHTML
     // file and not an SVG file.
    JdomSvg.writePrettyFile("Svg18.xhtml",doc);
    //JdomSvg.writeCompactFile("Svg18.svg",doc);
    
  }//end main
  //----------------------------------------------------//

}//end class Svg18
//======================================================//

//This is a graphics library that is designed to eliminate
// much of the effort involved in writing JDOM code to
// create SVG output. The library contains individual
// static methods that are used to construct and return
// many of the standard SVG graphics elements. It also
// contains a method named makeNode that can be used to
// create any graphic element.
//Many of the methods have default attribute values.  If
// you need different attribute values for a particular
// graphic element, you can call the setAttribute method
// on the returned value to change the attribute values 
// after the method returns.
//Many of the methods set the stroke attribute value to
// black and set the stroke-width attribute value to 1
// by default.  If you don't want to be able to see the
// outline of the shape, change the stroke-width attribute
// value to 0 after the method returns.
class JdomSvg{
  //----------------------------------------------------//

  //This method writes the XML code into an output file
  // in pretty-print format. The pretty-print format
  // is less efficient than the compact format, but it
  // is very useful during test and debugging because
  // you can view source in your browser and the XML
  // code will be reasonably well formatted.
  public static void writePrettyFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
               new XMLOutputter(Format.getPrettyFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//
  
  //This method writes the XML code into an output file
  // in whitespace-normalized format. This format is more
  // compact and efficient than the pretty-print format.
  public static void writeCompactFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
              new XMLOutputter(Format.getCompactFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//

  //This method constructs and returns a reference to an
  // SVG root element node named svg with a viewBox
  // attribute to map the virtual dimensions into the
  // physical dimensions of the canvas.
  //By default, the min-x and min-y attribute values of
  // the viewBox are set to 0 0 and the value of the
  // preserveAspectRatio is set to none.
  //The svg element represents the canvas on which
  // various shapes can be drawn. The width and height
  // attribute values of the svg element establish the
  // physical size of the canvas on the screen. The
  // values of the viewBox attribute establish the
  // size of the canvas in "user units."  The
  // dimensions of the viewbox map directly into the
  // dimensions of the canvas.  This makes it possible
  // for the programmer to work in dimensions that are
  // convenient, such as 1000x1000, instead of having
  // to work with less convenient dimensions such as
  // 459x459.
  //Setting the value of the preserveAspectRatio
  // attribute to none prevents the system from
  // attempting to automatically preserve the aspect
  // ratio.  In this case, it is probably a good idea
  // for the programmer to make the ratio of the height
  // and width of the viewbox the same as the ratio of
  // the height and width of the canvas. That way, a
  // circle will look like a circle instead of looking
  // like an ellipse.
  //Note that the root element node does not have a parent
  // like the other nodes. Rather, it is passed as a 
  // parameter to the constructor for the Document node in
  // order to establish its place in the tree.
  public static Element makeSvg(
                      String ns,//namespace URI
                      int svgWidth,//physical screen width
                      int svgHeight,//physical height
                      int vbWidth,//virtual width
                      int vbHeight//virtual height
                      ){
    Element svg = new Element("svg",ns);
    
    //Set default attribute values.
    svg.setAttribute("version","1.1");
    svg.setAttribute("preserveAspectRatio","none");
    String vbMinX = "0 ";
    String vbMinY = "0 ";
    
    //Set user-specified attribute values. Note the 
    // format that is required to construct the attribute
    // value for the viewBox. If you need to call the
    // setAttribute method after this method returns to
    // change the attribute value for the viewBox
    // attribute, you will need to comply with the format
    // requirements for that value.
    svg.setAttribute("width",""+svgWidth);
    svg.setAttribute("height",""+svgHeight);
    svg.setAttribute("viewBox",
             vbMinX + vbMinY + ""+vbWidth + " "+vbHeight);
    
    return svg;
  }//end makeSvg
  //----------------------------------------------------//
  
  //This method constructs and returns a description node
  // for a given namespace and a given parent. Note that
  // this is SVG code.
  public static Element makeDescription(
              Element parent,//The parent of this element.
              String nameSpace,//The namespace.
              String text//Text content for this element.
              ){
    Element desc = new Element("desc",nameSpace);
    parent.addContent(desc);
    desc.setText(text);

    return desc;
  }//end makeDescription
  //----------------------------------------------------//
  
  //This method constructs and returns a comment node
  // for a given parent.
  public static Comment makeComment(
              Element parent,//The parent of this element.
              String text//Text content for this element.
              ){
    Comment comment = new Comment(text);
    parent.addContent(comment);

    return comment;
  }//end makeComment
  //----------------------------------------------------//

  //This method constructs and returns a rect node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none. Setting the fill to none has the effect of
  // causing the shape to be totally transparent.
  public static Element makeRect(
                  Element parent,
                  String namespace,
                  int x,//Coordinate of upper-left corner.
                  int y,//Coordinate of upper-left corner.
                  int width,
                  int height
                  ){
    Element rect = new Element("rect",namespace);
    parent.addContent(rect);
    
    //Set default attribute values.
    rect.setAttribute("fill","none");
    rect.setAttribute("stroke","black");
    rect.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    rect.setAttribute("x",""+x);
    rect.setAttribute("y",""+y);
    rect.setAttribute("width",""+width);
    rect.setAttribute("height",""+height);
    
    return rect;
  }//end makeRect
  //----------------------------------------------------//

  //This method constructs and returns an ellipse node for
  // a given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeEllipse(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int rx,//Horizontal radius
                                int ry //Vertical radius
                                ){
    Element ellipse = new Element("ellipse",namespace);
    parent.addContent(ellipse);
    
    //Set default attribute vales
    ellipse.setAttribute("fill","none");
    ellipse.setAttribute("stroke","black");
    ellipse.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    ellipse.setAttribute("cx",""+cx);
    ellipse.setAttribute("cy",""+cy);
    ellipse.setAttribute("rx",""+rx);
    ellipse.setAttribute("ry",""+ry);
    
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This method constructs and returns a polyline node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polyline and a polygon
  // (see below) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  // While you may close a polyline if you cause the
  // coordinates of the last point to match the
  // coordinates of the first point, it is not
  // automatically closed as in the case of a polygon.
  //Be careful if you fill a polyline that is not closed.
  // The results may not be what you expect.
  static Element makePolyline(Element parent,
                              String namespace,
                              int[] points){//See above.
    Element polyline = new Element("polyline",namespace);
    parent.addContent(polyline);

    //Set default attributes
    polyline.setAttribute("stroke","black");
    polyline.setAttribute("stroke-width","1");
    polyline.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + " ";
    }//end for loop
    polyline.setAttribute("points",dataPoints);
    
    return polyline;
  }//end makePolyline
  //----------------------------------------------------//
  
  //This method constructs and returns a polygon node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polygon and a polyline
  // (see above) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  static Element makePolygon(Element parent,
                             String namespace,
                             int[] points){
    Element polygon = new Element("polygon",namespace);
    parent.addContent(polygon);
    
    //Set default attributes.
    polygon.setAttribute("stroke","black");
    polygon.setAttribute("stroke-width","1");
    polygon.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    polygon.setAttribute("points",dataPoints);

    return polygon;
  }//end makePolygon
  //----------------------------------------------------//
  
  //This method constructs and returns a line node for a
  // given parent in a given namespace.  By default,the
  // stroke is black and the stroke-width is 1.
  public static Element makeLine(
                                Element parent,
                                String namespace,
                                int x1,//Start coordinate
                                int y1,//Start coordinate
                                int x2,//End coordinate
                                int y2 //End coordinate
                                ){
    Element line = new Element("line",namespace);
    parent.addContent(line);
    
    //Set default attribute vales
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    
    return line;
  }//end makeLine
  //----------------------------------------------------//
  
  //This method constructs and returns a circle node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeCircle(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int r  //Radius
                                ){
    Element circle = new Element("circle",namespace);
    parent.addContent(circle);
    
    //Set default attribute vales
    circle.setAttribute("fill","none");
    circle.setAttribute("stroke","black");
    circle.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    circle.setAttribute("cx",""+cx);
    circle.setAttribute("cy",""+cy);
    circle.setAttribute("r",""+r);
    
    return circle;
  }//end makeCircle
  //----------------------------------------------------//
  
  //This is a utility method that is used to construct a
  // string that describes a grid pattern consisting of 
  // horizontal and vertical lines at a specified pixel
  // spacing for a rectangular area of a specified width
  // and height. The string is intended to be used as the
  // data string for a call to the method named makePath.
  //There is nothing about this method that is peculiar to
  // the use of JDOM.
  //Note that this method makes use of the special
  // horizontal and vertical lineto commands in an attempt
  // to reduce the download size and the bandwidth
  // requirements for a drawing containing a large number
  // of horizontal and vertical lines in the grid pattern.
  static String makeGridString(
                        int width,int height,int spacing){
    //Construct the data string for the vertical lines.
    String data = "M0,0 ";
    for(int cnt = 0;cnt &lt; width;cnt += spacing){
      data += "v" + height + " M" + cnt + ",0 ";
    }//end for loop
    //Add the final vertical line.
    data += "v" + height + " \n";
    
    //Now add the horizontal lines to the data string.
    data += "M0,0 ";
    for(int cnt = 0;cnt &lt; height;cnt += spacing){
      data += "h" + width + " M0," + cnt + " ";
    }//end for loop
    //Add the final horizontal line.
    data += "h" + width + "\n ";
    
    return data;

  }//end makeGridString
  //----------------------------------------------------//

  //This method returns a reference to a path. By
  // default, the stroke is set to black one pixel wide,
  // and the fill is set to none.
  //See the method named makeGridString for a utility
  // method that is designed to create the data string
  // for this method for the special case of drawing grids
  // that resemble graph paper. For other cases, simply
  // create a data string that is compatible with the SVG
  // path element.
  static Element makePath(Element parent,
                          String namespace,
                          String d){
    Element path  = new Element("path",namespace);
    parent.addContent(path);
    
    //Set default attribute values.
    path.setAttribute("stroke","black");
    path.setAttribute("stroke-width","1");
    path.setAttribute("fill","none");
    
    //Set user specified default values.
    path.setAttribute("d",d);
    return path;
  }//end makePath
  //----------------------------------------------------//
  
  /*The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
  
  The first parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node.
   
  The second parameter is a String that specifies the
   namespace for the element represented by the new node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
   If there are no attributes, the value of this parameter
   should be null.
  
  An example of the recommended usage of the method
   follows:
  Element abc = JdomSvg.makeNode(
                     parent,
                     namespace,
                     "NodeType",
                     new String[]{"name","value",
                                  "name","value",
                                  "name","value"
                                 });//end call to makeNode
  */
  static Element makeNode(Element parent,
                          String namespace,
                          String nodeType,
                          String[] data){

    Element element = new Element(nodeType,namespace);
    parent.addContent(element);
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    //Extract the values from the array and construct
    // each of the attributes and its value.
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//
  
  //This method creates a linear gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes in the same program scope.
  static Element makeLinearGradient(Element parent,
                                    String namespace,
                                    String id){
    Element gradient = 
                  new Element("linearGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient
  //----------------------------------------------------//
  
  //This method creates a radial gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes. See the SVG documentation for more
  // information on the various attributes of the radial
  // gradient element.
  static Element makeRadialGradient(Element parent,
                                    String namespace,
                                    String id,
                                    String gradientUnits,
                                    int cx,//center
                                    int cy,//center
                                    int r  //radius
                                    ){
    Element gradient = 
                  new Element("radialGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient
  //----------------------------------------------------//
  
  //This method creates a gradient stop node to be
  // appended to a linear gradient node or a radial
  // gradient node. See the SVG documentation for more
  // information on the various attributes of the gradient
  // stop element.                          
  static Element makeGradientStop(Element parent,
                                  String namespace,
                                  String offset,
                                  String color){
    Element stopElement = new Element("stop",namespace);
    parent.addContent(stopElement);
    
    stopElement.setAttribute("offset",offset);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop
  //----------------------------------------------------//
  
  //This method returns a reference to a text element
  // node. The x and y parameters specify the location of
  // the lower left corner of the first text character.
  // Note that this is graphic text and not XML text.
  static Element makeText(Element parent,
                          String namespace,
                          int x,
                          int y,
                          String text){
    Element textNode = new Element("text",namespace);
    parent.addContent(textNode);

    textNode.setAttribute("x",""+x);
    textNode.setAttribute("y",""+y);
    
    textNode.addContent(text);

    return textNode;
  }//end makeText
  //----------------------------------------------------//
  
  //This method constructs and returns a reference to a
  // standard XHTML root node named html using the
  // incoming namespace and the attributes that are hard
  // coded into the method.
  public static Element makeXhtmlRoot(String xns){

    //The reason for expanding the namespace to include
    // the pair of attributes is because JDOM won't allow
    // me to set an attribute with a name that contains a
    // colon. This is a workaround for a problem that I
    // don't know to solve otherwise.
    String expandedNs = 
                     xns + "\" xml:lang=\"en\" lang=\"en";

    return new Element("html",expandedNs);
  }//end makeXhtmlRoot
  //----------------------------------------------------//

}//end class JdomSvg</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<b><a name="Listing_32">Listing 32</a>. Program code for Svg19.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg19.java,
Copyright 2007, R.G.Baldwin

The program named Svg18 was a stand alone desktop program 
that used JDOM to produce an output XHTML file with
embedded SVG/XML code.  That SVG code can be rendered by 
loading the file into an SVG graphics engine such as 
Firefox 2.0.0.4.

The purpose of this program is to convert the code from 
Svg18 into a servlet that will deliver XHTML code with 
the same embedded SVG/XML code to a client browser. That 
SVG/XML code should be properly rendered when the servlet
is accessed using an SVG capable browser such as
Firefox 2.0.0.4.

The following steps were required to make the conversion:

1.  Copy the jdom.jar file into the proper location on the
    server. On my jakarta-tomcat server running as a 
    localhost server, the proper location is:

    C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\lib

    This assumes that the servlet class files will be 
    copied into:

    C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\classes

2.  Declare the following import directives in Svg19:

    import javax.servlet.*;
    import javax.servlet.http.*;

3.  Declare that the class named Svg19 extends the 
    HttpServlet class.

4.  Replace the signature for the main method in Svg18 
    with the following signature for the doGet method in 
    Svg19:

    public void doGet(HttpServletRequest req,
                      HttpServletResponse res)
                             throws ServletException,
                              IOException{

5.  Execute the following statement to set the content 
    type delivered by the servlet. (See further discussion
    of this topic below.)

    res.setContentType("image/svg+");

6.  Use the following expression to get an output stream 
    to be used by the XMLOutputter object to send the 
    output data to the client browser:

    res.getWriter()

7.  Start the server running and access the servlet using
    Firefox 2.0.0.4 at http://localhost/servlet/Svg19


In order to cause the servlet to send the output to the 
client browser instead of writing it to a file, I defined
the following new methods and placed them in the JdomSvg 
graphics library class:

    writePrettyPrintWriter(PrintWriter out, Document doc)
    writeCompactPrintWriter(PrintWriter out, Document doc)

Depending on whether I wanted a prettyPrint format or a 
compact format, I modified an output statement from the 
main method of Svg18 to read as follows:

    JdomSvg.writePrettyPrintWriter(res.getWriter(),doc);
    JdomSvg.writeCompactPrintWriter(res.getWriter(),doc);

Otherwise, it was not necessary or me to make any 
additional changes to the program named Svg18 to convert 
it into the servlet. See the program named Svg18 for 
additional comments regarding the program.

Tested using J2SE 6.0, JDOM 1.0, Firefox 2.0.0.4, and
jakarta-tomcat-5.0.27 running as a localhost server
under WinXP.
*********************************************************/
import java.io.*;
import org.jdom.*;
import org.jdom.output.XMLOutputter;
import org.jdom.output.Format;

import javax.servlet.*;
import javax.servlet.http.*;

public class Svg19 extends HttpServlet{
  
  public void doGet(HttpServletRequest req,
                    HttpServletResponse res)
                           throws ServletException,
                            IOException{
                              
    //The following statement was disabled for the 
    // reason explained in the comments above.
    res.setContentType("image/svg+xml");

    //Create a String variable containing the XHTML
    // namespace URI to reduce the amount of typing that 
    // is required later. Note that the variable name is 
    // short and easy to type.
    String xns = "http://www.w3.org/1999/xhtml";
  
    //For clarity, create strings containing the name of
    // the element that is constrained by the DTD (the
    // html root element), the Public ID of the DTD, and 
    // the System ID of the DTD.
    String dtdConstrainedElement = "html";
    String dtdPublicID = 
                 "-//W3C//DTD XHTML 1.0 Transitional//EN";
    String dtdSystemID = "http://www.w3.org/TR/xhtml1/"
                          + "DTD/xhtml1-transitional.dtd";

    //Create the DTD declaration node.
    DocType docType = new DocType(
           dtdConstrainedElement,dtdPublicID,dtdSystemID);

    //Create the XHTML root node named html.
    Element html = JdomSvg.makeXhtmlRoot(xns);
    
    //Create the document node.
    Document doc = new Document(html,docType);

    //Add optional and required elements to the document
    // node, placing text content in the title node, 
    Element head = JdomSvg.makeNode(html,xns,"head",null);
    Element title = JdomSvg.makeNode(
                                   head,xns,"title",null);
    title.setText("XHTML/SVG Servlet Graphic Demo.");
                         
    Element body = JdomSvg.makeNode(html,xns,"body",null);

    //Put a paragraph element in the body element.
    Element temp = JdomSvg.makeNode(body,xns,"p",null);
    temp.setText("There is a graphic below here.");

    //Now switch your thinking into graphics programming
    // mode to place a large and fairly complex SVG
    // graphic in the body element.

    //Create a String variable containing the SVG
    // namespace URI to reduce the amount of typing that
    // is required later. Note that the variable name is
    // short and easy to type.
    String ns = "http://www.w3.org/2000/svg";

    //This program creates and displays exactly the same
    // graphics elements that were created and displayed
    // by the earlier program named Svg17.  However, the
    // physical size of the canvas in this program was
    // reduced to 75-percent of its size in the earlier
    // program for the purpose of demonstrating the use of
    // the word "Scalable" in the name Scalable Vector
    // Graphics (SVG).  Note also that because of the use
    // of virtual dimensions implemented through the use
    // of the viewBox, it was not necessary to modify any
    // of the SVG graphics code to accommodate the
    // reduction in the overall physical size of the
    // graphics elements.

    //Physical dimensions of the graphic on the screen.
    int svgWidth = (int)(460*0.75);
    int svgHeight = (int)(552*0.75);
    
    //Virtual dimensions of the graphic in user units.
    int viewBoxWidth = 500;
    int viewBoxHeight = 500*svgHeight/svgWidth;

    //Create the SVG root element named svg.
    Element svg = JdomSvg.makeSvg(ns,
                                  svgWidth,
                                  svgHeight,
                                  viewBoxWidth,
                                  viewBoxHeight);

    //The makeSvg method does not automatically add the
    // new node to a parent for reasons that are explained
    // in the method.  Therefore, it is necessary to add
    // the node to the parent outside of the makeSvg
    // method.
    body.addContent(svg);

    //Begin creating actual graphics elements.  With the
    // exception of the changes in the physical dimensions
    // of the graphic on the screen as implemented above,
    // the graphics code in this program is the same as
    // the code in the earlier program named Svg017.

    //Draw light green grid lines every 10 user units on
    // the basis of the virtual dimensions in user units.
    //First create the path data.
    String gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,10);

    //Create the path element and add it to the root.
    temp = JdomSvg.makePath(svg,ns,gridData);
    //Set the color to a very light green.
    temp.setAttribute("stroke","#ccffcc");

    //Using the same procedure, draw darker green grid
    // lines every 50 user units and draw them on top of
    // the existing grid lines.
    gridData = JdomSvg.makeGridString(
                           viewBoxWidth,viewBoxHeight,50);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#99ff99");
  
    //Draw even darker green grid lines every 100 user
    // units.
    gridData = JdomSvg.makeGridString(
                          viewBoxWidth,viewBoxHeight,100);
    temp = JdomSvg.makePath(svg,ns,gridData);
    temp.setAttribute("stroke","#22ff22");
    
    //Draw an even darker green border on the perimeter of
    // the grid.
    temp = JdomSvg.makeRect(svg,ns,1,1,
                          viewBoxWidth-2,viewBoxHeight-2);
    temp.setAttribute("stroke","#00ff00");
    temp.setAttribute("stroke-width","2");
    
    //Call the makeNode method to create a defs element
    // that will be the container for gradient
    // definitions.
    Element defs = JdomSvg.makeNode(svg,//parent
                                    ns,//namespace
                                    "defs",
                                    null//no attributes
                                    );
    
    //Define gradientA, which provides a linear gradient
    // that starts with yellow, changes to red, and
    // changes back to yellow going from left to right.
    Element gradientA = JdomSvg.makeLinearGradient(
                                         defs,//parent
                                         ns,//namespace
                                         "gradientA");//id
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientA and specify where the
    // colors begin and end, 
    JdomSvg.makeGradientStop(gradientA,//parent
                             ns,
                             "4%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,  
                             "50%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientA,
                             ns,
                            "96%",
                            "yellow");

    //Call the makeNode method to draw an ellipse. Fill it
    // with linear gradientA and rotate it by 30 degrees.
    // Note that I could have called the makeEllipse
    // method, but I wanted to demonstrate the use of the
    // more general makeNode method for a graphics element
    // that has several attributes.
    JdomSvg.makeNode(
            svg,//parent
            ns,
            "ellipse",//node type
            new String[]{"cx","150",
                         "cy","80",
                         "rx","100",
                         "ry","40",
                         "fill","url(#gradientA)",
                         "stroke","blue",
                         "stroke-width","3",
                         "opacity","0.5",
                         "transform","translate(150,80) "
                                   + "rotate(-30) "
                                   + "translate(-150,-80)"
                        }//end array definition
    );//end makeNode method
    
    //Note: Setting the opacity attribute value to 0.6 is
    // of no consequence when the output file is rendered
    // using Firefox 2.0.0.4.  The gradient continues to
    // be opaque.  However, this is a weakness in the
    // Firefox rendering engine and is not a limitation of
    // SVG.  When the file is rendered using an Adobe
    // rendering engine, the gradient is partially
    // transparent as it should be.
    
    //Define gradientB, which provides a radial gradient
    // that goes through yellow, red, green, and blue.
    // Use it to fill a rectangle.
    int rectCornerX = 300;
    int rectCornerY = 10;
    int rectWidth = 150;
    int rectHeight = 150;
    Element gradientB = JdomSvg.makeRadialGradient(
                               defs,//parent
                               ns,//namespace
                               "gradientB",//ID
                               "userSpaceOnUse",
                               rectCornerX,//cx
                               rectCornerY,//cy
                               ((int)(rectWidth*1.2)));//r
                                       
    //Create three stop nodes that identify the colors
    // used to produce gradientB and to specify where
    // the colors begin and end, 
    JdomSvg.makeGradientStop(gradientB,//parent
                             ns,//namespace
                             "10%",//start here
                             "yellow");//color
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,  
                             "33%",
                            "red");
                           
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "66%",
                            "green");
                            
    JdomSvg.makeGradientStop(gradientB,
                             ns,
                            "96%",
                            "blue");
                            
    //Draw the rectangle and fill it with gradientB.
    temp = JdomSvg.makeRect(svg,
                            ns,
                            rectCornerX,
                            rectCornerY,
                            rectWidth,
                            rectHeight);
    temp.setAttribute("fill","url(#gradientB)");

    //Draw a cubic Bezier curve consisting of two Bezier
    // segments.  First draw a polygon that shows the
    // start points, the end points, and the control
    // points for the segments. Fill the polygon with
    // yellow to provide a background color for the 
    // Bezier curve.
    temp = JdomSvg.makePolygon(
                     svg,
                     ns,
                     new int[] {180,290,50,250,150,200,
                                150,400,250,350,120,310});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    
    //Draw the cubic curve. Note the use of absolute
    // coordinate values only and also the use of the S
    // command. Stroke the curve with red and fill it with
    // blue.
    temp = JdomSvg.makePath(svg,ns,"M180,290 C50,250,"
                    + "150,200,150,300 S250,350,120,310");
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","blue");
    
    //Draw a quadratic Bezier curve consisting of two
    // Bezier segments.  First draw a polyline that shows
    // the start points, the end points, and the control
    // points.  Fill the polyline with yellow color with
    // an opacity attribute value of 0.5.  This allows
    // the grid to show through the filled polyline.
    temp = JdomSvg.makePolyline(
                       svg,
                       ns,
                       new int[] {300,300,400,200,500,300,
                                  400,400,300,300});
    temp.setAttribute("stroke","red");
    temp.setAttribute("fill","yellow");
    temp.setAttribute("opacity","0.5");

    //Draw the quadratic curve. Note the use of relative
    // coordinate values. Stroke the curve with a wide
    // red stroke and fill it with blue.
    temp = JdomSvg.makePath(svg,ns,
              "M300,300 q100,-100,200,0,-100,100,-200,0");

    temp.setAttribute("stroke","red");
    temp.setAttribute("stroke-width","3");
    temp.setAttribute("fill","blue");


    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with no rotation. Stroke it with
    // yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                        "M100,500 a70,30 0 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Draw an elliptical arc to illustrate the appearance
    // of such an arc with a rotation of 45 degrees.
    // Stroke it with yellow and fill it with red.
    temp = JdomSvg.makePath(svg,ns,
                       "M350,500 a70,30 45 1,0 50,-50 z");
    temp.setAttribute("stroke","yellow");
    temp.setAttribute("stroke-width","2");
    temp.setAttribute("fill","red");

    //Label the grid. First label the vertical lines.
    for(int cnt = 0;cnt &lt; viewBoxWidth;cnt += 50){
      JdomSvg.makeText(
                     svg,ns,cnt,viewBoxHeight - 4,""+cnt);
    }//end for loop

    //Now label the horizontal lines.    
    for(int cnt = 0;cnt &lt; viewBoxHeight;cnt += 50){
      JdomSvg.makeText(svg,ns,3,cnt,""+cnt);
    }//end for loop
  
    //Label each of the graphic elements
    JdomSvg.makeText(svg,ns,50,180,
                          "Ellipse with linear gradient");
    JdomSvg.makeText(svg,ns,270,180,
                        "Rectangle with radial gradient");
    JdomSvg.makeText(svg,ns,100,420,
                                    "Cubic Bezier curve");
    JdomSvg.makeText(svg,ns,280,420,
                         "Quadratic Bezier with opacity");
    JdomSvg.makeText(svg,ns,50,555,
                       "Elliptical arc without rotation");
    JdomSvg.makeText(svg,ns,300,555,
                          "Elliptical arc with rotation");
    
    //End creation of graphics elements.
    
 
    //Create a paragraph element containing text content
    // and place it at the end of the body element.
    temp = JdomSvg.makeNode(body,xns,"p",null);
    temp.setText("There is a graphic above here.");
 
     //Write the output to the client browser.
    //JdomSvg.writePrettyPrintWriter(res.getWriter(),doc);
    JdomSvg.writeCompactPrintWriter(res.getWriter(),doc);
    
  }//end doGet
  //----------------------------------------------------//

}//end class Svg19
//======================================================//

//This is a graphics library that is designed to eliminate
// much of the effort involved in writing JDOM code to
// create SVG output. The library contains individual
// static methods that are used to construct and return
// many of the standard SVG graphics elements. It also
// contains a method named makeNode that can be used to
// create any graphic element.
//Many of the methods have default attribute values.  If
// you need different attribute values for a particular
// graphic element, you can call the setAttribute method
// on the returned value to change the attribute values 
// after the method returns.
//Many of the methods set the stroke attribute value to
// black and set the stroke-width attribute value to 1
// by default.  If you don't want to be able to see the
// outline of the shape, change the stroke-width attribute
// value to 0 after the method returns.
class JdomSvg{
  //----------------------------------------------------//

  //This method writes the XML code into an output file
  // in pretty-print format. The pretty-print format
  // is less efficient than the compact format, but it
  // is very useful during test and debugging because
  // you can view source in your browser and the XML
  // code will be reasonably well formatted.
  public static void writePrettyFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
               new XMLOutputter(Format.getPrettyFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//
  
  //This method writes the XML code into an output file
  // in whitespace-normalized format. This format is more
  // compact and efficient than the pretty-print format.
  public static void writeCompactFile(
                              String fname, Document doc){
    try{
      FileOutputStream out = new FileOutputStream(fname);

      XMLOutputter xmlOut = 
              new XMLOutputter(Format.getCompactFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writeCompactFile
  //----------------------------------------------------//

  //This method writes the XML code into a PrintWriter
  // output stream in pretty-print format.
  public static void writePrettyPrintWriter(
                           PrintWriter out, Document doc){
    try{
      XMLOutputter xmlOut = 
               new XMLOutputter(Format.getPrettyFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writePrettyFile
  //----------------------------------------------------//
  
  //This method writes the XML code into PrintWriter
  // output stream in whitespace-normalized format.
  public static void writeCompactPrintWriter(
                           PrintWriter out, Document doc){
    try{
      XMLOutputter xmlOut = 
              new XMLOutputter(Format.getCompactFormat());
      xmlOut.output(doc,out);

      out.flush();
      out.close();
    }catch (IOException e){
      System.err.println(e);
    }//end catch
  }//end writeCompactPrintWriter
  //----------------------------------------------------//
  //This method constructs and returns a reference to an
  // SVG root element node named svg with a viewBox
  // attribute to map the virtual dimensions into the
  // physical dimensions of the canvas.
  //By default, the min-x and min-y attribute values of
  // the viewBox are set to 0 0 and the value of the
  // preserveAspectRatio is set to none.
  //The svg element represents the canvas on which
  // various shapes can be drawn. The width and height
  // attribute values of the svg element establish the
  // physical size of the canvas on the screen. The
  // values of the viewBox attribute establish the
  // size of the canvas in "user units."  The
  // dimensions of the viewbox map directly into the
  // dimensions of the canvas.  This makes it possible
  // for the programmer to work in dimensions that are
  // convenient, such as 1000x1000, instead of having
  // to work with less convenient dimensions such as
  // 459x459.
  //Setting the value of the preserveAspectRatio
  // attribute to none prevents the system from
  // attempting to automatically preserve the aspect
  // ratio.  In this case, it is probably a good idea
  // for the programmer to make the ratio of the height
  // and width of the viewbox the same as the ratio of
  // the height and width of the canvas. That way, a
  // circle will look like a circle instead of looking
  // like an ellipse.
  //Note that the root element node does not have a parent
  // like the other nodes. Rather, it is passed as a 
  // parameter to the constructor for the Document node in
  // order to establish its place in the tree.
  public static Element makeSvg(
                      String ns,//namespace URI
                      int svgWidth,//physical screen width
                      int svgHeight,//physical height
                      int vbWidth,//virtual width
                      int vbHeight//virtual height
                      ){
    Element svg = new Element("svg",ns);
    
    //Set default attribute values.
    svg.setAttribute("version","1.1");
    svg.setAttribute("preserveAspectRatio","none");
    String vbMinX = "0 ";
    String vbMinY = "0 ";
    
    //Set user-specified attribute values. Note the 
    // format that is required to construct the attribute
    // value for the viewBox. If you need to call the
    // setAttribute method after this method returns to
    // change the attribute value for the viewBox
    // attribute, you will need to comply with the format
    // requirements for that value.
    svg.setAttribute("width",""+svgWidth);
    svg.setAttribute("height",""+svgHeight);
    svg.setAttribute("viewBox",
             vbMinX + vbMinY + ""+vbWidth + " "+vbHeight);
    
    return svg;
  }//end makeSvg
  //----------------------------------------------------//
  
  //This method constructs and returns a description node
  // for a given namespace and a given parent. Note that
  // this is SVG code.
  public static Element makeDescription(
              Element parent,//The parent of this element.
              String nameSpace,//The namespace.
              String text//Text content for this element.
              ){
    Element desc = new Element("desc",nameSpace);
    parent.addContent(desc);
    desc.setText(text);

    return desc;
  }//end makeDescription
  //----------------------------------------------------//
  
  //This method constructs and returns a comment node
  // for a given given parent.
  public static Comment makeComment(
              Element parent,//The parent of this element.
              String text//Text content for this element.
              ){
    Comment comment = new Comment(text);
    parent.addContent(comment);

    return comment;
  }//end makeComment
  //----------------------------------------------------//

  //This method constructs and returns a rect node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none. Setting the fill to none has the effect of
  // causing the shape to be totally transparent.
  public static Element makeRect(
                  Element parent,
                  String namespace,
                  int x,//Coordinate of upper-left corner.
                  int y,//Coordinate of upper-left corner.
                  int width,
                  int height
                  ){
    Element rect = new Element("rect",namespace);
    parent.addContent(rect);
    
    //Set default attribute values.
    rect.setAttribute("fill","none");
    rect.setAttribute("stroke","black");
    rect.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    rect.setAttribute("x",""+x);
    rect.setAttribute("y",""+y);
    rect.setAttribute("width",""+width);
    rect.setAttribute("height",""+height);
    
    return rect;
  }//end makeRect
  //----------------------------------------------------//

  //This method constructs and returns an ellipse node for
  // a given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeEllipse(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int rx,//Horizontal radius
                                int ry //Vertical radius
                                ){
    Element ellipse = new Element("ellipse",namespace);
    parent.addContent(ellipse);
    
    //Set default attribute vales
    ellipse.setAttribute("fill","none");
    ellipse.setAttribute("stroke","black");
    ellipse.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    ellipse.setAttribute("cx",""+cx);
    ellipse.setAttribute("cy",""+cy);
    ellipse.setAttribute("rx",""+rx);
    ellipse.setAttribute("ry",""+ry);
    
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This method constructs and returns a polyline node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polyline and a polygon
  // (see below) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  // While you may close a polyline if you cause the
  // coordinates of the last point to match the
  // coordinates of the first point, it is not
  // automatically closed as in the case of a polygon.
  //Be careful if you fill a polyline that is not closed.
  // The results may not be what you expect.
  static Element makePolyline(Element parent,
                              String namespace,
                              int[] points){//See above.
    Element polyline = new Element("polyline",namespace);
    parent.addContent(polyline);

    //Set default attributes
    polyline.setAttribute("stroke","black");
    polyline.setAttribute("stroke-width","1");
    polyline.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + " ";
    }//end for loop
    polyline.setAttribute("points",dataPoints);
    
    return polyline;
  }//end makePolyline
  //----------------------------------------------------//
  
  //This method constructs and returns a polygon node for
  // a given parent in a given namespace..
  //The array of type int[], which contains the
  // coordinates for each point in the polyline, must
  // contain an even number of values for the polyline
  // to be drawn correctly. Otherwise, it simply won't be
  // drawn.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.
  //The main difference between a polygon and a polyline
  // (see above) is that a polygon is automatically closed
  // by connecting the last point to the first point.
  static Element makePolygon(Element parent,
                             String namespace,
                             int[] points){
    Element polygon = new Element("polygon",namespace);
    parent.addContent(polygon);
    
    //Set default attributes.
    polygon.setAttribute("stroke","black");
    polygon.setAttribute("stroke-width","1");
    polygon.setAttribute("fill","none");
    
    //Set user specified attributes.
    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    polygon.setAttribute("points",dataPoints);

    return polygon;
  }//end makePolygon
  //----------------------------------------------------//
  
  //This method constructs and returns a line node for a
  // given parent in a given namespace.  By default,the
  // stroke is black and the stroke-width is 1.
  public static Element makeLine(
                                Element parent,
                                String namespace,
                                int x1,//Start coordinate
                                int y1,//Start coordinate
                                int x2,//End coordinate
                                int y2 //End coordinate
                                ){
    Element line = new Element("line",namespace);
    parent.addContent(line);
    
    //Set default attribute vales
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    
    return line;
  }//end makeLine
  //----------------------------------------------------//
  
  //This method constructs and returns a circle node for a
  // given parent in a given namespace.  By default,the
  // stroke is black, the stroke-width is 1, and the fill
  // is none.
  public static Element makeCircle(
                                Element parent,
                                String namespace,
                                int cx,//Center coordinate
                                int cy,//Center coordinate
                                int r  //Radius
                                ){
    Element circle = new Element("circle",namespace);
    parent.addContent(circle);
    
    //Set default attribute vales
    circle.setAttribute("fill","none");
    circle.setAttribute("stroke","black");
    circle.setAttribute("stroke-width","1");
    
    //Set user specified attribute values.
    circle.setAttribute("cx",""+cx);
    circle.setAttribute("cy",""+cy);
    circle.setAttribute("r",""+r);
    
    return circle;
  }//end makeCircle
  //----------------------------------------------------//
  
  //This is a utility method that is used to construct a
  // string that describes a grid pattern consisting of 
  // horizontal and vertical lines at a specified pixel
  // spacing for a rectangular area of a specified width
  // and height. The string is intended to be used as the
  // data string for a call to the method named makePath.
  //There is nothing about this method that is peculiar to
  // the use of JDOM.
  //Note that this method makes use of the special
  // horizontal and vertical lineto commands in an attempt
  // to reduce the download size and the bandwidth
  // requirements for a drawing containing a large number
  // of horizontal and vertical lines in the grid pattern.
  static String makeGridString(
                        int width,int height,int spacing){
    //Construct the data string for the vertical lines.
    String data = "M0,0 ";
    for(int cnt = 0;cnt &lt; width;cnt += spacing){
      data += "v" + height + " M" + cnt + ",0 ";
    }//end for loop
    //Add the final vertical line.
    data += "v" + height + " \n";
    
    //Now add the horizontal lines to the data string.
    data += "M0,0 ";
    for(int cnt = 0;cnt &lt; height;cnt += spacing){
      data += "h" + width + " M0," + cnt + " ";
    }//end for loop
    //Add the final horizontal line.
    data += "h" + width + "\n ";
    
    return data;

  }//end makeGridString
  //----------------------------------------------------//

  //This method returns a reference to a path. By
  // default, the stroke is set to black one pixel wide,
  // and the fill is set to none.
  //See the method named makeGridString for a utility
  // method that is designed to create the data string
  // for this method for the special case of drawing grids
  // that resemble graph paper. For other cases, simply
  // create a data string that is compatible with the SVG
  // path element.
  static Element makePath(Element parent,
                          String namespace,
                          String d){
    Element path  = new Element("path",namespace);
    parent.addContent(path);
    
    //Set default attribute values.
    path.setAttribute("stroke","black");
    path.setAttribute("stroke-width","1");
    path.setAttribute("fill","none");
    
    //Set user specified default values.
    path.setAttribute("d",d);
    return path;
  }//end makePath
  //----------------------------------------------------//
  
  /*The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
  
  The first parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node.
   
  The second parameter is a String that specifies the
   namespace for the element represented by the new node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
   If there are no attributes, the value of this parameter
   should be null.
  
  An example of the recommended usage of the method
   follows:
  Element abc = JdomSvg.makeNode(
                     parent,
                     namespace,
                     "NodeType",
                     new String[]{"name","value",
                                  "name","value",
                                  "name","value"
                                 });//end call to makeNode
  */
  static Element makeNode(Element parent,
                          String namespace,
                          String nodeType,
                          String[] data){

    Element element = new Element(nodeType,namespace);
    parent.addContent(element);
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    //Extract the values from the array and construct
    // each of the attributes and its value.
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//
  
  //This method creates a linear gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes in the same program scope.
  static Element makeLinearGradient(Element parent,
                                    String namespace,
                                    String id){
    Element gradient = 
                  new Element("linearGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient
  //----------------------------------------------------//
  
  //This method creates a radial gradient node to which
  // stop elements must be appended. The id attribute is
  // used to differentiate this gradient node from other
  // gradient nodes. See the SVG documentation for more
  // information on the various attributes of the radial
  // gradient element.
  static Element makeRadialGradient(Element parent,
                                    String namespace,
                                    String id,
                                    String gradientUnits,
                                    int cx,//center
                                    int cy,//center
                                    int r  //radius
                                    ){
    Element gradient = 
                  new Element("radialGradient",namespace);
    parent.addContent(gradient);
    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient
  //----------------------------------------------------//
  
  //This method creates a gradient stop node to be
  // appended to a linear gradient node or a radial
  // gradient node. See the SVG documentation for more
  // information on the various attributes of the gradient
  // stop element.                          
  static Element makeGradientStop(Element parent,
                                  String namespace,
                                  String offset,
                                  String color){
    Element stopElement = new Element("stop",namespace);
    parent.addContent(stopElement);
    
    stopElement.setAttribute("offset",offset);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop
  //----------------------------------------------------//
  
  //This method returns a reference to a text element
  // node. The x and y parameters specify the location of
  // the lower left corner of the first text character.
  // Note that this is graphic text and not XML text.
  static Element makeText(Element parent,
                          String namespace,
                          int x,
                          int y,
                          String text){
    Element textNode = new Element("text",namespace);
    parent.addContent(textNode);

    textNode.setAttribute("x",""+x);
    textNode.setAttribute("y",""+y);
    
    textNode.addContent(text);

    return textNode;
  }//end makeText
  //----------------------------------------------------//
  
  //This method constructs and returns a reference to a
  // standard XHTML root node named html using the
  // incoming namespace and the attributes that are hard
  // coded into the method.
  public static Element makeXhtmlRoot(String xns){

    //The reason for expanding the namespace to include
    // the pair of attributes is because JDOM won't allow
    // me to set an attribute with a name that contains a
    // colon. This is a workaround for a problem that I
    // don't know to solve otherwise.
    String expandedNs = 
                     xns + "\" xml:lang=\"en\" lang=\"en";

    return new Element("html",expandedNs);
  }//end makeXhtmlRoot
  //----------------------------------------------------//

}//end class JdomSvg
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java jaxp svg &quot;scalable vector graphics&quot; </p>
<p>-end- </p>
<p>&nbsp;</p>
</body>
</html>
