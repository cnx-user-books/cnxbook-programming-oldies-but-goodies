<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">Displaying an Image in a PictureExplorer Object</h2>
<i>Learn the final details of what you will need to incorporate objects of the 
PictureExplorer class into applications of your own design. </i><p><b>Published:</b>&nbsp; 
March 19, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 366</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_so_far">What you have learned from 
		earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a><ul>
	<li><a href="#A_sample_program">A sample program</a></li>
	<li><a href="#Reducing_the_confusion">Reducing the confusion</a></li>
</ul>
	</li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_sample_program_named_Java362a">The sample program named 
	Java362a</a></li>
	<li><a href="#An_overview_of_the_GUI">An overview of the GUI</a></li>
	<li><a href="#The_PictureExplorer_class">The PictureExplorer class</a><ul>
	<li><a href="#The_constructor">The constructor</a></li>
	<li><a href="#The_createWindow_method">The createWindow method</a><ul>
	<li><a href="#The_createAndInitScrollingImage_method">The 
	createAndInitScrollingImage method</a></li>
	<li><a href="#The_ImageDisplay_class">The ImageDisplay class</a></li>
</ul>
	</li>
	<li><a href="#Additional_methods_of_the_PictureExplorer_class">Additional 
	methods of the PictureExplorer class</a><ul>
	<li><a href="#The_actionPerformed_method">The actionPerformed method</a></li>
</ul>
	</li>
</ul>
	</li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, sharpening, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_so_far">What you have learned from earlier 
lessons</a></h3>
<p> If you have studied the <a href="#Resources">earlier lessons</a> in this 
series, you have learned about turtles, worlds, and pictures.&nbsp; You have learned that objects of the <b>Picture</b> 
class are useful for much more than simply serving as living quarters for 
turtles.&nbsp; They are also useful for manipulating images in interesting and 
complex ways.</p>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b><font size="3" face="arial">Pixel 
				Editor Program</font></b><br>
				See the lesson titled <font size="3" face="arial"><i>A Pixel 
				Editor Program in Java:&nbsp; Multimedia Programming with Java</i> in
				<a href="#Resources">Resources</a> for a 
				non-trivial application of a <b>PictureExplorer</b> object.</font></td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<p> <font color="#FF0000"><b>A PictureExplorer object</b></font></p>
<p> You learned that an object of the <b>PictureExplorer</b> class 
<i>(see Figure 1)</i> is a GUI that allows you to determine the numeric 
color values for any pixel in a picture by placing a cursor on the pixel.</p>
<p>
 <b><a name="Figure_1">Figure 1</a>. Reduced screen output produced by the explore 
	method. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <img border="0" src="java366a.jpg" width="394" height="353"></td>
    </tr>
  </tbody>
</table>
</p>
<p><i>(Note that in the screen shot in Figure 1, the GUI was manually resized 
to make it smaller and the Zoom menu was opened to display its contents.)</i></p>
<p> <font color="#FF0000"><b>A PictureExplorer object has a cursor</b></font></p>
<p> The position of the cursor is controlled by clicking or dragging the mouse 
within the picture, clicking buttons in the upper panel, or typing coordinate values 
into text fields in the upper panel.</p>
<p> <font color="#FF0000"><b>Zoom</b></font></p>
<p> You can zoom in and out to view the pixels in more or less detail and you 
can see the actual color of the pixel displayed in a small colored square.</p>
<p><font color="#FF0000"><b>A JFrame with a menu</b></font></p>
<p>You have learned how the GUI is constructed from a big-picture viewpoint.&nbsp; 
You learned that the GUI window is the visual manifestation of a <b>JFrame</b> 
object.&nbsp; You learned how the <b>JFrame</b> object is configured, how the <b>Zoom</b> menu is constructed, and how an 
<b>ActionListener</b> object is 
registered on each item in that menu.</p>
<p><font color="#FF0000"><b>A panel with user controls</b></font></p>
<p>In the previous lesson, you learned how to construct the panel containing the 
user controls <i>(the infoPanel)</i> in the 
upper portion of the GUI as shown in Figure 1.&nbsp; You also learned how 
to register event listener objects on the components in that panel making use of 
anonymous objects of anonymous classes.</p>
<p><font color="#FF0000"><b>Other interesting topics</b></font></p>
<p>Along the way, you learned about some other interesting topics 
including:</p>
<ul>
	<li>The use of <b>BoxLayout.</b></li>
	<li>The class file naming scheme.</li>
	<li>The use of <b>getResources</b> to get the URL of a file.</li>
<li>The use of a class loader to load a resource file.</li>
</ul>
	<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
	lesson</a></h3>
<p>So far, everything that you have learned is peripheral to the display of the 
picture itself in a scrollable window.&nbsp; Displaying the picture in a 
scrollable window is the main topic of this lesson.</p>
<p><font color="#ff0000"><b>Source code listings</b></font></p>
<p>A complete listing of Ericson's <b>PictureExplorer</b> class is provided in 
Listing 23 near the end of the lesson.&nbsp; A complete listing of a very simple program 
named Java362a that I will use to illustrate the behavior of the <b>PictureExplorer</b> 
class is provided in Listing 24.&nbsp; Finally, a complete listing of an 
associated class named <b>ImageDisplay</b> is provided in Listing 25.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Reduced screen output produced by the 
	explore method. </li>
	<li><a href="#Figure_2">Figure 2</a>. Screen output produced by the show 
	method. </li>
	<li><a href="#Figure_3">Figure 3</a>. Partial description of the 
	getScaledInstance method.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Background color for first-level 
	code. </li>
	<li><a href="#Listing_2">Listing 2</a>. Background color for second-level 
	code.</li>
	<li><a href="#Listing_3">Listing 3</a>. Background color for third and 
	lower-level code. </li>
	<li><a href="#Listing_4">Listing 4</a>. Private instance variables of the 
	PictureExplorer class. </li>
	<li><a href="#Listing_5">Listing 5</a>. The constructor for the 
	PictureExplorer class. </li>
	<li><a href="#Listing_6">Listing 6</a>. The createWindow method. </li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the 
	createAndInitScrollingImage method.</li>
	<li><a href="#Listing_8">Listing 8</a>.
Beginning of the ImageDisplay class.</li>
	<li><a href="#Listing_9">Listing 9</a>. The first overloaded constructor.
	</li>
	<li><a href="#Listing_10">Listing 10</a>. The second overloaded 
	constructor. </li>
	<li><a href="#Listing_11">Listing 11</a>. Register PictureExplorer object 
	as a listener object. </li>
	<li><a href="#Listing_12">Listing 12</a>. The mouseClicked and 
	mousePressed event handlers.</li>
	<li><a href="#Listing_13">Listing 13</a>. The mouseDragged event handler.</li>
	<li><a href="#Listing_14">Listing 14</a>. The displayPixelInformation 
	method. </li>
	<li><a href="#Listing_15">Listing 15</a>. Remainder of the 
	createAndInitScrollingImage method.</li>
	<li><a href="#Listing_16">Listing 16</a>. The actionPerformed method.</li>
	<li><a href="#Listing_17">Listing 17</a>.
Register the PictureExplorer object as 
an ActionListener on each menu item.</li>
	<li><a href="#Listing_18">Listing 18</a>. The enableZoomItems method.</li>
	<li><a href="#Listing_19">Listing 19</a>. The beginning of the zoom 
	method. </li>
	<li><a href="#Listing_20">Listing 20</a>. Replace the current image with 
	a scaled image. </li>
	<li><a href="#Listing_21">Listing 21</a>. The remainder of the zoom 
	method. </li>
	<li><a href="#Listing_22">Listing 22</a>. Partial listing of the checkScroll 
	method. </li>
	<li><a href="#Listing_23">Listing 23</a>. Source code for Ericson's 
	PictureExplorer class. </li>
	<li><a href="#Listing_24">Listing 24</a>. Source code for the program named 
	Java362a. </li>
	<li><a href="#Listing_25">Listing 25</a>. Source code for the ImageDisplay 
	class. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<h3><a name="A_sample_program">A sample program</a></h3>
<p>I will use a very simple program to illustrate the creation of an 
object of the <b>PictureExplorer</b> class.</p>
<p>The sample program <i>(named Java362a)</i> begins by creating a new <b>Picture</b> object using input from an image file in the current directory.&nbsp; Then it calls the <b>show</b> method on the object to produce 
the screen output shown in Figure 2.</p>












<p>
 <b><a name="Figure_2">Figure 2</a>. Screen output produced by the show method. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <img border="0" src="java366b.jpg" width="469" height="374"></td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Call the explore method</b></font></p>
<p>After that, the program calls the <b>explore</b> method on the <b>Picture</b> 
object to produce the screen output shown earlier in Figure 1.</p>
<p>You learned all about the <b>show</b> method of the <b>SimplePicture</b> 
class in earlier lessons.&nbsp; You began learning about the <b>explore</b> method and the <b>PictureExplorer</b> 
class in the earlier lesson titled <i>Getting Started with the PictureExplorer 
Class:&nbsp; Multimedia Programming with Java</i> <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>The explore method</b></font></p>
<p>The <b>explore</b> method of the <b>SimplePicture</b> class contains a single 
statement, which instantiates an object of the <b>PictureExplorer</b> class.&nbsp; 
As soon as that object is instantiated, the GUI shown in Figure 1 appears on the 
screen and it remains on the screen until the program is terminated or the user 
clicks the X-button in the upper-right corner of the GUI.</p>

<h3><a name="Reducing_the_confusion">Reducing the confusion</a></h3>
<p align="left">Methods in the <b>PictureExplorer</b> class often call 
other methods that belong to the class.&nbsp; Those methods, in turn, often call 
other methods.&nbsp; Because I will be switching back and forth among code 
fragments extracted from different methods, things can get confusing.&nbsp; I 
will use color in an attempt to reduce the confusion.&nbsp; That is, when one 
method calls another and I need to put the explanation of the first method on 
hold while I explain the code in the second method, I will change the background color 
against which the code fragments are displayed.</p>

<p><font color="#ff0000"><b>Background color for 
first-level classes, methods and/or constructors</b></font></p>

<p>For example, I will present 
code fragments extracted from Ericson's PictureExplorer class against the 
background color shown in Listing 1.</p>

<p><b><a name="Listing_1">Listing 1</a>. Background color for 
first-level code. </b>

<table bgcolor="#FFFFBB" border="1" cols="1" width="477">
	<tr>
		<td>
		<div align="left">
			<pre>Color = #FFFFBB</pre>
		</div>
		</td>
	</tr>
</table>

<p><font color="#ff0000"><b>Background color for second-level 
methods</b></font></p>

<p>Similarly, I will present code fragments extracted from 
second-level methods against the background color shown in Listing 2.</p>

<p><b><a name="Listing_2">Listing 2</a>. Background color for 
second-level code.</b>

<table bgcolor="#FFEEFF" border="1" cols="1" width="477">
	<tr>
		<td>
		<div align="left">
			<pre>Color = #FFEEFF</pre>
		</div>
		</td>
	</tr>
</table>

<p><font color="#ff0000"><b>Background color for third and lower-level methods</b></font></p>

<p>Finally, I will present code fragments extracted from third-level and 
lower-level code <i>(if any)</i> against the background colors, going from 
left to right, in Listing 3.</p>

<p><b><a name="Listing_3">Listing 3</a>. Background color for 
third and lower-level code. </b>

<table border="1" cols="1" width="477">
	<tr>
		<td bgcolor="#DDFFFF">
		<div align="left">
			<pre>3-#DDFFFF</pre>
		</div>
		</td>
		<td bgcolor="#C1C100">
		<pre>4-#C1C100</pre></td>
		<td bgcolor="#FFCC66">
		<pre>5-#FFCC66</pre></td>
		<td bgcolor="#B1C2BD">
		<pre>6-#B1C2BD</pre></td>
		<td bgcolor="#EEEEEE">
		<pre>7-#EEEEEE</pre></td>
	</tr>
</table>
<p align="left">In the unlikely event that I need to distinguish among more than seven 
levels at the same time, I will come up with another color and explain its 
use at the time.</p>
<h2 align="center"> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
</center>
<h3><a name="The_sample_program_named_Java362a">The sample program named 
Java362a</a></h3>
<p>The purpose of this program is to support an explanation of the <b>
PictureExplorer</b> class.</p>
<p>Normally, I break programs down and explain them in fragments.&nbsp; However, 
this program is short and simple and I explained it in detail in previous 
lessons <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; You can view a 
complete listing of the program in Listing 24 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Create a Picture object and display it with the 
explore 
method</b></font></p>
<p>A <b>Picture</b> object having dimensions of 450x345 pixels is created by 
reading an image file from the current directory.&nbsp; The <b>show</b> method 
is called on the <b>Picture</b> object producing the screen output shown in 
Figure 2.&nbsp; Then the <b>explore</b> 
method is called on the <b>Picture</b> object producing the screen output GUI 
shown in Figure 1.</p>
<p><font color="#FF0000"><b>Displays a copy of the original Picture object</b></font></p>
<p>As you learned in the earlier lessons, the <b>explore</b> method creates a 
copy of the original <b>Picture</b> object and passes its reference to the 
constructor for a new 
object of the <b>PictureExplorer</b> class.&nbsp; The new <b>PictureExplorer</b> 
object displays the copy of the original picture in the format shown in Figure 
1.<i>&nbsp; (Once again, note that the GUI in 
Figure 1 was manually resized to make it smaller and the <b>Zoom</b> menu was 
opened to display its contents.)</i></p>
<h3><a name="An_overview_of_the_GUI">An overview of the GUI</a></h3>
<p>You also learned in the previous lessons that the onscreen GUI window that you see in 
Figure 1 is the visual manifestation of a
<b>JFrame</b> object.&nbsp; Basically, a <b>JFrame</b> object consists of the 
following parts:</p>
<ul>
	<li>A banner at the top containing some built-in control components <i>
	(three buttons on the right and a menu on the left)</i> and optionally a <b>
	String</b> title.</li>
	<li>A rectangular area under the banner that can contain a menu.&nbsp; This 
	area is collapsed if you elect not to provide one or more menus.</li>
	<li>A content area underneath the menu area.</li>
	<li>A border around the outer edges.</li>
</ul>
<p><font color="#FF0000"><b>The content area</b></font></p>
<p>I explained the menu area in some depth in an earlier lesson.&nbsp; We will 
be primarily concerned with the content area in this lesson.</p>
<p>The content area <i>(immediately below the menu area)</i> has a default <b>BorderLayout</b> object as the layout 
manager.&nbsp; This layout manager makes it possible to place one component in 
the CENTER and four additional components in the NORTH, SOUTH, EAST, and WEST 
locations.</p>
<p>In the GUI produced by the <b>PictureExplorer</b> class, there is one component in the CENTER and one 
component in the NORTH location.&nbsp; There are no components in the EAST, 
SOUTH, and WEST locations.&nbsp; <i>(Keep in mind that each of the five 
allowable components can themselves contain other components.)</i></p>
<p><font color="#FF0000"><b>A JPanel object in the NORTH location</b></font></p>
<p>The component in the NORTH location of the <b>JFrame</b> object's content 
area is a <b>JPanel</b> object.&nbsp; This <b>JPanel</b> object, which contains 
all of the buttons and text fields shown in Figure 1, was the primary focus of 
the previous lesson.</p>
<p><font color="#FF0000"><b>A JScrollPane object in the CENTER location</b></font></p>
<p>The component in the CENTER is an object of the <b>JScrollPane</b> class.&nbsp; 
This component will be the main focus of this lesson.</p>
<h3><a name="The_PictureExplorer_class">The PictureExplorer class</a></h3>
<p>A complete listing of the <b>PictureExplorer</b> class is provided in Listing 
23 near the end of the lesson.&nbsp; I will break the class down and explain it 
in fragments.&nbsp; <i>(I explained part of the <b>PictureExplorer</b> class in the 
previous two lessons.)</i></p>
<p><font color="#FF0000">
<b>Private instance variables of the PictureExplorer class</b></font></p>
<p>The <b>PictureExplorer</b> class declares a large number of private instance 
variables and initializes some of them.&nbsp; They are shown in Listing 4 for 
easy reference.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Private instance variables of the 
PictureExplorer class. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> // current x and y index
 private int xIndex = 0;
 private int yIndex = 0;

 //Main gui variables
 private JFrame pictureFrame;
 private JScrollPane scrollPane;

 //information bar variables
 private JLabel xLabel;
 private JButton xPrevButton;
 private JButton yPrevButton;
 private JButton xNextButton;
 private JButton yNextButton;
 private JLabel yLabel;
 private JTextField xValue;
 private JTextField yValue;
 private JLabel rValue;
 private JLabel gValue;
 private JLabel bValue;
 private JLabel colorLabel;
 private JPanel colorPanel;

 // menu components
 private JMenuBar menuBar;
 private JMenu zoomMenu;
 private JMenuItem twentyFive;
 private JMenuItem fifty;
 private JMenuItem seventyFive;
 private JMenuItem hundred;
 private JMenuItem hundredFifty;
 private JMenuItem twoHundred;
 private JMenuItem fiveHundred;

 /** The picture being explored */
 private DigitalPicture picture;

 /** The image icon used to display the picture */
 private ImageIcon scrollImageIcon;

 /** The image display */
 private ImageDisplay imageDisplay;

 /** the zoom factor (amount to zoom) */
 private double zoomFactor;

 /** the number system to use, 0 means starting at 0,
  *  1 means starting at 1 */
 private int numberBase=0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There's not much to be said about the instance variables at this point.&nbsp; 
We will be referring back to them as the explanation of the <b>PictureExplorer</b> class progresses.</p>
<h4><a name="The_constructor">The constructor</a></h4>
<p>I explained the constructor in the previous two lessons.&nbsp; However, I have shown it again in 
Listing 5 for easy reference.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. The constructor for the PictureExplorer</b>
<b>class. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Public constructor
  * @param picture the picture to explore
  */
 public PictureExplorer(DigitalPicture picture){
   // set the fields
   this.picture = picture;
   zoomFactor = 1;

   // create the window and set things up
   <b>createWindow();</b>
 }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Call the
createWindow method</b></font></p>
<p>The constructor saves the incoming parameter, <i>(which refers to the picture 
to be displayed in the content area of the GUI)</i> and sets a value of 1 into 
the instance variable named <b>zoomFactor</b>.&nbsp; Then it calls the <b>
createWindow</b> method where the completion of construction is accomplished.</p>
<p>When the <b>createWindow</b> method returns, 
the constructor returns the new <b>PictureExplorer</b> object's 
reference to 
the <b>explore</b> method of the <b>SimplePicture</b> class <i>(or perhaps to 
a method in a class of your own design)</i> from which the 
constructor was called.</p>
<p><font color="#FF0000"><b>An anonymous object</b></font></p>
<p>The 
<b>explore</b> method doesn't save the <b>PictureExplorer</b> object's reference in a named reference variable.&nbsp; 
Therefore, the <b>PictureExplorer</b> object is an anonymous object that 
remains on the screen until the user clicks the X-button in the upper-right 
corner of Figure 1 or the program terminates.</p>
<h4><a name="The_createWindow_method">The createWindow method</a></h4>
<p>The <b>createWindow</b> method of the <b>PictureExplorer</b> class is shown in its entirety in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The createWindow method. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Creates the JFrame and sets everything up
  */
 private void createWindow(){
   // create the picture frame and initialize it
   createAndInitPictureFrame();

   // set up the menu bar
   setUpMenuBar();

   //create the information panel
   createInfoPanel();

   //creates the scrollpane for the picture
   <b>createAndInitScrollingImage();</b>

   // show the picture in the frame at the size it needs
   // to be
   pictureFrame.pack();
   pictureFrame.setVisible(true);
 }//end createWindow method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A sequence of method calls</b></font></p>
<p>As you learned in the earlier lessons, the <b>createWindow</b> method 
consists of:</p>
<ul>
	<li>A sequence of four calls to other methods to construct various parts of 
	the <b>PictureExplorer</b> object.</li>
	<li>A call to the <b>pack</b> method to set the <b>JFrame</b> to the correct 
	size.</li>
	<li>A call to the <b>setVisible</b> method to cause the <b>JFrame</b> object 
	to become visible on the screen.</li>
</ul>
<p>I explained the following three methods in the earlier lessons:</p>
<ul>
	<li><b>createAndInitPictureFrame</b></li>
	<li><b>setUpMenuBar</b></li>
	<li><b>createInfoPanel</b></li>
</ul>
<p>I will explain the <b>createAndInitScrollingImage</b> method in this lesson.</p>
<h4><b><a name="The_createAndInitScrollingImage_method">The 
createAndInitScrollingImage method</a></b></h4>
<p>The beginning of the 
<b>createAndInitScrollingImage</b> method is shown in the code fragment in Listing 7.&nbsp;
<i>(Note the change in background color, indicating that the discussion has 
moved down by one level in the method call stack.)</i></p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the 
createAndInitScrollingImage method.</b><table border="1" cols="1" width="477" bgcolor="#FFEEFF">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Create and initialize the scrolling image
  */
 private void createAndInitScrollingImage(){
   scrollPane = new JScrollPane();

   BufferedImage bimg = picture.getBufferedImage();
   <b>imageDisplay = new ImageDisplay(bimg);</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A new JScrollPane object</b></font></p>
<p>Listing 7 begins by instantiating a new object of the <b>JScrollPane</b> 
class, which will be added to the GUI later as the top-level container for the image.&nbsp; 
I will have more to say about this later.</p>
<p><font color="#FF0000"><b>Get a reference to the BufferedImage object</b></font></p>
<p>Then Listing 7 calls the <b>getBufferedImage</b> method on the <b>Picture</b> 
object to get a reference to the <b>BufferedImage</b> object that belongs to the 
picture.&nbsp; <i>(This is the <b>Picture</b> object that was received as a 
parameter when the <b>PictureExplorer</b> object was instantiated.)</i></p>
<p>To make a long story short, the <b>BufferedImage</b> object encapsulates the 
actual image that we see when we look at a display of a <b>Picture</b> object.</p>
<p><font color="#FF0000"><b>Instantiate an ImageDisplay object</b></font></p>
<p>Then things get really interesting.&nbsp; Listing 7 passes the <b>BufferedImage</b> 
object's reference to the constructor for a class that we haven't touched on yet: 
the <b>ImageDisplay</b> class.</p>
<h4><a name="The_ImageDisplay_class">The ImageDisplay class</a></h4>
<p>A complete listing of the source code for the <b>ImageDisplay</b> class is shown in 
Listing 25.</p>
<p>The beginning of the <b>ImageDisplay</b> class is shown in the code fragment 
in Listing 8.&nbsp; <i>(Note the change 
of background color as we put the <b>createAndInitScrollingImage</b> method of 
the <b>PictureExplorer</b> class on the back 
burner while we discuss the <b>ImageDisplay</b> class.)</i></p>
<p>
<b><a name="Listing_8">Listing 8</a>. Beginning of the ImageDisplay class. </b>
<table border="1" cols="1" width="477" bgcolor="#DDFFFF">
  <tbody>
    <tr>
      <td>
      <pre>import javax.swing.*;
import java.awt.*;
import java.awt.image.*;

/**
 * Class to display an image and the current location with
 * a + sign
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class ImageDisplay extends JPanel
                          implements Scrollable{

  //////////// fields (attributes ////////////////////////
  private Image image;       //the image to draw
  private Dimension prefSize;//preferred size of  display
  private int currentX = 0;  //the current x index
  private int currentY = 0;  //the current y index</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 8 simply declares four instance variables and initializes some of them.&nbsp; That's not too exciting, so we won't dwell on that.</p>
<p><font color="#FF0000"><b>Extends JPanel and implements Scrollable</b></font></p>
<p>It is important to note that an object of the <b>ImageDisplay</b> class extends 
the <b>JPanel</b> class and 
implements the <b>Scrollable</b> interface.</p>
<p>Implementation of the <b>Scrollable</b> 
interface makes the object suitable for being displayed in a <b>JScrollPane</b> 
window later.</p>
<p>The fact that the <b>ImageDisplay</b> class extends <b>JPanel</b> makes an object of the class a container into which other 
components can be placed.</p>
<p><font color="#FF0000"><b>Can fire mouse events and display tool tips</b></font></p>
<p>Perhaps more important, as a subclass of <b>
JPanel</b>, the <b>ImageDisplay</b> object has the ability to fire mouse events and 
can register<b> MouseListener</b> and <b>MouseMotionListener</b> objects to 
handle those events.&nbsp; </p>
<p>Finally, being a subclass of <b>JPanel</b> gives the object to ability to 
display tool tip text when the mouse pointer lingers over the object.</p>
<p><font color="#FF0000">
<b>The first overloaded constructor</b></font></p>
<p>Listing 9 shows the first of two overloaded constructors for the <b>
ImageDisplay</b> class.&nbsp; This is the 
constructor that was called by the last statement in Listing 7.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. The first overloaded constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#DDFFFF">
  <tbody>
    <tr>
      <td>
      <pre>  /**
   * Constructor that takes the image to display
   * @param theImage the image to display
   */
  public ImageDisplay(Image theImage){
    image = theImage;
    prefSize = new Dimension(
              image.getWidth(this),image.getHeight(this));
    setPreferredSize(prefSize);
    revalidate();
  }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#EEEEEE">
  <b>An ImageObserver</b><br />
  A reference to <b>this</b> object is passed to the <b>getWidth</b> and <b>
	getHeight</b> methods as an <b>ImageObserver</b>.&nbsp; If you know what 
	this means, good.&nbsp; If not, don't worry about it.&nbsp; It's probably 
	not important in this context.</td></tr></table>
</td>
</tr>
</table>
<p>Except for the last statement, the code in Listing 9 is straightforward.&nbsp; 
That code saves a reference to the incoming <b>BufferedImage</b> object as the 
superclass <b>Image</b> type and sets the preferred size of the new object to 
the width and the height of the image.</p>
<p><font color="#FF0000"><b>The call to the revalidate method</b></font></p>
<p>The typical explanation for a need to call the <b>revalidate</b> method is 
that the call causes the layout manager to re-layout the component and all of 
its children.&nbsp; However, since this component doesn't yet contain any 
children, I can't explain why the author chose to call <b>revalidate</b> at this 
point.&nbsp; I will leave this as <i>an exercise for the student</i> to ponder.</p>
<p><font color="#FF0000">
<b>The second overloaded constructor</b></font></p>
<p>The second of two overloaded constructors is shown in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. The second overloaded constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#DDFFFF">
  <tbody>
    <tr>
      <td>
      <pre>  /**
   * Constructor that takes the image and current x and y
   * @param theImage the image to display
   * @param x the current x value to use
   * @param y the current y value to use
   */
  public ImageDisplay(Image theImage, int x, int y)
  {
    this(theImage);
    currentX = x;
    currentY = y;
  }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This constructor begins by using the <b>this</b> keyword to call the 
constructor shown in Listing 9.&nbsp; When that constructor returns, this 
constructor saves two coordinate values received as incoming parameters in two 
of the instance variables shown in Listing 8.&nbsp; By default, these two 
variables have a value of zero, and the constructor shown in Listing 9 doesn't 
change those values.</p>
<p><font color="#FF0000"><b>Methods of the ImageDisplay class</b></font></p>
<p>There are several methods defined in the <b>ImageDisplay</b> class, which I 
will subdivide into three categories:</p>
<ul>
	<li>Accessor methods</li>
	<li>Scrollable methods</li>
	<li>The paintComponent method</li>
</ul>
<p><font color="#FF0000"><b>Accessor methods</b></font></p>
<p>The code in the accessor methods is very straightforward.&nbsp; The accessor 
methods provide 
access for getting or setting the values in three of the instance variables 
shown in Listing 8.&nbsp; The name of each method indicates its purpose.</p>
<p>The accessor methods are:</p>
<ul>
	<li>getImage</li>
	<li>getCurrentX</li>
	<li>getCurrentY</li>
	<li>setCurrentX</li>
	<li>setCurrentY</li>
	<li>setImage</li>
</ul>
<p><font color="#FF0000"><b>Scrollable methods</b></font></p>
<p>The scrollable methods consist of five methods that are declared in the <b>
Scrollable</b> interface and provide for communication between the <b>ImageDisplay</b> object and its container, which is an object of the <b>
JScrollPane</b> class.</p>
<p>These methods are also accessor methods of the <b>get</b> variety, and the 
code in the methods is not complex.&nbsp; Two of the methods return an <b>int</b> 
value having to do with the scroll-bar movement increments.</p>
<p>Two other methods return a <b>boolean</b> value having to do with how the size of the 
object is to be taken into account when the <b>ImageDisplay</b> object is 
displayed in the <b>JScrollPane</b> object.</p>
<p>One method returns a reference to an object of the class <b>Dimension</b>, which is 
the preferred display size of the <b>ImageDisplay</b> object.</p>
<p><font color="#FF0000"><b>The paintComponent method</b></font></p>
<p>The <b>paintComponent</b> method is called when it is time to actually render the 
image encapsulated in the <b>ImageDisplay</b> object on the screen.&nbsp; This 
is a fairly long and fairly complex method.</p>
<p>I'm not going to try to explain this method in this document.&nbsp; It is 
full of computations based on locations, measurements, and dimensions.&nbsp; It is 
almost necessary to sit down with the code, a pencil, and a sheet of graph paper 
to make sense out of the code.</p>
<p>Once again, I will leave it as an exercise for the student to 
analyze and understand this method.<br>
<br>
<font color="#FF0000"><b>Back to the createAndInitScrollingImage method</b></font><br>
<br>
That brings us back to the <b>createAndInitScrollingImage</b> method where we 
left off in Listing 7.<br>
<br>
The code in Listing 11 causes the <b>PictureExplorer</b> object to be registered 
as a listener object for mouse events fired by the <b>ImageDisplay</b> object.&nbsp; 
In other words, whenever the user clicks or drags the mouse in the image, code 
belonging to the <b>PictureExplorer</b> object will be executed to handle events 
fired by the <b>ImageDisplay</b> object.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Register PictureExplorer object as a 
listener object. </b>
<table border="1" cols="1" width="477" bgcolor="#FFEEFF">
  <tbody>
    <tr>
      <td>
      <pre>imageDisplay.addMouseMotionListener(this);
imageDisplay.addMouseListener(this);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>To understand what is going on here, we need to examine several methods that are defined in the <b>
PictureExplorer</b> class, so I will once again change background colors for the 
code fragments.</p>
<p><font color="#FF0000"><b>PictureExplorer class implements listener interfaces</b></font></p>
<p>If you examine Listing 23, you will see that the <b>PictureExplorer</b> class 
implements the following listener interfaces:</p>
<ul>
	<li>ActionListener</li>
	<li>MouseListener</li>
	<li>MouseMotionListener</li>
</ul>
<p>At this point in the lesson, we are interested only in the last two items in the above 
list.&nbsp; <i>(We will get to the <b>ActionListener</b> interface later in this 
lesson.)</i></p>
<p><font color="#FF0000"><b>Must define concrete event-handler methods</b></font></p>
<p>Because the class implements the <b>MouseListener</b> interface, it 
must provide concrete definitions for the following event-handler methods.&nbsp;
<i>(Recall that concrete method definitions may be empty methods.)</i></p>
<ul>
	<li>mouseClicked</li>
	<li>mouseEntered</li>
	<li>mouseExited</li>
	<li>mousePressed</li>
	<li>mouseReleased</li>
</ul>
<p>Also, because the class implements the <b><a name="MouseMotionListener">MouseMotionListener</a></b> 
interface, it must provide concrete definitions for the following event-handler 
methods:</p>
<ul>
	<li>mouseDragged</li>
	<li>mouseMoved</li>
</ul>
<p><font color="#FF0000">
<b>The mouseClicked and mousePressed event handlers</b></font></p>
<p>I will begin with the methods of the <b>MouseListener</b> 
interface.&nbsp; Of the five methods declared in that interface, only the two 
shown in Listing 12 contain any code.&nbsp; The bodies of the other three are 
completely empty, meaning that when a matching event is fired and the 
method is called, control returns silently to the calling method with no action 
being taken.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. The mouseClicked and mousePressed event 
handlers.</b><table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> 
 /**
  * Method called when the mouse is clicked
  * @param e the mouse event
  */
 public void <b>mouseClicked</b>(MouseEvent e){
   displayPixelInformation(e);
 }//end mouseClicked method

 /**
  * Method called when the mouse button is pushed down
  * @param e the mouse event
  */
 public void <b>mousePressed</b>(MouseEvent e){
   displayPixelInformation(e);
 }//end mousePressed method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Common behavior</b></font></p>
<p>The behavior of both event-handler methods in Listing 12 is the same.&nbsp; 
In both cases, the <b>
displayPixelInformation</b> method is called, passing a reference to the <b>
MouseEvent</b> object received as a parameter by the event handler to the 
method.</p>
<p>Before getting into the code in the <b>
displayPixelInformation</b> method, however, let's take a look at 
the event handlers for the <b>MouseMotionListener</b> interface.</p>
<p><font color="#FF0000"><b>The mouseDragged event handler</b></font></p>
<p>One of the <a href="#MouseMotionListener">two methods</a> declared in the <b>
MouseMotionListener</b> interface <i>(<b>mouseMoved</b>)</i> has an empty body.&nbsp; 
The other method, which is not empty, is shown in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The mouseDragged event handler.</b><table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Called when the mouse is dragged (button held down and
  * moved)
  * @param e the mouse event
  */
 public void mouseDragged(MouseEvent e){
   displayPixelInformation(e);
 }//end mouseDragged method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>More common behavior</b></font></p>
<p>As you can see, the behavior of the event handler in Listing 13 is identical 
to the behavior of the two event handlers in Listing 12.&nbsp; Therefore, it is 
time for us to take a look at the method named <b>displayPixelInformation</b>.</p>
<p><font color="#FF0000">
<b>The displayPixelInformation method</b></font></p>
<p>There are three overloaded versions of methods named
<b>displayPixelInformation</b>
defined in the <b>PictureExplorer</b> class.&nbsp; The version of the <b>displayPixelInformation</b> method that is called by the three event 
handlers discussed above is shown in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. The displayPixelInformation method. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to display pixel information based on a mouse
  * event
  * @param e a mouse event
  */
 private void displayPixelInformation(MouseEvent e)
 {

   // get the cursor x and y
   int cursorX = e.getX();
   int cursorY = e.getY();

   // get the x and y in the original (not scaled image)
   int pictureX = (int)(cursorX/zoomFactor + numberBase);
   int pictureY = (int)(cursorY/zoomFactor + numberBase);

   // display the information for this x and y
   displayPixelInformation(pictureX,pictureY);

 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Three overloaded displayPixelInformation</b> <b>
methods</b></font></p>
<p>As mentioned above, there are three overloaded methods named
<b>displayPixelInformation</b>
defined in the <b>PictureExplorer</b> class.&nbsp; Two of the methods receive 
coordinate information as incoming parameters.</p>
<p>Of these two, one receives the coordinate 
information as type <b>int</b> while the other receives the coordinate 
information as type <b>String</b>.</p>
<p><font color="#FF0000"><b>Purpose of the overloaded displayPixelInformation 
methods</b></font></p>
<p>The purpose of these methods is to display the coordinate and color 
information in the top panel in Figure 1 whenever that information changes.</p>
<p>I explained two overloaded 
versions of the method in the earlier lesson titled <i>Building the Information 
Panel for the PictureExplorer GUI:&nbsp; Multimedia Programming with Java, (See
<a href="#Resources">Resources</a>.)</i></p>
<p><font color="#FF0000"><b>An incoming parameter of type MouseEvent</b></font></p>
<p>The version of the method that is called in Listing 12 and Listing 13 doesn't receive coordinate 
information directly as incoming parameters.&nbsp; Instead, this version of the 
method receives a reference to a <b>MouseEvent</b> object and must extract the 
coordinate information from that object.</p>
<p><font color="#FF0000"><b>Get the coordinate values for the mouse pointer</b></font></p>
<p>Listing 14 begins by calling the <b>getX</b> and <b>getY</b> methods on the 
incoming <b>MouseEvent</b> object to get the coordinate values 
of the mouse pointer when the event was fired.&nbsp; <i>(Note that these two methods return the coordinates of the mouse pointer relative 
to the upper-left corner of the component (<b>JPanel</b>) that fired the 
event even when that corner of the component is outside the visible limits of 
the <b>
JScrollPane</b>.)</i></p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#EEEEEE">
  <b>The numberBase</b><br />
  I discussed the use of the variable named <b>numberBase</b>, for which the 
	value can be only 0 or 1, in an earlier lesson.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Compensate for the zoomFactor</b></font></p>
<p>If the <b>zoomFactor</b> has previously been used to zoom in or out on the 
image, the effective size of the <b>JPanel</b> has been increased or decreased accordingly.</p>
<p>Listing 14 divides the coordinate values returned by the <b>getX</b> and <b>getY</b> 
methods by the <b>zoomFactor</b> to remove the effects of zooming and convert 
the coordinates back to the actual coordinates of the pixel at the location of 
the mouse pointer when the event was fired.</p>
<p><font color="#FF0000"><b>Call another overloaded displayPixelInformation 
method</b></font></p>
<p>Then Listing 14 passes the coordinate values in a call to one of the other 
overloaded versions of the
<b>displayPixelInformation</b> method to cause the coordinate and color 
information to be displayed as shown in the upper portion of Figure 1.</p>
<p><font color="#FF0000">
<b>Remainder of the createAndInitScrollingImage method</b></font></p>
<p>Returning once more to where we left off in the
<b>createAndInitScrollingImage</b> method in Listing 11, the remaining code in 
the method is shown in Listing 15.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Remainder of the 
createAndInitScrollingImage method.</b><table border="1" cols="1" width="477" bgcolor="#FFEEFF">
  <tbody>
    <tr>
      <td>
      <pre>    imageDisplay.setToolTipText("Click a mouse button on "
                + "a pixel to see the pixel information");

    scrollPane.setViewportView(imageDisplay);
    pictureFrame.getContentPane().add(
                         scrollPane, BorderLayout.CENTER);
    }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set text for a toolTip</b></font></p>
<p>Listing 15 begins by calling the <b>setToolTipText</b> method on the <b>
ImageDisplay</b> object to establish the text that is displayed when <i>&quot;the 
mouse pointer lingers over the image&quot;</i> in Figure 1.</p>
<p><font color="#FF0000"><b>Put the ImageDisplay object in the scroll pane</b></font></p>
<p>Following this, Listing 15 calls the <b>setViewportView</b> method on the <b>
JScrollPane</b> object, passing a reference to the <b>ImageDisplay</b> as a 
parameter.&nbsp; Then Listing 15 adds the <b>JScrollPane</b> object to the 
center of the content pane on the <b>JFrame</b> object.</p>
<p>The combination of these two method calls causes the <b>ImageDisplay</b> 
object to be displayed in the CENTER location <i>(with or without scroll bars)</i> 
in the <b>JFrame</b> object as 
shown in Figure 1.</p>
<p><font color="#FF0000"><b>Manually resizing the JFrame object</b></font></p>
<p>The <b>JFrame</b> object can be manually resized.&nbsp; The scroll bars 
appear only when the size of the image is greater than the current size of the 
viewable area of the <b>JFrame</b>.</p>
<p><font color="#FF0000"><b>The end of the createAndInitScrollingImage method</b></font></p>
<p>That signals the end of the
<b>createAndInitScrollingImage</b> method.&nbsp; Hopefully you understand by how 
just how the image is 
displayed in a scrollable window in a <b>PictureExplorer</b> object.</p>
<h4><a name="Additional_methods_of_the_PictureExplorer_class">Additional methods 
of the PictureExplorer class</a></h4>
<p>It may seem to you that we have been working on the <b>PictureExplorer</b> 
class for a long time.&nbsp; Believe it or not, however, we aren't finished with the <b>PictureExplorer</b> 
class yet.&nbsp; There are several more methods that I need to explain.</p>
<h4><a name="The_actionPerformed_method">The actionPerformed method</a></h4>
<p>In the earlier lesson titled <i>Getting Started with the PictureExplorer 
Class:&nbsp; Multimedia Programming with Java (see <a href="#Resources">Resources</a>)</i>, 
I explained that the <b>PictureExplorer</b> class implements the <b>
ActionListener</b> interface and registers and object of itself as an action 
listener on every item in the <b>Zoom</b> menu shown in Figure 1.</p>
<p>I also 
explained that this means that whenever an item on the <b>Zoom</b> menu is selected, the <b>
actionPerformed</b> method defined in the <b>PictureExplorer</b> class is 
called.&nbsp; However, I didn't explain the behavior of the <b>actionPerformed</b> 
method.</p>
<p>That time to explain the <b>actionPerformed</b> has come.&nbsp; The method is shown in its 
entirety in Listing 16.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. The actionPerformed method</b>.<b> </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Controls the zoom menu bar
  *
  * @param a the ActionEvent
  */
 public void actionPerformed(ActionEvent a){

   if(a.getActionCommand().equals("Update")){
     this.repaint();
   }

   if(a.getActionCommand().equals("25%")){
     this.zoom(.25);
     enableZoomItems();
     twentyFive.setEnabled(false);
   }

   if(a.getActionCommand().equals("50%")){
     this.zoom(.50);
     enableZoomItems();
     fifty.setEnabled(false);
   }

   if(a.getActionCommand().equals("75%")){
     this.zoom(.75);
     enableZoomItems();
     seventyFive.setEnabled(false);
   }

   if(a.getActionCommand().equals("100%")){
     this.zoom(1.0);
     enableZoomItems();
     hundred.setEnabled(false);
   }

   if(a.getActionCommand().equals("150%")){
     this.zoom(1.5);
     enableZoomItems();
     hundredFifty.setEnabled(false);
   }

   if(a.getActionCommand().equals("200%")){
     this.zoom(2.0);
     enableZoomItems();
     twoHundred.setEnabled(false);
   }

   if(a.getActionCommand().equals("500%")){
     this.zoom(5.0);
     enableZoomItems();
     fiveHundred.setEnabled(false);
   }
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>actionPerformed</b> method is long, but it isn't complicated.</p>
<p><font color="#FF0000"><b>An ActionEvent object</b></font></p>
<p>Whenever a component fires an action event, it instantiates a new object of 
the <b>ActionEvent</b> class and passes that object's reference in a call to the
<b>actionPerformed</b> methods of every <b>ActionListener</b> object that has 
been registered to be notified of the event.</p>
<p><font color="#FF0000"><b>The action command string</b></font></p>
<p>Among other things, the <b>ActionEvent</b> object encapsulates a reference to 
a <b>String</b> object that can be retrieved by calling the <b>getActionCommand</b> method on the 
reference to the <b>ActionEvent</b> object.</p>
<p><font color="#FF0000"><b>Eight if statements</b></font></p>
<p>The code in the <b>actionPerformed</b> method <i>(see Listing 16)</i> consists of eight <b>if</b> statements.&nbsp; 
Code in the body of each <b>if</b> statement extracts the string from the incoming <b>ActionEvent</b> object.&nbsp; 
The value of the string is tested against eight different literal string values 
to determine what action, if any, to take.</p>
<p>Seven of the eight <b>
if</b> statements test for string values that identify one of the seven 
items on the <b>Zoom</b> menu shown in Figure 1.</p>
<p>The other <b>if</b> statement tests for the string value <i>&quot;Update&quot;</i>.&nbsp; When 
it is determined that the <b>ActionEvent</b> object encapsulates this string value, the <b>repaint</b> 
method is called, causing the entire <b>PictureExplorer</b> object to be 
repainted on the computer screen.&nbsp; I will dispose of that case first.</p>
<p><font color="#FF0000"><b>A string value of <i>&quot;update&quot;</i></b></font></p>
<p>There isn't any code in the <b>PictureExplorer</b> class that instantiates an
<b>ActionEvent</b> object and encapsulates the string <i>&quot;Update&quot;</i> in the 
object.&nbsp; That means that this capability is provided for the benefit of 
other programs that may use of an object of the <b>PictureExplorer</b> class 
and may have a need to cause the object to repaint itself on the screen.</p>
<p><font color="#FF0000"><b>The cases of the seven Zoom menu items</b></font></p>
<p>You saw the code fragment shown in Listing 17 in the earlier lesson titled <i>Getting Started with the PictureExplorer 
Class:&nbsp; Multimedia Programming with Java</i> <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Register the PictureExplorer object as 
an ActionListener on each menu item.</b><table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre>   // add the action listeners
   twentyFive.addActionListener(this);
   fifty.addActionListener(this);
   seventyFive.addActionListener(this);
   hundred.addActionListener(this);
   hundredFifty.addActionListener(this);
   twoHundred.addActionListener(this);
   fiveHundred.addActionListener(this);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of this code was to register the <b>PictureExplorer</b> object as 
an <b>ActionListener</b> on each of the seven menu items shown in the <b>Zoom</b> 
menu in Figure 1.</p>
<p><font color="#FF0000"><b>The default string values</b></font></p>
<p>By default, when a menu item fires an <b>ActionEvent</b>, the string that 
describes the menu item is encapsulated in the <b>ActionEvent</b> object that is 
passed to the <b>actionPerformed</b> method of each registered action listener.</p>
<p>Therefore, when the menu items shown in Figure 1 fire action events, the strings 
&quot;25%&quot;, &quot;50%&quot;, &quot;75%&quot;, etc., are encapsulated in the <b>ActionEvent</b> objects.&nbsp; 
This is exactly what seven of the eight <b>if</b> statements in Listing 16 are 
testing for.</p>
<p><font color="#FF0000"><b>The code for a true condition</b></font></p>
<p>If any one of those seven <b>if</b> statements in Listing 16 returns true, 
very similar code is executed.&nbsp; That code:</p>
<ul>
	<li>Calls the <b>zoom</b> method passing a numeric value as a parameter.</li>
	<li>Calls the <b>enableZoomItems</b> method.</li>
	<li>Calls the <b>setEnabled</b> method on a reference to the menu item that 
	fired the event, passing false as a parameter.</li>
</ul>
<p>I will explain these three actions in reverse order, which is generally the 
order of increasing complexity.</p>
<p><font color="#FF0000"><b>Calling the setEnabled method</b></font></p>
<p>The last of the three actions is to call the <b>setEnabled</b> method on the 
item that fired the event, passing false as a parameter.</p>
<p>This disables that particular menu item, making it incapable of being 
selected again until it has been enabled.&nbsp; For example, the menu item labeled <i>&quot;100%&quot;</i> has 
been disabled in Figure 1, because that is the current zoom level.&nbsp; <i>
(There is no point in being able to select a Zoom menu item that matches the 
current zoom level.)</i></p>
<p><font color="#FF0000">
<b>The enableZoomItems method</b></font></p>
<p>Immediately prior to making the call to the <b>setEnabled</b> method, the 
code in Listing 16 calls the
<b>enableZoomItems</b> method.&nbsp; This method is shown in Listing 18.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. The enableZoomItems method</b>.<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to enable all menu commands
  */
 private void enableZoomItems(){
   twentyFive.setEnabled(true);
   fifty.setEnabled(true);
   seventyFive.setEnabled(true);
   hundred.setEnabled(true);
   hundredFifty.setEnabled(true);
   twoHundred.setEnabled(true);
   fiveHundred.setEnabled(true);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 18 enables all seven menu items.&nbsp; The effect of the 
last two statements inside the body of each of the last seven <b>if</b> 
statements in Listing 16 is to enable all seven menu items, and then disable the 
one that fired the event.</p>
<p>That is the easy part.&nbsp; The more complex part of handling the action 
event is the call to the <b>zoom</b> 
method as the first statement in the body of each of the last seven <b>if </b>
statements in Listing 16.</p>
<p><font color="#FF0000">
<b>The beginning of the zoom method</b></font></p>
<p>The zoom method begins in Listing 19.</p>
<p>Note first that each call to the <b>zoom</b> method in Listing 16 passes the 
zoom factor <i>(ranging from 0.25 to 5.0)</i> as a parameter to the <b>zoom</b> 
method.&nbsp; As you will see, this factor is used to scale the size of the 
displayed image in the <b>PictureExplorer</b> object.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. The beginning of the zoom method. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Zooms in the on picture by scaling the image.
  * It is extremely memory intensive.
  * @param factor the amount to zoom by
  */
 public void zoom(double factor)
 {
   // save the current zoom factor
   zoomFactor = factor;

   // calculate the new width and height and get an image
   // that size
   int width = (int) (picture.getWidth()*zoomFactor);
   int height = (int) (picture.getHeight()*zoomFactor);
   BufferedImage bimg = picture.getBufferedImage();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Save the new zoom state</b></font></p>
<p>Listing 19 begins by saving the incoming parameter in the instance variable 
named <b>zoomFactor</b>.&nbsp; From that point forward, the contents of that 
variable can be queried by other methods that need to know the current zoom 
state.</p>
<p><font color="#FF0000"><b>Calculate the zoomed size</b></font></p>
<p>Then Listing 19 calculates the required width and height of the displayed image 
by multiplying the raw dimensions of the picture by the <b>zoomFactor</b>.</p>
<p><font color="#FF0000"><b>Get a reference to the buffered image</b></font></p>
<p>Finally Listing 19 gets a reference to the <b>BufferedImage</b> object that 
actually contains the image in the <b>Picture</b> object.</p>
<p><font color="#FF0000">
<b>Replace the current image with a scaled image</b></font></p>
<p>Listing 20 calls the <b>setImage</b> method on the <b>ImageDisplay</b> object 
to cause the image being displayed to be replaced with a new scaled image.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Replace the current image with a scaled 
image. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre>   // set the scroll image icon to the new image
   imageDisplay.setImage(bimg.getScaledInstance(width,
                           height, Image.SCALE_DEFAULT));
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The interesting code is in the parameter list</b></font></p>
<p>The interesting code in Listing 20 is the code in the parameter list when the
<b>setImage</b> method is called.&nbsp; This code calls the <b>getScaledInstance</b> 
method on the <b>BufferedImage</b> object, passing the width, height, and a 
constant named <b>SCALE_DEFAULT</b> as parameters.</p>
<p><font color="#FF0000"><b>What does Sun have to say about this?</b></font></p>
<p>Figure 3 contains some of what Sun has to say about the <b>getScaledInstance</b> 
method.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Partial description of the 
	getScaledInstance method. </b> 
<table border="1" cols="1" width="477" bgcolor="#C1C100" >
  <tbody>
    <tr>
      <td>
      Creates a scaled version of this image.<p>A new <b>Image</b> object is 
		returned which will render the image at the specified <b>width</b> and
		<b>height</b> by default.
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In other words, a new scaled <b>Image</b> object is created and passed to the
<b>setImage</b> method of the <b>ImageDisplay</b> object to be displayed in 
place of the image currently being displayed.</p>
<p><font color="#FF0000"><b>What about the constant named SCALE_DEFAULT</b></font></p>
<p>The constant named <b>SCALE_DEFAULT</b> that is passed to the
 <b>getScaledInstance</b> method tells the method to use a default 
algorithm to scale the image.&nbsp; Several other optional constants are available 
that generally trade off speed against the smoothness of the scaled image.</p>
<p><font color="#FF0000">
<b>The remainder of the zoom method</b></font></p>
<p>The first three statements in Listing 21 take care of some housekeeping 
chores insofar as the <b>ImageDisplay</b> object is concerned.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. The remainder of the zoom method. </b>
<table border="1" cols="1" width="477" bgcolor="#FFFFBB">
  <tbody>
    <tr>
      <td>
      <pre>   imageDisplay.setCurrentX((int) (xIndex * zoomFactor));
   imageDisplay.setCurrentY((int) (yIndex * zoomFactor));
   imageDisplay.revalidate();
   
   checkScroll();  // check if need to reposition scroll
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Not a housekeeping matter</b></font></p>
<p>The last statement in Listing 21 is another matter.&nbsp; This statement 
calls the <b>checkScroll</b> method for the purpose of checking to determine if 
the current position is in the viewing area and if not, to scroll to center the 
current position if possible.</p>
<p><font color="#FF0000">
<b>Partial listing of the checkScroll method</b></font></p>
<p>A partial listing of the <b>checkScroll</b> method is shown in Listing 22.&nbsp;
<i>(You can view the method in its entirety in Listing 23 near the end of the 
lesson.)</i></p>
<p>
<b><a name="Listing_22">Listing 22</a>. Partial listing of the checkScroll 
method. </b>
<table border="1" cols="1" width="477" bgcolor="#FFEEFF">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to check that the current position is in the
  * viewing area and if not scroll to center the current
  * position if possible
  */
 public void checkScroll()
 {
   // get the x and y position in pixels
   int xPos = (int) (xIndex * zoomFactor);
   int yPos = (int) (yIndex * zoomFactor);

   // only do this if the image is larger than normal
   if (zoomFactor &gt; 1) {

     // get the rectangle that defines the current view
     JViewport viewport = scrollPane.getViewport();
     Rectangle rect = viewport.getViewRect();
//code deleted for brevity

     // move the viewport upper left point
     viewport.scrollRectToVisible(
         new Rectangle(viewX,viewY,rectWidth,rectHeight));
   }
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Wanted: source code, pencil, and graph paper</b></font></p>
<p>This is another one of those cases where you almost need to sit down with the 
source code, a pencil, and a sheet of graph paper to sketch and figure out what 
is going on.&nbsp; I decided to leave that as an <i>exercise for the student</i> and 
deleted the tedious parts of the code in Listing 22, keeping the code that wraps around that tedious code.</p>
<p><font color="#FF0000"><b>Scrolling the image programatically</b></font></p>
<p>The main thing that I wanted to show you is that it is possible to:</p>
<ul>
	<li>Get a reference 
to an object of type <b>JViewport</b>&nbsp; that defines the current view of a
	<b>JScrollPane</b> object</li>
	<li>Call the <b>scrollRectToVisible</b> method on 
that object to programatically scroll the view so that the <b>Rectangle</b> 
object passed as a parameter to the method becomes visible.</li>
</ul>
<p>In other 
words, you can write code that will emulate a user manually scrolling the view 
by using 
the scrollbars shown in Figure 1.</p>
<p><font color="#FF0000"><b>The end of the zoom method</b></font></p>
<p>As shown in Listing 21, the call to the <b>checkScroll</b> method signals the 
end of the <b>zoom</b> method, which began in Listing 19.</p>
<p><font color="#FF0000"><b>Remaining methods of the PictureExplorer class</b></font></p>
<p>That leaves the following methods of the <b>PictureExplorer</b> class that I 
haven't explained yet.</p>
<ul>
	<li>changeToBaseOne()</li>
	<li>setTitle(String title)</li>
	<li>repaint()</li>
	<li>isLocationInPicture(int x, int y)</li>
	<li>clearInformation()</li>
	<li>main( String args[])</li>
</ul>
<p>Generally speaking, the names of the methods in the above list indicate their purpose.&nbsp; <i>
(The main method is provided so that the class can be tested as a stand-alone 
application.)</i></p>
<p>The code in each of these methods is straightforward.&nbsp; Therefore, I won't bore you with an explanation.&nbsp; You 
can view the code for all of the methods in Listing 23.</p>
<p><font color="#FF0000"><b>A FocusTraversalPolicy Class </b></font></p>
<p>In addition, the <b>PictureExplorer</b> class defines a private member class 
named <b>PictureExplorerFocusTraversalPolicy</b>, which extends the class named
<b>FocusTraversalPolicy</b>.</p>
<p>You learned in the earlier lesson titled <i>Getting Started with the PictureExplorer 
Class:&nbsp; Multimedia Programming with Java</i> <i>(see <a href="#Resources">Resources</a>)</i> 
that an object of the <b>PictureExplorerFocusTraversalPolicy</b> class is used 
to set the focus traversal policy of the <b>PictureExplorer</b> object.</p>
<p>There is nothing trivial about the code in the definition of this member 
class.&nbsp; However, focus traversal policy is a major topic and one which 
probably deserves one or two lessons in its own right.&nbsp; Therefore, I will 
simply have to leave the explanation of this class for a future lesson.</p>
<p>That concludes the explanation of the <b>PictureExplorer</b> class.&nbsp; </p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to make a copy of the source code for the <b>
PictureExplorer</b> class.&nbsp; 
Put it in your current directory along with your program&nbsp;files and then 
open the file in your IDE.&nbsp; <i>(Make certain that the current directory 
appears in the classpath to the left of Ericson's media library.)</i></p>
<p>Experiment with the <b>PictureExplorer</b> code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.&nbsp; </p>
<p>Also experiment with the <b>PictureExplorer</b> onscreen GUI.&nbsp;&nbsp; Try some different image 
files and see if the color values reported by the GUI make sense to you.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In the previous two lessons, you learned about the overall construction of the <b>
PictureExplorer</b> GUI shown in Figure 1.&nbsp; You also learned how to 
construct the <b>Zoom</b> menu and how to register event listener objects on the items 
in the menu.</p>
<p>You learned how to construct the <b>infoPanel</b> in the 
NORTH location of the GUI in Figure 1.&nbsp; You also learned how 
to register event listener objects on the components in that panel making use of 
objects of anonymous classes.</p>
<p>Along the way, you also learned about some other interesting topics 
including:</p>
<ul>
	<li>The use of <b>BoxLayout</b></li>
	<li>The class file naming scheme.</li>
	<li>The use of <b>getResources</b> to get the URL of a file</li>
	<li>The use of a class loader to load a resource file</li>
</ul>
<p>In this lesson, you learned:</p>
<ul>
	<li>How the image is displayed <i>(with scrolling)</i> 
in the lower portion of Figure 1.</li>
	<li>How mouse events are used to set and move the 
cursor in the image</li>
	<li>How mouse events cause color and location information to be displayed in 
the upper portion of Figure 1.</li>
</ul>
<p>You also learned about a class named <b>ImageDisplay</b>, which you may find 
useful in programs of your own design.</p>
<p>By now you should have a pretty good handle on the <b>
PictureExplorer</b> class and should be able to incorporate it into 
programs of your own.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>Future lesssons will explain a variety of topics including:</p>
<ul>
	<li>Alpha Transparency and the Picture class</li>
	<li>A Comparison of the HSB and RGB Color Models</li>
	<li>Statistical Processing of Digital Photographs</li>
	<li>Adding 3D Contour Mapping to Ericson's Multimedia Library</li>
</ul>

<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java355.htm">355</a> The HSB Color Model</li>
	<li><a href="http://www.dickbaldwin.com/java/Java356.htm">356</a> The show Method and the PictureFrame Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java357.htm">357</a> An HSB 
	Color-Editing Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java358.htm">358</a> Applying 
	Affine Transforms to Picture Objects</li>
	<li><a href="http://www.dickbaldwin.com/java/Java359.htm">359</a> Creating a 
	lasso for editing digital photos in Java</li>
	<li><a href="http://www.dickbaldwin.com/java/Java360.htm">360</a> Wrapping 
	Up the SimplePicture Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java361.htm">361</a> A 
	Temperature and Tint Editing Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java362.htm">362</a> Getting 
	Started with the PictureExplorer Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java363.htm">363</a> Redeye 
	Correction in Digital Photographs</li>
	<li><a href="http://www.dickbaldwin.com/java/Java364.htm">364</a> Building 
	the Information Panel for the PictureExplorer GUI</li>
	<li><a href="http://www.dickbaldwin.com/java/Java365.htm">365</a> Using 
	Flood-Fill in Java Programs</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 23 through Listing 25 below.
<p>
<b><a name="Listing_23">Listing 23</a>. Source code for Ericson's PictureExplorer class. </b>
<table border="1" cols="1" width="477" bgcolor="#EEEEEE">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.image.*;
import javax.swing.border.*;
/**
 * Displays a picture and lets you explore the picture by
 * displaying the x, y, red, green, and blue values of the
 * pixel at the cursor when you click a mouse button or
 * press and hold a mouse button while moving the cursor.
 * It also lets you zoom in or out.  You can also type in
 * a x and y value to see the color at that location.
 *
 * Originally created for the Jython Environment for
 * Students (JES).
 * Modified to work with DrJava by Barbara Ericson
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Keith McDermottt, gte047w@cc.gatech.edu
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class PictureExplorer implements
       MouseMotionListener, ActionListener, MouseListener{

 // current x and y index
 private int xIndex = 0;
 private int yIndex = 0;

 //Main gui variables
 private JFrame pictureFrame;
 private JScrollPane scrollPane;

 //information bar variables
 private JLabel xLabel;
 private JButton xPrevButton;
 private JButton yPrevButton;
 private JButton xNextButton;
 private JButton yNextButton;
 private JLabel yLabel;
 private JTextField xValue;
 private JTextField yValue;
 private JLabel rValue;
 private JLabel gValue;
 private JLabel bValue;
 private JLabel colorLabel;
 private JPanel colorPanel;

 // menu components
 private JMenuBar menuBar;
 private JMenu zoomMenu;
 private JMenuItem twentyFive;
 private JMenuItem fifty;
 private JMenuItem seventyFive;
 private JMenuItem hundred;
 private JMenuItem hundredFifty;
 private JMenuItem twoHundred;
 private JMenuItem fiveHundred;

 /** The picture being explored */
 private DigitalPicture picture;

 /** The image icon used to display the picture */
 private ImageIcon scrollImageIcon;

 /** The image display */
 private ImageDisplay imageDisplay;

 /** the zoom factor (amount to zoom) */
 private double zoomFactor;

 /** the number system to use, 0 means starting at 0,
  *  1 means starting at 1 */
 private int numberBase=0;

 /**
  * Public constructor
  * @param picture the picture to explore
  */
 public PictureExplorer(DigitalPicture picture)
 {
   // set the fields
   this.picture=picture;
   zoomFactor=1;

   // create the window and set things up
   createWindow();
 }

 /**
  * Changes the number system to start at one
  */
 public void changeToBaseOne()
 {
   numberBase=1;
 }

 /**
  * Set the title of the frame
  *@param title the title to use in the JFrame
  */
 public void setTitle(String title)
 {
   pictureFrame.setTitle(title);
 }

 /**
  * Method to create and initialize the picture frame
  */
 private void createAndInitPictureFrame()
 {
   pictureFrame = new JFrame(); // create the JFrame
   //allow the user to resize it
   pictureFrame.setResizable(true);
    // use border layout
   pictureFrame.getContentPane().setLayout(
                                      new BorderLayout());
    // when close stop
   pictureFrame.setDefaultCloseOperation(
                                 JFrame.DISPOSE_ON_CLOSE);
   pictureFrame.setTitle(picture.getTitle());
   PictureExplorerFocusTraversalPolicy newPolicy =
                new PictureExplorerFocusTraversalPolicy();
   pictureFrame.setFocusTraversalPolicy(newPolicy);

 }

 /**
  * Method to create the menu bar, menus, and menu items
  */
 private void setUpMenuBar()
 {
   //create menu
   menuBar = new JMenuBar();
   zoomMenu = new JMenu("Zoom");
   twentyFive = new JMenuItem("25%");
   fifty = new JMenuItem("50%");
   seventyFive = new JMenuItem("75%");
   hundred = new JMenuItem("100%");
   hundred.setEnabled(false);
   hundredFifty = new JMenuItem("150%");
   twoHundred = new JMenuItem("200%");
   fiveHundred = new JMenuItem("500%");

   // add the action listeners
   twentyFive.addActionListener(this);
   fifty.addActionListener(this);
   seventyFive.addActionListener(this);
   hundred.addActionListener(this);
   hundredFifty.addActionListener(this);
   twoHundred.addActionListener(this);
   fiveHundred.addActionListener(this);

   // add the menu items to the menus
   zoomMenu.add(twentyFive);
   zoomMenu.add(fifty);
   zoomMenu.add(seventyFive);
   zoomMenu.add(hundred);
   zoomMenu.add(hundredFifty);
   zoomMenu.add(twoHundred);
   zoomMenu.add(fiveHundred);
   menuBar.add(zoomMenu);

   // set the menu bar to this menu
   pictureFrame.setJMenuBar(menuBar);
 }

 /**
  * Create and initialize the scrolling image
  */
 private void createAndInitScrollingImage()
 {
   scrollPane = new JScrollPane();

   BufferedImage bimg = picture.getBufferedImage();
   imageDisplay = new ImageDisplay(bimg);
   imageDisplay.addMouseMotionListener(this);
   imageDisplay.addMouseListener(this);
   imageDisplay.setToolTipText("Click a mouse button on "
                + "a pixel to see the pixel information");
   scrollPane.setViewportView(imageDisplay);
   pictureFrame.getContentPane().add(
                         scrollPane, BorderLayout.CENTER);
 }

 /**
  * Creates the JFrame and sets everything up
  */
 private void createWindow()
 {
   // create the picture frame and initialize it
   createAndInitPictureFrame();

   // set up the menu bar
   setUpMenuBar();

   //create the information panel
   createInfoPanel();

   //creates the scrollpane for the picture
   createAndInitScrollingImage();

   // show the picture in the frame at the size it needs
   // to be
   pictureFrame.pack();
   pictureFrame.setVisible(true);
 }

 /**
  * Method to set up the next and previous buttons for the
  * pixel location information
  */
 private void setUpNextAndPreviousButtons()
 {
   // create the image icons for the buttons
   Icon prevIcon = new ImageIcon(
         SoundExplorer.class.getResource("leftArrow.gif"),
                                        "previous index");
   Icon nextIcon = new ImageIcon(
        SoundExplorer.class.getResource("rightArrow.gif"),
                                            "next index");
   // create the arrow buttons
   xPrevButton = new JButton(prevIcon);
   xNextButton = new JButton(nextIcon);
   yPrevButton = new JButton(prevIcon);
   yNextButton = new JButton(nextIcon);

   // set the tool tip text
   xNextButton.setToolTipText(
                       "Click to go to the next x value");
   xPrevButton.setToolTipText(
                   "Click to go to the previous x value");
   yNextButton.setToolTipText(
                       "Click to go to the next y value");
   yPrevButton.setToolTipText(
                   "Click to go to the previous y value");

   // set the sizes of the buttons
   int prevWidth = prevIcon.getIconWidth() + 2;
   int nextWidth = nextIcon.getIconWidth() + 2;
   int prevHeight = prevIcon.getIconHeight() + 2;
   int nextHeight = nextIcon.getIconHeight() + 2;
   Dimension prevDimension =
                      new Dimension(prevWidth,prevHeight);
   Dimension nextDimension =
                     new Dimension(nextWidth, nextHeight);
   xPrevButton.setPreferredSize(prevDimension);
   yPrevButton.setPreferredSize(prevDimension);
   xNextButton.setPreferredSize(nextDimension);
   yNextButton.setPreferredSize(nextDimension);

   // handle previous x button press
   xPrevButton.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent evt) {
       xIndex--;
       if (xIndex &lt; 0)
         xIndex = 0;
       displayPixelInformation(xIndex,yIndex);
     }
   });

   // handle previous y button press
   yPrevButton.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent evt) {
       yIndex--;
       if (yIndex &lt; 0)
         yIndex = 0;
       displayPixelInformation(xIndex,yIndex);
     }
   });

   // handle next x button press
   xNextButton.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent evt) {
       xIndex++;
       if (xIndex &gt;= picture.getWidth())
         xIndex = picture.getWidth() - 1;
       displayPixelInformation(xIndex,yIndex);
     }
   });

   // handle next y button press
   yNextButton.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent evt) {
       yIndex++;
       if (yIndex &gt;= picture.getHeight())
         yIndex = picture.getHeight() - 1;
       displayPixelInformation(xIndex,yIndex);
     }
   });
 }

 /**
  * Create the pixel location panel
  * @param labelFont the font for the labels
  * @return the location panel
  */
 public JPanel createLocationPanel(Font labelFont) {

   // create a location panel
   JPanel locationPanel = new JPanel();
   locationPanel.setLayout(new FlowLayout());
   Box hBox = Box.createHorizontalBox();

   // create the labels
   xLabel = new JLabel("X:");
   yLabel = new JLabel("Y:");

   // create the text fields
   xValue = new JTextField(
                 Integer.toString(xIndex + numberBase),6);
   xValue.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent e) {
       displayPixelInformation(
                       xValue.getText(),yValue.getText());
     }
   });
   yValue = new JTextField(
                 Integer.toString(yIndex + numberBase),6);
   yValue.addActionListener(new ActionListener() {
     public void actionPerformed(ActionEvent e) {
      displayPixelInformation(
                       xValue.getText(),yValue.getText());
     }
   });

   // set up the next and previous buttons
   setUpNextAndPreviousButtons();

   // set up the font for the labels
   xLabel.setFont(labelFont);
   yLabel.setFont(labelFont);
   xValue.setFont(labelFont);
   yValue.setFont(labelFont);

   // add the items to the vertical box and the box to
   // the panel
   hBox.add(Box.createHorizontalGlue());
   hBox.add(xLabel);
   hBox.add(xPrevButton);
   hBox.add(xValue);
   hBox.add(xNextButton);
   hBox.add(Box.createHorizontalStrut(10));
   hBox.add(yLabel);
   hBox.add(yPrevButton);
   hBox.add(yValue);
   hBox.add(yNextButton);
   locationPanel.add(hBox);
   hBox.add(Box.createHorizontalGlue());

   return locationPanel;
 }

 /**
  * Create the color information panel
  * @param labelFont the font to use for labels
  * @return the color information panel
  */
 private JPanel createColorInfoPanel(Font labelFont)
 {
   // create a color info panel
   JPanel colorInfoPanel = new JPanel();
   colorInfoPanel.setLayout(new FlowLayout());

   // get the pixel at the x and y
   Pixel pixel = new Pixel(picture,xIndex,yIndex);

   // create the labels
   rValue = new JLabel("R: " + pixel.getRed());
   gValue = new JLabel("G: " + pixel.getGreen());
   bValue = new JLabel("B: " + pixel.getBlue());

   // create the sample color panel and label
   colorLabel = new JLabel("Color at location: ");
   colorPanel = new JPanel();
   colorPanel.setBorder(new LineBorder(Color.black,1));

   // set the color sample to the pixel color
   colorPanel.setBackground(pixel.getColor());

   // set the font
   rValue.setFont(labelFont);
   gValue.setFont(labelFont);
   bValue.setFont(labelFont);
   colorLabel.setFont(labelFont);
   colorPanel.setPreferredSize(new Dimension(25,25));

   // add items to the color information panel
   colorInfoPanel.add(rValue);
   colorInfoPanel.add(gValue);
   colorInfoPanel.add(bValue);
   colorInfoPanel.add(colorLabel);
   colorInfoPanel.add(colorPanel);

   return colorInfoPanel;
 }

 /**
  * Creates the North JPanel with all the pixel location
  * and color information
  */
 private void createInfoPanel()
 {
   // create the info panel and set the layout
   JPanel infoPanel = new JPanel();
   infoPanel.setLayout(new BorderLayout());

   // create the font
   Font largerFont =
                   new Font(infoPanel.getFont().getName(),
                       infoPanel.getFont().getStyle(),14);

   // create the pixel location panel
   JPanel locationPanel = createLocationPanel(largerFont);

   // create the color informaiton panel
   JPanel colorInfoPanel =
                         createColorInfoPanel(largerFont);

   // add the panels to the info panel
   infoPanel.add(BorderLayout.NORTH,locationPanel);
   infoPanel.add(BorderLayout.SOUTH,colorInfoPanel);

   // add the info panel
   pictureFrame.getContentPane().add(
                            BorderLayout.NORTH,infoPanel);
 }

 /**
  * Method to check that the current position is in the
  * viewing area and if not scroll to center the current
  * position if possible
  */
 public void checkScroll()
 {
   // get the x and y position in pixels
   int xPos = (int) (xIndex * zoomFactor);
   int yPos = (int) (yIndex * zoomFactor);

   // only do this if the image is larger than normal
   if (zoomFactor &gt; 1) {

     // get the rectangle that defines the current view
     JViewport viewport = scrollPane.getViewport();
     Rectangle rect = viewport.getViewRect();
     int rectMinX = (int) rect.getX();
     int rectWidth = (int) rect.getWidth();
     int rectMaxX = rectMinX + rectWidth - 1;
     int rectMinY = (int) rect.getY();
     int rectHeight = (int) rect.getHeight();
     int rectMaxY = rectMinY + rectHeight - 1;

     // get the maximum possible x and y index
     int maxIndexX = (int)(picture.getWidth()*zoomFactor)
                           - rectWidth - 1;
     int maxIndexY = (int)(picture.getHeight()*zoomFactor)
                           - rectHeight - 1;

     // calculate how to position the current position in
     // the middle of the viewing area
     int viewX = xPos - (int) (rectWidth / 2);
     int viewY = yPos - (int) (rectHeight / 2);

     // reposition the viewX and viewY if outside allowed
     // values
     if (viewX &lt; 0)
       viewX = 0;
     else if (viewX &gt; maxIndexX)
       viewX = maxIndexX;
     if (viewY &lt; 0)
       viewY = 0;
     else if (viewY &gt; maxIndexY)
       viewY = maxIndexY;

     // move the viewport upper left point
     viewport.scrollRectToVisible(
         new Rectangle(viewX,viewY,rectWidth,rectHeight));
   }
 }

 /**
  * Zooms in the on picture by scaling the image.
  * It is extremely memory intensive.
  * @param factor the amount to zoom by
  */
 public void zoom(double factor)
 {
   // save the current zoom factor
   zoomFactor = factor;

   // calculate the new width and height and get an image
   // that size
   int width = (int) (picture.getWidth()*zoomFactor);
   int height = (int) (picture.getHeight()*zoomFactor);
   BufferedImage bimg = picture.getBufferedImage();

   // set the scroll image icon to the new image
   imageDisplay.setImage(bimg.getScaledInstance(width,
                           height, Image.SCALE_DEFAULT));
   imageDisplay.setCurrentX((int) (xIndex * zoomFactor));
   imageDisplay.setCurrentY((int) (yIndex * zoomFactor));
   imageDisplay.revalidate();
   checkScroll();  // check if need to reposition scroll
 }

 /**
  * Repaints the image on the scrollpane.
  */
 public void repaint()
 {
   pictureFrame.repaint();
 }

 //****************************************//
 //               Event Listeners          //
 //****************************************//

 /**
  * Called when the mouse is dragged (button held down and
  * moved)
  * @param e the mouse event
  */
 public void mouseDragged(MouseEvent e)
 {
   displayPixelInformation(e);
 }

 /**
  * Method to check if the given x and y are in the
  * picture
  * @param x the horiztonal value
  * @param y the vertical value
  * @return true if the x and y are in the picture and
  * false otherwise
  */
 private boolean isLocationInPicture(int x, int y)
 {
   boolean result = false; // the default is false
   if (x &gt;= 0 && x &lt; picture.getWidth() &&
       y &gt;= 0 && y &lt; picture.getHeight())
     result = true;

   return result;
 }

 /**
  * Method to display the pixel information from the
  * passed x and y but also converts x and y from strings
  * @param xString the x value as a string from the user
  * @param yString the y value as a string from the user
  */
 public void displayPixelInformation(
                           String xString, String yString)
 {
   int x = -1;
   int y = -1;
   try {
     x = Integer.parseInt(xString);
     x = x - numberBase;
     y = Integer.parseInt(yString);
     y = y - numberBase;
   } catch (Exception ex) {
   }

   if (x &gt;= 0 && y &gt;= 0) {
     displayPixelInformation(x,y);
   }
 }

 /**
  * Method to display pixel information for the passed x
  * and y
  * @param pictureX the x value in the picture
  * @param pictureY the y value in the picture
  */
 private void displayPixelInformation(
                               int pictureX, int pictureY)
 {
   // check that this x and y is in range
   if (isLocationInPicture(pictureX, pictureY))
   {
     // save the current x and y index
     xIndex = pictureX;
     yIndex = pictureY;

     // get the pixel at the x and y
     Pixel pixel = new Pixel(picture,xIndex,yIndex);

     // set the values based on the pixel
     xValue.setText(Integer.toString(
                                   xIndex  + numberBase));
     yValue.setText(Integer.toString(
                                    yIndex + numberBase));
     rValue.setText("R: " + pixel.getRed());
     gValue.setText("G: " + pixel.getGreen());
     bValue.setText("B: " + pixel.getBlue());
     colorPanel.setBackground(new Color(pixel.getRed(),
                                        pixel.getGreen(),
                                        pixel.getBlue()));

   }
   else
   {
     clearInformation();
   }

   // notify the image display of the current x and y
   imageDisplay.setCurrentX((int) (xIndex * zoomFactor));
   imageDisplay.setCurrentY((int) (yIndex * zoomFactor));
 }

 /**
  * Method to display pixel information based on a mouse
  * event
  * @param e a mouse event
  */
 private void displayPixelInformation(MouseEvent e)
 {

   // get the cursor x and y
   int cursorX = e.getX();
   int cursorY = e.getY();

   // get the x and y in the original (not scaled image)
   int pictureX = (int)(cursorX/zoomFactor + numberBase);
   int pictureY = (int)(cursorY/zoomFactor + numberBase);

   // display the information for this x and y
   displayPixelInformation(pictureX,pictureY);

 }

 /**
  * Method to clear the labels and current color and
  * reset the  current index to -1
  */
 private void clearInformation()
 {
   xValue.setText("N/A");
   yValue.setText("N/A");
   rValue.setText("R: N/A");
   gValue.setText("G: N/A");
   bValue.setText("B: N/A");
   colorPanel.setBackground(Color.black);
   xIndex = -1;
   yIndex = -1;
 }

 /**
  * Method called when the mouse is moved with no buttons
  * down
  * @param e the mouse event
  */
 public void mouseMoved(MouseEvent e)
 {}

 /**
  * Method called when the mouse is clicked
  * @param e the mouse event
  */
 public void mouseClicked(MouseEvent e)
 {
   displayPixelInformation(e);
 }

 /**
  * Method called when the mouse button is pushed down
  * @param e the mouse event
  */
 public void mousePressed(MouseEvent e)
 {
   displayPixelInformation(e);
 }

 /**
  * Method called when the mouse button is released
  * @param e the mouse event
  */
 public void mouseReleased(MouseEvent e)
 {
 }

 /**
  * Method called when the component is entered (mouse
  * moves over it)
  * @param e the mouse event
  */
 public void mouseEntered(MouseEvent e)
 {
 }

 /**
  * Method called when the mouse moves over the component
  * @param e the mouse event
  */
 public void mouseExited(MouseEvent e)
 {
 }

 /**
  * Method to enable all menu commands
  */
 private void enableZoomItems()
 {
   twentyFive.setEnabled(true);
   fifty.setEnabled(true);
   seventyFive.setEnabled(true);
   hundred.setEnabled(true);
   hundredFifty.setEnabled(true);
   twoHundred.setEnabled(true);
   fiveHundred.setEnabled(true);
 }

 /**
  * Controls the zoom menu bar
  *
  * @param a the ActionEvent
  */
 public void actionPerformed(ActionEvent a)
 {

   if(a.getActionCommand().equals("Update"))
   {
     this.repaint();
   }

   if(a.getActionCommand().equals("25%"))
   {
     this.zoom(.25);
     enableZoomItems();
     twentyFive.setEnabled(false);
   }

   if(a.getActionCommand().equals("50%"))
   {
     this.zoom(.50);
     enableZoomItems();
     fifty.setEnabled(false);
   }

   if(a.getActionCommand().equals("75%"))
   {
     this.zoom(.75);
     enableZoomItems();
     seventyFive.setEnabled(false);
   }

   if(a.getActionCommand().equals("100%"))
   {
     this.zoom(1.0);
     enableZoomItems();
     hundred.setEnabled(false);
   }

   if(a.getActionCommand().equals("150%"))
   {
     this.zoom(1.5);
     enableZoomItems();
     hundredFifty.setEnabled(false);
   }

   if(a.getActionCommand().equals("200%"))
   {
     this.zoom(2.0);
     enableZoomItems();
     twoHundred.setEnabled(false);
   }

   if(a.getActionCommand().equals("500%"))
   {
     this.zoom(5.0);
     enableZoomItems();
     fiveHundred.setEnabled(false);
   }
 }

 /**
  * Test Main.  It will ask you to pick a file and then
  * show it
  */
 public static void main( String args[])
 {
   Picture p = new Picture(FileChooser.pickAFile());
   PictureExplorer test = new PictureExplorer(p);

 }

 /**
  * Class for establishing the focus for the textfields
  */
 private class PictureExplorerFocusTraversalPolicy
                 extends FocusTraversalPolicy {

        /**
         * Method to get the next component for focus
         */
        public Component getComponentAfter(
                                 Container focusCycleRoot,
                                 Component aComponent) {
            if (aComponent.equals(xValue))
              return yValue;
            else
              return xValue;
        }

        /**
         * Method to get the previous component for focus
         */
         public Component getComponentBefore(
                                 Container focusCycleRoot,
                                 Component aComponent) {
            if (aComponent.equals(xValue))
              return yValue;
            else
              return xValue;
         }

         public Component getDefaultComponent(
                               Container focusCycleRoot) {
            return xValue;
        }

        public Component getLastComponent(
                               Container focusCycleRoot) {
            return yValue;
        }

        public Component getFirstComponent(
                               Container focusCycleRoot) {
            return xValue;
        }
    }//end PictureExplorerFocusTraversalPolicy inner class

}//end PictureExplorer class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Source code for the program named Java362a. </b>
<table border="1" cols="1" width="477" bgcolor="#EEEEEE">
  <tbody>
    <tr>
      <td>
      <pre>/*Program Java362a
Copyright R.G.Baldwin 2009

The purpose of this program is to support an explanation 
of the PictureExplorer class.

A Picture object having dimensions of 450x345 pixels is 
created. The the show method and the explore method are 
called on the object to produce two different screen 
displays of the picture.

The explore method simply creates a new object of the
PictureExplorer class.

Tested using Windows Vista Premium Home edition and
Ericso's multimedia library.
*********************************************************/

public class Main{
  public static void main(String[] args){
    //Construct a new 460x345 Picture object.
    Picture pix1 = new Picture(&quot;ScaledBeach460x345.jpg&quot;);
    pix1.show();//display the picture in the show format
    //Display the picture again in the explore format.
    pix1.explore();
  }//end main method
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Source code for the ImageDisplay class.
</b>
<table border="1" cols="1" width="477" bgcolor="#EEEEEE">
  <tbody>
    <tr>
      <td>
      <pre>import javax.swing.*;
import java.awt.*;
import java.awt.image.*;

/**
 * Class to display an image and the current location with
 * a + sign
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class ImageDisplay extends JPanel
                          implements Scrollable{

  //////////// fields (attributes ////////////////////////
  private Image image;       //the image to draw
  private Dimension prefSize;//preferred size of  display
  private int currentX = 0;  //the current x index
  private int currentY = 0;  //the current y index

  //////////// constructors //////////////////////////////

  /**
   * Constructor that takes the image to display
   * @param theImage the image to display
   */
  public ImageDisplay(Image theImage){
    image = theImage;
    prefSize = new Dimension(
              image.getWidth(this),image.getHeight(this));
    setPreferredSize(prefSize);
    revalidate();
  }

  /**
   * Constructor that takes the image and current x and y
   * @param theImage the image to display
   * @param x the current x value to use
   * @param y the current y value to use
   */
  public ImageDisplay(Image theImage, int x, int y)
  {
    this(theImage);
    currentX = x;
    currentY = y;
  }

  ///////////////// methods //////////////////////////////

  /**
   * Method to get the image
   * @return the image
   */
  public Image getImage() { return image; }

  /**
   * Method to get the current x
   * @return the current x value
   */
  public int getCurrentX() { return currentX; }

  /**
   * Method to get the current y
   * @return the current y value
   */
  public int getCurrentY() { return currentY; }

  /**
   * Method to set the current x
   * @param x the x value to use
   */
  public void setCurrentX(int x)
  {
    currentX = x;
    repaint();
  }

  /**
   * Method to set the current y
   * @param y the y value to use
   */
  public void setCurrentY(int y)
  {
    currentY = y;
    repaint();
  }

  /**
   * Method to set the image
   * @param theImage the new image to use
   */
  public void setImage(Image theImage){
    image = theImage;
    setPreferredSize(new Dimension(
             image.getWidth(this),image.getHeight(this)));
    repaint();
  }

  /**
   * Method to return the preferred size
   * @return the preferred size of this component
   */
  public Dimension getPreferredScrollableViewportSize()
  {
    return prefSize;
  }

  /**
   * Method to return the unit increment for scrolling
   * @param visibleRect the visible rectangle
   * @param orientation vertical or horizontal
   * @param direction neg is up or left and pos is right
   * or down
   * @return the unit increment for arrow clicks
   */
  public int getScrollableUnitIncrement(
                                    Rectangle visibleRect,
                                    int orientation,
                                    int direction)
  { return 1; }

  /**
   * Method to return the block increment for scrolling
   * @param visibleRect the visible rectangle
   * @param orientation vertical or horizontal
   * @param direction neg is up or left and pos is right
   * or down
   * @return the block increment for clicking in scroll
   * area
   */
  public int getScrollableBlockIncrement(
                                    Rectangle visibleRect,
                                    int orientation,
                                    int direction){
    return 10;
  }

  /**
   * Method to check if the viewport width is the source
   * width
   * @return true if viewport and source have same width
   */
  public boolean getScrollableTracksViewportWidth()
  { return false; }

  /**
   * Method to check if the viewport height is the source
   * height
   * @return true if viewport and soure have same height
   */
  public boolean getScrollableTracksViewportHeight()
  { return false; }

  /**
   * Method to handle displaying this object
   * @param g the graphics object for drawing with
   */
  public void paintComponent(Graphics g)
  {
    super.paintComponent(g);
    int num = 3;
    int xStart = currentX - num;
    int xEnd = currentX + num;
    int yStart = currentY - num;
    int yEnd = currentY + num;
    int width = image.getWidth(this);
    int maxX = width - 1;
    int height = image.getHeight(this);
    int maxY = height - 1;

    // draw the image
    g.drawImage(image,0,0,this);

    // check if the current index is in the image
    if (currentX &gt;= 0 && currentX &lt; width &&
        currentY &gt;= 0 && currentY &lt; height)
    {

      // check that the start and end values are visible
      if (xStart &lt; 0)
        xStart = 0;
      if (xEnd &gt; maxX)
        xEnd = maxX;
      if (yStart &lt; 0)
        yStart = 0;
      if (yEnd &gt; maxY)
        yEnd = maxY;

      // draw a small cross at the current x and y in
      // yellow
      g.setColor(Color.yellow);
      g.drawLine(xStart,currentY,xEnd,currentY);
      g.drawLine(currentX,yStart,currentX,yEnd);
      g.setColor(Color.black);

      // outline the cross in black so that it shows up
      // better
      int leftX = currentX - 1;
      int rightX = currentX + 1;
      int upY = currentY - 1;
      int downY = currentY + 1;
      if (xStart &lt;= leftX && upY &gt;= 0)
        g.drawLine(xStart,upY,leftX,upY);
      if (yStart &lt;= upY && leftX &gt;= 0)
        g.drawLine(leftX,yStart,leftX,upY);
      if (yStart &lt;= upY && rightX &lt;= maxX)
        g.drawLine(rightX,yStart,rightX,upY);
      if (upY &gt;= 0 && rightX &lt;= xEnd)
        g.drawLine(rightX,upY,xEnd,upY);
      if (downY &lt; height && rightX &lt;= xEnd)
        g.drawLine(rightX,downY,xEnd,downY);
      if (downY &lt;= yEnd && rightX &lt; width)
        g.drawLine(rightX,downY,rightX,yEnd);
      if (xStart &lt;= leftX && downY &lt; height)
        g.drawLine(xStart,downY,leftX,downY);
      if (leftX &gt;= 0 && downY &lt;= yEnd)
        g.drawLine(leftX,downY,leftX,yEnd);

    }
  }
}</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
