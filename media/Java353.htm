<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">A Slider-Controlled Sharpening Program for Digital Photos</h2>
<i>Learn how to write a Java program to apply a sharpening filter to your 
digital photos.&nbsp; The amount of sharpening is controlled by the user with a 
slider.</i>
<p><b>Published:</b>&nbsp; March 10, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 353</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_so_far">What you have learned from 
		earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia 
		class library</a></li>
		<li><a href="#Software_installation_and_testing">Software 
		installation and testing</a></li>
	</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
		<li><a href="#The_program_named_Sharpen01">The program named Sharpen01</a></li>
		<li><a href="#The_program_named_EdgeDetect03">The program named 
		EdgeDetect03</a></li>
	</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see
<a href="#Resources">Resources</a>)</i> designed to teach you how 
to write Java programs to do things like:</p>
<ul>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_so_far">What you have learned from earlier 
lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> 
in this series, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>Many aspects of image processing, including color distance, projecting 
	3D coordinates onto a 2D display plane, and edge detection.</li>
	<li>How to write an animated flocking program.</li>
	<li>How to blur or soften your digital photos.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p>You will learn how to write a Java program to apply a sharpening filter to 
your digital photos where the amount of sharpening is controlled by the user 
with a slider.</p>
<p>In addition, you will see what happens when sharpening is overdone, causing 
the program to degenerate to an edge-detection program.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Sample output from the program names 
	Sharpen01. </li>
	<li><a href="#Figure_2">Figure 2</a>. From maximum sharpening to maximum 
	softening.</li>
	<li><a href="#Figure_3">Figure 3</a>. Incremental changes in sharpening.</li>
	<li><a href="#Figure_4">Figure 4</a>. EdgeDetect03 program output for six 
	sample slider values.</li>
	<li><a href="#Figure_5">Figure 5</a>. Changes in program code</li>
	<li><a href="#Figure_6">Figure 6</a>. The king with edge detection.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the method named 
	processThePicture. </li>
	<li><a href="#Listing_2">Listing 2</a>. Compute weighting factors for two 
	different cases.</li>
	<li><a href="#Listing_3">Listing 3</a>. Compute weighting factors for the 
	sharpening filter. </li>
	<li><a href="#Listing_4">Listing 4</a>. Apply the filter. </li>
	<li><a href="#Listing_5">Listing 5</a>. Remainder of the code for the 
	program named Sharpen01. </li>
	<li><a href="#Listing_6">Listing 6</a>. Source code for the program named 
	Sharpen01. </li>
	<li><a href="#Listing_7">Listing 7</a>. Source code for the program named 
	EdgeDetect03. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see
<a href="#Resources">Resources</a>) </i>by Mark Guzdial and 
Barbara Ericson at Georgia Institute of Technology.&nbsp; In doing this, I will also 
present some interesting sample programs that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see 
<a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#FF0000"><b>Two programs</b></font></p>
<p>I will present and explain two different programs in this lesson.&nbsp; In the 
first program named <b>Sharpening01</b>, I will show you how to write a program in which the user controls 
the amount of sharpening that is applied to a digital image using a slider.&nbsp; The 
results are immediately visible in a display of the image to which the 
sharpening is being applied as shown in Figure 1.</p>
<p>
 <b><a name="Figure_1">Figure 1</a>. Sample output from the program names 
	Sharpen01. </b>
<table bgcolor="#EFE9B8"  border="1" cols="1">
<tr><td>
	<p align="center">
	<img border="0" src="java353a.jpg" width="220" height="280"></td></tr>
<tr><td><img border="0" src="java353b.jpg" width="239" height="126"></td></tr>
</table></p>

<p>For convenience purposes, this program can also be used to apply a softening 
filter to the image as an alternative to the sharpening filter.</p>
<p><font color="#FF0000"><b>From maximum sharpening to maximum softening</b></font></p>
<p>Figure 2 shows a series of output displays for slider values of -100, -20, 
-1, +1, +20, and +100 going from left to right, top to bottom.</p>

<p><b><a name="Figure_2">Figure 2</a>. From maximum sharpening to maximum softening.</b>
<table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td><img border="0" src="java353c.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353d.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java353e.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353f.jpg" width="220" height="280"></td>
	</tr>

		<tr>
		<td><img border="0" src="java353g.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353h.jpg" width="220" height="280"></td>
	</tr>
</table>
</p>


<p>The picture in the upper-left corner shows maximum sharpening and the picture 
in the lower-right corner shows maximum softening.&nbsp; The two images in the 
middle should be identical with no sharpening or softening.</p>
<p><font color="#FF0000"><b>Incremental changes in sharpening</b></font></p>
<p>When applying sharpening to your digital photos, you will probably be working in 
the area closer to zero on the slider.&nbsp; Figure 3 shows a series of 
output displays for slider values of -1, -2, -3, -4, -5, and -6 going from 
left to right, top to bottom.</p>

<p><b><a name="Figure_3">Figure 3</a>. Incremental changes in sharpening.</b>
<table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td><img border="0" src="java353e.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353k.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java353m.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353n.jpg" width="220" height="280"></td>
	</tr>
		<tr>
		<td><img border="0" src="java353o.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353p.jpg" width="220" height="280"></td>
	</tr>
</table>
</p>


<p><font color="#FF0000"><b>No sharpening a the top left</b></font></p>
<p>No sharpening was applied to the image in upper-left corner.&nbsp; The 
sharpening was increased in slider-unit steps going from there to the 
bottom-right corner in left-to-right order.</p>
<p><font color="#FF0000"><b>Adjust the granularity</b></font></p>
<p>If those unit steps in 
sharpening are too <a name="granular">granular</a>, or not granular enough for your needs, there is a 
variable named <a href="#sensitivity_">sensitivity</a> in the code that you can modify 
to decrease or increase the granularity.&nbsp; I will point it out later when 
explaining the code.</p>
<p><font color="#FF0000"><b>When sharpening is overdone...</b></font></p>
<p dir="ltr">In the second program, I will show you one of the things that can 
happen if you get it 
wrong when writing a sharpening program.&nbsp; The result in this case is that the program 
degenerates into an edge-detection program.&nbsp; Once again, the results are 
immediately visible in a display of the image to which sharpening is being 
applied.</p>
<p dir="ltr">Figure 4 shows the output from the 
program named <b>EdgeDetect03</b> for slider values of -100, -20, -1, +1, +20, 
and +100 going from left to right, top to bottom.</p>
<p dir="ltr"><font color="#FF0000"><b>EdgeDetect03 program output for six sample 
slider values</b></font></p>


<p>Figure 4 shows a series of output displays for slider values of -100, -20, 
-1, +1, +20, and +100 going from left to right, top to bottom.&nbsp; These are 
the same slider values that were used for the other program in Figure 2.</p>

<p><b><a name="Figure_4">Figure 4</a>. EdgeDetect03 program output for six 
sample slider values.</b>
<table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td><img border="0" src="java353q.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353r.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java353s.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353t.jpg" width="220" height="280"></td>
	</tr>
		<tr>
		<td><img border="0" src="java353u.jpg" width="220" height="280"></td>
		<td><img border="0" src="java353v.jpg" width="220" height="280"></td>
	</tr>
</table>
</p>


<p><font color="#FF0000"><b>Maximum sharpening at the upper left corner</b></font></p>
<p>As before, the picture in the upper-left corner shows maximum sharpening.&nbsp; 
However, unlike the previous program, this program does not soften the image when the slider 
moves to the 
right of zero.&nbsp; Instead, this program applies the same algorithm for slider 
values on both sides of zero.&nbsp; However, when the slider is positioned to the right of 
+1, the color is inverted before storing it in the output display image.&nbsp; 
Thus, the bottom-right image is an inverted version of the top-left image.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Sharpen01">The program named Sharpen01</a></h3>
In an earlier lesson titled <i>A Slider-Controlled Softening Program for Digital 
Photos (see <a href="#Resources">Resources</a>)</i>, I showed you how to write a 
program that will apply a softening filter to your digital photos.&nbsp;
<p>Designing an effective <i>softening</i> filter is a cakewalk compared to designing an 
effective <i>sharpening</i> filter.&nbsp; I discussed the issues involved with sharpening filters 
in some detail in an earlier lesson titled <i>Processing Image Pixels, Applying 
Image Convolution in Java, Part 1, (see <a href="#Resources">Resources</a>)</i>, so I won't repeat 
that discussion here.</p>
<p><font color="#FF0000"><b>Started with the template program</b></font></p>
<p>This program was created using the program named <b>
SingleSliderTemplate01</b> as the starting point.&nbsp; I explained that 
template in the earlier lesson titled <i>A Slider-Controlled Softening Program for Digital 
Photos (see <a href="#Resources">Resources</a>).</i></p>
<p><font color="#FF0000"><b>Purpose of the program</b></font></p>
<p>The purpose of this program is to teach you how to write a slider-controlled 
program to apply a sharpening filter to your digital photos.&nbsp; The amount of 
sharpening is controlled by the user with a slider.</p>
<p><font color="#FF0000"><b>A dual-purpose program</b></font></p>
<p>In addition to applying a sharpening filter, the program is also designed to 
allow the user to apply a softening filter, <i>(as an alternative to the sharpening 
filter)</i>, using an algorithm that was explained in the earlier program.&nbsp; 
In other words, this program can be used to either sharpen or soften a digital 
photo.&nbsp; The program requires access to Ericson's multimedia library.</p>
<p>This program was designed to emphasize an understanding of the 
image-sharpening process and was not designed for speed.</p>
<p><font color="#FF0000"><b>Two parts to the screen output</b></font></p>
<p>The screen output produced by the program consists of two parts as shown in 
Figure 1:</p>
<ul>
	<li>A display of the picture being processed.</li>
	<li>A GUI that is used to control the process.</li>
</ul>
<p><font color="#FF0000"><b>Configuration of the slider</b></font></p>
<p>As you can see in Figure 1, the slider ranges from -100 to +100.&nbsp; The 
initial position of the slider when the program starts running is 0.&nbsp; The 
program applies a sharpening filter when the slider is to the left of -1, and 
applies a softening filter when the slider is to the right of +1.&nbsp; No 
sharpening or softening occurs when the slider is between -1 and +1 inclusive.</p>
<p><font color="#FF0000"><b>The algorithms</b></font></p>
<p>The sharpening or softening algorithm is applied separately to the red, 
green, and blue color values of all the pixels.&nbsp; I will provide a 
detailed explanation of the <i>sharpening</i> algorithm later.&nbsp; You can read about 
the <i>softening</i> algorithm in the earlier lesson titled <i>A Slider-Controlled 
Softening Program for Digital Photos (see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Writing backup files</b></font></p>
<p>Positioning the slider at some point along its range and clicking the <b>
Write</b> button in Figure 1 causes a bmp-formatted backup file to be written containing the 
current state of the display.&nbsp; See the explanation of the program named <b>
SingleSliderTemplate01</b> in the earlier lesson for information regarding the 
number of sequential backup files that are saved and the names of those files.</p>
<p><font color="#FF0000"><b>Termination of the program</b></font></p>
<p>Clicking the large X in the upper-right corner of the display does not 
terminate the program.&nbsp; This simply hides the display and is of no 
practical use.&nbsp; The program is terminated by clicking the large X in the 
upper-right corner of the GUI.</p>
<p>Before terminating, the program writes an output file containing the final 
state of the display in the same format as the input file.&nbsp; The name of the 
output file is the same as the name of the input file except that the word FINAL 
is inserted immediately ahead of the extension.</p>
<p>This program does not modify the contents of the input file.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>As usual, I will explain this program in fragments.&nbsp; A complete 
listing of the program is provided in Listing 6 near the end of the lesson.</p>
<p>Because this program is based on the template from the program named <b>
SingleSliderTemplate01</b>, and because you <i>(hopefully)</i> learned all about 
that template in the earlier lesson titled A<i> Slider-Controlled Softening Program for Digital Photos (see <a href="#Resources">Resources</a>)</i>, 
I will only need to explain the method from Listing 6 named <b>
processThePicture</b>.</p>
<p><font color="#FF0000"><b>The method named processThePicture</b></font></p>
<p>This version of the method named <b>processThePicture</b> applies both a 
<i>sharpening</i> algorithm and a <i>softening</i> algorithm to an image depending on whether 
the user selects sharpening or softening.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Convolution on images</b><br />
  You can learn more about image convolution in the lesson titled <i>Processing 
	Image Pixels, Performing Convolution on Images</i>
<font size="3" face="arial">
	and the lessons following that one
</font>
	in
<font size="3" face="arial">
	<a href="#Resources">Resources</a>.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Convolution</b></font></p>
<p>In pure technical terms, this method convolves the pixels in the image with 
two different nine-point, two-dimensional convolution filters <i>(depending on 
the selection of smoothing versus sharpening)</i> having very specific 
characteristics.&nbsp; The convolution filters are applied separately to the 
red, green, and blue color values of the pixels.</p>
<p><font color="#FF0000"><b>More familiar terminology</b></font></p>
<p>Using terminology that may be more familiar to you as a programmer, each color value for each 
pixel is replaced by a weighted sum of the color value for that pixel <i>
(referred to as the center pixel)</i> and the color values for its eight closest 
neighbors <i>(referred to as the neighbors)</i>.</p>
<p><font color="#FF0000"><b>Characteristics of the algorithm</b></font></p>
<p>Some of the characteristics of the algorithm are:</p>
<ul>
	<li>The center pixel and its eight neighbors constitute a 3x3 square of 
	pixels.</li>
	<li>Equal weights are applied to each of the eight neighbors.</li>
	<li>The sum of the nine weights applied to the center pixel and its eight 
	neighbors is 1.0.</li>
</ul>
<p><font color="#FF0000"><b>Weighting factors are based on the slider value</b></font></p>
<p>The current value of the slider is used with a logarithmic algorithm to 
compute the weights that are applied to the pixel and its eight neighbors.&nbsp; 
However, different algorithms are used to compute the weights for <i>sharpening</i> and 
the weights for <i>softening</i>.</p>
<p>The slider is configured to range from -100 to +100 as shown in Figure 1, and the initial slider 
position is 0.&nbsp; <i>(This requires a minor change to the template program, 
which you can view in Listing 6.)</i></p>
<p><font color="#FF0000"><b>No sharpening or softening in the middle</b></font></p>
<p>When the slider position is <span lang="en-us"></span>between -1 and +1 inclusive, a weight of 1.0 
is applied to the center pixel and weights of 0.0 are applied to the neighboring 
pixels.&nbsp; No sharpening or softening occurs for this case.</p>
<p><font color="#FF0000"><b>Softening to the right</b></font></p>
<p>The softening algorithm is applied when the slider position is to the right of +1.&nbsp; The 
amount of softening increases as the slider is moved further to the right.&nbsp; 
When the slider is at +100, a weight of 0 is applied to the center pixel and 
weights of 0.125 are applied to each of the neighbors.&nbsp; This results in maximum 
softening.</p>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>Negative weighting factors</b><br>
				Note that negative weights may be applied in this case.</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<p><font color="#FF0000"><b>Sharpening to the left</b></font></p>
<p>The sharpening algorithm is applied when the slider position is to the left of -1.&nbsp; The 
amount of sharpening increases as the slider is moved further to the left.&nbsp; 
When the slider is positioned at -100, a weight of 5 is applied to the center 
pixel and weights of -0.5 are applied to the neighbors.&nbsp; This results in 
maximum sharpening.</p>
<p><font color="#FF0000"><b>Brief operational description</b></font></p>
<p>A fresh display picture, based on the specified input file, is created and 
the method named <b>processThePicture</b> is called each time the user moves the 
slider to a new position.&nbsp; <i>(Code associated with the slider component 
prevents the method from being called while the slider is in motion.)</i></p>
<p>Code in the method named <b>processThePicture</b> modifies the display 
picture and then repaints it on the screen.&nbsp; At that point, the program 
pauses, doing nothing until the user either moves the slider to another new 
position, clicks the <b>Write</b> button shown in Figure 1, or clicks the large 
X in the upper-right corner of the GUI in Figure 1.</p>
<p>If the user clicks the <b>Write</b> button, the program writes the current 
state of the display picture into an output backup file and pauses again.</p>
<p>If the user moves the slider to a different position, the method named <b>processThePicture</b> 
is called and the overall process repeats.</p>
<p>If the user clicks the large X in the upper right corner of the GUI in Figure 
1, the final output file is written and the program terminates.</p>
<p><font color="#FF0000">
<b>Beginning of the method named processThePicture</b></font></p>
<p>The method named <b>processThePicture</b> begins in Listing 
1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the method named 
processThePicture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void processThePicture(){
    //Compute the weights that will be applied to the
    // center pixel and its eight closest neighbors.
    double centerWeight = 0.0;
    double neighborWeight = 0.0;

    //Get the current value of the slider. Note that the
    // getValue method returns type int. It is being cast
    // to double to make it compatible with future
    // computations.
    double value = (double)(slider.getValue());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>No explanation should be required for Listing 1 beyond the embedded comments.</p>
<p><font color="#FF0000"><b>The filter for a flat color surface</b></font></p>
<p>Both filters are designed so that there is no change in the color of the 
center pixel when there is no change in the color of the input image in a 3x3 
pixel area.&nbsp; In other words, working with the red, green, and blue color 
values independently, if the color value is constant across that nine-pixel 
square area, the corresponding output color value is the same as the color value across 
the area.</p>
<p>Changes in the output color values occur when there are changes in the 
color values across the nine-pixel square area.&nbsp; Depending on the weighting 
factors used, these changes can sharpen the image, soften the image, or do lots 
of strange and interesting things to the image.&nbsp; <i>(See the earlier 
lessons on processing image pixels in <a href="#Resources">Resources</a>.)</i></p>
<p><font color="#FF0000">
<b>Compute weighting factors for two different cases</b></font></p>
<p>Listing 2 computes the weighting factors for two different cases based on the 
value of the slider.&nbsp; The listing begins by computing the weighting factors 
for a softening filter when the slider is to the right of +1.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Compute weighting factors for two 
different cases.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    if(value &gt; 1.0){
      //Compute weights for a softening filter when the
      // slider is to the right of +1.
      centerWeight = 1.0 - Math.log10(value)/2;
      neighborWeight = (1.0 - centerWeight)/8.0;
    }else if((value &gt;= -1) && (value &lt;= 1)){
      //Make the filter a do-nothing filter for the range
      // -1 to 1. This filter will not cause sharpening or
      // blurring to occur.
      centerWeight = 1.0;
      neighborWeight = 0.0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The algorithm that is applied for that case is the same algorithm that you 
learned about in the earlier lesson titled <i>A Slider-Controlled Softening 
Program for Digital Photos (see <a href="#Resources">Resources</a>)</i>.&nbsp; 
Therefore, no further explanation of the code for the first case in Listing 2 
should be required.</p>
<p><font color="#FF0000"><b>Slider between -1 and +1 inclusive</b></font></p>
<p>The second case in Listing 2 is the case where the slider is between -1 and 
+1 inclusive.&nbsp; For this case, the weight that is applied to the center 
pixel in the 3x3 square of pixels is 1.0 and the weights applied to the 
remaining eight pixels is 0.0.&nbsp; Therefore, those eight pixels have no 
effect on the output and no sharpening or softening occurs for this case.</p>
<p><font color="#FF0000"><b>The sharpening filter</b></font></p>
<p>The code in Listing 3 computes the weighting factors for the sharpening 
filter.&nbsp; This occurs when the slider is to the left of -1.</p>
<p>To begin with, because the slider is to the left of -1, the value of the 
slider is negative.&nbsp; A positive value is needed for computation of the 
weighting factors, so I needed to change the algebraic sign of the value of the slider.&nbsp; 
I could have simply incorporated this into the computation that follows, but I 
elected to change the sign explicitly for clarity.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Compute weighting factors for the 
sharpening filter. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    }else{
      value = -value;

      double sensitivity = 2.0;
      centerWeight =
                    (1.0 + Math.log10(value)*sensitivity);
      neighborWeight = (1-centerWeight)/8.0;
    }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><b><font color="#FF0000">The sensitivity factor</font></b></p>
<p>As I mentioned <a href="#granular">earlier</a>, I also decided to include a
<b><a name="sensitivity_">sensitivity</a></b> factor for you to 
experiment with by changing the value of the factor and recompiling the program.</p>
<p>If you increase the value of the variable named <b>sensitivity</b>, you will 
increase the sensitivity of the sharpening process.&nbsp; In other words, you 
will cause the amount of sharpening to increase for the same amount of travel of 
the slider toward the left end of the slider.&nbsp; Similarly, decreasing the 
value will reduce the sensitivity of the sharpening process.</p>
<p>Increasing that value causes 
the value of the <b>centerWeight</b> factor <i>(which is applied to the center 
pixel in the 3x3 square of pixels)</i>, which will, in turn, drive the factor 
that is applied to the other eight pixels in the 3x3 square in the negative 
direction.</p>
<p><font color="#FF0000"><b>Can produce negative weighting factors</b></font></p>
<p>If you examine the code in Listing 3, you should conclude that the weighting 
factors that are applied to the eight pixels around the edge of the 3x3 square 
can and often will be negative.</p>
<p>Image convolution with all positive 
weighting factors is relatively predictable and easy to understand because it is 
simply a weighted averaging process.&nbsp; However, as I 
explained in the earlier lesson titled <i>Processing Image Pixels, Applying 
Image Convolution in Java, Part 1, (see <a href="#Resources">Resources</a>)</i>, 
strange things can occur when negative weighting factors are involved.&nbsp; One 
of the most obvious is that negative output values can result, which is not a legal 
color value for a pixel.</p>
<p><font color="#FF0000"><b>Approximates the first derivative</b></font></p>
<p>For those who remember their differential calculus, to a first degree of approximation, the application of the convolution filter 
for which the weighting factors were computed in Listing 3 approximates taking 
the first derivative of the color surface.</p>
<p><font color="#FF0000"><b>Proportional to the slope of the surface</b></font></p>
<p>As a result, the output is 
somewhat proportional to the slope of the surface at any given point on that 
surface.&nbsp; If the surface is flat <i>(the slope is zero)</i>, the output is essentially the same as the 
input.</p>
<p><font color="#FF0000"><b>If the surface is not flat...</b></font></p>
<p>However, if the topography of the surface is changing rapidly, as 
is the case in those areas where the color of the image is changing, the 
magnitude of the output 
is greater and can be negative.</p>
<p><font color="#FF0000"><b>Some difficult concepts are involved</b></font></p>
<p>This concept alone can be difficult to wrap your mind around.&nbsp; 
Add to that the fact that there are three colors involved and only those output color values between 0 and 
255 are allowed and things can become even more difficult for many of us to get 
a good grasp on.</p>
<p><font color="#FF0000">
<b>Apply the filter</b></font></p>
<p>From here on, with one major exception, the code is pretty much the same as 
the code that you learned about in the earlier lesson on softening filters.&nbsp; 
That code continues in Listing 4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Apply the filter. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Declare some working variables.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[8];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);

    //Process each pixel.
    for(int col = 1;col &lt; width -1;col++){
      for(int row = 1;row &lt; height - 1;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the eight surrounding pixels.
        pixels[0] = temp.getPixel(col-1,row-1);
        pixels[1] = temp.getPixel(col,row-1);
        pixels[2] = temp.getPixel(col+1,row-1);

        pixels[3] = temp.getPixel(col-1,row);
        pixels[4] = temp.getPixel(col+1 ,row);

        pixels[5] = temp.getPixel(col-1,row+1);
        pixels[6] = temp.getPixel(col,row+1);
        pixels[7] = temp.getPixel(col+1,row+1);

        //Compute the weighted sum of the red values.
        red = 0;
        //First compute the sum of the color values for
        // the eight neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        //Make certain that the color value is within its
        // allowable limits of 0 to 255 inclusive.
<b>        if(red &gt; 255) red = 255;
        if(red &lt; 0) red = 0;</b>
        pixel.setRed(red);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The exception</b></font></p>
<p>The major exception that I mentioned earlier is shown in the first two of the 
last three statements in Listing 4.&nbsp; Because of the strong possibility of this 
algorithm producing negative output values or producing values greater than 255, 
I inserted the two statement in Listing 4 that clip the output color value to 
either 0 or 255 when that occurs.</p>
<p><font color="#FF0000">
<b>Remainder of the code for the program named Sharpen01</b></font></p>
<p>When the code in Listing 4 finishes executing, the new red color value for a single pixel has been computed and set into the output display image.</p>
<p>Listing 5 uses the same approach to compute the output values for the green 
and blue colors, and iterates within the pair of nested <b>for</b> loops until 
all of the pixels in the picture have been processed.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Remainder of the code for the program 
named Sharpen01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        //Compute the weighted sum of the green values.
        // This is essentially the same algorithm as for
        // the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        if(green &gt; 255) green = 255;
        if(green &lt; 0) green = 0;
        pixel.setGreen(green);

        //Compute the weighted sum of the blue values.
        // This is essentially the same algorithm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        if(blue &gt; 255) blue = 255;
        if(blue &lt; 0) blue = 0;
        pixel.setBlue(blue);

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class Sharpen01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once all the pixels have been processed, Listing 5 repaints the display and 
the method named <b>processThePicture</b> terminates.</p>
<p><font color="#FF0000"><b>Wait for something to happen</b></font></p>
<p>As explained earlier, at that point, the program pauses, doing nothing until 
the user either moves the slider to a new position, clicks the <b>Write</b> 
button shown in Figure 1, or clicks the large X in the upper-right corner of the 
GUI in Figure 1.</p>
<p>If the user clicks the <b>Write</b> button, the program writes the current 
state of the display picture into an output backup file and pauses again.</p>
<p>If the user moves the slider to a different position, the method named <b>processThePicture</b> 
is called and the overall process repeats.</p>
<p>If the user clicks the large X in the upper right corner of the GUI in Figure 
1, the program writes the final output file and terminates.</p>
<h3><a name="The_program_named_EdgeDetect03">The program named EdgeDetect03</a></h3>
<p>A complete listing of this program is provided in Listing 7 near the end of 
the lesson.</p>
<p>If you compare Figure 4 with Figure 2, you will see that the behavior of this 
program is radically different from the behavior of the earlier program named <b>
Sharpen01</b>.</p>
<p><font color="#FF0000"><b>One statement makes all the difference</b></font></p>
<p>The critical difference in the behavior of the 
two programs is the result of the modification of a single statement in the 
computation of the weighting factor that is applied to the eight outer pixels in 
the 3x3 square of pixels.</p>
<p><font color="#FF0000"><b>Several changes made, only one was critical</b></font></p>
<p>The <i>softening</i> code on the right side of the slider was 
replaced by <i>sharpening</i> code with an inverted color output in this 
program.&nbsp; This resulted in some rearrangement of the overall structure of the code.&nbsp; 
However, neither of these changes was responsible for the difference that you 
see when you compare Figure 2 and Figure 4.</p>
<p><font color="#FF0000"><b>The critical difference</b></font></p>
<p>The critical difference is the difference in the two statements shown in Figure 5.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Changes in program code. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
      <pre>neighborWeight = (1-centerWeight)/8.0;
      
neighborWeight = -centerWeight/8.0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Computing neighborWeight in Sharpen01</b></font></p>
<p>The first statement in Figure 5 was extracted from Listing 3, which shows the 
computation of the weight that is applied to the eight outer pixels in the 3x3 
square of pixels in the earlier program named <b>Sharpen01</b>.</p>
<p><font color="#FF0000"><b>Computing neighborWeight in EdgeDetect03</b></font></p>
<p>The second statement in Figure 5 shows the computation of the corresponding 
weighting factor that was extracted from Listing 7, which is the source code 
for the program that produced the output shown in Figure 4.</p>
<p><font color="#FF0000"><b>The weighting factor was used the same way in both 
programs</b></font></p>
<p>The most obvious difference between the two values of <b>neighborWeight</b> 
is as follows.</p>
<p><font color="#FF0000"><b>For the program named Sharpen01</b></font></p>
<p>For the first case shown in Figure 5, the sum of the 
weights applied to the nine pixels in the 3x3 square is equal to 1.0.&nbsp; 
</p>
<p>Therefore, when the weights are applied to an area of the image for which the 
color is relatively constant across the 3x3 square <i>(such as the area 
immediately to the left of the butterfly's left wing in the upper-left image in 
Figure 3),</i> the output color 
is essentially the same as the color at the center of the square.</p>
<p>When the square moves into an area where the color is changing <i>(such as the 
left edge of the butterfly's left wing in the same image)</i>, the output color 
differs from the color at the center of the square</p>
<p>For example, if you examine 
the left edge of the left wing in the upper-left image in Figure 2, you will see 
that the wing is bordered by a narrow band of white <i>(or nearly)</i> white pixels.&nbsp; 
That band of white pixels doesn't exist in the <span lang="en-us"></span>original image shown at the 
left center of Figure 2.</p>
<p><font color="#FF0000"><b>For the program named EdgeDetect03</b></font></p>
<p>For the second case shown in Figure 5, the sum of the weights applied to the 
nine pixels in the 3x3 square is equal to 0.0 instead of 1.0.</p>
<p>Therefore, when the weights 
are applied to an area of the image for which the color is relatively constant 
across the 3x3 square <i>(again, such as the area immediately to the left of the 
butterfly's left wing in the upper-left image in Figure 3),</i> the output color 
is not the same color as the color at the center of the square.&nbsp; Instead, 
it is black or nearly black as shown in Figure 4.</p>
<p>When the square moves into an area where the color is changing <i>(such as 
the left edge of the butterfly's left wing in the same image)</i> the output 
color changes to something other than black.&nbsp; </p>
<p>As you can see in the upper-left image in Figure 4, the output color at 
that point changed to white <i>(or nearly white)</i> similar to the case for the 
upper-left image in Figure 2.</p>
<p><font color="#FF0000"><b>Why white?</b></font></p>
<p>The resulting white 
color in both cases is probably the result of the output color exceeding a value of 255 and 
being clipped to 255.&nbsp; If you use the second statement in Figure 5 with a 
much less sensitive sharpening filter, you are likely to see colors other than 
black and white as the filter moves across the color changes in the input image.</p>
<p><font color="#FF0000"><b>Why did I show you this?</b></font></p>
<p>I showed you this program mainly to illustrate the sorts of strange results 
that can occur when you overdo the sharpening process.&nbsp; However, this 
program isn't completely without some merit.</p>
<p>Figure 6 shows a picture of the king during his Army days, with the 
picture having been subjected to edge detection.</p>



<p><b><a name="Figure_6">Figure 6</a>. The king with edge detection.</b>
<table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td><img border="0" src="java353w.jpg" width="126" height="156"></td>
		<td><img border="0" src="java353x.jpg" width="126" height="156"></td>
		<td><img border="0" src="java353y.jpg" width="126" height="156"></td>
	</tr>
</table>
</p>


<p>If you were going to make a pencil drawing of the king, this might be a good 
way to get started.&nbsp; However, I doubt that you will create and save 
very many edge-detected pictures of your friends in your electronic scrapbook.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 6 and Listing 7, compile the 
code, and execute it.&nbsp; Experiment with the code, making changes, and observing 
the results of your changes.&nbsp; Make certain that you can explain why your changes 
behave as they do.</p>
<p>See if you can find ways to modify the algorithms to improve the speed 
without changing the behavior.&nbsp; For example, consider using the techniques 
described in the lesson titled <i>Using the Java 2D ConvolveOp Filter Class to 
Process Images (see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I explained two different programs in this lesson.&nbsp; In the first program, I 
showed you how to write a program that can be used to either sharpen or soften a 
picture.&nbsp; The amount of sharpening or softening is controlled by the user 
with a slider.</p>
<p>The second program is similar to the first except that I showed you how 
sharpening can go terribly wrong if you don't program it properly.&nbsp; By 
making a seemingly minor modification to one statement in this program relative to the other 
program, 
I caused the sharpening algorithm to degenerate into an edge-detection 
algorithm.</p>
<p>On the other hand, if you are interested in edge detection, this could be a 
useful program.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn more about the <b>Picture</b> an <b>
SimplePicture</b> classes along with the DigitalPicture interface.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
6 and Listing 7 below.
<p>
<b><a name="Listing_6">Listing 6</a>. Source code for the program named Sharpen01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sharpen01 Copyright 2009 R.G.Baldwin

This program was created using the program named
SingleSliderTemplate01 as the starting point.

The purpose of this program is to teach you how to write a
slider-driven program to apply a sharpening filter to your
digital photos. The degree of sharpening is controlled by
the user with a slider.

In addition to applying a sharpening filter, the program
is also designed to apply a blurring filter using an
algorithm that was demonstrated in an earlier program. In
other words, this program can be used to either sharpen
or blur a digital photo.

The  program requires access to Ericson's multimedia
library.

The speed and smoothness of programs that you write using
the template program will depend on a combination of your
programming skills and the speed of your computer. This
program was designed to emphasize an understanding of the
image sharpening process and was not designed for speed.

The screen output produced by the program consists of two
parts: a display of the picture being processed and a GUI.

See the comments at the beginning of the program named
SingleSliderTemplate01 for a detailed discussion of the
components in the GUI.

The slider ranges from -100 to +100 with the initial
position of the slider at 0. The program applies a
sharpening filter when the slider is to the left of -1,
and applies a blurring filter when the slider is to the
right of +1.

No sharpening or blurring occurs when the slider is
between -1 and +1 inclusive.

The sharpening or blurring algorithm is applied separately
to the red, green, and blue color values of all the
pixels.

A detailed description of the algorithm is provided in the
comments at the beginning of the method named
processThePicture.

Positioning the slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display. See
the program named SingleSliderTemplate01 for information
regarding the number of sequential backup files that are
saved and the names of those files.

Clicking the large X in the upper-right corner of the
display does not terminate the program.  This simply hides
the display and is of no practical value.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension.

This program does not modify the contents of the original
input file.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class Sharpen01 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =new JLabel(
            "    Sharpen to the left,blur to the right.");
  private JLabel fileNameLabel = new JLabel("File Name:");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
                          new JTextField("Sharpen01.jpg");
  private JSlider slider = new JSlider(-100,100,0);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new Sharpen01();
  }//end main method
  //----------------------------------------------------//

  public Sharpen01(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(20);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(fileNameLabel);
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the slider.
    //Each time the slider fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // processThePicture.
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*This version of the method named processThePicture
  applies both a sharpening algorithm and a blurring
  algorithm to an image. In pure technical terms, this
  method convolves the pixels in the image with a
  nine-point, two-dimensional convolution filter having
  very  specific characteristics. The convolution filter
  is applied separately to the red, green, and blue color
  values of the pixels.

  Using terminology that may be more familiar to you, each
  color value for each pixel is replaced by a weighted
  sum of the color value for that pixel (referred to as
  the center pixel) and the color values for its eight
  closest neighbors (referred to as the neighbors). The
  center pixel and its eight neighbors constitute a 3x3
  square of pixels.

  Equal weights are applied to each of the eight
  neighbors.

  The sum of the weights applied to the center pixel and
  its eight neighbors is 1.0.

  The current value of the slider is used with a
  logarithmic algorithm to compute the weights that are
  applied to the pixel and its eight neighbors. However,
  different algorithms are used to compute the weights for
  sharpening and the weights for blurring.

  The slider is configured to range from -100 to +100 and
  the initial slider position is 0.

  When the slider position is is between -1 and 1
  inclusive, a weight of 1.0 is applied to the center
  pixel and weights of 0.0 are applied to the neighboring
  pixels. No sharpening or blurring occurs for this case.

  When the slider position is to the right of +1, blurring
  occurs. The degree of blurring increases as the slider
  is moved further to the right. When the slider is at
  +100, a weight of 0 is applied to the center pixel and
  weights of 0.125 are applied to the neighbors. This
  results in maximum blurring.

  When the slider position is to the left of -1,
  sharpening occurs. The degree of sharpening increases as
  the slider is moved further to the left. When the slider
  is positioned at -100, a weight of 5 is applied to the
  center pixel and weights of -0.5 are applied to the
  neighbors. This results in maximum sharpening.
  */
  private void processThePicture(){
    //Compute the weights that will be applied to the
    // center pixel and its eight closest neighbors.
    double centerWeight = 0.0;
    double neighborWeight = 0.0;

    //Get the current value of the slider. Note that the
    // getValue method returns type int. It is being cast
    // to double to make it compatible with future
    // computations.
    double value = (double)(slider.getValue());

    //Compute weighting factors based on the value of the
    // slider. Make the response for both filters
    // equal to 1.0 when applied to a region of the
    // image where there is no change in a color value
    // across the 3x3 square of pixels. Colors values in
    // those areas will be reproduced with no change.
    if(value &gt; 1.0){
      //Compute weights for a blurring filter when the
      // slider is to the right of 1.
      centerWeight = 1.0 - Math.log10(value)/2;
      neighborWeight = (1.0 - centerWeight)/8.0;
    }else if((value &gt;= -1) && (value &lt;= 1)){
      //Make the filter a do-nothing filter for the range
      // -1 to 1. This filter will not cause sharpening or
      // blurring to occur.
      centerWeight = 1.0;
      neighborWeight = 0.0;
    }else{
      //Compute weights for a sharpening filter when the
      // slider is to the left of -1.
      //Note that the value of the slider is negative here
      // so the sign of value needs to be changed to
      // positive. I could simply include this in the
      // computation but made it explicit for clarity.
      value = -value;
      //The sensitivity of the sharpening process can be
      // increased by increasing the value of the variable
      // named sensitivity and recompiling the program.
      // This causes the value of centerWeight to increase
      // and drives the value of neighborWeight in the
      // negative direction.
      double sensitivity = 2.0;
      centerWeight =
                    (1.0 + Math.log10(value)*sensitivity);
      neighborWeight = (1-centerWeight)/8.0;
    }//end else

    //Declare some working varibles.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[8];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);

    //Process each pixel.
    for(int col = 1;col &lt; width -1;col++){
      for(int row = 1;row &lt; height - 1;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the eight surrounding pixels.
        pixels[0] = temp.getPixel(col-1,row-1);
        pixels[1] = temp.getPixel(col,row-1);
        pixels[2] = temp.getPixel(col+1,row-1);

        pixels[3] = temp.getPixel(col-1,row);
        pixels[4] = temp.getPixel(col+1 ,row);

        pixels[5] = temp.getPixel(col-1,row+1);
        pixels[6] = temp.getPixel(col,row+1);
        pixels[7] = temp.getPixel(col+1,row+1);

        //Compute the weighted sum of the red values.
        red = 0;
        //First compute the sum of the color values for
        // the eight neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        //Make certain that the color value is within its
        // allowable limits of 0 to 255 inclusive.
        if(red &gt; 255) red = 255;
        if(red &lt; 0) red = 0;
        pixel.setRed(red);

        //Compute the weighted sum of the green values.
        // This is essentially the same algorighm as for
        // the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        if(green &gt; 255) green = 255;
        if(green &lt; 0) green = 0;
        pixel.setGreen(green);

        //Compute the weighted sum of the blue values.
        // This is essentially the same algorighm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        if(blue &gt; 255) blue = 255;
        if(blue &lt; 0) blue = 0;
        pixel.setBlue(blue);

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class Sharpen01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Source code for the program named EdgeDetect03. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File EdgeDetect03 Copyright 2009 R.G.Baldwin

This program was created by starting with the program
named SingleSliderTemplate01.

The purpose of this program is to teach you how to write a
slider-driven program to apply a sharpening filter to your
digital photos. The degree of sharpening is controlled by
the user with a slider.

The sharpening filter is so severe that the program tends
to degenerate to an edge detector program.

The  program requires access to Ericson's multimedia
library.

The speed and smoothness of programs that you write using
the template program will depend on a combination of your
programming skills and the speed of your computer. This
program was designed to emphasize an understanding of the
image sharpening process and was not designed for speed.

The screen output produced by the program consists of two
parts: a display of the picture being processed and a GUI.

See the comments at the beginning of the program named
SingleSliderTemplate01 for a detailed discussion of the
components in the GUI.

The slider ranges from -100 to +100 with the initial
position of the slider at 0. The program applies a
sharpening filter when the slider is to the left of -1 and
also applies the same sharpening filter when the slider is
to the right of +1. However, in the latter case, the color
is inverted before being stored in the output display.

No sharpening occurs when the slider is
between -1 and +1 inclusive.

The sharpening algorithm is applied separately
to the red, green, and blue color values of all the
pixels.

A detailed description of the algorithm is provided in the
comments at the beginning of the method named
processThePicture.

Positioning the slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display. See
the program named SingleSliderTemplate01 for information
regarding the number of sequential backup files that are
saved and the names of those files.

Clicking the large X in the upper-right corner of the
display does not terminate the program.  This simply hides
the display and is of no practical value.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension.

This program does not modify the contents of the original
input file.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class EdgeDetect03 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =new JLabel(
            "    Sharpen to the left,blur to the right.");
  private JLabel fileNameLabel = new JLabel("File Name:");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
                       new JTextField("EdgeDetect03.jpg");
  private JSlider slider = new JSlider(-100,100,0);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new EdgeDetect03();
  }//end main method
  //----------------------------------------------------//

  public EdgeDetect03(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(20);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(fileNameLabel);
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the slider.
    //Each time the slider fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // processThePicture.
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*This version of the method named processThePicture
  applies a severe sharpening algorith to an image. The
  algorithm is so severe that it often behaves as an edge
  detector causing pixels at locations where the color is
  changing to be displayed as black or white. In pure
  technical terms, this method convolves the pixels in the
  image with a nine-point, two-dimensional convolution
  filter having very  specific characteristics. The
  convolution filter is applied separately to the red,
  green, and blue color values of the pixels.

  Using terminology that may be more familiar to you,
  each color value for each pixel is replaced by a
  weighted sum of the color value for that pixel
  (referred to as the center pixel) and the color values
  for its eight closest neighbors (referred to as the
  neighbors). The center pixel and its eight neighbors
  constitute a 3x3 square of pixels.

  Equal weights are applied to each of the eight
  neighbors.

  IMPORTANT: The sum of the weights applied to the center
  pixel and its eight neighbors is 0.0. This causes the
  output color to be black when the filter is passing
  over a flat surface. Application of the filter often
  results in negative color values and color values
  greater than 255. When this happens, the color value is
  set to 0 or 255 as appropriate.

  The current value of the slider is used with a
  logarithmic algorithm to compute the weights that are
  applied to the pixel and its eight neighbors.

  The slider is configured to range from -100 to +100 and
  the initial slider position is 0.

  When the slider position is is between -1 and 1
  inclusive, a weight of 1.0 is applied to the center
  pixel and weights of 0.0 are applied to the neighboring
  pixels. No sharpening occurs for this case.

  When the slider position is to the left of -1,
  sharpening occurs. The degree of sharpening increases as
  the slider is moved further to the left. When the slider
  is positioned at -100, a weight of 5 is applied to the
  center pixel and weights of -0.625 are applied to the
  neighbors. This results in maximum sharpening, which
  often results in white edges on a black background.

  When the slider position is to the right of +1, exactly
  the same sharpening algorithm is applied. However, in
  this case the color is inverted before being stored in
  the output display. This often results in black edges on
  a white background.
  */
  private void processThePicture(){
    //Compute the weights that will be applied to the
    // center pixel and its eight closest neighbors.
    double centerWeight = 0.0;
    double neighborWeight = 0.0;
    boolean blackEdges = false;//Invert picture on true.

    //Get the current value of the slider. Note that the
    // getValue method returns type int. It is being cast
    // to double to make it compatible with future
    // computations.
    double value = (double)(slider.getValue());
    //Compute weighting factors based on the value of the
    // slider. Make the response for the filter
    // equal to 0.0 when applied to a region of the
    // image where there is no change in a color value
    // across the 3x3 square of pixels. Colors in those
    // areas will be converted to black.

    //The sensitivity of the sharpening process can be
    // increased by increasing the value of the variable
    // named sensitivity and recompiling the program.
    // This causes the value of centerWeight to increase
    // and drives the value of neighborWeight in the
    // negative direction.
    double sensitivity = 2.0;

    //Deal first with the area between -1 and +1
    // inclusive on the slider.
    if((value &gt;= -1) && (value &lt;= 1)){
    //Make the filter a do-nothing filter for the range
    // -1 to 1. This filter will not cause sharpening to
    // occur.
    centerWeight = 1.0;
    neighborWeight = 0.0;
    }else{
      //Now deal with the area of the slider to the right
      // of +1 and to the left of -1.
      if(value &gt; 1){
        //Invert the colors of the processed image. This
        // will convert black to white and white to black.
        blackEdges = true;
      }else{
        //Change the sign on value to compensate for the
        // fact that the slider is in  the negative
        // region.
        value = -value;
      }//end else

      //Now compute the weighting factors regardless of
      // which side of 0 the slider is on.
      //IMPORTANT: Note that the sum of the weights is 0
      // instead of 1 as was the case for the earlier
      // sharpening filter in another program. This will
      // cause the output to be 0 when the filter is
      // moving across a flat color surface.
      centerWeight =
                    (1.0 + Math.log10(value)*sensitivity);
      //IMPORTANT: NOTE THAT THE FOLLOWING EXPRESSION IS
      // DIFFERENT FROM THE CORRESPONDING EXPRESSION IN
      // THE PROGRAM NAMED Sharpen01.
      neighborWeight = -centerWeight/8.0;
    }//end else

    //Declare some working varibles.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[8];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);

    //Process each pixel.
    for(int col = 1;col &lt; width -1;col++){
      for(int row = 1;row &lt; height - 1;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the eight surrounding pixels.
        pixels[0] = temp.getPixel(col-1,row-1);
        pixels[1] = temp.getPixel(col,row-1);
        pixels[2] = temp.getPixel(col+1,row-1);

        pixels[3] = temp.getPixel(col-1,row);
        pixels[4] = temp.getPixel(col+1 ,row);

        pixels[5] = temp.getPixel(col-1,row+1);
        pixels[6] = temp.getPixel(col,row+1);
        pixels[7] = temp.getPixel(col+1,row+1);

        //Compute the weighted sum of the red values.
        red = 0;
        //First compute the sum of the color values for
        // the eight neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        //Make certain that the color value is within its
        // allowable limits of 0 to 255 inclusive. If not,
        // set it to the limit.
        if(red &gt; 255) red = 255;
        if(red &lt; 0) red = 0;
        if(blackEdges){
          //Invert the color value for the right side of
          // the slider.
          pixel.setRed(255-red);
        }else{
          pixel.setRed(red);
        }//end else

        //Compute the weighted sum of the green values.
        // This is essentially the same algorighm as for
        // the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        if(green &gt; 255) green = 255;
        if(green &lt; 0) green = 0;

        if(blackEdges){
          pixel.setGreen(255-green);
        }else{
          pixel.setGreen(green);
        }//end else

        //Compute the weighted sum of the blue values.
        // This is essentially the same algorighm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        if(blue &gt; 255) blue = 255;
        if(blue &lt; 0) blue = 0;

        if(blackEdges){
          pixel.setBlue(255-blue);
        }else{
          pixel.setBlue(blue);
        }//end else

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class EdgeDetect03</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
