<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Instance Members, Class Members, Constructors, and Finalizationin Java by Richard G. Baldwin </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Instance Members, Class Members, Constructors, and Finalization<!--endTitle--></H2>
<P>Java Programming, Lecture Notes # 42, Revised 10/03/99. </P>
<P><!-toc file=Java042a.htm words=Preface-><A HREF="#Preface">Preface</A><BR>
<!--endtoc--><!-toc file=Java042b.htm words=Introduction-><A HREF="#Introduction">Introduction</A><BR>
<!--endtoc--><!-toc file=Java042c.htm words=Instance Variables-><A HREF="#InstanceMembers">Instance Variables</A><BR>
<!--endtoc--><!-toc file=Java042d.htm words=Class Variables-><A HREF="#ClassMembers">Class Variables</A><BR>
<!--endtoc--><!-toc file=Java042e.htm words=Instance Methods-><A HREF="#InstanceMethods">Instance Methods</A><BR>
<!--endtoc--><!-toc file=Java042f.htm words=Class Methods-><A HREF="#ClassMethods">Class Methods</A><BR>
<!--endtoc--><!-toc file=Java042g.htm words=Constructors-><A HREF="#Constructors">Constructors</A><BR>
<!--endtoc--><!-toc file=Java042h.htm words=Finalization-><A HREF="#Finalization">Finalization</A><BR>
<!--endtoc--><!-toc file=Java042i.htm words=Review-><A HREF="#Review">Review</A><!--endtoc--> </P>
<P><!-next=Java042a.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of persons already familiar with C++ who are making the transition into Java. </P>
<P><!-prev=Java042.htm-><!-next=Java042b.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Introduction"></A>Introduction</H2>
</FONT><I><P>Instance variables, class variables, instance methods,</I> and <I>class methods</I> were introduced in earlier lessons. This lesson builds on the material provided earlier </P>
<P>This lesson also provides some new insights into <I>constructors</I> which were not provided in previous discussions on the use of <I>constructors</I>. </P>
<P>Finally, this lesson takes another pass at the topic of <I>finalization</I>, the process of doing cleanup before an object is reclaimed by the <I>garbage collector</I>. </P>
<P><!-prev=Java042a.htm-><!-next=Java042c.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="InstanceMembers"></A>Instance Variables</H2>
</FONT><P>In both Java and C++, the declaration of a member variable (data member) inside a class definition <U>without </U>use of the <I>static</I> keyword results in an <I>instance variable </I>in objects of that class. (A declaration which uses the <I>static</I> keyword signifies a <I>class</I> variable.) </P>
<P>The significance of an <I>instance variable</I> is that every object instantiated from that class contains its own copy of all <I>instance variables</I>. If you were to examine the memory allocated for each object of that class, you would find that memory has been set aside for each object to contain its own copy of all instance variables of the class. </P>
<P>In other words, since an object is <I>an instance of a class</I>, and since every object has its own copy of a particular data member of the class, then that data member can be thought of as an <I>instance variable</I>. That is the source of the name. </P>
<P>In Java, you access the instance variables associated with a particular object by joining the name of the object with the name of the variable using a period as shown below (note that some authors refer to the period as the <I>dot operator</I>): </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>myObject.myInstanceVariable</PRE></TT></TD>
</TR>
</TABLE>


<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, you access the instance variables associated with a particular object in either of two ways. One way is to use the name of the object, the dot operator, and the name of the variable just the same as in Java. </P>
<P>The other way is to use the name of a <I>pointer variable</I> which points to the object, the <I>pointer operator</I>, and the name of the variable. Both of these ways are shown below: </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<TT><P>myObject.myInstanceVariable</TT> </P>
<TT><PRE>myPointerVariable -&gt; myInstanceVariable</PRE></TT></TD>
</TR>
</TABLE>

<P><!-prev=Java042b.htm-><!-next=Java042d.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ClassMembers"></A>Class Variables</H2>
</FONT><P>In both Java and C++, the declaration of a data member inside the class <U>using </U>the <B><I>static</I> </B>keyword results in a <I>class variable</I>. </P>
<P>One of the significant things about a <I>class variable</I> is that <U>all instances of the class</U> (all objects instantiated from the class) <U>share the class variables</U>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, it is necessary to "re-declare" all class variables outside the class definition, producing a "pseudo-global" variable; that is, a variable that is global insofar as objects of that class are concerned. Such "re-declaration" is not required in Java.</TD>
</TR>
</TABLE>

<P>If you were to find a way to examine the memory allocated for each object, you would find that every objects shares the same memory for storage of each class variable. Although this author isn't certain exactly how this is implemented in Java, it probably means that the memory allocated for each individual object contains some sort of pointer or reference to the memory location where the actual class variable is stored. </P>
<P>Another significant thing about class variables is that in both Java and C++, you can <U>access class variables</U> using the <U>name of the class</U> and the <U>name of the variable</U>. It is <U>not</U> necessary to instantiate an object of the class to access class variables. </P>
<P>In Java, <U>class variables</U> are accessed using the name of the class and the name of the variable joined by the <I>dot operator</I>. The following familiar code fragment accesses the class variable named <B>out</B> of the class named <B>System</B>. In the process, it accesses the <B>println</B> method of the class variable to display a string on the standard output device. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>System.out.println("Display my string");</PRE></TT></TD>
</TR>
</TABLE>


<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, class variables are accessed using the <I>scope resolution operator</I> along with the name of the class and the name of the variable as shown below: </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<TT><PRE>MyClass::myClassVariable</PRE></TT></TD>
</TR>
</TABLE>

<P>Also in both Java and C++, you can access class variables through an <U>instance of the class</U> (object) using the <U>same syntax</U> that you would use to access an instance variable. </P>
<P>Remember that since all objects of the class <U>share the class variable</U>, if any object modifies it, it is modified for all objects of the class. This can be used as a form of inter-object communication. </P>
<P>In Java, <I>class variables</I> are often used with the <B>final</B> keyword to create variables that <U>act like constants</U>. This is a memory efficient approach because you don't need multiple copies of constants. </P>
<P><!-prev=Java042c.htm-><!-next=Java042e.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="InstanceMethods"></A>Instance Methods</H2>
</FONT><P>When you include a member function in a C++ class definition, or include a method in a Java class definition <U>without</U> use of <B><I>static</I> </B>keyword, this will result in objects of that class containing an <I>instance method</I>. </P>
<P>Although each object of the class <U>does not contain its own copy</U> of the <I>instance method </I>(multiple copies of the method <U>do not</U> exist in memory), the <U>end result is the same</U> as if each object contained its own copy. (If memory were not a concern, each instance might be given its own copy of the method for improved speed.) </P>
<P>When you invoke an <I>instance method </I>using a specific object, if that method refers to instance variables of the class, that method is caused to refer to the <U>specific</U> instance variables of the <U>specific</U> object for which it was invoked. This is the behavior that causes us to refer to the method as an <I>instance method</I>. </P>
<P>Instance methods are invoked in Java by joining the name of the object and the name of the method using the dot operator as shown below: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>myObject.myInstanceMethod( )</PRE></TT></TD>
</TR>
</TABLE>


<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Instance methods are invoked in C++ in several different ways. One way is identical to Java using the name of the object, the dot operator, and the name of the method. Another way is to use the name of a <I>pointer variable</I> which points to the object, the <I>pointer operator</I>, and the name of the method as shown below. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<TT><P>myObject.myInstanceMethod( )</TT> </P>
<TT><PRE>myObjectPointer -&gt; myInstanceMethod( )</PRE></TT></TD>
</TR>
</TABLE>

<P>Note that <I>instance methods</I> have access to <U>both</U> <I>instance variables</I> and <I>class variables </I>in both Java and C++. </P>
<P><!-prev=Java042d.htm-><!-next=Java042f.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ClassMethods"></A>Class Methods</H2>
</FONT><P>When a member function is included in a C++ class definition or a method is included in a Java class definition, and the <B><I>static</I> </B>keyword is used, this results in a <I>class method</I>. </P>
<P>One of the significant things about <I>class methods</I> is that they can be invoked <U>without a requirement</U> to instantiate an object of the class. </P>
<P>In Java, a class method can be invoked by joining the name of the class to the name of the method using the dot operator as shown below: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>MyClass.myClassMethod()</PRE></TT></TD>
</TR>
</TABLE>


<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, a class method can be invoked using the name of the class, the scope resolution operator, and the name of the method as shown below: </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<TT><PRE>MyClass::myClassMethod()</PRE></TT></TD>
</TR>
</TABLE>

<P>In Java, <I>class methods</I> can <U>only</U> access other class members: <I>class variables</I> and other <I>class methods</I>. They <U>do not have access</U> to the instance variables of the class unless they create a new object and access the instance variables through that object. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Similar considerations hold for C++.</TD>
</TR>
</TABLE>

<P><!-prev=Java042e.htm-><!-next=Java042g.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Constructors"></A>Constructors</H2>
</FONT><P><A HREF="#ConstructorOverloading">Constructor Overloading</A><BR>
<A HREF="#DefaultConstructor">Default Constructor</A><BR>
<A HREF="#InstantiatingObjectsontheHeap">Instantiating Objects on the Heap</A><BR>
<A HREF="#OutOfMemoryError">OutOfMemoryError</A><BR>
<A HREF="#InstantiatingObjectsinMethodCalls">Instantiating Objects in Method Calls</A><BR>
<A HREF="#ConstructorsandInheritance">Constructors and Inheritance</A><BR>
<A HREF="#ConstructorsandAccessControl">Constructors and Access Control</A></P>
<P>Both Java and C++ support the notion of <I>overloaded methods</I>. This means that two or more methods may have the same name so long as they have different argument lists in their signatures. </P>
<P>If you overload a method name, the compiler determines at compile time, on the basis of the arguments provided to the invocation of the method, which version of the method to call in that instance. </P>
<P>Also, both Java and C++ support the notion of a constructor. A constructor is a special method which is used to construct an object. A constructor always has the same name as the class in which it is defined, has no return type specified, and must not include a <B>return</B> statement. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ConstructorOverloading"></A>Constructor Overloading</H3>
</FONT><U><P>Constructors may be overloaded</U>, so a single class may have more than one constructor, all of which have the same name, but different argument lists. </P>
<P>The primary purpose of a constructor is to initialize the instance variables of an object when the object is instantiated. </P>
<P>The same set of instance variables can often be initialized in <U>more than one way</U> using overloaded constructors. </P>
<P>For example, an object which stores date information <U>might</U> be initialized using a "mm/dd/yy" string format, or <U>might</U> be initialized using three integer values, one for month, one for day, and one for year. </P>
<P>In this case, two constructors could be defined, each of which would accept the initialization data in a different format, and convert that data to the format required to initialize the instance variables in an object of that type. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="DefaultConstructor"></A>Default Constructor</H3>
</FONT><P>It is not necessary to define a constructor in either Java or C++. In both cases, if you don't define a constructor, a default constructor is provided automatically on your behalf. </P>
<P>In Java, the default constructor automatically initializes all instance variables to zero or the equivalent of zero. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the default constructor doesn't perform any initialization. Rather, it simply causes the object to be instantiated in memory and available for use.</TD>
</TR>
</TABLE>

<P>You can think of the default constructor as a constructor which doesn't take any parameters. For that reason, some authors refer to the default constructor as the <B>Noarg</B> constructor. </P>
<P>Note however that you can also define a constructor that doesn't take any parameters, and cause its behavior to differ from the behavior of the default constructor. In this case, your new constructor will replace the default constructor. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In both Java and C++, if you provide any constructors, the default constructor is <U>no longer provided</U> automatically. In the event that you need a parameterized constructor and a constructor which doesn't take parameters, you <U>must provide them both</U>.</TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="InstantiatingObjectsontheHeap"></A>Instantiating Objects on the Heap</H3>
</FONT><P>In Java, objects can only be instantiated on the <I>heap</I>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ is less restrictive than Java in this regard, so that in C++, objects can be instantiated in a variety of ways. </TD>
</TR>
</TABLE>

<P>In other words, in order to instantiate an object in Java, you must </P>

<UL>
<LI>use the <B>new</B> operator to request memory from the operating system at runtime, and </LI>
<LI>use the constructor to instantiate the object in that memory. </LI></UL>

<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Note that there are ways to instantiate objects that don't make explicit use of the <STRONG>new</STRONG> operator, but they also instantiate the object on the heap. They are discussed in the <U>Intermediate</U> and <U>Advanced</U> courses.</TD>
</TR>
</TABLE>


<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The syntax for instantiating objects is different in Java and C++. </TD>
</TR>
</TABLE>

<P>The following statements show how the constructor is typically used in Java to declare, instantiate, and (optionally) initialize an object: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<P><TT>MyClass myObject = <B>new</B> MyClass();</TT> </P>
<TT><PRE>MyClass myObject = <B>new </B>MyClass(1,2,3);</PRE></TT></TD>
</TR>
</TABLE>

<P>These statements perform three actions in one. </P>

<UL>
<LI>The object is <I>declared </I>by notifying the compiler of the name of the object. </LI>
<LI>The object is <I>instantiated </I>by using the <B>new</B> operator to allocate memory space to contain the new object. </LI>
<LI>The object is <I>initialized </I>by making a call to the constructor named <B><TT>MyClass.</B></TT> </LI></UL>

<P>In the first case, the <U>default constructor</U> is called which will initialize the instance variables to zero or equivalent. </P>
<P>In the second case, a <U>parameterized constructor</U> is called and the initialization parameters 1, 2, and 3 are passed to that constructor. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="OutOfMemoryError"></A>OutOfMemoryError</H3>
</FONT><P>In Java, if you attempt to instantiate an object and the Java Virtual Machine <U>cannot allocate</U> the requisite memory (following a run of the garbage collector, if necessary), the system will throw an <B>OutOfMemoryError</B>. You could catch and attempt to process that error if you believe that some sort of recovery is possible. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the result of running out of memory will depend on the version of compiler that you are using. This is a complex topic in C++, so you need to make certain that you review the documentation received with your compiler to determine how programs produced using that compiler will behave.</TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="InstantiatingObjectsinMethodCalls"></A>Instantiating Objects in Method Calls</H3>
</FONT><P>The two statements above return a <I>reference </I>to the new object. The reference is stored in the variable named <B><TT>MyObject</TT>.</B> </P>
<P>In both Java and C++, it is also possible to make a call to the constructor without <U>obviously </U>assigning the reference to a variable. This is commonly referred to as an <I>anonymous</I> object. </P>
<P>For example, if a method requires an object of a particular type as an argument, it is allowable to include a call to the constructor of that type of object in the call to the method as illustrated below. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>obj.myFunction(
  new<B> myClassConstructor(1,2,3)</B> );//Java version</PRE></TT></TD>
</TR>
</TABLE>

<P>This statement causes an object to be instantiated and initialized and passed to the method where it is used to initialize a method parameter inside the method. </P>
<P>In this case, in order for the program to compile properly, a version of the method must exist which expects to receive an object of this type as a parameter. The argument list for the method will include a reference parameter of the correct type. </P>
<P>In both Java and C++, when a function or method begins execution, all of the parameters are created as local <I>automatic </I>variables. (<I>Automatic</I> variables cease to exist then the method terminates.) In Java, all variables are <I>automatic</I>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In addition to <I>automatic </I>variables, C++ supports <B>static</B> variables that do not cease to exist when the function terminates.</TD>
</TR>
</TABLE>

<P>The <U>scope</U> of these variables, that come into existence as <I>method parameters</I>, is the full extent of the method. </P>
<P>In this case, the object that is instantiated in conjunction with the method call will be used to initialize the <I>method parameter</I> variable when the method begins execution. That is how it is saved. </P>
<P>Since it will be <I>automatic</I>, when the method terminates, it will become eligible for garbage collection in Java. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Because it is be automatic, when the function terminates, it will destruct in C++.</TD>
</TR>
</TABLE>

<P>In both Java and C++, you declare and implement a constructor just like you would implement any other method in your class, except that you do not specify a return type (note that there are some other differences if the superclass contains a parameterized constructor and you elect to invoke it). </P>
<P>As mentioned earlier, the name of the constructor must be the same as the name of the class. Your constructor may be overloaded, meaning that you may define more than one constructor having the same name but a different argument list in the signature. </P>
<P>The following Java application illustrates some of the constructor concepts discussed above. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File cnstrct1.java Copyright 1997, R.G.Baldwin
This is a Java application which illustrates:
1.  Instantiating an object by calling the default 
constructor.
2.  Instantiating an object by calling a parameterized 
constructor as a parameter to a function call.

The program was tested using JDK 1.1.3 under Win95.

The program displays the following output:

<B>Starting Program
Object contains 100
</B>**********************************************************/

class <B>NewClass</B>{
  int instanceVar;
  //-----------------------------------------------------//
  
  <B>NewClass</B>(int inData){//parameterized<B> constructor
</B>    instanceVar = inData; //save inData
  }//end parameterized constructor
  //-----------------------------------------------------//

  void <B>showInstanceVar</B>(){
    System.out.println("Object contains " + instanceVar);
  }//end showInstanceVar
}//end NewClass
//=======================================================//

class <B>cnstrct1 </B>{ //define the controlling class
  //The following method receives an object and calls one
  // of the methods of the object to display the data 
  // contained in the object.
  void <B>myFunction(NewClass</B> objIn){
    objIn.showInstanceVar();
  }//end myFunction
  //-----------------------------------------------------//
  
  public static void <B>main</B>(String[] args){ //main method
    System.out.println("Starting Program");
        
    //Instantiate an object of this type by calling 
    // default constructor for the controlling class
    cnstrct1 obj = <B>new </B>cnstrct1();
        
    //Call instance method with call to parameterized 
    // constructor as a parameter
    obj.myFunction(new<B> NewClass(100)</B>);
  }//end main

}//End cnstrct1 class.  </PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ConstructorsandInheritance"></A>Constructors and Inheritance</H3>
</FONT><P>Constructors take on a special significance in cases where inheritance is involved. </P>
<P>In cases of inheritance, you will want the <I>subclass </I>to cause the constructor for the <I>superclass</I> to <U>execute first</U> to initialize those <I>instance variables</I> which derive from the superclass. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, this sequence of events is accomplished using a fairly complex syntax in the definition of the constructor. In Java, the syntax is less complex.</TD>
</TR>
</TABLE>

<P>In Java, to cause the constructor of the superclass to be invoked <U>prior</U> to the execution of the body of the constructor of the subclass, you simply include the following statement as the <U>first statement</U> in the constructor for the subclass: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><B><TT>super(optional</B><I> parameters</I><B>);</PRE></B></TT></TD>
</TR>
</TABLE>

<P>This will cause the constructor for the <I>superclass</I> to execute, using the optional parameters for initialization. </P>
<P>Although it isn't obvious, in all cases that you don't provide a <B>super()</B> statement ahead of the first executable statement in your constructor, the system inserts and executes such a statement on your behalf. This causes the <B>noarg</B> method of the superclass to be invoked before any of the code in your constructor is invoked. </P>
<P>Therefore, the construction of all objects in Java begins with the construction of that part of the object attributed to the class named <B>Object</B> which is the superclass of all classes. Construction then works its way down the inheritance tree (from the root to the branches) until the code in your constructor is finally executed. </P>
<P>The following Java application illustrates use of the <B>super</B> keyword to call a superclass constructor from a subclass. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File cnstrct2.java Copyright 1997, R.G.Baldwin
This is a Java application which extends the application 
named cnstrct1.java.  

In addition to the concepts illustrated in that 
application, this application illustrates the use of 
super() in a subclass constructor to call the constructor 
in the superclass.

Note that this program <B>will not compile</B> unless the 
replacement for the default constructor is provided.

Note also that the program <B>will not compile</B> if an output 
statement is placed ahead of the call to super() in the 
subclass constructor.

The program displays the following output:

<B>Starting Program
Default constructor invoked
Entering SuperClass constructor
Back in SubClass constructor
Object contains 100
</B>
**********************************************************/

class <B>SuperClass</B>{
  int instanceVar;
  
  <B>SuperClass(){//replacement</B> for <B>default constructor
</B>    System.out.println("Default constructor invoked");
  }//end default constructor
  //-----------------------------------------------------//

  <B>SuperClass(int</B> inData){//parameterized<B> constructor
</B>    System.out.println("Entering SuperClass constructor"); 
    instanceVar = inData;//put inData in instance variable
  }//end parameterized constructor
  //-----------------------------------------------------//

  void <B>showInstanceVar</B>(){
    System.out.println("Object contains " + instanceVar);
  }//end showInstanceVar
}//end SuperClass
//=======================================================//

class <B>SubClass extends SuperClass</B>{
  SubClass(int incomingData){// constructor
    //The following statement <B>will not compile</B>.  The call 
    // to super() must be the first thing in a method if 
    // it appears at all.
   <B> //System.out.println("Entering SubClass constructor");</B> 
    <B>super(incomingData);//call</B> the SuperClass constructor
    System.out.println("Back in SubClass constructor");
  }//end SubClass constructor
}//end SubClass
//=======================================================//

class <B>cnstrct2 </B>{ //define the controlling class
  //The following method receives an object and calls one 
  // of the methods of the object to display the data 
  // contained in the object. In this case, both the 
  // <B>method </B>and the <B>instance variable</B> are <B>inherited </B>from 
  // the SuperClass.
  void <B>myFunction(SubClass</B> objIn){
    objIn.showInstanceVar();
  }//end myFunction
  //-----------------------------------------------------//
  
  public static void <B>main</B>(String[] args){ //main method
    System.out.println("Starting Program");
    
    //Instantiate an object of the SuperClass type to
    // <B>illustrate the requirement</B> for the default 
    // constructor in the SuperClass class
    <B>new SuperClass()</B>;
  
    //Instantiate an object of <B>this type</B> by calling
    // default constructor
    <B>cnstrct2 obj = new cnstrct2()</B>;
  
    //Call function with call to parameterized SubClass 
    // constructor as a parameter.  The constructor in the
    // subclass passes the parameter along to the 
    // constructor in the superclass.
    obj.myFunction(new<B> SubClass(100)</B>);
  }//end main

}//End cnstrct2 class.  </PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ConstructorsandAccessControl"></A>Constructors and Access Control</H3>
</FONT><P>Access control also has a special meaning with regard to constructing objects. </P>
<P>The specified access control determines <U>what other objects can instantiate</U> objects of the class. </P>
<P>The following is a non-exhaustive description of what access control means with regards to constructing new objects. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Any code in any object can access and instantiate an object of any class in any package that has a <STRONG>public</STRONG><BR>
modifier (unless it also has an <STRONG>abstract</STRONG> modifier, in which case it can't be instantiated under any circumstance). There is no such thing as a <STRONG>private</STRONG> or <STRONG>protected</STRONG> modifier for a class, only <STRONG>public</STRONG>, <STRONG>abstract</STRONG>, and <STRONG>fina</STRONG>l. The <STRONG>abstract</STRONG> and <STRONG>final</STRONG> modifiers are mutually exclusive.</P>
<P>Only code in the same package can access and instantiate an object of a class that does not have a <STRONG>public</STRONG> modifier (if the class has an <STRONG>abstract</STRONG> modifier, it can't be instantiated). </TD>
</TR>
</TABLE>

<P>At this point, you may want to review earlier lesson on access control to refresh your memory as to what access control means to object construction.</P>
<P>The above results are obtained when you apply an access modifier to the class. According to <U>The Java Tutorial</U>, you can also apply access modifiers directly to the constructor with the following results:</P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><STRONG>private</STRONG> <BR>
No other class can instantiate your class as an object. Your class can still contain public class methods, and those methods can construct an object and return it, but no one else can. <BR>
<BR>
<STRONG>protected</STRONG> <BR>
Only subclasses of your class can create instances of it. <BR>
<BR>
<STRONG>public</STRONG> <BR>
Anybody can create an instance of your class. <BR>
<BR>
<STRONG>package-access</STRONG> <BR>
No one outside the package can construct an instance of your class. This is useful if you want to have classes in your package create instances of your class but you don't want to let anyone else.</TD>
</TR>
</TABLE>

<P><!-prev=Java042f.htm-><!-next=Java042h.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Finalization"></A>Finalization</H2>
</FONT><P><A HREF="#FinalizeisNotaDestructor">Finalize is Not a Destructor</A><BR>
<A HREF="#FinalizationandInheritance">Finalization and Inheritance</A></P>
<P>To begin with, <I>finalization</I> is a much more complex topic than some authors might lead you to believe. This will be apparent to C++ programmers who are familiar with the notion of destructors as they are used in C++. </P>
<P>It is strongly recommended that you avail yourself of the opportunity (if it still exists) to review the "book in progress" named <U>Thinking in Java</U> http://www.eckelobjects.com being written by Bruce Eckel. Pay particular attention to Eckel's discussion of C++ destructors and the Java <I>finalize</I> method. </P>
<P>The following treatment is based primarily on <U>The Java Tutorial</U> by Campione and Walrath which is somewhat light in the area of the finalize method as supplemented by Bruce Eckel's comments. </P>
<P>Every object has a <I>finalize</I> method which is inherited from the class named <B><I>Object</B></I>. Before an object is reclaimed by the garbage collector, the <I>finalize</I> method for the object is called. </P>
<P>If you need to do any cleanup associated with memory management, you can override the <I>finalize</I> method and place the cleanup code in that method. </P>
<P>If you need to do cleanup not associated with memory management before the object is reclaimed, and you are not in a hurry to have that cleanup done, you can invoke <B>runFinalizersOnExit(true)</B> early in your program, override the <I>finalize</I> method, and be confident that your objects will be finalized before the program terminates. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Note that the following two methods were added to JDK 1.1 to deal with some of finalization uncertainty that existed in JDK 1.0.2. </P>

<UL>
<B><LI>runFinalizersOnExit(boolean)</B>. Static method in class <B>java.lang.Runtime</B>. Enable or disable finalization on exit; doing so specifies that the finalizers of all objects that have finalizers that have not yet been automatically invoked are to be run before the Java runtime exits. </LI>
<B><LI>runFinalizersOnExit(boolean)</B>. Static method in class <B>java.lang.System</B>. Enable or disable finalization on exit; doing so specifies that the finalizers of all objects that have finalizers that have not yet been automatically invoked are to be run before the Java runtime exits. </UL>
</TD>
</TR>
</TABLE>

<P>In Java, if you need cleanup code to be executed on a timely basis, it is the responsibility of the programmer to write special methods for non-memory cleanup, and to purposely execute those methods at the appropriate points in time. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<H3 ALIGN="CENTER"><A NAME="FinalizeisNotaDestructor"></A><FONT COLOR="#ff0000">Finalize is Not a Destructor</FONT> </H3>
<P>C++ programmers should note that the <I>finalize</I> method in Java is not a <I>destructor </I>as in C++. The destructor in C++, if it exists, is <B><I><U>always</B></I></U> invoked when the object goes out of scope or is otherwise destroyed (as in using the <I>delete</I> operator to return the memory occupied by the object to the operating system). </P>
<P>Even though the <I>finalize</I> method is always invoked before the <I>garbage collector</I> reclaims memory in Java, there is no guarantee that the <I>garbage collector</I> will reclaim the memory occupied by a particular object. Therefore, there is no guarantee that the <I>finalize</I> method will ever be called. </P>
<P>(Actually, beginning with JDK 1.1, it is possible to guarantee that objects will be finalized by invoking <B>runFinalizersOnExit(true)</B> somewhere in your program.) </P>
<P>The bottom line is, don't put any code in the <I>finalize</I> method which <U>must be executed</U> unless you invoke <B>runFinalizersOnExit(true)</B>. </P>
<P>There is apparently nothing in Java that is comparable to a <I>destructor</I> in C++.</TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="FinalizationandInheritance"></A>Finalization and Inheritance</H3>
</FONT><P>Note that <U>The Java Tutorial</U> points out that if your class inherits from a superclass that also has a finalize method, you should use the following syntax to call that method <U>after</U> your <I>finalize</I> method has performed all of its duties. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>super.finalize();</PRE></TT></TD>
</TR>
</TABLE>

<P>For <I>construction</I>, we usually want to construct <U>from the root</U> of the inheritance tree <U>to the branches</U>. </P>
<P>For <I>finalization</I>, we usually want to finalize in the <U>reverse order</U>, from the branches back to the root. </P>
<P><!-prev=Java042g.htm-><!-next=Java042i.htm><!-first=Java042.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Review"></A>Review</H2>
</FONT><P>Q - In Java, <I>class variables</I> are often used with the __________ keyword to create variables that act like constants. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <B>final </B>keyword.</FONT> </P>
<P>Q - In Java, the ___________ keyword is used to declare a class variable. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <B>static </B>keyword.</FONT> </P>
<P>Q - In Java, the ___________ keyword is used to declare a class method. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <B>static </B>keyword.</FONT> </P>
<P>Q - When you include a method in a Java class definition <U>without</U> use of <I>static</I> keyword, this will result in objects of that class containing an <I>instance method</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Normally each object contains its own copy of each instance method: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False, multiple copies of the method do <U>not</U> normally exist in memory.</FONT> </P>
<P>Q - When you invoke an <I>instance method </I>using a specific object, if that method refers to instance variables of the class, that method is caused to refer to the specific instance variables of the specific object for which it was invoked: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Instance methods are invoked in Java using the name of the object, the colon, and the name of the method as shown below: True or False? If false, explain why. </P>

<UL>
<TT><LI>myObject:myInstanceMethod( )</TT> </LI></UL>

<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Use the period or dot operator, not the colon.</FONT> </P>
<P>Q - <I>Instance methods</I> have access to both <I>instance variables</I> and <I>class variables </I>in Java: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - <I>Class methods</I> have access to both <I>instance variables</I> and <I>class variables </I>in Java: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Class method can only access other class members.</FONT> </P>
<P>Q - What are the two most significant characteristics of class methods? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - 1. Class methods can only access other class members. 2. Class methods can be accessed using only the name of the class. An object of the class is not required to access class methods.</FONT> </P>
<P>Q - In Java, a class method can be invoked using the name of the class, the colon, and the name of the method as shown below: True or False? If false, explain why. </P>

<UL>
<TT><LI>MyClass:myClassMethod()</TT> </LI></UL>

<FONT SIZE=2 COLOR="#0000ff"><P>A - False. You must use the period or dot operator, not the colon.</FONT> </P>
<P>Q - What is meant by <I>overloaded methods</I>? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The term <I>overloaded methods</I> means that two or more methods may have the same name so long as they have different argument lists.</FONT> </P>
<P>Q - If you overload a method name, the compiler determines at run time, on the basis of the arguments provided to the invocation of the method, which version of the method to call in that instance: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The determination is made at compile time.</FONT> </P>
<P>Q - A constructor is a special method which is used to construct an object. A constructor always has the same name as the class in which it is defined, and has no return type specified. True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Constructors may be overloaded, so a single class may have more than one constructor, all of which have the same name, but different argument lists: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - What is the purpose of a parameterized constructor? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The purpose of a parameterized constructor is to initialize the instance variables of an object when the object is instantiated.</FONT> </P>
<P>Q - The same set of instance variables can often be initialized in more than one way using overloaded constructors: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - It is not necessary to provide a constructor in Java. True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. .</FONT> </P>
<P>Q - You can think of the default constructor as a constructor which doesn't take any parameters: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, if you provide any constructors, the default constructor is no longer provided automatically: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, if you need both a parameterized constructor and a constructor which doesn't take parameters (often called a default constructor), you must provide them both: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, you can instantiate objects in static memory at compile time, or you can use the <B>new</B> operator to request memory from the operating system at runtime and use the constructor to instantiate the object in that memory: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java, objects can only be instantiated on the <I>heap </I>at runtime.</FONT> </P>
<P>Q - Provide a code fragment consisting of a single statement that illustrates how the constructor is typically used in Java to declare, instantiate, and initialize an object. Assume a parameterized constructor with three parameters of type <B>int.</B> </P>
<FONT COLOR="#0000ff"><TT><P>A - MyClass myObject = <B>new </B>MyClass(1,2,3);</FONT></TT> </P>
<P>Q - Provide a code fragment consisting of a single statement that illustrates how the default constructor is typically used in Java to declare and instantiate an object. </P>
<FONT COLOR="#0000ff"><TT><P>A - MyClass myObject = <B>new</B> MyClass();</FONT></TT> </P>
<P>Q - What are the three actions performed by the following statement? </P>
<TT><P>MyClass myObject = <B>new </B>MyClass(1,2,3);</TT> </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - This statement performs three actions in one.</FONT> </P>

<UL>
<FONT SIZE=2 COLOR="#0000ff"><LI>The object is declared by notifying the compiler of the name of the object.</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>The object is instantiated by using the <B>new</B> operator to allocate memory space to contain the new object.</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>The object is initialized by making a call to the constructor named </FONT><B><FONT COLOR="#0000ff"><TT>MyClass.</B></FONT></TT> </LI></UL>

<P>Q - In Java, if you attempt to instantiate an object and the Java Virtual Machine cannot allocate the requisite memory, the system will: ________________________________________. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Throw an <B>OutOfMemoryError</B>.</FONT> </P>
<P>Q - The following is a valid method call: True or False. If false, explain why. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<P><TT>obj.myFunction(new myClassConstructor(1,2,3) );//Java version</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, when a method begins execution, all of the parameters are created as local automatic variables: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In the following statement, an object is instantiated and initialized and passed as a parameter to a function. What will happen to that object when the function terminates? </P>
<TT><P>obj.myFunction(new myClassConstructor(1,2,3) );//Java version</TT> </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - It will become eligible for garbage collection.</FONT> </P>
<P>Q - In Java, you declare and implement a constructor just like you would implement any other method in your class, except that: _______________________________________________ </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - you do not specify a return type and must not include a return statement.</FONT> </P>
<P>Q - The name of the constructor must be the same as the name of the ___________________. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - <B>class</B>.</FONT> </P>
<P>Q - Usually in cases of inheritance, you will want the <I>subclass </I>to cause the constructor for the <I>superclass</I> to execute last to initialize those <I>instance variables</I> which derive from the superclass: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. You will want the <I>subclass </I>to cause the constructor for the <I>superclass</I> to execute <U>first.</U></FONT> </P>
<P>Q - Provide a code fragment that you would include at the beginning of your constructor for a subclass to cause the constructor for the superclass to be invoked prior to the execution of the body of the constructor. </P>
<B><FONT COLOR="#0000ff"><TT><P>A - super(optional</B><I> parameters</I><B>);</B></FONT></TT> </P>
<P>Q - Every object has a <I>finalize</I> method which is inherited from the class named ________________. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - <B><I>object</B></I>.</FONT> </P>
<P>Q - Before an object is reclaimed by the garbage collector, the _______________ method for the object is called. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - <B>finalize</B></FONT> </P>
<P>Q - In Java, the destructor is always called when an object goes out of scope: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Java does not support the concept of a destructor.</FONT> </P>
<P>Q - Write a Java program that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE> /*File SampProg18.java from lesson 42
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates:
1.  Instantiating an object by calling the default 
    constructor.
2.  Instantiating an object by calling a parameterized 
    constructor as a parameter to a function call.

The program should display the following output:

Starting Program
Object contains 100
Terminating, Baldwin
**********************************************************/

class TestClass{
  int instanceVar;
  TestClass(int inData){//parameterized constructor
    instanceVar = inData;//put inData in instance variable
  }//end parameterized constructor

  void showInstanceVar(){
    System.out.println(
      "Object contains " + instanceVar);
  }//end showInstanceVar
}//end TestClass

class SampProg18 { //define the controlling class
  public static void main(String[] args){ //main method
    System.out.println("Starting Program");
  
    //Instantiate obj of this type by calling default
    // constructor
    SampProg18 obj = new SampProg18();
  
    //Call function with call to parameterized constructor 
    // as a parameter
    obj.myFunction(new TestClass(100));
    System.out.println("Terminating, Baldwin");
  }//end main

  //The following function receives an object and calls 
  // one of its methods to display the data contained in
  // the object.
  void myFunction(TestClass objIn){
    objIn.showInstanceVar();
  }//end myFunction
}//End SampProg18 class.  </PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java program that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg19.java from lesson 42
Copyright 1997, R.G.Baldwin
Without viewing the solution which follows, write a Java
application that illustrates the use of 
java.lang.system.runFinalizersOnExit().

The output from the program should be:
  
Terminating, Baldwin
Finalizing TestClassA object
Finalizing TestClassB object
**********************************************************/

class TestClassA{
  protected void finalize(){//override finalization method
    System.out.println("Finalizing TestClassA object");
  }//end overridden finalize() method
}//end TestClassA

class TestClassB{
  protected void finalize(){//override finalization method
    System.out.println("Finalizing TestClassB object");
  }//end overridden finalize() method
}//end TestClassB

class SampProg19{//controlling class
  public static void main(String[] args){//main method
    //Guarantee finalization of all objects on exit
    System.runFinalizersOnExit(true);
    
    //Instantiate two objects to be finalized
    TestClassA objA = new TestClassA();
    TestClassB objB = new TestClassB();
    System.out.println("Terminating, Baldwin");
  }//end main
}//end class SampProg19</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java042h.htm-><!-first=Java042.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
