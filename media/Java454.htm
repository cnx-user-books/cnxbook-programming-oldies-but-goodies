<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Using the Java 2D AffineTransformOp Filter Class to Process 
Images</h2>
<i>Learn how to write programs that use the AffineTransformOp 
image-filtering class of the Java 2D API for a variety of image-processing 
purposes.</i>
<p><b>Published:</b>&nbsp; April 10, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 454</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#General%20Background%20Information">General
Background Information</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
<ul>
	<li> <a href="#Scaling">Scaling</a></li>
	<li> <a href="#Translation">Translation</a></li>
	<li> <a href="#Rotation">Rotation</a></li>
	<li> <a href="#Mirror_Image">Mirror Image</a></li>
</ul>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listing</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p><font color="#ff0000"><b>Part of a series</b></font></p>
<p>In an earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3645761">A Framework for Experimenting with Java 2D 
Image-Processing Filters</a>, I taught you how to write a framework program that 
makes it easy to use the image-filtering classes of the Java 2D API to process the pixels in an 
image and to display the processed image.</p>
<p>In the previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/3654171">Using the Java 2D LookupOp Filter Class 
to Process Images</a>, I taught you how to write programs that use the <b>LookupOp</b> 
image-filtering class of the Java 2D API for a variety of image-processing 
purposes.</p>
<p>At the close of that lesson, I told you that future lessons would teach you 
how to use the following image-filtering classes from the Java 2D
<a name="FilterClassList">API</a>:</p>
<ul>
	<li><b>AffineTransformOp</b> </li>
	<li><b>BandCombineOp</b> </li>
	<li><b>ConvolveOp</b> </li>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b> </li>
</ul>
<p>In this lesson, I will keep that promise and teach you how to use the <b>
AffineTransformOp</b> image-filtering class to perform a variety of 
transformations on images.&nbsp; I will teach you how to use the remaining classes 
from the above list in future lessons.</p>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different listings and figures while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<p>I also recommend that you pay particular attention to the lessons listed in 
the <a href="#References">References</a> section of this document.
</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General Background Information</a></font></h2>
<p><font color="#ff0000"><b>Constructing images</b></font></p>
<p>Before getting into the programming details, it may be useful for you to 
review the concept of how images are constructed, stored, transported, and 
rendered in Java <i>(and in most modern computer environments for that matter).</i></p>
<p>I provided a great deal of information on those topics in the earlier lesson 
entitled
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
Processing Image Pixels using Java, Getting Started</a>.&nbsp; Therefore, I won't 
repeat that information here.&nbsp; Rather, I will simply refer you back to the
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
earlier lesson</a>.</p>
<p><font color="#ff0000"><b>The framework program named ImgMod05</b></font></p>
<p>It will also be useful for you to understand the behavior of the framework 
program named <b>ImgMod05</b>.&nbsp; Therefore, I strongly recommend that you 
study the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3645761">A Framework for Experimenting with Java 2D 
Image-Processing Filters</a>.</p>
<p>However, if you don't have the time to do that, I can summarize that 
framework program as follows:</p>
<p><font color="#ff0000"><b>Purpose of ImgMod05</b></font></p>
<p>The purpose of <b>ImgMod05</b> is to make it easy for you to experiment with 
the modification of images using the image-filtering classes of the Java 2D API 
and to display the modified version of the image along with the original image.
<i>(See an example of the graphic output format in <a href="#Figure_5">Figure 5</a>.)</i></p>
<p><font color="#ff0000"><b>The Replot button</b></font></p>
<p>The <b>ImgMod05</b> program GUI contains a <b>Replot</b> button <i>(as shown 
in <a href="#Figure_5">Figure 5</a>)</i>.&nbsp; At the beginning of the run, and each time thereafter that 
the <b>Replot</b> button is clicked:</p>
<ul>
	<li>The image-processing method belonging to an object of specified 
	image-processing class is invoked.</li>
	<li>The original image is passed to the image-processing method, which 
	returns a reference to a processed image.</li>
	<li>The resulting processed image is displayed along with the original image.</li>
	<li>The processed image is written into an output JPEG file named <b>junk.jpg</b>.</li>
</ul>
<p><font color="#ff0000"><b>Display of the images</b></font></p>
<p>When the <b>ImgMod05</b> program is started, the original image and the 
processed version of the image are displayed in a frame with the original image 
above the processed image <i>(as shown in <a href="#Figure_5">Figure 5</a>)</i>.&nbsp; The program attempts 
to set the size of the display so as to accommodate both images.&nbsp; If both images 
are not totally visible, the user can manually resize the display frame.</p>
<p><font color="#ff0000"><b>Input and output file format</b></font></p>
<p>The <b>ImgMod05</b> program will read gif and jpg input files and possibly 
some other input file types as well.&nbsp; The output file is always a JPEG file.</p>
<p><font color="#ff0000"><b>Typical usage</b></font></p>
<p>Enter the following at the command-line to run the <b>ImgMod05</b> program:</p>
<pre><b>java ImgMod05 ProcessingProgramName ImageFileName</b></pre>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain an image-processing program named
<b>ImgMod40</b> that is compatible with the framework program named <b>ImgMod05</b>.&nbsp; 
This program provides a GUI that allows the user to perform the following 
transforms on an input image:</p>
<ul>
	<li>Scaling</li>
	<li>Translation</li>
	<li>Rotation</li>
	<li>Mirror Image</li>
</ul>
<p>With the exception of the Mirror Image transform, all of the transforms in the above list 
allow the user to input important parameters via the GUI.</p>
<p>The program GUI is a <b>JTabbedPane</b> with four pages.&nbsp; Let's begin by 
taking a look at each of those pages.</p>
<p><font color="#FF0000"><b>Scaling</b></font></p>
<p>The <i>Scaling</i> page of the GUI is shown 
in <a name="Figure_1"><a href="#Figure_1">Figure 1</a></a>.</p>






<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java454a01.jpg" width="471" height="301"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see from <a href="#Figure_1">Figure 1</a>, the program allows the user to specify 
independent horizontal and vertical scale factors.&nbsp; In addition, the user 
is allowed to choose one of three optional interpolation schemes.&nbsp; <i>(I 
will have more to say about interpolation shortly.)</i></p>
<p><a href="#Figure_6">Figure 6</a> shows an example of a scaled image using <i>bicubic</i> interpolation.</p>
<p><font color="#FF0000"><b>Translation</b></font></p>
<p>The <i>Translation </i>page from the GUI is shown in <a name="Figure_2"><a href="#Figure_2">Figure 2</a></a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java454a02.jpg" width="471" height="301"><br></pre>
      <pre><b><a href="#Figure_2">Figure 2</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This program allows the user to translate the image to the right and down by 
specifying positive translation distances in pixels.&nbsp; Translation to the left 
and up can also be performed by specifying negative translation distances.&nbsp; 
However, translation to the left has the effect of chopping off part of the 
image on the left side, while translation up has the effect of chopping off part of 
the image at the top.</p>
<p><a href="#Figure_7">Figure 7</a> shows an example of an image that has been translated to the right 
and down.</p>
<p><font color="#FF0000"><b>Rotation</b></font></p>
<p>The <i>Rotation</i> page of the GUI is shown in <a name="Figure_3"><a href="#Figure_3">Figure 3</a></a>.</p>
<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java454a03.jpg" width="471" height="301"><br></pre>
      <pre><b><a href="#Figure_3">Figure 3</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Rotating the image.</b><br />
  Note that prior to performing the rotation, the image in 
	<a href="#Figure_8">Figure 8</a> was 
translated to the right and down a distance sufficient to make it possible to 
rotate it without chopping off its corners on the left and the top.</td></tr></table>
</td>
</tr>
</table>

This program allows the user to rotate the image about its center by a 
positive or negative angle specified in degrees, where positive rotation is 
clockwise rotation.</p>
<p>An example of rotating an image is shown in <a href="#Figure_8">Figure 8</a>.</p>
<p><font color="#FF0000"><b>Mirror Image</b></font></p>
<p>The <i>Mirror Image</i> page in the GUI is shown in <a name="Figure_4"><a href="#Figure_4">Figure 4</a></a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java454a04.jpg" width="471" height="301"><br></pre>
      <pre><b><a href="#Figure_4">Figure 4</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The mirror image is created by translating the image to the right by a 
distance equal to its width, and then flipping it about its left edge.&nbsp; There are no user input parameters for this process.&nbsp; An 
example of creating the mirror image of an image is shown in <a href="#Figure_9">Figure 9</a>.</p>
<p><font color="#FF0000"><b>A very significant capability</b></font></p>
<p>In my opinion, <i>(with the possible exception of the <b>ColorConvertOp</b> 
class)</i>, the <b>AffineTransformOp</b> class is the most significant of all 
the image-filtering classes in the Java 2D API.</p>
<p><font color="#FF0000"><b>Many sequential transforms can be performed</b></font></p>
<p>Although this demonstration program doesn't allow the user to perform a 
series of different transforms in sequence on the same image, be aware that once 
you start writing your own code, you can create many different image-processing 
effects by performing multiple transforms in sequence.</p>
<blockquote>
	<p><i>(Actually you could do that with this program by running the program 
	several times in succession using the output file from one run as the input 
	file to the next run, but that wouldn't be very convenient.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Interpolation is a major programming issue</b></font></p>
<p>I will explain more about interpolation shortly.&nbsp; For now, suffice it to 
say that because of the interpolation issue, a great deal of programming effort 
would be required for you to write your own class that replicates the behavior 
of the <b>AffineTransformOp</b> class.&nbsp; That is the main reason that I 
consider the capability provided by this class to be so significant.&nbsp; Therefore, if this class will serve your 
needs, this is clearly a case where you should <i>use</i> the existing class 
instead of <i>inventing</i> a new class.</p>
<blockquote>
	<p><i>(It would also be very difficult to write your own class to replicate 
	the behavior of the <b>ColorConvertOp</b> class.&nbsp; However, I may be 
	wrong on this, but I consider the <b>AffineTransformOp</b> class to be more 
	useful, more of the time than the <b>ColorConvertOp </b>class.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Creating new color values through interpolation</b></font></p>
<p>Whenever you change the size, the location, or the orientation of an image, 
you usually need to 
<a href="http://astronomy.swin.edu.au/~pbourke/colour/bicubic/">recreate the color values</a> for all of the pixels 
in the transformed image on the 
basis of the color values contained in the original image.&nbsp; This is not a 
trivial computational task.&nbsp; <i>(I discuss this <a href="#interpolation">
requirement</a> in additional detail in a later section that explains the 
requirements for scaling and then rendering images.)</i></p>
<p><font color="#FF0000"><b>The AffineTransformOp class provides three 
interpolation choices</b></font></p>
<p>When you use the <b>AffineTransformOp</b> class to transform one image into 
another image, you have three choices regarding how the color values for the new 
pixels will be <a name="InterpolationChoices">created</a>:</p>
<ul>
	<li>Use the <i>
	<a href="http://iria.pku.edu.cn/~jiangm/courses/dip/html/node66.html">nearest neighbor</a></i></li>
	<li>Perform <i>
	<a href="http://iria.pku.edu.cn/~jiangm/courses/dip/html/node67.html">bilinear</a></i> interpolation</li>
	<li>Perform <i>
	<a href="http://iria.pku.edu.cn/~jiangm/courses/dip/html/node68.html">bicubic</a></i> interpolation</li>
</ul>
<p>The <i>Scaling</i> page of the program GUI shown in <a href="#Figure_1">Figure 1</a> makes it 
possible for the user to select which of the three interpolation schemes will be 
used.&nbsp; </p>
<p><font color="#FF0000"><b>Higher quality equates to higher computational cost</b></font></p>
<p>Generally speaking, the quality of the resulting image will improve and the 
computer time required to generate the new image will increase as you go down 
the above <a href="#InterpolationChoices">list</a> from top to bottom.&nbsp; In other words, <i>bicubic
</i>interpolation usually requires more computational effort and provides better 
output image quality than the <i>nearest neighbor</i> scheme.&nbsp; <i>Bilinear
</i>interpolation falls somewhere in between the other two.</p>
<p><font color="#FF0000"><b>Technical material on interpolation</b></font></p>
<p><a href="http://astronomy.swin.edu.au/~pbourke/colour/">Paul Bourke</a> 
provides a general discussion of <i>bicubic</i> interpolation on his
<a href="http://astronomy.swin.edu.au/~pbourke/colour/bicubic/">bicubic site</a> 
and also mentions both <i>bilinear</i> and <i>nearest neighbor</i> interpolation 
as well.&nbsp; </p>
<p>You can also find mathematical descriptions of the three interpolation 
schemes by clicking the hyperlinks in the above <a href="#InterpolationChoices">
list of interpolation choices</a>.</p>
<p><font color="#ff0000"><b>Scaling</b></font></p>
<p><a href="#Figure_5">Figure 5</a> and
<a href="#Figure_6">Figure 6</a> show the results of a scaling 
transform.&nbsp; For this transform, the width of the image was increased by a factor 
of 1.5 and the height was increased by a factor of 2.0.&nbsp; The <i>nearest neighbor</i> 
scheme<i> </i>was used to create the new pixel values for
<a href="#Figure_5">Figure 5</a>.&nbsp; <i>Bicubic </i>interpolation was 
used for <a name="Figure_5"><a href="#Figure_6">Figure 6</a></a>.</p>
<table bgcolor="#ffffff" border="1" cols="1">
	<tr>
		<td>
		<pre><img src="java454b01.jpg" border="0" height="463" width="241">
</pre>
		<pre><b><a href="#Figure_5">Figure 5</a></b></pre>
		</td>
	</tr>
</table>
<p><font color="#ff0000"><b>The image quality in Figure 6 is better</b></font></p>
<p>If you compare the bottom image in <a href="#Figure_5">Figure 5</a> 
above with the bottom image in <a href="#Figure_6">Figure 6</a> 
below, you should be able to see that the image quality in
<a href="#Figure_6">Figure 6</a> is superior to that in
<a name="Figure_6"><a href="#Figure_5">Figure 5</a></a>.</p>
<table bgcolor="#ffffff" border="1" cols="1">
	<tr>
		<td>
		<pre><img src="java454b02.jpg" border="0" height="463" width="241">
</pre>
		<pre><b><a href="#Figure_6">Figure 6</a></b></pre>
		</td>
	</tr>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Note the vertical stripes.</b><br />
  For example, note the vertical stripes in the light gray stem in the 
	upper-left of the bottom image in <a href="#Figure_5">Figure 5</a>.&nbsp; 
	Although there is some striping in this area of
	<a href="#Figure_6">Figure 6</a>, it isn't nearly as pronounced.</td></tr></table>
</td>
</tr>
</table>

<font color="#ff0000"><b>Neither image has outstanding quality</b></font></p>
<p>Although neither image shows outstanding quality, <i>(which is a common 
result of enlarging images of this type)</i>, the image produced using the <i>
nearest neighbor </i>scheme in <a href="#Figure_5">Figure 5</a> is 
more grainy than the image produced using <i>bicubic </i>interpolation in
<a href="#Figure_6">Figure 6</a>.</p>
<p><font color="#ff0000"><b>Translation</b></font></p>
<p><a href="#Figure_7">Figure 7</a> shows the result of translating the image by 15.25 pixels to the 
right and 20.75 pixels down.&nbsp; <i>(Bicubic interpolation was used for 
<a name="Figure_7" href="#Figure_7">Figure 
7</a>.)</i></p>
<table bgcolor="#ffffff" border="1" cols="1">
	<tr>
		<td>
		<pre><b><img src="java454b03.jpg" border="0" height="348" width="180">

<a href="#Figure_7">Figure 7</a></b></pre>
		</td>
	</tr>
</table>
<p>Ideally, the output image would be an exact copy of the input image in this 
case.&nbsp; However, there is probably some degradation due to the requirement to 
create the new pixel color values through interpolation of the original pixel 
color values.</p>
<p><font color="#ff0000"><b>Rotation</b></font></p>
<p><a href="#Figure_8">Figure 8</a> shows the result of first translating the image to the right and 
down a distance sufficient to give it room to rotate about its center without 
chopping off the corners, and then rotating it by 31.5 degrees in a clockwise 
direction about its center.&nbsp; <i>(Bicubic interpolation was used for 
<a name="Figure_8"><a href="#Figure_8">Figure 8</a></a>.)</i></p>
<table bgcolor="#ffffff" border="1" cols="1">
	<tr>
		<td>
		<pre><img src="java454b04.jpg" border="0" height="392" width="232">
</pre>
		<pre><b><a href="#Figure_8">Figure 8</a></b></pre>
		</td>
	</tr>
</table>
</p>
<p><font color="#ff0000"><b>Mirror image</b></font></p>
<p><a href="#Figure_9">Figure 9</a> shows the result of using the
<b>AffineTransformOp</b> class to translate the image to the right by a distance 
equal to its width, and then flipping it about its left edge.&nbsp; This creates a mirror image of the original image.&nbsp; <i>(Bicubic interpolation was used for 
<a name="Figure_9" href="#Figure_9">Figure 
9</a>.)</i></p>
<table bgcolor="#ffffff" border="1" cols="1">
	<tr>
		<td>
		<pre><img src="java454b05.jpg" border="0" height="327" width="164">
</pre>
		<pre><b><a href="#Figure_9">Figure 9</a></b></pre>
		</td>
	</tr>
</table>
</p>
<p>Now it's time to examine the code.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
<font color="#FF0000"><b>The program named ImgMod40</b></font><p>As explained 
earlier, in this lesson, I will present and explain an image-processing program 
named <b>ImgMod40</b> that is compatible with the framework program named <b>
ImgMod05</b>.&nbsp; This program provides a GUI that allows the user to perform the 
following transforms on an input image:</p>
<ul>
	<li>Scaling</li>
	<li>Translation</li>
	<li>Rotation</li>
	<li>Mirror Image</li>
</ul>
<p>With the exception of the Mirror Image transform, all of the transforms in the above list 
allow the user to input important parameters via the GUI.</p>
<p><font color="#FF0000"><b>Purpose</b></font></p>
<p>The purpose of this program is to show you how to write image-processing 
programs of this type, and also to illustrate a variety of different uses for 
the <b>AffineTransformOp</b> image-filtering class of the Java 2D API.</p>
<p><font color="#FF0000"><b>General comments</b></font></p>
<p>The program named <b>ImgMod038</b>, which I explained in the earlier lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3654171">Using the Java 2D LookupOp Filter Class to Process Images</a>, 
contained a number of general comments that apply to this program also.&nbsp; 
You are encouraged to take a look at those comments.</p>
<p><font color="#FF0000"><b>Compatible with ImgMod50</b></font></p>
<p>This class is compatible with the use of the framework program named <b>ImgMod05</b>, 
which I explained in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3645761">A Framework for 
Experimenting with Java 2D Image-Processing Filters</a>.&nbsp; The framework program named 
<b>ImgMod05</b> displays the original and the processed images in the format 
shown in <a href="#Figure_5">Figure 5</a>.&nbsp; It also writes the processed 
image into an output file in 
JPEG format.&nbsp; The name of the output file is <b>junk.jpg</b> and it is written into the current directory.</p>
<p><font color="#FF0000"><b>The program GUI</b></font></p>
<p>Image-processing programs such as this one may provide a program GUI for 
data input making it possible for the user to modify the behavior of the 
image-processing method each time the <b>Replot</b> button <i>(shown in 
<a href="#Figure_5">Figure 
5</a>)</i> is clicked.</p>
<p>This 
program creates a GUI consisting of a tabbed pane containing four pages.&nbsp; The tabs 
on the pages are labeled:</p>
<ul>
	<li>Scaling</li>
	<li>Translation</li>
	<li>Rotation</li>
	<li>Mirror Image</li>
</ul>
<p>Each page 
contains a set of controls that make it possible to process the image in a way 
that illustrates the processing concept indicated by the label on the 
tab.</p>
<p>The four pages of the tabbed pane are shown in <a href="#Figure_1">Figure 1</a> through <a href="#Figure_4">Figure 4</a>.</p>
<p>Processing details for each page are provided in the comments in the code 
used to construct and process the individual pages.</p>
<p><font color="#FF0000"><b>Instructions for running the program</b></font></p>
<p>Enter the following at the command line to run 
this program:</p>
<p><pre><b>java ImgMod05 ImgMod40 ImageFileName</b></pre></p>
<p>If the program is unable to load 
the image file within ten seconds, it will abort with an error message.</p>
<p>The program was tested using J2SE 5.0 under 
WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will discuss and explain this program in fragments.&nbsp; You can view a 
complete listing of the program in <a href="#Listing_29">Listing 29</a> near the end of the lesson.</p>
<p><font color="#FF0000"><b>The class named ImgMod40</b></font></p>
<p>This program consists of a single class named <b>ImgMod40</b>, which begins 
in <a name="Listing_1" href="#Listing_1">Listing 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod40 extends Frame implements ImgIntfc05{

  JTabbedPane tabbedPane = new JTabbedPane();<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The class extends <b>Frame</b>, making an object of the class eligible to 
serve as its own program GUI.</p>
<p>The class also implements the interface named <b>ImgIntfc05</b> making it 
eligible to be run under control of the framework program named <b>ImgMod05</b>.</p>
<blockquote>
	<p><i>(Recall that image-processing programs that are compatible with the 
	framework program named ImgMod05 must implement the interface named 
	ImgIntfc05.)</i></p>
</blockquote>
<p><a href="#Listing_1">Listing 1</a> instantiates an object of the <b>JTabbedPane</b> class, which 
serves as the primary container for the GUI shown in <a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>Instantiate control components for the GUI pages</b></font></p>
<p><a href="#Listing_2">Listing 2</a> instantiates a number of components required to construct the four 
pages of the GUI shown in <a href="#Figure_1">Figure 1</a> through <a href="#Figure_4">Figure 4</a>.&nbsp; Those components that 
require local access only are instantiated closer to where they are used.&nbsp; 
Those that require broader access are instantiated in <a href="#Listing_2">Listing 2</a> as instance 
<a name="Listing_2">variables</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  <b>//Components used to construct the Scaling page.</b>
  Panel page00 = new Panel();
  TextField page00TextFieldHorizontal = 
                                    new TextField("0.5",6);
  TextField page00TextFieldVertical = 
                                    new TextField("0.5",6);
  //Components for radio buttons
  CheckboxGroup Page00Group = new CheckboxGroup();
  Checkbox page00NearestNeighbor = new Checkbox(
       "Nearest Neighbor Interpolation",Page00Group,false);
  Checkbox page00Bilinear = new Checkbox(
               "Bilinear Interpolation",Page00Group,false);
  Checkbox page00Bicubic = new Checkbox(
                 "Bicubic Interpolation",Page00Group,true);


  <b>//Components used to construct the Translation page.</b>
  Panel page01 = new Panel();
  TextField page01TextFieldHorizontal = 
                                      new TextField("5",6);
  TextField page01TextFieldVertical = 
                                     new TextField("10",6);


  <b>//Components used to construct the Rotation page.</b>
  Panel page02 = new Panel();
  TextField page02TextField = new TextField("45.0",6);


  <b>//Components used to construct the Mirror Image page.</b>
  Panel page03 = new Panel();<br><br><b><font face="Courier New,Courier"><a href="#Listing_2">Listing 2</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor for the class is shown in its entirety in <a href="#Listing_3">Listing 3</a>.&nbsp; 
This is the primary constructor.&nbsp; It calls other methods to separate the 
construction of the GUI into easily understandable units.&nbsp; Each method that 
it calls constructs one page in the tabbed <a name="Listing_3">pane</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  ImgMod40(){//constructor
  
    constructPage00();
    tabbedPane.add(page00);//Add page to the tabbedPane.
    
    constructPage01();
    tabbedPane.add(page01);//Add page to the tabbedPane.
    
    constructPage02();
    tabbedPane.add(page02);//Add page to the tabbedPane.
    
    constructPage03();
    tabbedPane.add(page03);//Add page to the tabbedPane.
    
    add(tabbedPane);//Add tabbedPane to the Frame.

    setTitle("Copyright 2006, R.G.Baldwin");
    setBounds(555,0,470,300);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor<br><br><b><font face="Courier New,Courier"><a href="#Listing_3">Listing 3</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The method named <b>processImg</b> is declared in the interface named <b>
ImgIntfc05</b>, and must be defined by any program that is compatible with being 
executed under control of the framework program named <b>ImgMod05</b>.</p>
<p>This is the primary image-processing method of the program.&nbsp; It is 
called by the program named <b>ImgMod05</b> at startup, and each time thereafter 
that the user clicks the <b>Replot</b> button shown in <a href="#Figure_5">Figure 5</a>.</p>
<p>The <b>processImg</b> method is shown in its entirety in <a name="Listing_4"><a href="#Listing_4">Listing 4</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public BufferedImage processImg(BufferedImage theImage){
    
    BufferedImage outputImage = null;
    
    //Process the page in the tabbed pane that has been
    // selected by the user.
    switch(tabbedPane.getSelectedIndex()){
      case 0:outputImage = <b>processPage00</b>(theImage);
             break;
      case 1:outputImage = <b>processPage01</b>(theImage);
             break;
      case 2:outputImage = <b>processPage02</b>(theImage);
             break;
      case 3:outputImage = <b>processPage03</b>(theImage);
             break;
    }//end switch

    return outputImage;
  }//end processImg<br><br><b><font face="Courier New,Courier"><a href="#Listing_4">Listing 4</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the processImg method</b></font></p>
<p>Each time the <b>processImg</b> method is invoked, it queries the <b>
JTabbedPane</b> object in the GUI to determine which page has been selected by 
the user.&nbsp; Then, depending on which page has been selected, it invokes one of the following four methods to process the 
image in accordance with the concept embodied by the selected page:</p>
<ul>
	<li>processPage00 - Scaling</li>
	<li>processPage01 - Translation</li>
	<li>processPage02 - Rotation</li>
	<li>processPage03 - Mirror Image</li>
</ul>
<h3><a name="Scaling">Scaling</a></h3>
<p><font color="#FF0000"><b>Construct the Scaling page</b></font></p>
<p>The primary constructor shown in <a href="#Listing_3">Listing 3</a> invokes the method named <b>
constructPage00</b> to construct the <i>Scaling</i> page shown in <a href="#Figure_1">Figure 1</a>.&nbsp; The 
method named <b>constructPage00</b> is shown in its entirety in 
<a name="Listing_5"><a href="#Listing_5">Listing 5</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructPage00(){
    page00.setName("Scaling");//Label on the tab.
    page00.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE SCALING\n"
      + "This page illustrates the scaling of an image "
      + "using three different types of interpolation."
      + "\n\n"
      + "Enter a positive scale factor between 0.001 and "
      + "10.0 in each of the text fields, select an "
      + "interpolation type, and click the Replot button. "
      + "The best quality interpolation will probably be "
      + "achieved with the use of Bicubic Interpolation. "
      + "Nearest Neighbor Interpolation will probably "
      + "produce the poorest quality.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,7,1,
                                 TextArea.SCROLLBARS_NONE);
    page00.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    Panel page00ControlPanel = new Panel();
    page00ControlPanel.setLayout(new GridLayout(5,1));
    
    //Construct and populate the panels that contain the
    // radio buttons, the labels, and the text fields.
    // Add each such panel an a new cell in the grid
    // layout going from the top of the grid to the bottom
    // of the grid.
    
    //Begin with the radio buttons.  The purpose of putting
    // the radio buttons on panels is to cause them to be
    // left justified in their cells.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel00.add(page00NearestNeighbor);
    page00ControlPanel.add(subControlPanel00);
    
    Panel subControlPanel01 = new Panel();
    subControlPanel01.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel01.add(page00Bilinear);
    page00ControlPanel.add(subControlPanel01);
    
    Panel subControlPanel02 = new Panel();
    subControlPanel02.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel02.add(page00Bicubic);
    page00ControlPanel.add(subControlPanel02);
    
    //Now create and populate panels that contain labels
    // and associated TextField objects
    Panel subControlPanel03 = new Panel();
    subControlPanel03.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel03.add(new Label(
                               "Horizontal Scale Factor"));
    subControlPanel03.add(page00TextFieldHorizontal);
    page00ControlPanel.add(subControlPanel03);
    
    Panel subControlPanel04 = new Panel();
    subControlPanel04.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel04.add(new Label(
                                 "Vertical Scale Factor"));
    subControlPanel04.add(page00TextFieldVertical);
    page00ControlPanel.add(subControlPanel04);
    
    page00.add(page00ControlPanel,BorderLayout.CENTER);
  }//end constructPage00<br><br><b><font face="Courier New,Courier"><a href="#Listing_5">Listing 5</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Straightforward code</b></font></p>
<p>Although the code in <a href="#Listing_5">Listing 5</a> is rather long and tedious, there is nothing 
complicated about it.&nbsp; If you use <a href="#Figure_1">Figure 1</a> as a guide, you should be able 
to follow the code in <a href="#Listing_5">Listing 5</a> with no difficulty.</p>
<p><font color="#FF0000"><b>The processPage00 method</b></font></p>
<p>When the user selects the <i>Scaling</i> tab in <a href="#Figure_1">Figure 1</a> and clicks the <b>
Replot</b> button shown in <a href="#Figure_5">Figure 5</a>, the <b>switch</b> statement in <a href="#Listing_4">Listing 4</a> invokes 
the method named <b>processPage00</b> to process the image.</p>
<p><font color="#FF0000"><b>General processing methodology</b></font></p>
<p>In general, the methodology used to process an image using the <b>
AffineTransformOp</b> image-filtering class of the Java 2D API consists of the 
<a name="following_three_steps">following three steps</a>:</p>
<ol>
	<li>Get an <a name="object_of_the_AffineTransform_class">object of the <b>AffineTransform</b> class</a> that reflects the type of transformation that 
	is required.&nbsp; <i>(See the earlier lesson entitled
	<a href="http://www.developer.com/java/other/article.php/626051">Java 2D 
	Graphics, Simple Affine Transforms</a> for more information on the <b>AffineTransform</b> class.)</i></li>
	<li>Use the <b>AffineTransform</b> object to
	<a name="create_an_image-filtering_object">create an image-filtering object</a> 
	of the <b>AffineTransformOp</b> class with a specified interpolation scheme.</li>
	<li><a name="Invoke_the_filter_method">Invoke the <b>filter</b> method</a> on the image-filtering object to apply 
	the filter to the image.</li>
</ol>
<p>As you will see, some of the above steps require additional code in 
preparation for accomplishing the step.</p>
<p><font color="#FF0000"><b>Processing the image</b></font></p>
<p>The <b>processPage00</b> method processes the image according to the controls 
located on the <i>Scaling</i> page shown in <a href="#Figure_1">Figure 1</a>.&nbsp; This method uses the
<b>AffineTransformOp</b> filter class to process the image.</p>
<p>This method illustrates image scaling using independent horizontal and 
vertical scale factors, giving the user a choice of three different 
interpolation schemes.&nbsp; <i>(See the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/626051">Java 2D 
Graphics, Simple Affine Transforms</a> for more information on the use of a 
scaling affine transform.)</i></p>
<p>The <b>processPage00</b> method begins in <a name="Listing_6"><a href="#Listing_6">Listing 6</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  BufferedImage <b>processPage00</b>(BufferedImage theImage){
    
    //Set a non-zero default value for the horizontal scale
    // factor.
    double horizontalScale = 0.001;
    try{//Get horizontalScale from the text field.
      horizontalScale = Double.parseDouble(
                      page00TextFieldHorizontal.getText());
    }catch(java.lang.NumberFormatException e){
      page00TextFieldHorizontal.setText("Bad Input");
      horizontalScale = 0.001; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for horizontal scale
    if((horizontalScale &lt; 0.001) || 
                                 (horizontalScale &gt; 10.0)){
      page00TextFieldHorizontal.setText("Bad Input");
      horizontalScale = 0.001;//Override bad user input.
    }//end if
  
    //Set a non-zero default value for the vertical scale
    // factor.
    double verticalScale = 0.001;
    try{//Get verticalScale from the text field.
      verticalScale = Double.parseDouble(
                        page00TextFieldVertical.getText());
    }catch(java.lang.NumberFormatException e){
      page00TextFieldHorizontal.setText("Bad Input");
      verticalScale = 0.001; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for verticalScale
    if((verticalScale &lt; 0.001) || (verticalScale &gt; 10.0)){
      page00TextFieldHorizontal.setText("Bad Input");
      verticalScale = 0.001;//Override bad user input.
    }//end if<br><br><b><font face="Courier New,Courier"><a href="#Listing_6">Listing 6</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Getting the scale factors</b></font></p>
<p>The first task that the method must accomplish is to get the horizontal and 
vertical scale factors that were entered by the user into the text fields in 
<a href="#Figure_1">Figure 1</a>.&nbsp; This is accomplished by the code in <a href="#Listing_6">Listing 6</a>.&nbsp; The code in 
<a href="#Listing_6">Listing 6</a> is straightforward, and should not require further explanation beyond 
the comments embedded in the code.</p>
<p><font color="#FF0000"><b>Identify the desired interpolation scheme</b></font></p>
<p>The next task that the method must perform is to determine which 
interpolation scheme has been selected by the user and to become prepared to use that 
interpolation scheme in the creation of the
<a href="#create_an_image-filtering_object">image-filtering object</a>.&nbsp; 
This is accomplished in <a name="Listing_7"><a href="#Listing_7">Listing 7</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    int interpolationScheme;

    if(page00Bicubic.getState() == true){
      interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;
    }else if(page00Bilinear.getState() == true){
      interpolationScheme = 
                           AffineTransformOp.TYPE_BILINEAR;
    }else{//page00NearestNeighbor must be selected
      interpolationScheme = 
                   AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
    }//end else<br><br><b><font face="Courier New,Courier"><a href="#Listing_7">Listing 7</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_7">Listing 7</a> gets the selected interpolation scheme from the radio buttons and 
reflects that selection in an <b>int</b> variable named <b>interpolationScheme</b>.&nbsp; 
This variable will be used later in the creation of the
<a href="#create_an_image-filtering_object">image-filtering object</a>.</p>
<p><font color="#FF0000"><b>Create the required AffineTransform object</b></font></p>
<p>As indicated in the above <a href="#following_three_steps">list 
of three required steps</a>, an <b>AffineTransform</b> object is required later 
to create the image-filtering object.&nbsp; The creation of that object is accomplished by 
<a name="Listing_8"><a href="#Listing_8">Listing 8</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    AffineTransform transformObj = 
                         AffineTransform.getScaleInstance(
                            horizontalScale,verticalScale);<br><br><b><font face="Courier New,Courier"><a href="#Listing_8">Listing 8</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>An examination of the documentation for the <b>AffineTransform</b> class 
shows that there are several different ways to create such an object.&nbsp; The 
statement in <a href="#Listing_8">Listing 8</a> is probably the simplest of those ways.</p>
<blockquote>
	<p><i>(The <b>getScaleInstance</b> method of the <b>AffineTransform</b> 
	class is a convenience method that is designed to make it easy to create 
	scaling transforms.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Create the image-filtering object</b></font></p>
<p><a href="#Listing_9">Listing 9</a> accomplishes the <a href="#create_an_image-filtering_object">second 
step</a> in the above list of three required <a name="Listing_9">steps</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    AffineTransformOp filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);<br><br><b><font face="Courier New,Courier"><a href="#Listing_9">Listing 9</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_9">Listing 9</a> instantiates a new object of the <b>AffineTransformOp</b> class 
passing a reference to the <b>AffineTransform</b> object, along with the 
variable that identifies the interpolation scheme to the constructor for the <b>
AffineTransformOp</b> class.&nbsp; The resulting object will be used to filter 
the image.</p>
<p><font color="#FF0000"><b>Now for something different</b></font></p>
<p>For all of the image-filtering classes in the Java 2D API <i>(except for the <b>
AffineTransformOp</b> class)</i>, all that is necessary to filter the image and 
to return a reference to a <b>BufferedImage</b> object <i>(that encapsulates the 
filtered image)</i> is to execute a statement similar to the following:</p>
<p><pre><b><a name="return_filterObj">return filterObj</a>.filter(theImage,null);</b></pre></p>
<p>For example, this is very similar to the code that I used to filter the 
images in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3654171">Using the Java 2D LookupOp Filter 
Class to Process Images</a>.</p>
<p>However, for reasons that I am unable to explain, when I use that approach 
for the <b>AffineTransformOp</b> class, the <b>ColorModel</b> of the <b>
BufferedImage</b> object that is returned to the framework program named <b>
ImgMod05</b> is not compatible with the method used by that program to write the 
output JPEG file.&nbsp; This results in an output file in which the image data 
appears to be scrambled.&nbsp; Therefore, it was necessary for me to find and 
use an alternative approach that provides better control over the color model.</p>
<p><font color="#FF0000"><b>An alternative approach</b></font></p>
<p><a href="#Figure_10">Figure 10</a> contains partial documentation for the <b>filter</b> method of the
<b>AffineTransformOp</b> <a name="Figure_10">class</a>.</p>

<p>
<table border="1" cols="1" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public final BufferedImage <b>filter</b>(BufferedImage&nbsp;src,
                                  BufferedImage&nbsp;dst)</pre>
		<dl>
			<dd>Transforms the source <code>BufferedImage</code> and stores the 
			results in the destination <code>BufferedImage</code>. If the color 
			models for the two images do not match, a color conversion into the 
			destination color model is performed. If the destination image is 
			null, a <code>BufferedImage</code> is created with the source <code>
			ColorModel</code>.<br>
&nbsp;</dd>
			<dd>
			<dl>
				<dt><b>Parameters:</b> </dt>
				<dd><code>src</code> - The <code>BufferedImage</code> to 
				transform.
				</dd>
				<dd><code>dst</code> - The <code>BufferedImage</code> in which 
				to store the results of the transformation. 
				</dd>
				<dt><b>Returns:</b> </dt>
				<dd>The filtered <code>BufferedImage</code>.</dd>
			</dl>
			</dd>
		</dl>
      <pre><b><a href="#Figure_10">Figure 10</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two ways to access the filtered image</b></font></p>
<p>According to the information in <a href="#Figure_10">Figure 10</a>, there are two ways to 
gain access to the filtered image:</p>
<ol>
	<li><a name="Capture_the_return_value">Capture the return value</a> from the
	<b>filter</b> method, which is 
	a reference to a <b>BufferedImage</b> object that encapsulates the filtered 
	image.&nbsp; <i>(With this approach, null can be passed as the second parameter 
	to the <b>filter</b> method.)</i></li>
	<li><a name="Provide_a_reference">Provide a reference</a> to a <b>
	BufferedImage</b> object as the second parameter to the <b>filter</b> method.&nbsp; 
	<i>(The 
	method will deposit the filtered image in this <b>BufferedImage</b> object.)</i></li>
</ol>
<p>The simple return <a href="#return_filterObj">statement</a> that I have used 
with the other image-filtering classes of the Java 2D API is based on the
<a href="#Capture_the_return_value">first approach</a> in the above list.</p>
<p>The somewhat more complicated alternative approach that I was forced to 
use in this program is based on the <a href="#Provide_a_reference">second 
approach</a> in the above list.</p>
<p><font color="#FF0000"><b>The
createCompatibleDestImage method</b></font></p>
<p>In summary, this alternative approach invokes the <b>
createCompatibleDestImage</b> method of the <b>AffineTransformOp</b> class to 
create <i>&quot;a zeroed destination image with the correct size and number of 
bands.&quot;</i>&nbsp; A reference to this object is passed as the second parameter 
to the <b>filter</b> method.</p>
<p>The <b>createCompatibleDestImage</b> method requires two parameters:</p>
<ul>
	<li>src</code> - The <b>BufferedImage</b> to be transformed.</li>
	<li>destCM - The<b> ColorModel</b> of the destination image. </li>
</ul>
<p><font color="#FF0000"><b>Explicit control over the color model</b></font></p>
<p>I'm not certain that it was the <b>ColorModel</b> that caused the problem in 
the first place.&nbsp; 
However, as you will see in <a href="#Listing_10">Listing 10</a>, I forced the <b>ColorModel</b> of the 
destination object to match the <b>ColorModel</b> of the image being filtered 
<i>(by invoking the <b>getColorModel</b> method on the image being filtered to 
create the <b>ColorModel</b> for the second parameter to the <b>
createCompatibleDestImage</b> method)</i> and that resolved the problem.</p>
<p><font color="#FF0000"><b>Create the destination object</b></font></p>
<p><a href="#Listing_10">Listing 10</a> creates a destination <b>BufferedImage</b> object that will be 
passed to the <b>filter</b> method to receive the filtered <a name="Listing_10">image</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());<br><br><b><font face="Courier New,Courier"><a href="#Listing_10">Listing 10</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Filter the image and return the filtered image</b></font></p>
<p><a href="#Listing_11">Listing 11</a> invokes the <b>filter</b> method to 
apply the filter to the image and save the filtered image in 
the destination object.&nbsp; Then the code in <a href="#Listing_11">Listing 11</a> returns a reference to the destination 
object.&nbsp; This reference is eventually returned to the framework program named <b>ImgMod05</b>, where the filtered image 
is displayed as shown in <a href="#Figure_5">Figure 5</a> and also written into an output JPEG file 
named <b>junk.<a name="Listing_11">jpg</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    filterObj.filter(theImage, dest);
    
    //Return the destination object's reference.
    return dest;

  }//end processPage00<br><br><b><font face="Courier New,Courier"><a href="#Listing_11">Listing 11</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_11">Listing 11</a> also signals the end of the method named <b>processPage00</b>, and 
the end of the explanation of the scaling transform under the control of 
the <i>Scaling</i> page shown in <a href="#Figure_1">Figure 1</a>.</p>
<h3><a name="Translation">Translation</a></h3>
<p><font color="#FF0000"><b>Construct the Translation page</b></font></p>
<p>
The primary constructor shown in <a href="#Listing_3">Listing 3</a> invokes the method named <b>
constructPage01</b> to construct the <i>Translation</i> page shown in <a href="#Figure_2">Figure 2</a>.&nbsp; The method 
named <b>constructPage01</b> is shown in its entirety in <a name="Listing_12"><a href="#Listing_12">Listing 12</a></a>.<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructPage01(){
    page01.setName("Translation");//Label on the tab.
    page01.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE TRANSLATION\n"
      + "This page illustrates the translation of an "
      + "image to a new location relative to the "
      + "upper-left corner of the container using Bicubic "
      + "Interpolation.\n\n"
      + "Enter the horizontal and vertical translation "
      + "distances in pixels into the text fields and "
      + "click the Replot button.\n\n"
      + "Note that the translation distances must be "
      + "between -1000 and +1000 pixels.  Also note that "
      + "negative translations may shift the image "
      + "completely out of the Frame on the top or the "
      + "left side of the image.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,9,1,
                                 TextArea.SCROLLBARS_NONE);
    page01.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    Panel page01ControlPanel = new Panel();
    page01ControlPanel.setLayout(new GridLayout(3,1));
    
    //Place each label and its corresponding text field
    // on a panel.  Place the panels in the cells in the
    // grid layout from top to bottom.  Note that there
    // is an empty cell at the bottom for cosmetic
    // purposes.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(
                          new FlowLayout(FlowLayout.LEFT));
    subControlPanel00.add(new Label(
             "Horizontal Translation Distance in Pixels"));
    subControlPanel00.add(page01TextFieldHorizontal);
    page01ControlPanel.add(subControlPanel00);
    
    Panel subControlPanel01 = new Panel();
    subControlPanel01.setLayout(
                          new FlowLayout(FlowLayout.LEFT));
    subControlPanel01.add(new Label(
               "Vertical Translation Distance in Pixels"));
    subControlPanel01.add(page01TextFieldVertical);
    page01ControlPanel.add(subControlPanel01);
    
    page01.add(page01ControlPanel,BorderLayout.CENTER);
  }//end constructPage01<br><br><b><font face="Courier New,Courier"><a href="#Listing_12">Listing 12</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you use <a href="#Figure_2">Figure 2</a> as a guide, you should have no problems following the 
code in <a href="#Listing_12">Listing 12</a>.</p>
<p><font color="#FF0000"><b>Processing the image</b></font></p>
<p>The <b>processPage01</b> method is called from within the <b>switch</b> 
statement in 
<a href="#Listing_4">Listing 4</a> to process the image according to the controls 
located on the <i>Translation</i> page shown in <a href="#Figure_2">Figure 2</a>.&nbsp; As before, this 
method uses the <b>AffineTransformOp</b> filter class to process the image.</p>
<p>This method illustrates image translation using independent horizontal and 
vertical distance values.&nbsp; The method uses <i>bicubic</i> Interpolation.</p>
<p><font color="#FF0000"><b>Get translation distances and set the interpolation 
scheme</b></font></p>
<p>The <b>processPage01</b> method begins in <a name="Listing_13"><a href="#Listing_13">Listing 13</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  BufferedImage processPage01(BufferedImage theImage){
    
    double horizontalDistance = 0.0;
    try{//Get horizontalDistance from the text field.
      horizontalDistance = Double.parseDouble(
                      page01TextFieldHorizontal.getText());
    }catch(java.lang.NumberFormatException e){
      page01TextFieldHorizontal.setText("Bad Input");
      horizontalDistance = 0.0; //Override bad user input.
    }//end catch
   
    //Guarantee reasonable values for horizontalDistance
    if((horizontalDistance &lt; -1000.0) || 
                            (horizontalDistance &gt; 1000.0)){
      page01TextFieldHorizontal.setText("Bad Input");
      horizontalDistance = 0.0;//Override bad user input.
    }//end if

    double verticalDistance = 0.0;
    try{//Get verticalDistance from the text field.
      verticalDistance = Double.parseDouble(
                        page01TextFieldVertical.getText());
    }catch(java.lang.NumberFormatException e){
      page01TextFieldHorizontal.setText("Bad Input");
      verticalDistance = 0.0; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for verticalDistance
    if((verticalDistance &lt; -1000.0) || 
                              (verticalDistance &gt; 1000.0)){
      page01TextFieldHorizontal.setText("Bad Input");
      verticalDistance = 0.0;//Override bad user input.
    }//end if
  
    //Set the interpolation scheme to the best available.
    // Note that this page doesn't allow the user to
    // select the interpolation scheme.
    int interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;<br><br><b><font face="Courier New,Courier"><a href="#Listing_13">Listing 13</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first two tasks that must be accomplished by the method are to get the translation distances that were 
entered by the user into the text fields in <a href="#Figure_2">Figure 2</a>, and to set the 
interpolation scheme.&nbsp; This is accomplished by the code in <a href="#Listing_13">Listing 13</a>, 
which is straightforward, and shouldn't require further explanation.</p>
<p><font color="#FF0000"><b>Create the required AffineTransform object</b></font></p>
<p>As explained <a href="#following_three_steps">earlier</a>, the methodology used to process an image using the <b>
AffineTransformOp</b> image-filtering class of the Java 2D API consists of
<a href="#following_three_steps">three steps</a>.</p>
<p>The <a href="#object_of_the_AffineTransform_class">first step</a> is to get 
an object of the <b>AffineTransform</b> class that reflects the type of 
transformation that is required.&nbsp; <i>(See the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/626051">Java 2D 
Graphics, Simple Affine Transforms</a> for more information on the <b>
AffineTransform</b> class.)</i>&nbsp; This step is accomplished by the code in 
<a name="Listing_14"><a href="#Listing_14">Listing 14</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    AffineTransform transformObj = 
                    AffineTransform.getTranslateInstance(
                      horizontalDistance,verticalDistance);<br><br><b><font face="Courier New,Courier"><a href="#Listing_14">Listing 14</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The getTranslateInstance method</b></font></p>
<p><a href="#Listing_14">Listing 14</a> creates an <b>AffineTransform</b> object for translation that 
matches the user input from the control panel shown in <a href="#Figure_2">Figure 2</a>.&nbsp; 
The code in <a href="#Listing_14">Listing 14</a> invokes the static <b>
getTranslateInstance</b> convenience method of the<b> AffineTransform</b> class 
to create the object.<b> </b></p>
<p>Note that even though the actual translation is ultimately performed in terms 
of integer pixels, the <b>getTranslateInstance</b> method of the <b>
AffineTransform</b> class requires the horizontal and vertical translation 
distances to be provided as type <b>double</b>.</p>
<p><font color="#FF0000"><b>What does it mean to translate an image?</b></font></p>
<p>By way of explanation, my earlier article entitled
<a href="http://www.developer.com/java/other/article.php/626051">Java 2D 
Graphics, Simple Affine Transforms</a> has this to say about translation:</p>
<blockquote>
	<p><i>&quot;The purpose of translation is to move the origin of the coordinate system 
in device space.&nbsp; </i></p>
	<p><i>For example, the default position of the origin is the upper left-hand 
corner of the component on which the graphic is being displayed.&nbsp; Assume that 
the component is a <b>Frame</b> object that is four inches on each side.&nbsp; You might 
like for the origin to be in the center of the <b>Frame</b> instead of at the top 
left-hand corner.&nbsp; You could accomplish this by translating the origin by two 
inches in both the horizontal and vertical directions.</i></p>
	<p><i>Or, you might like for the origin to be just barely inside the borders of 
the <b>Frame</b> object instead of outside the borders as is the default.&nbsp; This can be 
accomplished by getting the widths of the top border and left border by invoking
	<b>getInsets</b> on the <b>Frame</b>, and then using those values to translate the 
origin to a location that is just barely inside the borders.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Moving the origin</b></font></p>
<p>Thus, when you translate an image, you are actually moving the origin.&nbsp; 
The pixels, in turn, move along with the origin.&nbsp; A positive horizontal translation 
distance will cause the image to appear to move to the right in its container 
and a negative horizontal distance will cause the image to appear to move to the 
left.&nbsp; Similarly, a positive vertical distance will cause the image to 
appear to move down and a negative vertical distance will cause the image to 
appear to move up.</p>
<p>Understanding this concept of moving the origin will become somewhat more 
important later when I explain the code that produces the mirror image.</p>
<p><font color="#FF0000"><b>Create a filtering object</b></font></p>
<p>The second required step that I described
<a href="#create_an_image-filtering_object">earlier</a> is to use the <b>
AffineTransform</b> object to create an image-filtering object of the class <b>
AffineTransformOp</b> with a specified interpolation scheme.&nbsp; This is 
accomplished in <a href="#Listing_15">Listing 15</a>, which is essentially the same as the code in 
<a name="Listing_15" href="#Listing_9">Listing 
9</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    AffineTransformOp filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);<br><br><b><font face="Courier New,Courier"><a href="#Listing_15">Listing 15</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#ff0000"><b>Filter the image and return the filtered image</b></font></p>
<p>The third required step that I described <a href="#Invoke_the_filter_method">
earlier</a> is to invoke the <b>filter</b> method on the image-filtering object 
to apply the filter to the image.&nbsp; This is accomplished in 
<a name="Listing_16"><a href="#Listing_16">Listing 16</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create a destination object.
    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(theImage, dest);
    
    //Return a reference to the destination object.
    return dest;
  }//end processPage01<br><br><b><font face="Courier New,Courier"><a href="#Listing_16">Listing 16</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_16">Listing 16</a> is essentially the same as the code that I explained 
earlier in <a href="#Listing_10">Listing 10</a> and <a href="#Listing_11">Listing 11</a></p>
<p><a href="#Listing_16">Listing 16</a> also signals the end of the <b>processPage01</b> method, and the 
end of the explanation of the <i>Translation</i> page sown in <a href="#Figure_2">Figure 2</a>.</p>
<h3><a name="Rotation">Rotation</a></h3>
<p><font color="#FF0000"><b>Construct the Rotation page</b></font></p>
<p>The primary constructor shown in <a href="#Listing_3">Listing 3</a> invokes the method named <b>
constructPage02</b> to construct the <i>Rotation</i> page shown in <a href="#Figure_3">Figure 3</a>.&nbsp; 
The method named <b>constructPage02</b> is shown in its entirety in 
<a name="Listing_17"><a href="#Listing_17">Listing 17</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructPage02(){
    page02.setName("Rotation");//Label on the tab.
    page02.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE Rotation\n"
      + "This page illustrates translation of an image "
      + "followed by Rotation of the same image using "
      + "Bicubic Interpolation.\n\n"
      + "The image is rotated around its center after "
      + "being translated to the right and down by a "
      + "distance that is sufficient to give it room to "
      + "rotate.\n\n"
      + "Enter the desired rotation angle in degrees and "
      + "click the Replot button.  Positive rotation "
      + "angles represent clockwise rotation and negative "
      + "rotation angles represent counter-clockwise "
      + "rotation.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,9,1,
                                 TextArea.SCROLLBARS_NONE);
    page02.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    // Use a control panel with a GridLayout for 
    // cosmetic purposes.  Note that there are two empty
    // cells at the bottom of the grid.
    Panel page02ControlPanel = new Panel();
    page02ControlPanel.setLayout(new GridLayout(3,1));
    
    //Place the label and the text field on a panel and
    // place that panel in the top cell in the grid.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    //Note, a positive value in degrees represents
    // clockwise rotation.
    subControlPanel00.add(new Label(
                                   "Rotation in Degrees"));
    subControlPanel00.add(page02TextField);
    page02ControlPanel.add(subControlPanel00);
       
    page02.add(page02ControlPanel,BorderLayout.CENTER);
  }//end constructPage02<br><br><b><font face="Courier New,Courier"><a href="#Listing_17">Listing 17</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>ConstructPage02</b> constructs the <i>Rotation</i> page 
shown in <a href="#Figure_3">Figure 3</a>.&nbsp; If you use <a href="#Figure_3">Figure 3</a> as a guide, you should have no 
problems following the code in <a href="#Listing_17">Listing 17</a>.</p>
<p><font color="#ff0000"><b>Processing the image</b></font></p>
<p>The <b>processPage02</b> method is called from within the <b>switch</b> 
statement in 
<a href="#Listing_4">Listing 4</a> to process the image according to the controls 
located on the <i>Rotation</i> page shown in <a href="#Figure_3">Figure 3</a>.&nbsp; As before, this method 
uses the <b>AffineTransformOp</b> filter class to process the image.</p>
<p>This method illustrates image rotation where the angle of rotation is 
specified by the user in degrees.&nbsp; A positive angle in degrees results in 
clockwise rotation.&nbsp; A negative angle in degrees results in 
counter-clockwise rotation.</p>
<p>The <b>processPage02</b> method uses <i>bicubic</i> Interpolation.</p>
<p><font color="#FF0000"><b>Get the rotation angle in degrees</b></font></p>
<p>The <b>processPage02</b> method begins in <a href="#Listing_18">Listing 18</a>.&nbsp; The code in 
<a href="#Listing_18">Listing 18</a> gets the user input in degrees rotation from the text field in Figure 
3.&nbsp; Then it converts the angle from degrees to <a name="Listing_18">radians</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  BufferedImage processPage02(BufferedImage theImage){
    
    //Get the rotation angle in degrees.  A positive angle
    // in degrees corresponds to clockwise rotation.
    double rotationAngleInDegrees = 0.0;
    try{//Get rotationAngleInDegrees from the text field.
      rotationAngleInDegrees = Double.parseDouble(
                                page02TextField.getText());
    }catch(java.lang.NumberFormatException e){
      page02TextField.setText("Bad Input");
      rotationAngleInDegrees = 0.0;//Override bad input.
    }//end catch
    
    //Compute the rotation angle in radians.
    double rotationAngleInRadians = 
                      rotationAngleInDegrees*Math.PI/180.0;<br><br><b><font face="Courier New,Courier"><a href="#Listing_18">Listing 18</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you use <a href="#Figure_3">Figure 3</a> as a guide, you should have no problems following the 
code in <a href="#Listing_18">Listing 18</a>.</p>
<p><font color="#FF0000"><b>Set the interpolation scheme</b></font></p>
<p><a href="#Listing_19">Listing 19</a> sets the interpolation scheme to <i> <a name="Listing_19">bicubic</a></i>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    int interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;<br><br><b><font face="Courier New,Courier"><a href="#Listing_19">Listing 19</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Translate the image down and to the right</b></font></p>
<p>If the image in the top of <a href="#Figure_8">Figure 8</a> were to be simply rotated about its 
center, the resulting image would be too wide and too tall to fit in the same 
amount of space.&nbsp; Therefore, before rotating the image, this program 
attempts to translate the image down and to the right a sufficient distance to 
allow it to be rotated about its center without chopping of the corners on the 
left side and the top.&nbsp; This is accomplished by estimating the length of 
the image diagonal as the hypotenuse of a right triangle and then using that 
distance to perform the translation.</p>
<p>This translation operation is shown in <a name="Listing_20"><a href="#Listing_20">Listing 20</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Translate the image down and to the right far enough
    // that the corners won't be chopped off by the top and
    // left edges of the container when the image is
    // rotated by 45 degrees.
    
    //Get the length of half the diagonal dimension of the
    // image using the formula for the hypotenuse of a
    // right triangle.
    int halfDiagonal = (int)(Math.sqrt(
         theImage.getWidth()*theImage.getWidth() + 
           theImage.getHeight()*theImage.getHeight())/2.0);
                                 
    //Set the horizontal and vertical translation
    // distances.
    int horizontalDistance = 
                      halfDiagonal - theImage.getWidth()/2;
    int verticalDistance = 
                     halfDiagonal - theImage.getHeight()/2;
    
    //Create an Affine Transform object that can be used
    // to translate the image by the distances computed
    // above.
    AffineTransform transformObj = 
                    AffineTransform.getTranslateInstance(
                      horizontalDistance,verticalDistance);
    
    //Get a translation filter object based on the
    // AffineTransform object.
    AffineTransformOp filterObj = new AffineTransformOp(
              transformObj,AffineTransformOp.TYPE_BICUBIC);
    
    //Perform the translation and save the modified image
    // as type BufferedImage.  This image will be the input
    // to the rotation transform.
    BufferedImage translatedImage = 
                          filterObj.filter(theImage, null);<br><br><b><font face="Courier New,Courier"><a href="#Listing_20">Listing 20</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Since you already understand image translation, further explanation of the 
code in <a href="#Listing_20">Listing 20</a> shouldn't be necessary.</p>
<p><font color="#FF0000"><b>Get the AffineTransform object</b></font></p>
<p><a href="#Listing_21">Listing 21</a> invokes the static <b>getRotateInstance</b> method 
of the <b>AffineTransform</b> class to get an <b>
AffineTransform</b> object suitable for causing the image to be rotated around a 
point that represents the center of the image before it was translated to the 
right and down.&nbsp; <i>(This satisfies the 
<a href="#object_of_the_AffineTransform_class">first step</a> in the earlier list of 
<a name="Listing_21" href="#following_three_steps">three required steps</a>.)</i></p>
<p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    transformObj = AffineTransform.getRotateInstance(
                rotationAngleInRadians,
                horizontalDistance + theImage.getWidth()/2,
                verticalDistance + theImage.getHeight()/2);<br><br><b><font face="Courier New,Courier"><a href="#Listing_21">Listing 21</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The angle in radians</b></font></p>
<p>The first parameter to the <b>getRotateInstance</b> method in <a href="#Listing_21">Listing 21</a> specifies the 
rotation angle in radians <i>(note the conversion from degrees to 
radians in <a href="#Listing_18">Listing 18</a> above)</i>.</p>
<p><font color="#FF0000"><b>The anchor point</b></font></p>
<p>The second and third parameters specify the coordinates of an anchor point around 
which the image is to be rotated.&nbsp; According to Sun, this overloaded 
version of the <b>getRotateInstance</b> method:</p>
<blockquote>
	<p><i>&quot;Returns a transform that rotates coordinates around an anchor point. 
	This operation is equivalent to translating the coordinates so that the 
	anchor point is at the origin (S1), then rotating them about the new origin 
	(S2), and finally translating so that the intermediate origin is restored to 
	the coordinates of the original anchor point (S3).&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Coordinate considerations</b></font></p>
<p>When the original image was translated by the filtering operation in 
<a href="#Listing_20">Listing 
20</a>, and the translated image was returned in an object of type <b>
BufferedImage</b>, the coordinate origin was effectively reset back to the top left corner of the 
new larger image.&nbsp; Because the actual 
picture that constitutes the original image was shifted to the right and down, the 
coordinates of the center of that picture were then greater than was the case 
before the translation took place.&nbsp; The expressions passed as the second 
and third parameters in <a href="#Listing_21">Listing 21</a> specify the new coordinates of the center of 
the picture.</p>
<p><font color="#FF0000"><b>Get a rotation image-filtering object</b></font></p>
<p><a href="#Listing_22">Listing 22</a> gets a rotation filter object based on the transform object and the specified interpolation scheme.&nbsp;
<i>(This satisfies the <a href="#create_an_image-filtering_object">second step</a> in the 
earlier list of <a name="Listing_22" href="#following_three_steps">three required steps</a>.)</i></p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);<br><br><b><font face="Courier New,Courier"><a href="#Listing_22">Listing 22</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that <a href="#Listing_22">Listing 22</a> re-uses the variable named <b>filterObj</b> of type <b>
AffineTransformOp</b> that was declared in <a href="#Listing_20">Listing 20</a> 
and originally used to translate the image down and to the right.</p>
<p><font color="#FF0000"><b>Apply the filter</b></font></p>
<p><a href="#Listing_23">Listing 23</a> satisfies the 
<a href="#Invoke_the_filter_method">third step</a> in 
the earlier list of <a href="#following_three_steps">three required steps</a> by applying the rotation filter to the 
image.&nbsp; <a href="#Listing_23">Listing 23</a> also returns a reference to the 
processed image such that 
it will eventually be displayed by the program named <b>ImgMod05</b>, as shown 
<a name="Listing_23">in</a> <a href="#Figure_8">Figure 8</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    BufferedImage dest = 
               filterObj.createCompatibleDestImage(
                 translatedImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(translatedImage, dest);
    
    //Return a reference to the destination object.
    return dest;  

  }//end processPage02<br><br><b><font face="Courier New,Courier"><a href="#Listing_23">Listing 23</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_23">Listing 23</a> is essentially the same as the code that I explained 
in <a href="#Listing_10">Listing 10</a> and <a href="#Listing_11">Listing 11</a>.</p>
<p><a href="#Listing_23">Listing 23</a> also signals the end of the method named <b>processPage02</b>, and 
the end of the explanation of the processing of the <i>Rotation</i> page shown 
in <a href="#Figure_3">Figure 3</a>.</p>
<h3><a name="Mirror_Image">Mirror Image</a></h3>
<p>The <i>Mirror Image</i> operation consists of the concatenation of a 
translation operation followed by a scaling operation.</p>
<p><font color="#FF0000"><b>What does it really mean to scale an image?</b></font></p>
<p>To understand the process of creating a mirror image, we first need to 
understand what it really means to scale an image.</p>
<p><font color="#FF0000"><b>The representation of an image</b></font></p>
<p>An image consists of a set of red, green, and blue sample values specified at 
a corresponding set of coordinates.&nbsp; You can think of these sample values 
as representing elevation samples taken from a set of three 3D surfaces.&nbsp; 
One surface represents red, one represents green, and the other represents blue.</p>
<p><font color="#FF0000"><b>Stretching or shrinking the surfaces</b></font></p>
<p>When we scale the image, we effectively multiply each of the coordinate 
values by a scale factor without modifying the sample values.&nbsp; This has the 
effect of causing the original sample values to occur at a different set of 
coordinate values, either stretching or shrinking the surfaces that they 
represent.</p>
<p>If the scale factor is greater than 1.0, this stretches the surface causing 
the distance between the sample values to increase.&nbsp; If the scale factor is 
less than 1.0, this causes the surface to shrink and the distance between the 
sample values decreases.</p>
<p><font color="#FF0000"><b>Reconstructing the three surfaces</b></font></p>
<p>For rendering purposes, once we have scaled the image, we need to estimate the elevation values of each 
surface at each pixel location in a uniform grid of pixels.&nbsp; Therefore, the 
new surfaces described by the elevation sample values at the new locations must 
be 
reflected onto the grid that represents the pixels.</p>
<p><font color="#FF0000"><b><a name="interpolation">Interpolation</a></b></font></p>
<p>This is where interpolation comes into play.&nbsp; 
If the new locations of the sample values don't fall exactly on the locations of 
pixels in the grid, those sample values must be used to estimate the elevation 
of the surfaces at the pixel locations.&nbsp; Even if the new locations of the 
sample values do fall on the locations of pixels in the grid, if the surface was 
stretched, then interpolation must be used to estimate the elevation of the 
surface at pixel locations in between the new locations of the sample values.</p>
<p><font color="#FF0000"><b>What if the scale factors are negative?</b></font></p>
<p>An interesting thing happens if, for example, the horizontal scale factor is 
negative.&nbsp; This causes the locations of samples that were originally to the 
right of the origin to be moved to the negative plane on the left of the origin.&nbsp; 
This is essentially the process that is used to create the mirror image shown in 
<a href="#Figure_9">Figure 9</a> under control of the page shown in <a href="#Figure_4">Figure 4</a>.&nbsp; In this case, the 
origin is translated to the right by an amount equal to the width of the 
original image.&nbsp; Then the horizontal coordinate value for each pixel is 
multiplied by -1 causing the locations of all the samples to be moved to the 
left of the new origin.</p>
<p><font color="#FF0000"><b>Construct the Mirror Image page</b></font></p>
<p>The primary constructor shown in <a href="#Listing_3">Listing 3</a> invokes the method named <b>
constructPage03</b> to construct the <i>Mirror Image</i> page shown in 
<a href="#Figure_4">Figure 
4</a>.&nbsp; The method named <b>constructPage03</b> is shown in its entirety in 
<a name="Listing_24"><a href="#Listing_24">Listing 24</a></a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructPage03(){
    page03.setName("Mirror Image");//Label on the tab.
    page03.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    //This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="Mirror Image\n\n"
      + "This page translates the image to the right by "
      + "an amount equal to its width, and then flips it "
      + "around its left edge to produce a mirror image "
      + "of the original image.\n\n"
      + "Click the Replot button to create the mirror "
      + "image.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,6,1,
                                 TextArea.SCROLLBARS_NONE);
    page03.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

  }//end constructPage03<br><br><b><font face="Courier New,Courier"><a href="#Listing_24"><a href="#Listing_24">Listing 24</a></a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#ff0000"><b>The processPage03 method</b></font></p>
<p>When the user selects the <i>Mirror Image</i> tab in <a href="#Figure_4">Figure 4</a> and clicks the
<b>Replot</b> button in <a href="#Figure_9">Figure 9</a>, the <b>switch</b> statement in <a href="#Listing_4">Listing 4</a> 
invokes the method named <b>processPage03</b> to process the image.&nbsp; The <b>
processPage03</b> method begins in <a href="#Listing_25">Listing 25</a>.</p>
<p>Note that unlike <i>Scaling</i>, <i>Translation</i>, and <i>Rotation</i>, there is no affine 
transform for <i>Mirror Image</i>.&nbsp; Rather, as mentioned earlier, this method 
illustrates the use of a horizontal translation followed by scaling with a 
negative scale factor to produce a mirror image of the original 
<a name="Listing_25">image</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  BufferedImage processPage03(BufferedImage theImage){

    AffineTransform transformObj = 
                      AffineTransform.getTranslateInstance(
                                    theImage.getWidth(),0);<br><br><b><font face="Courier New,Courier"><a href="#Listing_25">Listing 25</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_25">Listing 25</a> gets an <b>AffineTransform</b> object that can be used to shift the image to the right by an amount equal to its width.</p>
<p><font color="#FF0000"><b>A transformation matrix</b></font></p>
<p>Although I don't plan to get into the details here, as I explained in the 
earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/626051">Java 2D 
Graphics, Simple Affine Transforms</a>, an <b>AffineTransform</b> is a linear 
transform, so the transformation can be expressed in the matrix notation of 
linear algebra.&nbsp; An arbitrary <b>AffineTransform</b> can be mathematically 
expressed by six numbers in a matrix.</p>
<p><font color="#FF0000"><b>Modification of the transform matrix</b></font></p>
<p>Those six numbers can be manipulated and modified at will in numerous ways 
prior to the actual application of the transform process.&nbsp; One of the most 
interesting aspects of such manipulation is that the matrices for different 
kinds of transforms can be combined through concatenation into a single 
matrix.&nbsp; Then, when the transformation is actually performed using the 
resulting transformation matrix, the result will be as if each of the individual 
transformations had been performed separately and in sequence.</p>
<p><font color="#FF0000"><b>The scale method of the AffineTransform class</b></font></p>
<p>Although it is possible to perform such matrix modifications by working 
directly with the six values in the matrix, for some cases, there is an easier 
way.&nbsp; For example, one of the methods of the <b>AffineTransform</b> class 
is a convenience method named <b>scale</b>.</p>
<p>The <b>scale</b> method concatenates an existing transform matrix with a 
scaling transform matrix, producing a matrix that performs both transforms at 
the same time.</p>
<p><a href="#Listing_26">Listing 26</a> invokes the <b>scale</b> method to concatenate 
the translation matrix created in <a href="#Listing_25">Listing 25</a> with a scaling matrix.&nbsp; In 
this case, the horizontal scale factor is -1.0 and the vertical scale factor is 
1.0.&nbsp; When this transform matrix is applied to an image, it will be 
translated and scaled in a single <a name="Listing_26">operation</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    transformObj.scale(-1.0, 1.0);<br><br><b><font face="Courier New,Courier"><a href="#Listing_26">Listing 26</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display the transform matrix</b></font></p>
<p>For illustration purposes only, <a href="#Listing_27">Listing 27</a> displays the contents of the 
resulting transform <a name="Listing_27">matrix</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Display the six values in the transformation matrix.
    double[] theMatrix = new double[6];
    transformObj.getMatrix(theMatrix);
    
    //Display first row of values by displaying every
    // other element in the array starting with element
    // zero.
    for(int cnt = 0; cnt &lt; 6; cnt+=2){
      System.out.print(theMatrix[cnt] + "\t");
    }//end for loop
    
    //Display second row of values displaying every
    // other element in the array starting with element
    // number one.
    System.out.println();//new line
    for(int cnt = 1; cnt &lt; 6; cnt+=2){
      System.out.print(theMatrix[cnt] + "\t");
    }//end for loop
    System.out.println();//end of line
    System.out.println();//blank line<br><br><b><font face="Courier New,Courier"><a href="#Listing_27">Listing 27</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in listing 27 is not required for the <i>Mirror Image</i> transform to be 
performed.&nbsp; Rather, it is provided to allow you to examine the values in 
the transformation matrix.&nbsp; If you don't care about the mathematics involved, you can 
completely ignore the code in <a href="#Listing_27">Listing 27</a>.</p>
<p><font color="#FF0000"><b>Perform the three required steps</b></font></p>
<p><a href="#Listing_28">Listing 28</a> performs the 
<a href="#following_three_steps">three required steps</a> that were listed earlier, using code that has been 
previously <a name="Listing_28">explained</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Get a translation filter object based on the
    // AffineTransform object.
    AffineTransformOp filterObj = new AffineTransformOp(
              transformObj,AffineTransformOp.TYPE_BICUBIC);

    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(theImage, dest);
    
    //Return a reference to the destination object.
    return dest;

  }//end processPage03<br><br><b><font face="Courier New,Courier"><a href="#Listing_28">Listing 28</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p><a href="#Listing_28">Listing 28</a> also signals the end of the method named <b>processPage03</b>, and 
the end of the explanation of the <i>Mirror Image</i> transform that produces 
results similar to those shown in <a href="#Figure_9">Figure 9</a> under control of the page shown in 
<a href="#Figure_4">Figure 4</a>.</p>
<p>Finally, <a href="#Listing_28">Listing 28</a> also signals the end of the explanation of the program 
named <b>ImgMod40</b>.<br>
</p>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code from <a href="#Listing_29">Listing 29</a> into your text editor, 
compile it, and execute it.&nbsp; Experiment with it, making changes, and observing 
the results of your changes.</p>
<p>Remember, you will also need to compile the code for the framework program 
named <b>ImgMod05</b> and the interface named <b>ImgIntfc05</b>.&nbsp; You will 
find that source code in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3645761">A Framework for 
Experimenting with Java 2D Image-Processing Filters</a>.</p>
<p>You will also need one or more JPEG image files to experiment with.&nbsp; You 
should have no difficulty finding such files at a variety of locations on the 
web.&nbsp; I recommend that you stick with relatively small images so that both the 
original image and the processed image will fit in the vertical space on your 
screen in the format shown in <a href="#Figure_8">Figure 8</a>.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I provided and explained an image-processing program named <b>
ImgMod40</b> that is compatible with the framework program named <b>ImgMod05</b>.</p>
<p>The purpose of this program is to show you how to write such programs, and also 
to illustrate a variety of different uses for the <b>AffineTransformOp</b> class 
of the Java 2D API.</p>
<p>Four specific uses of the <b>AffineTransformOp</b> class 
were illustrated, and you should be able to devise many more.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons in this series will teach you how to use the following 
image-filtering classes from the Java 2D API:</p>
<ul>
	<li><b>BandCombineOp</b> </li>
	<li><b>ConvolveOp</b> </li>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b> </li>
</ul>
<h2 align="center"><a name="References">References</a></h2>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight</li>
	<li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</li>
	<li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion</li>
	<li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java</li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1</li>
	<li><a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2</li>
	<li><a href="http://www.developer.com/java/other/article.php/3640776">416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3645761">450</a> A Framework for Experimenting with Java 2D Image-Processing 
	Filters</li>
	<li><a href="http://www.developer.com/java/other/article.php/3654171">452</a> Using the Java 2D LookupOp Filter Class to Process Images</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listing</h2>
</center>
A complete listing of the program discussed in this lesson is shown in Listing 
29 <a name="Listing_29">below</a>. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod40.java
Copyright 2006, R.G.Baldwin

The purpose of this class is to illustrate a variety of 
different uses for the AffineTransformOp filter class of 
the Java 2D API.

See general comments in the class named ImgMod038.

This class is compatible with the use of the driver program
named ImgMod05.

The driver program named ImgMod05 displays the original and
the modified images.  It also writes the modified image 
into an output file in JPEG format.  The name of the output
file is junk.jpg and it is written into the current 
directory.

Image-processing programs such as this one may provide a 
GUI for data input making it possible for the user to 
modify the behavior of the image-processing method each 
time the Replot button is clicked.  Such a GUI is provided
for this program.

Enter the following at the command line to run this 
program:

java ImgMod05 ImgMod40 ImageFileName

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

This program creates a GUI consisting of a tabbed pane 
containing four pages.  The tabs on the pages are labeled:

Scaling
Translation
Rotation
Mirror Image

Each page contains a set of controls that makes it possible
to process the image in a way that illustrates the 
processing concept indicated by the label on the tab.
Processing details for each page are provided in the 
comments in the code used to construct and process the 
individual pages.

Tested using J2SE 5.0 under WinXP.
**********************************************************/

import java.awt.image.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.geom.AffineTransform;

class ImgMod40 extends Frame implements ImgIntfc05{
  //Primary container used to construct the GUI.
  JTabbedPane tabbedPane = new JTabbedPane();
  
  //Components used to construct the Scaling page.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel page00 = new Panel();
  TextField page00TextFieldHorizontal = 
                                    new TextField("0.5",6);
  TextField page00TextFieldVertical = 
                                    new TextField("0.5",6);
  //Components for radio buttons
  CheckboxGroup Page00Group = new CheckboxGroup();
  Checkbox page00NearestNeighbor = new Checkbox(
       "Nearest Neighbor Interpolation",Page00Group,false);
  Checkbox page00Bilinear = new Checkbox(
               "Bilinear Interpolation",Page00Group,false);
  Checkbox page00Bicubic = new Checkbox(
                 "Bicubic Interpolation",Page00Group,true);
  
  //Components used to construct the Translation page.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel page01 = new Panel();
  TextField page01TextFieldHorizontal = 
                                      new TextField("5",6);
  TextField page01TextFieldVertical = 
                                     new TextField("10",6);

  //Components used to construct the Rotation page.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel page02 = new Panel();
  TextField page02TextField = new TextField("45.0",6);
  
  //Components used to construct the Mirror Image page.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel page03 = new Panel();
  
  //-----------------------------------------------------//
  
  //This is the primary constructor.  It calls other
  // methods to separate the construction of the GUI into
  // easily understandable units.  Each method that it
  // calls constructs one page in the tabbed pane.
  ImgMod40(){//constructor
  
    constructPage00();
    tabbedPane.add(page00);//Add page to the tabbedPane.
    
    constructPage01();
    tabbedPane.add(page01);//Add page to the tabbedPane.
    
    constructPage02();
    tabbedPane.add(page02);//Add page to the tabbedPane.
    
    constructPage03();
    tabbedPane.add(page03);//Add page to the tabbedPane.
    
    add(tabbedPane);//Add tabbedPane to the Frame.

    setTitle("Copyright 2006, R.G.Baldwin");
    setBounds(555,0,470,300);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor
  //-----------------------------------------------------//
  
  //This method constructs the Scaling page.
  // This method is called from the primary constructor.
  void constructPage00(){
    page00.setName("Scaling");//Label on the tab.
    page00.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE SCALING\n"
      + "This page illustrates the scaling of an image "
      + "using three different types of interpolation."
      + "\n\n"
      + "Enter a positive scale factor between 0.001 and "
      + "10.0 in each of the text fields, select an "
      + "interpolation type, and click the Replot button. "
      + "The best quality interpolation will probably be "
      + "achieved with the use of Bicubic Interpolation. "
      + "Nearest Neighbor Interpolation will probably "
      + "produce the poorest quality.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,7,1,
                                 TextArea.SCROLLBARS_NONE);
    page00.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    Panel page00ControlPanel = new Panel();
    page00ControlPanel.setLayout(new GridLayout(5,1));
    
    //Construct and populate the panels that contain the
    // radio buttons, the labels, and the text fields.
    // Add each such panel an a new cell in the grid
    // layout going from the top of the grid to the bottom
    // of the grid.
    
    //Begin with the radio buttons.  The purpose of putting
    // the radio buttons on panels is to cause them to be
    // left justified in their cells.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel00.add(page00NearestNeighbor);
    page00ControlPanel.add(subControlPanel00);
    
    Panel subControlPanel01 = new Panel();
    subControlPanel01.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel01.add(page00Bilinear);
    page00ControlPanel.add(subControlPanel01);
    
    Panel subControlPanel02 = new Panel();
    subControlPanel02.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel02.add(page00Bicubic);
    page00ControlPanel.add(subControlPanel02);
    
    //Now create and populate panels that contain labels
    // and associated TextField objects
    Panel subControlPanel03 = new Panel();
    subControlPanel03.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel03.add(new Label(
                               "Horizontal Scale Factor"));
    subControlPanel03.add(page00TextFieldHorizontal);
    page00ControlPanel.add(subControlPanel03);
    
    Panel subControlPanel04 = new Panel();
    subControlPanel04.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    subControlPanel04.add(new Label(
                                 "Vertical Scale Factor"));
    subControlPanel04.add(page00TextFieldVertical);
    page00ControlPanel.add(subControlPanel04);
    
    page00.add(page00ControlPanel,BorderLayout.CENTER);
  }//end constructPage00
  //-----------------------------------------------------//

  //This method processes the image according to the
  // controls located on the Scaling page.
  //This method uses the AffineTransformOp filter class to
  // process the image.
  //The method is called from within the switch statement
  // in the method named processImg, which is the primary
  // image-processing method in this program.
  //This method illustrates image scaling, giving the user
  // a choice of three different interpolation schemes.
  //See the earlier lesson at
  // http://www.developer.com/java/other/article.php
  // /626051
  // for additional information on the use of a scaling
  // affine transform.
  BufferedImage processPage00(BufferedImage theImage){
    
    //Set a non-zero default value for the horizontal scale
    // factor.
    double horizontalScale = 0.001;
    try{//Get horizontalScale from the text field.
      horizontalScale = Double.parseDouble(
                      page00TextFieldHorizontal.getText());
    }catch(java.lang.NumberFormatException e){
      page00TextFieldHorizontal.setText("Bad Input");
      horizontalScale = 0.001; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for horizontal scale
    if((horizontalScale &lt; 0.001) || 
                                 (horizontalScale &gt; 10.0)){
      page00TextFieldHorizontal.setText("Bad Input");
      horizontalScale = 0.001;//Override bad user input.
    }//end if
  
    //Set a non-zero default value for the vertical scale
    // factor.
    double verticalScale = 0.001;
    try{//Get verticalScale from the text field.
      verticalScale = Double.parseDouble(
                        page00TextFieldVertical.getText());
    }catch(java.lang.NumberFormatException e){
      page00TextFieldHorizontal.setText("Bad Input");
      verticalScale = 0.001; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for verticalScale
    if((verticalScale &lt; 0.001) || (verticalScale &gt; 10.0)){
      page00TextFieldHorizontal.setText("Bad Input");
      verticalScale = 0.001;//Override bad user input.
    }//end if
    
    //Get the selected interpolation scheme from the radio
    // buttons and reflect that selection in an int value
    // corresponding to the selected button.
    int interpolationScheme;
    if(page00Bicubic.getState() == true){
      interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;
    }else if(page00Bilinear.getState() == true){
      interpolationScheme = 
                           AffineTransformOp.TYPE_BILINEAR;
    }else{//page00NearestNeighbor must be selected
      interpolationScheme = 
                   AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
    }//end else
    
    //An AffineTransform object is required later to create
    // the filter object.  An examination of the
    // documentation for the AffineTransform class will
    // show that there are several different ways to create
    // such an object.  The following statement is probably
    // the simplest of those ways.
    //Create an AffineTransform object for scaling that
    // matches the user input from the control panel.
    AffineTransform transformObj = 
                         AffineTransform.getScaleInstance(
                            horizontalScale,verticalScale);
    
    //At this point, you could use the methods of the
    // AffineTransform class to get, modify, and restore
    // the transform matrix in order to modify the
    // behavior of the transformation process.  See the
    // earlier lesson at
    // http://www.developer.com/java/other/article.php
    // /626051
    // for additional information on this topic.
        
    //Use the AffineTransform object to create a filtering
    // object.
    AffineTransformOp filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);

    /*Note:  Normally, I would perform the filtering 
     *operation and return the filtered result simply by 
     *executing the following statement:
    
     *  return filterObj.filter(theImage, null);
      
     *However, for reasons that I am unable to explain, 
     *when I do that for the AffineTransformOp class, the
     *ColorModel of the BufferedImage object that is 
     *returned to the framework program named ImgMod05 is
     *not compatible with the method used by that program 
     *to write the output JPEG file.  This results in an 
     *output file in which the image data appears to be 
     *scrambled.  Therefore, it was necessary for me to
     *use the following alternative code instead.*/
    
    //Create a destination BufferedImage object to receive
    // the filtered image.  Force the ColorModel of the
    // destination object to match the ColorModel of the
    // incoming object.
    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(theImage, dest);
    
    //Return a reference to the destination object.
    return dest;

  }//end processPage00
  //-----------------------------------------------------//
  
  //This method constructs the Translation page.
  //The method is called from the primary constructor.
  void constructPage01(){
    page01.setName("Translation");//Label on the tab.
    page01.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE TRANSLATION\n"
      + "This page illustrates the translation of an "
      + "image to a new location relative to the "
      + "upper-left corner of the container using Bicubic "
      + "Interpolation.\n\n"
      + "Enter the horizontal and vertical translation "
      + "distances in pixels into the text fields and "
      + "click the Replot button.\n\n"
      + "Note that the translation distances must be "
      + "between -1000 and +1000 pixels.  Also note that "
      + "negative translations may shift the image "
      + "completely out of the Frame on the top or the "
      + "left side of the image.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,9,1,
                                 TextArea.SCROLLBARS_NONE);
    page01.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    Panel page01ControlPanel = new Panel();
    page01ControlPanel.setLayout(new GridLayout(3,1));
    
    //Place each label and its corresponding text field
    // on a panel.  Place the panels in the cells in the
    // grid layout from top to bottom.  Note that there
    // is an empty cell at the bottom for cosmetic
    // purposes.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(
                          new FlowLayout(FlowLayout.LEFT));
    subControlPanel00.add(new Label(
             "Horizontal Translation Distance in Pixels"));
    subControlPanel00.add(page01TextFieldHorizontal);
    page01ControlPanel.add(subControlPanel00);
    
    Panel subControlPanel01 = new Panel();
    subControlPanel01.setLayout(
                          new FlowLayout(FlowLayout.LEFT));
    subControlPanel01.add(new Label(
               "Vertical Translation Distance in Pixels"));
    subControlPanel01.add(page01TextFieldVertical);
    page01ControlPanel.add(subControlPanel01);
    
    page01.add(page01ControlPanel,BorderLayout.CENTER);
  }//end constructPage01
  //-----------------------------------------------------//

  //This method processes the image according to the
  // controls located on the Translation page.
  //This method uses the AffineTransformOp filter class
  // to process the image.  The method is called from
  // within the switch statement in the method
  // named processImg, which is the primary image
  // processing method in this program.
  //This method illustrates image translation using Bicubic
  // Interpolation.
  BufferedImage processPage01(BufferedImage theImage){
    
    double horizontalDistance = 0.0;
    try{//Get horizontalDistance from the text field.
      horizontalDistance = Double.parseDouble(
                      page01TextFieldHorizontal.getText());
    }catch(java.lang.NumberFormatException e){
      page01TextFieldHorizontal.setText("Bad Input");
      horizontalDistance = 0.0; //Override bad user input.
    }//end catch
   
    //Guarantee reasonable values for horizontalDistance
    if((horizontalDistance &lt; -1000.0) || 
                            (horizontalDistance &gt; 1000.0)){
      page01TextFieldHorizontal.setText("Bad Input");
      horizontalDistance = 0.0;//Override bad user input.
    }//end if

    double verticalDistance = 0.0;
    try{//Get verticalDistance from the text field.
      verticalDistance = Double.parseDouble(
                        page01TextFieldVertical.getText());
    }catch(java.lang.NumberFormatException e){
      page01TextFieldHorizontal.setText("Bad Input");
      verticalDistance = 0.0; //Override bad user input.
    }//end catch
    
    //Guarantee reasonable values for verticalDistance
    if((verticalDistance &lt; -1000.0) || 
                              (verticalDistance &gt; 1000.0)){
      page01TextFieldHorizontal.setText("Bad Input");
      verticalDistance = 0.0;//Override bad user input.
    }//end if
  
    //Set the interpolation scheme to the best available.
    // Note that this page doesn't allow the user to
    // select the interpolation scheme.
    int interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;

    //Create an AffineTransform object for translation that
    // matches the user input from the control panel.
    //Note that even though the actual translation is
    // performed in terms of integer pixels, the 
    // getTranslateInstance method requires the horizontal
    // and vertical distances to be provided as type
    // double.  A positive horizontal distance will cause
    // the image to appear to move to the right in its
    // container and a negative horizontal distance will
    // cause the image to appear to move to the left.
    // Similarly, a positive vertical distance will cause
    // the image to appear to move down and a negative
    // vertical distance will cause the image to appear to
    // move up.
    AffineTransform transformObj = 
                    AffineTransform.getTranslateInstance(
                      horizontalDistance,verticalDistance);
        
    //Use the AffineTransform object to create a filtering
    // object.
    AffineTransformOp filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);
    
    /*Note:  Normally, I would perform the filtering 
     *operation and return the filtered result simply by 
     *executing the following statement:
    
     *  return filterObj.filter(theImage, null);
      
     *However, for reasons that I am unable to explain, 
     *when I do that for the AffineTransformOp class, the
     *ColorModel of the BufferedImage object that is 
     *returned to the framework program named ImgMod05 is
     *not compatible with the method used by that program 
     *to write the output JPEG file.  This results in an 
     *output file in which the image data appears to be 
     *scrambled.  Therefore, it was necessary for me to
     *use the following alternative code instead.*/
    
    //Create a destination BufferedImage object to receive
    // the filtered image.  Force the ColorModel of the
    // destination object to match the ColorModel of the
    // incoming object.
    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(theImage, dest);
    
    //Return a reference to the destination object.
    return dest;

  }//end processPage01
  //-----------------------------------------------------//
  
  //This method constructs the Rotation page.
  //This method is called from the primary constructor. 
  // It illustrates the translation of an image followed by
  // rotation of the translated image.
  void constructPage02(){
    page02.setName("Rotation");//Label on the tab.
    page02.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    // This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="IMAGE Rotation\n"
      + "This page illustrates translation of an image "
      + "followed by Rotation of the same image using "
      + "Bicubic Interpolation.\n\n"
      + "The image is rotated around its center after "
      + "being translated to the right and down by a "
      + "distance that is sufficient to give it room to "
      + "rotate.\n\n"
      + "Enter the desired rotation angle in degrees and "
      + "click the Replot button.  Positive rotation "
      + "angles represent clockwise rotation and negative "
      + "rotation angles represent counter-clockwise "
      + "rotation.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,9,1,
                                 TextArea.SCROLLBARS_NONE);
    page02.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

    //Construct the control panel and add it to the page.
    // Use a control panel with a GridLayout for 
    // cosmetic purposes.  Note that there are two empty
    // cells at the bottom of the grid.
    Panel page02ControlPanel = new Panel();
    page02ControlPanel.setLayout(new GridLayout(3,1));
    
    //Place the label and the text field on a panel and
    // place that panel in the top cell in the grid.
    Panel subControlPanel00 = new Panel();
    subControlPanel00.setLayout(new FlowLayout(
                                         FlowLayout.LEFT));
    //Note, a positive value in degrees represents
    // clockwise rotation.
    subControlPanel00.add(new Label(
                                   "Rotation in Degrees"));
    subControlPanel00.add(page02TextField);
    page02ControlPanel.add(subControlPanel00);
       
    page02.add(page02ControlPanel,BorderLayout.CENTER);
  }//end constructPage02
  //-----------------------------------------------------//

  //This method processes the image according to the
  // controls located on the Rotation page.
  //This method uses the AffineTransformOp filter class
  // to process the image.  The method is called from
  // within the switch statement in the method named
  // processImg, which is the primary image-processing
  // method in this program.
  //This method illustrates image Translation followed by 
  //image Rotation using Bicubic Interpolation.
  BufferedImage processPage02(BufferedImage theImage){
    
    //Get the rotation angle in degrees.  A positive angle
    // in degrees corresponds to clockwise rotation.
    double rotationAngleInDegrees = 0.0;
    try{//Get rotationAngleInDegrees from the text field.
      rotationAngleInDegrees = Double.parseDouble(
                                page02TextField.getText());
    }catch(java.lang.NumberFormatException e){
      page02TextField.setText("Bad Input");
      rotationAngleInDegrees = 0.0;//Override bad input.
    }//end catch
    
    //Compute the rotation angle in radians.
    double rotationAngleInRadians = 
                      rotationAngleInDegrees*Math.PI/180.0;
  
    //Set the interpolation scheme.
    int interpolationScheme = 
                            AffineTransformOp.TYPE_BICUBIC;
    
    //Translate the image down and to the right far enough
    // that the corners won't be chopped off by the top and
    // left edges of the container when the image is
    // rotated by 45 degrees.
    
    //Get the length of half the diagonal dimension of the
    // image using the formula for the hypotenuse of a
    // right triangle.
    int halfDiagonal = (int)(Math.sqrt(
         theImage.getWidth()*theImage.getWidth() + 
           theImage.getHeight()*theImage.getHeight())/2.0);
                                 
    //Set the horizontal and vertical translation
    // distances.
    int horizontalDistance = 
                      halfDiagonal - theImage.getWidth()/2;
    int verticalDistance = 
                     halfDiagonal - theImage.getHeight()/2;
    
    //Create an Affine Transform object that can be used
    // to translate the image by the distances computed
    // above.
    AffineTransform transformObj = 
                    AffineTransform.getTranslateInstance(
                      horizontalDistance,verticalDistance);
    
    //Get a translation filter object based on the
    // AffineTransform object.
    AffineTransformOp filterObj = new AffineTransformOp(
              transformObj,AffineTransformOp.TYPE_BICUBIC);
    
    //Perform the translation and save the modified image
    // as type BufferedImage.  This image will be the input
    // to the rotation transform.
    BufferedImage translatedImage = 
                          filterObj.filter(theImage, null);
    
    //Now rotate the image around a point that is at the
    // center of the original image.  Begin by getting a
    // rotation transform object.  The second and third
    // parameters specify the point about which the image
    // will be rotated.
    transformObj = AffineTransform.getRotateInstance(
                rotationAngleInRadians,
                horizontalDistance + theImage.getWidth()/2,
                verticalDistance + theImage.getHeight()/2);
                  
    //Now get a rotation filter object based on the
    // transform object and the specified interpolation
    // scheme.
    filterObj = new AffineTransformOp(
                         transformObj,interpolationScheme);

    /*Note:  Normally, I would perform the filtering 
     *operation and return the filtered result simply by 
     *executing the following statement:
    
     *  return filterObj.filter(translatedImage, null);
      
     *However, for reasons that I am unable to explain, 
     *when I do that for the AffineTransformOp class, the
     *ColorModel of the BufferedImage object that is 
     *returned to the framework program named ImgMod05 is
     *not compatible with the method used by that program 
     *to write the output JPEG file.  This results in an 
     *output file in which the image data appears to be 
     *scrambled.  Therefore, it was necessary for me to
     *use the following alternative code instead.*/
    
    //Create a destination BufferedImage object to receive
    // the filtered image.  Force the ColorModel of the
    // destination object to match the ColorModel of the
    // incoming object.
    BufferedImage dest = 
               filterObj.createCompatibleDestImage(
                 translatedImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(translatedImage, dest);
    
    //Return a reference to the destination object.
    return dest;  

  }//end processPage02
  //-----------------------------------------------------//
  
  //This method constructs the Mirror Image page.
  //This method is called from the primary constructor.
  void constructPage03(){
    page03.setName("Mirror Image");//Label on the tab.
    page03.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the page.
    //This text appears in a disabled text area at the
    // top of the page in the tabbed pane.
    String text ="Mirror Image\n\n"
      + "This page translates the image to the right by "
      + "an amount equal to its width, and then flips it "
      + "around its left edge to produce a mirror image "
      + "of the original image.\n\n"
      + "Click the Replot button to create the mirror "
      + "image.";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.
    TextArea textArea = new TextArea(text,6,1,
                                 TextArea.SCROLLBARS_NONE);
    page03.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);

  }//end constructPage03
  //-----------------------------------------------------//

  //This method processes the image according to the
  // Mirror Image page.
  //This method uses the AffineTransformOp filter class to
  // process the image.  The method is called from within
  // the switch statement in the method named processImg,
  // which is the primary image processing method in this
  // program.
  //Note that unlike Scaling, Translation, and Rotation, 
  // there is no affine transform for Mirror Image. Rather,
  // this method illustrates the use of horizontal
  // translation followed by scaling with negative scale
  // factors to produce a mirror image of the original
  // image.
  BufferedImage processPage03(BufferedImage theImage){

    //Get an AffineTransform object that can be used to
    // shift the image to the right by an amount equal to
    // its width.
    AffineTransform transformObj = 
                      AffineTransform.getTranslateInstance(
                                    theImage.getWidth(),0);
    
    //Concatenate this transform with a scaling
    // transformation.
    transformObj.scale(-1.0, 1.0);
    
    //Display the six values in the transformation matrix.
    double[] theMatrix = new double[6];
    transformObj.getMatrix(theMatrix);
    
    //Display first row of values by displaying every
    // other element in the array starting with element
    // zero.
    for(int cnt = 0; cnt &lt; 6; cnt+=2){
      System.out.print(theMatrix[cnt] + "\t");
    }//end for loop
    
    //Display second row of values displaying every
    // other element in the array starting with element
    // number one.
    System.out.println();//new line
    for(int cnt = 1; cnt &lt; 6; cnt+=2){
      System.out.print(theMatrix[cnt] + "\t");
    }//end for loop
    System.out.println();//end of line
    System.out.println();//blank line

    //Get a translation filter object based on the
    // AffineTransform object.
    AffineTransformOp filterObj = new AffineTransformOp(
              transformObj,AffineTransformOp.TYPE_BICUBIC);
    
    /*Note:  Normally, I would perform the filtering 
     *operation and return the filtered result simply by 
     *executing the following statement:
    
     *  return filterObj.filter(theImage, null);
      
     *However, for reasons that I am unable to explain, 
     *when I do that for the AffineTransformOp class, the
     *ColorModel of the BufferedImage object that is 
     *returned to the framework program named ImgMod05 is
     *not compatible with the method used by that program 
     *to write the output JPEG file.  This results in an 
     *output file in which the image data appears to be 
     *scrambled.  Therefore, it was necessary for me to
     *use the following alternative code instead.*/
    
    //Create a destination BufferedImage object to receive
    // the filtered image.  Force the ColorModel of the
    // destination object to match the ColorModel of the
    // incoming object.
    BufferedImage dest = 
                      filterObj.createCompatibleDestImage(
                        theImage,theImage.getColorModel());
    
    //Filter the image and save the filtered image in the
    // destination object.
    filterObj.filter(theImage, dest);
    
    //Return a reference to the destination object.
    return dest;

  }//end processPage03
  //-----------------------------------------------------//

  //The following method must be defined to implement the
  // ImgIntfc05 interface.  It is called by the framework
  // program named ImgMod05.
  public BufferedImage processImg(BufferedImage theImage){
    
    BufferedImage outputImage = null;
    
    //Process the page in the tabbed pane that has been
    // selected by the user.
    switch(tabbedPane.getSelectedIndex()){
      case 0:outputImage = processPage00(theImage);
             break;
      case 1:outputImage = processPage01(theImage);
             break;
      case 2:outputImage = processPage02(theImage);
             break;
      case 3:outputImage = processPage03(theImage);
             break;
    }//end switch

    return outputImage;
  }//end processImg
}//end class ImgMod40
<br><br><b><font face="Courier New,Courier"><a href="#Listing_29">Listing 29</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p> </p>
<hr align="center" size="3" width="100%">
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java 2D image pixel framework filter&nbsp;AffineTransform AffineTransformOp</p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
