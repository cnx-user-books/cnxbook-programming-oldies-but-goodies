<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Network Programming - Sockets<!--endtitle--></b></h2></center>
Java Programming, Lesson # 560, Revised 02/20/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#echo program">Echo Program</a></li>

<ul><li><a href="#code fragments from the echo program">Code Fragments from the
Echo Program</a></li>

<li><a href="#program listing for the echo program">Program Listing for the
Echo Program</a></li></ul>

<li><a href="#date/time program">Date/Time Program</a></li>

<ul><li><a href="#code fragments from date/time program">Code Fragments from Date/Time
Program</a></li>

<li><a href="#program listing from date/time program">Program Listing for Date/Time
Program</a></li></ul>

<li><a href="#simple browser program">Simple Browser Program</a></li>

<ul><li><a href="#code fragments from the browser program">Code Fragments from
the Browser Program</a></li>

<li><a href="#program listing for browser program">Program Listing for Browser
Program</a></li></ul>

<li><a href="#e-mail program">E-Mail Program</a></li>

<ul><li><a href="#code fragments for e-mail program">Code Fragments from E-Mail
Program</a></li>

<li><a href="#program listing for e-mail program">Program Listing for E-Mail
Program</a></li></ul>

<li><a href="#summary">Summary</a></li></ul>

<hr width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b><u>Advanced Java Programming</u></b> classes
at ACC are responsible for knowing and understanding all of the material
in this lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
Sockets come in three varieties which are implemented by the Java classes
named <b>Socket</b>, <b>DatagramSocket</b>, and <b>ServerSocket</b>. The
first two socket classes represent <b>TCP</b> and <b>UDP</b> communications
respectively.

<p>Generally, the two socket classes are used to implement both clients
and servers , while the <b>ServerSocket</b> class is only used to implement
servers. We will see numerous examples of socket programming in this and
subsequent lessons.

<p>This lesson will concentrate on the use of the <b>Socket</b> class.
The other two classes will be covered in subsequent lessons.

<p>Socket programming provides a low-level mechanism by which you can connect
two computers for the exchange of data. One of those is generally considered
to be the <i>client </i>while the other is considered to be the <i>server</i>.

<p>The <i>client </i>initiates a connection with a <i>server.</i> <i>Servers</i>
wait for a <i>clients</i> to initiate connections.

<p>The governing protocol will determine what happens after the connection
is made. In order for two computers to communicate effectively, they must
each implement some mutually acceptable application protocol

<p>Socket programming makes it possible for you to cause data to flow in
a full-duplex mode between a <i>client </i>and a <i>server</i>. This data
flow can be viewed in almost exactly the same way that we view data flow
to and from a disk: <u>as a stream of bytes</u>.

<p>As with most stream data processing, the system is responsible for moving
the bytes from the source to the destination. It is the responsibility
of the programmer to assign meaning to those bytes.

<p>Assigning meaning takes on a special significance for socket programming.
In particular, as mentioned above, it is the responsibility of the programmer
to implement a mutually acceptable communication protocol, at the application
level, to cause the data to flow in an orderly manner. Some of the bytes
are used to implement the protocol, and some of the bytes are used to transfer
data.

<p>An application protocol is a set of rules by which the programs in the
two computers can carry on a conversation and transfer data in the process.

<p>For example, we will write a program using the SMTP mail protocol to
send an email message to someone. We will also write a program that implements
a very abbreviated form of the HTTP protocol to download web pages from
a server and to display them.

<p>Each of these programs will involve adherence to a fairly simple protocol
(at least the part that we implement will be simple).

<p>We will also write a program that obtains the date and time from another
computer. In this case, the protocol is about as simple as it can possibly
be. In this case, the client will simply make the connection and listen
for a string containing the date and time. In this case, the client isn't
even required to make a request.

<p>It is easy to use sockets to write code that will cause a stream of
bytes to flow in both directions between a <i>client </i>and a <i>server</i>.
This is no more difficult than causing a stream of bytes to flow in both
directions between memory and a file on a disk.

<p>Getting the bytes to flow is the easy part. Beyond that, you must do
all of the programming to implement an application protocol that is understood
by both the <i>client </i>and the <i>server</i>. Often that is the more
difficult part.
<center><h2><a name="echo program"></a><font color="#ff0000">Echo Program</font></h2></center>
This program implements a <i>client </i>that performs a simple echo test
with a <i>server </i>by sending a line of text to the <i>echo port</i>
which is port 7 on the <i>server</i>.

<p>You must be logged onto an appropriate network for this program to run
properly. However, it is possible that the network can exist completely
within a single computer under some operating systems. (We will learn to
cause a single computer to simulate a network under Win95 later.) Otherwise,
the program will throw an exception of type <b>UnknownHostException</b>.

<p>The program begins by instantiating a <b>String </b>object containing
the name of an echo server that is being used to test the program.

<p>This is followed by the declaration and initialization of an <b>int
</b>variable containing the standard echo port number. The standard echo
port is port 7.

<p>Than the program gets a socket connection to port 7 on the server.

<p>Following this, the program gets input and output streams from the socket
and wraps them in the new Reader and Writer classes. You may want to pay
particular attention to this, because as of this writing in January of
1998, it is difficult to find written material that explains how to use
the Reader and Writer classes in conjunction with socket programming.

<p>Once the connection is made and the input and output streams are ready
to use, the program sends a line of text to the echo port on the specified
server.

<p>This causes the server to send the same line of text back to the client.

<p>The program reads the line of text that is received and displays it.

<p>Finally, the program closes the socket and terminates.

<p>This program was tested using JDK 1.1.3 under Win95.

<p>Assuming that you select a server that supports echo processing on port
7, the output from this program should be:

<p><b>This is an echo test</b>

<p>If you select a server that does not support echo processing on port
7, your output will be different. For example, I tried to run this program
on the server identified as "www.whitehouse.net" and the response was something
like "connection refused."

<p>This is an interesting result because, as we will see later, that <i>URL
</i>does support the <i>daytime</i> port on port 13 that delivers the date
and time.
<center><h3><a name="code fragments from the echo program"></a><font color="#ff0000">Code
Fragments from the Echo Program</font></h3></center>
This program is used to create a <i>client</i> that communicates with a
<i>server</i> for purposes of performing an <i>echo test</i>.

<p>We will begin with the first few lines in the <b>main()</b> method of
the controlling class where we declare two local variables that you will
need to recognize later.

<p>These variables are used later to specify the <i>server </i>and the
<i>port </i>on the server that we are connecting to.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; String server = "<b>www2.austin.cc.tx.us</b>";
&nbsp;&nbsp;&nbsp; int port = <b>7</b>; //echo port</pre></td></tr></table>
Much of this program is wrapped in a try/catch block that I am going to
ignore as I highlight these code fragments. You can see the try/catch activity
in context in the complete listing of the program that appears later in
the lesson.

<p>The next code fragment <u>is the the key statement</u> in this program
insofar as learning new material is concerned.

<p>This statement establishes a connection with the specified port on the
specified server by instantiating a new object of type <b>Socket</b>.

<p>Once this object exists, it is possible to use it to communicate with
the server on the specified port using the protocol prescribed for the
service being delivered on that port.

<p>The constructor for this class throws two different types of exceptions
so you will need to wrap this statement in a try/catch block. The two types
of exceptions are: <b>UnknownHostException </b>and <b>IOException.</b><br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket socket = <b>new Socket(server,port)</b>;</pre></td></tr></table>
Once you have a <b>Socket</b> object, you can use that object to open input
and output streams that allow you to transfer data between the client and
the server.

<p>The only thing remarkable about this code is the fact that it uses the
Reader and Writer capabilities of JDK 1.1. Most of the books that I have
read are still using deprecated methods from JDK 1.0 in their sample programs
for socket programming.

<p>Of the many books that I reviewed on this topic, the only one that I
found that had upgraded to the Reader and Writer classes was <u>Java, How
to Program, Second Edition</u>, by Deitel and Deitel.

<p>I find the proper use of the I/O stream library to be one of the most
difficult, confusing, and tedious aspect of Java programming, and it became
even more difficult with the advent of the new classes in JDK 1.1. I was
thankful to find information in the Deitel book about how to use these
new classes to properly construct the streams needed for socket programming.

<p>Note that the <b>true</b> parameter in the last line will cause the
output stream to flush automatically. Proper flushing is an important aspect
of socket programming.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>//Get an input stream from the socket
BufferedReader inputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new InputStreamReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b> socket.getInputStream()</b>));

//Get&nbsp; an output stream to the socket.&nbsp; Note
// that this stream will autoflush.
PrintWriter outputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; new PrintWriter(new OutputStreamWriter(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>socket.getOutputStream()</b>),<b>true</b>);</pre></td></tr></table>
The next code fragment uses the <b>outputStream</b> created above to send
a line of text to the server, and then uses the <b>inputStream</b> created
above to capture and display the echo that is returned from the server.

<p>After we we display the echo, we close the socket.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>outputStream.println</b>("This is an echo test");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<b>inputStream.readLine()</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.<b>close()</b>;</pre></td></tr></table>
Finally, we implement some catch blocks to deal with the different types
of exceptions that can be thrown in the previous code. You can see the
catch blocks in the complete program listing in the next section.

<p><u>That's really about all there is to socket programming from the <i>client</i>
viewpoint</u>.

<p>Beyond this, the programming complexity associated with socket programming
is the result of the requirement to implement an application protocol that
will successfully communicate with the server.
<center><h3><a name="program listing for the echo program"></a><font color="#ff0000">Program
Listing for the Echo Program</font></h3></center>
You may find it helpful to take a look at the following listing of the
program to see the above code fragments in context.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Sockets03.java Copyright 1998, R.G.Baldwin
Revised 01/20/98

This program performs a simple echo test with a server
by sending a line of text to the echo port, port 7.

You must be logged onto an appropriate network for this
program to run properly.&nbsp; Otherwise, it will throw
an exception of type UnknownHostException.

Most of the program is enclosed in a try/catch block to
deal with possible exceptions.

The program begins by instantiating a String object
containing the name of an echo server that you are
using to test the program.

This is followed by declaration and initialization of
an int variable containing the standard echo port number.
The standard echo port is number 7.

Than the program gets a socket connection to port 7
on the echo server.

Then the program gets input and output streams from the
socket and wraps them in the new reader classes.

Once the input and output streams are ready to use, the
sends a line of text to the echo port on the server.

The echo server sends the same line of text back to
the client.

Then the program reads the line of text that is&nbsp;
received and displays it.

Then the program closes the socket and terminates.

This program was tested using JDK 1.1.3 under Win95.

The output from this program is:
&nbsp;&nbsp;
This is an echo test
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets03{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; String server = "www2.austin.cc.tx.us";
&nbsp;&nbsp;&nbsp; int port = 7; //echo port
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a socket, connected to the specified server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the specified port.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket socket = new Socket(server,port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get an input stream from the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new InputStreamReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getInputStream()));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get&nbsp; an output stream to the socket.&nbsp; Note
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that this stream will autoflush.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintWriter outputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PrintWriter(new OutputStreamWriter(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getOutputStream()),true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Send line of text to the server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println("This is an echo test");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get echoed line back from server and display it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Close the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.close();
&nbsp;&nbsp;&nbsp; }//end try
&nbsp;&nbsp;&nbsp; catch(UnknownHostException e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Must be online to run properly.");
&nbsp;&nbsp;&nbsp; }//end catch UnknownHostException
&nbsp;&nbsp;&nbsp; catch(IOException e){System.out.println(e);}
&nbsp; }//end main
}//end class Sockets03
//=======================================================//</pre></td></tr></table>

<center><h2><a name="date/time program"></a><font color="#ff0000">Date/Time Program</font></h2></center>
This program implements a <i>client</i> that gets the date and time from
the <i>daytime</i> port on a server that supports that port.

<p>This program is even simpler than the previous one, because it isn't
necessary to send anything to the server to get the desired result. All
that is necessary to cause the server to send the desired information is
to make the connection.

<p>This program gets and displays the date and time on the server at "<b>www.whitehouse.net</b>".

<p>It also displays the current date and time in Austin, TX (or wherever
the program happens to be run) for comparison.

<p>You must be logged onto an appropriate network for this program to run
properly. Otherwise, it will throw an exception of type <b>UnknownHostException</b>.

<p>The program begins by instantiating a <b>String </b>object containing
the name of the server being used to test the program.

<p>This is followed by the declaration and initialization of an <b>int
</b>variable identifying the standard <i>daytime </i>port. The standard
<i>daytime </i>port is port 13.

<p>Than the program gets a socket connection to port 13 on the specified
server.

<p>Following this, the program gets an input stream from the socket and
wraps it in the new reader classes.

<p>This program doesn't't need an output stream because the client doesn't
send anything to the server. Simply connecting is sufficient to trigger
the server to send the date and time.

<p>After the connection is made via the socket and the input stream is
ready to use, the client reads a line of incoming text. This line of text
contains the date and time sent by the server.

<p>The program displays this line of text, and also gets and displays the
date and time on the local system using the <b>Date </b>class for comparison.

<p>Then the program closes the socket and terminates.

<p>This program was tested using JDK 1.1.3 under Win95.

<p>The output from this program for one particular run was:
<br>&nbsp;
<table border bgcolor="#00ffff" ><tr><td><pre>Got socket&nbsp;
Current time at www.whitehouse.net: Wed <b>Jan 21</b> 00:31:13 1998&nbsp;
Current time in Austin, TX: Tue <b>Jan 20</b> 23:31:18 CST 1998&nbsp;</pre></td></tr></table>
This is an interesting output because it was run near midnight and the
difference in time zones caused the date to be different in Austin, TX
and in the Eastern Time Zone.

<p>Note also that there was a five-second difference in the two clocks
with the server clock appearing to be slow relative to the client clock.

<p>Prior to running this test, I synchronized the clock in my computer
with a Naval Observatory time standard in Washington, D.C. I don't know
how much of the five second difference was attributable to transmission
time of the data from the server to the client, and how much was due to
the fact that one or the other of the clocks wasn't exactly correct.
<center><h3><a name="code fragments from date/time program"></a><font color="#ff0000">Code
Fragments from Date/Time Program</font></h3></center>
There isn't any code in this program that differs in any significant way
from the previous program, other than the <b>System.out.println()</b> statements
that display the date and time. You have seen hundreds of statement like
those statements.

<p>Therefore, I won't bore you with highlighted code fragments from this
program.
<center><h3><a name="program listing from date/time program"></a><font color="#ff0000">Program
Listing for Date/Time Program</font></h3></center>
A complete listing of this program follows.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Sockets04.java Copyright 1998, R.G.Baldwin
Revised 01/20/98

This program gets and displays the date and time on the
server at "www.whitehouse.net".

It also displays the current date and time in Austin,
TX, or wherever the program happens to be run.

You must be logged onto an appropriate network for this
program to run properly.&nbsp; Otherwise, it will throw
an exception of type UnknownHostException.

Most of the program is enclosed in a try/catch block to
deal with possible exceptions.

The program begins by instantiating a String object
containing the name of the server being used to
test the program.

This is followed by declaration and initialization of
an int variable containing the standard daytime port.
The standard daytime port is number 13.

Than the program gets a socket connection to port 13
on the daytime server.

Then the program gets an input stream from the socket
and wraps it in the new reader classes.

Once the input stream is ready to use, the client
reads a line of incoming text.&nbsp; This is the
date and time sent by the server.

Then the program displays this line of text, and also
gets and displays the date and time on the local system
using the Date class.

Then the program closes the socket and terminates.

This program was tested using JDK 1.1.3 under Win95.

The output from this program was:

Got socket
Current time at www.whitehouse.net:
Wed Jan 21 00:31:13 1998
Current time in Austin, TX:
Tue Jan 20 23:31:18 CST 1998&nbsp;&nbsp;
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets04{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; String server = "www.whitehouse.net";
&nbsp;&nbsp;&nbsp; int port = 13; //daytime port
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a socket, connected to the specified server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the specified port.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket socket = new Socket(server,port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Got socket");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get an input stream from the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new InputStreamReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getInputStream()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Current time at www.whitehouse.net:");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Current time in Austin, TX:");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(new Date());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Close the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.close();
&nbsp;&nbsp;&nbsp; }//end try
&nbsp;&nbsp;&nbsp; catch(UnknownHostException e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Must be online to run properly.");
&nbsp;&nbsp;&nbsp; }//end catch UnknownHostException
&nbsp;&nbsp;&nbsp; catch(IOException e){System.out.println(e);}
&nbsp; }//end main
}//end class Sockets04
//=======================================================//</pre></td></tr></table>

<center><h2><a name="simple browser program"></a><font color="#ff0000">Simple Browser
Program</font></h2></center>
The next program is an extremely simple web browser program. More correctly,
the next program is a simple HTTP client (web browser) implemented using
sockets.

<p>The program implements just enough of the HTTP protocol to make it capable
of getting an HTML page (or any other type of file for that matter) from
an HTTP server. Considerably more programming effort would be required
to turn it into a useful browser, but such programming should be within
the reach of the persons enrolled in Prof. Baldwin's Advanced Java Programming
course at ACC

<p>You must be logged onto an appropriate network for this program to run
properly. Otherwise, it will throw an exception of type <b>UnknownHostException</b>.

<p>The program begins by defining the name of a server and the number of
the HTTP port on that server. The standard port number for HTTP servers
is port 80.

<p>Then the program opens a socket to the specified server on the specified
port.

<p>As in the previous programs, this program creates input and output stream
objects for transferring data between the <i>client</i> and the <i>server</i>.

<p>As mentioned earlier, the output stream will <i>autoflush</i>, which
is critical. If the output stream isn't flushed, the server will not respond
properly (presumably it may not receive all of the data until the stream
is flushed).

<p>Then the program, acting as an HTTP client, sends a <b>GET </b>command
to the server specifying a particular path and file name. The <b>GET</b>
command is part of the HTTP application protocol.

<p>This causes the server to attempt to fetch the specified file and send
it to the client. If the server is being properly supported on the specific
port, it will send something, although that something could be an error
message.

<p>The program reads lines of text from the input stream and displays them
on the standard output device. Note that even though this may be HTML data,
it is displayed as ordinary text. Therefore, if it is HTML, you will see
it in raw form including all of the HTML tags.

<p>When there are no more lines to be read, a null is received. This causes
the client to exit the input loop and to close the socket.

<p>This program was tested using JDK 1.1.3 under Win95.

<p>As of 01/20/98, the output from this program was as follows. This is
a text representation of an HTML file named Test01.html. Note that the
contents of this test file on the server may change over time, so you may
not see exactly the same result if you compile and run this program.
<br>&nbsp;
<table border bgcolor="#00ffff" ><tr><td><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
&lt;HTML>
&lt;HEAD><u>Note that some lines of text were deleted
in the interest of brevity</u>.

&lt;P>This test file is used to test certain&nbsp;
network programming applications.&lt;/P>

&lt;/BODY>
&lt;/HTML></pre></td></tr></table>

<center><h3><a name="code fragments from the browser program"></a><font color="#ff0000">Code
Fragments from the Browser Program</font></h3></center>
This program begins much like the two previous programs by getting a socket
connection on port 80 of the specified server.

<p>Following this, it instantiates stream objects for input and output
using the new Reader and Writer classes. I won't highlight that code here,
because it is essentially the same as what you saw in the first program
in this lesson.

<p>The HTTP protocol provides several different commands or requests that
the client can send to the server. This program implements <u>only</u>
the <b>GET</b> command. This is a request by the client to find and download
a specified file.

<p>The statement used by the <i>client</i> to request the file named <b>Test01.html</b>
from the <i>server</i> is shown below.

<p>Note that the request includes not only the file name, but also the
path to that file relative to the directory that the HTTP server software
considers to be the <i>pseudo-root</i>. This is probably not the actual
root directory on the server computer, but rather is a logical root.

<p>The server software is willing to access and deliver files from directories
relative to this <i>pseudo-root</i>.

<p>Note that the request is actually made by printing a line of text on
the stream that is connected to the server.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(<b>"GET /baldwin/Test01.html"</b>);</pre></td></tr></table>
At this point, if the <b>GET</b> message is properly sent, it is probably
safe to assume that some text will be sent back by the server, although
it may consist of an error message.

<p>The next fragment reads that text from the input stream, displays it
on the standard output device, and closes the socket when there is no more
data to be extracted from the input stream.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String line = null;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>while</b>((line = inputStream.<b>readLine()</b>) != <b>null</b>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(line);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.<b>close</b>();</pre></td></tr></table>
This is followed by the usual exception handling code.

<p>An interesting exercise for the student would be to improve this program
to give it additional browser characteristics.

<p>For example, you could review the specifications for HTML and write
a display method that would display the data in the style normally associated
with HTML pages.

<p>You could wrap the entire program in a Graphical User Interface with
a <b>TextArea</b> for display and a <b>TextField</b> for specifying the
<i>URL</i>.

<p>You could review the HTTP specifications and implement additional client
requests for the HTTP protocol.

<p>Or, you could start with this program and write a "web crawler" program
that would begin at some specified <i>URL</i>, downloading files and following
links until you either terminate the program after reaching some depth
level on links, or fill up your disk with downloaded files.

<p>A safer program for starters would be a web crawler that follows links
but doesn't actually save the files that it downloads. It would download
each file, parse it to extract the links, and then discard everything but
the links.
<center><h3><a name="program listing for browser program"></a><font color="#ff0000">Program
Listing for the Browser Program</font></h3></center>
A complete program listing of this program follows.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Sockets01.java Copyright 1998, R.G.Baldwin
Revised 01/20/98

This program is a simple http client (web browser)
implemented using sockets.

The program implements just enough of the http protocol
to make it capable of getting an html page from an
http server.

You must be logged onto an appropriate network for this
program to run properly.&nbsp; Otherwise, it will throw
an exception of type UnknownHostException.

Most of the program is enclosed in a try/catch block to
deal with possible exceptions.

The program begins by defining the name of a server and
the number of the http port on that server.&nbsp; The standard
port number for http servers is 80.

Then the program opens a socket to the specified server
on the specified port.

Then it uses the new BufferedReader class along with the
new InputStreamReader class to open an input stream from
the socket.&nbsp; These classes are wrapped around an input
stream provided by the Socket class.

Then it uses the new PrintWriter class along with the
new OutputStreamWriter class to open an output stream to
the socket.&nbsp; These classes are also wrapped around an&nbsp;
output stream provided by the Socket class.

The output stream will autoflush, which is critical.&nbsp; If
the output stream isn't flushed, the server will not
respond (presumably it doesn't receive all of the&nbsp;
output data until the stream is flushed).

Then the program, acting as an http client, sends a GET
command to the server specifying a particular path and&nbsp;
file name.

This causes the server to attempt to fetch the specified&nbsp;
file and send it to the client.

Then the program reads lines from the input stream and&nbsp;
displays them on the standard output device.

When there are no more lines to be read, a null is&nbsp;
received.&nbsp; This causes the client to exit the input
loop and to close the socket.

This program was tested using JDK 1.1.3 under Win95.

As of 01/20/98, the output from this program was as&nbsp;
follows.&nbsp; This is a text representation of an html file
named Test01.html. Note that the contents of this test&nbsp;
file on the server may change over time, so you may not
see exactly the same result when you compile and run
this program.

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
&lt;HTML>
&lt;HEAD>
&nbsp;&nbsp; &lt;TITLE>&lt;/TITLE>
&nbsp;&nbsp; &lt;META NAME="Author" CONTENT="">
&nbsp;&nbsp; &lt;META NAME="GENERATOR" CONTENT=
"Mozilla/3.01Gold (Win95; I) [Netscape]">
&lt;/HEAD>
&lt;BODY>

&lt;P>&lt;B>&lt;I>Richard G Baldwin (512) 223-4758,&nbsp;
&lt;A HREF="mailto:baldwin@austin.cc.tx.us">
baldwin@austin.cc.tx.us&lt;/A>,
&lt;A HREF="http://www2.austin.cc.tx.us/baldwin/">
http://www2.austin.cc.tx.us/baldwin/&lt;/A>&lt;/I>&lt;/B>&lt;/P>

&lt;H3 ALIGN=CENTER>
&lt;A HREF="http://www2.austin.cc.tx.us/baldwin/">
Test File&lt;/A>&lt;/H3>

&lt;P>This test file is used to test certain&nbsp;
network programming applications.&lt;/P>

&lt;/BODY>
&lt;/HTML>
**********************************************************/

import java.net.*;
import java.io.*;

class Sockets01{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; String server = "www2.austin.cc.tx.us";//server name
&nbsp;&nbsp;&nbsp; int port = 80; //http port
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a socket, connected to the specified server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the specified port.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket socket = new Socket(server,port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get an input stream from the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new InputStreamReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getInputStream()));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get&nbsp; an output stream to the socket.&nbsp; Note
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that this stream will autoflush.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintWriter outputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PrintWriter(new OutputStreamWriter(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getOutputStream()),true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Send a GET command to the server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println("GET /baldwin/Test01.html");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Declare a String to read lines into.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String line = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Loop reading and displaying lines until null&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is received.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((line = inputStream.readLine()) != null)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(line);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Close the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.close();
&nbsp;&nbsp;&nbsp; }//end try
&nbsp;&nbsp;&nbsp; catch(UnknownHostException e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Must be online to run properly.");
&nbsp;&nbsp;&nbsp; }//end catch UnknownHostException
&nbsp;&nbsp;&nbsp; catch(IOException e){System.out.println(e);}
&nbsp; }//end main
}//end class Sockets01
//=======================================================//</pre></td></tr></table>

<center><h2><a name="e-mail program"></a><font color="#ff0000">E-Mail Program</font></h2></center>
As of January 1998, the <b>SMTP </b>protocol for sending email messages
can be found at http://www.gssnet.com/rfc/rfc821a.htm

<p>This sample program is a simple <b>SMTP</b> client implemented using
sockets.

<p>The program implements enough of the <b>SMTP </b>protocol to make it
capable of sending an email message to someone if you know their email
name and the identity of their <b>SMTP</b> server.

<p>You must be logged onto an appropriate network for this program to run
properly. Otherwise, it will throw an exception of type <b>UnknownHostException</b>.

<p>The program begins by instantiating a <b>String </b>object containing
the name of an <b>SMTP</b> server. Although I tested this program using
my <b>SMTP</b> server, I removed the name of my server from the program
to avoid getting lots of test messages from other people who might be testing
this program. It should be easy enough for you to obtain the identify of
your own <b>SMTP</b> server and to test the program by sending messages
to yourself.

<p>You should cause the <b>String </b>object mentioned above to contain
the name of your email server or the email server that you are using to
test the program.

<p>Instantiation of the <b>String</b> containing the name of the <b>SMTP</b>
server is followed by declaration and initialization of an <b>int </b>variable
identifying the port number for the standard <b>SMTP </b>mail service.
The standard <b>SMTP </b>port is port 25.

<p>The program gets a socket connection to port 25 on the <b>SMTP</b> server.

<p>Then the program gets input and output streams from the socket as in
the previous programs.

<p>Once the connection is made and the input and output streams are ready
to use, the program begins the conversation with the email server by implementing
an abbreviated version of the <b>SMTP </b>protocol.

<p>The <b>SMTP</b> protocol consists of transmitting a series of simple
lines of text to the server and listening for lines of text being returned.
In this program, the text that is received by the client is displayed on
the standard output device, and is shown below.

<p>After the test message has been sent, the program closes the socket
and terminates.

<p>This program was tested using JDK 1.1.3 under Win95.

<p>As of 01/20/98, the output from this program (with line breaks manually
inserted) was as follows.
<br>&nbsp;
<table border bgcolor="#00ffff" ><tr><td><pre>220 monk.austin.cc.tx.us ESMTP&nbsp;
&nbsp; Sendmail 8.8.5/8.6.9 ready at&nbsp;
&nbsp; Tue, 20 Jan 1998 22:16:37 -0600
250 baldwin... Sender ok
250 baldwin... Recipient ok
354 Enter mail, end with "." on a line by itself</pre></td></tr></table>

<center><h3><a name="code fragments for e-mail program"></a><font color="#ff0000">Code
Fragments from E-Mail Program</font></h3></center>
The program begins by establishing the name of the <b>SMTP </b>server and
the standard port on which that is service is normally supported. As indicated
above, you should insert the name of your server in place of the highlighted
string below.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; String server = "<b>put your email server name here</b>";
&nbsp;&nbsp;&nbsp; int port = 25; //mail port</pre></td></tr></table>
After this, we get a socket, get an input stream, and get an output stream
just like in the previous programs. I will skip over that code in this
section because you have seen it before.

<p>The purpose of this program is to send an email message to someone,
so at this point, we begin the conversation with the mail server by sending
a line of text in the following format. This line of text identifies the
sender of the message. Then we read and display a line.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Begin the conversation with the email server.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "mail from: <b>put your email name here</b>");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());</pre></td></tr></table>
Next we send a line of text to the server identifying the recipient of
the message. Again, we read and display a line of text sent by the server.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "rcpt to: " + "<b>put your email name here</b>");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());</pre></td></tr></table>
All of this is assuming that everything works as expected.

<p>If we were really serious about writing a program that could handle
this protocol, we would need to examine the text coming from the server
to confirm that everything is working as expected, and take corrective
action if it isn't. This would require considerably more study of the protocol
specification than I have done at this point in time.

<p>Next, we send the string <b>"data"</b>, and as usual, we read and display
a line of text from the server.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println("data");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());</pre></td></tr></table>
Following this, we construct and send the actual message followed by a
period on a line by itself. Then we read and display a line of text, and
close the socket.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String timeStamp = (new Date()).toString();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(<b>"Test message " + timeStamp</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(<b>"."</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.<b>readLine</b>());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.<b>close</b>();</pre></td></tr></table>
After closing the socket, we deal with the normal collection of exception
handlers.

<p>As indicated above, using this protocol would have involved considerably
more code if we had been careful to adhere to the specification exactly,
and had examined each of the messages received from the server to confirm
that everything was going OK.
<center><h3><a name="program listing for e-mail program"></a><font color="#ff0000">Program
Listing for E-Mail Program</font></h3></center>
A complete listing of the program follows.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Sockets02.java Copyright 1998, R.G.Baldwin
Revised 01/20/98

This program is a simple SMTP (email) client implemented
using sockets.

The program implements enough of the SMTP protocol
to make it capable of sending an email message to
someone at an SMTP server.

You must be logged onto an appropriate network for this
program to run properly.&nbsp; Otherwise, it will throw
an exception of type UnknownHostException.

Most of the program is enclosed in a try/catch block to
deal with possible exceptions.

The program begins by instantiating a String object
containing the name of an email server.&nbsp; Although I
tested this program using my server, I removed the
name of my server to avoid getting hundreds of test
messages from people around the world testing this&nbsp;
program.

You should cause the String object to contain the name
of your email server or the email server that you are
using to test the program.

This is followed by declaration and initialization of
an int variable containing the port number for the&nbsp;
standard SMTP mail service.&nbsp; The standard SMTP port
is number 25.

Than the program gets a socket connection to port 25
on the email server.

Then the program gets input and output streams from the
socket and wraps them in the new reader classes.

Once the input and output streams are ready to use, the
program begins the conversation with the email server
following the SMTP protocol.

This consists of transmitting a series of simple lines
of text to the server and listening for lines of text
being returned.&nbsp; The text that is received by the client
is displayed on the standard output device, and is&nbsp;
shown below.

After the test message has been sent, the program
closes the socket and terminates.

This program was tested using JDK 1.1.3 under Win95.

As of 01/20/98, the output from this program (with line
breaks manually inserted) was as follows.&nbsp;&nbsp;

220 monk.austin.cc.tx.us ESMTP&nbsp;
&nbsp; Sendmail 8.8.5/8.6.9 ready at&nbsp;
&nbsp; Tue, 20 Jan 1998 22:16:37 -0600
250 baldwin... Sender ok
250 baldwin... Recipient ok
354 Enter mail, end with "." on a line by itself
**********************************************************/

import java.net.*;
import java.io.*;
import java.util.*;

class Sockets02{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; String server = "put your email server name here";

&nbsp;&nbsp;&nbsp; int port = 25; //mail port
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get a socket, connected to the specified server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the specified port.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket socket = new Socket(server,port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get an input stream from the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new InputStreamReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getInputStream()));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get&nbsp; an output stream to the socket.&nbsp; Note
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that this stream will autoflush.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintWriter outputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PrintWriter(new OutputStreamWriter(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.getOutputStream()),true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Begin the conversation with the email server.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "mail from: put your email name here");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "rcpt to: " + "put your email name here");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println("data");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String timeStamp = (new Date()).toString();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println("Test message " + timeStamp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputStream.println(".");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(inputStream.readLine());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Close the socket
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket.close();
&nbsp;&nbsp;&nbsp; }//end try
&nbsp;&nbsp;&nbsp; catch(UnknownHostException e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Must be online to run properly.");
&nbsp;&nbsp;&nbsp; }//end catch UnknownHostException
&nbsp;&nbsp;&nbsp; catch(IOException e){System.out.println(e);}
&nbsp; }//end main
}//end class Sockets02
//=======================================================//</pre></td></tr></table>

<center><h2><a name="summary"></a><font color="#ff0000">Summary</font></h2></center>
Once you learn how to instantiate <b>Socket</b> objects and how to deal
with the input and output streams, writing <i>client</i> software using
sockets in Java is easy.

<p>The real complexity, to the extent that there may complexity, is wrapped
up in understanding and implementing the various protocols required by
the servers for the different services that are offered.

<p>-end-<!--end--></body></html>