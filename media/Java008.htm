<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Differences between Java and C++ by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Similarities and Differences between Java and C++<!--endtitle--></H2>
<P ALIGN="CENTER">Java Programming, Lecture Notes # 8, Originally published in 
1997.&nbsp; Revised 10/03/99. </P>
<P><!-toc file=Java008a.htm words=Preface-><A HREF="#preface">Preface</A><BR>
<!--endtoc--><!-toc file=Java008b.htm words=Introduction-><A HREF="#introduction">Introduction</A><BR>
<!--endtoc--><!-toc file=Java008c.htm words=An Initial Word about Java and C++-><A HREF="#a word about c++ and java">An Initial Word about Java and C++</A><BR>
<!--endtoc--><!-toc file=Java008d.htm words=Similarities and Differences-><A HREF="#major differences">Similarities and Differences</A><!--endtoc--> </P>
<P><!-next=Java008a.htm><!-first=Java008.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>By the end of the course, students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of persons who are already familiar with C++ and who are making the transition into Java. </P>
<P>This lesson is designed primarily as a reading assignment. It is not likely that Prof. Baldwin will spend any class time discussing the material in this lesson. However, he will respond to specific questions from students regarding the material in this lesson as long as those questions pertain to Java and not to C++. </P>
<P>This lesson is intended to be general in nature. Therefore, no effort has been expended to keep it in compliance with any particular version of the Java JDK. </P>
<P><!-prev=Java008.htm-><!-next=Java008b.htm><!-first=Java008.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><P>This lesson introduces you to Java programming by presenting some of the similarities and differences between Java and C++. </P>
<P><!-prev=Java008a.htm-><!-next=Java008c.htm><!-first=Java008.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="a_word_about_c___and_java"></A>An Initial Word about Java and C++</H2>
</FONT><P>Please see the material in the Preface, which discusses the relationship between Java and C++ insofar as this course of study is concerned. In general, students in Prof. Baldwin's Java classes are not required to have any knowledge of C++. </P>
<P><!-prev=Java008b.htm-><!-next=Java008d.htm><!-first=Java008.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="major_differences"></A>Similarities and Differences</H2>
</FONT><P>This list of similarities and differences is based heavily on <U>The Java Language Environment, A White Paper</U> by James Gosling and Henry McGilton http://java.sun.com/doc/language_environment/ and the soon-to-be published book, <U>Thinking in Java</U> by Bruce Eckel, http://www.EckelObjects.com/. At least these were the correct URLs at one point in time. Be aware, however, that the web is a dynamic environment and the URLs may change in the future. </P>
<P>Java does not support <B>typedefs</B>, <B>defines</B>, or a <B>preprocessor</B>. Without a preprocessor, there are no provisions for <I>including</I> <B>header files</B>. </P>
<P>Since Java does not have a preprocessor there is no concept of <I>#define macros </I>or <I>manifest constants</I>. However, the declaration of <I>named constants </I>is supported in Java through use of the <B>final</B> keyword. </P>
<P>Java does not support <B>enums </B>but, as mentioned above, does support <I>named constants</I>. </P>
<P>Java supports <B>classes</B>, but does not support <B>structures</B> or <B>unions</B>. </P>
<P>All stand-alone C++ programs require a function named <B>main</B> and can have numerous other functions, including both <U>stand-alone functions</U> and functions, which are <U>members of a class</U>. There are <U>no stand-alone functions in Java</U>. Instead, there are only functions that are members of a class, usually called <B>methods</B>. Global functions and global data are not allowed in Java. </P>
<P>All classes in Java ultimately inherit from the <B>Object</B> class. This is significantly different from C++ where it is possible to create inheritance trees that are completely unrelated to one another. </P>
<P>All function or method definitions in Java are contained within the class definition. To a C++ programmer, they may look like <B>inline</B> function definitions, but they aren't. Java doesn't allow the programmer to request that a function be made <B>inline</B>, at least not directly. </P>
<P>Both C++ and Java support <B><I>class</B></I> (static) methods or functions that can be called without the requirement to instantiate an object of the class. </P>
<P>The <B>interface</B> keyword in Java is used to create the equivalence of an abstract base class containing only method declarations and constants. No variable data members or method definitions are allowed. (True abstract base classes can also be created in Java.) The <I>interface</I> concept is <U>not supported by C++</U>. </P>
<P>Java does not support <B>multiple inheritance</B>. To some extent, the <I>interface</I> feature provides the desirable features of multiple inheritance to a Java program without some of the underlying problems. </P>
<P>While Java does not support multiple inheritance, single inheritance in Java is similar to C++, but the manner in which you implement inheritance differs significantly, especially with respect to the use of constructors in the inheritance chain. </P>
<P>In addition to the access specifiers applied to individual members of a class, C++ allows you to provide an additional access specifier when inheriting from a class. This latter concept is not supported by Java. </P>
<P>Java does not support the <B>goto</B> statement (but <B>goto</B> is a reserved word). However, it does support labeled <B>break</B> and <B>continue</B> statements, a feature <U>not supported by C++</U>. In certain restricted situations, labeled <B>break</B> and <B>continue</B> statements can be used where a <B>goto</B> statement might otherwise be used. </P>
<P>Java does not support <B>operator overloading</B>. </P>
<P>Java does not support <B>automatic type conversions (</B>except where guaranteed safe). </P>
<P>Unlike C++, Java has a <B>String</B> type, and objects of this type are immutable (cannot be modified). Quoted strings are automatically converted into <B>String</B> objects. Java also has a <B>StringBuffer</B> type. Objects of this type can be modified, and a variety of string manipulation methods are provided. </P>
<P>Unlike C++, Java provides true arrays as first-class objects. There is a <B>length</B> member, which tells you how big the array is. An exception is thrown if you attempt to access an array out of bounds. All arrays are instantiated in dynamic memory and assignment of one array to another is allowed. However, when you make such an assignment, you simply have two references to the same array.  Changing the value of an element in the array using one of the references changes the value insofar as both references are concerned. </P>
<P>Unlike C++, having two "pointers" or references to the same object in dynamic memory is not necessarily a problem (but it can result in somewhat confusing results). In Java, dynamic memory is reclaimed automatically, but is not reclaimed until all references to that memory become NULL or cease to exist. Therefore, unlike in C++, the allocated dynamic memory cannot become invalid for as long as it is being referenced by any reference variable. </P>
<P>Java does not support <B>pointers </B>(at least it does not allow you to modify the address contained in a pointer or to perform pointer arithmetic). Much of the need for pointers was eliminated by providing types for arrays and strings. For example, the oft-used C++ declaration <B><TT>char* ptr</B></TT> needed to point to the first character in a C++ null-terminated "string" is not required in Java, because a string is a true object in Java. </P>
<P>A class definition in Java looks similar to a class definition in C++, but there is <U>no closing semicolon</U>. Also forward reference declarations that are sometimes required in C++ are not required in Java. </P>
<P>The scope resolution operator (<B>::</B>) required in C++ is not used in Java. The dot is used to construct all fully-qualified references. Also, since there are no pointers, the pointer operator (<B>-&gt;</B>) used in C++ is not required in Java. </P>
<P>In C++, <B>static</B> data members and functions are called using the name of the class and the name of the static member connected by the scope resolution operator. In Java, the dot is used for this purpose. </P>
<P>Like C++, Java has primitive types such as <B>int, float, </B>etc. Unlike C++, the size of each primitive type is the same regardless of the platform. There is no unsigned integer type in Java. Type checking and type requirements are much tighter in Java than in C++. </P>
<P>Unlike C++, Java provides a true <B>boolean</B> type. </P>
<P>Conditional expressions in Java must evaluate to <B>boolean </B>rather than to integer, as is the case in C++. Statements such as <B><TT>if(x+y)...</B></TT> are not allowed in Java because the conditional expression doesn't evaluate to a <B>boolean</B>. </P>
<P>The <B>char</B> type in C++ is an 8-bit type that maps to the ASCII (or extended ASCII) character set. The <B>char</B> type in Java is a 16-bit type and uses the Unicode character set (the Unicode values from 0 through 127 match the ASCII character set). For information on the Unicode character set see http://www.stonehand.com/unicode.html. </P>
<P>Unlike C++, the &gt;&gt; operator in Java is a "signed" right bit shift, inserting the sign bit into the vacated bit position. Java adds an operator that inserts zeros into the vacated bit positions. </P>
<P>C++ allows the instantiation of variables or objects of all types either at compile time in static memory or at run time using dynamic memory. However, Java requires all variables of primitive types to be instantiated at compile time, and requires all objects to be instantiated in dynamic memory at runtime. Wrapper classes are provided for all primitive types except <B>byte</B> and <B>short</B> to allow them to be instantiated as objects in dynamic memory at runtime if needed. </P>
<P>C++ requires that classes and functions be declared before they are used. This is not necessary in Java. </P>
<P>The "namespace" issues prevalent in C++ are handled in Java by including everything in a class, and collecting classes into <I>packages</I>. </P>
<P>C++ requires that you re-declare <B>static</B> data members outside the class. This is not required in Java. </P>
<P>In C++, unless you specifically initialize variables of primitive types, they will contain garbage. Although local variables of primitive types can be initialized in the declaration, primitive data members of a class cannot be initialized in the class definition in C++. </P>
<P>In Java, you can initialize primitive data members in the class definition. You can also initialize them in the constructor. If you fail to initialize them, they will be initialized to zero (or equivalent) automatically. </P>
<P>Like C++, Java supports constructors that may be overloaded. As in C++, if you fail to provide a constructor, a default constructor will be provided for you. If you provide a constructor, the default constructor is not provided automatically. </P>
<P>All objects in Java are passed by reference, eliminating the need for the <I>copy constructor</I> used in C++.</P>
<blockquote>
	<P><i>(In reality, all parameters are passed by value in Java.&nbsp; 
	However, passing a copy of a reference variable makes it possible for code 
	in the receiving method to access the object referred to by the variable, 
	and possibly to modify the contents of that object.&nbsp; However, code in 
	the receiving method cannot cause the original reference variable to refer 
	to a different object.)</i> </P>
</blockquote>
<P>There are no destructors in Java. Unused memory is returned to the operating system by way of a <I>garbage collector</I>, which runs in a different thread from the main program. This leads to a whole host of subtle and extremely important differences between Java and C++. </P>
<P>Like C++, Java allows you to overload functions. However, default arguments are not supported by Java. </P>
<P>Unlike C++, Java does not support <I>templates</I>. Thus, there are no <I>generic</I> functions or classes. </P>
<P>Unlike C++, several <I>"data structure"</I> classes are contained in the "standard" version of Java. More specifically, they are contained in the standard class library that is distributed with the Java Development Kit (JDK). For example, the standard version of Java provides the containers <B>Vector</B> and <B>Hashtable</B> that can be used to contain any object through recognition that any object is<I> </I>an object of type <B>Object</B>. However, to use these containers, you must perform the appropriate <I>upcasting</I> and <I>downcasting</I>, which may lead to efficiency problems. </P>
<I><P>Multithreading</I> is a standard feature of the Java language. </P>
<P>Although Java uses the same keywords as C++ for access control: <B>private, public, </B>and <B>protected</B>, the interpretation of these keywords is significantly different between Java and C++. </P>
<P>There is no <B>virtual</B> keyword in Java. All non-static methods always use dynamic binding, so the <B>virtual</B> keyword isn't needed for the same purpose that it is used in C++. </P>
<P>Java provides the <B>final</B> keyword that can be used to specify that a method cannot be overridden and that it can be statically bound. (The compiler <I>may </I>elect to make it <I>inline</I> in this case.) </P>
<P>The detailed implementation of the <I>exception handling</I> system in Java is significantly different from that in C++. </P>
<P>Unlike C++, Java does not support <I>operator overloading</I>. However, the (<B>+</B>) and (<B>+=</B>) operators are automatically overloaded to concatenate strings, and to convert other types to <B>string </B>in the process. </P>
<P>As in C++, Java applications can call functions written in another language. This is commonly referred to as <I>native methods</I>. However, <U>applets cannot call native methods</U>. </P>
<P>Unlike C++, Java has built-in support for program documentation. Specially written comments can be automatically stripped out using a separate program named <B>javadoc</B> to produce program documentation. </P>
<P>Generally Java is more robust than C++ due to the following: </P>

<UL>
<LI>Object handles (references) are automatically initialized to <B>null</B>. </LI>
<LI>Handles are checked before accessing, and exceptions are thrown in the event of problems. </LI>
<LI>You cannot access an array out of bounds. </LI>
<LI>Memory leaks are prevented by automatic <I>garbage collection</I>.</LI></UL>

<P><!-prev=Java008c.htm-><!-first=Java008.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
