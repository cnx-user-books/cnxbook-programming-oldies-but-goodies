<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Implementing The Model-View-Controller Paradigm using Observer and Observable<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 200, Revised 02/24/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#the model-view-controller paradigm">The Model-View-Controller
Paradigm</a></li>

<li><a href="#the mvc sample program">The MVC Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#program listing">Program Listing</a></li></ul></ul>

<hr align=left width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b>Advanced Java Programming</b> classes at
ACC are responsible for knowing and understanding all of the material in
this lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
In a nutshell, the <i>Model-View-Controller</i> (MVC) paradigm is an approach
to programming that separates data input, data processing, and data output
in such a way that either the input or the output can be modified without
having any impact on the processing.

<p>This is also another application of <i>callbacks</i> in Java.
<center><h2><a name="the model-view-controller paradigm"></a><font color="#ff0000">The
Model-View-Controller Paradigm</font></h2></center>
The MVC concept has been used in the Smalltalk world for some time, and
has now been carried forward into Java. The primary Java tools for implementing
MVC are the <b>Observable</b> class and the <b>Observer</b> interface.

<p>The <b>Observable </b>class is used to implement the <i>Model</i> (where
the data processing is performed) and the <b>Observer</b> interface is
used to implement the <i>View</i> (where the results of the processing
are displayed).

<p>No special tools are required to implement the <i>Controller</i> which
handles data input.

<p>According to Mark Wutka in <u>Java Expert Solutions</u>:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"The idea behind MVC is that an application really consists of three
things-a <i>model</i>, some <i>views </i>of the model, and some <i>controllers</i>.&nbsp;

<p>The <i>model </i>is the part of the application that contains the actual
application logic. ... When we talk about separating the user interface
from the application, the <i>model </i>is the application.&nbsp;

<p>If the <i>model </i>represents the application, then the <i>view </i>and
<i>controller </i>represent the user interface. The user interface is conceptually
split into input components and output components.&nbsp;

<p>A <i>controller </i>is an input component. It supplies information to
the model.&nbsp;

<p>A <i>view </i>is an output component-it displays information from the
model.&nbsp;

<p>MVC is not some brand new, untested theory - it is the way Smalltalk
applications have been written for many years. "</td></tr></table>
In a discussion having to do with format translation of input data, Wutka
also tells us:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"The model should have absolutely no dependence on the external representation
of information. This is an extremely important point, because it greatly
affects the reusability of your code.&nbsp;

<p>You should be able to change input sources and change output formats
without touching the model. In other words, the model deals with pure information
that has no external meaning attached to it."</td></tr></table>
In other words, Wutka is saying that the <i>model</i> should have no responsibility
for translating the format of input data. Such translation, if required,
should be performed in the <i>Controller</i>. Also, the <i>model</i> should
have no responsibility for determining how results are to be displayed.

<p>In his discussion of <i>Observables and the Model-View-Controller Paradigm
</i>Wutka tells us:
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>"The <b>Observer </b>interface and the <b>Observable </b>class make
it easier for you to create <i>views </i>of data in the model by creating
a notification system to let your <i>view </i>know when data in the <i>model
</i>has changed.&nbsp;

<p>The mechanism is very simple. You create some object in your <i>model
</i>that is a subclass of <b>Observable</b>. Anytime this class changes,
it calls <b>setChanged </b>to flag itself as having changed, and then calls
<b>notifyObservers</b>.&nbsp;

<p>The reason for the separation is that you may run through a series of
checks in your <i>model</i>, any one of which might change the data. When
you have finished, you call <b>notifyObservers </b>one time, rather than
notifying the observers after every check. Whether to notify every time
or periodically is a design decision."</td></tr></table>
Many word processors provide good examples of the MVC concept at work.
Most word processors provide at least two views of the data: the WYSIWYG
edit view and the preview of how the page will actually look when the document
is printed.

<p>In the case of word processors, the <i>Controller</i> collects keystrokes
from the keyboard and delivers them to the <i>Model</i> which notifies
the <i>View</i> that the data has changed so that the updated data can
be displayed.

<p>Sometimes with a word processor, a slow computer, and a large document,
the <i>View</i> will lag behind the <i>Controller</i> and the <i>Model</i>,
but normally this doesn't have any detrimental impact on the ability of
the <i>Controller</i> and the <i>Model</i> to do their jobs. The <i>Model</i>
simply notifies the views that the data has changed. It doesn't know or
care what the <i>View</i> does with the data, or if the <i>View</i> is
able to keep up. In fact, the <i>Model</i> might not even know anything
about the <i>View</i> other than that it is registered for notification
of changes in the data.

<p>This lesson makes no attempt to provide a rigorous discussion of MVC.
If you link to your favorite search engine and do a search, you will probably
find more material on the subject than you have the time to read (although
most of it will probably be couched in Smalltalk). Rather, this lesson
will attempt to teach you how to use Java to implement MVC.

<p>If you go to the news groups, you will probably find more discussion
and debate on the topic than you care to read (for example, do a search
on <b>Observable</b> at DejaNews.com).

<p><font color="#000000">As is often the case, we will attempt to teach
you how to use Java to implement MVC by examining a sample program that
implements MVC.</font><center><h2><a name="the mvc sample program"></a><font color="#ff0000">The MVC Sample
Program</font></h2></center>
This program illustrates the use of the <b>Observer </b>interface and the
<b>Observable </b>class in the implementation of the <i>Model-View-Controller</i>
(MVC) paradigm.

<p>When you run this program, three <b>Frame </b>objects will appear on
the screen in a column. The top <b>Frame </b>object is the <i>Controller
</i>object that lets you enter temperature data in Celsius into a <b>TextField
</b>object. The <i>Controller</i> object also lets you terminate the program
by clicking its close box.

<p>The two bottom <b>Frame </b>objects display different <i>Views </i>of
the temperature data after it has been converted to Fahrenheit by the <i>Model</i>.
One displays the data in standard digital format. The other converts the
temperature to a color and displays the color.

<p>Conversion from Celsius to Fahrenheit is the data processing function
of the <i>model.</i>

<p>The <i>Model-View-Controller</i> paradigm requires one <i>Model </i>object,
one or more <i>Controller </i>objects, and one or more <i>View </i>objects.

<p>This program instantiates a <i>Model </i>object, as an instance of the
class named <b>ModelClass </b>that extends the <b>Observable </b>class.

<p>The <i>Model </i>object is instantiated on the <u>main thread</u>. The
program saves a reference to the <i>Model </i>object in an instance variable
of the controlling class for use by the methods of the other objects.

<p>The program <u>spawns one thread</u> which is a <i>Controller</i> object
and <u>two threads</u> which are <i>View </i>objects. In other words, one
<i>Controller </i>object is provided to accept user input and pass it along
to the <i>Model </i>object. Two different <i>View </i>objects are provided
that display two different views of the value of the property named <b>temp
</b>maintained by the <b>Model </b>object.

<p>The <i>Model</i>, the <i>Controller</i>, and both <i>View</i> objects
all operate on different threads.

<p>The <i>Model </i>object accepts temperature values in Celsius, from
the <i>Controller </i>object, converts them to Fahrenheit as data-processing
task, and maintains them as a property named <b>temp</b>. Only one value
of the <b>temp </b>property is maintained. New temperature values cause
the current value of the <b>temp </b>property to be overwritten.

<p>Because the class named <b>ModelClass </b>(which is used to instantiate
the <i>Model </i>object) extends the <b>Observable </b>class, objects of
type <b>ModelClass </b>have the ability to <u>maintain a list</u> of registered
<b>Observer </b>objects (<i>View </i>objects). This is a form of callbacks.

<p>Interested <b>Observer </b>(<i>View</i>) objects register their interest
in being notified of changes in the <b>temp </b>property of the <i>Model
</i>by invoking the <b>addObserver()</b> method of the <b>Observable </b>class
on a reference to the <i>Model </i>object.

<p>Whenever the property value changes, the <i>Model </i>object notifies
all of the registered <i>View </i>objects of the change, passing its own
identify and the new value of the <b>temp </b>property to each of the registered
<i>View </i>objects.

<p>The registered <i>View </i>objects are notified <u>only</u> when <u>actual
changes occur</u> in the <b>temp </b>property value. If two successive
input temperature values from the <i>Controller </i>object are the same
(don't result in an actual change in the <b>temp </b>property), the <i>View
</i>objects are not notified.

<p>The notification process consists of calculating and saving the new
value of the <b>temp </b>property in Fahrenheit, invoking the <b>setChanged()</b>
method of the <b>Observable </b>class (as described earlier), and then
invoking the <b>notifyObservers()</b> method of the <b>Observable </b>class.

<p>The actual notification of the registered <i>View </i>objects takes
place <u>behind the scenes</u>. As is typical for this sort of thing in
Java, the notification is accomplished by <u>invoking</u> the <b>update()</b>
method on each of the registered <i>View </i>objects and passing the identity
of the <i>Model</i> object along with the new value of the temp property
as parameters (similar to notifying listener objects than an event has
occurred).

<p>Although this program has <u>only one</u> <i>Controller </i>object,
there is no reason that additional <i>Controller </i>objects could not
be added. Therefore, the <b>setTemp()</b> method is synchronized to avoid
the possibility of two or more <i>Controller </i>objects trying to modify
the <b>temp </b>property value at the same time.

<p>A <b>Thread </b>class named <b>ControlThread </b>is used to implement
a <i>Controller </i>object that accepts temperature data from the user
and passes the data along to the <i>Model </i>object.

<p>The <i>Controller </i>object provides a <b>TextField </b>object that
the user can access to enter new temperature values. If the user enters
a character combination that cannot be successfully converted to a double
value, an error message appears in the <b>TextField </b>object.

<p>The mechanism by which the <i>Controller </i>object sends new data to
the <i>Model </i>object is by invoking the <b>setTemp() </b>method on a
reference to the <i>Model </i>object. The reference to the <i>Model </i>object
is passed to the <i>Controller </i>object when it is instantiated to be
saved and used later for this purpose.

<p>The "close" button on the <b>Frame </b>provided by the <i>Controller
</i>object is used to terminate the program. An <u>anonymous inner-class</u>
is used to instantiate an anonymous <b>WindowListener </b>object to accomplish
this.

<p>A <u>named inner-class</u> action listener object is registered on the
<b>TextField </b>to process the user-input data whenever the user presses
the [<b>Enter</b>] key while the <b>TextField </b>has the focus.

<p>The <b>ActionListener </b>object extracts the data from the <b>TextField
</b>object, converts it to a <b>double </b>value (if possible), and sends
it to the <i>Model </i>object by invoking the <b>setTemp()</b> method on
the reference to the <i>Model </i>object and passing the <b>double </b>value
as a parameter.

<p>If the <b>TextField </b>data is successfully converted to a <b>double
</b>value, the <b>TextField </b>object is cleared for entry of new data.
If not, an error message is written into the <b>TextField </b>object.

<p>Two <i>View </i>objects are instantiated and registered on the <i>Model
</i>object. One of the <i>View </i>objects displays the temperature data
in digital form in a <b>Frame </b>object.

<p>The other <i>View</i> object converts the temperature data to a color
and displays the color in a <b>Frame </b>object with red tones indicating
warmer and blue tones indicating colder.

<p>The "close" buttons on the <b>Frame </b>objects provided by the <i>View
</i>objects are <u>not active</u>. As mentioned earlier, the program can
be terminated by clicking the "close" button on the <b>Frame </b>object
provided by the <i>Controller </i>object.

<p>Both of the <i>View </i>objects are passed a reference to the <i>Model
</i>object when they are instantiated. This reference is saved and used
later to register the <i>View </i>objects on the <i>Model </i>object for
notification of changes to the <b>temp </b>property value maintained by
the <i>Model </i>object.

<p>Each of the <i>View </i>objects registers its interest in receiving
such notifications by invoking the <b>addObserver()</b> method on its reference
to the <i>Model </i>object.

<p><i>View </i>objects receive notification of changes in the values of
interest by having their <b>update()</b> method invoked. This method is
declared by the <b>Observer </b>interface which is implemented by the two
<i>View </i>classes.

<p>The <b>update() </b>methods of all registered <i>View </i>objects are
invoked when the <b>notifyObservers()</b> method of the <b>Observable </b>class
is invoked by code in the <i>Model </i>object (after having first invoked
the<b> setChanged()</b> method of the <b>Observable </b>class).

<p>When the <b>upDate()</b> method is invoked, the identification of the
<i>Model </i>object and the value of the <b>temp </b>property are passed
in as parameters. The parameter identifying the <i>Model </i>object is
not used in this program because the <i>View </i>objects are registered
on only one <i>Model</i> and therefore, identification of the source is
not required.

<p>Code within the <b>upDate()</b> method of one of the <i>View </i>objects
displays the value of the temp property in <u>digital format</u>.

<p>Code within the <b>upDate()</b> method of the other <i>View </i>object
converts the value of the temp property to a color and <u>displays the
color</u>.

<p>Thus, we have <u>two different views</u> of the data which has been
provided by the <i>Controller </i>object and processed by the <i>Model
</i>object, in the same sense that a typical word processing program provides
two or more views of data provided by the user and processed by the program.

<p>Although our sample program deals only with one simple property of type
<b>double</b>, an <u>object is passed</u> to the <i>View </i>object when
its <b>update()</b> method is invoked and there is no reason that that
object could not contain a <u>variety of different instance variables</u>
to be used by the <i>View </i>object for different purposes.

<p>Similarly, even though the <i>Controller </i>object passes only a simple
<b>double </b>value to the <i>Model </i>object, there is no reason that
the <i>Controller </i>object could not <u>pass an object</u> containing
a <u>variety of instance variables</u> for use by the <i>Model </i>object.

<p>This program was tested using JDK 1.1.3 under Win95.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
The first interesting code fragment is an instance variable of the controlling
class named <b>refToModel</b> that provides the critical link between the
<i>Model</i> object and the <i>Controller</i> and <i>View</i> objects.

<p>The <i>Controller</i> objects must be able to access the <i>Model</i>
object in order to invoke the <b>setTemp()</b> method on the <i>Model</i>
object to pass data to the <i>Model</i> object.

<p>Similarly, the <i>View</i> objects must be able to access the <i>Model</i>
object in order to invoke the <b>addObserver()</b> method on the <i>Model</i>
object to register themselves as observers.

<p>Therefore, some kind of link that supports invocation of methods on
the <i>Model</i> object by the <i>Controller</i> and <i>View</i> objects
is critical to the overall operation of the program.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class Mvc01{//controlling class
&nbsp; ModelClass <b>refToModel</b>;//reference to the Model object</pre></td></tr></table>
As is typical, the <b>main</b> method instantiates an object of the controlling
class. Inside the constructor of the controlling class, a new object of
the <b>ModelClass</b> is instantiated on the main thread. A reference to
that object is assigned to the instance variable named <b>refToModel</b>
as discussed above.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; Mvc01(){//constructor
&nbsp;&nbsp;&nbsp; <b>refToModel </b>= <b>new ModelClass</b>();&nbsp;&nbsp;</pre></td></tr></table>
Next, we spawn <u>three new threads</u>: two for <i>View</i> objects, and
one for a <i>Controller</i> object. As a result, all of the major components
of our program are operating on different threads. The following code fragment
is typical of that used to instantiate and start the three thread objects.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; Thread <b>view1Thread </b>=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(new view1Thread(refToModel),"View1");&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; view1Thread.<b>start</b>();</pre></td></tr></table>
Next, we define a class that is used to instantiate an object that represents
the <i>Model.</i> This <i>Model </i>converts incoming temperature data
in degrees Celsius to temperature in degrees Fahrenheit and makes those
temperature values available to any <i>View </i>objects that are registered
for notification when the value changes.

<p>Because this class extends <b>Observable</b>, it knows how to <u>register</u><b>Observers </b>to be notified when the value of interest changes, and
to <u>notify</u> Observers when that happens.

<p>The first interesting code fragment for this class is the line showing
that it extends <b>Observable</b> and the instance variable that constitutes
the property named <b>temp</b>.

<p>A <i>property</i> is a special thing (not just an instance variable)
and the name of the <i>property </i>derives from the Java design patterns
that say that a property that is set by a method named <b>setTemp()</b>
is itself named <b>temp</b>. This naming convention is discussed more fully
in the lessons on Java <b>Beans</b>. The value of the property named <b>temp</b>
is actually maintained in an instance variable named <b>tempF</b>.

<p>The value of the property named <b>temp</b> is observed and displayed
by the <i>View</i> objects in this program.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>ModelClass </b>extends <b>Observable</b>{
&nbsp; double <b>tempF</b>;</pre></td></tr></table>
Because of the simplicity of this <i>Model</i>, all of the data processing
as well as notification of registered observers takes place inside the
<b>setTemp()</b> method, which is the method invoked by the <i>Controller</i>
object to provide new data to the <i>Model</i>.

<p>When this method is invoked by the <i>Controller</i> object with new
data, the method first converts the data from Celsius to Fahrenheit and
then confirms that there is actually a change in the data value. If the
value has not actually changed, the registered <i>View</i> objects are
not notified.

<p>If the value of the property named <b>temp</b> has actually changed,
the code goes through the required steps of first invoking the <b>setChanged()</b>
method and then invoking the <b>notifyObservers()</b> method. The rationale
for this two-step process was explained in the earlier quotation from Wutka.

<p>Note that the name <b>tempF</b> is used both as the name of an instance
variable of the class (<b>this.tempF</b>) and as the name of a local variable
in the method (another name choice for the local variable might have been
better, but this does illustrate the ability to use the <b>this</b> reference
to disambiguate such things).
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; synchronized void <b>setTemp</b>(double tempC){
&nbsp;&nbsp;&nbsp; double tempF = 1.8 * tempC + 32;//convert C to F
&nbsp;&nbsp;&nbsp; <b>if</b>(tempF != this.tempF){//confirm value changed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.tempF = tempF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.setChanged();//required by notifyObservers()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; notifyObservers(new Double(this.tempF));
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end setTemp()</pre></td></tr></table><b>setTemp()</b> is the only method in the class named <b>ModelClass</b>,
so now we come to the definition of the class from which the <i>Controller</i>
object is instantiated.

<p>This class is named <b>controlThread</b> and implements the <b>runnable</b>
interface so that it can be used to instantiate a <b>Thread</b> object.

<p>The constructor for this class receives a reference to the <i>Model</i>
object and saves it in an instance variable named <b>refToModel</b>. The
constructor code is too simple to highlight here, but you can see it in
the complete listing of the program near the end of this document.

<p>Objects of this class are visual, and provide a <b>TextField</b> object
into which the user can enter temperature data in Celsius.

<p>As is the case in all <b>Thread</b> objects, the real work is done in
the <b>run()</b> method, or in methods invoked by <b>run()</b>.

<p>Most of the code in the body of the <b>run() </b>method is used to construct
the visual user interface in a <b>Frame</b> object. You have seen code
of this type many times before. Therefore, much of it has been deleted
from this section of interesting code fragments. You can view all of the
code in the complete program listing that appears later in this lesson.

<p>As you can see, this is pretty straightforward stuff at this point.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>run</b>(){
&nbsp;&nbsp;&nbsp; //Construct the visual display for the Control in a&nbsp;
&nbsp;&nbsp;&nbsp; // Frame object
&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp; TextField textField = <b>new TextField(15)</b>;
&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp; //<b>Register an action listener</b> object on the TextField&nbsp;
&nbsp;&nbsp;&nbsp; // object that will be notified when the user presses&nbsp;
&nbsp;&nbsp;&nbsp; // the &lt;Enter> key while the TextField has the focus.
&nbsp;&nbsp;&nbsp; textField.<b>addActionListener</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ActionListenerClass());
&nbsp;&nbsp;&nbsp; //...&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end run()</pre></td></tr></table>
Most of the actual work is in the <i>Controller</i> object is performed
by the <b>actionPerformed()</b> method that is invoked when the user enters
some data into the <b>TextField</b> object and presses the [<b>Enter</b>]
key.

<p>The <b>actionPerformed()</b> method is defined in a class named <b>ActionListenerClass</b>.
This is a named inner class of the class named <b>controlThread</b>. It
was made an inner class simply to make it easier to gain access to the
<b>refToModel </b>variable that is used to send new data to the <i>Model
</i>object (avoids passing a parameter to a constructor).

<p>Objects of this class listen for action events on the <b>TextField</b>
object. When an action event occurs, the text is read from the <b>TextField</b>,
converted to a <b>double </b>value, and passed into the <b>setTemp()</b>
method of the <i>Model </i>object.

<p>As soon as the text data is read from the <b>TextField</b> object, the
text field is cleared for entry of new data.

<p>If the attempt to convert the incoming data to a valid <b>double</b>
value fails, an exception is thrown and an error message is displayed in
the text field.

<p>If no exception is thrown, the new <b>double</b> value is sent to the
<i>Model</i> object by invoking the <b>setTemp()</b> method on that object
and passing the new value as a parameter.

<p>Note that the methods of the <b>Double</b> wrapper class are used in
the attempt to convert the input <b>String</b> data to a numeric <b>double</b>
value.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data = ((TextField)e.<b>getSource</b>()).<b>getText</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Clear the TextField object for next entry
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((TextField)e.getSource()).<b>setText</b>("");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>refToModel</b>.<b>setTemp</b>(new Double(data).doubleValue());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(NumberFormatException excep){//on bad input
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((TextField)e.getSource()).setText(//error message
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Numeric Data Only");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch block
&nbsp;&nbsp;&nbsp; }//end actionPerformed()</pre></td></tr></table>
Following this, two <b>Thread </b>classes are defined (classes that implement
the <b>Runnable</b> interface) to serve as the two <i>View</i> objects.
One of the <i>View</i> objects displays the temperature data in typical
printed digital format. The other converts the data to a color and displays
the color.

<p>Again, the work is done in the <b>run()</b> methods of the two classes,
and much of the work involves creating the visual <b>Frame</b> object for
the display. Most of the code required to construct the display will be
deleted from this portion of the lesson. It is available for you to view
later in the complete program listing.

<p>As before, the constructors for these two classes receive and save a
reference to the <i>Model</i> object as an instance variable named <b>refToModel</b>.
This reference is needed so that the <i>View</i> objects can register with
the <i>Model</i> as observers. The constructor is too simple to show here.

<p>An additional instance variable of type <b>Label</b>, named <b>displayWindow</b>,
is also declared for later use. In one class, it is used to display the
temperature in digital form. In the other class, the background color of
the label is used to display a color that represents the temperature.

<p>The first interesting code fragment is the code in the <b>run()</b>
methods of both <i>View</i> classes that registers the object to be notified
whenever a change occurs in the value of the <b>temp</b> property in the
<i>Model</i> object. This registration is accomplished by invoking the
<b>addObserver()</b> method on the reference to the <i>Model</i> object
as shown below.

<p>This is followed by some code to construct the visual <b>Frame</b> object
in which the temperature data will be displayed. That code has been deleted
from the following representation of the <b>run()</b> method.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void run(){
&nbsp;&nbsp;&nbsp; refToModel.<b>addObserver</b>(this);//register
&nbsp;&nbsp;&nbsp; //...
&nbsp; }//end run()</pre></td></tr></table>
Once an <b>Observer</b> object is registered on an <b>Observable</b> object,
the <b>update()</b> method in the <b>Observer</b> object will be invoked
whenever the <b>notifyObservers()</b> method is invoked on the <b>Observable</b>
object. The parameters to the <b>update()</b> method consist of two objects:
one object to identify the <b>Observable</b> object, and the other parameter
to contain the values being observed.

<p>Each of the <i>View</i> objects contains an <b>update()</b> method and
this is where the temperature data is formatted for display in the two
visual <b>Frame</b> objects created and maintained by the <i>View</i> objects.

<p>The <b>update()</b> methods in the two <i>View</i> classes are similar.
I am going to show you the version that displays the temperature data in
color because it is the most interesting of the two. The other one simply
uses the <b>setText()</b> method of the <b>Label</b> object to display
the incoming temperature, although some casting and the use of the <b>Double</b>
wrapper class is required to disassemble the incoming object.

<p>For both cases, the <b>update()</b> method is invoked (behind the scenes)
by the <i>Model </i>object to notify the <i>View </i>object that the value
of the property named <b>temp </b>maintained by the <i>Model </i>has changed.
The new value is encapsulated in a <b>Double</b> object by the <i>Model</i>
object and passed to the <b>update()</b> method as an object of type <b>Object</b>
known locally as <b>arg</b>.

<p>This particular view displays the temperature as a color with a temperature
of 255 or greater being pure red, a temperature of 0 or lower being pure
blue, and temperatures in between resulting in a proportional mixture of
red and blue. The following code fragment shows how this is accomplished.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>update</b>(Observable o, Object <b>arg</b>){
&nbsp;&nbsp;&nbsp; double temp = ((Double)<b>arg</b>).doubleValue();
&nbsp;&nbsp;&nbsp; if(temp > 255.0) temp = 255.0;//clip at 255
&nbsp;&nbsp;&nbsp; if(temp &lt; 0.0) temp = 0.0;//clip at zero
&nbsp;&nbsp;&nbsp; int red = (int)temp;
&nbsp;&nbsp;&nbsp; int blue = (int)(255-temp);
&nbsp;&nbsp;&nbsp; //Set the green contribution to the color to zero.
&nbsp;&nbsp;&nbsp; displayWindow.setBackground(new Color(red,0,blue));
&nbsp; }//end update()&nbsp;&nbsp;
}//end class view2Thread</pre></td></tr></table>
A complete listing of the program follows.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
See the earlier text in this lesson for an operational description of this
program. Some of the interesting code fragments are highlighted in <b>boldface</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Mvc01.java&nbsp; Copyright 1997, R.G.Baldwin
This program illustrates the use of the Observer interface
and the Observable class in the implementation of the
Model-View-Controller (MVC)paradigm.

When you run this program, three Frame objects will appear
on the screen in a column.&nbsp; The top Frame object is the
Control object that lets you enter temperature data into
a TextField object.&nbsp; This object also lets you terminate
the program by clicking its close box.

The two bottom Frame objects display different Views of
the temperature data.&nbsp; One displays the data in standard
digital format.&nbsp; The other converts the temperature to a
color and displays the color.

This program was tested using JDK 1.1.3 under Win95.

=========================================================*/

import java.util.*;
import java.awt.*;
import java.awt.event.*;

//=======================================================//
class <b>Mvc01</b>{//controlling class
&nbsp; ModelClass <b>refToModel</b>;//reference to the Model object
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; static public void <b>main</b>(String[] args){
&nbsp;&nbsp;&nbsp; new Mvc01();//Instantiate this object.
&nbsp; }//end main
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Mvc01(){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; //Instantiate an object of the Model class on the main&nbsp;
&nbsp;&nbsp;&nbsp; // thread.
&nbsp;&nbsp;&nbsp; refToModel = <b>new ModelClass()</b>;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Spawn two View threads, and one Control thread.
&nbsp;&nbsp;&nbsp; // First instantiate the thread objects.
&nbsp;&nbsp;&nbsp; Thread view1Thread =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(<b>new view1Thread</b>(refToModel),"View1");
&nbsp;&nbsp;&nbsp; Thread view2Thread =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(<b>new view2Thread</b>(refToModel),"View2");
&nbsp;&nbsp;&nbsp; Thread control1Thread =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(<b>new controlThread</b>(refToModel),"Control");

&nbsp;&nbsp;&nbsp; // Now start the threads running.&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; view1Thread.start();
&nbsp;&nbsp;&nbsp; view2Thread.start();
&nbsp;&nbsp;&nbsp; control1Thread.start();&nbsp;
&nbsp; }//end constructor
}//end class Mvc01
//=======================================================//

//This class is used to instantiate an object that&nbsp;
// represents the Model in the MVC paradigm. This Model
// converts incoming temperature data in degrees Celsius
// to temperature in degrees Fahrenheit and makes those
// temperature values&nbsp; available to any Views that are&nbsp;
// registered for notification when the value changes.
//
// Because this class extends Observable, it also knows
// how to register Observers to be notified when the
// value of interest changes, and to notify Observers when
// that happens.
class <b>ModelClass </b>extends <b>Observable</b>{
&nbsp; double tempF;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This is the method by which the Control provides new
&nbsp; // input data to the Model. This method also notifies
&nbsp; // registered View objects when the value of the temp
&nbsp; // property has changed.
&nbsp; synchronized void <b>setTemp</b>(double tempC){
&nbsp;&nbsp;&nbsp; //Convert from Celsius to Fahrenheit
&nbsp;&nbsp;&nbsp; double tempF = 1.8 * tempC + 32;
&nbsp;&nbsp;&nbsp; //Confirm that value has change, and if so notify
&nbsp;&nbsp;&nbsp; // View objects.
&nbsp;&nbsp;&nbsp; if(tempF != this.tempF){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.tempF = tempF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.<b>setChanged</b>();//required by notifyObservers()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>notifyObservers</b>(new Double(this.tempF));
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end setTemp()
}//end ModelClass
//=======================================================//

//This class is used to instantiate an object to serve as
// the Control in the MVC paradigm.&nbsp; Values entered into
// a TextField object are sent to the Model
class <b>controlThread </b>implements <b>Runnable</b>{
&nbsp; ModelClass <b>refToModel</b>;//Reference to the Model object.
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; controlThread(ModelClass <b>refToModel</b>){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; this.refToModel = <b>refToModel</b>;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>run</b>(){
&nbsp;&nbsp;&nbsp; //Construct the visual display for the Control in a&nbsp;
&nbsp;&nbsp;&nbsp; // Frame object
&nbsp;&nbsp;&nbsp; Frame control = new Frame(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; control.setLayout(new FlowLayout());
&nbsp;&nbsp;&nbsp; control.setBounds(0,0,300,135);
&nbsp;&nbsp;&nbsp; control.add(new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Control:&nbsp; Enter temperature in Celsius here"));
&nbsp;&nbsp;&nbsp; TextField textField = new TextField(15);
&nbsp;&nbsp;&nbsp; textField.setBackground(Color.yellow);
&nbsp;&nbsp;&nbsp; control.add(textField);
&nbsp;&nbsp;&nbsp; control.add(new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Close this Frame to terminate."));
&nbsp;&nbsp;&nbsp; control.setVisible(true);

&nbsp;&nbsp;&nbsp; //Register an action listener object on the TextField&nbsp;
&nbsp;&nbsp;&nbsp; // object that will be notified when the user presses&nbsp;
&nbsp;&nbsp;&nbsp; // the &lt;Enter> key while the TextField has the focus.
&nbsp;&nbsp;&nbsp; textField.<b>addActionListener</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>new ActionListenerClass()</b>);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Instantiate an <b>anonymous inner-class</b> listener object
&nbsp;&nbsp;&nbsp; // to <b>terminate </b>program when the user clicks the close
&nbsp;&nbsp;&nbsp; // box on the Frame object.
&nbsp;&nbsp;&nbsp; control.addWindowListener(new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});//end addWindowListener
&nbsp; }//end run()
&nbsp; //=====================================================//

&nbsp; //This is a listener class that is a<b> named inner class</b>&nbsp;
&nbsp; // of the class named controlThread.&nbsp; It was made
&nbsp; // an inner class to make it easier to gain access
&nbsp; // to the refToModel variable that is used to send new
&nbsp; // data to the Model.
&nbsp;&nbsp;
&nbsp; //Objects of this class listen for action events on the
&nbsp; // TextField object.&nbsp; When an action event occurs, the
&nbsp; // text is read from the TextField, converted to a
&nbsp; // double value, and passed into the setTemp() method of
&nbsp; // the Model object.
&nbsp; class <b>ActionListenerClass </b>implements ActionListener{
&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data = ((TextField)e.getSource()).getText();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Clear the TextField object for next entry
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((TextField)e.getSource()).setText("");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; refToModel.setTemp(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Double(data).doubleValue());
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(NumberFormatException excep){//on bad input
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((TextField)e.getSource()).setText(//error message
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Numeric Data Only");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch block
&nbsp;&nbsp;&nbsp; }//end actionPerformed()
&nbsp; }//end inner class named ActionListenerClass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
}//end class controlThread
//=====================================================//

//This class is used to instantiate a thread&nbsp; object
// that is a View in the MVC paradigm.&nbsp; This particular
// View displays the temp property of the Model in&nbsp;
// digital format.&nbsp; Note that this is a Thread class.
class <b>view1Thread </b>implements <b>Observer</b>, <b>Runnable</b>{
&nbsp; Label <b>displayWindow</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; ModelClass <b>refToModel</b>;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; view1Thread(ModelClass <b>refToModel</b>){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; this.refToModel = <b>refToModel</b>;//save the reference
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>run</b>(){
&nbsp;&nbsp;&nbsp; //Register this object to be notified whenever
&nbsp;&nbsp;&nbsp; // a change occurs in the value of the temp property
&nbsp;&nbsp;&nbsp; // in the Model object.
&nbsp;&nbsp;&nbsp; refToModel.<b>addObserver</b>(this);//register
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a display panel for the View
&nbsp;&nbsp;&nbsp; Frame display = new Frame("View1 - Digital View");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display.setLayout(new FlowLayout());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display.add(new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Fahrenheit View of Temperature: "));
&nbsp;&nbsp;&nbsp; displayWindow = new Label("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ");
&nbsp;&nbsp;&nbsp; display.add(displayWindow);
&nbsp;&nbsp;&nbsp; display.setBounds(0,135,300,100);
&nbsp;&nbsp;&nbsp; display.setVisible(true);
&nbsp; }//end run()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is invoked by the Model to notify that
&nbsp; // the value of the temp property maintained by the
&nbsp; // Model has changed.&nbsp; The new value is passed in as arg.
&nbsp; public void <b>update</b>(Observable o, Object <b>arg</b>){
&nbsp;&nbsp;&nbsp; displayWindow.<b>setText</b>("" + ((Double)<b>arg</b>).doubleValue());
&nbsp; }//end update()&nbsp;&nbsp;
}//end class view1Thread
//=======================================================//

//This class is used to instantiate a thread object that
// is a View in the MVC paradigm.&nbsp; This particular View
// displays the property value of the Model object in
// color format: more red for warmer and more blue for
// cooler.&nbsp; Note that this is a Thread class.
class <b>view2Thread </b>implements <b>Observer</b>, <b>Runnable</b>{
&nbsp; Label displayWindow;
&nbsp; ModelClass <b>refToModel</b>;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; view2Thread(ModelClass refToModel){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; this.refToModel = refToModel;//save the reference
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void run(){
&nbsp;&nbsp;&nbsp; //Register this object to be notified whenever a&nbsp;
&nbsp;&nbsp;&nbsp; // change occurs in the value of the temp property
&nbsp;&nbsp;&nbsp; // in the Model object.
&nbsp;&nbsp;&nbsp; refToModel.<b>addObserver</b>(this);//register
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a display panel for the View
&nbsp;&nbsp;&nbsp; Frame display = new Frame("View2 - Color View");
&nbsp;&nbsp;&nbsp; display.setLayout(new FlowLayout());
&nbsp;&nbsp;&nbsp; displayWindow = new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ");
&nbsp;&nbsp;&nbsp; display.add(displayWindow);
&nbsp;&nbsp;&nbsp; display.add(new Label(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp; Blue means Cold, Red means Hot&nbsp;&nbsp; "));
&nbsp;&nbsp;&nbsp; display.setBounds(0,235,300,100);
&nbsp;&nbsp;&nbsp; display.setVisible(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end run()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is invoked by the Model object to notify
&nbsp; // the View that the value of the property named temp
&nbsp; // maintained by the Model has changed.&nbsp; The new value
&nbsp; // is passed in as arg.&nbsp;
&nbsp; public void <b>update</b>(Observable o, Object <b>arg</b>){
&nbsp;&nbsp;&nbsp; //This view displays the temperature as a color
&nbsp;&nbsp;&nbsp; // with a temperature of 255 or greater being
&nbsp;&nbsp;&nbsp; // pure red, a temperature of 0 or lower being
&nbsp;&nbsp;&nbsp; // pure blue, and temperatures in between&nbsp;
&nbsp;&nbsp;&nbsp; // resulting in a proportional mixture of red and&nbsp;
&nbsp;&nbsp;&nbsp; // blue.
&nbsp;&nbsp;&nbsp; double temp = ((Double)arg).doubleValue();
&nbsp;&nbsp;&nbsp; if(temp > 255.0) temp = 255.0;
&nbsp;&nbsp;&nbsp; if(temp &lt; 0.0) temp = 0.0;
&nbsp;&nbsp;&nbsp; int red = (int)temp;
&nbsp;&nbsp;&nbsp; int blue = (int)(255-temp);
&nbsp;&nbsp;&nbsp; //Set the green contribution to the color to zero.
&nbsp;&nbsp;&nbsp; displayWindow.setBackground(new Color(red,0,blue));
&nbsp; }//end update()&nbsp;&nbsp;
}//end class view2Thread
//=======================================================//</pre></td></tr></table>
-end-<!--end--></body></html>