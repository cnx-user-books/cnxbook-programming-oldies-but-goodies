<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Using the Java 2D ConvolveOp Filter Class to Process Images</h2>
<i>Learn how to write programs that use the ConvolveOp class of the Java 2D API 
to perform two-dimensional image convolution.&nbsp; Also learn about some of the 
weaknesses of the ConvolveOp class that result from a lack of options for 
dealing with convolution output values greater than 255 and less than 0.</i><p><b>Published:</b>&nbsp; 
August 28, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 460</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
		<li><a href="#Constructing_images">Constructing images</a></li>
		<li><a href="#The_framework_program_named_ImgMod05">The framework program 
	named ImgMod05</a></li>
		<li><a href="#ConvolveOp_Examples">ConvolveOp Examples</a></li>
	</ul></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>In an earlier lesson titled &quot;A Framework for Experimenting with Java 2D 
Image-Processing Filters&quot; <i>(see <a href="#Resources">Resources</a>)</i>, I taught you how to write a framework program that 
makes it easy to use the image-filtering classes of the Java 2D API to process 
the pixels in an image and to display the processed image.</p>
<p>At the close of that lesson, I told you that future lessons would teach you 
how to use the following image-filtering classes from the Java 2D
<a name="FilterClassList">API</a>:</p>
<ul>
	<li><b>LookupOp</b></li>
	<li><b>AffineTransformOp</b> </li>
	<li><b>BandCombineOp</b> </li>
	<li><b>ConvolveOp</b> </li>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b> </li>
</ul>
<p>In several of the previous lessons listed in the <a href="#Resources">Resources</a> 
section, I taught you how to use the <b>LookupOp</b>, the <b>AffineTransformOp</b>, 
and the <b>BandCombineOp</b> image-filtering classes.</p>
<p>In this lesson, I will teach you how to use the <b>ConvolveOp</b> 
image-filtering class to perform a variety of filtering operations on images.&nbsp;
</p>
<p>I will teach you how to use the remaining classes from the above
<a href="#FilterClassList">list</a> in future lessons.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Illustration of an edge treatment 
	option.</li>
	<li><a href="#Figure_2">Figure 2</a>. Illustration of another edge treatment 
	option.</li>
	<li><a href="#Figure_3">Figure 3</a>. Application of a flat 4x4 smoothing 
	filter.</li>
	<li><a href="#Figure_4">Figure 4</a>. Application of an embossing filter 
	using ConvolveOp.</li>
	<li><a href="#Figure_5">Figure 5</a>. Screen shot of the user input GUI.</li>
	<li><a href="#Figure_6">Figure 6</a>. Screen shot of typical program output.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the class definition.</li>
	<li><a href="#Listing_2">Listing 2</a>. The 9x9 convolution filter matrix.</li>
	<li><a href="#Listing_3">Listing 3</a>. Instantiation of Label object for 
	display of data entry errors.</li>
	<li><a href="#Listing_4">Listing 4</a>. The primary constructor.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the method named 
	constructMainPanel.</li>
	<li><a href="#Listing_6">Listing 6</a>. Creation of the panel for radio 
	buttons and text fields.</li>
	<li><a href="#Listing_7">Listing 7</a>. Creation and population of a 
	sub-panel for the radio buttons.</li>
	<li><a href="#Listing_8">Listing 8</a>. Creation of a sub-panel that 
	contains the text fields.</li>
	<li><a href="#Listing_9">Listing 9</a>. Population and initialization of the 
	array of TextField objects.</li>
	<li><a href="#Listing_10">Listing 10</a>. Complete the construction of the 
	user input GUI.</li>
	<li><a href="#Listing_11">Listing 11</a>. Beginning of the processMainPanel 
	method.</li>
	<li><a href="#Listing_12">Listing 12</a>. Conversion of the 2D convolution 
	filter into a 1D array.</li>
	<li><a href="#Listing_13">Listing 13</a>. Correct for all filter values 
	equal to 0.0f.</li>
	<li><a href="#Listing_14">Listing 14</a>. Setting the edge treatment 
	parameters.</li>
	<li><a href="#Listing_15">Listing 15</a>. Creation of the ConvolveOp filter.</li>
	<li><a href="#Listing_16">Listing 16</a>. Apply the ConvolveOp filter and 
	return the filtered image.</li>
	<li><a href="#Listing_17">Listing 17</a>. The required processImg method.</li>
	<li><a href="#Listing_18">Listing 18.</a> Complete listing for the class 
	named ImgMod42.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><b><a name="Constructing_images">Constructing images</a></b></h3>
<p>Before getting into the programming details, it may be useful for you to 
review the concept of how images are constructed, stored, transported, and 
rendered in Java <i>(and in most modern computer environments for that matter).</i></p>
<p>I provided a great deal of information on those topics in the earlier lesson 
titled &quot;Processing Image Pixels using Java, Getting Started&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; Therefore, I won't repeat that 
information here.&nbsp; Rather, I will simply refer you back to the earlier lesson.</p>
<h3><b><a name="The_framework_program_named_ImgMod05">The framework program 
named ImgMod05</a></b></h3>
<p>It will also be useful for you to understand the behavior of the framework 
program named <b>ImgMod05</b>.&nbsp; Therefore, I strongly recommend that you study 
the earlier lesson titled &quot;A Framework for Experimenting with Java 2D 
Image-Processing Filters&quot; <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p>However, if you don't have the time to do that, you should take a look at the 
earlier lesson titled &quot;Using the Java 2D LookupOp Filter Class to Process 
Images&quot; <i>(see <a href="#Resources">Resources</a>)</i>, in which I summarized 
the behavior of the framework program named <b>ImgMod05</b>.</p>
<h3><a name="ConvolveOp_Examples">ConvolveOp Examples</a></h3>
<p>In my opinion, the <b>ConvolveOp</b> class is the weakest of the 
image-filtering classes in the Java 2D API.&nbsp; I will explain my reasons for this 
opinion later in the section titled <a href="#ConvolveOpAssessment">Assessment</a>.&nbsp; 
First, however, I will show you some examples of image convolution using the 
capabilities of the <b>ConvolveOp</b> class.</p>
<p><font color="#ff0000"><b>Edge treatment</b></font></p>
<p>When performing image convolution, you must always decide how you are going 
to treat the edges of the image.&nbsp; The <b>ConvolveOp</b> class provides the 
following choices:</p>
<ul>
	<li>Copy edge pixels in unmodified form</li>
	<li>Zero fill the edge pixels</li>
</ul>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Emphasizing edge treatment</b><br />
  The processed portion of the images in Figures 1 and 2 was purposely 
	blacked out or set to white to emphasize the treatment of the edges.
</td></tr></table>
</td>
</tr>
</table>
<p>Figures 1 and 2 show the results of electing 
each of those two choices.</p>
<p><font color="#ff0000"><b>Copy edge pixels in unmodified form</b></font></p>
<p>In Figure 1, the pixels at the edges 
of the input image were simply copied to the edges of the output image without 
modification.&nbsp; This is evidenced by the fact that the edges of the output image 
look just like the edges of the input image.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Illustration of an edge treatment option. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460d01.jpg" width="164" height="327"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#ff0000"><b>Zero fill the edge pixels</b></font></p>
<p>In Figure 2, the pixels at the edge 
of the output image were set to zero, producing the black border around the 
output image.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Illustration of another edge treatment 
	option.</b><table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460d02.jpg" width="164" height="327"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The remaining examples will use the first alternative and simply copy the 
pixels from the edges of the input image to the edges of the output image in 
unmodified form.</p>
<p><font color="#ff0000"><b>A flat 4x4 smoothing filter</b></font></p>
<p>Figure 3 shows the result of applying 
a flat 4x4 smoothing filter to the same image of a starfish that was used in the 
earlier lesson titled
&quot;Processing Image Pixels, Applying Image Convolution in Java&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Application of a flat 4x4 smoothing filter. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460d03.jpg" width="311" height="477"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you compare the output image in Figure 3 with Figure 18 in the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_18">
earlier lesson</a>, you will see good agreement.&nbsp; This is because none of the 
output color values fell outside the range from 0 to 255 inclusive, and it was 
not necessary to deal with the normalization issue that I will discuss later in 
the <a href="#ConvolveOpAssessment">Assessment</a> section.</p>
<p><font color="#ff0000"><b>An embossing filter</b></font></p>
<p>Figure 34 in the <a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a> presented the results of a convolution filtering process that 
was intended to produce an output that looks like embossed stationary.&nbsp;
Figure 4 shows the same process 
implemented using the <b>ConvolveOp</b> class.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Application of an embossing filter using 
	ConvolveOp. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460d04.jpg" width="311" height="477"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
</p>
<p><font color="#ff0000"><b>The differences are striking</b></font></p>
<p>The difference between the results shown in
Figure 4 above and Figure 34 in the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a> are striking.&nbsp; The difference lies solely in the <i>
normalization</i> scheme used to deal with convolution output values that fall 
outside the allowable range from 0 through 255 inclusive.</p>
<p><font color="#ff0000"><b>One approach is to simply clip the values</b></font></p>
<p>Apparently the <b>ConvolveOp</b> class simply clips those values at 0 and 
255.&nbsp; This is not a <i>safe</i> scheme because it throws away some of the 
output values replacing them by either 0 or 255.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Don't clip the data</b><br />
  When we perform digital signal processing <i>(DSP)</i> in the world of 
	signals, we usually try to avoid clipping the data.&nbsp; Clipping is a 
	nonlinear, non-reversible process, which is usually considered to be a bad 
	idea.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#ff0000"><b><a name="A_statistical_scheme">A statistical scheme</a></b></font></p>
<p>The scheme used in the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a>, on the other hand doesn't throw away any of the output 
values.&nbsp; Rather, the distribution of the output values is compressed, while 
maintaining its general shape, so as to cause all of the output values to fall 
within the allowable range.&nbsp; Thus, this is a <i>safe</i> scheme in that it 
doesn't throw away any information.</p>
<p><font color="#ff0000"><b>Another statistical scheme</b></font></p>
<p><a href="http://www.developer.com/java/ent/article.php/3590351#Figure_57">
Another image</a> in the earlier lesson shows the results for the same input 
image and the same convolution filter with still another normalization scheme.&nbsp; 
This scheme causes the mean and the standard deviation of the output to match 
the mean and the standard deviation of the input.&nbsp; As a result, some of the 
output values may still fall outside the acceptable limits.&nbsp; In that case, those 
values are simply clipped at 0 and 255, making this scheme less <i>safe</i> than 
the one described above, but 
probably more safe than simply clipping the output values at 0 and 255.</p>
<p><font color="#ff0000"><b><a name="ConvolveOpAssessment">Assessment</a></b></font></p>
<p>Earlier I indicated that in my opinion, the <b>ConvolveOp</b> class is the 
weakest of the image-filtering classes in the Java 2D API.&nbsp; Now I will explain 
my reasons for that opinion.</p>
<p><font color="#ff0000"><b>Output normalization is the real issue</b></font></p>
<p>In the earlier lesson titled
&quot;Processing Image 
Pixels, Applying Image Convolution in Java&quot; <i>(see <a href="#Resources">
Resources</a>)</i>, I explained that image 
convolution results can, and frequently do result in color values that fall 
outside the allowable color value range from 0 through 255 inclusive.&nbsp; Thus, the real issue in image 
convolution is not how to do the convolution arithmetic for a given convolution 
filter.&nbsp; The arithmetic 
algorithm for image convolution is almost trivial.&nbsp; The real issue for the 
serious image processor has to do with how you normalize the output values to:</p>
<ul>
	<li>Force them into the range from 0 through 255,</li>
	<li>Discard those that are outside the range from 0 through 255, or</li>
	<li>Some combination of the two</li>
</ul>
<p><font color="#ff0000"><b>Apparently the ConvolveOp class simply clips the 
output</b></font></p>
<p>Although the documentation for the <b>ConvolveOp</b> class doesn't indicate 
how the results are normalized, observation of the results suggests that values 
outside the acceptable range are simply clipped to values of 0 and 255.</p>
<p><font color="#ff0000"><b>Not necessarily the best approach</b></font></p>
<p>While that is the easiest approach to implement, it probably isn't the best 
approach from an image processing viewpoint.&nbsp; In fact, there probably isn't any 
one best approach.&nbsp; The normalization scheme that works best for one situation 
is likely to give way to a different normalization scheme for another 
situation.&nbsp; Unfortunately, simply clipping the output at 0 and 255 isn't likely 
to be the best approach for very many situations.</p>
<p><font color="#ff0000"><b>Two normalization schemes were described earlier</b></font></p>
<p>In the earlier lesson titled
&quot;Processing Image 
Pixels, Applying Image Convolution in Java&quot; <i>(see <a href="#Resources">
Resources</a>)</i>, I described two different 
normalization schemes that are based on the statistical distribution of the 
input and output color values.&nbsp; I showed that the choice of normalization scheme 
can have a dramatic effect on the visual results.</p>
<p><font color="#ff0000"><b>Would like optional normalization schemes in the 
ConvolveOp class</b></font></p>
<p>I would like to have seen a choice among several such normalization schemes 
provided by the <b>ConvolveOp</b> class instead of simply clipping the results 
to values of 0 and 255.&nbsp; In my opinion, simply clipping the results seriously 
limits the value of the <b>ConvolveOp</b> class for the serious image processor.&nbsp; 
Be that as it may, the remaining sections of this tutorial lesson will teach you 
how to use the <b>ConvolveOp</b> class for performing image convolution.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>General comments</b><br />
  General comments regarding the uses of classes such as this one can be found 
	in the class named <b>ImgMod038</b> in the lesson named &quot;Using the Java 2D 
	LookupOp Filter Class to Process Images&quot; <i>(see <a href="#Resources">
	Resources</a>)</i>.
</td></tr></table>
</td>
</tr>
</table>
<p>In this lesson, I will present and explain a Java class named I<b>mgMod42</b>.&nbsp; (<i>A complete listing of this class is shown in Listing 18 
near the end of the lesson.)</i>&nbsp; The purpose of this class is to 
illustrate the use of the <b>ConvolveOp</b> filter class of the Java 2D API.</p>
<p><font color="#FF0000"><b>Compatible with ImgMod05</b></font></p>
<p>The class named <b>ImgMod42</b> is compatible with the use of the driver 
program named <b>ImgMod05</b>.&nbsp; The driver program named <b>ImgMod05</b> 
displays the original and the modified image as shown in Figure 6.&nbsp; It also writes the modified 
image into an output file in JPEG format.&nbsp; The name of the output file is
<b>junk.jpg</b> and it is written into the current directory.</p>
<p><font color="#FF0000"><b>A user input GUI</b></font></p>
<p>Image processing programs such as this one may provide a GUI for data input 
making it possible for the user to modify the behavior of the image processing 
method each time the <b>Replot</b> button shown in Figure 6 is clicked.&nbsp; Such a GUI is 
provided for this program.&nbsp; Figure 5 shows a screen shot of the user input 
GUI.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Screen shot of the user input GUI. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460a01.jpg" width="469" height="401"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I will have more to say about the user input GUI later.</p>
<p><font color="#FF0000"><b>Typical program output</b></font></p>
<p>Figure 6 shows a screen shot of the program output produced by the input GUI values 
shown in Figure 5 in conjunction with an image file named <b>penny02.jpg</b>.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Screen shot of typical program output. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java460a02.jpg" width="243" height="523"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Usage information</b></font></p>
<p>Enter the following at the command line to run this program:</p>
<p><font face="monospace"><b>java ImgMod05 
ImgMod42 ImageFileName</b></font></p>
<p>If the program is unable to load the image file within 
ten seconds, it will abort with an error message.</p>
<p><font color="#FF0000"><b>The user input GUI</b></font></p>
<p>As can be seen in Figure 5, the program creates a GUI for user input containing:</p>
<ul>
	<li>User 
instructions</li>
	<li>Two radio buttons, which are used to select the treatment given to the 
edge of the image during the convolution process.</li>
	<li>Eighty-one individual text fields, which allow the user to specify the 
values of a 9x9 2Dconvolution filter.</li>
</ul>
<p><font color="#FF0000"><b>The 2D convolution filter</b></font></p>
<p>The program convolves a 
user-specified image with a user-specified 2D convolution filter 
having up to 81 filter coefficients, nine along each dimension.&nbsp; </p>
<p>Figure 5 
shows the user input values for such a two-dimensional convolution filter, with 
all but one of the filter coefficient values being 0.0.&nbsp; The remaining 
filter coefficient is shown at the center of the matrix in Figure 5 with a value 
of 1.0.</p>
<p>The user-specified 9x9 convolution 
filter is used to filter the image each time the <b>Replot</b> button shown in 
Figure 6 is clicked.</p>
<p><font color="#FF0000"><b>Filter initialization</b></font></p>
<p>The convolution filter values are initialized 
at startup to a set of values that will simply pass the input image through to the output without modification.&nbsp; 
To accomplish this, the 
filter is initialized at startup with a value of 1.0 at the center and values of 0.0 in all 
other locations.&nbsp; <i>(This is the filter shown in Figure 5.)</i>&nbsp; This 
filter simply reproduces the input image in the output as shown in Figure 6.&nbsp;
<i>(The image format shown in Figure 6 has the input image at the top and the 
output image at the bottom.)</i></p>
<p><font color="#FF0000"><b>User input filter values</b></font></p>
<p>The user specifies the convolution filter coefficient values by 
changing the individual filter values in the 9x9 matrix shown in Figure 5.&nbsp; It is not necessary for the user to change 
all 81 filter values.&nbsp; Although they do consume some computing resources, filter coefficients having a value of 0.0 contribute nothing 
to the output image.</p>
<p><font color="#FF0000"><b>What happens when convolution values are out of the 
allowable range?</b></font></p>
<p>As mentioned earlier, it is unclear in the documentation what happens to the color values 
for an output image pixel 
if the value resulting from the convolution process falls outside the range from 
0 to 255.&nbsp; However, observation of the results suggests that those values are 
simply clipped at 0 and 255.</p>
<p>This program was tested using J2SE 6 under WinXP.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<font color="#FF0000"><b>Will discuss in fragments</b></font><p>A complete 
listing of this class is presented in Listing 18.&nbsp; As is my custom, I will 
present and explain this class in fragments.</p>
<p><font color="#FF0000"><b>Beginning of the class definition</b></font></p>
<p>The class definition begins in the first program fragment shown in Listing 1.&nbsp; 
Note that it is necessary for this class to implement the interface named <b>
ImgIntfc05</b> in order to be compatible with the driver program named <b>
ImgMod05</b>.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the class definition.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod42 extends Frame implements ImgIntfc05{
  
  Panel mainPanel = new Panel();//main control panel
  
  CheckboxGroup radioButtonGroup = new CheckboxGroup();
  Checkbox edgeNoOp = new Checkbox(
     "Copy Edge Pixels Unmodified",radioButtonGroup,true);
  Checkbox edgeZeroFill = new Checkbox(
          "Zero-Fill Edge Pixels",radioButtonGroup,false);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 1 begins the instantiation of components that are used to construct the main 
control panel portion of the user input GUI.&nbsp; Components that require local access only are defined locally.&nbsp; Others are defined as instance variables.</p>
<p>In addition to instantiating the main control panel object, Listing 1 
instantiates a pair of radio buttons that are used to specify the treatment of the pixels at the edge of the image.&nbsp; 
These two radio buttons are shown near the center of Figure 5.</p>
<p><font color="#FF0000"><b>An array of TextField objects</b></font></p>
<p>Listing 2 instantiates an array of <b>TextField</b> objects that are used for 
specifying matrix/convolution filter values.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. The 9x9 convolution filter matrix.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  TextField[][] matrixField = new TextField[9][9];</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This 9x9 matrix of <b>TextField</b> objects is visible immediately below the 
radio buttons in Figure 5.</p>
<p><font color="#FF0000"><b>A Label object for error notification</b></font></p>
<p>Listing 3 instantiates and populates a <b>Label</b> object that is used to notify of data entry errors.&nbsp; 
This label is shown in the green area at the bottom of Figure 5.&nbsp; In the 
event of a data entry error, this area turns red and displays the message &quot;Bad 
input data for the convolution filter.&quot;</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Instantiation of Label object for display 
of data entry errors. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  String okMessage = "No data entry errors detected.";
  Label errorMsg = new Label(okMessage);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The primary constructor</b></font></p>
<p>Listing 4 shows the primary constructor.&nbsp; This constructor calls another 
method to construct the main control panel so as to separate the construction of 
the GUI into easily understandable units.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. The primary constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  ImgMod42(){//constructor
  
    constructMainPanel();
    add(mainPanel);

    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(555,0,470,400);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 4 is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>Constructing the main control panel</b></font></p>
<p>Listing 5 begins the definition of the method named <b>constructMainPanel</b>.&nbsp; This method constructs the main 
control panel containing all of the controls in the user input GUI.&nbsp; This method is called from the primary 
constructor shown in Listing 4.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the method named constructMainPanel.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void constructMainPanel(){
    mainPanel.setLayout(new BorderLayout());
    
    String text ="CONVOLUTION\n"
      + "Enter convolution filter values into the text "
      + "fields and click the Replot button.\n\n"
      + "It is not necessary to enter a value into every "
      + "text field.\n\n"
      + "The filter must have at least one non-zero "
      + "value.  Otherwise, a single filter value will "
      + "be automatically set to 0.01, preventing an "
      + "Exception, but causing the output image to be "
      + "very dark";
      
    TextArea textArea = new TextArea(text,7,1,
                                TextArea.SCROLLBARS_NONE);
    mainPanel.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>After setting the layout manager, Listing 5 creates and adds the instructional text to 
a <b>TextArea</b> object in the panel.&nbsp; This text appears in a disabled text area at the top of the 
panel as shown in Figure 5.</p>
<p>Note that the number of columns specified for the <b>TextArea</b> in Listing 
5 is immaterial because the <b>TextArea</b> object is placed in the <b>NORTH</b> location of a
<b>BorderLayout</b>.&nbsp; Therefore, it will always fill the available horizontal space.</p>
<p><font color="#FF0000">
<b>Create panel for radio buttons and text fields</b></font></p>
<p>Listing 6 creates a panel that contains the radio buttons and the text fields into which the user enters convolution coefficient values.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Creation of the panel for radio buttons 
and text fields. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Panel controlPanel = new Panel();
    controlPanel.setLayout(new BorderLayout());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create and populate a sub-panel for the radio buttons</b></font></p>
<p>Listing 7 creates and populates a sub-panel that contains the radio buttons.&nbsp; 
It is populated with check boxes that behave like radio buttons.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Creation and population of a sub-panel for 
the radio buttons. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Panel radioButtonPanel = new Panel();
    radioButtonPanel.add(edgeNoOp);
    radioButtonPanel.add(edgeZeroFill);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the sub-panel that contains the text fields</b></font></p>
<p>Listing 8 creates a sub-panel that will contain the text fields into which 
the user enters convolution filter coefficient values.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Creation of a sub-panel that contains the text fields.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Panel textFieldPanel = new Panel();
    textFieldPanel.setLayout(new GridLayout(9,9));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Populate and initialize the array of TextField objects</b></font></p>
<p>Listing 9 populates and initializes the array of <b>TextField</b> objects for 
the convolution filter coefficients, with all zero values and adds them to their 
panel.<b>&nbsp; matrixField</b> is a reference to a 9x9 array object tree 
populated with <b>TextField</b> objects.&nbsp; <b>textFieldPanel</b> is a <b>
Panel</b> object with a 9x9 grid layout.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Population and initialization of the array of TextField objects.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    for(int row = 0;row &lt; matrixField.length;row++){
      for(int col = 0;col &lt; matrixField[0].length;col++){
        matrixField[row][col] = new TextField("0.0",6);
        textFieldPanel.add(matrixField[row][col]);
      }//end inner loop
    }//end outer loop
    
    matrixField[4][4].setText("1.0");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Finally, Listing 9 initializes one <b>TextField</b> object with a value of 
1.0 <i>(as shown in Figure 5)</i> so as to create a convolution filter that simply copies the input image to the output.</p>
<p><font color="#FF0000"><b>Complete construction of the user input GUI</b></font></p>
<p>Listing 10 completes the construction of the user input GUI.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Complete the construction of the user 
input GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Populate the control panel.
    controlPanel.add(radioButtonPanel,BorderLayout.NORTH);
    controlPanel.add(textFieldPanel,BorderLayout.CENTER);

    //Finish populating the main panel.
    mainPanel.add(controlPanel,BorderLayout.CENTER);
    
    //Add the errorMsg label.
    mainPanel.add(errorMsg,BorderLayout.SOUTH);
    errorMsg.setBackground(Color.GREEN);
  }//end constructMainPanel</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>All of the code in Listing 10 is straightforward and shouldn't require 
further explanation.</p>
<p><font color="#FF0000"><b>The processMainPanel method</b></font></p>
<p>Listing 11 shows the beginning of the <b>processMainPanel</b> method.&nbsp; 
This method processes the image according to the filter values provided by the 
user.&nbsp; This method uses the <b>ConvolveOp</b> filter class to process the 
image.&nbsp; The <b>processMainPanel</b> method is called from within the method 
named <b>processImg</b>, which is the primary image processing method in this 
program.&nbsp; The method named <b>processImg</b> is called by the driver 
program named <b>ImgMod05</b>.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Beginning of the processMainPanel 
method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  BufferedImage processMainPanel(BufferedImage theImage){
    
    //Reset the error message to the default.
    errorMsg.setText(okMessage);
    errorMsg.setBackground(Color.GREEN);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Convert the 2D convolution filter into a 1D array</b></font></p>
<p>Listing 12 converts the matrix/convolution filter into a one-dimensional 
array.&nbsp; This is the format required for input to the constructor for the <b>
Kernel</b> class, which is used to pass the convolution coefficients into the 
filtering process. </p>
<p>Listing 12 tests for all zero values and values that can't be converted to 
numeric format in the process of converting to a one-dimensional array.&nbsp; If 
either condition is detected, Listing 12 creates a set of convolution 
coefficients having a single very small value.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Conversion of the 2D convolution filter 
into a 1D array. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    boolean zeroTest = true;
    float[] matrix = new float[
              matrixField.length * matrixField[0].length];
    int matrixCnt = 0;
    try{
      for(int row = 0;row &lt; matrixField.length;row++){
        for(int col = 0;col &lt; matrixField[0].length;
                                       col++,matrixCnt++){
          matrix[matrixCnt] = Float.parseFloat(
                         matrixField[row][col].getText());
          if(matrix[matrixCnt] != 0.0f){
            zeroTest = false;
          }//end if
        }//end col loop
      }//end row loop
    }catch(java.lang.NumberFormatException e){
      //Bad input data for the convolution filter. Cause
      // the output image to be very dark so that it will
      // be obvious to the user that there is a problem.
      // Also cause the label containing the error message
      // to turn from green to red.
      matrixCnt = 0;
      for(int row = 0;row &lt; matrixField.length;row++){
        for(int col = 0;col &lt; matrixField[0].length;
                                       col++,matrixCnt++){
          matrix[matrixCnt] = 0.0f;
        }//end col loop
      }//end row loop
      //Set one filter coefficient to a non-zero, very
      // small value.
      matrix[0] = 0.01f;
      errorMsg.setText(
            "Bad input data for the convolution filter.");
      errorMsg.setBackground(Color.RED);
    }//end catch</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although the code in Listing 12 is somewhat complicated, there is nothing in 
Listing 12 that is new to this lesson, so a detailed explanation of Listing 12 
shouldn't be necessary</p>
<p><font color="#FF0000">
<b>Correct for all filter values equal to 0.0f</b></font></p>
<p>If all of the filter values are 0.0f, Listing 13 causes one value to be a 
very small non-zero value and displays an error message.&nbsp; This will prevent 
the program from throwing an exception when it tries to perform a convolution 
operation using a convolution filter having all zero values.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Correct for all filter values equal to 
0.0f. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    if(zeroTest){
      matrix[0] = 0.1f;
      errorMsg.setText(
            "Bad input data for the convolution filter.");
      errorMsg.setBackground(Color.RED);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Set the edge treatment parameters</b></font></p>
<p>Listing 14 uses the state of the radio buttons to establish the manner in 
which the edge of the image will be treated during the convolution process.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Setting the edge treatment parameters. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    int edgeTreatment;
    if(edgeZeroFill.getState() == true){
      edgeTreatment = ConvolveOp.EDGE_ZERO_FILL;
    }else{//edgeNoOp must have been selected
      edgeTreatment = ConvolveOp.EDGE_NO_OP;
    }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the ConvolveOp filter</b></font></p>
<p>Listing 15 begins by creating the required <b>ConvolveOp</b> filter object 
that will be used to convolve the image with the filter.&nbsp; It creates the 
required <b>Kernel</b> object as an anonymous object in the parameter list for 
the <b>ConvolveOp</b> constructor.&nbsp; The third parameter to the constructor 
with a value of null is for &quot;rendering hints,&quot; which are not used by this 
program, but which have been briefly discussed in earlier lessons.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Creation of the ConvolveOp filter. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    ConvolveOp filterObj = new ConvolveOp(
                         new Kernel(matrixField.length,
                                    matrixField[0].length,
                                    matrix),
                         edgeTreatment,
                         null);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Apply the filter and return the filtered image</b></font></p>
<p>It all comes down to this.&nbsp; After the <b>ConvolveOp</b> filter object 
has been created, Listing 16 calls the <b>filter</b> method on the <b>ConvolveOp</b> 
filter object to apply the convolution filter to the image.&nbsp; All of the 
code discussed prior to this point was required just to get ready to perform the 
convolution.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Apply the ConvolveOp filter and return 
the filtered image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    return filterObj.<b>filter</b>(theImage,null);

  }//end processMainPanel</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The kernel was created using the filter coefficient values provided by the 
user.&nbsp; The <b>filter</b> method convolves the image with the kernel, 
returning the filtered image as type <b>BufferedImage</b>.&nbsp; This filtered 
image is immediately returned by the <b>processMainPanel</b> method.</p>
<p>The second parameter to the <b>filter</b> method with a value of null allows 
the filtered image to be deposited in a separate destination <b>BufferedImage</b> 
object.&nbsp; This feature was not used in this program.</p>
<p><font color="#FF0000">
<b>The required processImg method</b></font></p>
<p>The <b>processImg</b> method shown in Listing 17 must be defined to implement the
<b>ImgIntfc05</b> interface.&nbsp; This method is called by the driver program named
<b>ImgMod05</b>.&nbsp; This method has been discussed in numerous earlier 
lessons in this series and shouldn't require further discussion in this lesson.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. The required processImg method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public BufferedImage processImg(BufferedImage theImage){
    BufferedImage outputImage = 
                               processMainPanel(theImage);
    return outputImage;
  }//end processImg
}//end class ImgMod42</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>And that is the end of the class named <b>ImgMod42</b> and the end of the 
program.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 18 into your text
editor, compile it, and execute it.&nbsp; Experiment with it, making
changes, and observing the results of your changes.</p>
<p>Keep in mind that you will also need to compile and use the program named <b>
ImgMod05</b>.&nbsp; You will find the source code for <b>ImgMod05</b> in the 
earlier lesson titled &quot;A Framework for Experimenting with Java 2D 
Image-Processing Filters&quot; <i>(see Resources)</i>.</p>
<p>My recommendation is that you:</p>
<ul>
	<li>Go back and review some of my earlier lessons on image convolution 
	that did not use the <b>ConvolveOp</b> class to perform the convolution.</li>
	<li>Use the convolution filters that I explained in those lessons in 
	conjunction with this program in an attempt to replicate the results 
	produced by those programs.</li>
	<li>See if you can understand why the different approaches produce similar 
	results when they do, and why they don't provide similar results when they 
	don't.</li>
</ul>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I provided and explained an image-processing class named <b>
ImgMod42</b> that is compatible with the framework program named <b>ImgMod05</b>.</p>
<p>The purpose of this class is to teach you how to write programs that use the
<b>ConvolveOp</b> class of the Java 2D API to perform two-dimensional image 
convolution.</p>
<p>I also explained some of the weaknesses of the <b>ConvolveOp</b> class that 
result from a lack of options for dealing with convolution output values greater 
than 255 and less than 0.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>Future lessons in this series will teach you how to use the following 
image-filtering classes from the Java 2D API: </p>
<ul>
	<li><b>RescaleOp</b> </li>
	<li><b>ColorConvertOp</b></li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the class discussed in this lesson is shown in
Listing 18 below.
<p>
<b><a name="Listing_18">Listing 18</a>. Complete listing for the class named 
ImgMod42. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod42.java
Copyright 2007, R.G.Baldwin

The purpose of this class is to illustrate the use of the 
ConvolveOp filter class of the Java 2D API.

See general comments in the class named ImgMod038 in the
lesson named "Using the Java 2D LookupOp Filter Class to 
Process Images".

This class is compatible with the use of the driver 
program named ImgMod05.

The driver program named ImgMod05 displays the original 
and the modified image.  It also writes the modified image
into an output file in JPEG format.  The name of the 
output file is junk.jpg and it is written into the current
directory.

Image processing programs such as this one may provide a 
GUI for data input making it possible for the user to 
modify the behavior of the image processing method each 
time the Replot button is clicked.  Such a GUI is provided
for this program.

Enter the following at the command line to run this 
program:

java ImgMod05 ImgMod42 ImageFileName

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

This program convolves a user-specified image with a 
user-specified two-dimensional convolution filter having 
up to 81 filter coefficients, nine along each dimension.

A 9x9 convolution filter is used to filter the image each 
time the Replot button is clicked.  The filter is 
initialized with a value of 1.0 at the center and values 
of 0.0 in all other locations.  The user specifies the 
convolution filter coefficient values by changing the 
individual filter values. It is not necessary for the user
to change all 81 filter values.  Filter coefficients
having a value of 0.0 contribute nothing to the output.

The program creates a GUI for user input containing:
User instructions
Two radio buttons used to select the type of treatment 
 given to the edge of the image during the convolution 
 process.
Text fields used to specify the values of a 9x9 
 convolution filter.

The convolution filter values are initialized so as to 
simply pass the input image through to the output 
without modification.

It is unclear in the documentation what happens to the 
color value if the value resulting from the convolution
process falls outside the range from 0 to 255.  However, 
observation of the results suggests that those values are 
clipped at 0 and 255.

Tested using J2SE 6 under WinXP.
*********************************************************/

import java.awt.image.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class ImgMod42 extends Frame implements ImgIntfc05{
  
  //Components used to construct the main panel.
  // Components that require local access only are defined
  // locally.  Others are defined here as instance
  // variables.
  Panel mainPanel = new Panel();//main control panel
  
  //A pair of radio buttons used to specify the treatment
  // of the pixels at the edge of the image.
  CheckboxGroup radioButtonGroup = new CheckboxGroup();
  Checkbox edgeNoOp = new Checkbox(
     "Copy Edge Pixels Unmodified",radioButtonGroup,true);
  Checkbox edgeZeroFill = new Checkbox(
          "Zero-Fill Edge Pixels",radioButtonGroup,false);

  //An array of TextField objects for specifying
  // matrix/convolution filter values.  Normally, I would
  // refer to the data entered into these TextField
  // objects simply as the filter.  However, in order to
  // distinguish between the convolution filter, and the
  // filter method of the ConvolveOp class, in most cases,
  // I will refer to the data as a matrix.
  TextField[][] matrixField = new TextField[9][9];

  //The following Label is used to notify of data entry
  // errors.
  String okMessage = "No data entry errors detected.";
  Label errorMsg = new Label(okMessage);
  //----------------------------------------------------//
  
  //This is the primary constructor.  It calls another
  // method to construct the main panel so as to separate
  // the construction of the GUI into easily
  // understandable units.
  ImgMod42(){//constructor
  
    constructMainPanel();
    add(mainPanel);

    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(555,0,470,400);
    setVisible(true);

    //Define a WindowListener to terminate the program.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(1);
        }//end windowClosing
      }//end windowAdapter
    );//end addWindowListener
  }//end constructor
  //----------------------------------------------------//
  
  //This method constructs the main panel containing all
  // of the controls.  This method is called from the
  // primary constructor.
  void constructMainPanel(){
    mainPanel.setLayout(new BorderLayout());
    
    //Create and add the instructional text to the panel.
    // This text appears in a disabled text area at the
    // top of the panel.
    String text ="CONVOLUTION\n"
      + "Enter convolution filter values into the text "
      + "fields and click the Replot button.\n\n"
      + "It is not necessary to enter a value into every "
      + "text field.\n\n"
      + "The filter must have at least one non-zero "
      + "value.  Otherwise, a single filter value will "
      + "be automatically set to 0.01, preventing an "
      + "Exception, but causing the output image to be "
      + "very dark";
      
    //Note:  The number of columns specified for the
    // following TextArea is immaterial because the
    // TextArea object is placed in the NORTH location of
    // a BorderLayout.  Therefore, it will always fill the
    // available horizontal space.
    TextArea textArea = new TextArea(text,7,1,
                                TextArea.SCROLLBARS_NONE);
    mainPanel.add(textArea,BorderLayout.NORTH);
    textArea.setEnabled(false);
    
    //Create the panel that contains the radio buttons
    // and the text fields into which the user enters
    // convolution coefficient values.
    Panel controlPanel = new Panel();
    controlPanel.setLayout(new BorderLayout());
    
    //Create and populate the sub-panel that contains
    // the radio buttons. Populate it with check boxes
    // that behave like radio buttons.
    Panel radioButtonPanel = new Panel();
    radioButtonPanel.add(edgeNoOp);
    radioButtonPanel.add(edgeZeroFill);

    //Create the sub-panel that contains the text fields.
    Panel textFieldPanel = new Panel();
    textFieldPanel.setLayout(new GridLayout(9,9));

    //Populate and initialize the array of TextField
    // objects for the convolution filter, with all zero
    // values and add them to their panel. matrixField
    // is a reference to a 9x9 array object tree
    // populated with TextField objects. textFieldPanel
    // is a Panel object with a 9x9 grid layout.
    for(int row = 0;row &lt; matrixField.length;row++){
      for(int col = 0;col &lt; matrixField[0].length;col++){
        matrixField[row][col] = new TextField("0.0",6);
        textFieldPanel.add(matrixField[row][col]);
      }//end inner loop
    }//end outer loop
    
    //Initialize one TextField object so as to create a
    // filter that simply copies the input image to the
    // output.
    matrixField[4][4].setText("1.0");
    
    //Populate the control panel.
    controlPanel.add(radioButtonPanel,BorderLayout.NORTH);
    controlPanel.add(textFieldPanel,BorderLayout.CENTER);

    //Finish populating the main panel.
    mainPanel.add(controlPanel,BorderLayout.CENTER);
    
    //Add the errorMsg label.
    mainPanel.add(errorMsg,BorderLayout.SOUTH);
    errorMsg.setBackground(Color.GREEN);
  }//end constructMainPanel
  //----------------------------------------------------//

  //This method processes the image according to the
  // filter values provided by the user.
  //The method uses the ConvolveOp filter class to
  // process the image.  The method is called from within
  // the method named processImg, which is the primary
  // image processing method in this program.
  BufferedImage processMainPanel(BufferedImage theImage){
    
    //Reset the error message to the default.
    errorMsg.setText(okMessage);
    errorMsg.setBackground(Color.GREEN);

    //Now convert the matrix/convolution filter into a
    // one-dimensional array. This is the required format
    // for input to the constructor for the Kernel class,
    // which is  used to pass the convolution
    // coefficients into the filtering process.    
    //Test for all zero values and values that can't be
    // converted to numeric format in the process of
    // converting to a one-dimensional array. If either
    // condition is detected, create a set of
    // convolution coefficients having a single very small
    // value.
    boolean zeroTest = true;
    float[] matrix = new float[
              matrixField.length * matrixField[0].length];
    int matrixCnt = 0;
    try{
      for(int row = 0;row &lt; matrixField.length;row++){
        for(int col = 0;col &lt; matrixField[0].length;
                                       col++,matrixCnt++){
          matrix[matrixCnt] = Float.parseFloat(
                         matrixField[row][col].getText());
          if(matrix[matrixCnt] != 0.0f){
            zeroTest = false;
          }//end if
        }//end col loop
      }//end row loop
    }catch(java.lang.NumberFormatException e){
      //Bad input data for the convolution filter. Cause
      // the output image to be very dark so that it will
      // be obvious to the user that there is a problem.
      // Also cause the label containing the error message
      // to turn from green to red.
      matrixCnt = 0;
      for(int row = 0;row &lt; matrixField.length;row++){
        for(int col = 0;col &lt; matrixField[0].length;
                                       col++,matrixCnt++){
          matrix[matrixCnt] = 0.0f;
        }//end col loop
      }//end row loop
      //Set one filter coefficient to a non-zero, very
      // small value.
      matrix[0] = 0.01f;
      errorMsg.setText(
            "Bad input data for the convolution filter.");
      errorMsg.setBackground(Color.RED);
    }//end catch
    
    //If all filter values are 0.0f, cause one value to
    // be a very small non-zero value and display an
    // error message. This will prevent the program from
    // throwing an exception when it tries to perform a
    // convolution operation using a convolution filter
    // having all zero values.
    if(zeroTest){
      matrix[0] = 0.1f;
      errorMsg.setText(
            "Bad input data for the convolution filter.");
      errorMsg.setBackground(Color.RED);
    }//end if
    
    //Use the state of the radio buttons to set the manner
    // in which the edge of the image will be treated
    // during the convolution process.
    int edgeTreatment;
    if(edgeZeroFill.getState() == true){
      edgeTreatment = ConvolveOp.EDGE_ZERO_FILL;
    }else{//edgeNoOp must have been selected
      edgeTreatment = ConvolveOp.EDGE_NO_OP;
    }//end else
    
    //Create the filter object. Create the Kernel object
    // as an anonymous object in the parameter list for
    // the ConvolveOp constructor.
    ConvolveOp filterObj = new ConvolveOp(
                         new Kernel(matrixField.length,
                                    matrixField[0].length,
                                    matrix),
                         edgeTreatment,
                         null);
    //Apply the filter and return the filtered image
    return filterObj.filter(theImage,null);

  }//end processMainPanel
  //----------------------------------------------------//

  //The following method must be defined to implement the
  // ImgIntfc05 interface.  It is called by the driver
  // program named ImgMod05.
  public BufferedImage processImg(BufferedImage theImage){
    BufferedImage outputImage = 
                               processMainPanel(theImage);
    return outputImage;
  }//end processImg
}//end class ImgMod42</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight</li>
	<li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</li>
	<li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion</li>
	<li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java</li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1</li>
	<li><a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2</li>
	<li><a href="http://www.developer.com/java/other/article.php/3640776">416</a> 
	Processing Image Pixels, An Improved Image-Processing Framework in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3645761">450</a> 
	A Framework for Experimenting with Java 2D Image-Processing Filters</li>
	<li><a href="http://www.developer.com/java/other/article.php/3654171">452</a> 
	Using the Java 2D LookupOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3670696">454</a> 
	Using the Java 2D AffineTransformOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3681466">456</a> 
	Using the Java 2D LookupOp Filter Class to Scramble and Unscramble Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3686856">458</a> Using the Java 2D BandCombineOp Filter Class to Process Images</li>
</ul>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java 2D image pixel framework filter&nbsp;ConvolveOp </p>
<p>-end- </p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
