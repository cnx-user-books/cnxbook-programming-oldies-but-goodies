<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Data Structures in Java: Part 1, Getting Started</h2>
<i>Baldwin introduces you to the Java Collections Framework.&nbsp; Once
you learn how to use the framework, it is unlikely that you will need to
reinvent common data structures, search algorithms, or sorting algorithms
again, because those capabilities are neatly packaged within the framework.</i>
<p><b>Published:</b> May 7, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1350
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Sample Program">Sample Program</a></li>

<li>
<a href="#Interesting Code Fragments">Interesting Code Fragments</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This is the first lesson in a new miniseries on Java data structures and
the Java Collections Framework.
<p>The purpose of this miniseries is to help you learn the essential features
of Object-Oriented data structures in Java using the <i>Collections Framework</i>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings while you are reading about them.
<p><b><font color="#FF0000">Recommended supplementary reading</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes my lessons are difficult
to locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at </font><a href="http://softwaredev.earthweb.com/java">Gamelan.com</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
This lesson provides a brief introduction to the use of the Java Collections
Framework.&nbsp; The framework is designed to encourage you to reuse rather
than to reinvent collections and maps.
<p>A collection represents a group of objects, known as its elements.&nbsp;
Some collections allow duplicate elements while others do not. Some collections
are ordered and others are not.&nbsp; <i>(Maps will be discussed in subsequent
lessons.)</i>
<p>The Collections Framework is defined by a set of interfaces and associated
contracts, and provides concrete implementations of the interfaces for
the most common data structures.&nbsp; In addition, the framework also
provides several abstract implementations, which are designed to make it
easier for you to create new and different implementations while still
maintaining the structural polymorphic integrity of the framework.
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
<b><font color="#FF0000">A little quiz</font></b>
<p>Let's begin with a little quiz to establish your baseline knowledge
of the Collections Framework.&nbsp; Take a look at the program in Listing
6 near the end of this lesson.&nbsp; Which of the following is the output
produced by that program?
<ul>
<li>
A.&nbsp; Compiler Error</li>

<li>
B.&nbsp; Runtime Error</li>

<li>
C.&nbsp; 44321</li>

<li>
D. 12344</li>

<li>
E. 1234</li>

<li>
F.&nbsp; None of the above.</li>
</ul>
<font color="#000000">If your answer was <b>1234</b> then you already know
quite a lot about the use of the Collections Framework.&nbsp; If not, keep
reading to begin learning about the framework.</font>
<p><b><font color="#FF0000">Elements of the Framework are easy to use</font></b>
<p>This simple introductory program is not intended to do anything particularly
useful.&nbsp; Rather, it was designed to illustrate several important features
of the framework, including the ease with which elements of the framework
can be reused in your programs.
<p><b><font color="#FF0000">Don't reinvent the wheel</font></b>
<p>As many of you already know, I am a college professor.&nbsp; I specialize
in teaching OOP using Java.&nbsp; In the past, many college courses in
Data Structures <i>(often referred to as CS2 courses)</i> have emphasized
the concept of <i>reinventing the wheel</i>.&nbsp; Students were required
to learn how to reinvent a variety of complex data structures in order
to successfully complete the course.
<p><b><font color="#FF0000">Hopefully a change is in the works</font></b>
<p>Hopefully, with the conversion of these CS2 courses to Java OOP, the
emphasis will change to <i>reuse</i> instead of <i>reinvent</i>.
<p>Unfortunately, most of the CS2 Java textbooks that I have seen so far
look like warmed-over textbooks from the days of Pascal, C, and C++.&nbsp;
Many look like they were written using cut-and-paste technology to update
an old Pascal, C, or C++ textbook to incorporate a little Java OOP.&nbsp;
Most of the textbooks that I have seen include only enough Java OOP to
avoid violating <i>truth in advertising</i> requirements.&nbsp; They still
emphasize
<i>reinvent</i> instead of <i>reuse</i>.
<p><b><font color="#FF0000">Collections Framework encourages reuse</font></b>
<p>The Java Collections Framework is designed to encourage programmers
to reuse existing interfaces and classes instead of inventing new ones.&nbsp;
In the event that it is necessary to invent a new class or interface, the
programmer is encouraged to integrate it into the Framework in a polymorphic
manner.
<center>
<h2>
<a NAME="Sample Program"></a><font color="#000000">Sample Program</font></h2></center>
<font color="#000000">I am going to provide a brief discussion of the sample
program <i>(shown in Listing 6)</i> in this lesson.&nbsp; Later, I will
provide more detailed discussions of many of the features used in that
program.</font>
<center>
<h2>
<a NAME="Interesting Code Fragments"></a><font color="#000000">Interesting
Code Fragments</font></h2></center>
I will break this program down and discuss it in fragments.
<p><b><font color="#FF0000">An object of the TreeSet class</font></b>
<p>The code fragment in Listing 1 instantiates an object of the <b>TreeSet</b>
class and stores the object's reference in a reference variable of type
<b>Collection</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">class Worker{
&nbsp; public void doIt(){
&nbsp;&nbsp;&nbsp; <b>Collection</b> ref = new <b>TreeSet</b>();

<b>Listing 1</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Collection is an interface</font></b>
<p>The <b>TreeSet</b> class implements the <b>SortedSet</b> interface,
which extends the <b>Set</b> interface, which in turn extends the <b>Collection</b>
interface.&nbsp; Thus, a <b>TreeSet</b> object <i>is a</i> <b>Collection</b>.&nbsp;
Therefore, a reference to a <b>TreeSet</b> object can be stored in a reference
variable of type <b>Collection</b>, and can be treated as the generic type
<b>Collection</b>.
<p><b><font color="#FF0000">What is a TreeSet object?</font></b>
<p>Among other things, in CS2 courses, we worry about the time and memory
cost of a collection.&nbsp; According to Sun, the <b>TreeSet</b> class
guarantees that the sorted set will be in ascending element order, and
provides guaranteed log(n) time cost for the basic operations (<i>add</i>,
<i>remove</i>
and <i>contains</i>).
<p><b><font color="#FF0000">What does ascending element order mean?</font></b>
<p>Again, according to Sun, the elements will be sorted according to the
<i>natural
order</i> of the elements <i>(see the Comparable interface)</i> or by a
comparator <i>(see the Comparator interface)</i> provided at the time the
set is created.&nbsp; This depends on which overloaded constructor is used.&nbsp;
I will have more to say about these alternatives in a subsequent lesson.
<p><b><font color="#FF0000">What does log(n) time cost mean?</font></b>
<p>I'm not going to try to explain the details of log(n) time cost here.&nbsp;
Suffice it to say that the <i>add</i>, <i>remove</i>, and <i>contains</i>
methods execute very fast.&nbsp; <i>(I will have more to say about this
is a subsequent lesson.)</i>
<p><b><font color="#FF0000">A TreeSet object is a Set</font></b>
<p>An object of the <b>TreeSet</b> class also <i>is a</i> <b>Set</b>.&nbsp;
One of the characteristics of a Java <b>Set</b> <i>(an object that implements
the Set interface)</i> is that it can contain no duplicate elements.&nbsp;
Therefore, a <b>TreeSet</b> object can contain no duplicate elements.&nbsp;
If the <b>add()</b> method of a <b>TreeSet</b> object is invoked in an
attempt to add a duplicate element, the element will not be added.
<p><b><font color="#FF0000">A TreeSet object is a SortedSet</font></b>
<p>The <b>TreeSet</b> class also implements the <b>SortedSet</b> interface.&nbsp;
This guarantees that the contents of a <b>TreeSet</b> object will be in
ascending element order, regardless of the order in which the elements
are added.&nbsp; <i>(In a subsequent lesson, I will discuss how comparisons
are made to enforce the ordering of the elements.)</i>
<p><b><font color="#FF0000">A TreeSet object is a Collection</font></b>
<p>Because an object of the <b>TreeSet</b> class <i>is a</i> <b>Collection</b>,
a reference to such an object can be passed to any method that requires
an incoming parameter of type <b>Collection</b>.&nbsp; The receiving method
can invoke any method on that reference that is declared in the <b>Collection</b>
interface<b>.
</b><i>(I will discuss such methods in detail in subsequent
lessons.)</i>
<p><b><font color="#FF0000">Populate the Collection</font></b>
<p>The statement in Listing 2 below passes the <b>TreeSet</b> object's
reference to a method named <b>fillIt()</b>, which is a class method of
the <b>Populator</b> class.&nbsp; <i>(The Populator class is a class of
my own design whose only purpose is to illustrate the polymorphic behavior
achieved using the Collections Framework.)</i>&nbsp; The behavior of this
method is to add elements to the incoming <b>Collection</b> object without
regard for the actual type of the object <i>(the class from which the object
was instantiated).</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Populator.<b>fillIt</b>(ref);

<b>Listing 2</b></font></pre>
</td>
</tr>
</table>

<p>At this point, I am going to discuss the <b>fillIt()</b> method of the
<b>Populator</b>
class invoked in the above fragment.&nbsp; The entire class definition
of the <b>Populator</b> class is shown in Listing 3 below.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">class <b>Populator</b>{
&nbsp; public static void <b>fillIt</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Collection</b> ref){
&nbsp;&nbsp;&nbsp; ref.<b>add</b>(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(3));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(2));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(1));
&nbsp; }//end fillIt()
}//end class populator

<b>Listing 3</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Don't know, don't care</font></b>
<p>As you can see in the above fragment, the <b>fillIt()</b> method receives
the reference to the <b>TreeSet</b> object as type <b>Collection</b>.&nbsp;
This method doesn't know, and doesn't care, what the actual type of the
object is.&nbsp; All it cares about is that the object <i>is a</i> <b>Collection</b>
object.&nbsp; <i>(Otherwise, the object's reference couldn't be passed
in as a parameter.&nbsp; A type mismatch would occur.)</i>
<p>Because the incoming parameter is a reference to a <b>Collection</b>
object, the <b>fillIt() </b>method can invoke the <b>add()</b> method on
the object, with confidence that the behavior of the <b>add()</b> method
will be appropriate for the specific type of object involved.&nbsp; <i>(For
example, the behavior of the add() method for an object of the TreeSet
class will probably be different from the behavior of the add() method
for an object of some other class that implements the Collection interface.)</i>
<p><b><font color="#FF0000">Polymorphism is great!</font></b>
<p>The great thing about polymorphic behavior is that the author of the
<b>fillIt()</b> method doesn't need to be concerned about the implementation
details of the <b>add()</b> method.
<p><b><font color="#FF0000">Add five elements with some duplicates</font></b>
<p>The code in the <b>fillIt()</b> method adds five elements to the object.&nbsp;
Each element is a reference to a new object of type <b>Integer</b>.&nbsp;
Two of the objects encapsulate the <b>int</b> value 4, and thus are duplicates.
<p>The <b>int</b> values encapsulated in the <b>Integer</b> objects are
not in ascending order.&nbsp; Rather, they are added to the object in descending
order.&nbsp; <i>(They could be added in any order and the end result would
be the same.)</i>
<p><b><font color="#FF0000">Filter out the duplicates</font></b>
<p>Unknown to the author of the <b>fillIt()</b> method, the <b>add()</b>
method filters out the duplicate element in order to satisfy the contract
of the <b>Collection</b> interface.&nbsp; In this case, the author didn't
care what happens in the case of duplicate elements.
<p><b><font color="#FF0000">Notification of duplicates</font></b>
<p>If the author of the <b>fillIt()</b> method does care what happens in
the case of duplicates, she can find out when an object is a duplicate.
<p>According to the contract of the <b>Collection</b> interface, the <b>add()</b>
method must return
<i>true</i> if the invocation of the method modifies
the contents of the object and must return <i>false</i> if the collection
does not permit duplicates and the collection already contains the specified
element.
<p><b><font color="#FF0000">Sort the elements</font></b>
<p>Also unknown to the author of the <b>fillIt()</b> method, even though
the elements are added in descending order <i>(or could be added in any
other order for that matter),</i> they are stored and maintained in the
<b>TreeSet</b> object in such a way that they can later be accessed in
ascending order.
<p><b><font color="#FF0000">The TreeSet object is now populated</font></b>
<p>When the <b>fillIt()</b> method returns, the <b>TreeSet</b> object contains
four <i>(not five)</i> elements with no duplicates.&nbsp; Each element
is a reference to an object of type <b>Integer</b>.&nbsp; Those references
are maintained in such a way as to make them accessible in ascending order,
based on the
<b>int</b> values encapsulated in each of the <b>Integer</b>
objects.
<p><b><font color="#FF0000">Get an Iterator object</font></b>
<p>Returning now to the flow in the <b>doIt()</b> method, the following
statement invokes the <b>iterator()</b> method on the <b>TreeSet</b> object's
reference that is stored in the reference variable of type
<b>Collection</b>.&nbsp;
This is shown in Listing 4 below.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; <b>Iterator</b> iter = ref.iterator();

<b>Listing 4</b></font></pre>
</td>
</tr>
</table>

<p>Invocation of the <b>iterator()</b> method on any <b>Collection</b>
object returns an instance of a class that implements the <b>Iterator</b>
interface.&nbsp; The <b>Iterator</b> object can be used to traverse the
collection, gaining access to each element in order.&nbsp; <i>(The concept
of in order means different things for different kinds of collections.&nbsp;
For a collection instantiated from the TreeSet class, in order means in
ascending order.)</i>
<p><b><font color="#FF0000">Again, don't know, don't care</font></b>
<p>Again, the author of the method that uses the <b>Collection</b> object
doesn't need to know or care about the internal implementation of the collection,
or the implementation of the methods of the <b>Iterator</b> object.&nbsp;
They simply do what they do, and can be used for their intended purpose.
<p><b><font color="#FF0000">An Iterator object acts as a doorkeeper</font></b>
<p>The <b>Iterator</b> interface declares three methods:
<ul>
<li>
hasNext()</li>

<li>
next()</li>

<li>
remove()</li>
</ul>
You might say that an <b>Iterator</b> object acts as a doorkeeper for the
collection object that it represents, providing access to the contents
of the collection in a very specific manner.
<p>The code fragment in Listing 5 below shows how the first two of the
above methods can be used to
<ul>
<li>
Traverse the collection, accessing each of the object's elements in succession</li>

<li>
Display the value encapsulated in the object referred to by each element</li>
</ul>
As mentioned earlier, when the collection is an object instantiated from
the <b>TreeSet</b> class, access to the elements is provided in ascending
order.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; while(iter.<b>hasNext()</b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.<b>next()</b>);
&nbsp;&nbsp;&nbsp; }//end while loop

<b>Listing 5</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Four elements with no duplicates</font></b>
<p>At this point, the <b>TreeSet</b> object contains four elements, with
no duplicates.&nbsp; Each of the elements is a reference to an object of
type <b>Integer</b>.&nbsp; The code in the above loop causes each of those
elements to be accessed and displayed in ascending order.&nbsp; This causes
the following text to appear on the screen:
<p>1234
<p><b><font color="#FF0000">An editorial opinion</font></b>
<p>In my opinion, this is the kind of knowledge that a computer science
student in a modern data structures course should be learning.&nbsp; This
is a far departure from courses of the past where CS2 students were required
to memorize the intricate details of how to implement various data structures.
<p><b><font color="#FF0000">What kind of knowledge is needed?</font></b>
<p>Does an architect need to understand the detailed inner workings of
an air conditioning compressor in order to design a cooling system into
a building?&nbsp; Of course not!
<p>However, the architect does need to know the tradeoffs among the available
cooling systems in terms of initial cost, operating cost, size, efficiency,
etc.
<p>Does an audio technician need to understand the detailed inner workings
of an electronic audio equalizer in order to construct an integrated audio
system?&nbsp; Absolutely not!&nbsp; If that were a requirement, there would
likely be very few audio systems in existence.
<p>However, the audio technician does need to understand the tradeoffs
among the various available audio equalizers.
<p><b><font color="#FF0000">The same concept applies to software design</font></b>
<p>Does an OOP software designer need to know the detailed inner workings
of the various kinds of collection objects in order to use them effectively?&nbsp;
No!
<p>However, the software designer does need to know the tradeoffs among
the various types of collection objects in terms of their operational behavior.
<p>Modern CS2 students should be learning about the performance and operational
differences among the different types of collections, and how to use available
frameworks to create and use those collections.&nbsp; They should not be
wasting their time learning how to reinvent them.&nbsp; They have more
important ways to spend their valuable time, and they have more important
things to learn.
<p><b><font color="#FF0000">An analogy</font></b>
<p>Frankly, I don't care how the programmers at Sun implemented the <b>TreeSet</b>
class, so long as the behavior of objects instantiated from that class
meets the published specifications.<i></i>
<p>As an analogy, I also don't care how they implemented the <b>Random</b>
class, so long as objects instantiated from the <b>Random</b> class provide
the pseudo random values that I need in my programs.
<p>I see no conceptual differences between the <b>TreeSet </b>class and
the <b>Random</b> class from a software reuse viewpoint.
<ul>
<li>
I can instantiate an object of the <b>Random</b> class to produce pseudo
random values, without caring how those values are actually generated.&nbsp;
However, if I am working in cryptography, I might need to know how many
such values can be generated before the sequence repeats.</li>

<li>
I can use any of the thirty or so methods of the <b>Math</b> class to produce
a variety of complex mathematical values without caring about how those
values are actually produced.&nbsp; However, since many of those values
are approximations, I might need to know something about the quality of
the approximation.</li>

<li>
I can instantiate an object of the <b>TreeSet</b> class to create a collection
object, which guarantees that the sorted set will be in ascending element
order, and provide log(n) time cost for the basic operations of
<i>add</i>,
<i>remove</i>,
and <i>contains</i>.&nbsp; As long as I know that, I have very little need
to know exactly how the collection object is implemented.</li>
</ul>

<p><br><b><font color="#FF0000">Its time to reinvent the CS2 curriculum</font></b>
<p>I'm confident that the future employers of most students share my opinion
on this.&nbsp; I don't know of any employer who wants their programmers
to expend time and dollars reinventing the classical data structures.&nbsp;
What those employers are looking for is a staff of programmers who understand
the tradeoffs among the data structures, and when it is appropriate to
use each of the different structures.
<p>It is time to reinvent the curriculum in CS2 courses by
<ul>
<li>
Encouraging the understanding of techniques for software reuse</li>

<li>
Teaching when, why, and how each of the different structures should be
used</li>

<li>
Discouraging the reinvention of those structures</li>
</ul>

<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have provided a brief introduction to the use of the
Java Collections Framework.&nbsp; The framework is designed to encourage
you to reuse rather than to reinvent collections and maps <i>(I will have
more to say about maps in a subsequent lesson).</i>
<p>A collection represents a group of objects, known as its elements.
<p>While some collections allow duplicate elements, others do not. Some
collections are ordered and others are not ordered.
<p>The Collections Framework is defined by a set of interfaces and associated
contracts.&nbsp; The framework provides concrete implementations of the
interfaces <i>(classes)</i> for the most common data structures.&nbsp;
In addition, the framework also provides several abstract implementations,
which are designed to make it easier for you to create new and different
concrete implementations.
<p>The <b>TreeSet</b> class is a concrete implementation of the <b>SortedSet</b>
interface.&nbsp; The <b>SortedSet</b> interface extends <b>Set</b>, which
extends <b>Collection</b>.&nbsp; Thus, a <b>TreeSet</b> object <i>is a
</i><b>SortedSet</b>.&nbsp; Also it <i>is a</i> <b>Set</b>, and it <i>is
a</i> <b>Collection</b>.
<p>The <b>TreeSet</b> class guarantees that the sorted set will be in ascending
element order, and provides guaranteed log(n) time cost for the basic operations
(<i>add</i>, <i>remove</i> and <i>contains</i>).
<p><b>TreeSet</b> objects can be treated as the generic type <b>Collection</b>.&nbsp;
Methods declared in the <b>Collection</b> interface can be invoked on a
<b>TreeSet</b>
object without regard for the actual class from which the object was instantiated.

<i>(This is polymorphic behavior.)</i>
<p>When such methods are invoked, the author of the program can have confidence
that the behavior of the method will be appropriate<b><i> </i></b>for an
object of the class from which the object was instantiated.&nbsp; In my
opinion, this is the true essence of object-oriented behavior.
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
This is the first lesson in a miniseries on the Collection Framework.&nbsp;
Subsequent lessons will teach you how to use the framework for creating
and using various types of collections and maps.
<p>Once you learn how to use the framework, it is unlikely that you will
need to reinvent classical data structures, search algorithms, or sorting
algorithms, because those capabilities are neatly packaged within the framework.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
6 below</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">import java.util.TreeSet;
import java.util.Collection;
import java.util.Iterator;

public class AP400{
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Worker().doIt();
&nbsp; }//end main()
}//end class AP400

class Worker{
&nbsp; public void doIt(){
&nbsp;&nbsp;&nbsp; Collection ref = new TreeSet();
&nbsp;&nbsp;&nbsp; Populator.fillIt(ref);
&nbsp;&nbsp;&nbsp; Iterator iter = ref.iterator();
&nbsp;&nbsp;&nbsp; while(iter.hasNext()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(iter.next());
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end doIt()
}// end class Worker

class Populator{
&nbsp; public static void fillIt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection ref){
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(4));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(3));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(2));
&nbsp;&nbsp;&nbsp; ref.add(new Integer(1));
&nbsp; }//end fillIt()
}//end class populator

<b>Listing 6</b></font></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
