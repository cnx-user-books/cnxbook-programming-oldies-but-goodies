<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Understanding Transforms in Java 2D</h2>
Gain an understanding of transforms in Java 2D in a way that you can extend to an 
understanding of transforms in Java 3D.<p><b>Published:</b>&nbsp; December 4, 
2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1550</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Recap">Recap</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Download">Download</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#FF0000"><b>Part of a series</b></font></p>
<p>This lesson is part of a series designed to start with Java 3D basics and 
work up to some very complicated programs, such as the program that I explained 
in the earlier lesson titled &quot;Understanding Lighting in the Java 3D API&quot; <i>(see
<a href="#Resources">Resources</a>).</i></p>
<p>The first lesson in this series was titled &quot;Back to Basics in the Java 3D 
API.&quot;&nbsp; The 
previous lesson was titled &quot;Combining Rotation and Translation in Java 3d.&quot;&nbsp; 
This lesson is titled &quot;Understanding Transforms in Java 2D.&quot;</p>
<p><font color="#FF0000"><b>Not a typographical error!</b></font></p>
<p>I really did mean Java <i>2D</i> and not Java <i>3D</i> in the previous 
sentence.&nbsp; That was not a typographical error.</p>
<p>I imagine that now you are wondering why I would 
include a lesson on Java 2D in a series that is designed to teach you about 
Java 3D. Believe me, there is a good reason, which I will explain a little 
<a href="#That_is_the_reason">later</a>.</p>
<p>My 
current plan is for future lessons to deal with user and object interaction as 
well as transforms, advanced animation, and textures in Java 3D.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p>In this lesson, you will learn to understand transforms in Java 2D in a way 
that you will be able to extend to an understanding of transforms in Java 3D.&nbsp; You will also learn how to 
write Java 2D code that makes use of that understanding.</p>
<p><b><font color="#ff0000">Compiling and running Java 2D programs</font></b></p>
<p>In previous lessons, I told you that in order to compile and run programs using the Java 3D API, you will need to 
download and install the Java 3D API software.&nbsp; As of the date of this writing, 
Java 3D version 1.5.0 is available for <a href="#Download">download</a>.</p>
<p>In addition, you will need to <a href="#Download">download</a> 
and install either <b>Microsoft DirectX</b> or <b>OpenGL</b> to run Java 3D 
programs.&nbsp; All of the Java 3D sample 
programs in this series of tutorials were developed and tested using Microsoft 
DirectX.&nbsp; They were not tested using OpenGL.</p>
<p>However, no special download and installation is required for Java 2D.&nbsp; For some time now, 
Java 2D 
has been an integral part of the standard edition of Java 2.&nbsp; I recommend 
that you use the Sun product often referred to as Java SE 6 <i>(version 1.6.0 or 
later)</i> if it is available for your platform.&nbsp; If not, version 1.5, and 
probably version 1.4 should suffice as well.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>.
 Program output at startup. 
	</li>
	<li><a href="#Figure_2">Figure 2</a>. Matrices for translation, scaling, 
	and rotation.</li>
	<li><a href="#Figure_3">Figure 3</a>. Matrix operations for the three 
	basic transforms.</li>
	<li><a href="#Figure_4">Figure 4</a>. Matrix computation for a point 
	using translation matrix.</li>
	<li><a href="#Figure_5">Figure 5</a>. The six specifiable values 
	displayed on the screen.</li>
	<li><a href="#Figure_6">Figure 6</a>. The default transform.</li>
	<li><a href="#Figure_7">Figure 7</a>. Display the current transform after 
	origin adjustment.</li>
	<li><a href="#Figure_8">Figure 8</a>. Graphic output produced by user 
	input scale values.</li>
	<li><a href="#Figure_9">Figure 9</a>. The new transform matrix values 
	after scaling.</li>
	<li><a href="#Figure_10">Figure 10</a>. Translating by 50 and 30 for x 
	and y.</li>
	<li><a href="#Figure_11">Figure 11</a>. Contents of the current transform 
	matrix after translation.</li>
	<li><a href="#Figure_12">Figure 12</a>. Graphic output after application 
	of the shear transform.</li>
	<li><a href="#Figure_13">Figure 13</a>. Contents of the current transform 
	following the shear.</li>
	<li><a href="#Figure_14">Figure 14</a>. Prepare to explain a rotate 
	transform.</li>
	<li><a href="#Figure_15">Figure 15</a>. Graphic output following 30-degree 
	rotate transform.</li>
	<li><a href="#Figure_16">Figure 16.</a> Contents of the current transform 
	following a rotate transform.</li>
	<li><a href="#Figure_17">Figure 17</a>. Graphic output from the final 
	translate transform.</li>
	<li><a href="#Figure_18">Figure 18</a>. Contents of the final transform 
	matrix.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. The displayMatrix method.</li>
	<li><a href="#Listing_2">Listing 2</a>. The drawOrigin method.</li>
	<li><a href="#Listing_3">Listing 3</a>.
Beginning of the class named Java2D001. 
	</li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the inner class 
	named GUI.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the inner class 
	named Display.</li>
	<li><a href="#Listing_6">Listing 6</a>. Move the origin to the center of 
	the canvas.</li>
	<li><a href="#Listing_7">Listing 7</a>. Cause the positive y direction to 
	be up instead of down.</li>
	<li><a href="#Listing_8">Listing 8</a>. Draw a cyan rectangle, a circle, 
	and a cross at the origin.</li>
	<li><a href="#Listing_9">Listing 9</a>. Apply a user-specified scale 
	transform.</li>
	<li><a href="#Listing_10">Listing 10</a>. Apply a user specified 
	translate transform.</li>
	<li><a href="#Listing_11">Listing 11</a>. Update the current transform to 
	include shear.</li>
	<li><a href="#Listing_12">Listing 12</a>. Update the current transform to 
	apply a rotate transform.</li>
	<li><a href="#Listing_13">Listing 13</a>. The final translate transform.</li>
	<li><a href="#Listing_14">Listing 14</a>. Program listing for the program 
	named Java2D001.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#FF0000"><b>Why a lesson on Java 2D?</b></font></p>
<p>We have reached the point in this series where you need to learn about 
transforms in Java 3D.&nbsp; This is not a trivial topic.&nbsp; It is an extremely complex topic.&nbsp; Although 
transforms are also not a trivial 
topic in Java 2D, it is 
much easier to understand transforms in Java 2D than in Java 3D.</p>
<p>While 
transforms in the two APIs are not implemented in exactly the same way, the transform concept in 
Java 2D is sufficiently 
similar to the transform concept in Java 3D that once you understand transforms in 2D, you should be able to 
make the stretch into 3D.&nbsp; In any event, it can't hurt for you to 
understand Java 2D transforms when you embark on an attempt to understand Java 
3D 
transforms.</p>
<p><a name="That_is_the_reason">That is the reason</a> that I have included a lesson on Java 2D in a series that 
is centered on Java 3D.&nbsp; I will follow this lesson up with a lesson on 
understanding transforms in Java 3D.</p>
<p><font color="#FF0000"><b>Types of transforms of interest</b></font></p>
<p>This lesson will be concerned with transforms of the following types:</p>
<ul>
	<li>Scaling</li>
	<li>Translation</li>
	<li>Shear</li>
	<li>Rotation</li>
</ul>
<p><font color="#FF0000"><b>Prerequisite background knowledge</b></font></p>
<p>To understand transforms in either 2D or 3D <i>(particularly the rotation 
transform)</i> you need to have some understanding of trigonometry.&nbsp; I'm 
sorry, but that is simply the way it is.&nbsp; In addition, it will be 
helpful if you have some knowledge of matrices and matrix algebra.</p>
<p>While I will do my best to help you to understand transforms, trying to teach 
you the requisite background knowledge is beyond the scope of this tutorial.&nbsp; 
I will provide only a brief discussion of the requisite background.&nbsp; For 
technical background, I recommend that you study the articles titled 
&quot;Trigonometry&quot;, &quot;Planar 
transformations&quot;, and &quot;A little algebra&quot; <i>(see <a href="#Resources">Resources</a>)</i>.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The Shape interface</b><br />
  Note that <i>Shape</i> is the name of an interface in Java 2D.&nbsp; However, 
	at this point, I am not referring to that interface.&nbsp; Rather, I am 
	referring to a shape in a much more general sense.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>What is a shape in 2D?</b></font></p>
<p>The outline of a shape <i>(hereafter referred to simply as a shape)</i> in 
Java 2D is defined by two or more points connected by straight line segments.&nbsp; 
The outline may or may not be closed.</p>
<p><font color="#FF0000"><b>A special case of a polygon</b></font></p>
<p>For example, the square in the image on the left in Figure 1 is a closed 
shape defined by four points and four connecting straight line segments.&nbsp; 
The square is a special case of a polygon.&nbsp; The corners of the square are 
often referred to as the vertices of the polygon.&nbsp; The points that define 
the polygon occur at the vertices.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Program output at startup. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1550a01.jpg" width="472" height="254"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The circle is also a closed shape</b></font></p>
<p>The circle shown inside the square in Figure 1 is also a closed shape defined by considerably 
more than four points connected by very short straight line segments.&nbsp; As a 
practical matter, unless the circle is defined by an infinite number of points,
<i>(which is not possible)</i>, it is also a polygon with the points occurring 
at the vertices.&nbsp; If we were to draw a circle with a much larger radius 
defined by the same number of vertices, there is a good chance that the vertices 
could be discerned by the naked eye.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="I_a_line_a_closed_shape">Is a line a closed shape</a>?</b><br />
  The fact that the width of a line increases when subjected to a scale 
	transform (see Figure 8) suggests that maybe a line is really a narrow 
	filled rectangle, which would suggest that a line really is a closed shape.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The cross is not a closed shape <i>(or is it)?</i></b></font></p>
<p>The cross shown in Figure 1 consists of two lines, each of which is defined 
by two end points.&nbsp; The end points are connected by straight line segments.&nbsp; 
While the cross is also a shape in the general sense, it is not a closed shape
<i>(see <a href="#I_a_line_a_closed_shape">sidebar</a>)</i>.</p>
<p><font color="#FF0000"><b>What is a point?</b></font></p>
<p>A point is a location in 2D space defined by a pair of coordinate values <i>(x,y)</i>.&nbsp; The 
value for x defines the location of the point relative to an <i>origin</i> along 
the x-axis in a &quot;Cartesian coordinate system&quot; <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; The value for y defines the location of the point 
along the y-axis.</p>
<p><font color="#FF0000"><b>Orthogonal axes</b></font></p>
<p>A pair of orthogonal <i>(see <a href="#Resources">Resources</a>)</i> axes 
intersect at the <i>origin</i>.&nbsp; The axis may or may not be visible in the 
graph.&nbsp; Even when they are not visible, they are assumed to be present.</p>
<p>The x-axis is typically considered to be the horizontal axis with positive 
values going from left to right.&nbsp; The other axis in the pair of orthogonal 
axes is typically considered to be the y-axis with positive values going from 
bottom to top.&nbsp; Note, however that there is no requirement that the graph 
be displayed in such a way that the orthogonal axes are horizontal and vertical.&nbsp; 
They are often rotated for display purposes, as is the case in this program.</p>
<p>Note also that the application of a shear transform causes the axes to no 
longer be orthogonal <i>(see Figure 12)</i>.&nbsp; <i>(Is this a true statement?&nbsp; 
Think about it.)</i></p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Direction of the positive y-axis</b><br />
  By default, the positive direction of the vertical axis in a graph generated using Java code goes 
	from top to bottom.&nbsp; However, that was purposely corrected in this 
	program so that the positive direction of the vertical axis for the graph shown in Figure 1, as 
	well as the other graphs in this lesson is from bottom to top.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The y-coordinate</b></font></p>
<p>As mentioned earlier, the value for y defines the location of the point relative to the origin 
along the y-axis in the Cartesian coordinate system.&nbsp; As mentioned above, 
the y-axis is typically considered to be the vertical axis with positive values 
going from bottom to top.</p>
<p><font color="#FF0000"><b>Where is the origin?</b></font></p>
<p>The origin may be located anywhere on or off the graph, but is often located 
either at the bottom left or at the center.&nbsp; However, regardless of its 
location, it is always at the intersection of the orthogonal axes.&nbsp; The 
origin is located in the center of the left image in Figure 1 and is marked by the cross.&nbsp; 
The circle and the square in Figure 1 are centered on the origin.</p>
<p><font color="#FF0000"><b>What is a vector?</b></font></p>
<p>According to Wikipedia <i>(see <a href="#Resources">Resources</a>)</i>, there 
are several kinds of vectors.&nbsp; A <i>spatial vector</i> is an object defined 
by both magnitude and direction; in contrast to a <i>scalar</i>, an object with 
magnitude only.&nbsp; Typically in Java 2D, a point is used to define one end of a 
vector.</p>
<p>Also, according to Wikipedia, the word vector is used to describe a 
one-dimensional, directional matrix; a <i>row vector</i> or a <i>column vector</i>.&nbsp; 
I will use the word vector in both senses <i>(spatial and matrix)</i> in this 
lesson.&nbsp; Hopefully the sense in which the word is being used will be clear from 
the context of the discussion.</p>
<p><font color="#FF0000"><b>What is a transform?</b></font></p>
<p>In the sense that it will be used in this lesson, a transform is an operation 
that converts the coordinate values for each of the points that define a shape into a 
different set of coordinate values.&nbsp; The shape that is defined by the new 
coordinate values will probably be recognizable as representing the original 
shape, although it may be a different size <i>(scale)</i>, may be in a different 
location <i>(translation)</i>, may have a different orientation <i>(rotation)</i>, 
may be sheared <i>(shear)</i>, may be squashed in one dimension or the other, or 
may be flipped across one or both of the axes.</p>
<p><font color="#FF0000"><b>What is an affine transform?</b></font></p>
<p>The transforms that will be used in this lesson are actually <i>affine</i> 
transforms.&nbsp; According to the Java 2D documentation:</p>
<blockquote>
	<p><i>&quot;The AffineTransform class represents a 2D affine transform that 
	performs a linear mapping from 2D coordinates to other 2D coordinates that 
	preserves the &quot;straightness&quot; and &quot;parallelness&quot; of lines. Affine 
	transformations can be constructed using sequences of translations, scales, 
	flips, rotations, and shears.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Translation</b></font></p>
<p>To translate a shape means to move the shape from one location in the 2D 
space to a different location in the 2D space.&nbsp; <i>(You will see how this 
is accomplished later.)</i>&nbsp; We can translate a shape by 
translating all of the points that define the shape.&nbsp; We can translate a 
point by adding offsets to the x and y coordinate values that define the 
location of the point.</p>
<p>If we express the original coordinates of a point as x1 and y1, and express 
the offsets as tx and ty, then we can express the coordinates of the new 
location of the point as:</p>
<p><pre>x2 = x1 + tx
y2 = y1 + ty</pre></p>

<p><font color="#FF0000"><b>Scaling</b></font></p>
<p>To scale a shape means to change the locations of all the points that 
represent the shape according to a very specific formula.&nbsp; Typically, but 
not always, a scaling transform will change the size of the shape, making it 
larger or smaller.&nbsp; <i>(Note that scaling by a factor of -1 doesn't change the size.)</i>&nbsp; 
We can accomplish a scaling transform by multiplying the x coordinate values of 
all the points that define the shape by one scale factor and multiplying the 
y coordinate values of all the points that define the shape by the same or a 
different scale factor.</p>
<p><font color="#FF0000"><b>Enlarging, reducing, squashing, and flipping</b></font></p>
<p>If the scale factors used to multiply the x and y coordinate values are the 
same, the shape will simply become larger or smaller <i>(and could be flipped 
across the axes if the scale factors are negative)</i>.&nbsp; If the scale 
factors are different, the shape may be squashed in one dimension or the other, 
or possibly even flipped across one or both axes, but will probably still be 
recognizable as representing the same shape.</p>
<p><font color="#FF0000"><b>Scale relative to the origin</b></font></p>
<p>The scale factors that are used in a scaling transform are expressed relative 
to the origin.&nbsp; For example, a scale factor of 2.0 will cause a coordinate 
value for a point to represent the coordinate value for a new point that is 
twice as far from the origin.</p>
<p>If we express the original coordinates of a point as x1 and y1, and express 
the scale factors as sx and sy, then we can express the coordinates of the new 
location of the point as</p>
<p><pre>x2 = x1 * sx
y2 = y1 * sy</pre></p>
<p>where the * indicates multiplication.</p>
<p><font color="#FF0000"><b>Rotation</b></font></p>
<p>Rotation is much less intuitive than either translation or scaling, and 
requires a fair knowledge of trigonometry to understand.&nbsp; However, it is 
possible to create and use rotation transforms in a cookbook fashion without 
understanding why they work.</p>
<p>The following equations for rotating a point around the origin in 2D space 
are derived in &quot;Planar transformations&quot; <i>(see <a href="#Resources">Resources</a>)</i>, 
where v represents the angle of rotation.</p>
<p><pre>x2 = x1 * cos(v) - y1 * sin(v)
y2 = x1 * sin(v) + y1 * cos(v)</pre></p>


<p><table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Positive angle of rotation</b><br />
  The specification of a positive rotation angle in the user input GUI in Figure 
	1 also results in a counterclockwise angle of rotation.
</td></tr></table>
</td>
</tr>
</table><font color="#FF0000"><b>Positive angle of rotation</b></font><p>The author who derived these two equations points out that they assume that a 
positive rotation angle is counterclockwise around the origin. </p>
</p>
<p><font color="#FF0000"><b>Shear</b></font></p>
<p>Shear is much more complicated.&nbsp; I provided a pretty good 
description of shear in my earlier article titled &quot;Graphics, Simple Affine 
Transforms&quot; <i>(see <a href="#Resources">Resources</a>)</i>, and I am 
simply going to leave it at that insofar as shear is concerned.&nbsp; However, I 
would be remiss if I failed to point out that once a shear transform is applied, 
the axes are no longer orthogonal <i>(or at least, they no longer appear to be 
orthogonal)</i>.</p>
<blockquote>
	<p><i>(I also provided information regarding scaling, translation, and 
	rotation in the earlier lesson titled </i>&quot;Graphics, Simple Affine 
	Transforms,&quot; <i>which you may find helpful.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Matrices</b></font></p>
<p>The article titled &quot;Planar transformations&quot; <i>(see <a href="#Resources">Resources</a>)</i> 
gives us the matrix equations shown in Figure 2, which can be solved to 
accomplish translation, scaling, and rotation transforms. </p>












<p>
 <b><a name="Figure_2">Figure 2</a>. Matrices for translation, scaling, and 
	rotation. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Translation decided by tx and ty 	
|x2|   |x1|   |tx|
|  | = |  | + |  |
|y2|   |y1|   |tx|

Scaling decided by sx and sy 	
|x2|   |sx  0|   |x1|
|  | = |     | * |  |
|y2|   |0  sy|   |y1|

Rotation decided by v 	
|x2|   |cos(v)  -sin(v)|   |x1|
|  | = |               | * |  |
|y2|   |sin(v)   cos(v)|   |y1|</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The same author teaches us a little about matrix algebra in the article 
titled &quot;A little algebra&quot; <i>(see <a href="#Resources">Resources</a>)</i>, in 
case you need some background study to improve your knowledge of matrix algebra.</p>
<p><font color="#FF0000"><b>Homogeneous coordinates</b></font></p>
<p>That same author goes on to tell us that if we write the coordinate values 
for a point in the form of the following column vector, we can write the three 
basic transforms of translation, scaling, and rotation as multiplication between 
a 3x3 matrix and a 1x3 column vector.</p>
<p><pre>
	| x |
	| y |
	| 1 |	</pre></p>
<p><font color="#FF0000"><b>The 3x3 matrices</b></font></p>
<p>The 3x3 matrices to which he refers are shown in boldface in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Matrix operations for the three basic 
	transforms. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Translation  	
|x2|   <b>|1 0 tx|</b> |x1|
|y2| = <b>|0 1 ty|</b>*|y1|
|1 |   <b>|0 0  1|</b> |1 |

Scaling 	
|x2|   <b>|sx 0 0|</b> |x1|
|y2| = <b>|0 sy 0|</b>*|y1|
|1 |   <b>|0  0 1|</b> |1 |

Rotation 	
|x2|   <b>|cos(v) -sin(v) 0|</b> |x1|
|y2| = <b>|sin(v) cos(v)  0|</b>*|y1|
|1 |   <b>|0        0     1|</b> |1 |
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Therefore, regardless of the type of transform needed <i>(translation, 
scaling, or rotation)</i>, the arithmetic required is 
the same.&nbsp; A single algorithm for matrix multiplication can be used to 
perform all three transforms provided that we are able to generate the 
appropriate 3x3 matrix values.</p>
<p><font color="#FF0000"><b>Also supports combining transforms</b></font></p>
<p>As I will explain later, this form also makes it possible to combine several 
transforms into a single matrix before applying that composite transform to all 
the points that make up a shape.&nbsp; This can result in improved efficiency.</p>
<p><font color="#FF0000"><b>Homogeneous coordinates</b></font></p>
<p>The author of &quot;Planar transformations&quot; describes the form shown in Figure 3 as <i>homogeneous </i>
coordinates.&nbsp; Regarding the changes that were made getting from the form in 
Figure 2 to the form in Figure 3, the author goes on to explain:</p>
<blockquote>
	<p><i>&quot;...are expressed in homogeneous coordinates. We will not worry about 
	the third coordinate, the number 1. We'll not try to give a geometric 
	explanation of this. The whole point is to standardize the mathematics in 
	the transformations. The third coordinate stays the same in the basic 
	transformations and, as we will see later, in combinations of them.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Some special cases</b></font></p>
<p>The author of &quot;Planar transformations&quot; then goes on to discuss some special cases for the 3x3 matrices 
that can be used in transforms to produce:</p>
<ul>
	<li><b>mirroring</b> - to produce the mirror image of a shape.</li>
	<li><b>shearing</b> - a scaling along one of the axes that depends on the 
	coordinate on the other axis.&nbsp; For example, shearing will turn a 
	rectangle into a parallelogram.</li>
	<li><b>projection</b> - projecting a point onto an axis.</li>
</ul>
<p>You may find these special transforms useful in your future work.</p>
<p><font color="#FF0000"><b>Compound operations</b></font></p>
<p>As mentioned earlier, it is possible to combine a series of transforms into a 
single matrix multiplication by first multiplying the matrices that 
represent of the individual transforms to produce a single compound matrix.&nbsp; 
Instead of having to perform a series of individual transforms on each point 
that represents a shape, a compound transform matrix can be created first, and 
each point can be transformed by multiplying the column vector that represents 
that point by the compound matrix that represents the entire set of transforms.&nbsp; 
The savings in computational requirements can be very large.</p>
<p><font color="#FF0000"><b>The bad news</b></font></p>
<p>It is possible to write Java 2D programs where almost your entire thought 
process revolves around the creation and use of transform matrices down to the 
element level.&nbsp; <i>(See the <b>transform</b> method of the <b>Graphics2D</b> 
class for example.)</i>&nbsp; The bad news is that for some programs, this may be the 
only way to get the job done. There may be no alternative to engaging deeply in 
matrix thought.</p>
<p><font color="#FF0000"><b>The good news</b></font></p>
<p>However, the good news is that it is possible to write most Java 2D programs 
without having to think too deeply about matrices.&nbsp; This is because the 
Java 2D API provides convenience methods that abstract most of the matrix 
operations behind a fairly common Java programming interface.&nbsp; Even when 
you use the convenience methods, however, it is a good idea to have some 
appreciation of what is actually taking place behind the curtains.</p>
<p><font color="#FF0000"><b>Back to the basics</b></font></p>
<p>Let's go way back.&nbsp; A computer monitor<i> (at least the old fashioned 
kind)</i> has a glass screen that has been coated on the inside with specks of 
luminescent material that will glow red, green, or blue when bombarded 
with electrons.&nbsp; <i>(The newer flat panel monitors are constructed 
differently, but the results are essentially the same.)</i>&nbsp; The specks of 
luminescent&nbsp;material are 
placed on the glass in a uniform grid.&nbsp; These specks, <i>(or the analogous 
items in a flat panel display)</i>, determine the resolution of the monitor.&nbsp; <i>
(You cannot resolve two points on the screen that are closer than the distance 
between the luminescent specks.&nbsp; The size of the specks also has an impact 
on resolution.&nbsp; Usually smaller specks will support higher resolution.)</i></p>
<p><b><font color="#FF0000">Screen pixels</font></b></p>


<p>Although this is not technically correct from a purest viewpoint, I am going 
to refer to these specks as screen pixels <i>(short for picture elements)</i>.&nbsp; 
The number of pixels per inch on the screen determines the resolution of the 
screen.&nbsp; For example, the flat screen on my laptop is a little less than 12 
inches wide and a little less than nine inches tall.&nbsp; Supposedly it has a 
horizontal resolution of 1024 pixels and a vertical resolution of 768 pixels.</p>
<p>Theoretically, if I write a Java program to plot a single point on the 
screen, only one of the screen pixels will be illuminated to display that point.&nbsp;
<i>(Realistically, more than one adjacent pixel may be illuminated due to 
electronic variability in the electronics that drive the screen display.)</i> </p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Aspect ratio</b><br />
  The aspect ratio of an image is its displayed width divided by its displayed height, 
	often expressed as x:y.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The aspect ratio</b></font></p>
<p>The <i>aspect ratio</i> on my laptop is very close to 1:1 at about 87 
pixels per inch in both dimensions.&nbsp; The important thing about having a 
good aspect ratio is that when I use a program to draw a circle on the screen, 
it will look like a circle to the viewer instead of looking like an ellipse.&nbsp; 
However, if the aspect ratio is different from 1:1, I could compensate for that 
problem using a scaling transform.</p>
<p><font color="#FF0000"><b>Overriding the paint method</b></font></p>
<p>Onscreen graphics are produced in Java 2D by overriding the <b>paint</b> method 
belonging to the <b>Canvas</b> object on which the graphics are to be drawn.&nbsp;
<i>(In addition to the <b>Canvas</b> class, there are a few other classes in the 
AWT, such as <b>Frame</b> and <b>Panel</b> that contain a <b>paint</b> method 
that can be overridden to draw onscreen graphics.)</i></p>
<p><font color="#FF0000"><b>Illuminating pixels</b></font></p>
<p>The <b>paint</b> method draws its pictures by illuminating pixels on the 
screen.&nbsp; Regardless of what you may think you are doing when you write 
the program, the location 
of the pixel that is to be illuminated is eventually resolved to be a specified 
number of pixels to the right of and a specified number of pixels down from 
the pixel that occupies the upper left corner of the canvas.</p>
<p><font color="#FF0000"><b>Relocating the origin</b></font></p>
<p>By default, the origin for the Cartesian coordinate system is at the upper 
left corner of the canvas.&nbsp; As you will see in the program later, we can 
apply a <i>translate</i> transform to move the origin to a different location on the 
canvas.&nbsp; Having done that, when we write program code to draw shapes, we specify the locations of the points to be 
plotted relative to the new origin.&nbsp; When we do that, the 
transform that was applied to relocate the origin is automatically used to 
resolve the locations of the points back to a coordinate system that has its 
origin at the upper left corner of the canvas.</p>
<p><font color="#FF0000"><b>The positive y direction</b></font></p>
<p>By default, the positive y direction is down the screen, which is 
the opposite of what we often like to see.&nbsp; We can apply a scaling 
transform to cause the positive y direction to be up instead of down.&nbsp; Once 
again, however, when we do that and then plot a point, the transform is 
automatically used to resolve the location of the point back to the default with 
the origin at the upper left corner of the canvas and the positive y direction 
going down the screen.</p>
<p><font color="#FF0000"><b>A practical example</b></font></p>
<p>The image on the left in Figure 1 shows a rectangle, a circle, and a cross 
that are centered on an origin that was translated to the center of the canvas.&nbsp; 
For example, the left end of the horizontal line in the cross was specified to 
be at (-7,0) and the right end was specified to be at (7,0).</p>
<p>When I applied the two transforms to relocate the origin and to correct for 
the problem with the positive y direction, this resulted in the 
current compound transform shown by the boldface transform matrix in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Matrix computation for a point using 
	translation matrix. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>
|x2|   <b>|1.00  0.00 113.50|</b>   |-7|   |105|
|y2| = <b>|0.00 -1.00 113.50|</b> * | 0| = |113|
|1 |   <b>|   0     0   1   |</b>   | 1|   |  1|
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Do the arithmetic</b></font></p>
<p>Assuming that the resulting pixel location is truncated to the next lower 
integer, performing the computation shown in Figure 4 would cause the actual 
location of the left end of the line in pixels relative to the upper left corner of the canvas to be (105,113).&nbsp; </p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Converting to actual screen coordinates</b><br />
  This is followed by another similar computation either in the Java virtual 
	machine or in operating system to determine the actual screen coordinates of 
	the two ends of the line.&nbsp; The answer will depend on the current location 
of the Frame containing the canvas on the screen.
</td></tr></table>
</td>
</tr>
</table>
<p>Performing a similar computation for the coordinate at the 
right end of the short horizontal line in Figure 1 would result in a location of 
(120,113).&nbsp; Even though I specified in the program that the line should be drawn 
from (-7,0) to (7,0), it was actually drawn from (105,113) to (120,113) relative 
to the upper left corner of the canvas.</p>
<p><font color="#FF0000"><b>A virtual coordinate system</b></font></p>
<p>Fortunately, once we apply the transform to relocate the origin and correct 
for the positive y direction, we can think and program 
in terms of <i>virtual</i> coordinates relative to our new <i>virtual</i> origin.&nbsp; All of 
the complicated matrix arithmetic necessary to convert our <i>virtual</i> coordinates 
to actual coordinates relative to the upper left corner of the canvas takes place 
automatically behind the curtain.</p>
<p>Hopefully this discussion will have served as an introduction to the 
discussions and explanations that follow.</p>
<p><font color="#FF0000"><b>Let's see some code!</b></font></p>
<p>With that as a technical background, it's time to examine a program that 
makes it easy to experiment with and hopefully easy to understand how to create 
and to use 
transforms in Java 2D.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain a program named <b>Java2D001</b>.&nbsp; 
The purpose of this program is to illustrate transforms in Java 2D.&nbsp; <i>
(This program is very similar to the Java 3D program named Java3D010 that I will 
present and explain in a future lesson.)</i></p>
<p><font color="#FF0000"><b>The user input GUI</b></font></p>
<p>The user input GUI shown on the right side of Figure 1 allows the user to 
specify parameter values for a sequence of five transforms of the types shown in 
the leftmost column in the GUI in Figure 1.&nbsp; The transforms are performed 
in the order shown from top to bottom in Figure 1.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Invalid numeric data</b><br />
  Clicking the Replot button when one of the input fields contains invalid 
	numeric data <i>(including a blank field)</i> will cause the program to abort with a NumberFormatException.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The Replot button</b></font></p>
<p>A <b>Replot</b> button at the bottom of the GUI allows the user to modify 
input parameters, re-compute the transforms, apply the new transforms, and 
produce a new output based on the new transforms.</p>
<p><font color="#FF0000"><b>Display the transform matrices</b></font></p>
<p>In addition to providing a graphic output display on the left in Figure 1, 
the program also gets and displays the specifiable values in the <b>AffineTransform</b> 
object each time it is updated to support a new transform.</p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>The program was tested using Java SE 6 running under Windows XP.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<font color="#FF0000"><b>Will explain in fragments</b></font><p>As is my custom, 
I will present and explain this program in fragments.&nbsp; A complete listing 
of the program is provided in Listing 14. </p>
<p>Before getting into the main body of the program, I will present and explain 
two utility methods that are used throughout the program.&nbsp; The first utility 
method is a method named <b>displayMatrix</b>.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The six specifiable values</b><br />
  This refers to the six values in the top two rows of the transform matrices 
	shown in Figure 3.&nbsp; In other words, the bottom row consisting solely of 
	0 and 1 are not included in the printed output.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
<b>The displayMatrix method</b></font></p>
<p>This method is shown in its entirety in Listing 1.&nbsp; The method receives a reference to an 
<b>AffineTransform</b> object.&nbsp; It extracts and displays the six 
specifiable values contained in the transform matrix on the command line screen 
in the format shown in Figure 5.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. The displayMatrix method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    void displayMatrix(AffineTransform theTransform){
      
      //Retrieve the contents of the AffineTransform into
      // an array of type double.
      double[] theMatrix = new double[6];
      theTransform.getMatrix(theMatrix);

      //See http://www.particle.kth.se/~lindsey/JavaCourse
      // /Book/Part1/Tech/Chapter05/formatterPrintf.html
      // for instructions on the use of System.out.printf.

      //Display first row of values by displaying every
      // other element in the array starting with element
      // zero.
      System.out.printf ("%5.2f %5.2f %5.2f %n", 
                  theMatrix[0],theMatrix[2],theMatrix[4]);
      //Display second row of values displaying every
      // other element in the array starting with element
      // number one.
      System.out.printf ("%5.2f %5.2f %5.2f %n", 
                 theMatrix[1],theMatrix[3],theMatrix[5]);
      
    }//end displayMatrix</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. The six specifiable values displayed on the 
	screen. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre> 1.00  0.00 113.50
-0.00 -1.00 113.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Extract AffineTransform contents into an array</b></font></p>
<p>The code in this method is relatively straightforward.&nbsp; It receives an 
incoming parameter, which is a reference to an object of type <b>AffineTransform</b>.&nbsp; 
It calls the <b>getMatrix</b> method of the <b>AffineTransform</b> class, which 
deposits the data values in a six-element array of type <b>double</b> that is 
passed to the method to receive the data.</p>
<p><font color="#FF0000"><b>The display format</b></font></p>
<p>The most complicated thing about the method is the use of the <b>
System.out.printf</b> statement <i>(that first became available in Java version 
1.5)</i> to format each <b>double</b> value into five columns with two digits to 
the right of the decimal point.&nbsp; Listing 1 contains the URL of a web site 
that provides a good explanation of how to do the formatting, so I will simply 
refer you to that website <i>(see <a href="#Resources">Resources</a> for an 
active hyperlink to this site)</i>.</p>
<p>Beyond that, the comments in Listing 1 should suffice to explain the code.</p>
<p><font color="#FF0000">
<b>The drawOrigin method</b></font></p>
<p>The next utility method that I will discuss is the method named <b>drawOrigin</b>, 
which is presented in its entirety in Listing 2.&nbsp; This method will draw a 
circle containing a cross at the current origin, as shown in the center of the 
left image in Figure 1.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. The drawOrigin method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        void drawOrigin(Graphics g){
          Graphics2D g2 = (Graphics2D)g;
          g2.drawLine(-7,0,7,0);
          g2.drawLine(0,-7,0,7);
          g2.drawOval(-5,-5,10,10);
        }//end drawOrigin</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you know anything about Java graphics, you should have no difficulty 
understanding the code in this method.&nbsp; If you don't understand the code in 
Listing 2, let me suggest that you go to my web site <i>(see
<a href="#Resources">Resources</a>)</i> and start studying Java from the 
beginning.</p>
<p><font color="#FF0000">
<b>Beginning of the class named Java2D001</b></font></p>
<p>The main class for the program named <b>Java2D001</b> begins in Listing 3.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of the class named Java2D001. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class Java2D001 extends Frame{
  GUI gui = new GUI();
  
  TextField sxTxt = new TextField("1.0");
  TextField syTxt = new TextField("1.0");
  TextField txTxt = new TextField("0.0");
  TextField tyTxt = new TextField("0.0");
  TextField shxTxt = new TextField("0.0");
  TextField shyTxt = new TextField("0.0");    
  TextField rotTxt = new TextField("0.0");
  TextField tx2Txt = new TextField("0.0");
  TextField ty2Txt = new TextField("0.0");
  
  Label naTxt = new Label("");
  //----------------------------------------------------//
                  
  public static void main(String[] args){
    new Java2D001();
  }//end main
  //----------------------------------------------------//

  Java2D001(){//constructor
    setBounds(236,0,235,254);
    setTitle("Copyright 2007, R.G.Baldwin");

    //Construct the user input panel and add it to the
    // CENTER of the Frame.
    Panel inputPanel = new Panel();
    inputPanel.setLayout(new GridLayout(0,3));
    
    inputPanel.add(new Label("Xform Type",Label.CENTER));
    inputPanel.add(new Label("X",Label.CENTER));
    inputPanel.add(new Label("Y",Label.CENTER));
    
    inputPanel.add(new TextField("Scale"));
    inputPanel.add(sxTxt);
    inputPanel.add(syTxt);
    
    inputPanel.add(new TextField("Translate"));
    inputPanel.add(txTxt);
    inputPanel.add(tyTxt);
    
    inputPanel.add(new TextField("Shear"));
    inputPanel.add(shxTxt);
    inputPanel.add(shyTxt);
    
    inputPanel.add(new TextField("Rotate (deg)"));
    inputPanel.add(rotTxt);
    inputPanel.add(naTxt);
    
    inputPanel.add(new TextField("Translate"));
    inputPanel.add(tx2Txt);
    inputPanel.add(ty2Txt);
    
    add(inputPanel,BorderLayout.CENTER);
    
    //Add a button with an ActionListener that allows the
    // user to modify transform parameters, recompute the
    // transform, replot the graphic output, and
    // re-display the matrix data.
    Button button = new Button("Replot");
    button.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        gui.sx = Double.parseDouble(sxTxt.getText());
        gui.sy = Double.parseDouble(syTxt.getText());
        gui.tx = Double.parseDouble(txTxt.getText());
        gui.ty = Double.parseDouble(tyTxt.getText());
        gui.shx = Double.parseDouble(shxTxt.getText());
        gui.shy = Double.parseDouble(shyTxt.getText());
        //Convert angle from degrees to radians.
        gui.rotAngle = (Double.parseDouble(rotTxt.
                              getText()) * Math.PI/180.0);
        gui.tx2 = Double.parseDouble(tx2Txt.getText());
        gui.ty2 = Double.parseDouble(ty2Txt.getText());
        gui.display.repaint();}//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    add(button,BorderLayout.SOUTH);
    setVisible(true);

  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 3 begins by instantiating a new object of an inner class 
named <b>GUI</b> and saving a reference to that object in an instance variable 
named <b>gui</b>.&nbsp; Then it proceeds to construct the user input GUI shown 
on the right in Figure 1.</p>
<p><font color="#FF0000"><b>The ActionListener</b></font></p>
<p>The <b>ActionListener</b> that is registered on the <b>Replot</b> button:</p>
<ul>
	<li>Gets 
all of the user input values in the fields in the input GUI</li>
	<li>Converts them into 
numeric format</li>
	<li>Stores them in instance variables in the object of the inner 
class named <b>GUI</b></li>
</ul>
<p>This code calls the <b>parseDouble</b> method to 
convert the <b>String</b> data from the input fields into numeric values of type
<b>double</b>.&nbsp; If this method is called on a string that cannot be 
converted into a numeric value of type <b>double</b> <i>(including an empty 
string resulting from a blank field)</i>, it will throw a <b>
NumberFormatException</b>.&nbsp; That, in turn, will cause the program to abort 
because I didn't do anything to handle the exception.</p>
<p>Beyond this explanation and the comments in Listing 4, there should be 
nothing else about the code in Listing 3 that requires an explanation.</p>
<p><font color="#FF0000">
<b>Beginning of the inner class named GUI</b></font></p>
<p>The inner class named <b>GUI</b> begins in Listing 4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the inner class named GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  //This is an inner class.
  class GUI extends Frame{
    //The following values are set by the ActionListener
    // that is registered on the Replot button before a
    // call to the repaint method is made.
    double sx = 1.0; //scale X
    double sy = 1.0; //scale Y
    double tx = 0.0; //translate X
    double ty = 0.0; //translate Y
    double shx = 0.0;//shear X
    double shy = 0.0;//shear Y
    double rotAngle = 0.0;//rotate
    double tx2 = 0.0;//translate X again
    double ty2 = 0.0;//translate Y again
    
    <b>Display display = new Display();</b>
    
    GUI(){//constructor
      setBounds(0,0,235,254);
      setTitle("Copyright 2007, R.G.Baldwin");
      <b>add(display,BorderLayout.CENTER);</b>
      setVisible(true);      		
      
      //Window listener to terminate program.
      addWindowListener(new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);}});
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is the class that is used to create, display, and maintain the graphic 
output display shown in the left image in Figure 1.&nbsp; The most significant 
things about the code in Listing 4 are the two boldface statements, which:</p>
<ul>
	<li>Instantiate a new object of another inner class named <b>Display</b>.</li>
	<li>Add that object as a display canvas in the CENTER of the <b>Frame</b> 
	object shown as the left image in Figure 1.</li>
</ul>
<p><font color="#FF0000">
<b>Beginning of the inner class named Display</b></font></p>
<p>This is where the program starts to get interesting.&nbsp; An object of the
<b>Display</b> class provides a <b>Canvas</b> object on which shapes are drawn.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the inner class named 
Display. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      class <b>Display</b> extends <b>Canvas</b>{
        //Override the paint() method to draw and
        // manipulate a rectangle based on user provided
        // transform parameters.
        public void <b>paint</b>(Graphics g){
          //Downcast the Graphics object to a Graphics2D
          // object.
          Graphics2D g2 = (Graphics2D)g;
          
          System.out.println();//Blank line
          System.out.println("Display new matrix data.");
      
          //Display contents of default AffineTransform
          // object.
          System.out.println("Default Transform");
          displayMatrix(g2.<b>getTransform</b>());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In order to create graphics using Java's AWT components, you must extend a 
class that provides a <b>paint</b> method and override the <b>paint</b> method 
to provide the graphic behavior that you need.&nbsp; Although several different 
AWT classes can be used for this purpose, the <b>Canvas</b> class was designed 
by Sun specifically for this purpose.</p>
<p><font color="#FF0000"><b>Display extends Canvas and overrides paint</b></font></p>
<p>As you can see, the <b>Display</b> class that begins in Listing 5 extends the
<b>Canvas</b> class.&nbsp; The code in Listing 5 shows the beginning of the 
overridden <b>paint</b> method.</p>
<p>The paint method receives an incoming parameter that is a reference to an 
object of the <b>Graphics</b> class.&nbsp; As a practical matter, you can 
consider the <b>Graphics</b> object to represent the rectangular portion of the 
screen where you will be drawing your graphic shapes.</p>
<p><font color="#FF0000"><b>The Graphics and Graphics2D classes</b></font></p>
<p>The <b>Graphics</b> class was a part of Java from very early on.&nbsp; It 
provides a nominal set of drawing methods for drawing primitive shapes in 
addition to lines and points.&nbsp; Along the way, a new class named <b>
Graphics2D</b> was added to the Java library as a subclass of the <b>Graphics</b> 
class.&nbsp; It significantly improved the ability of the programmer to create 
onscreen graphics.&nbsp; Because it is a subclass of the <b>Graphics</b> class, 
if you want to use any of the methods defined in the <b>Graphics2D</b> class, 
you must downcast the incoming reference to type <b>Graphics2D</b>.</p>
<p>The first statement in the overridden <b>paint</b> method in Listing 5 
performs this downcast, saving the reference in a variable named <b>g2</b>.&nbsp; 
This is the reference variable that will be used to perform most of the work in 
the overridden <b>paint</b> method.</p>
<p><font color="#FF0000"><b>Get and display a transform</b></font></p>
<p>The last statement in Listing 5 calls the <b>getTransform</b> method on <b>g2</b> 
and passes the returned value to the method named <b>displayMatrix</b> that I 
explained earlier in conjunction with Listing 1.&nbsp; According to the 
documentation, the <b>getTransform</b> method <i>&quot;Returns a copy of the current
Transform in the Graphics2D context.&quot;</i></p>
<p><font color="#FF0000">
 <b>The default transform</b></font></p>
<p>Because this call is made immediately upon entering the overridden <b>paint</b> 
method, the result will be the default transform that is applied to virtual 
coordinates to convert them to absolute coordinates relative to the upper left corner of 
the canvas.&nbsp; The transform is shown in Figure 6.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. The default transform. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Display new matrix data.
Default Transform
 1.00  0.00  0.00
 0.00  1.00  0.00</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The transform matrix shown in Figure 6 is referred to in &quot;Planar 
transformations&quot; <i>(see <a href="#Resources">Resources</a>)</i> as an identity 
matrix, which <i>&quot;transforms a point to itself.&quot;</i>&nbsp; In other words, when 
the <b>paint</b> method begins execution, the transform that is applied to 
virtual coordinates makes no changes at all to those coordinates <i>(except 
perhaps truncating floating coordinate values to integer coordinate values)</i> 
and plots those coordinates in pixels relative to the upper left corner of the 
canvas.</p>
<p>From this point forward, whenever the program performs a transform, the newly 
created transform matrix is multiplied by the current transform matrix to produce a new 
current transform matrix.&nbsp; I will use the <b>getTransform</b> method numerous times 
to get and display the values in the current transform.</p>
<p><font color="#FF0000">
<b>Move the origin to the center of the canvas</b></font></p>
<p>As I have stated more times than you probably wanted to hear, the default 
origin is located at the upper left corner of the canvas.&nbsp; I wasn't happy 
with that.&nbsp; I wanted the origin to be in the center of the canvas.&nbsp; 
Listing 6 calls the <b>translate</b> method of the <b>Graphics2D</b> class to 
rectify this situation and move the virtual origin to the center of the display area.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Move the origin to the center of the 
canvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          g2.<b>translate</b>(getWidth()/2.0,getHeight()/2.0);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>According to Sun, the <b>translate</b> method:</p>
<blockquote>
	<p><i>&quot;Concatenates the current 
Graphics2D Transform with a translation transform. Subsequent rendering is 
translated by the specified distance relative to the previous position.&quot;</i></p>
</blockquote>
<p>In other words, after applying this transform, I can draw something at the 
virtual coordinates (0,0) and it will be drawn in the center of the canvas, as 
shown by the cross in Figure 1.&nbsp; The modified current transform will be 
used to automatically convert my virtual coordinates to actual coordinates 
relative to the upper left corner of the canvas.&nbsp; This is what I attempted 
to explain earlier in conjunction with the discussion surrounding Figure 4.</p>
<p><font color="#FF0000">
<b>Cause the positive y direction to be up instead of down</b></font></p>
<p>However, I still wasn't satisfied.&nbsp; The code in Listing 6 moved the 
virtual origin to the center as desired, but the positive y direction was still 
going down the screen.&nbsp; Listing 7 calls the <b>scale</b> method to flip the 
sign on all subsequent y coordinate values to cause the positive y direction to 
be up instead of down.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Cause the positive y direction to be up 
instead of down. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          g2.<b>scale</b>(1,-1);
          
          System.out.println("After correction for "
                 + "origin and direction of positive Y.");
          System.out.println("Negative y-scale corrects "
                        + "for direction of positive Y.");
          displayMatrix(g2.getTransform());
          </pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>According to the documentation, the <b>scale</b> method:</p>
<blockquote>
	<p><i>&quot;Concatenates the 
current Graphics2D Transform with a scaling transformation.&nbsp; Subsequent rendering 
is resized according to the specified scaling factors relative to the previous 
scaling.&quot;</i></p>
</blockquote>
<p>In other words, from this point forward, all virtual y coordinate values will 
be multiplied by -1 in the process of transforming them into actual y coordinate 
values relative to the upper left corner of the canvas.</p>
<p><font color="#FF0000"><b>Display the current transform</b></font></p>
<p>Listing 7 also gets and displays the current transform, producing the screen 
output shown in Figure 7.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Display the current transform after origin 
	adjustment. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>After correction for origin and direction of positive Y.
Negative y-scale corrects for direction of positive Y.
 1.00  0.00 113.50
 0.00 -1.00 113.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The information shown in Figure 7 is the information that I used to manually 
create the transform matrix shown in boldface in Figure 4.&nbsp; Once again, I 
attempted to explain the impact of this transform in the discussion surrounding 
Figure 4.</p>
<p>Up to this point, the screen output produced by the program will be the same 
each time that it is run.&nbsp; Following this point, the screen output depends 
on the user input values in the GUI shown in Figure 1.</p>
<p><font color="#FF0000">
<b>Draw a rectangle, a circle, and a cross at the origin</b></font></p>
<p>The code in Listing 8 draws a cyan rectangle, a circle, and cross centered on 
the virtual origin as shown in Figure 1.&nbsp; Note, however, that when the 
program is first run, the default user input parameters are as shown in the 
input GUI in Figure 1.&nbsp; This set of parameters results in several more 
rectangles, circles, and crosses being drawn on top of those that are colored 
cyan.&nbsp; The last rectangle drawn is the one that you see, which just happens 
to be blue instead of cyan.&nbsp; <i>(See Figures 12 and 17 for examples where 
the different sets of shapes have been separated in the drawing area.)</i></p>
<p>
<b><a name="Listing_8">Listing 8</a>. Draw a cyan rectangle, a circle, and a 
cross at the origin. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Draw a CYAN rectangle centered on the
          // current origin.
          g2.setColor(Color.CYAN);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          
          //Draw the current origin as a circle containing
          // a cross.
          drawOrigin(g);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Apply a user-specified scale transform</b></font></p>
<p>Listing 9 calls the <b>scale</b> method again to update the transform to include a scale 
component.&nbsp; Then it displays the values contained in the current transform.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Apply a user-specified scale transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          System.out.println(
                            "Update for Scale Transform");
          //Call the scale method to update the transform.
          g2.<b>scale</b>(sx,sy);
          displayMatrix(g2.getTransform());
          
          //Draw a RED rectangle centered on the origin.
          g2.setColor(Color.RED);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When the program first starts running, the default values in the user input 
fields in Figure 1 are &quot;do-nothing&quot; values.&nbsp; Thus, there will be no change 
in the values in the transform from those shown in Figure 7.&nbsp; However, if 
the user enters values <i>(other than 1.0)</i> into either or both of the Scale 
fields shown in Figure 1 and then clicks the <b>Replot</b> button, there will be 
a change in the values contained in the current transform.&nbsp; There will also 
be a change in the graphic output as well.</p>
<p><font color="#FF0000">
 <b>Graphic output produced by user input scale values</b></font></p>
<p>For example, Figure 8 shows the result of scaling the x coordinate values by 
a factor of 5, scaling the y coordinate values by a factor of 10, and leaving 
all of the other input fields unchanged.</p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Graphic output produced by user input scale 
	values. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1550a02.jpg" width="471" height="253"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You can see the cyan rectangle showing through in Figure 8 because it was 
drawn before this scaling transform took effect.&nbsp; The scaling transform had 
an effect on all of the rectangles, circles, and crosses drawn after it took 
effect.</p>
<p><font color="#FF0000"><b>The new transform matrix values after scaling</b></font></p>
<p>Figure 9 shows the values contained in the current transform following the 
execution of the code in Listing 9.</p>
<p>
 <b><a name="Figure_9">Figure 9</a>. The new transform matrix values after 
	scaling. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Scale Transform
<b> 5.00</b>   0.00 113.50
 0.00 <b>-10.00</b> 113.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that a scaling transform impacts only the first value in the first row and 
the second value in the second row, as indicated by the locations of sx and sy 
in the scaling matrix shown in Figure 3.</p>
<p><font color="#FF0000"><b>Draw a red rectangle</b></font></p>
<p>In addition to updating the current transform to include a scaling transform, 
the code in Listing 9 draws a red rectangle, circle, and cross centered on the 
origin.&nbsp; However, it isn't visible in Figure 8 because it gets covered up 
with the blue material that is drawn later.</p>
<p><font color="#FF0000">
<b>Apply a user specified translate transform</b></font></p>
<p>Listing 10 updates the transform to include a user specified translate 
transform.&nbsp; The code in Listing 10 also draws an orange rectangle, a 
circle, and a cross centered on the current virtual origin.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Apply a user specified translate 
transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Update transform to include a translate
          // component,  and display the values.
          System.out.println(
                        "Update for Translate Transform");
          g2.<b>translate</b>(tx,ty);
          displayMatrix(g2.getTransform());
          
          //Draw an ORANGE rectangle centered on the
          // origin.
          g2.setColor(Color.ORANGE);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Translating by 50 and 30 for x and y</b></font></p>
<p>Figure 10 shows the result of setting each of the scale factors to 1.5, 
setting the translate parameter for the x coordinate to 50, setting the 
translate parameter for the y coordinate to 30, and clicking the <b>Replot</b> 
button.</p>
<p>
 <b><a name="Figure_10">Figure 10</a>. Translating by 50 and 30 for x and y. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1550a03.jpg" width="471" height="254"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A very important result</b></font></p>
<p>This is a very important result.&nbsp; You can now see the cyan-colored 
shapes at the original virtual origin.&nbsp; You can also see the red shapes 
centered on the same original virtual origin.</p>
<p>There is an orange rectangle, circle, and cross located under the blue 
versions of the same shapes so you can't see them.&nbsp; Recall that those 
shapes were drawn centered on the virtual origin after the application of the 
translate transform.</p>
<p>Figure 10 demonstrates that what happens when you apply a translate transform 
is that the location of the current virtual origin changes.&nbsp; In this case, 
the current virtual origin has been moved 50 pixels to the right and 30 pixels 
up.&nbsp; We know that because the rectangles, circles, and crosses are always 
centered on the current virtual origin.</p>
<p><font color="#FF0000">
 <b>Contents of the current transform matrix after translation</b></font></p>
<p>Figure 11 shows the contents of the current transform matrix after the 
application of the translate transform.</p>
<p>
 <b><a name="Figure_11">Figure 11</a>. Contents of the current transform matrix 
	after translation. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Translate Transform
 1.50  0.00 <b>188.50</b>
 0.00 -1.50 <b>68.50</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The important thing to note about the data in Figure 11 is the change in the 
two values in the third column.&nbsp; These two values represent tx and ty in 
the translate transform shown in Figure 3.&nbsp; After the application of the 
original translate transform to relocate the virtual origin, both of these 
values were 113.5.&nbsp; The new values shown in Figure 11 were determined not 
only by the translation distances, but also by the scale transform values of 
1.5.&nbsp; You can verify this by doing the matrix multiplication by hand if you 
care to do so.</p>
<p><font color="#FF0000">
<b>Update the current transform to include shear</b></font></p>
<p>Listing 11 updates the current transform to include shear, and then draws a 
black rectangle, circle, and cross centered on the current virtual origin.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Update the current transform to include 
shear. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          System.out.println(
                            "Update for Shear Transform");
          g2.<b>shear</b>(shx,shy);
          displayMatrix(g2.getTransform());

          //Draw a BLACK rectangle centered on the origin.
          g2.setColor(Color.BLACK);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Graphic output after application of the shear transform</b></font></p>
<p>Figure 12 shows the result of leaving the other input parameters the same and 
clicking the <b>Replot</b> button with the shear parameter values shown.</p>
<p>
 <b><a name="Figure_12">Figure 12</a>. Graphic output after application of the 
	shear transform. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1550a04.jpg" width="471" height="254"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Orange shapes are now showing</b></font></p>
<p>Now you can see the orange shapes that were previously covered by black 
shapes and blue shapes.&nbsp; However, the new black shapes are obscured by blue 
shapes.</p>
<p>As you can see, the effect of shear is to cause a rectangle to become a 
parallelogram and to cause similar deformities to occur for other shapes such as 
circles and lines.</p>
<p>A very important aspect of a shear transform is illustrated.&nbsp; Recall 
that the small blue circle in Figure 12 is centered on the virtual origin.&nbsp; 
Recall also that the blue cross is also centered on the virtual origin and the 
lines that comprise the cross are aligned with the virtual axes.&nbsp; The 
virtual axes are no longer orthogonal.&nbsp; The angles at the intersections of 
the virtual axes are no longer 90 degrees.</p>
<p><font color="#FF0000">
 <b>Contents of the current transform following the shear</b></font></p>
<p>Figure 13 shows the contents of the current transform matrix after the 
application of the shear transform.</p>
<p>
 <b><a name="Figure_13">Figure 13</a>. Contents of the current transform 
	following the shear. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Shear Transform
 1.50  <b>0.30</b> 188.50
<b>-0.60</b> -1.50 68.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you compare this with Figure 11, you will see that the only changes were 
to the boldface elements in Figure 13.&nbsp; As it turns out, these two elements 
are impacted by the application of a shear transform.&nbsp; As you will see 
later, these two elements <i>(plus some other elements as well)</i> are also 
impacted by a rotate transform.&nbsp; </p>
<p><font color="#FF0000"><b>Prepare to explain a rotate transform</b></font></p>
<p>The next transform to be considered is a rotate transform.&nbsp; To prepare 
for that, I am going to reset the scale transform parameters to unity and reset 
the shear transform parameters to zero in order to cause the current transform 
matrix to be simpler.&nbsp; The result of doing this is shown in Figure 14.</p>
<p>
 <b><a name="Figure_14">Figure 14</a>. Prepare to explain a rotate transform. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Shear Transform
 1.00  0.00 163.50
-0.00 -1.00 83.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The transform matrix shown in Figure 14 reflects the original translation and 
scaling to deal with the location of the virtual origin and the positive y 
direction plus translation by 50 on x and 30 on y.&nbsp; No other transforms are 
reflected by the matrix values in Figure 14.</p>
<p><font color="#FF0000">
<b>Update the current transform to apply a rotate transform</b></font></p>
<p>Listing 12 applies a rotate transform and then draws a green rectangle, 
circle, and cross centered on the virtual origin.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Update the current transform to apply a 
rotate transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Update transform to provide rotation and
          // display, the transform values.    
          System.out.println(
                           "Update for Rotate Transform");
                           
          g2.<b>rotate</b>(rotAngle);
          displayMatrix(g2.getTransform());

          //Draw a GREEN rectangle centered on the origin.
          g2.setColor(Color.GREEN);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Graphic output following 30-degree rotate transform</b></font></p>
<p>Figure 15 shows the result of applying a 30-degree rotate transform.&nbsp; <i>
(The rectangles are smaller because I reduced the scale transform factors back 
to 1.0.)</i></p>
<p>
 <b><a name="Figure_15">Figure 15</a>. Graphic output following 30-degree rotate 
	transform. </b>
<table border="0" cols="0" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java1550a05.jpg" width="471" height="254"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The green rectangle, circle, and cross <i>(along with the blue shapes that 
are hiding the green shapes)</i> were all rotated 30 degrees counterclockwise.&nbsp; 
This means that the orthogonal axes associated with the new virtual origin are 
no longer horizontal and vertical.&nbsp; Rather, they are now tilted by 30 degrees 
relative to the horizontal and the vertical.</p>
<p><font color="#FF0000">
 <b>Contents of the current transform following a rotate transform</b></font></p>
<p>Figure 16 shows the contents of the current transform matrix following the 
application of the rotate transform.</p>
<p>
 <b><a name="Figure_16">Figure 16</a>. Contents of the current transform 
	following a rotate transform. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Rotate Transform
<b> 0.87 -0.50</b> 163.50
<b>-0.50 -0.87</b> 83.50</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Trigonometry</b></font></p>
<p>Note in particular the boldface values, and compare them with the values 
indicated for the Rotation transform at the bottom of Figure 3. <i>(The 
algebraic signs won't match those shown in Figure 3 because of the sign-flipping 
scale transform performed earlier to change the positive y direction)</i></p>
<p>Go to Google and type in &quot;what is sine 30 degrees&quot;</p>
<p>Google will tell you:</p>
<p>&quot;sine(30 degrees) = 0.5</p>
<p><i>(Just in case you didn't already know that you can do that at Google, you 
have learned something else that is useful in this lesson.)</i></p>
<p>Now do the same for cosine of 30 degrees and you will be told:</p>
<p>&quot;cosine(30 degrees) = 0.866025404&quot;</p>
<p>Going back to Figure 3, you can see that two of the elements in the transform 
matrix in Figure 16 should be the sine of 30 degrees and the other two should be 
the cosine of 30 degrees.&nbsp; Taking into account the fact that I specified a 
display format that rounded the values to two decimal digits, the values in 
Figure 16 are exactly what they should be according to the information provided 
by the article titled &quot;Planar transformations&quot; <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; Had I not applied the sign flipping scale transform 
earlier, even the algebraic signs in Figure 16 would match the algebraic signs 
shown in Figure 3.</p>
<p><font color="#FF0000">
<b>The final translate transform</b></font></p>
<p>Listing 13 applies one additional translate transform before the end of the 
overridden <b>paint</b> method.&nbsp; Then it draws the blue rectangle, circle, 
and cross that we have seen hiding shapes of other colors up to this point.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The final translate transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Update transform to include another translate
          // component and display the values.
          System.out.println(
                 "Update for Second Translate Transform");
          g2.<b>translate</b>(tx2,ty2);
          displayMatrix(g2.getTransform());

          //Draw a BLUE rectangle centered on the origin.
          g2.setColor(Color.BLUE);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
    
        }//end overridden paint()</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Graphic output from the final translate transform</b></font></p>
<p>The graphic output from the final translate transform is shown in Figure 17.</p>
<p>
 <b><a name="Figure_17">Figure 17</a>. Graphic output from the final translate 
	transform. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1550a06.jpg" width="471" height="254"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>For this case, I left all of the other parameters the same as Figure 15 but 
added a final translate transform of 25 pixels in the positive x direction only&nbsp; 
Note that I purposely did not translate in the y direction.</p>
<p><font color="#FF0000"><b>This is very revealing</b></font></p>
<p>What you see in Figure 17 is very revealing.&nbsp; The virtual origin did not 
move along a horizontal path as you might have expected it to do.</p>
<p>Had I not applied a rotation transform earlier, a translation in the positive 
x direction only would have caused the rectangle that is centered on the new 
virtual origin to move horizontally.&nbsp; However, because of the earlier 
rotate transform, <b>the x axis is no longer horizontal</b>.&nbsp; Rather it is tilted 
by 30 degrees relative to the horizontal.&nbsp; As a result, the new virtual 
origin was translated by 25 pixels along a line that is tilted at 30 degrees 
relative to the horizontal.</p>
<p>Thus, a translate transform causes the virtual origin to move without 
changing the orientation of the x and y axes.&nbsp; A rotate transform causes 
the x and y axes to be rotated around the virtual origin without moving the 
virtual origin.&nbsp; It is as though a push pin is&nbsp;used to keep the 
origin on the graph paper fixed in the same spot and then the graph paper is 
rotated around that push pin.</p>
<p><b><font color="#FF0000">Contents of the final transform matrix</font></b></p>
<p>Figure 18 shows the contents of the transform matrix following the final 
translate transform.</p>
<p>
 <b><a name="Figure_18">Figure 18</a>. Contents of the final transform matrix.</b><table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Update for Second Translate Transform
 0.87 -0.50 <b>185.15</b>
-0.50 -0.87 <b>71.00</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Compare Figure 18 with Figure 16 and you will see that only the two values 
highlighted in boldface in Figure 18 were modified by applying this translate 
transform.</p>
<p><font color="#FF0000"><b>The transform method</b></font></p>
<p>In addition to the <b>scale</b>, <b>translate</b>, <b>shear</b>, and <b>
rotate</b> methods used above to modify the current transform, there is also a 
method named <b>transform</b> that can be used to modify the current transform.&nbsp; 
The <b>transform</b> method requires an <b>AffineTransform</b> object as an 
incoming parameter and could be useful if you need to create and use a custom 
transform.</p>
<h2 align="center"><a name="Recap">Recap</a></h2>
<p>We have covered a lot of ground here, so let's recap what we have learned.</p>
<p><font color="#FF0000"><b>The absolute coordinate system</b></font></p>
<p>Shapes are drawn by illuminating pixels on the computer screen in a physical 
area of the screen that is occupied by a Java <b>Canvas</b> object or other 
suitable Java plotting surface.</p>
<p>The Java 2D system always illuminates pixels to draw shapes in an <i>absolute</i> 
Cartesian coordinate system.</p>
<p>The absolute coordinate system contains two orthogonal axes that intersect at 
the absolute origin.</p>
<p>One axis in the absolute coordinate system is horizontal and the other is 
vertical.</p>
<p>The two axes in the absolute coordinate system intersect at the upper left 
corner of the canvas, thus causing the absolute origin to be at the upper left 
corner.</p>
<p>Specific coordinates in the absolute coordinate system are given in screen 
resolution pixels relative to the absolute origin.</p>
<p>The positive direction for horizontal coordinates in the absolute coordinate 
system is to the right, while the positive direction for vertical coordinates in the absolute coordinate 
system is down the screen.</p>
<p><font color="#FF0000"><b>The virtual coordinate system</b></font></p>
<p>Pixels are illuminated and shapes are drawn in a Java 2D program using a <i>
virtual</i> coordinate system.</p>
<p>The origin in the virtual coordinate system may or may not coincide with the 
origin in the absolute coordinate system.</p>
<p>The scale of the virtual coordinate system may or may not be the same as the 
scale of the absolute coordinate system.</p>
<p>The positive directions relative to the virtual origin may or may not be the 
same as the positive directions relative to the absolute origin.</p>
<p>The axes in the virtual coordinate system may or may not be horizontal and 
vertical whereas the axes in the absolute coordinate system are always 
horizontal and vertical.</p>
<p>The axes in the virtual coordinate system may or may not be orthogonal 
whereas the axes in the absolute coordinate system are always orthogonal.</p>
<p><font color="#FF0000"><b>Transforming virtual coordinates into absolute 
coordinates</b></font></p>
<p>The Java 2D plotting system maintains a <i>transform</i> at all times.&nbsp; 
The purpose of the transform is to convert the coordinates of a point in the 
virtual coordinate system into coordinates in the absolute coordinate system.</p>
<p>Whenever a point is plotted in the virtual coordinate system, the current 
transform is used to convert the virtual coordinates of that point into absolute 
coordinates.&nbsp; The absolute coordinates relative to the upper left corner of 
the canvas are then converted to absolute coordinates relative to the upper left 
corner of the screen, and a specific screen pixel is illuminated to represent 
the point being plotted.</p>
<p>The default transform is an identity matrix, which is a &quot;do nothing&quot; 
transform.&nbsp; Hence, the default virtual coordinate system is an exact match 
for the absolute coordinate system.&nbsp; The default origin is at the upper 
left corner of the canvas.&nbsp; The default positive horizontal direction is to 
the right.&nbsp; The default positive vertical direction is down.&nbsp; Default 
coordinate values are given in screen resolution pixels relative to the origin.</p>
<p><font color="#FF0000"><b>Modifying the current transform</b></font></p>
<p>Calling any of the following Graphics2D methods will modify the current 
transform that is maintained by the Java 2D system:</p>
<ul>
	<li>scale</li>
	<li>translate</li>
	<li>shear</li>
	<li>rotate</li>
	<li>transform</li>
</ul>
<p><font color="#FF0000"><b>Changing the virtual coordinate system</b></font></p>
<p>Modifying the current transform effectively causes a change in the virtual 
coordinate system.&nbsp; The change affects only those shapes that are drawn 
after the method is called to modify the current transform.&nbsp; The change 
does not retroactively apply to shapes that were drawn prior to the call to the 
method.</p>
<p>Calling the <b>scale</b> method causes distances relative to the virtual 
origin to be measured differently.&nbsp; It does not modify the location of the 
virtual origin or the orientation of the virtual axes.</p>
<p>Calling the <b>translate</b> method causes the virtual origin to be moved to 
a different location.&nbsp; It does not modify how distances are measured or the 
orientation of the virtual axes.</p>
<p>Calling the <b>shear</b> method changes the orientation of the virtual axes 
such that they are no longer orthogonal.&nbsp; It does not modify the location 
of the virtual origin or how distances are measured.</p>
<p>Calling the <b>rotate</b> method changes the orientation of the virtual axes.&nbsp; 
Both virtual axes are rotated by the same angle around the virtual origin.&nbsp; 
If the axes were previously orthogonal, they remain orthogonal.&nbsp; If the 
virtual axes were not previously orthogonal, the angles at the intersections of 
the virtual axes are not modified.&nbsp; Calling this method does not modify the 
location of the virtual origin or how distances are measured relative to the 
virtual origin.</p>
<p>Calling the <b>transform</b> method changes the virtual coordinate system in 
a manner that is prescribed by the <b>AffineTransform</b> object that is passed 
as a parameter to the method.</p>
<p><font color="#FF0000"><b>The bottom line</b></font></p>
<p>Hopefully, what you have learned in this lesson will better prepare you to 
use transforms when programming with the Java 2D API.&nbsp; Hopefully, it will 
also better prepare you to understand the considerably more complex use of 
transforms in Java 3D, which will be the topic of a future lesson.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to compile and execute the code from Listing 14.&nbsp; Experiment 
with the code, making changes, and observing the results of your changes.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, you learned to understand transforms in Java 2D in a way that 
you will be able to extend to an understanding of transforms in Java 3D.&nbsp; You also learned how to write code 
that makes use of that understanding.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The topics for future lessons include transforms in Java 3D, interactive Java 
3D programs, advanced animation, and surfaces.</p>
<h2 align="center"><a name="Download">Download</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/developer/onlineTraining/java3d/javaa3d.zip">
	Getting Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by 
	Dennis J Bouvier</li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/collateral/examples.zip">
	Source code</a> for example programs from the Bouvier tutorial above</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Version 1.5.0</a> of the Java 3D API</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Implementation documentation</a> for version 1.5.0 of the Java 3D API</li>
	<li>
	<a href="http://www.gamesforwindows.com/en-US/AboutGFW/Pages/DirectX10.aspx">
	Microsoft DirectX10</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://www.dickbaldwin.com/toc.htm">Dick Baldwin's tutorial web 
	site</a></li>
	<li><a href="http://java.sun.com/products/java-media/3D/">Main page</a> for 
	the Java 3D API</li>
	<li>Java 3D <a href="http://wiki.java.net/bin/view/Javadesktop/Java3DFAQ">
	FAQ</a></li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/reference/api/index.html">
	Online documentation</a> for Java 3D version 1.3 <i>(see Download above for 
	v1.5.0 documentation)</i></li>
	<li><a href="http://java.sun.com/developer/onlineTraining/java3d/">Getting 
	Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by Dennis J 
	Bouvier</li>
	<li>
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/javax/media/j3d/doc-files/intro.html">
	Introduction to the Java 3D API</a> with links to other tutorial information</li>
	<li>Various Java 3D <a href="http://www.java3d.org/">resources</a></li>
	<li>Another Java 3D <a href="http://www.java3d.org/tutorial.html">tutorial</a></li>
	<li><a href="http://www.ia.hiof.no/~borres/cgraph/math/twod/p-twod.html">Planar transformations</a></li>
	<li>
	<a href="http://www.ia.hiof.no/~borres/cgraph/math/algebra/p-algebra.html">A 
	little algebra</a></li>
	<li><a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">
	Cartesian coordinate system</a>, Wikipedia</li>
	<li><a href="http://en.wikipedia.org/wiki/Orthogonal">Orthogonality</a>, Wikipedia</li>
	<li><a href="http://en.wikipedia.org/wiki/Trigonometry">Trigonometry</a>, 
	Wikipedia</li>
	<li><a href="http://en.wikipedia.org/wiki/Vector">Vector</a>, Wikipedia</li>
	<li>
	<a href="http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Tech/Chapter05/formatterPrintf.html">
	System.out.printf() - J2SE5.0</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/626051">306</a> 
	Java 2D Graphics, Simple Affine Transforms&nbsp;</li>
	<li>
	<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">1468</a> Plotting Engineering and Scientific Data using Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3622246">1540</a> 
	Understanding Lighting in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3701536">1541</a> Back to Basics in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3704116">1542</a> Digging a Little Deeper into the Java 3D API</li>
	<li><a href="http://www.developer.com/java/data/article.php/3706721">1544</a> Simple Animation with the Java 3D API</li>
	<li><a href="http://www.developer.com/java/other/article.php/3709341">1546</a> Understanding the Alpha Time-Base Class in Java 3D</li>
	<li><a href="http://www.developer.com/java/other/article.php/3712226">1548</a> Combining Rotation and Translation in Java 3d</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program discussed in this lesson is shown in
Listing 14 below.
<p>
<b><a name="Listing_14">Listing 14</a>. Program listing for the program named 
Java2D001. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Java2D001.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to illustrate transforms in
Java 2D space.

This program is very similar to the Java 3D program named 
Java3D010.

A user input GUI allows the user to specify values for 
transforms of the following types:
  
Scale
Translate
Rotate
Shear

A Replot button allows the user to modify input 
parameters, recompute the transforms, and produce a new
output.  Clicking the Replot button when one of the
input fields contains invalid numeric data will cause the
program to abort with a NumberFormatException.

In addition to providing a graphic output display, the 
program also gets and displays the specifiable values in 
the AffineTransform object each time it is updated to
support a new transform.

Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import java.awt.geom.*;
import java.awt.*;
import java.awt.event.*;

class Java2D001 extends Frame{
  GUI gui = new GUI();
  
  TextField sxTxt = new TextField("1.0");
  TextField syTxt = new TextField("1.0");
  TextField txTxt = new TextField("0.0");
  TextField tyTxt = new TextField("0.0");
  TextField shxTxt = new TextField("0.0");
  TextField shyTxt = new TextField("0.0");    
  TextField rotTxt = new TextField("0.0");
  TextField tx2Txt = new TextField("0.0");
  TextField ty2Txt = new TextField("0.0");
  
  Label naTxt = new Label("");
  //----------------------------------------------------//
                  
  public static void main(String[] args){
    new Java2D001();
  }//end main
  //----------------------------------------------------//

  Java2D001(){//constructor
    setBounds(236,0,235,254);
    setTitle("Copyright 2007, R.G.Baldwin");

    //Construct the user input panel and add it to the
    // CENTER of the Frame.
    Panel inputPanel = new Panel();
    inputPanel.setLayout(new GridLayout(0,3));
    
    inputPanel.add(new Label("Xform Type",Label.CENTER));
    inputPanel.add(new Label("X",Label.CENTER));
    inputPanel.add(new Label("Y",Label.CENTER));
    
    inputPanel.add(new TextField("Scale"));
    inputPanel.add(sxTxt);
    inputPanel.add(syTxt);
    
    inputPanel.add(new TextField("Translate"));
    inputPanel.add(txTxt);
    inputPanel.add(tyTxt);
    
    inputPanel.add(new TextField("Shear"));
    inputPanel.add(shxTxt);
    inputPanel.add(shyTxt);
    
    inputPanel.add(new TextField("Rotate (deg)"));
    inputPanel.add(rotTxt);
    inputPanel.add(naTxt);
    
    inputPanel.add(new TextField("Translate"));
    inputPanel.add(tx2Txt);
    inputPanel.add(ty2Txt);
    
    add(inputPanel,BorderLayout.CENTER);
    
    //Add a button with an ActionListener that allows the
    // user to modify transform parameters, recompute the
    // transform, replot the graphic output, and
    // re-display the matrix data.
    Button button = new Button("Replot");
    button.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        gui.sx = Double.parseDouble(sxTxt.getText());
        gui.sy = Double.parseDouble(syTxt.getText());
        gui.tx = Double.parseDouble(txTxt.getText());
        gui.ty = Double.parseDouble(tyTxt.getText());
        gui.shx = Double.parseDouble(shxTxt.getText());
        gui.shy = Double.parseDouble(shyTxt.getText());
        //Convert angle from degrees to radians.
        gui.rotAngle = (Double.parseDouble(rotTxt.
                              getText()) * Math.PI/180.0);
        gui.tx2 = Double.parseDouble(tx2Txt.getText());
        gui.ty2 = Double.parseDouble(ty2Txt.getText());
        gui.display.repaint();}//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    add(button,BorderLayout.SOUTH);
    setVisible(true);

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class.
  class GUI extends Frame{
    //The following values are set by the ActionListener
    // that is registered on the Replot button before a
    // call to the repaint method is made.
    double sx = 1.0; //scale X
    double sy = 1.0; //scale Y
    double tx = 0.0; //translate X
    double ty = 0.0; //translate Y
    double shx = 0.0;//shear X
    double shy = 0.0;//shear Y
    double rotAngle = 0.0;//rotate
    double tx2 = 0.0;//translate X again
    double ty2 = 0.0;//translate Y again
    Display display = new Display();
    
    GUI(){//constructor
      setBounds(0,0,235,254);
      setTitle("Copyright 2007, R.G.Baldwin");
      add(display,BorderLayout.CENTER);
      setVisible(true);      		
      
      //Window listener to terminate program.
      addWindowListener(new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);}});
    }//end constructor
    //--------------------------------------------------//
    
      //This is an inner class, that provides a Canvas
      // object on which the shapes are drawn.
      class Display extends Canvas{
        //Override the paint() method to draw and
        // manipulate a rectangle based on user provided
        // transform parameters.
        public void paint(Graphics g){
          //Downcast the Graphics object to a Graphics2D
          // object.
          Graphics2D g2 = (Graphics2D)g;
          
          System.out.println();//Blank line
          System.out.println("Display new matrix data.");
      
          //Display contents of default AffineTransform
          // object.
          System.out.println("Default Transform");
          displayMatrix(g2.getTransform());

          //Apply a translation to move the origin to the
          // center of the display area.
          g2.translate(getWidth()/2.0,getHeight()/2.0);

          //Flip the sign on y values to cause the
          // positive y-direction to be up instead of
          // down, which is the default.
          g2.scale(1,-1);
          
          System.out.println("After correction for "
                 + "origin and direction of positive Y.");
          System.out.println("Negative y-scale corrects "
                        + "for direction of positive Y.");
          displayMatrix(g2.getTransform());
          
          //Draw a CYAN rectangle centered on the
          // current origin.
          g2.setColor(Color.CYAN);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          
          //Draw the current origin as a circle containing
          // a cross.
          drawOrigin(g);   
          
          //Update transform to include a scale component,
          // and display the values.
          System.out.println(
                            "Update for Scale Transform");
          //Call the scale method to update the transform.
          g2.scale(sx,sy);
          displayMatrix(g2.getTransform());
          
          //Draw a RED rectangle centered on the origin.
          g2.setColor(Color.RED);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
      
          //Update transform to include a translate
          // component,  and display the values.
          System.out.println(
                        "Update for Translate Transform");
          g2.translate(tx,ty);
          displayMatrix(g2.getTransform());
          
          //Draw an ORANGE rectangle centered on the
          // origin.
          g2.setColor(Color.ORANGE);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
      
          //Update transform to include a shear component,
          // and display the values.
          System.out.println(
                            "Update for Shear Transform");
          g2.shear(shx,shy);
          displayMatrix(g2.getTransform());

          //Draw a BLACK rectangle centered on the origin.
          g2.setColor(Color.BLACK);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
      
          //Update transform to provide rotation and
          // display, the transform values.    
          System.out.println(
                           "Update for Rotate Transform");
                           
          g2.rotate(rotAngle);
          displayMatrix(g2.getTransform());

          //Draw a GREEN rectangle centered on the origin.
          g2.setColor(Color.GREEN);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
          
          //Update transform to include another translate
          // component and display the values.
          System.out.println(
                 "Update for Second Translate Transform");
          g2.translate(tx2,ty2);
          displayMatrix(g2.getTransform());

          //Draw a BLUE rectangle centered on the origin.
          g2.setColor(Color.BLUE);
          g2.draw(new Rectangle2D.Double(-10,-10,20,20));
          drawOrigin(g);
    
        }//end overridden paint()
        //----------------------------------------------//
        
        //This method will draw a circle containing a
        // cross at the current origin.
        void drawOrigin(Graphics g){
          Graphics2D g2 = (Graphics2D)g;
          g2.drawLine(-7,0,7,0);
          g2.drawLine(0,-7,0,7);
          g2.drawOval(-5,-5,10,10);
        }//end drawOrigin
        //----------------------------------------------//
      }//end inner class Display
      //================================================//
      
    //This method receives a reference to an
    // AffineTransform and displays the six specifiable
    // values in the transform matrix.
    void displayMatrix(AffineTransform theTransform){
      
      //Retrieve the contents of the AffineTransform into
      // an array of type double.
      double[] theMatrix = new double[6];
      theTransform.getMatrix(theMatrix);

      //See http://www.particle.kth.se/~lindsey/JavaCourse
      // /Book/Part1/Tech/Chapter05/formatterPrintf.html
      // for instructions on the use of System.out.printf.

      //Display first row of values by displaying every
      // other element in the array starting with element
      // zero.
      Sys0em.out.printf ("%5.2f %5.2f %5.2f %n", 
                  theMatrix[0],theMatrix[2],theMatrix[4]);
      //Display second row of values displaying every
      // other element in the array starting with element
      // number one.
      System.out.printf ("%5.2f %5.2f %5.2f %n", 
                 theMatrix[1],theMatrix[3],theMatrix[5]);
      
    }//end displayMatrix
    //--------------------------------------------------//
  }//end class GUI
  //====================================================//

}//end class Java2D001</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java &quot;java 3D&quot; &quot;Java 2D&quot; canvas scale translate shear rotate </p>
<p>-end- </p>
</body>
</html>
