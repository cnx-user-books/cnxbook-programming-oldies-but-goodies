<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <title>... in Java by Richard G Baldwin</title>
</head>
  <body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
  
<h2> An Automated Test Program using the Java Robot Class</h2>
 <i>Baldwin shows you how to use a Java robot to perform automatic testing
on a  Java GUI.</i>
<p><b>Published:</b>&nbsp; July 29, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b> 
</p>
<p>Java Programming Notes # 1474</p>
<ul>
 <li> <a href="#Preface">Preface</a></li>
 <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and Sample
Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program Listings</a></li>
 
</ul>
  
<hr size="3" width="100%" align="center"> 
<center> 
<h2> <a name="Preface"></a>Preface</h2>
</center>
 
<p> Programming in Java doesn't have to be dull and boring.&nbsp; In fact,
it's possible  to have a lot of fun while programming in Java.&nbsp; This
is the second lesson in a  short miniseries that shows you how to use the
<b>Robot</b> class to write programs  that are both fun and useful.</p>
 
<p> <b><font color="#ff0000">New features in SDK Version 1.3</font></b></p>
 
<p>One of the new features that was released in SDK Version 1.3 was the <b>Robot</b>
class.&nbsp; According to Sun, </p>
 
<blockquote> 
  <p><i>"This class is used to generate native system input events for the
 purposes of test automation, self-running demos, and other applications
where  control of the mouse and keyboard is needed. The primary purpose of
Robot is to  facilitate automated testing of Java platform implementations."</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>What is a Java robot?</b></font></p>
 
<p>The <b>Robot</b> class makes it possible for your Java program to temporarily
take  control of the  mouse and keyboard input functionality at the operating-system
level.</p>
 
<p><font color="#ff0000"><b>Several instance methods are available</b></font></p>
 
<p>The <b>Robot</b> class provides several instance methods, <i>(including
the  following),</i> by which your program can produce mouse and keyboard
input, just as  though that input were being provided by a human user.</p>
 
<ul>
   <li><b>mouseMove</b> - Moves the mouse pointer to a set of specified absolute
   screen coordinates given in pixels.</li>
   <li><b>mousePress</b> - Presses one of the buttons on the mouse.</li>
   <li><b>mouseRelease</b> - Releases one of the buttons on the mouse.</li>
   <li><b>keyPress</b> - Presses a specified key on the keyboard.</li>
   <li><b>keyRelease</b> - Releases specified key on the keyboard.</li>
 
</ul>
 
<p><font color="#ff0000"><b>A word of caution</b></font></p>
 
<p>A runaway Java <b>Robot</b> object has the ability to wrest control away
from  the human user, so you need to be a little careful.&nbsp; For example,
if you  allow your Java <b>Robot</b> program to go into an infinite loop,
making mouse  moves, clicking the mouse, and entering keystrokes, you may
find that the only  practical way to regain control of your computer is to
either turn off the power  or press the reset button to force your computer
to restart.</p>
 
<p><font color="#ff0000"><b>Three lessons in the miniseries</b></font></p>
 
<p>According to my current plans, this miniseries on the <b>Robot</b> class
 will consist of three lessons.&nbsp; The first lesson, entitled&nbsp;<a
 href="http://www.developer.com/java/other/article.php/2212401">Introduction
to the Java Robot Class in Java</a>, demonstrated the  low-level nature of
 an object of the <b>Robot</b> class.&nbsp;  That was accomplished by showing
you how to create a Java robot that can  manipulate other non-Java programs,
such as Windows Notepad and Internet  Explorer.</p>
 
<p>This lesson, which is the second lesson in the miniseries, will show you
how to use a robot to  perform automatic testing on a Java GUI.</p>
 
<p>The third lesson will show you how to write a robot program to  provide
a visual animated demonstration of the use of a Java GUI.</p>
 
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate 
browser window.&nbsp; That will make it easier for you to scroll back and 
forth among the different listings and figures while you are reading about 
them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However,
as of the date of this writing, Gamelan doesn't maintain a consolidated index
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp;
You will find a consolidated index at <font color="#000000"> <a
 href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font> </p>
<h2 align="center"><font color="#000000"> <a name="Preview">Preview</a></font></h2>
 
<p>I will discuss the sample programs named <b>Robot02</b> and <b>Robot02Slave</b>
 in this lesson.</p>
<blockquote> 
  <p> <i>(The program named <b>Robot02</b> uses a <b>Robot</b>  object to
perform tests on an instance of the class named <b>Robot02Slave</b>.)</i></p>
</blockquote>
 
<p>The  sample programs in this lesson will show you how to use a Java robot
to perform  automatic testing on a Java GUI.</p>
<center> 
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion 
and Sample Code</font></h2>
</center>
   
<p> <font color="#ff0000"><b>Description of the program named Robot02Slave</b></font></p>
<p> Figure 1 shows the GUI produced by the program named <b>Robot02Slave</b>
on  startup, before being exercised by the <b>Robot</b> object belonging
to the  program named <b>Robot02</b>.&nbsp; The GUI contains eight <b>JToggleButton</b>
 objects and one <b>JTextField</b> object in a <b>GridLayout</b>.</p>
<p align="center"> <img border="0" src="java1474a.gif" width="251"
 height="201">
</p>
<p align="center"> Figure 1 Test program GUI on startup</p>
<p> As you can see, the <b>JToggleButton</b> in the upper left corner has
the focus  and none of the toggle buttons are <i>selected</i> at startup.</p>
<p> <font color="#ff0000"><b>Can be manipulated by Robot02</b></font></p>
<p> The class named <b>Robot02Slave</b> is used to instantiate a GUI object
that  can be manipulated by an object of the class named <b>Robot02</b>.&nbsp;
The  class can also be used to instantiate a GUI object that can be manipulated
manually using the mouse and the keyboard, independent of the robot object.</p>
<p> <font color="#ff0000"><b>Will fire action and focus events</b></font></p>
<p> When you click on any of the buttons, the button will fire an <b>ActionEvent</b>.&nbsp;
 Also, when you click on any of the buttons, the button will gain the focus
and  fire a <b>FocusEvent</b> if the button didn't already have the focus.</p>
<p> <font color="#ff0000"><b>Button will toggle between two states</b></font></p>
<p> Because the button is a <b>JToggleButton</b>, it will also toggle between
being selected and not  being selected.&nbsp; When the button is not selected,
 it is colored a light shade of gray, and appears to protrude from the screen
<i> (due to the Motif look and feel).</i> When the button is selected, it
is colored a dark shade of  gray and appears to be pushed into the screen
<i>(see Figure 2 later for an  example of selected buttons).</i></p>
<p> <font color="#ff0000"><b>Text field also fires action and focus events</b></font></p>
<p> When you click the text field, it will gain the focus.&nbsp; When you
 press the ENTER key  while the text field has the focus, it will fire an 
<b>ActionEvent</b>.&nbsp;</p>
<p> <font color="#ff0000"><b>Focus traversal</b></font></p>
<p> If you successively press the <i>focus traversal key,</i> the focus will
traverse the components  using the <i>focus traversal policy</i> that is
in effect.&nbsp; I did not  implement a new focus traversal policy, nor did
I change the focus traversal  key.&nbsp; Therefore, the default focus traversal
policy and the default focus  traversal key are both in effect.&nbsp; Successively
pressing the TAB key will cause the focus to move from one component to the
next, top to bottom,  left to right, and then back to the top left.</p>
<p> If you hold down the SHIFT key and successively press the TAB key, the
focus will traverse  the components in the reverse direction.</p>
<p> <font color="#ff0000"><b>Focus events</b></font></p>
<p> In all cases that the focus moves from one component to another, regardless
of  the cause, the component that gains the focus and the component that
loses the  focus will each fire a <b>FocusEvent</b>.</p>
<p> <font color="#ff0000"><b>Common event handlers</b></font></p>
<p> A common <b>ActionEvent</b> handler is registered on each of the eight
buttons and the text field.&nbsp; The event handler gets and displays the
 value of the <b>actionCommand</b> property for the component that fired
the event.</p>
<p> Whenever a component loses or gains the focus, that component will fire
a <b>FocusEvent</b>.&nbsp;  A common <b>FocusEvent</b> handler is registered
on each of the eight buttons and the text field.&nbsp; The event handler
gets and displays the  value of the <b>name</b> property for the component
 that fired the event, along with an indication as to whether the focus was
lost or gained  by that component.</p>
<p> <font color="#ff0000"><b>Sample screen outputs</b></font></p>
<p> Here is the screen output produced by the event handlers as a result
of manually  clicking the button with the H while the button with the A has
the focus.</p>
<p> <b><font face="monospace">A lost focus H gained focus<br>
 ActionCommand = H</font></b></p>
<blockquote>   
  <p> <i>(Note that the value of the <b>name</b> property for each button
was set to match the text on the face of the  button.&nbsp; The text on the
face of a button is the default action command for  the button.&nbsp; Also
note that  the value of the <b>name</b> property for the text field was set
to I.)</i></p>
</blockquote>
 
<p> Here is the screen output produced by pressing the TAB key several times
in  succession, causing the focus to traverse the components in a forward
direction.</p>
<p> <b><font face="monospace">H lost focus I gained focus<br>
 I lost focus A gained focus<br>
 A lost focus B gained focus<br>
 B lost focus C gained focus<br>
 C lost focus D gained focus<br>
 D lost focus E gained focus<br>
 E lost focus F gained focus</font></b></p>
<p> Note that the button showing the H had the focus when this sequence began.</p>
<p> <font color="#ff0000"><b>Nothing special was required</b></font></p>
<p> With one exception, nothing special was done to cause this program to
be  suitable for manipulation by the program named <b>Robot02</b>.&nbsp;
That  exception has to do with the <b>main</b> method<b>.&nbsp; </b>As you
will see  later, the <b>main</b> method does not include any code that is
necessary for  this program to behave properly.&nbsp; The code in the <b>main</b>
method simply  instantiates an object of the controlling class.</p>
<p> The program was tested using SDK 1.4.1 under WinXP.</p>
<p><font color="#ff0000"><b> The main method for the program named Robot02Slave</b></font></p>
   
<p>I will discuss this program in fragments.&nbsp; A complete listing of
the    program is shown in Listing 24 near the end of the lesson.</p>
<p>Most of the code  in this program is straightforward, and is explained
in other tutorial lessons  on my <a href="http://www.dickbaldwin.com">web
site</a>.&nbsp; Therefore, the  discussion of this program will be very brief.&nbsp;
The more detailed  discussion will be reserved for the program named <b>Robot02</b>
later in the  lesson.</p>
<p>The program named <b>Robot02Slave</b> begins in Listing 1 where the <b>main</b>
 method starts by instantiating an object of the class to which it belongs.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>public class Robot02Slave extends JFrame<br>         implements ActionListener,FocusListener{<br><br>  public static void <b>main</b>(String[] args){<br>    <b>new Robot02Slave()</b>;<br>  }//end main<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>This main method can be used to run the program in a standalone mode independent
of the  robot program.</p>
 
<blockquote> 
  <p><i>(Note than this class implements two listener interfaces.&nbsp; Therefore,
 an object of this class is a valid listener for action events and focus
events.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Prepare the JFrame for use</b></font></p>
 
<p>The constructor for the class begins in Listing 2.&nbsp; The code in Listing
 2 prepares the JFrame for use by setting the title, layout, location on
the screen,  size, etc.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public Robot02Slave(){//constructor<br><br>    setDefaultCloseOperation(<br>                          JFrame.EXIT_ON_CLOSE );<br>    getContentPane().setLayout(<br>                            new GridLayout(3,3));<br>    setBounds(10,10,250,200);<br>    setTitle("Copyright 2003, R.G.Baldwin");<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Create the button objects</b></font></p>
 
<p>The code in Listing 3 instantiates eight anonymous <b>JToggleButton</b>
 objects and adds them to the content pane.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    for(int cnt = 0; cnt &lt; 8; cnt++){<br>      getContentPane().add(new JToggleButton(<br>                        "" + (char)('A' + cnt)));<br>    }//end for loop<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>The text on the faces of the buttons is set to the letters A through H.</p>
 
<p><font color="#ff0000"><b>Add a text field</b></font></p>
 
<p>The code in Listing 4 adds a <b>JTextField</b> object as the ninth component.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    getContentPane().add(new JTextField(""));<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Get a list of the components</b></font></p>
 
<p>The code in Listing 5 gets a list of references to all nine components
and stores them in the elements of  an array of references of type <b>Component</b>.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    Component[] components =<br>          getContentPane().getComponents();<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Register event listeners on the components</b></font></p>
 
<p>The code in Listing 6 registers action and focus listeners on each of
the  components.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    for(int cnt = 0; cnt &lt; components.length;<br>                                          cnt++){<br>      //Must downcast in order to register an<br>      // action listener.<br>      if(components[cnt] instanceof<br>                                  JToggleButton){<br>        ((JToggleButton)components[cnt]).<br>                         <b>addActionListener(this)</b>;<br>      }else if(components[cnt] instanceof<br>                                     JTextField){<br>        ((JTextField)components[cnt]).<br>                         <b>addActionListener(this)</b>;<br>      }//end else<br><br>      //Register a focus listener on each<br>      // component<br>      components[cnt].<b>addFocusListener(this)</b>;<br><br>      //Give each component a name.  Make the<br>      // name match the text on the face of the<br>      // buttons.  Name the text field "I"<br>      components[cnt].<b>setName</b>(<br>                         "" + (char)('A' + cnt));<br>    }//end for loop<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>In addition, the code in Listing 6 sets the value of the <b>name</b> property
of each  component to a unique value by which we can recognize it later.</p>
 
<p>The code in Listing 6 is straightforward, so I won't discuss it further.</p>
 
<p><font color="#ff0000"><b>Set the look and feel, and make the GUI visible</b></font></p>
 
<p>The code in Listing 7 sets the look and feel to Sun's Motif, and makes
the  GUI visible.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    String plafClassName =<br>               "com.sun.java.swing.plaf.motif." +<br>                              "MotifLookAndFeel";<br>    try{<br>       UIManager.setLookAndFeel(plafClassName);<br>     }catch(Exception ex){ex.printStackTrace();}<br><br>     //Cause the new L&amp;F to be applied<br>     SwingUtilities.updateComponentTreeUI(this);<br><br>    //Make the frame visible<br>    setVisible( true );<br>  }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Once again, the code in Listing 7 is straightforward, so I won't discuss
it  further.</p>
 
<p>Listing 7 signals the end of the constructor.</p>
 
<p><font color="#ff0000"><b>Define the action listener</b></font></p>
 
<p>Because the class named <b>Robot02Slave</b> implements the <b>ActionListener</b>
 interface, it must define the method named <b>actionPerformed</b>, which
is  declared in the interface.&nbsp; This is accomplished in Listing 8.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public void <b>actionPerformed</b>(ActionEvent e){<br>    System.out.println("ActionCommand = "  +<br>                           e.getActionCommand());<br>  }//end actionPerformed<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>This code makes it possible to register <b>this</b> object as an action
 listener on each of the components in Listing 6.</p>
 
<p><font color="#ff0000"><b>Display the actionCommand property</b></font></p>
 
<p>The code in the <b>actionPerformed</b> method gets and displays the <b> 
actionCommand</b> property belonging to the component that fired the <b> ActionEvent</b>.&nbsp;
The default value for the <b>actionCommand</b> property  for a <b>JToggleButton</b>
object is the text on the face of the button.&nbsp;  The value of the <b>actionCommand</b>
property for a <b>JTextField</b> object is  the contents of the text field
when the event was fired.</p>
 
<p><font color="#ff0000"><b>Define the focus listener</b></font></p>
 
<p>Because the class named <b>Robot02Slave</b> implements the <b>FocusListener</b>
 interface, it must define the methods named <b>focusLost</b>, and <b>focusGained</b>,
 which are declared in the interface.&nbsp; This is accomplished in Listing
9.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public void <b>focusLost</b>(FocusEvent e){<br>    System.out.print(e.getComponent().getName()<br>                             + " lost focus  ");<br>  }//end focus lost<br><br>  public void <b>focusGained</b>(FocusEvent e){<br>    System.out.println(e.getComponent().getName()<br>                              + " gained focus");<br>  }//end focusGained<br><br>}//end class definition<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>As is the case with the action listener, this code makes it possible to
 register <b>this</b> object as a focus listener on each of the components
in  Listing 6.</p>
 
<p><font color="#ff0000"><b>Firing focus events</b></font></p>
 
<p>Whenever the focus moves from one component to another,  the component
 losing the focus and the component gaining the focus each fire a focus event.</p>
 
<p>Among other things, the <b>FocusEvent</b> object passed to the <b>focusLost</b>
method identifies  the component that lost the focus.&nbsp; The <b>FocusEvent</b>
object passed to  the <b>focusGained</b> method identifies the component
that gained the focus.</p>
 
<p><font color="#ff0000"><b>Display the value of the name property</b></font></p>
 
<p>When a focus event is fired, the code in Listing 9 displays the value
of the <b>name</b> property belonging to the component that either lost or
gained the  focus, causing it to fire the event.</p>
 
<p><font color="#ff0000"><b>End of Robot02Slave program</b></font></p>
 
<p>Listing 9 also signals the end of the program named <b>Robot02Slave</b>.</p>
 
<p><font color="#ff0000"><b>Description of the program named Robot02</b></font></p>
 
<p>There is no GUI for the program named <b>Robot02</b>.&nbsp; The program
 simply starts, instantiates an object of the <b>Robot02Slave</b> class,
executes  a series of mouse moves, mouse clicks, and keyboard inputs on that
object, and  then terminates.</p>
 
<p><font color="#ff0000"><b>A dynamic process</b></font></p>
 
<p>Because this is a dynamic process, you will need to actually run the program
 to see exactly how it behaves.&nbsp; Figure 2 shows the GUI produced by
the  program named <b>Robot02Slave</b> after being exercised by the <b>Robot</b>
 object belonging to the program named <b>Robot02</b>.</p>
 
<p align="center"><img border="0" src="java1474b.gif" width="251"
 height="201">
</p>
 
<p align="center">Figure 2 Test program GUI after being exercised by the
robot</p>
 
<p>You may find it useful to compare the appearance of the GUI in Figure
2 with  the appearance of the GUI at startup shown earlier in Figure 1.</p>
 
<p><font color="#ff0000"><b>Behavior of the program named Robot02</b></font></p>
 
<p>This program illustrates the use of the <b>Robot</b> class, which was
released in SDK Version 1.3,  to exercise the various features of a Java
GUI.</p>
 
<p>The program instantiates an object of the class named <b>Robot02Slave</b>.&nbsp;
 The GUI belonging to this object contains eight <b>JToggleButton</b> objects
and a <b>JTextField</b> object in a <b>GridLayout</b> as shown in Figures
1 and 2.&nbsp;  This program uses an object of the <b>Robot</b> class to
exercise the GUI  belonging to the <b>Robot02Slave</b> object.</p>
 
<p><font color="#ff0000"><b>Focus traversal</b></font></p>
 
<p>The upper-left button in the GUI shown in Figure 1  holds the focus  when
the program starts.</p>
 
<p>The robot presses the TAB key a sufficient number of times to cause the
focus to traverse all of the components  once in the forward direction according
to the focus traversal policy in effect.&nbsp;  Because the default focus
traversal policy is in effect, this causes the focus  to move from left to
right, top to bottom, ending on the text field in the  bottom right as shown
in Figure 2.</p>
 
<p>Then the robot holds down the SHIFT key and presses the TAB key a sufficient
 number of times to cause the focus to traverse all of the components once
in the reverse direction.&nbsp; At this point, the button in the upper left
 once again holds the focus, as shown in Figure 1.</p>
 
<p>A time delay is inserted between successive presses of the TAB key so
that  you can view the focus as it traverses the components.</p>
 
<p><font color="#ff0000"><b>Click the mouse on each button</b></font></p>
 
<p>The program identifies each of the components in the GUI produced by <b>Robot02Slave</b>,
 and determines the physical location of each of those components on the
screen.</p>
 
<p>Once the robot has determined the location of a component, it presses
and  then releases the left mouse button on that component.&nbsp;  This constitutes
a <i>click</i> on the button.</p>
 
<p><font color="#ff0000"><b>How do the components behave?</b></font></p>
 
<p>Clicking the mouse on a <b>JToggleButton</b> object causes the button
to fire an <b>ActionEvent</b>  and a <b>FocusEvent</b>.</p>
 
<p>Clicking the mouse on a <b>JTextField</b> object causes the text field
to  fire a <b>FocusEvent</b>.</p>
 
<p><font color="#ff0000"><b>Enter text into the JTextField object</b></font></p>
 
<p>Then, the program determines if the component being processed is a <b>JTextField</b>
object.&nbsp; If so, it  types the text <b>Done</b> into the text field and
presses the ENTER key to cause the text field to fire an <b>ActionEvent</b>.</p>
 
<p>This program was tested on my machine using SDK 1.4.1 under WinXP</p>
 
<p><font color="#ff0000"><b>Will discuss in fragments</b></font></p>
 
<p>As usual, I will discuss this program in fragments.&nbsp; A complete listing
 of the program is shown in Listing 23 near the end of the lesson.&nbsp;
The  class definition begins in Listing 10 with the declaration of a reference
 variable to hold a reference to an object of type <b>Robot</b>.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>public class Robot02{<br>  Robot robot;<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Create an object to be exercised</b></font></p>
 
<p>The code in Listing 11 instantiates a new object of the class named <b> 
Robot02Slave</b>, discussed earlier in this lesson.&nbsp; That object's  reference
is saved in a reference variable named <b>slave</b>, in order that it  can
be manipulated by the robot.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  Robot02Slave slave = new Robot02Slave();<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Create some keycodes</b></font></p>
 
<p>The code in Listing 12 creates an array object of type <b>int</b>, and
 initializes the elements of the array to contain the virtual keycodes for
the  characters <b>done</b><i>.</i></p>
<blockquote> 
  <p> <i>(Note that regardless of the case of the characters in the names
of the  virtual keycodes, these keycodes must be combined with the virtual
SHIFT keycode  to produce upper-case versions of the characters.)</i></p>
</blockquote>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  int keyInput[] = {<br>      KeyEvent.VK_D,<br>      KeyEvent.VK_O,<br>      KeyEvent.VK_N,<br>      KeyEvent.VK_E<br>  };//end keyInput array<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p>As shown earlier in Figure 2, these characters will be automatically entered
 into the <b>JTextField</b> object belonging to the GUI being exercised by
the  robot.</p>
 
<p><font color="#ff0000"><b>The main method</b></font></p>
 
<p>The <b>main</b> method for the program named <b>Robot02</b> is shown in
Listing 13.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public static void <b>main</b>(String args[]){<br>    System.out.println("Start test program");<br>    <b>new Robot02()</b>;<br>    System.out.println("\nEnd test program");<br>  }//end main<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>As you can see, the code in the <b>main</b> method simply displays starting
 and ending messages and instantiates an  object of the <b>Robot02</b> class.</p>
 
<p><font color="#ff0000"><b>The constructor</b></font></p>
 
<p>The behavior of the program is controlled by code in the constructor,
<i> (which begins in Listing 14),</i> and code in a method that is called
by code in  the constructor.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public Robot02(){//constructor<br>    try{<br>      robot = <b>new Robot()</b>;<br>    }catch(AWTException e){<br>      e.printStackTrace();<br>    }//end catch<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p>The constructor begins by instantiating an object of the <b>Robot</b>
class,  and saving that object's reference in the instance variable named
<b>robot</b>,  which was declared in Listing 10.&nbsp; Because the reference
is saved in an  instance variable, it is accessible throughout the class.</p>
 
<p><font color="#ff0000"><b>Is the slave object visible?</b></font></p>
 
<p>Because of delays involved in displaying graphics, it is possible that
the  robot could become ready to be manipulate the GUI before the GUI is
ready to be  manipulated.&nbsp; Therefore, the code in Listing 15 loops until
the <b>showing</b>  property of the GUI object becomes true.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    while(!(slave.isShowing())){<br>      //loop until slave is showing on the screen<br>    }//end while loop<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<blockquote> 
  <p><i>(In order to avoid tying up computer resources with a tight loop,
and  slowing things down even more, it might be better to cause the current
thread to  sleep for a short period of time during each iteration of the
loop in Listing  15.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Get a list of GUI components</b></font></p>
 
<p>The code in Listing 16 gets a list of the components belonging to the
GUI and  saves the references to those components in the elements of an array
object of  type <b>Component</b>.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    Component[] components =<br>          slave.getContentPane().getComponents();<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>The <b>length</b> of the array will be used by the robot to determine
how  many times to press the TAB key to cause the focus to traverse all of
the  components in the GUI.</p>
 
<p>The references stored in the array will be used by  the robot later to
click the mouse on each of the components.</p>
 
<p><font color="#ff0000"><b>Traverse the components in the forward direction</b></font></p>
 
<p>The code in Listing 17 prints a message, and then presses the TAB key
a  sufficient number of times to cause the focus to traverse all of the components
 once in the forward direction.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    System.out.println("\nTraverse forward");<br>    for(int cnt = 0;<br>           cnt &lt; (components.length - 1); cnt++){<br>      robot.<b>keyPress</b>(KeyEvent.VK_TAB);<br>      //Insert delays to cause the focus to<br>      // traverse the components slowly.<br>      robot.delay(1000);<br>    }//end for loop<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>A one-second delay is inserted between each key press to make it possible
to  view the focus as it traverses the components.</p>
 
<p><font color="#ff0000"><b>Focus events</b></font></p>
 
<p>Because focus events are fired each time the focus moves from one component
 to the next, the code in Listing 17 produces the following output on the
screen.</p>
 
<p><b><font face="monospace">Traverse forward<br>
 A lost focus B gained focus<br>
 B lost focus C gained focus<br>
 C lost focus D gained focus<br>
 D lost focus E gained focus<br>
 E lost focus F gained focus<br>
 F lost focus G gained focus<br>
 G lost focus H gained focus<br>
 H lost focus I gained focus</font></b></p>
 
<p>Each line of text shown above <i>(except for the first line)</i> was actually
 the result of two focus events being fired.&nbsp; One event was fired by
the  component that lost the focus.&nbsp; The other event was fired by the
component  that gained the focus.</p>
 
<blockquote> 
  <p><i>(If you review the event handler methods in Listing 9, you will see
that I  invoked the <b>print</b> method for <b>focusLost</b> and the <b>println</b>
 method for <b>focusGained</b>.&nbsp; This causes each pair of events to
produce  a single line of text in the output.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Where is the screen output produced?</b></font></p>
<p>It  is important for you to understand that except for the first line
of text shown  above, the screen output that is produced when the focus moves
is being produced  by the event handler methods belonging to the GUI object,
and is not being  produced by the robot.&nbsp; The robot simply causes the
focus to move by  pressing the TAB key.&nbsp; The behavior that results is
strictly dependent on  the event handlers belonging to the GUI being manipulated.</p>
<p> <font color="#ff0000"><b>Traverse the components in the reverse direction</b></font></p>
<p> The code in Listing 18 prints a message and then presses the SHIFT key.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    System.out.println("\nTraverse backwards");<br>    //Press the shift key.<br>    robot.keyPress(KeyEvent.VK_SHIFT);<br>    for(int cnt = 0;<br>           cnt &lt; (components.length - 1); cnt++){<br>      robot.keyPress(KeyEvent.VK_TAB);<br>      robot.delay(1000);<br>    }//end for loop<br>    //Release the shift key.<br>    robot.keyRelease(KeyEvent.VK_SHIFT);<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Then the robot presses the TAB key a sufficient number of times to cause
the  focus to traverse all of the components once in the reverse direction.&nbsp;
 Then the robot releases the SHIFT key.</p>
 
<p><font color="#ff0000"><b>Focus events</b></font></p>
 
<p>Again, because focus events are fired each time the focus moves from one
 component to the next, the code in Listing 18 produces the following output
on  the screen.</p>
<p><b><font face="monospace">Traverse backwards<br>
 I lost focus H gained focus<br>
 H lost focus G gained focus<br>
 G lost focus F gained focus<br>
 F lost focus E gained focus<br>
 E lost focus D gained focus<br>
 D lost focus C gained focus<br>
 C lost focus B gained focus<br>
 B lost focus A gained focus</font></b></p>
<p><font color="#ff0000"><b>Click the  components and enter text into the
text field</b></font></p>
<p>The robot's next    task is to execute a mouse click on each of the components
and to enter  text into the <b>JTextField</b> object.&nbsp; This process
begins in Listing 19,  which shows the beginning of a <b>for</b> loop that
is used to  execute this process.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    System.out.println("\nClick all components");<br>    for(int cnt = 0; cnt &lt; components.length;<br>                                         cnt++){<br>      Point location =<br>           components[cnt].getLocationOnScreen();<br>      System.out.print("Click at: " +<br>          location.x + ", " + location.y + "  ");<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Get and save screen location for each component</b></font></p>
 
<p>As shown in Listing 19, the first task in the <b>for</b> loop is to get,
save, and display the actual  screen coordinates for each component.</p>
 
<blockquote> 
  <p><i>(Note that these are absolute coordinates in pixels relative to the
 upper-left corner of the screen, and are not coordinates relative to the
 upper-left corner of the object containing the components.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Partial screen output</b></font></p>
 
<p>The code in Listing 19 produced the following screen output during the
first  iteration of the <b>for</b> loop.</p>
 
<p><b><font face="monospace">Click all components<br>
 Click at: 14, 33</font></b></p>
 
<p>The first line of text shown above was produced by the first statement
in  Listing 19, which is outside the <b>for</b> loop.&nbsp; The second line
of text  shown above shows the absolute screen coordinates of the upper left-hand
corner  of the component whose reference is stored in the first element of
the array  object referred to by the reference variable named <b>components</b>.</p>
 
<blockquote> 
  <p><i>(The <b>setBounds</b> method invoked by the GUI constructor in Listing
2  causes the upper-left corner of the GUI to be located at screen coordinates
10,  10.&nbsp; The above output indicates that the upper-left corner of the
component  is four pixels to the right of and 23 pixels below the upper-left
corner of the <b>JFrame</b> object that is the container for the GUI.&nbsp;
Compare that with  Figure 1 to confirm those numbers in your own mind.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Execute a mouse click on the component</b></font></p>
<p> The code in Listing 20 invokes the <b>mouseMoveAndClick</b> method to
execute a  mouse click on the physical location on the screen where the component
resides.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      mouseMoveAndClick(location.x,location.y);<br><br><b><font
 face="Courier New,Courier">Listing 20</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>The mouseMoveAndClick method</b></font></p>
 
<p>At this point, I am going to set the <b>for</b> loop in the constructor
aside  momentarily and discuss the method named <b>mouseMoveAndClick</b>,
as shown in  its entirety in Listing 21.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public void <b>mouseMoveAndClick</b>(<br>                             int xLoc, int yLoc){<br>    robot.mouseMove( xLoc,yLoc );<br>    robot.mousePress(InputEvent.BUTTON1_MASK);<br>    robot.mouseRelease(InputEvent.BUTTON1_MASK);<br><br>    robot.delay(1000);<br>  }//end mouseMoveAndClick<br><br><b><font
 face="Courier New,Courier">Listing 21</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p>The code in Listing 21 causes the robot to move the mouse pointer to a
screen  location specified by the incoming parameters.</p>
 
<p>Then the robot presses and releases the left mouse button, which represents
a  mouse <i>click</i> on that screen location.</p>
 
<p><b><font color="#ff0000">Events may be fired</font></b></p>
 
<p>If a <b>JToggleButton</b> object, which does not already have the focus,
is  located at those coordinates, the combination of the operating system
and the  Java virtual machine working together causes the button at that
location to gain  the focus and to fire  both an <b>ActionEvent</b> and a
<b>FocusEvent</b>.&nbsp; <i>(If the button  already has the focus, it won't
fire the <b>FocusEvent</b>.)</i></p>
 
<p>If a <b>JTextField</b> object, which does not already have the focus,
is  located at those coordinates, the combination of the operating system
and the  Java virtual machine causes the text field to gain the focus and
to fire a <b> FocusEvent</b>.&nbsp; <i>(If the text field already has the
focus, it won't fire  the <b>FocusEvent</b>.)</i></p>
 
<blockquote> 
  <p><i>(Recall that if one component loses the focus when another component
gains  the focus, the component losing the focus will also fire a <b>FocusEvent</b>.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>A one-second delay</b></font></p>
 
<p>The code in Listing 21 also inserts a one-second delay to make it possible
to  view the effect of clicking the button.</p>
 
<p><font color="#ff0000"><b>Enter text into the text field</b></font></p>
 
<p>Returning to the discussion of the <b>for</b> loop in the constructor,
 the code in Listing 22 tests to see if the component being processed during
the  current iteration of the <b>for</b> loop is a <b>JTextField</b> object.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      if(components[cnt] instanceof JTextField<br>                  &amp;&amp; components[cnt].hasFocus()){<br>        System.out.println("\nEnter text");<br>        robot.keyPress(KeyEvent.VK_SHIFT);<br>        for (int cnt2 = 0;<br>                 cnt2 &lt; keyInput.length; cnt2++){<br>          if(cnt2 &gt; 0){<br>            robot.keyRelease(KeyEvent.VK_SHIFT);<br>          }//end if<br>          robot.keyPress(keyInput[cnt2]);<br>          robot.delay(1000);<br>        }//end for loop<br>        //Cause the text field to fire an<br>        // ActionEvent<br>        robot.keyPress(KeyEvent.VK_ENTER);<br>      }//end if<br>    }//end for loop<br>  }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 22</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Execute key presses to enter text and fire  ActionEvent</b></font></p>
 
<p>If the component is a <b>JTextField</b> object, and if it has the focus,
the  code in Listing 22 causes the robot to type the text <b>Done</b> into
the text  field as shown in Figure 2.</p>
 
<blockquote> 
  <p><i>(Note the use of the virtual SHIFT key to cause the first character
to be  entered in upper case and the remaining characters to be entered in
lower case.&nbsp;  Also note the use of the virtual ENTER key to cause the
text field to fire an <b> ActionEvent</b> after all the characters have been
typed into the text field.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>The screen output</b></font></p>
 
<p>The code in Listings 19 through 22 causes the following screen output.</p>
 
<p><b><font face="monospace">Click all components<br>
 Click at: 14, 33 ActionCommand = A<br>
 Click at: 94, 33 A lost focus B gained focus<br>
 ActionCommand = B<br>
 Click at: 174, 33 B lost focus C gained focus<br>
 ActionCommand = C<br>
 Click at: 14, 90 C lost focus D gained focus<br>
 ActionCommand = D<br>
 Click at: 94, 90 D lost focus E gained focus<br>
 ActionCommand = E<br>
 Click at: 174, 90 E lost focus F gained focus<br>
 ActionCommand = F<br>
 Click at: 14, 147 F lost focus G gained focus<br>
 ActionCommand = G<br>
 Click at: 94, 147 G lost focus H gained focus<br>
 ActionCommand = H<br>
 Click at: 174, 147 H lost focus I gained focus<br>
 <br>
 Enter text<br>
 ActionCommand = Done</font></b></p>
 
<p><font color="#ff0000"><b>The screen output is mixed</b></font></p>
 
<p>The screen output shown above is a mixture of output produced by the <b> 
Robot02</b> program and output produced by the event handlers belonging to
the  GUI object being manipulated by the robot.&nbsp; The coordinate information
is  displayed by the robot.&nbsp; The information regarding action events
and focus  events is produced by the event handlers belonging to the GUI.</p>
 
<p><font color="#ff0000"><b>The end of the Robot02 program</b></font></p>
 
<p>And that is the end of the code for the program named Robot02.</p>
 
<center> 
<h2> <a name="Run the program"></a>Run the Program</h2>
</center>
       
<p>I encourage you to copy the code from Listings 23 and 24 into your text
editor, compile it, and execute it.&nbsp; Experiment with it, making changes,
and observing the results of your changes. </p>
 
<p>The <b>Robot</b>  class was first released in SDK Version 1.3, so you
will need to be running  Version 1.3 or later.&nbsp; This program was tested
on my machine using SDK 1.4.1 under WinXP</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
   
<p>In this lesson, I have taught you how to use a Java robot to perform  
 automatic testing on a Java GUI.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
   
<p>The next lesson in this miniseries will show you how to write an animated
   robot program to provide an animated visual demonstration of the use of
a Java GUI.</p>
   
<center> 
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
   Complete listings of the programs discussed in this lesson are shown in
Listings    23 and 24 below. <br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>/*File Robot02.java<br>Copyright 2003 R.G.Baldwin<br><br>Illustrates the use of the java.awt.Robot class,<br>which was released in SDK Version 1.3.<br><br>The program instantiates an object of the class<br>named Robot02Slave.  This object contains eight<br>JToggleButton objects and a JTextField object<br>in a GridLayout.<br><br>The program begins with the upper-left button<br>holding the focus.<br><br>The program presses the tab key eight times in<br>succession to cause the focus to traverse all of<br>the components in the forward direction according<br>to the default focus traversal policy, which<br>moves the focus from top left to bottom right.<br><br>At this point, the text field in the bottom right<br>holds the focus.<br><br>Then the program holds down the shift key and<br>presses the tab key eight more times in<br>succession to cause the focus to traverse all of<br>the components in the reverse direction.<br><br>At this point, the button in the upper left<br>holds the focus.<br><br>The program identifies each of the components<br>in the GUI produced by Robot02Slave.  It<br>determines the physical location of each of those<br>components on the screen.  Once it has determined<br>the location of a component, it presses the left<br>mouse button on that component and then releases<br>the left mouse button on that component.  If the<br>component is a button, this causes the button to<br>fire an ActionEvent along with a FocusEvent.<br><br>If the component is a text field, it simply fires<br>a FocusEvent when clicked by the mouse.<br><br>Then, the program determines if the component is<br>a JTextField object.  If so, it enters the text<br>"Done" into the text field and presses the Enter<br>key to cause the text field to fire an<br>ActionEvent.<br><br>Tested using SDK 1.4.1 under WinXP<br>************************************************/<br><br>import java.awt.*;<br>import java.awt.event.*;<br>import javax.swing.*;<br><br>public class Robot02{<br>  //Create a robot object that will be used to<br>  // exercise a GUI object.<br>  Robot robot;<br><br>  //The following GUI object will be exercised by<br>  // the robot.<br>  Robot02Slave slave = new Robot02Slave();<br><br>  //The following text will be entered into the<br>  // text field on the GUI.<br>  int keyInput[] = {<br>      KeyEvent.VK_D,<br>      KeyEvent.VK_O,<br>      KeyEvent.VK_N,<br>      KeyEvent.VK_E<br>  };//end keyInput array<br>  //-------------------------------------------//<br><br>  public static void main(String args[]){<br>    System.out.println("Start test program");<br>    new Robot02();<br>    System.out.println("\nEnd test program");<br>  }//end main<br>  //-------------------------------------------//<br><br>  public Robot02(){//constructor<br>    try{<br>      robot = new Robot();<br>    }catch(AWTException e){<br>      e.printStackTrace();<br>    }//end catch<br><br>    //Make certain that the slave is visible on<br>    // the screen.<br>    while(!(slave.isShowing())){<br>      //loop until slave is showing on the screen<br>    }//end while loop<br><br>    //Get a list of the components on the slave<br>    Component[] components =<br>          slave.getContentPane().getComponents();<br><br>    //Traverse the focus path from the beginning<br>    // to the end in the forward direction.<br>    System.out.println("\nTraverse forward");<br>    for(int cnt = 0;<br>           cnt &lt; (components.length - 1); cnt++){<br>      robot.keyPress(KeyEvent.VK_TAB);<br>      //Insert delays to cause the focus to<br>      // traverse the components slowly.<br>      robot.delay(1000);<br>    }//end for loop<br><br>    //Traverse the focus path from the end to the<br>    // beginning in the reverse direction.<br>    System.out.println("\nTraverse backwards");<br>    //Press the shift key.<br>    robot.keyPress(KeyEvent.VK_SHIFT);<br>    for(int cnt = 0;<br>           cnt &lt; (components.length - 1); cnt++){<br>      robot.keyPress(KeyEvent.VK_TAB);<br>      robot.delay(1000);<br>    }//end for loop<br>    //Release the shift key.<br>    robot.keyRelease(KeyEvent.VK_SHIFT);<br><br>    //Automatically click each button on the<br>    // slave GUI.  Then enter text into the text<br>    // field<br>    System.out.println("\nClick all components");<br>    for(int cnt = 0; cnt &lt; components.length;<br>                                         cnt++){<br>      //Get, save, and display actual screen<br>      // location of a component<br>      Point location =<br>           components[cnt].getLocationOnScreen();<br>      System.out.print("Click at: " +<br>          location.x + ", " + location.y + "  ");<br><br>      //Execute a mouse click on the physical<br>      // location on the screen where the<br>      // component resides.<br>      mouseMoveAndClick(location.x,location.y);<br><br>      //If the component is a JTextField object,<br>      // execute keystrokes that will enter the<br>      // word "Done" into the text field.  Note<br>      // the use of upper and lower case.<br>      if(components[cnt] instanceof JTextField<br>                  &amp;&amp; components[cnt].hasFocus()){<br>        System.out.println("\nEnter text");<br>        robot.keyPress(KeyEvent.VK_SHIFT);<br>        for (int cnt2 = 0;<br>                 cnt2 &lt; keyInput.length; cnt2++){<br>          if(cnt2 &gt; 0){<br>            robot.keyRelease(KeyEvent.VK_SHIFT);<br>          }//end if<br>          robot.keyPress(keyInput[cnt2]);<br>          robot.delay(1000);<br>        }//end for loop<br>        //Cause the text field to fire an<br>        // ActionEvent<br>        robot.keyPress(KeyEvent.VK_ENTER);<br>      }//end if<br>    }//end for loop<br>  }//end constructor<br>  //-------------------------------------------//<br><br>  public void mouseMoveAndClick(<br>                             int xLoc, int yLoc){<br>    robot.mouseMove( xLoc,yLoc );<br>    robot.mousePress(InputEvent.BUTTON1_MASK);<br>    robot.mouseRelease(InputEvent.BUTTON1_MASK);<br><br>    robot.delay(1000);<br>  }//end mouseMoveAndClick<br><br>}//end class Robot02<br><br><b><font
 face="Courier New,Courier">Listing 23</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
  
<p>&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>/*File Robot02Slave.java<br>Copyright 2003 R.G.Baldwin<br><br>Illustrates the use of the java.awt.Robot class,<br>which was released in SDK Version 1.3.<br><br>This program is used to instantiate a GUI object<br>that is manipulated by an object of the class<br>named Robot02.  The program can also be used to<br>instantiate a GUI object that can be manipulated<br>manually using the mouse and the keyboard,<br>independent of the robot object.<br><br>An object of this class contains eight<br>JToggleButton objects and a JTextField object<br>in a GridLayout.<br><br>When you click on any of the buttons with the<br>mouse, the button fires an ActionEvent.  Because<br>it is a JToggleButton, it also changes between<br>a light shade of gray and a dark shade of gray.<br>When you enter text into the text field, the text<br>field fires an ActionEvent.<br><br>The same ActionEvent handler is registered on all<br>eight buttons and the text field.  The event<br>handler gets and displays the ActionCommand for<br>the component that fires the event.<br><br>Whenever any of the components lose or gain the<br>focus, they fire a FocusEvent.  The same<br>FocusEvent handler is registered on all eight<br>buttons and the text field.  The event handler<br>gets and displays the name of the component along<br>with an indication as to whether the focus was<br>lost or gained.<br><br>Tested using SDK 1.4.1 under WinXP<br>************************************************/<br><br>import java.awt.*;<br>import java.awt.event.*;<br>import javax.swing.*;<br><br>public class Robot02Slave extends JFrame<br>         implements ActionListener,FocusListener{<br><br>  //This main method can be used to run the<br>  // program in a standalone mode independent of<br>  // the robot.<br>  public static void main(String[] args){<br>    new Robot02Slave();<br>  }//end main<br>  //-------------------------------------------//<br><br>  public Robot02Slave(){//constructor<br><br>    //Prepare the JFrame for use<br>    setDefaultCloseOperation(<br>                          JFrame.EXIT_ON_CLOSE );<br>    getContentPane().setLayout(<br>                            new GridLayout(3,3));<br>    setBounds(10,10,250,200);<br>    setTitle("Copyright 2003, R.G.Baldwin");<br><br>    //Create eight buttons and add them to the<br>    // content pane<br>    for(int cnt = 0; cnt &lt; 8; cnt++){<br>      getContentPane().add(new JToggleButton(<br>                        "" + (char)('A' + cnt)));<br>    }//end for loop<br><br>    //Add a text field as the ninth component<br>    getContentPane().add(new JTextField(""));<br><br>    //Get a list of the components<br>    Component[] components =<br>          getContentPane().getComponents();<br><br>    //Register listeners on each component and<br>    // give each component a name<br>    for(int cnt = 0; cnt &lt; components.length;<br>                                          cnt++){<br>      //Must downcast in order to register an<br>      // action listener.<br>      if(components[cnt] instanceof<br>                                  JToggleButton){<br>        ((JToggleButton)components[cnt]).<br>                         addActionListener(this);<br>      }else if(components[cnt] instanceof<br>                                     JTextField){<br>        ((JTextField)components[cnt]).<br>                         addActionListener(this);<br>      }//end else<br><br>      //Register a focus listener on each<br>      // component<br>      components[cnt].addFocusListener(this);<br><br>      //Give each component a name.  Make the<br>      // name match the text on the face of the<br>      // buttons.  Name the text field "I"<br>      components[cnt].setName(<br>                         "" + (char)('A' + cnt));<br>    }//end for loop<br><br>    //Set the look and feel to Motif<br>    String plafClassName =<br>               "com.sun.java.swing.plaf.motif." +<br>                              "MotifLookAndFeel";<br>    try{<br>       UIManager.setLookAndFeel(plafClassName);<br>     }catch(Exception ex){ex.printStackTrace();}<br><br>     //Cause the new L&amp;F to be applied<br>     SwingUtilities.updateComponentTreeUI(this);<br><br>    //Make the frame visible<br>    setVisible( true );<br>  }//end constructor<br>  //-------------------------------------------//<br><br>  //Define the ActionEvent handler that is<br>  // registered on each of the components.<br>  public void actionPerformed(ActionEvent e){<br>    System.out.println("ActionCommand = "  +<br>                           e.getActionCommand());<br>  }//end actionPerformed<br>  //-------------------------------------------//<br><br>  //Define the FocusEvent handlers that are<br>  // registered on each of the components.<br>  public void focusLost(FocusEvent e){<br>    System.out.print(e.getComponent().getName()<br>                             + " lost focus  ");<br>  }//end focus lost<br><br>  public void focusGained(FocusEvent e){<br>    System.out.println(e.getComponent().getName()<br>                              + " gained focus");<br>  }//end focusGained<br><br>}//end class definition<br><br><b><font
 face="Courier New,Courier">Listing 24</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
  </p>
<hr size="3" width="100%" align="center"> 
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in part
in any form or medium without express written permission from Richard Baldwin
is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
 <b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is
a college professor (at Austin Community College in Austin, TX) and private
consultant whose primary focus is a combination of Java, C#, and XML. In
addition to the many platform and/or language independent benefits of Java
and C# applications, he believes that a combination of Java, C#, and XML
will become the primary driving force in the delivery of structured information
on the Web.</i> 
<p><i>Richard has participated in numerous consulting projects, and he frequently
provides onsite training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.DickBaldwin.com">Tutorials</a>, which has gained a worldwide
following among experienced and aspiring programmers. He has also published
articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and 
has many years of experience in the application of computer technology to
real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i> 
</p>
<p>-end- <br>
&nbsp; </p>
<br>
</body>
</html>
