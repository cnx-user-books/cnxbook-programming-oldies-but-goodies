<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Fun with Java: Sprite Animation, Part 6</h2>
<i>In his continuing series on sprite animation, Baldwin explains the behavior
of each of the methods of his SpriteManager class.&nbsp; This includes
the following features:&nbsp; finding an empty location for each new sprite,
updating sprite positions, drawing the new scene during each animation
cycle, and managing collisions between sprites.</i>
<p><b>Published:</b>&nbsp; November 11, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1460
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
If you are one of those orderly people who start reading a book at the
beginning and reads through to the end, you are probably wondering why
I keep repeating this long introduction.&nbsp; The truth is that this introduction
isn't meant for you.&nbsp; Rather, it is meant for those people who start
reading in the middle.
<p>That said, this is one of the lessons in a miniseries that will concentrate
on having fun while programming in Java.
<p>This miniseries will include a variety of Java programming topics that
fall in the category of <i>fun programming</i>.&nbsp; This particular lesson
is the sixth in of a group of lessons that will teach you how to write
animation programs in Java.&nbsp; The first lesson in the group was entitled
<a href="Java1450.htm">Fun
with Java: Sprite Animation, Part 1</a>.&nbsp; <i>(Here is your opportunity
to go back and start reading at the beginning.)</i> The previous lesson
was entitled <a href="Java1458.htm">Fun with Java: Sprite Animation, Part
5</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Animation programming</font></b><font color="#000000"></font>
<p><font color="#000000">This is one of a group of lessons that will teach
you how to write animation programs in Java.&nbsp; These lessons will teach
you how to write sprite animation, frame animation, and a combination of
the two.</font><font color="#000000"></font>
<p><b><font color="#FF0000">Spherical sea creatures</font></b>
<p><font color="#000000">The first program, being discussed in this lesson,
will show you how to use sprite animation to cause a group of colored spherical
sea creatures to swim around in a fish tank.&nbsp; A screen shot of the
output produced by this program is shown in Figure 1.</font>
<center>
<p><img SRC="java1460a.gif" height=212 width=301>
<p><font color="#000000">Figure 1.&nbsp; Animated spherical sea creatures
in a fish tank.</font></center>

<p><b><font color="#FF0000">The ability to change color</font></b><font color="#000000"></font>
<p><font color="#000000">Many sea creatures have the ability to change
their color in very impressive ways.&nbsp; The second program that I will
discuss in subsequent lessons will simulate that process using a combination
of sprite and frame animation.</font>
<p><b><font color="#FF0000">Sea worms</font></b>
<p><font color="#000000">The third program, also to be discussed in a subsequent
lesson, will use a combination of sprite animation, frame animation, and
some other techniques to cause a group of multi-colored sea worms to slither
around in the fish tank.&nbsp; In addition to slithering, the sea worms
will also change the color of different parts of their body, much like
real sea creatures.</font>
<p><font color="#000000">A screen shot of the output from the third program
is shown in Figure 2.</font>
<center>
<p><img SRC="java1460b.gif" height=212 width=301>
<p><font color="#000000">Figure 2.&nbsp; Animated sea worms in a fish tank.</font></center>

<p>Figure 3 shows the GIF image files that you will need to run these three
programs.
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td>
<center><pre><img SRC="java1460c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1460d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1460e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1460f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1460g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1460h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1460i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center>
<p>Figure 3.&nbsp; GIF image files that you will need.</center>

<p><b><font color="#FF0000">Getting the required GIF files</font></b>
<p>You should be able to capture the images by right-clicking on them individually,
and then saving them into files on your local disk.&nbsp; Having done that,
you will need to rename the files to match the names that are hard-coded
into the programs.
<p><b><font color="#FF0000">Review of previous lesson</font></b>
<p>In the previous lesson, I completed my discussion of the controlling
class for this animation program.
<p><b><font color="#FF0000">The update method</font></b>
<p>I showed you how to override the <b>update</b> method of the <b>Component</b>
class to improve the animation quality of the program over what would normally
be achieved using the default version of the <b>update</b> method.
<p>In the process, I showed you how to eliminate the flashing that often
accompanies efforts to use the default version of the <b>update</b> method
for animation purposes.&nbsp; This flashing is caused by the fact that
the default version of <b>update</b> draws an empty component <i>(often
white) </i>at the beginning of each redraw cycle.
<p><b><font color="#FF0000">Offscreen drawing context</font></b>
<p>I also showed you how to get and use an offscreen drawing context to
accomplish <i>double buffering</i> in the drawing process.&nbsp; The use
of double buffering makes it impossible for the user to see the scene as
it is being drawn because the scene is first drawn offscreen and then transferred
as a whole to the screen context.&nbsp; Depending on the drawing speed,
this can also produce a more pleasing result.
<p>I also provided a very brief discussion of the utility class named <b>BackgroundImage</b>.
<p><b><font color="#FF0000">Preview of this lesson</font></b>
<p>There are two more classes to cover before my discussion of this animation
program is complete:&nbsp; <b>SpriteManager</b> and <b>Sprite</b>.
<p>In this lesson, I will explain the behavior of each of the methods of
the <b>SpriteManager</b> class.&nbsp; This will include the following features:
<ul>
<li>
Finding an empty space for each new sprite</li>

<li>
Updating sprite positions</li>

<li>
Drawing the new scene during each animation cycle</li>

<li>
Managing collisions between sprites</li>
</ul>

<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
This program is so long that several lessons will be required to discuss
it fully.&nbsp; Rather than to make you wait until I complete all of those
lessons to get your hands on the program, I have provided a copy of the
entire program in Listing 11 near the end of the lesson.&nbsp; That way,
you can copy it into a source file on your local disk, compile it, run
it, and start seeing the results.
<p><b><font color="#FF0000">The SpriteManager class</font></b>
<p>As the name implies, an object of the <b>SpriteManager</b> class can
be used to manage a collection of sprites.&nbsp; Before I get into the
details, here is a preview of some of the attributes of the <b>SpriteManager</b>
class.
<p><b><font color="#FF0000">SpriteManager constructor</font></b>
<p>The constructor for the <b>SpriteManager</b> class requires an incoming
parameter of type
<b>BackgroundImage</b>. The <b>BackgroundImage</b> class
is a convenience class designed to facilitate certain operations involving
the background image displayed on the <b>Frame</b>.&nbsp; The code in various
methods of the <b>SpriteManager</b> class uses the <b>BackgroundImage</b>
object to manage the background image against which the animation process
is played out.&nbsp; <i>(You can view the background image by scrolling
back up to Figure 3.)</i>
<p><b><font color="#FF0000">A collection of sprites in a Vector object</font></b>
<p>An object of the <b>SpriteManager</b> class stores references to a collection
of sprites in an object of type <b>Vector</b>.&nbsp; A public method named
<b>addSprite</b>
can be invoked to cause a new sprite to be added to the collection.
<p><b><font color="#FF0000">Finding a parking place for a sprite</font></b>
<p>One of the public methods of the <b>SpriteManager</b> class is a method
named <b>getEmptyPosition</b>.&nbsp; This method attempts to identify a
location within the <b>Frame</b> that does not currently contain a sprite.&nbsp;
This makes it possible to create a population of sprites without having
them initially occupying the same physical space.
<p><b><font color="#FF0000">Updating the sprite positions</font></b>
<p>Another public method of the <b>SpriteManager</b> class is a method
named <b>upDate</b> <i>(not to be confused with the update method of the
Component class).</i>&nbsp; When this method is invoked, the <b>SpriteManager</b>
object causes all of the sprites in its collection to change their position
according to values stored in a <i>motion vector</i> owned by each sprite.
<p>When the sprites change their positions, collisions can and do occur.&nbsp;
Such collisions are handled by the <b>SpriteManager</b> using private methods
named <b>testForCollision</b> and <b>bounceOffSprite</b>.
<p><b><font color="#FF0000">Drawing the scene</font></b>
<p>Another public method of the <b>SpriteManager</b> class is named <b>drawScene</b>.&nbsp;
When this method is invoked, a new background image is drawn on the <b>Frame</b>.&nbsp;
This has the effect of erasing all of the sprites from the scene.&nbsp;
The method then causes each of the sprites to be drawn in their respective
positions.
<p><b><font color="#FF0000">Discuss in fragments</font></b>
<p>As usual, I will discuss the program in fragments.
<p>As shown in Listing 1, the <b>SpriteManager</b> class extends the <b>Vector</b>
class.&nbsp; Hence, an object of the <b>SpriteManager</b> class is a <b>Collection</b>
object according to the Java Collections Framework.&nbsp; <i>(If you are
unfamiliar with that framework, I have published several lessons on the
framework on my web site.)</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>SpriteManager extends Vector</b>{
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public <b>SpriteManager</b>(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage){
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The background</font></b>
<p>The <b>SpriteManager</b> class starts off in a very mundane way.&nbsp;
The constructor, shown in Listing 1, receives and saves a reference to
an object of the <b>BackgroundImage</b> class.
<p><b><font color="#FF0000">Adding sprites</font></b>
<p>Continuing to keep things simple, the code in Listing 2 is used to add
a new sprite to the collection.&nbsp; This code simply provides a wrapper
method with a descriptive name around the standard <b>add</b> method of
the <b>Vector</b> class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void <b>addSprite</b>(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p>There are overloaded versions of the <b>add</b> method in the <b>Vector</b>
class.&nbsp; In keeping with the stipulations of the Java Collections Framework,
the <b>add</b> method used here appends the incoming <b>Sprite</b> object's
reference to the end of the collection of references stored in the <b>Vector</b>.
<p><b><font color="#FF0000">The getEmptyPosition method</font></b>
<p>The purpose of the method named <b>getEmptyPosition</b> is to try to
find a rectangle the size of a sprite in a location that is not already
occupied by one of the sprites in the collection.
<p>This method, as shown in Listing 3, is long and ugly, but not conceptually
difficult.&nbsp; Therefore, I will provide a brief summary but I won't
discuss it in detail.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;
&nbsp; public Point <b>getEmptyPosition</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p>Basically the method uses a <b>for</b> loop inside a <b>while</b> loop
to search for a rectangular area not already occupied by a sprite.
<p><b><font color="#FF0000">Check up to 100 locations</font></b>
<p>The <b>while</b> loop will iterate up to 100 times looking for an empty
area.&nbsp; When it finds an empty area, the <b>while</b> loop terminates
and the method returns the location of that area to the calling program.&nbsp;
If the method fails to find an empty area in 100 tries, it gives up and
returns a location that is already occupied by another sprite.
<p><b><font color="#FF0000">Check random locations</font></b>
<p>Inside the <b>while</b> loop, the code uses a random number generator
to specify a trial location.&nbsp; It then uses a <b>for</b> loop, in conjunction
with the <b>intersects</b> method of the <b>Rectangle</b> class, to test
the trial location against the locations occupied by all of the sprites
in the collection.
<p><b><font color="#FF0000">An empty location</font></b>
<p>If the rectangular area at the trial location doesn't intersect a rectangular
area occupied by any existing sprite, that rectangular area and that location
is deemed to be empty.
<p><b><font color="#FF0000">An occupied location</font></b>
<p>If the rectangular area at the trial location does intersect a rectangular
area occupied by an existing sprite, that location is discarded.&nbsp;
In that case, another trial location area is specified using the random
number generator and the test is performed again.
<p><b><font color="#FF0000">Redraw and sleep</font></b>
<p>As I explained in an earlier lesson, once control enters the animation
loop, the <b>update</b> method is invoked on the <b>SpriteManager</b> object.&nbsp;
When the <b>update</b> method returns, the code invokes the <b>repaint</b>
method on the <b>Frame</b> and the animation thread goes to sleep for a
specified period of time.
<p>When the animation thread wakes up, the process is repeated.
<p><i>(Be careful not to confuse this method named update with the method
having the same name that is defined in the Component class, and overridden
in the controlling class for this program.)</i>
<p><b><font color="#FF0000">The update method</font></b>
<p>The update method causes all of the sprites being managed by the
<b>SpriteManager</b>
object to assume new positions based on the motion rules defined by the
<b>Sprite</b>
class.
<p>The beginning of the <b>update</b> method is shown in Listing 4.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void <b>update</b>() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.<b>updatePosition</b>();

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>Once all of the sprites have assumed new positions, it is possible that
some collisions among sprites may have occurred.&nbsp; The <b>update</b>
method tests for collisions by examining the location information belonging
to each of the
<b>Sprite</b> objects being managed.
<p><b><font color="#FF0000">Managing collisions</font></b>
<p>If a collision has occurred, a method named <b>bounceOffSprite</b> is
invoked to cause the two sprites to behave in a manner similar to that,
which occurs between two balls in a game of pool.&nbsp; <i>(I will discuss
the bounceOffSprite method later.)</i>
<p><b><font color="#FF0000">Iterate on all sprites</font></b>
<p>All of the executable code in the <b>update</b> method exists inside
a <b>for</b> loop that iterates through all of the sprites in the collection.
<p>The code inside the <b>for</b> loop begins by selecting the next sprite
in the collection and causing that sprite to assume a new position by invoking
the <b>updatePosition</b> method on the sprite.&nbsp; <i>(We will see exactly
how a sprite moves in a subsequent lesson where I discuss the Sprite class
in detail.)</i>
<p><b><font color="#FF0000">Test for a collision</font></b>
<p>The code in the <b>for</b> loop then invokes a private method of the
<b>SpriteManager</b>
class named <b>testForCollision</b> to determine if the sprite that just
moved collided with any other sprite.&nbsp; <i>(I will discuss the testForCollision
method shortly.)</i>
<p>This code is shown in Listing 5.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>testForCollision</b>(sprite)

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Negative return value is OK</font></b>
<p>If a collision did not occur, the <b>testForCollision</b> method returns
a negative value.&nbsp; This causes another iteration of the <b>for</b>
loop to test the next sprite in the collection for a collision.
<p><b><font color="#FF0000">Who hit me?</font></b>
<p>If a collision did occur, the <b>testForCollision</b> method returns
either zero or a positive value.&nbsp; This value is the index in the collection
of the <i>other party to the collision</i>.
<p><b><font color="#FF0000">Bounce when collision occurs</font></b>
<p>In this case, the code shown in Listing 6 passes references to both
parties in the collision to the method named <b>bounceOffSprite</b> to
cause the sprites to bounce off of one another.&nbsp; <i>(You will see
how that is done shortly when I discuss the method named bounceOffSprite.)</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<b>hitIndex >= 0</b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>bounceOffSprite</b>(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The testCollision method</font></b>
<p>The actual code that tests to determine if two sprites have collided
is performed by a method named <b>testCollision</b>, which is a method
of the <b>Sprite</b> class.&nbsp; Breaking this code out into a separate
method makes it easier to customize that code to be appropriate for sprites
of new designs.
<p><b><font color="#FF0000">The testForCollision method</font></b>
<p>The method named <b>testForCollision</b> defined in the <b>SpriteManager</b>
class invokes the <b>testCollision</b> method to determine if two specific
sprites have collided.
<p>The <b>testForCollision</b> method, shown in Listing 7, receives a reference
to a <b>Sprite</b> object as a parameter.&nbsp; It uses a <b>for</b> loop
to test that sprite against all of the sprites in the collection except
itself.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; private int <b>testForCollision</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; <b>for</b> (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.<b>testCollision</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">True for collision, false otherwise</font></b>
<p>During each iteration of the loop, it passes a reference to the sprite
being tested and a reference to one of the sprites in the collection to
the <b>testCollision</b> method of the <b>Sprite</b> class.&nbsp; If that
method determines that a collision has occurred, it returns true.&nbsp;
Otherwise, it returns false.
<p><b><font color="#FF0000">Terminate on collision</font></b>
<p>If the <b>testCollision</b> method returns true, the <b>testForCollision</b>
method terminates, returning the positive index of the sprite in the collection
that collided with the sprite being tested.
<p>If no collisions are detected, the <b>testForCollision</b> method returns
-1.
<p><b><font color="#FF0000">Small incremental steps</font></b>
<p>Although it isn't apparent while watching the animation run, each sprite
moves through the water in small incremental steps.&nbsp; Each sprite takes
one step in the horizontal direction and one step in the vertical direction
during each iteration of the animation loop in the <b>run</b> method of
the controlling class.
<p><b><font color="#FF0000">The motion vector</font></b>
<p>As you will see when I discuss the <b>Sprite</b> class in the next lesson,
each <b>Sprite</b> object has an instance variable of type <b>Point</b>
named <b>motionVector</b> <i>(the word vector here is used to indicate
a mathematical vector, and is not to be confused with the Java class named
Vector).</i>
<p>Each motion vector contains a signed integer describing the incremental
horizontal motion of the sprite and a signed integer describing the incremental
vertical motion of the sprite.&nbsp; Thus, the contents of the <b>Point</b>
object referred to by <b>motionVector</b> determine the speed and direction
of motion for the sprite.&nbsp; <i>(We will also see that these two values
can occasionally change on a random basis causing a sprite to change its
speed and direction of motion.)</i>
<p><b><font color="#FF0000">The bounceOffSprite method</font></b>
<p>The method named <b>bounceOffSprite</b> shown in Listing 8 receives
references to two <b>Sprite</b> objects.&nbsp; This method is called by
the <b>SpriteManager</b> object when two sprites are determined to have
collided.
<p><b><font color="#FF0000">Swap motion vectors</font></b>
<p>The concept is simple.&nbsp; If two sprites, <i>(call them A and B),</i>
collide, they swap motion vectors.&nbsp; This causes sprite B to assume
the speed and direction previously exhibited by sprite A, and causes sprite
A to assume the speed and direction previously exhibited by sprite B.
<p>Thus, the code shown in Listing 8 simply swaps the motion vectors between
the two sprites received as incoming parameters.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;
&nbsp; private void <b>bounceOffSprite</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()

<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">An unplanned behavior</font></b>
<p>However, if you watch the animation very carefully, you may witness
an interesting and totally unplanned behavior.&nbsp; Sometimes, two sprites
will travel side-by-side for a while and then separate.
<p><b><font color="#FF0000">Why does this happen?</font></b>
<p>I haven't performed a detailed analysis to determine what causes this
behavior, but I suspect that it results from two sprites colliding at a
very shallow angle.&nbsp; I suspect that simply swapping motion vectors
doesn't actually separate them, and they are deemed to have collided again
during the next animation update.&nbsp; If so, this causes them to swap
motion vectors again, and the process continues.&nbsp; Eventually, one
or both of the sprites makes a random change in speed and direction, at
which point they separate.
<p>Since these are animated sea creatures, I have chalked this behavior
up to the natural mating tendencies of sea creatures.
<p><b><font color="#FF0000">The drawScene method</font></b>
<p>In this program, the <b>drawScene</b> method is invoked by code in the
overridden <b>update</b> method of the controlling class.&nbsp; When the
<b>update </b>method is invoked, it is passed a reference to an offscreen
graphics context.
<p><b><font color="#FF0000">An offscreen graphics context</font></b>
<p>The <b>drawScene</b> method receives a reference to an object of type
<b>Graphics</b>
as an incoming parameter.&nbsp; This <b>Graphics</b> object represents
a graphics context.&nbsp; While it could represent any graphics context,
in this program it represents the offscreen graphics context mentioned
above.
<p><b><font color="#FF0000">Drawing pictures</font></b>
<p>The code in the <b>drawScene</b> method can draw pictures on the graphics
context represented by the incoming <b>Graphics</b> object by invoking
the methods of the <b>Graphics</b> class on that object.
<p>Listing 9 shows the beginning of the method named <b>drawScene</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;
&nbsp; public void <b>drawScene</b>(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>drawBackgroundImage</b>(g);

<b><font face="Courier New,Courier">Listing 9</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The drawBackgroundImage method</font></b>
<p>The code in Listing 9 invokes the <b>drawBackgroundImage</b> method
on the <b>BackgroundImage</b> object, passing the graphics context as a
parameter.
<p>If you refer back to the discussion of the <b>BackgroundImage</b> class
in the previous lesson, you will see that the code in the <b>drawBackgroundImage</b>
method invokes the <b>drawImage</b> method to draw the background image
on the graphics context that it receives an incoming parameter.
<p><b><font color="#FF0000">Covers all existing sprites</font></b>
<p>Because the size of the background image completely fills the graphics
context, this has the effect of drawing the background over all of the
sprites that were previously drawn there.
<p><b><i><font color="#FF0000">An interesting effect</font></i></b>
<p><i>(You can disable the statement in Listing 9 to see an interesting
effect that may help you to understand what is going on in the drawing
process.</i><i></i>
<p><i>Disabling this statement prevents the previously-drawn sprites from
being covered up by the background image, and the sprites simply accumulate
in the drawing area.&nbsp; They end up looking something like colored tube
worms.)</i>
<p><b><font color="#FF0000">Now draw the sprites</font></b>
<p>Once the new background image has been drawn on the graphics context,
it is ready for the drawing of the individual sprites in their new locations.
This is accomplished by the code in Listing 10.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>drawSpriteImage</b>(g);
&nbsp; }//end drawScene()

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The drawSpriteImage method</font></b>
<p>The code in Listing 10 iterates through all of the sprites in the collection,
invoking the <b>drawSpriteImage</b> method on each sprite and passing a
reference to the graphics context as a parameter.&nbsp; This causes each
of the individual sprites to be drawn in their new locations.&nbsp; <i>(I
will discuss the drawSpriteImage method of the Sprite class in the next
lesson.)</i>
<p><b><font color="#FF0000">Collisions with the walls</font></b>
<p>The <b>drawSpriteImage</b> method of the <b>Sprite</b> class deals with
the problem of sprites running into the walls.&nbsp; When a sprite runs
into one of the walls, it bounces off the wall.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have explained the behavior of each of the methods of
the <b>SpriteManager</b> class.&nbsp; This included the following features:
<ul>
<li>
Finding an empty space for each new sprite</li>

<li>
Updating sprite positions</li>

<li>
Drawing the new scene during each animation cycle</li>

<li>
Managing collisions between sprites</li>
</ul>

<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
There is one more class to cover before my discussion of this animation
program is complete:&nbsp; <b>Sprite</b>.
<p>I will begin my discussion of the <b>Sprite</b> class in the next lesson.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
11</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate01.java
Copyright 2001, R.G.Baldwin

This program displays several animated
colored spherical creatures swimming&nbsp;
around in an aquarium.&nbsp; Each creature&nbsp;
maintains generally the same course
with until it collides with another&nbsp;
creature or with a wall.&nbsp; However,&nbsp;
each creature has the ability to&nbsp;
occasionally make random changes in&nbsp;
its course.

**************************************/
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Animate01 extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable {
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];
&nbsp; //offscreen graphics context
&nbsp; private Graphics&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;
&nbsp; private MediaTracker mediaTracker;
&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate01();
&nbsp; }//end main
&nbsp; //---------------------------------//

&nbsp; Animate01() {//constructor
&nbsp;&nbsp;&nbsp; // Load and track the images
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Get and track the background&nbsp;
&nbsp;&nbsp;&nbsp; // image
&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("background02.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and track 6 images to use&nbsp;
&nbsp;&nbsp;&nbsp; // for sprites
&nbsp;&nbsp;&nbsp; gifImages[0] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("redball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);
&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("greenball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("blueball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("yellowball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("purpleball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("orangeball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Block and wait for all images to&nbsp;
&nbsp;&nbsp;&nbsp; // be loaded
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.waitForID(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Base the Frame size on the size&nbsp;
&nbsp;&nbsp;&nbsp; // of the background image.
&nbsp;&nbsp;&nbsp; //These getter methods return -1 if
&nbsp;&nbsp;&nbsp; // the size is not yet known.
&nbsp;&nbsp;&nbsp; //Insets will be used later to&nbsp;
&nbsp;&nbsp;&nbsp; // limit the graphics area to the&nbsp;
&nbsp;&nbsp;&nbsp; // client area of the Frame.
&nbsp;&nbsp;&nbsp; int width =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getWidth(this);
&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getHeight(this);

&nbsp;&nbsp;&nbsp; //While not likely, it may be&nbsp;
&nbsp;&nbsp;&nbsp; // possible that the size isn't
&nbsp;&nbsp;&nbsp; // known yet.&nbsp; Do the following&nbsp;
&nbsp;&nbsp;&nbsp; // just in case.
&nbsp;&nbsp;&nbsp; //Wait until size is known
&nbsp;&nbsp;&nbsp; while(width == -1 || height == -1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Waiting for image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWidth(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the frame
&nbsp;&nbsp;&nbsp; setSize(width,height);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2001, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; //Create and start animation thread
&nbsp;&nbsp;&nbsp; animationThread = new Thread(this);
&nbsp;&nbsp;&nbsp; animationThread.start();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner class window&nbsp;
&nbsp;&nbsp;&nbsp; // listener to terminate the&nbsp;
&nbsp;&nbsp;&nbsp; // program.
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public void run() {
&nbsp;&nbsp;&nbsp; //Create and add sprites to the&nbsp;
&nbsp;&nbsp;&nbsp; // sprite manager
&nbsp;&nbsp;&nbsp; spriteManager = new SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, backGroundImage));
&nbsp;&nbsp;&nbsp; //Create 15 sprites from 6 gif&nbsp;
&nbsp;&nbsp;&nbsp; // files.
&nbsp;&nbsp;&nbsp; for (int cnt = 0; cnt &lt; 15; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position = spriteManager.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEmptyPosition(new Dimension(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].getWidth(this),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.addSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeSprite(position, cnt % 6));
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Loop, sleep, and update sprite&nbsp;
&nbsp;&nbsp;&nbsp; // positions once each 83&nbsp;
&nbsp;&nbsp;&nbsp; // milliseconds
&nbsp;&nbsp;&nbsp; long time =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis();
&nbsp;&nbsp;&nbsp; while (true) {//infinite loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time += animationDelay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0,time -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end run method
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private Sprite makeSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex) {
&nbsp;&nbsp;&nbsp; return new Sprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[imageIndex],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Overridden graphics update method&nbsp;
&nbsp; // on the Frame
&nbsp; public void update(Graphics g) {
&nbsp;&nbsp;&nbsp; //Create the offscreen graphics&nbsp;
&nbsp;&nbsp;&nbsp; // context
&nbsp;&nbsp;&nbsp; if (offScreenGraphicsCtx == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createImage(getSize().width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage.getGraphics();
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Draw the sprites offscreen
&nbsp;&nbsp;&nbsp; spriteManager.drawScene(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx);

&nbsp;&nbsp;&nbsp; // Draw the scene onto the screen
&nbsp;&nbsp;&nbsp; if(offScreenImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage, 0, 0, this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end overridden update method
&nbsp; //---------------------------------//

&nbsp; //Overridden paint method on the&nbsp;
&nbsp; // Frame
&nbsp; public void paint(Graphics g) {
&nbsp;&nbsp;&nbsp; //Nothing required here.&nbsp; All&nbsp;
&nbsp;&nbsp;&nbsp; // drawing is done in the update&nbsp;
&nbsp;&nbsp;&nbsp; // method above.
&nbsp; }//end overridden paint method
&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Animate01
//===================================//

class BackgroundImage{
&nbsp; private Image image;
&nbsp; private Component component;
&nbsp; private Dimension size;

&nbsp; public BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image) {
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; size = component.getSize();
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end construtor
&nbsp;&nbsp;
&nbsp; public Dimension getSize(){
&nbsp;&nbsp;&nbsp; return size;
&nbsp; }//end getSize()

&nbsp; public Image getImage(){
&nbsp;&nbsp;&nbsp; return image;
&nbsp; }//end getImage()

&nbsp; public void setImage(Image image){
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end setImage()

&nbsp; public void drawBackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g) {
&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image, 0, 0, component);
&nbsp; }//end drawBackgroundImage()
}//end class BackgroundImage
//===========================

class SpriteManager extends Vector {
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage) {
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getEmptyPosition(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void update() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.updatePosition();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for collision. Positive&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result indicates a collision
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testForCollision(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitIndex >= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceOffSprite(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private int testForCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite) {
&nbsp;&nbsp;&nbsp; //Check for collision with other&nbsp;
&nbsp;&nbsp;&nbsp; // sprites
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void bounceOffSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawScene(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBackgroundImage(g);

&nbsp;&nbsp;&nbsp; //Iterate through sprites, drawing
&nbsp;&nbsp;&nbsp; // each sprite
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawSpriteImage(g);
&nbsp; }//end drawScene()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void addSprite(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()
&nbsp;&nbsp;
}//end class SpriteManager
//===================================//

class Sprite {
&nbsp; private Component component;
&nbsp; private Image image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;

&nbsp; public Sprite(Component component,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){

&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp;&nbsp;&nbsp; //Compute edges of usable graphics
&nbsp;&nbsp;&nbsp; // area in the Frame.
&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().top;
&nbsp;&nbsp;&nbsp; int bottomBorder =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public Rectangle getSpaceOccupied(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getMotionVector(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; Point position = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.&nbsp; This&nbsp;
&nbsp;&nbsp;&nbsp; // puts a cap on the maximum speed
&nbsp;&nbsp;&nbsp; // for a sprite.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point randomOffset =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Move the sprite on the screen
&nbsp;&nbsp;&nbsp; position.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

&nbsp;&nbsp;&nbsp; //Bounce off the walls
&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector = new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if ((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x + spaceOccupied.width)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(bounceRequired)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector);
&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.drawImage(image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public boolean testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; //Check for collision with&nbsp;
&nbsp;&nbsp;&nbsp; // another sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class
//===================================//

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2001, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and private
consultant whose primary focus is a combination of Java and XML. In addition
to the many platform-independent benefits of Java applications, he believes
that a combination of Java and XML will become the primary driving force
in the delivery of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
