<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Fun with Java: Sprite Animation, Part 2</h2>
<i>Baldwin shows you how to instantiate and use a MediaTracker object to
track the loading status of Image objects.&nbsp; He shows you how to use
the getImage method of the Toolkit class to create Image objects from GIF
files, how to register those Image objects on a MediaTracker object, and
how to use the waitForID method of the MediaTracker object to force the
program to block and wait until the images in a group are successfully
loaded, or until a loading error occurs.</i>
<p><b>Published:</b>&nbsp; October 8, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1452
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
Programming in Java doesn't have to be dull and boring.&nbsp; In fact,
it's possible to have a lot of fun while programming in Java.&nbsp; This
is one of the lessons in a miniseries that will concentrate on having fun
while programming in Java.
<p>This miniseries will include a variety of Java programming topics that
fall in the category of <i>fun programming</i>.&nbsp; This particular lesson
is the second in of a group of lessons that will teach you how to write
animation programs in Java.&nbsp; The first <i>(and previous)</i> lesson
in the group was entitled <a href="Java1450.htm">Fun with Java: Sprite
Animation, Part 1</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<font color="#000000">This is one of a group of lessons that will teach
you how to write animation programs in Java.&nbsp; These lessons will teach
you how to write <i>sprite</i> animation, <b>frame</b> animation, and a
combination of the two.</font>
<p><b><font color="#FF0000">Colored spherical sea creatures</font></b>
<p><font color="#000000">The first program, which is the program discussed
in this lesson,&nbsp; will show you how to use sprite animation to cause
a group of colored spherical sea creatures to swim around in a fish tank.&nbsp;
A screen shot of the output produced by this program is shown in Figure
1.</font>
<center>
<p><img SRC="java1452a.gif" height=212 width=301>
<p><font color="#000000">Figure 1.&nbsp; Animated spherical sea creatures
in a fish tank.</font></center>

<p><b><font color="#FF0000">Many sea creatures can change color</font></b>
<p><font color="#000000">Many sea creatures have the ability to change
their color in very impressive ways.&nbsp; The second program that I will
discuss in subsequent lessons will simulate that process using a combination
of sprite and frame animation.</font>
<p><b><font color="#FF0000">Animated multi-colored sea worms</font></b>
<p><font color="#000000">The third program, also to be discussed in a subsequent
lesson, will use a combination of sprite animation, frame animation, and
some other techniques to cause a group of multi-colored sea worms to slither
around in the fish tank.&nbsp; In addition to slithering, the sea worms
will also change the color of different parts of their body, much like
real sea creatures.</font>
<p><font color="#000000">A screen shot of the output from the third program
is shown in Figure 2.</font>
<center>
<p><img SRC="java1452b.gif" height=212 width=301>
<p><font color="#000000">Figure 2.&nbsp; Animated sea worms in a fish tank.</font></center>

<p><b><font color="#FF0000">Get your GIF images here</font></b>
<p>Figure 3 shows the GIF image files that you will need to run these three
programs.
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td>
<center><pre><img SRC="java1452c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1452d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1452e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1452f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1452g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1452h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1452i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center>
<p>Figure 3.&nbsp; GIF image files that you will need.</center>

<p>You should be able to capture the images by right-clicking on them individually,
and then saving them into files on your local disk.&nbsp; Having done that,
you will need to rename the files to match the names that are hard-coded
into the programs.
<p><b><font color="#FF0000">Classes and concepts discussed earlier</font></b>
<p>In the previous lesson, I introduced you to several classes and concepts
that you must understand in order to understand animation in Java.&nbsp;
Included in that discussion were the following classes, which are particularly
important to sprite animation:
<ul>
<li>
Image</li>

<li>
Toolkit</li>

<li>
Graphics</li>

<li>
MediaTracker</li>

<li>
Random</li>
</ul>
I also discussed a number of concepts, including the following, which are
particularly important to sprite animation:
<ul>
<li>
offscreen graphics contexts</li>

<li>
coordinates in Java graphics</li>

<li>
translation origins</li>

<li>
the drawImage method</li>

<li>
animation repetition rates</li>

<li>
pseudo-random numbers</li>
</ul>
<b><font color="#FF0000">Discussed beginning portions of controlling class</font></b>
<p>Also, in the previous lesson, I discussed the beginning portions of
the controlling class for the program named <b>Animate01</b>.&nbsp; <i>(A
complete listing of the program is provided near the end of this lesson.)</i>
<p><b><font color="#FF0000">The plan for this lesson</font></b>
<p>In this lesson, I will teach you how to instantiate and use a <b>MediaTracker</b>
object to track the loading status of <b>Image</b> objects.
<p>I will teach you how to use the <b>getImage</b> method of the <b>Toolkit</b>
class to create <b>Image</b> objects from GIF files, and how to register
those <b>Image</b> objects on a <b>MediaTracker</b> object.
<p>Finally, I will teach you how to use the <b>waitForID</b> method of
the <b>MediaTracker</b> object to force the program to block and wait until
the images in a group are either successfully loaded, or until a loading
error occurs.
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
This program is so long that several lessons will be required to discuss
it fully.&nbsp; Rather than to make you wait until I complete all of those
lessons to get your hands on the program, I have provided a copy of the
entire program in Listing 7 near the end of the lesson.&nbsp; That way,
you can copy it into a source file on your local disk, compile it, run
it, and start seeing the results.
<p><b><font color="#FF0000">Will discuss in fragments</font></b>
<p>As usual, I will discuss the program in fragments.&nbsp; In addition
to the controlling class named <b>Animate01</b>, the program contains several
other important classes.&nbsp; I began the discussion of the controlling
class in the previous lesson.&nbsp; I will continue discussing the controlling
class in this lesson picking up with the constructor for the controlling
class.
<p><b><font color="#FF0000">A MediaTracker object</font></b>
<p>Listing 1 shows the beginning of the constructor for the controlling
class.&nbsp; The first statement in Listing 1 instantiates a new object
of the <b>MediaTracker</b> class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; Animate01() {//constructor
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new <b>MediaTracker</b>(this);

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What is a MediaTracker object?</font></b>
<p>As explained in some detail in the previous lesson, the <b>MediaTracker</b>
class is a utility class, objects of which can be used to track the status
of a number of media objects.&nbsp; An object of the <b>MediaTracker</b>
class can help you to cope with the delays involved in loading image files
into the computer's memory.
<p><b><font color="#FF0000">The MediaTracker constructor</font></b>
<p>As of JDK 1.3, the <b>MediaTracker</b> class has only one constructor
whose signature is shown below:
<p><b><tt>public MediaTracker(Component comp)</tt></b>
<p>This constructor creates a media tracker object to track images for
a given component.&nbsp; The single parameter of type <b>Component</b>
is the component on which the images will eventually be drawn.
<p><b><font color="#FF0000">Will draw images on <i>this</i> object</font></b>
<p>In this program, the images will be drawn on an object of the controlling
class, which extends the <b>Frame</b> class.&nbsp; Therefore, in the code
in Listing 1, a reference to the object being constructed by the controlling
class' constructor <b>(this)</b> is passed as a parameter to the constructor
for the <b>MediaTracker</b> class.&nbsp; The resulting <b>MediaTracker</b>
object can be used to track images that will eventually be drawn on an
object instantiated from the controlling class.
<p><b><font color="#FF0000">The background image</font></b>
<p>As shown in Figure 1, the animated spherical sea creatures will be drawn
against a background image representing the inside of a fish tank.
<p>The code in Listing 2 creates an object of type <b>Image</b> containing
the picture described by the physical file named <b>background02.gif</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getImage</b>("background02.gif");

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p><i>(Instructions were provided earlier in this lesson for capturing
a GIF file containing the background image from this HTML document.&nbsp;
Once you have captured the GIF file, in order to make it compatible with
the code in Listing 2, you will need to rename the file background02.gif,
and store it in the directory containing the class file produced by compiling
the controlling class for this program.)</i>
<p><b><font color="#FF0000">The getImage method of the Toolkit class</font></b>
<p>The <b>Image</b> object is created in Listing 2 by invoking the <b>getImage</b>
method of the <b>Toolkit</b> class, passing the name of the GIF file as
a parameter.
<p>As of JDK 1.3, the <b>Toolkit</b> class provides two overloaded versions
of the <b>getImage</b> method. One takes a URL as a parameter, while the
other <i>(the one used in this program)</i> takes a file name represented
by a <b>String</b> object as a parameter.
<p><b><font color="#FF0000">The getDefaultToolkit method</font></b>
<p>Before getting into the details of the <b>getImage</b> method, it is
appropriate to make a few comments about the <b>getDefaultToolkit</b> method.
<p>The <b>getDefaultToolkit</b> method creates and returns an object of
some class that extends the
<b>Toolkit</b> class.&nbsp; This class defines
the methods declared in the <b>Toolkit</b> class in such a way as to handle
the peculiarities of the platform on which the Java program is running.
<p>Many such methods are declared as <i>abstract</i> methods in the <b>Toolkit</b>
class.&nbsp; In this particular case, we are interested in the overridden
version of the method named <b>getImage</b>.
<p><b><font color="#FF0000">Back to the getImage method</font></b>
<p>The signature of the <b>getImage</b> method, as declared in the <b>Toolkit</b>
class, is as shown below <i>(note that the method is abstract and must
be fully defined in the object returned by the getDefaultToolkit method).</i>
<p><b><tt>public abstract Image getImage(</tt></b>
<br><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
String filename)</tt></b>
<p><b><font color="#FF0000">Creates Image object from an image file</font></b>
<p>As of JDK 1.3, the <b>getImage</b> method returns a reference to an
object of type <b>Image</b>, which contains pixel data from the specified
file.&nbsp; The file format can be either GIF, JPEG or PNG.
<p>The parameter to this overloaded version of the <b>getImage</b> method
is a <b>String</b> object representing the name of a file containing pixel
data in a recognized file format.&nbsp; For the code in Listing 2, this
is the file named <b>background02.gif</b>, stored in the same directory
as the program file.
<p><b><font color="#FF0000">Coping with the loading delay</font></b>
<p>Even when the file is stored on a local hard drive, some finite amount
of time is required to find the file, read it, and create the <b>Image</b>
object.&nbsp; Any attempt to use the <b>Image</b> object before that process
is completed is very likely to result in problems.&nbsp; That is where
the <b>MediaTracker</b> object instantiated earlier comes into play.
<p><b><font color="#FF0000">Registering the Image object on the MediaTracker</font></b>
<p>The code in Listing 3 invokes the <b>addImage</b> method of the <b>MediaTracker</b>
class to register the <b>Image</b> object referred to by the reference
variable named <b>backGroundImage</b> on the <b>MediaTracker</b> object
with an ID value of 0.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p><i>(Note that there is another version of the addImage method that allows
for scaling the image as it is being loaded.&nbsp; That version is not
used in this program.)</i>
<p>According to the Sun documentation, the version of the <b>addImage</b>
method used in Listing 3
<blockquote><i>"Adds an image to the list of images being tracked by this
media tracker. The image will eventually be rendered at its default (unscaled)
size."</i></blockquote>
<b><font color="#FF0000">Getting Image object status</font></b>
<p>Having accomplished this, the <b>MediaTracker</b> object can then be
queried to determine the loading status of the image.&nbsp; A variety of
methods are provided by the <b>MediaTracker</b> class to support such queries.
<p>When an image is registered for tracking with a <b>MediaTracker</b>
object, the second parameter of the <b>addImage</b> method provides an
integer identifier value.&nbsp; Many of the methods that can be used to
query the
<b>MediaTracker</b> object take the identifier as a parameter.&nbsp;
Those methods provide information about the image(s) having that identifier
value to the exclusion of images having other identifier values.
<p><b><font color="#FF0000">Tracking images as a group</font></b>
<p>More than one image can be registered with the same identifier value.&nbsp;
In this case, all of the images having the same identifier value will be
tracked as a group.&nbsp; A query based on the common identifier value
will return information about the group as a whole rather than returning
information about the individual members of the group.
<p><b><font color="#FF0000">Seven different Image objects</font></b>
<p>This program uses seven different <b>Image</b> objects based on seven
different GIF files.&nbsp; One of the <b>Image</b> objects is used to create
the background shown in Figure 1.&nbsp; The other six <b>Image</b> objects
are used to create the spherical sea creature shown in Figure 1.
<p><b><font color="#FF0000">An Image object for sea creatures</font></b>
<p>The code to create and register the <b>Image</b> object used for the
background was shown in Listings 2 and 3.&nbsp; The code to create and
register the first of the <b>Image</b> objects used for sea creatures is
shown in Listing 4.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; <b>gifImages[0]</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>redball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>This is essentially the same as the code in Listings 2 and 3 with the
one exception that the reference to the <b>Image</b> object is stored in
an element of an array of type <b>Image[]</b> instead of being stored in
an ordinary reference variable.
<p><b><font color="#FF0000">The GIF file name</font></b>
<p>The code in Listing 4 also shows the name to be applied to one of the
GIF files that you capture from this HTML document: <b>redball.gif</b>.
<p><b><font color="#FF0000">The remaining Image objects</font></b>
<p>The code for creating and registering the remaining five <b>Image</b>
objects is shown in Listing 5.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>greenball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>blueball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>yellowball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>purpleball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("<b>orangeball.gif</b>");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);


<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The registration identifier</font></b>
<p>Note that the identifier value used to register all seven of the <b>Image</b>
objects on the <b>MediaTracker</b> object is the same (0).&nbsp; As a result,
the <b>MediaTracker</b> object will track the loading of all seven <b>Image</b>
objects as a group.
<p>Listing 5 also shows the names to be applied to the five remaining GIF
files that you capture from this HTML file.
<p><b><font color="#FF0000">Using the MediaTracker object</font></b>
<p>Listing 6 shows the use of the <b>MediaTracker</b> object to delay execution
of the program until all seven of the images have been loaded and are ready
for use.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.<b>waitForID</b>(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The waitForID method</font></b>
<p>The <b>waitForID</b> method call in Listing 6 causes the program to
block and wait for all of the images to complete loading <i>(or for a loading
error to occur).</i>&nbsp; Here is part of what Sun has to say about this
method:
<blockquote><i>"Starts loading all images tracked by this media tracker
with the specified identifier. This method waits until all the images with
the specified identifier have finished loading.</i>
<p><i>If there is an error while loading or scaling an image, then that
image is considered to have finished loading.&nbsp; Use the isErrorAny
and isErrorID methods to check for errors."</i></blockquote>
<b><font color="#FF0000">No guarantee of successful loading</font></b>
<p>The fact that this method returns doesn't guarantee that all of the
images identified by the ID value of 0 have successfully loaded.&nbsp;
As indicated by Sun, the occurrence of a loading error will also cause
this method to return.
<p>Once the method returns, in order to be completely safe, the program
should use one of the error checking methods listed in the quotation from
Sun to confirm that an error did not occur.
<p><b><font color="#FF0000">Another version of the waitForID method</font></b>
<p>Note that in theory, this method could block and wait forever.&nbsp;
Another version of the <b>waitForID</b> method allows for the specification
of a maximum length of time in milliseconds to block before returning,
with or without a successful load.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have explained how to instantiate and use a <b>MediaTracker</b>
object to track the loading status of <b>Image</b> objects.
<p>I have explained how to use the <b>getImage</b> method of the <b>Toolkit</b>
class to create <b>Image</b> objects from GIF files, and how to register
those <b>Image</b> objects on a <b>MediaTracker</b> object.
<p>Finally, I explained how to use the <b>waitForID</b> method of the <b>MediaTracker</b>
object to force the program to block and wait until the images in a group
are either successfully loaded, or until a loading error occurs.
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will continue explaining the constructor for the
controlling class.&nbsp; The first topic in that lesson will deal with
the methodology used to cause the size of the <b>Frame</b> object to be
based on the size of the <b>Image</b> object used as a background.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
7</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate01.java
Copyright 2001, R.G.Baldwin

This program displays several animated
colored spherical creatures swimming&nbsp;
around in an aquarium.&nbsp; Each creature&nbsp;
maintains generally the same course
with until it collides with another&nbsp;
creature or with a wall.&nbsp; However,&nbsp;
each creature has the ability to&nbsp;
occasionally make random changes in&nbsp;
its course.

**************************************/
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Animate01 extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable {
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];
&nbsp; //offscreen graphics context
&nbsp; private Graphics&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;
&nbsp; private MediaTracker mediaTracker;
&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate01();
&nbsp; }//end main
&nbsp; //---------------------------------//

&nbsp; Animate01() {//constructor
&nbsp;&nbsp;&nbsp; // Load and track the images
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Get and track the background&nbsp;
&nbsp;&nbsp;&nbsp; // image
&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("background02.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and track 6 images to use&nbsp;
&nbsp;&nbsp;&nbsp; // for sprites
&nbsp;&nbsp;&nbsp; gifImages[0] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("redball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);
&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("greenball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("blueball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("yellowball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("purpleball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("orangeball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Block and wait for all images to&nbsp;
&nbsp;&nbsp;&nbsp; // be loaded
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.waitForID(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Base the Frame size on the size&nbsp;
&nbsp;&nbsp;&nbsp; // of the background image.
&nbsp;&nbsp;&nbsp; //These getter methods return -1 if
&nbsp;&nbsp;&nbsp; // the size is not yet known.
&nbsp;&nbsp;&nbsp; //Insets will be used later to&nbsp;
&nbsp;&nbsp;&nbsp; // limit the graphics area to the&nbsp;
&nbsp;&nbsp;&nbsp; // client area of the Frame.
&nbsp;&nbsp;&nbsp; int width =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getWidth(this);
&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getHeight(this);

&nbsp;&nbsp;&nbsp; //While not likely, it may be&nbsp;
&nbsp;&nbsp;&nbsp; // possible that the size isn't
&nbsp;&nbsp;&nbsp; // known yet.&nbsp; Do the following&nbsp;
&nbsp;&nbsp;&nbsp; // just in case.
&nbsp;&nbsp;&nbsp; //Wait until size is known
&nbsp;&nbsp;&nbsp; while(width == -1 || height == -1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Waiting for image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWidth(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the frame
&nbsp;&nbsp;&nbsp; setSize(width,height);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2001, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; //Create and start animation thread
&nbsp;&nbsp;&nbsp; animationThread = new Thread(this);
&nbsp;&nbsp;&nbsp; animationThread.start();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner class window&nbsp;
&nbsp;&nbsp;&nbsp; // listener to terminate the&nbsp;
&nbsp;&nbsp;&nbsp; // program.
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public void run() {
&nbsp;&nbsp;&nbsp; //Create and add sprites to the&nbsp;
&nbsp;&nbsp;&nbsp; // sprite manager
&nbsp;&nbsp;&nbsp; spriteManager = new SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, backGroundImage));
&nbsp;&nbsp;&nbsp; //Create 15 sprites from 6 gif&nbsp;
&nbsp;&nbsp;&nbsp; // files.
&nbsp;&nbsp;&nbsp; for (int cnt = 0; cnt &lt; 15; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position = spriteManager.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEmptyPosition(new Dimension(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].getWidth(this),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.addSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeSprite(position, cnt % 6));
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Loop, sleep, and update sprite&nbsp;
&nbsp;&nbsp;&nbsp; // positions once each 83&nbsp;
&nbsp;&nbsp;&nbsp; // milliseconds
&nbsp;&nbsp;&nbsp; long time =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis();
&nbsp;&nbsp;&nbsp; while (true) {//infinite loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time += animationDelay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0,time -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end run method
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private Sprite makeSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex) {
&nbsp;&nbsp;&nbsp; return new Sprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[imageIndex],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Overridden graphics update method&nbsp;
&nbsp; // on the Frame

&nbsp; public void update(Graphics g) {
&nbsp;&nbsp;&nbsp; //Create the offscreen graphics&nbsp;
&nbsp;&nbsp;&nbsp; // context
&nbsp;&nbsp;&nbsp; if (offScreenGraphicsCtx == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createImage(getSize().width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage.getGraphics();
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Draw the sprites offscreen
&nbsp;&nbsp;&nbsp; spriteManager.drawScene(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx);

&nbsp;&nbsp;&nbsp; // Draw the scene onto the screen
&nbsp;&nbsp;&nbsp; if(offScreenImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage, 0, 0, this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end overridden update method
&nbsp; //---------------------------------//

&nbsp; //Overridden paint method on the&nbsp;
&nbsp; // Frame
&nbsp; public void paint(Graphics g) {
&nbsp;&nbsp;&nbsp; //Nothing required here.&nbsp; All&nbsp;
&nbsp;&nbsp;&nbsp; // drawing is done in the update&nbsp;
&nbsp;&nbsp;&nbsp; // method above.
&nbsp; }//end overridden paint method
&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Animate01
//===================================//

class BackgroundImage{
&nbsp; private Image image;
&nbsp; private Component component;
&nbsp; private Dimension size;

&nbsp; public BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image) {
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; size = component.getSize();
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end construtor
&nbsp;&nbsp;
&nbsp; public Dimension getSize(){
&nbsp;&nbsp;&nbsp; return size;
&nbsp; }//end getSize()

&nbsp; public Image getImage(){
&nbsp;&nbsp;&nbsp; return image;
&nbsp; }//end getImage()

&nbsp; public void setImage(Image image){
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end setImage()

&nbsp; public void drawBackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g) {
&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image, 0, 0, component);
&nbsp; }//end drawBackgroundImage()
}//end class BackgroundImage
//===========================

class SpriteManager extends Vector {
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage) {
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getEmptyPosition(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void update() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.updatePosition();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for collision. Positive&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result indicates a collision
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testForCollision(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitIndex >= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceOffSprite(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private int testForCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite) {
&nbsp;&nbsp;&nbsp; //Check for collision with other&nbsp;
&nbsp;&nbsp;&nbsp; // sprites
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void bounceOffSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawScene(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBackgroundImage(g);

&nbsp;&nbsp;&nbsp; //Iterate through sprites, drawing
&nbsp;&nbsp;&nbsp; // each sprite
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawSpriteImage(g);
&nbsp; }//end drawScene()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void addSprite(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()
&nbsp;&nbsp;
}//end class SpriteManager
//===================================//

class Sprite {
&nbsp; private Component component;
&nbsp; private Image image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;

&nbsp; public Sprite(Component component,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp;&nbsp;&nbsp; //Compute edges of usable graphics
&nbsp;&nbsp;&nbsp; // area in the Frame.
&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().top;
&nbsp;&nbsp;&nbsp; int bottomBorder =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public Rectangle getSpaceOccupied(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getMotionVector(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; Point position = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.&nbsp; This&nbsp;
&nbsp;&nbsp;&nbsp; // puts a cap on the maximum speed
&nbsp;&nbsp;&nbsp; // for a sprite.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point randomOffset =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Move the sprite on the screen
&nbsp;&nbsp;&nbsp; position.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

&nbsp;&nbsp;&nbsp; //Bounce off the walls
&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector = new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if ((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x + spaceOccupied.width)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(bounceRequired)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector);
&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.drawImage(image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public boolean testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; //Check for collision with&nbsp;
&nbsp;&nbsp;&nbsp; // another sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class
//===================================//

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2001, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
