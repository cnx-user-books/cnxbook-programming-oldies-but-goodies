<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Spectrum Analysis using Java, Forward and Inverse Transforms, Filtering in 
the Frequency Domain</h2>
    <i>Baldwin illustrates and explains forward and inverse Fourier 
transforms using both DFT and FFT algorithms.&nbsp; He also illustrates and 
explains the implementation of frequency filtering by modifying the complex 
spectrum in the frequency domain and transforming the modified complex spectrum back into the time 
domain.</i><p><b>Published:</b>&nbsp; November 16, 2004 </p>
<p><b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 1485</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a>
  <li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a>
  </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
  <p><font color="#FF0000"><b>Spectral analysis</b></font></p>
<p>A previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/3374611">Fun with Java, 
How and Why Spectral Analysis Works</a> explained some of the fundamentals 
regarding spectral analysis. </p>
<p>The lesson entitled
<a href="http://www.developer.com/java/other/article.php/3380031">Spectrum 
Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
Algorithm</a> presented and explained several Java 
programs for doing spectral analysis, including both DFT programs and FFT 
programs.&nbsp; That lesson illustrated the fundamental aspects of 
spectral analysis that center around the sampling frequency and the Nyquist 
folding frequency.</p>
<p>The lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3392871">Spectrum 
Analysis using Java, Frequency Resolution versus Data Length</a> used similar Java programs to explain spectral 
frequency resolution.</p>
<p>The lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3411041">Spectrum 
Analysis using Java, Complex Spectrum and Phase Angle</a> explained issues involving the complex spectrum, the phase angle, 
and shifts in the time domain.</p>
<p>This lesson will illustrate and explain forward and inverse Fourier 
transforms using both DFT and FFT algorithms.&nbsp; I will also illustrate and 
explain the implementation of frequency filtering by modifying the complex 
spectrum in the frequency domain and then transforming the modified complex 
spectra back into the time 
domain.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them. </p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p>In this lesson, I will present and explain the following new programs:</p>
<ul>
	<li><b>Dsp035</b> - Illustrates the reversible nature of the Fourier 
	transform.&nbsp; This program transforms a real time series into a complex 
	spectrum, and then reproduces the real time series by performing an inverse 
	Fourier transform on the complex spectrum.&nbsp; This is accomplished using 
	a DFT algorithm.</li>
	<li><b>InverseComplexToReal01</b> - Class that implements an inverse DFT 
	algorithm for transforming a complex spectrum into a real time series.</li>
	<li><b>Dsp036</b> - Replicates the behavior of the program named Dsp035 but 
	uses an FFT algorithm instead of a DFT algorithm.</li>
	<li><b>InverseComplexToRealFFT01</b> - Class that implements an inverse FFT 
	algorithm for transforming a complex spectrum into a real time series.</li>
	<li><b>Dsp037</b> - Illustrates filtering in the frequency domain.&nbsp; 
	Uses an FFT algorithm to transform a time-domain impulse into the frequency 
	domain.&nbsp; Modifies the complex spectrum, eliminating energy within a 
	specific band of frequencies.&nbsp; Uses an inverse FFT algorithm to produce 
	the filtered version of the impulse in the time domain.</li>
</ul>
<p>In addition, I will use the following programs that I explained in the lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3380031">
Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
Algorithm</a>.</p>
<ul>
	<li><b>ForwardRealToComplex01</b> - Class that implements a forward DFT algorithm 
	for transforming a real time series into a complex spectrum.</li>
	<li><b>ForwardRealToComplexFFT01</b> - Class that implements a forward FFT 
	algorithm for transforming a real time series into a complex spectrum.</li>
	<li><b>Graph03</b> - Used to display various types of data. <i>(The concepts were explained in an earlier lesson.)</i></li>
	<li><b>Graph06</b> - Also used to display various types of data in a 
	somewhat different format. <i>(The concepts were also explained in an earlier lesson.)</i></li>
</ul>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p><font color="#FF0000"><b>Description of the program named Dsp035</b></font></p>
<p>The program named <b>Dsp035</b> illustrates forward and inverse Fourier 
transforms using DFT algorithms.</p>
<p>The program performs spectral analysis on a time series consisting of pulses 
and a sinusoid.&nbsp; Then it passes the resulting real and complex parts of the 
spectrum to an inverse Fourier transform program.&nbsp; This program performs an 
inverse Fourier transform on the complex spectral data to reconstruct the 
original time series.</p>
<p>This program can be run with either <b>Graph03</b> or <b>Graph06</b> in order 
to plot the results.&nbsp; Enter the following at the command-line prompt to run 
the program with Graph03:</p>
<p><b>java Graph03 Dsp035</b></p>
<p>The program was tested using J2SE 1.4.2 under WinXP.</p>
<p><font color="#FF0000"><b>The order of the plotted results</b></font></p>
<p>When the data is plotted <i>(see Figure 1)</i> using the programs <b>Graph03</b> or <b>Graph06</b>, the plots 
appear in the following order from top to bottom:</p>
<ul>
	<li>The input time series</li>
	<li>The real spectrum of the input time series</li>
	<li>The imaginary spectrum of the input time series</li>
	<li>The amplitude spectrum of the input time series</li>
	<li>The output time series produced by the inverse Fourier transform</li>
</ul>
<p><font color="#FF0000"><b>The format of the plots</b></font></p>
<p>There were 256 values plotted horizontally in each section.&nbsp; I plotted the values on a grid 
that is 270 units wide to make it easier to view the plots on the rightmost end.&nbsp; This leaves some blank space on the rightmost end 
to contain the numbers, preventing the numbers from being mixed in with the 
plotted values.&nbsp; The last actual data value coincides with the rightmost 
tick mark on each plot.</p>
<p><font color="#FF0000"><b>The forward Fourier transform</b></font></p>
<p>A static method named <b>transform</b> belonging to the
class named <b>ForwardRealToComplex01</b> was used to
perform the forward Fourier transform.</p>
<blockquote>
	<p><i>(I explained this class and the <b>transform</b> method in the earlier 
	lesson entitled 
	<a href="http://www.developer.com/java/other/article.php/3380031">Spectrum 
	Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
	Algorithm</a>.)</i></p>
</blockquote>
<p>The
method named <b>transform</b> does not implement an FFT algorithm.&nbsp; Rather, 
it implements a DFT algorithm, which is more general than, but much slower than 
an FFT algorithm.</p>
<blockquote>
	<p><i>(See the
program named Dsp036 later in the lesson for the use of an FFT
algorithm.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The inverse Fourier transform</b></font></p>
<p>A static method named <b>inverseTransform</b> belonging to the class named <b>
InvereComplexToReal01</b> was used to perform the inverse Fourier transform.&nbsp; 
I will explain this method later in this lesson.</p>
<p><font color="#FF0000"><b>Let's see some results</b></font></p>
<p>Before getting into the technical details of the program, let's take a look 
at the results shown in Figure 1.</p>
<p>The top plot in Figure 1 shows the input time series used in this experiment.</p>



<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1485a01.jpg" width="409" height="430">

<b>Figure 1 Forward and inverse transform of a time
         series using DFT algorithm</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#FF0000"><b>Length is a power of two</b></font></p>
<p>The time series is 256 samples long.&nbsp; Although the DFT algorithm can 
accommodate time series of arbitrary lengths, I set the length of this time 
series to a power of two so that I can compare the results with results produced 
by an FFT algorithm later in the lesson.</p>
<blockquote>
	<p><i>(Recall that most FFT algorithms are restricted to input data lengths 
	that are a power of two.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The input time series</b></font></p>
<p>As you can see, the input time series consists of three concatenated pulses 
separated by blank spaces.&nbsp; The pulse on the leftmost end consists simply 
of some values that I entered into the time series to create a pulse with an 
interesting shape.</p>
<p>The middle pulse is a truncated sinusoid.</p>
<p>The rightmost pulse is a truncated square wave.</p>
<p><font color="#FF0000"><b>The objective</b></font></p>
<p>The objective of the experiment is to confirm that it is possible to transform this 
time series into the frequency domain using a forward Fourier transform, and 
then to recreate the time series by using an inverse Fourier transform to 
transform the complex spectrum back into the time domain.</p>
<p><font color="#FF0000"><b>The real part of the spectrum is symmetrical</b></font></p>
<p>The real part of the complex spectrum is shown in the second plot from the 
top in Figure 1.&nbsp; It will become important later to note that the real part of the 
spectrum is symmetrical about the folding frequency near the center of the plot
<i>(at the eighth tick mark).</i></p>
<p>Without attempting to explain why, I will simply tell you that the real part 
of the Fourier transform of a complex series whose imaginary part is all zeros 
is always symmetrical about the folding frequency.</p>
<p><font color="#FF0000"><b>The imaginary part of the spectrum is asymmetrical</b></font></p>
<p>The imaginary part of the complex spectrum is shown in the third plot from 
the top.&nbsp; Again, it will become important later to note that the imaginary 
part of the spectrum is asymmetrical about the folding frequency.</p>
<p>Once again, without attempting to explain why, the imaginary part of the 
Fourier transform of a complex series whose imaginary part is all zeros is 
always asymmetrical about the folding frequency.</p>
<p><font color="#FF0000"><b>The converse is also true</b></font></p>
<p>It is also true that the values of the imaginary part of the Fourier 
transform of a complex spectrum whose real part is symmetrical about the folding 
frequency and whose imaginary part is asymmetrical about the folding frequency 
will be all be zero.&nbsp; I will take advantage of these facts later to 
simplify the computing and plotting process.</p>
<p><font color="#FF0000"><b>The amplitude spectrum</b></font></p>
<p>The amplitude spectrum is shown in the fourth plot down from the top.&nbsp; 
Recall from previous lessons that the amplitude values are always positive, 
consisting of the square root of the sum of the squares of the real and 
imaginary parts.</p>
<p><font color="#FF0000"><b>The output time series</b></font></p>
<p>The output time series, produced by performing an inverse Fourier transform 
on the complex spectrum is shown in the bottom plot in Figure 1.&nbsp; Compare 
the bottom plot to the top plot.&nbsp; As you can see, they are the same, 
demonstrating the reversible nature of the Fourier transform.</p>
<p><font color="#FF0000"><b>Let's see some code</b></font></p>
<p>I will discuss this program in fragments.&nbsp; A complete listing of the 
program is provided in Listing 14 near the end of the lesson.</p>
<p>The beginning of the class for <b>Dsp035</b>, including the declaration of 
some variables and the creation of some array objects is shown in Listing 1.&nbsp; 
This code is straightforward.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class Dsp035 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeDataOut = new double[len];
  int zero = 0;

<b>Listing 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor begins in Listing 2.&nbsp; The code in Listing 2 creates the 
input time series data shown in the top plot of Figure 1.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public Dsp035(){//constructor

    //Create the raw data pulses
    timeDataIn[0] = 0;
    timeDataIn[1] = 50;
//...
//code deleted for brevity
//...
    timeDataIn[254] = -80;
    timeDataIn[255] = -80;

    //Create raw data sinusoid
    for(int x = len/3;x < 3*len/4;x++){
      timeDataIn[x] = 80.0 * Math.sin(
                              2*pi*(x)*1.0/20.0);
    }//end for loop

<b>Listing 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>Note that I deleted much of the code from Listing 2 for brevity.&nbsp; You 
can view the missing code in Listing 14 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Compute the complex spectrum</b></font></p>
<p>The code in Listing 3 invokes the static <b>transform</b> method of the <b>
ForwardRealToComplex01</b> class to compute and save the complex spectrum of the 
time series shown in the top plot of Figure 1.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    ForwardRealToComplex01.transform(timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude,
                                     zero,
                                     0.0,
                                     1.0);

<b>Listing 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p><font color="#FF0000"><b>The method parameters</b></font></p>
<p>I explained the <b>transform</b> method in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3380031">Spectrum 
Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT 
Algorithm</a>.&nbsp; The three middle plots in Figure 1 are plots of the data returned 
in the arrays referred to by <b>realSpect</b>, <b>imagSpect</b>, and <b>
magnitude</b> by the <b>transform </b>method.</p>
<p>The angle results returned by the <b>transform</b> program are not used in 
this lesson.</p>
<p>One of the parameters <i>(zero)</i> establishes that the first sample in the 
time series array referred to by
<b>timeDataIn</b> represents the zero time origin.</p>
<p>The parameters also specify that the complex spectrum is to be computed at a 
set of equally spaced frequencies ranging from zero <i>(0.0)</i> to the sampling 
frequency <i>(1.0).</i></p>
<p><font color="#FF0000"><b>Perform the inverse Fourier transform</b></font></p>
<p>The code in Listing 4 invokes the static <b>inverseTransform</b> method of 
the <b>InverseComplexToReal01</b> class to perform an inverse Fourier transform 
on the complex spectral data, producing the output time series shown in the 
bottom plot in Figure 1.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    InverseComplexToReal01.inverseTransform(
                    realSpect,
                    imagSpect,
                    timeDataOut);
  }//end constructor

<b>Listing 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>I will explain the <b>inverseTransform</b> method later.</p>
<p><font color="#FF0000"><b>An object of the class Dsp035</b></font></p>
<p>Listing 4 also signals the end of the constructor.&nbsp; Once the constructor 
has completed executing, an object of the <b>Dsp035</b> class exists.&nbsp; The 
array objects belonging to the object have been populated with the original time 
series, the complex spectrum of the original time series, and the output time 
series produced by performing an inverse Fourier transform on that complex 
spectrum.&nbsp; This data is ready for plotting.</p>
<p><font color="#FF0000"><b>The interface methods</b></font></p>
<p>All of the remaining code in <b>Dsp035</b> consists of the six methods 
necessary to satisfy the interface named <b>GraphIntfc01</b>.&nbsp; Those 
methods are required to provide data to the plotting program, as explained in 
earlier lessons in this series.</p>
<p>If you have studied the previous lessons in this series, you probably don't 
want to hear any more about those methods, so I won't discuss them further.&nbsp; 
You can view the six interface methods in Listing 14 near the end of the 
lessons.</p>
<p><font color="#FF0000"><b>The inverseTransform method of the 
InverseComplexToReal01 class</b></font></p>
<p>The static method named <b>inverseTransform</b> performs
a complex-to-real inverse discrete Fourier
transform returning a real result only.&nbsp; In other
words, the method transforms a complex input to a
real output.</p>
<p>There are more efficient ways to write
this method taking known symmetry and asymmetry conditions into account.&nbsp; 
However, I wrote the method the way that I did because I wanted it to
mimic the behavior of an FFT algorithm.&nbsp;
Therefore, the complex input must extend from
zero to the sampling frequency.</p>
<p>The method does not implement an FFT algorithm.&nbsp; Rather, the <b>
inverseTransform</b> method implements
a straight forward sampled-data version of the
continuous inverse Fourier transform that is defined
using integral calculus.</p>
<p><font color="#FF0000"><b>The parameters</b></font></p>
<p>The parameters to the <b>inverseTransform</b> are:</p>
<ul>
	<li>double[] realIn - incoming real data</li>
	<li>double[] imagIn - incoming imag data</li>
	<li>double[] realOut - outgoing real data</li>
</ul>
<p>The method considers the data length to be&nbsp;<b>realIn.length</b>, and considers the computational time increment to be
<b>1.0/realIn.length</b>.</p>
<p><font color="#FF0000"><b>Assumptions</b></font></p>
<p>The method returns a number of points equal to the data
length.&nbsp; It assumes that the real input consists of positive
frequency points for a symmetric real frequency
function.&nbsp; That is, the real input is assumed to
be symmetric about the folding frequency.&nbsp; The method does
not test this assumption.</p>
<p>The method assumes that imaginary input consists of positive
frequency points for an asymmetric imaginary
frequency function.&nbsp; That is, the imaginary input
is assumed to be asymmetric about the
folding frequency.&nbsp; Once again, the method does not test this
assumption.</p>
<p><font color="#FF0000"><b>A real output</b></font></p>
<p>A symmetric real part and an
asymmetric imaginary part guarantee that the
imaginary output will be all zero values.&nbsp; Having made that assumption, the program makes no attempt<br>
to compute an imaginary output.&nbsp; If the assumptions described above are not valid, the 
results won't be valid.</p>
<p>The program was tested using J2SE v1.4.2 under WinXP.</p>
<p><font color="#FF0000"><b>The inverseTransform method</b></font></p>
<p>The beginning of the class and the beginning of the static <b>
inverseTransform</b> method is shown in Listing 5.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
public class <b>InverseComplexToReal01</b>{

  public static void <b>inverseTransform</b>(
                               double[] realIn,
                               double[] imagIn,
                               double[] realOut){

    int dataLen = realIn.length;
    double delT = 1.0/realIn.length;
    double startTime = 0.0;
    
<b>Listing 5</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>Listing 5 declares and initializes some variables that will be used later.</p>
<p><font color="#FF0000"><b>The inverse transform computation</b></font></p>
<p>Listing 6 contains a pair of nested <b>for</b> loops that perform the actual 
inverse transform computation.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Outer loop interates on time domain
    // values.
    for(int i=0; i < dataLen;i++){
      double time = startTime + i*delT;
      double real = 0;
      //Inner loop iterates on frequency
      // domain values.
      for(int j=0; j < dataLen; j++){
        real += realIn[j]*
                      Math.cos(2*Math.PI*time*j)
             + imagIn[j]*
                      Math.sin(2*Math.PI*time*j);
      }//end inner loop
      realOut[i] = real;
    }//end outer loop
  }//end inverseTransform

}//end class InverseComplexToReal01

<b>Listing 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>If you have been studying the earlier lessons in this series, you should be 
able to understand the code in Listing 6 without further explanation.&nbsp; Pay 
particular attention to the comments that describe the two <b>for</b> loops.</p>
<p><font color="#FF0000"><b>The program named Dsp036</b></font></p>


<p>The program named <b>Dsp036</b> replicates the behavior of the program named <b>Dsp035</b>, except that it uses an FFT algorithm to perform the 
inverse Fourier transform instead of using a DFT algorithm as in <b>Dsp035</b>.</p>
<p><font color="#FF0000"><b>The output from Dsp036</b></font></p>
<p>The output produced by running the program named <b>Dsp036</b> and plotting 
the output using the program named <b>Graph03</b> is shown in Figure 2.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1485a02.jpg" width="409" height="431">

<b>Figure 2 Forward and inverse transform of a time
         series using FFT algorithm</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p>Compare Figure 2 with Figure 1.&nbsp; The two should be identical.&nbsp; The 
program named <b>Dsp036</b> was designed to use an FFT algorithm for the inverse 
Fourier transform and to replicate the behavior of the program named <b>Dsp035</b>, 
which uses a DFT algorithm for the inverse Fourier transform.&nbsp; In addition, 
the same plotting parameters were used for both figures.</p>
<p><font color="#FF0000"><b>The code</b></font></p>


<p>I'm only going to show you one short code fragment from the program named <b>
Dsp036</b>.&nbsp; Listing 7 shows the code that invokes the methods to perform 
the forward and inverse Fourier transforms using the FFT algorithm.&nbsp; A 
complete listing of the program named <b>Dsp036</b> is shown in Listing 16 near 
the end of the lesson.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Compute FFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplexFFT01.transform(
                                     timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude);

    //Compute inverse FFT of the spectral data
    InverseComplexToRealFFT01.
                                inverseTransform(
                                     realSpect,
                                     imagSpect,
                                     timeOut);

<b>Listing 7</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p><font color="#FF0000"><b>The forward Fourier transform</b></font></p>
<p>The <b>transform</b> method used to perform the forward Fourier transform in 
Listing 7 was 
discussed in an earlier lesson, so I won't discuss it further here.</p>
<p><font color="#FF0000"><b>The inverse Fourier transform</b></font></p>
<p>The static <b>inverseTransform</b> method of the <b>InverseComplexToRealFFT01</b> 
class was used to perform the inverse Fourier transform in Listing 7.&nbsp; You 
can view this method in Listing 17 near the end of the lesson.</p>
<p>I'm not going to discuss 
this method in detail either, because it is very similar to the method named <b>
InverseComplexToReal01</b> discussed earlier in conjunction with Listing 4 and 
the listings following that one.</p>
<p><font color="#FF0000"><b>A couple of things to note</b></font></p>
<p>There are a couple of things, however, that I do want to point out.&nbsp; </p>
<p>The<b> transform </b>method and the <b>inverseTransform</b> method each 
invoke a method named <b>complexToComplex</b> to actually perform the Fourier 
transform.&nbsp; This method implements a classical FFT algorithm accepting 
complex input data and producing complex output data.&nbsp; The restriction of 
real-to-complex and complex-to-real is imposed by the methods named <b>transform</b> 
and <b>inverseTransform</b>.</p>
<blockquote>
	<p><i>(The method named <b>complexToComplex</b> is also suitable for use if you have 
a need to perform complex-to-complex Fourier transforms.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The signature of the complexToComplex method</b></font></p>
<p>The signature for the <b>complexToComplex</b> method is shown in Figure 3.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>  public static void complexToComplex(
                                  int sign,
                                  int len,
                                  double real[],
                                  double imag[]){

<b>Figure 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p>The <b>complexToComplex</b> method can be used to perform either a forward or 
an inverse transform.&nbsp; The value of the first parameter determines whether the method performs a 
forward or an inverse Fourier transform.</p>
<p><font color="#FF0000"><b>The first parameter of the complexToComplex method</b></font></p>
<p>A value of +1 for the first 
parameter causes the <b>complexToComplex</b> method to perform a forward Fourier 
transform.</p>
<p>A value of -1 for the first parameter causes the <b>
complexToComplex</b> method to perform an inverse Fourier transform.</p>
<p><font color="#FF0000"><b>The forward transform</b></font></p>
<p>Although I didn't include the code in this lesson, <i>(because it was shown 
in an earlier lesson),</i> the <b>transform</b> method in Figure 7 passes a 
value of +1 to the <b>complexToComplex</b> method to cause it to perform a 
forward Fourier transform.</p>
<p><font color="#FF0000"><b>The inverse transform</b></font></p>
<p>Similarly, the <b>inverseTransform</b> method shown in Listing 17 passes a 
value of -1 to the <b>complexToComplex</b> method to cause it to perform an 
inverse Fourier transform.</p>
<p><font color="#FF0000"><b>FFT and DFT produce equivalent results</b></font></p>
<p>As evidenced in Figure 1 and Figure 2, the program named <b>Dsp035</b>, which 
uses a DFT algorithm, produces the same results as the program named <b>Dsp036</b>, 
which uses an FFT algorithm.&nbsp; However, if you were to put a timer on each 
of the programs, you 
would find that <b>Dsp036</b> runs faster due to the improved speed of the FFT 
algorithm over the DFT algorithm.</p>
<p><font color="#FF0000"><b>Using a Fourier transform to perform frequency 
filtering</b></font></p>
<p>
<p>The program named <b>Dsp037</b> illustrates frequency filtering accomplished 
by modifying the complex spectrum in the frequency 
domain and then performing an inverse Fourier transform on the modified 
frequency-domain data.&nbsp; The results are shown in Figure 4.</p>


<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1485a03.jpg" width="409" height="431">

<b>Figure 4 Illustrates filtering in the frequency
         domain</b></pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#FF0000"><b>Operation of the program</b></font></p>


<p>The program begins by using an FFT algorithm to perform a forward 
Fourier transform on a single impulse in the time domain.</p>
<blockquote>
	<p><i>(A DFT algorithm could have been used equally as well, but it would 
	have been slower.)</i></p>
</blockquote>
<p>The impulse is shown as the input time series in the topmost plot in Figure 
4.</p>
<blockquote>
	<p><i>(Although I didn't show the complex spectrum of the impulse, we know 
	that the magnitude of the spectrum of an impulse is constant across all 
	frequencies.&nbsp; In other words, the magnitude spectrum of an impulse is a 
	flat line from zero to the sampling frequency and above.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Modify the complex spectrum</b></font></p>
<p>Then the program 
eliminates all energy between one-sixth and five-sixths of the sampling 
frequency by setting the real and imaginary parts of the FFT output to zero.</p>
<p>The second, third, and fourth plots in Figure 4 show the real part, imaginary 
part, and amplitude respectively of the modified complex spectrum.</p>
<blockquote>
	<p><i>(The two boxes in the fourth plot in Figure 4 show what's left of the 
	spectral energy after the energy in the middle of the band has been 
	eliminated.)</i></p>
</blockquote>
<p>The folding frequency in these three plots is near the center of the plot at 
the eighth tick mark.</p>
<p><font color="#FF0000"><b>The plotting format</b></font></p>
<p>The input data length was 256 samples.&nbsp; All but one of the input data 
values was set to zero resulting in a single impulse in the input time series near the 
second tick mark in Figure 4.</p>
<blockquote>
	<p><i>(The real and complex parts of the frequency spectrum were computed at 
	256 frequencies between zero and the sampling frequency.)</i></p>
</blockquote>
<p>There were 256 values plotted horizontally in each separate plot.&nbsp; Once 
again, to make it 
easier to view the plots on the rightmost end, I plotted the values on a grid 
that is 270 units wide.&nbsp; This leaves some blank space on the rightmost end to 
contain the numbers, thus preventing the numbers from being mixed in with the 
plotted values.&nbsp; The last actual data value coincides with the rightmost tick 
mark on each plot.</p>
<p><b><font color="#FF0000">Perform an inverse Fourier transform</font></b></p>
<p>After modifying the complex spectrum as described above, the 
program performs an inverse Fourier transform on the modified complex spectrum to produce the 
filtered impulse.</p>
<p><font color="#FF0000"><b>The filtered impulse</b></font></p>
<p>The filtered impulse is shown as the bottom plot in 
Figure 4.&nbsp; As you can see, the pulse is smeared out in time relative to the 
input pulse in the top plot.&nbsp; This is the typical result of reducing the 
bandwidth of a pulse.&nbsp; </p>
<blockquote>
	<p><i>(This particular modification of the complex spectrum resulted in a 
	filtered pulse that has the waveform of a SIN(X)/X function.&nbsp; A 
	different modification of the complex spectrum would have resulted in a 
	filtered pulse with a different waveform.</i></p>
	<p><i>This example also illustrates one of the miracles of digital signal 
	processing.&nbsp; Energy appears in the output before it occurs in the 
	input.&nbsp; Obviously that is not possible in the real world of analog 
	systems, but many things are possible in the digital world that are not 
	possible in the real world.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The code for Dsp037</b></font></p>
<p>Listing 8 shows the beginning of the class definition for the program named
<b>Dsp037</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class Dsp037 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeOut = new double[len];

<b>Listing 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>Listing 8 simply declares and initializes some variables that will be used 
later.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor begins in Listing 9.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public Dsp037(){//constructor

    timeDataIn[32] = 90;

<b>Listing 9</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>Listing 9 creates the raw pulse data shown in the topmost plot in Figure 4.</p>
<p>When the array object referred to by <b>timeDataIn</b> is created, the values 
of all array elements are set to zero by default.&nbsp; Listing 9 modifies one 
of the elements to have a value of 90.&nbsp; This results in a single impulse at 
an index of 32.</p>
<p><font color="#FF0000"><b>Compute the Fourier transform</b></font></p>
<p>Still in the constructor, the code in Listing 10 uses an FFT algorithm in the 
method named <b>transform</b> <i>(discussed earlier)</i> to compute the Fourier 
transform of the impulse.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Compute FFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplexFFT01.transform(
                                     timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude);

<b>Listing 10</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>The results of the Fourier transform are stored in the array objects referred 
to by <b>realSpect</b>, <b>imagSpect</b>, and <b>magnitude</b>.</p>
<blockquote>
	<p><i>(The phase angle is also computed but is of no interest in this 
	example.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Apply the filter to the frequency data</b></font></p>
<p>Listing 11 applies the filter by setting sample values in a portion of the 
real and imaginary parts of the complex spectrum to zero.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int cnt = len/6;cnt < 5*len/6;cnt++){
      realSpect[cnt] = 0.0;
      imagSpect[cnt] = 0.0;
    }//end for loop

<b>Listing 11</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>This code eliminates all energy between one-sixth and five-sixths of the 
sampling frequency.&nbsp; The modified data for the real and imaginary parts of 
the complex spectrum are shown in the second and third plots in Figure 4.</p>
<p><font color="#FF0000"><b>Recompute the magnitude</b></font></p>

<p>Listing 12 recomputes the magnitude values for the modified real and 
imaginary values of the complex spectrum.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Recompute the magnitude based on the
    // modified real and imaginary spectra.
    for(int cnt = 0;cnt < len;cnt++){
      magnitude[cnt] =
        (Math.sqrt(
           realSpect[cnt]*realSpect[cnt]
           + imagSpect[cnt]*imagSpect[cnt])/len);
    }//end for loop

<b>Listing 12</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>The modified data for the amplitude of the complex spectrum are shown in the 
fourth plot in Figure 4.</p>
<p><font color="#FF0000"><b>Compute the inverse Fourier transform</b></font></p>
<p>Listing 13 uses the <b>inverseTransform</b> method to compute the inverse 
Fourier transform of the modified complex spectrum stored in <b>realSpect</b> 
and <b>imagSpect</b>.&nbsp; The results of the inverse transform are stored in
<b>timeOut</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    InverseComplexToRealFFT01.inverseTransform(
                                       realSpect,
                                       imagSpect,
                                       timeOut);
  }//end constructor

<b>Listing 13</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>The results of the inverse transform are shown in the bottom plot in Figure 
4.</p>
<p>Listing 13 also signals the end of the constructor.</p>
<p><font color="#FF0000"><b>Display the results</b></font></p>
<p>Once the constructor returns, all of the data that is to be plotted has been 
stored in the various array objects.&nbsp; The remaining code in the program 
consists of the definition of the six methods required by the interface named <b>
GraphIntfc01</b>.&nbsp; These methods are required to make it possible to use 
the program named <b>Graph03</b> to plot the results as shown in Figure 4.</p>
<p>I have discussed these methods on numerous previous occasions, and won't 
repeat that discussion here.</p>
<p><font color="#FF0000"><b>One more example, Dsp038</b></font></p>
<p>Figure 5 illustrates one more example of performing frequency filtering by 
modifying the complex spectrum and then performing an inverse transform on the 
modified spectrum.</p>
<p>While discussing the program named <b>Dsp037</b>, I told you that performing 
a different modification on the complex spectrum would result in a different 
waveform for the filtered impulse.&nbsp; The program named<b> Dsp038</b> applies 
a different modification to the complex spectrum, but is otherwise the same as
<b>Dsp037</b>.</p>
<blockquote>
	<p><i>(Because of the similarity of the two programs, I won't discuss the 
	code in <b>Dsp038</b>.&nbsp; You can view that code in Listing 19 near the 
	end of the lesson.)</i></p>
</blockquote>
<p>Figure 5 shows the output produced by the program named <b>Dsp038</b>. </p>


<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1485a04.jpg" width="409" height="431">

<b>Figure 5 Illustrates filtering in the frequency
         domain</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#FF0000"><b>Compare Figure 5 with Figure 4</b></font></p>
<p>The basic plotting format of Figure 5 is the same as Figure 4.</p>
<p>The first difference to note between the two figures is that I moved the 
impulse in the input time series in the topmost plot sixteen samples further to 
the right in <b>Dsp038</b>.</p>
<blockquote>
	<p><i>(This has no impact on the final result, which you can verify by 
	modifying the program to move the impulse to a different position and then 
	compiling and running the modified program.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Compare the bandwidth of the pass band</b></font></p>
<p>The second difference to note is shown in the modified amplitude spectrum in 
the fourth plot in the two figures.&nbsp; The bandwidth of the pass band is 
significantly narrower in Figure 5 than in Figure 4.&nbsp; Also, the pass band 
in Figure 4 extends all the way down to zero frequency, while Figure 5 
eliminates all energy below a frequency of three thirty-seconds of the sampling 
frequency.</p>
<p><font color="#FF0000"><b>Waveforms of filtered impulse</b></font></p>
<p>Finally, note the waveforms of the two filtered impulses.&nbsp; The overall 
amplitude of the filtered impulse in Figure 5 is less than in Figure 4, simply 
because it contains less total energy.&nbsp; In addition, the filtered impulse 
in Figure 5 is broader than the filtered impulse in Figure 4.&nbsp; This is 
because it has a narrower bandwidth.</p>
<blockquote>
	<p><i>(Pulses that are narrow in terms of time duration require a wider 
	bandwidth than pulses that have a longer time duration.&nbsp; The time 
	duration of the pulse tends to be inversely related to the bandwidth of the 
	pulse.)</i> </p>
</blockquote>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2>
<p>I encourage you to copy, compile, and run the programs provided in this 
lesson.&nbsp; Experiment with them, making changes and observing the results of your 
changes.</p>
<p>Create more complex experiments.&nbsp; For example, use more complex input 
time series when experimenting with frequency filtering.&nbsp; Apply different 
modifications to the complex spectrum when experimenting with frequency 
filtering.</p>
<p>Most of all enjoy yourself and learn something in the process.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>This lesson illustrates and explains forward and inverse Fourier 
transforms using both DFT and FFT algorithms.</p>
<p>The lesson also illustrates and 
explains the implementation of frequency filtering by modifying the complex 
spectrum in the frequency domain and then transforming the modified complex 
spectrum back into the time 
domain.</p>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program Listing</a>s</h2><p>
Complete listings of the programs discussed in this lesson follow.</p>
<p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
import java.util.*;

class Dsp035 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeDataOut = new double[len];
  int zero = 0;

  public Dsp035(){//constructor

    //Create the raw data pulses
    timeDataIn[0] = 0;
    timeDataIn[1] = 50;
    timeDataIn[2] = 75;
    timeDataIn[3] = 80;
    timeDataIn[4] = 75;
    timeDataIn[5] = 50;
    timeDataIn[6] = 25;
    timeDataIn[7] = 0;
    timeDataIn[8] = -25;
    timeDataIn[9] = -50;
    timeDataIn[10] = -75;
    timeDataIn[11] = -80;
    timeDataIn[12] = -60;
    timeDataIn[13] = -40;
    timeDataIn[14] = -26;
    timeDataIn[15] = -17;
    timeDataIn[16] = -11;
    timeDataIn[17] = -8;
    timeDataIn[18] = -5;
    timeDataIn[19] = -3;
    timeDataIn[20] = -2;
    timeDataIn[21] = -1;

    timeDataIn[240] = 80;
    timeDataIn[241] = 80;
    timeDataIn[242] = 80;
    timeDataIn[243] = 80;
    timeDataIn[244] = -80;
    timeDataIn[245] = -80;
    timeDataIn[246] = -80;
    timeDataIn[247] = -80;
    timeDataIn[248] = 80;
    timeDataIn[249] = 80;
    timeDataIn[250] = 80;
    timeDataIn[251] = 80;
    timeDataIn[252] = -80;
    timeDataIn[253] = -80;
    timeDataIn[254] = -80;
    timeDataIn[255] = -80;

    //Create raw data sinusoid
    for(int x = len/3;x < 3*len/4;x++){
      timeDataIn[x] = 80.0 * Math.sin(
                              2*pi*(x)*1.0/20.0);
    }//end for loop

    //Compute DFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplex01.transform(timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude,
                                     zero,
                                     0.0,
                                     1.0);

    //Compute inverse DFT of spectral data and
    // save output time data in output array
    InverseComplexToReal01.inverseTransform(
                    realSpect,
                    imagSpect,
                    timeDataOut);
  }//end constructor

  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.
  public int getNmbr(){
    //Return number of curves to plot.  Must not
    // exceed 5.
    return 5;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > timeDataIn.length-1){
      return 0;
    }else{
      return timeDataIn[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > realSpect.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*realSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > imagSpect.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*imagSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > magnitude.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*magnitude[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                   index > timeDataOut.length-1){
      return 0;
    }else{
      return timeDataOut[index];
    }//end else
  }//end function

}//end sample class Dsp035

<b>Listing 14</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File InverseComplexToReal01.java
Copyright 2004, R.G.Baldwin
Rev 5/24/04

Although there are more efficient ways to write
this program, it was written the way it was to
mimic the behavior of an FFT algorithm.
Therefore, the complex input must extend from
zero to the sampling frequency.

The static method named inverseTransform performs
a complex to real inverse discrete Fourier
transform returning a real result only.  In other
words, the method transforms a complex input to a
real output.

Does not implement the FFT algorithm. Implements
a straight-forward sampled-data version of the
continuous inverse Fourier transform defined
using integral calculus.

The parameters are:
double[] realIn - incoming real data
double[] imagIn - incoming imag data
double[] realOut - outgoing real data

Considers the data length to be
 realIn.length
Computational time increment is
 1.0/realIn.length

Returns a number of points equal to the data
length.

Assumes real input consists of positive
frequency points for a symmetric real frequency
function.  That is, the real input is assumed to
be symmetric about the folding frequency.  Does
not test this assumption.

Assumes imaginary input consists of positive
frequency points for an asymmetric imaginary
frequency function.  That is, the imaginary input
is assumed to be asymmetric about  the
folding frequency.  Does not test this
assumption.

The assumption of a symmetric real part and an
asymmetric imaginary part guarantees that the
imaginary output would be all zero if it were to
be computed.  Thus the program makes no attempt
to compute an imaginary output.

Tested using J2SE v1.4.2 under WinXP.
************************************************/

public class InverseComplexToReal01{

  public static void inverseTransform(
                               double[] realIn,
                               double[] imagIn,
                               double[] realOut){
    int dataLen = realIn.length;
    double delT = 1.0/realIn.length;
    double startTime = 0.0;
    //Outer loop interates on time domain
    // values.
    for(int i=0; i < dataLen;i++){
      double time = startTime + i*delT;
      double real = 0;
      //Inner loop iterates on frequency
      // domain values.
      for(int j=0; j < dataLen; j++){
        real += realIn[j]*
                      Math.cos(2*Math.PI*time*j)
             + imagIn[j]*
                      Math.sin(2*Math.PI*time*j);
      }//end inner loop
      realOut[i] = real;
    }//end outer loop
  }//end inverseTransform

}//end class InverseComplexToReal01

<b>Listing 15</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp036.java
Copyright 2004, R.G.Baldwin
Revised 5/24/04

Illustrates forward and inverse Fourier
 transforms using FFT algorithms.

Performs spectral analysis on a time series
consisting of pulses and a sinusoid.

Passes resulting real and complex parts to
inverse Fourier transform program to reconstruct
the original time series.

Run with Graph03.

Tested using J2SE 1.4.2 under WinXP.
************************************************/
import java.util.*;

class Dsp036 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeOut = new double[len];

  public Dsp036(){//constructor

    //Create the raw data pulses
    timeDataIn[0] = 0;
    timeDataIn[1] = 50;
    timeDataIn[2] = 75;
    timeDataIn[3] = 80;
    timeDataIn[4] = 75;
    timeDataIn[5] = 50;
    timeDataIn[6] = 25;
    timeDataIn[7] = 0;
    timeDataIn[8] = -25;
    timeDataIn[9] = -50;
    timeDataIn[10] = -75;
    timeDataIn[11] = -80;
    timeDataIn[12] = -60;
    timeDataIn[13] = -40;
    timeDataIn[14] = -26;
    timeDataIn[15] = -17;
    timeDataIn[16] = -11;
    timeDataIn[17] = -8;
    timeDataIn[18] = -5;
    timeDataIn[19] = -3;
    timeDataIn[20] = -2;
    timeDataIn[21] = -1;


    timeDataIn[240] = 80;
    timeDataIn[241] = 80;
    timeDataIn[242] = 80;
    timeDataIn[243] = 80;
    timeDataIn[244] = -80;
    timeDataIn[245] = -80;
    timeDataIn[246] = -80;
    timeDataIn[247] = -80;

    timeDataIn[248] = 80;
    timeDataIn[249] = 80;
    timeDataIn[250] = 80;
    timeDataIn[251] = 80;
    timeDataIn[252] = -80;
    timeDataIn[253] = -80;
    timeDataIn[254] = -80;
    timeDataIn[255] = -80;

    //Create raw data sinusoid
    for(int x = len/3;x < 3*len/4;x++){
      timeDataIn[x] = 80.0 * Math.sin(
                              2*pi*(x)*1.0/20.0);
    }//end for loop

    //Compute FFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplexFFT01.transform(
                                     timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude);

    //Compute inverse FFT of spectral data
    InverseComplexToRealFFT01.
                                inverseTransform(
                                     realSpect,
                                     imagSpect,
                                     timeOut);
  }//end constructor

  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.
  public int getNmbr(){
    //Return number of curves to plot.  Must not
    // exceed 5.
    return 5;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > timeDataIn.length-1){
      return 0;
    }else{
      return timeDataIn[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > realSpect.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*realSpect[index]/len;
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > imagSpect.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*imagSpect[index]/len;
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                    index > magnitude.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 5*magnitude[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                   index > timeOut.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return timeOut[index]/len;
    }//end else
  }//end function

}//end sample class Dsp036

<b>Listing 16</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File InverseComplexToRealFFT01.java
Copyright 2004, R.G.Baldwin
Rev 5/24/04

The static method named inverseTransform performs
a complex to real Fourier transform using a
complex-to-complex FFT algorithm.  A specific
parameter is passed to the FFT algorithm that
causes this to be an inverse Fourier transform.

See InverseComplexToReal01 for a version that
does not use an FFT algorithm but uses a DFT
algorithm instead.

Incoming parameters are:
  double[] realIn - incoming real data
  double[] imagIn - incoming imaginary data
  double[] realOut - outgoing real data

Requires spectral input data extending from zero
to the sampling frequency.

Assumes real input consists of positive
frequency points for a symmetric real frequency
function.  That is, the real input is assumed to
be symmetric about the folding frequency.  Does
not test this assumption.

Assumes imaginary input consists of positive
frequency points for an asymmetric imaginary
frequency function.  That is, the imaginary input
is assumed to be asymmetric about  the
folding frequency.  Does not test this
assumption.

The assumption of a symmetric real part and an
asymmetric imaginary part guarantees that the
imaginary output is all zeros.  Thus, the
program does not return an imaginary output.
Does not test the assumption that the imaginary
is all zeros.

CAUTION: THE INCOMING DATA LENGTH MUST BE A
POWER OF TWO. OTHERWISE, THIS PROGRAM WILL FAIL
TO RUN PROPERLY.

Returns a number of points equal to the incoming
data length.  Those points are uniformly
distributed beginning at zero.
************************************************/

public class InverseComplexToRealFFT01{

  public static void inverseTransform(
                             double[] realIn,
                             double[] imagIn,
                             double[] realOut){
    double pi = Math.PI;//for convenience
    int dataLen = realIn.length;
    double[] imagOut = new double[dataLen];
    //The complexToComplex FFT method does an
    // in-place transform causing the output
    // complex data to be stored in the arrays
    // containing the input complex data.
    // Therefore, it is necessary to copy the
    // input data into the output arrays before
    // passing them to the FFT algorithm.
    System.arraycopy(realIn,0,realOut,0,dataLen);
    System.arraycopy(imagIn,0,imagOut,0,dataLen);

    //Perform the spectral analysis.  The results
    // are stored in realOut and imagOut.  Note
    // that the -1 value for the first
    // parameter causes the transform to be an
    // inverse transform.  A +1 value would cause
    // it to be a forward transform.
    complexToComplex(-1,dataLen,realOut,imagOut);

  }//end inverseTransform method
  //-------------------------------------------//

  //This method computes a complex-to-complex
  // FFT.  The value of sign must be 1 for a
  // forward FFT and -1 for an inverse FFT.
  public static void complexToComplex(
                                  int sign,
                                  int len,
                                  double real[],
                                  double imag[]){
    double scale = 1.0;
    //Reorder the input data into reverse binary
    // order.
    int i,j;
    for (i=j=0; i < len; ++i) {
      if (j>=i) {
        double tempr = real[j]*scale;
        double tempi = imag[j]*scale;
        real[j] = real[i]*scale;
        imag[j] = imag[i]*scale;
        real[i] = tempr;
        imag[i] = tempi;
      }//end if
      int m = len/2;
      while (m>=1 && j>=m) {
        j -= m;
        m /= 2;
      }//end while loop
      j += m;
    }//end for loop

    //Input data has been reordered.
    int stage = 0;
    int maxSpectraForStage,stepSize;
    //Loop once for each stage in the spectral
    // recombination process.
    for(maxSpectraForStage = 1,
                stepSize = 2*maxSpectraForStage;
                maxSpectraForStage < len;
                maxSpectraForStage = stepSize,
                stepSize = 2*maxSpectraForStage){
      double deltaAngle =
                 sign*Math.PI/maxSpectraForStage;
      //Loop once for each individual spectra
      for (int spectraCnt = 0;
                 spectraCnt < maxSpectraForStage;
                 ++spectraCnt){
        double angle = spectraCnt*deltaAngle;
        double realCorrection = Math.cos(angle);
        double imagCorrection = Math.sin(angle);

        int right = 0;
        for (int left = spectraCnt;
                   left < len;left += stepSize){
          right = left + maxSpectraForStage;
          double tempReal =
                    realCorrection*real[right]
                    - imagCorrection*imag[right];
          double tempImag =
                    realCorrection*imag[right]
                    + imagCorrection*real[right];
          real[right] = real[left]-tempReal;
          imag[right] = imag[left]-tempImag;
          real[left] += tempReal;
          imag[left] += tempImag;
        }//end for loop
      }//end for loop for individual spectra
      maxSpectraForStage = stepSize;
    }//end for loop for stages
  }//end complexToComplex method

}//end class InverseComplexToRealFFT01

<b>Listing 17</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp037.java
Copyright 2004, R.G.Baldwin
Revised 5/24/04

Illustrates filtering in the frequency domain.
Performs FFT on an impulse.  Eliminates all
energy between one-sixth and five-sixths of the
sampling frequency by modifying the real and
imaginary parts of the FFT output.  Then performs
inverse FFT to produce the filtered impulse.

Run with Graph03.

Tested using J2SE 1.4.2 under WinXP.
************************************************/
import java.util.*;

class Dsp037 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeOut = new double[len];

  public Dsp037(){//constructor

    //Create the raw data pulse
    timeDataIn[32] = 90;

    //Compute FFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplexFFT01.transform(
                                     timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude);

    //Apply the frequency filter eliminating all
    // energy between one-sixth and five-sixths
    // of the sampling frequency by modifying the
    // real and imaginary parts of the spectrum.
    for(int cnt = len/6;cnt < 5*len/6;cnt++){
      realSpect[cnt] = 0.0;
      imagSpect[cnt] = 0.0;
    }//end for loop

    //Recompute the magnitude based on the
    // modified real and imaginary spectra.
    for(int cnt = 0;cnt < len;cnt++){
      magnitude[cnt] =
        (Math.sqrt(
           realSpect[cnt]*realSpect[cnt]
           + imagSpect[cnt]*imagSpect[cnt])/len);
    }//end for loop

    //Compute inverse FFT of modified spectral
    // data.
    InverseComplexToRealFFT01.inverseTransform(
                                       realSpect,
                                       imagSpect,
                                       timeOut);
  }//end constructor

  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.
  public int getNmbr(){
    //Return number of curves to plot.  Must not
    // exceed 5.
    return 5;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > timeDataIn.length-1){
      return 0;
    }else{
      return timeDataIn[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > realSpect.length-1){
      return 0;
    }else{
      return realSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > imagSpect.length-1){
      return 0;
    }else{
            return imagSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                    index > magnitude.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return len*magnitude[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                   index > timeOut.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 3.0*timeOut[index]/len;
    }//end else
  }//end function

}//end sample class Dsp037

<b>Listing 18</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp038.java
Copyright 2004, R.G.Baldwin
Revised 5/24/04

Illustrates filtering in the frequency domain.
Performs FFT on an impulse.  Modifies the
complex spectrum.  Then performs inverse FFT
to produce the filtered impulse.

Run with Graph03.

Tested using J2SE 1.4.2 under WinXP.
************************************************/
import java.util.*;

class Dsp038 implements GraphIntfc01{
  final double pi = Math.PI;

  int len = 256;

  double[] timeDataIn = new double[len];
  double[] realSpect = new double[len];
  double[] imagSpect = new double[len];
  double[] angle = new double[len];//unused
  double[] magnitude = new double[len];
  double[] timeOut = new double[len];

  public Dsp038(){//constructor

    //Create the raw data pulse
    timeDataIn[64] = 90;

    //Compute FFT of the time data and save it in
    // the output arrays.
    ForwardRealToComplexFFT01.transform(
                                     timeDataIn,
                                     realSpect,
                                     imagSpect,
                                     angle,
                                     magnitude);

    //Apply the frequency filter.
    for(int cnt = 0;cnt <= len/2;cnt++){
      if(cnt < 3*len/32){
        realSpect[cnt] = 0;
        imagSpect[cnt] = 0;
      }//end if

      if(cnt > 5*len/32){
        realSpect[cnt] = 0;
        imagSpect[cnt] = 0;
      }//end if

      //Fold complex spectral data
      if(cnt > 0){
        realSpect[len - cnt] = realSpect[cnt];
      }//end if
      if(cnt > 0){
        imagSpect[len - cnt] = -imagSpect[cnt];
      }//end if
    }//end for loop

    //Recompute the magnitude based on the
    // modified real and imaginary spectra.
    for(int cnt = 0;cnt < len;cnt++){
      magnitude[cnt] =
        (Math.sqrt(
           realSpect[cnt]*realSpect[cnt]
           + imagSpect[cnt]*imagSpect[cnt])/len);
    }//end for loop

    //Compute inverse FFT of modified spectral
    // data.
    InverseComplexToRealFFT01.inverseTransform(
                                       realSpect,
                                       imagSpect,
                                       timeOut);
  }//end constructor

  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.
  public int getNmbr(){
    //Return number of curves to plot.  Must not
    // exceed 5.
    return 5;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > timeDataIn.length-1){
      return 0;
    }else{
      return timeDataIn[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > realSpect.length-1){
      return 0;
    }else{
      return realSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > imagSpect.length-1){
      return 0;
    }else{
            return imagSpect[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                    index > magnitude.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return len*magnitude[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                   index > timeOut.length-1){
      return 0;
    }else{
      //scale for convenient viewing
      return 3.0*timeOut[index]/len;
    }//end else
  }//end function

}//end sample class Dsp038

<b>Listing 19</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p>&nbsp;</p>


<hr size="3" width="100%" align="center">    
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p>
     
<h4> <a name="About_the_author">About the author</a></h4><b>
<a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects, and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.dickbaldwin.com">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p>
     
<p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p>
     
<p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p>
     
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
  </p>
     
<p>-end- </p>
   </body>
</html>
