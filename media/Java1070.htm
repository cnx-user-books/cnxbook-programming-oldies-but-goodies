<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#999999" alink="#FF0000" lang="EN-US">
zz incomplete.&nbsp; Needs:
<br>Listing numbers to replace zz
<br>Editing for Parts 6, 7 &amp; 8
<br>Publication date
<br>Confirm correct img references
<br>Title:&nbsp; Instead of Part 1,2, etc, make titles read Concepts, GUI
Setup, Construction, Inheritance, Interfaces, Properties, Events, &amp;
Methods Refer to previous lessons by name
<br>Spell and grammer check
<br>Final edit.
<h2>
Swing from A to Z:&nbsp; Analyzing Swing<br>
Components, Part 6</h2>
<b>Published</b>&nbsp; zz zz
<br><b>By <a href="mailto:baldwin.richard@iname.com">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1070
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Sample Program">Sample Program</a></li>

<li>
<a href="#Interesting Code Fragments">Interesting Code Fragments</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This series of lessons entitled <i>Swing from A to Z</i>, discusses the
capabilities and features of Swing in quite a lot of detail.&nbsp; This
series is intended for those persons who need to understand Swing at a
detailed level.
<p>This is the sixth lesson in a miniseries discussing the use of introspection
for analyzing <b>Swing</b> components.&nbsp; The first lesson in this miniseries
was entitled <i>Swing from A to Z:&nbsp; Analyzing Swing Components, Part 1, Concepts</i>.&nbsp;
You will find&nbsp; links to all
of the lessons in the miniseries at the following <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">site</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Recommended supplementary reading</font></b>
<p>In an earlier lesson entitled <i>Alignment Properties and BoxLayout,
Part 1</i>, I recommended a list of Swing tutorials for you to study prior
to embarking on a study of this series of lessons.
<p>The lessons identified on that list will introduce you to the use of
Swing while avoiding much of the detail included in this series.
<p><b><font color="#FF0000">Where are the lessons located?</font></b>
<p>You will find those lessons published at <a href="http://gamelan.earthweb.com/dlink.index-jhtml.72.1082.-.43.jhtml">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes my lessons are difficult
to locate there.&nbsp; You will find a consolidated index at
<i>Baldwin's
Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a></i><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at Gamelan.com.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Streamlined Documentation</font></b>
<p><font color="#000000">The lessons in this miniseries discuss a very
useful Java program that supplements the Sun documentation.</font>
<p><font color="#000000">The program provides the following information
about Swing and AWT components:</font>
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<b><font color="#FF0000">Program output</font></b>
<p><font color="#000000">Figure 1 is a screen shot showing the program
output after you start the program and click the <b>OK</b> button.</font>
<center>
<p><img SRC="java1070a.gif" height=521 width=400>
<br><b><font color="#000000">Figure 1.&nbsp; Screen shot showing program
output.</font></b></center>

<p><font color="#000000">The various parts of this GUI have been explained
in the earlier lessons in this miniseries.</font>
<p><b><font color="#FF0000">The program code</font></b>
<p><font color="#000000">In the previous lessons, I have walked you through
the code for this program, up to, and including the code that gets and
displays the interface information in the upper-right pane.</font>
<p><font color="#000000">In this lesson, I will discuss the code that gets
and displays the sorted information on properties shown in the center-left
pane of Figure 1.</font>
<p><font color="#000000">In the previous lesson, I showed you how to use
a simple form of the sorting capability provided by the Java class libraries.&nbsp;
In this lesson, I will show you how to use a more sophisticated form of
that sorting capability.&nbsp; This will involve the use of an object instantiated
from a class that implements the <b>Comparator</b> interface.</font>
<p><font color="#000000">Subsequent lessons will explain other aspects
of the program.</font>
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
<b><font color="#FF0000">The Class class and the Introspector class</font></b>
<p><font color="#000000">Previous lessons explained the use of the <b>Class</b>
class and the <b>Introspector</b> class to achieve the objectives of this
program.</font>
<p><font color="#000000">This included a discussion of the <b>forName()</b>
and&nbsp; <b>getBeanInfo()</b> methods.</font>
<p><b><font color="#FF0000">Properties, events, and methods</font></b>
<p><font color="#000000">It was explained that an object of the interface
type <b>BeanInfo</b> can be used to obtain important information about
the properties, events, and methods of a target class.&nbsp; This lesson
will be primarily concerned with getting, sorting, and displaying the properties
of a target class.</font>
<center>
<h2>
<a NAME="Sample Program"></a><font color="#000000">Sample Program</font></h2></center>
A complete listing of this program, named <b>Introspect03</b> is provided
near the end of the lesson.&nbsp; It is provided here so that you can copy,
compile, and begin using it even before you have an opportunity to learn
how it works.
<center>
<h2>
<a NAME="Interesting Code Fragments"></a><font color="#000000">Interesting
Code Fragments</font></h2></center>
I will break this program down and discuss it in fragments.
<p><b><font color="#FF0000">The actionPerformed() method</font></b>
<p>The code in Listing zz is an abbreviated version of the <b>actionPerformed()</b>
method.&nbsp; Most of the code has been deleted because it is not germane
to this lesson.&nbsp; I discussed all of this code in an earlier lesson.&nbsp;
I am listing it here simply to refresh your memory.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006600">Class <b>targetClassObject</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());

</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000099">beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getBeanInfo</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>targetClassObject</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));

</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>doProperties();
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...


<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Getting a Class object</font></b>
<p>The code shown in green gets a <b>Class</b> object representing the
target class and refers to that object in the reference variable named
<b>targetClassObject</b>.
<p>The code shown in blue passes that reference, along with a reference
to the name of the ceiling class, to the method named <b>getBeanInfo()</b>.
<p><b><font color="#FF0000">Getting a BeanInfo object</font></b>
<p>The <b>getBeanInfo()</b> method returns a reference to an object instantiated
from a class that implements the <b>BeanInfo</b> interface.&nbsp; The reference
to the <b>BeanInfo</b> object is stored in the instance variable named
<b>beanInfo</b>.
<p>This object can then be used to obtain information about the properties,
events, and methods of the target class and its superclasses up to, but
not including, the ceiling class.
<p><b><font color="#FF0000">The doProperties() method</font></b>
<p>The method named <b>doProperties()</b> invoked by the <b>actionPerformed()</b>
method is the primary topic of this lesson.
<p>The purpose of the <b>doProperties()</b> method is to get, sort, and
display name and type information about the properties of the target class
and its superclasses, up to, but not including the ceiling class.
<p>This information is displayed in the left-center scroll pane of Figure
1.
<p><b><font color="#FF0000">Sorting is more difficult</font></b>
<p>If you take a look at the <b>PROPERTIES</b> pane in the left-center
of Figure 1, you will see that two pieces of information are&nbsp; displayed
for each property:
<ul>
<li>
The name of the property</li>

<li>
The type of the property</li>
</ul>
For example, the first property listed there is named <b>accessibleContext</b>,
and the type of that property is a class named <b>javax.accessibility.AccessibleContext</b>.
<p><b><font color="#FF0000">Sort on the name only</font></b>
<p>However, the sort is performed only on the name of the property, and
it is imperative that the sorting operation keeps the name and the type
of each property together.&nbsp; This required me to encapsulate the name
and type of each property into an object of a new class named <b>PropClass</b>,
ant then to sort the objects on the name of the property only.
<p><b><font color="#FF0000">More complex than sorting the interfaces</font></b>
<p>This caused the sorting operation for properties to be much more complicated
than was the sorting operation for interfaces discussed in the previous
lesson.
<p>For interfaces, the sorting operation was not very complicated.&nbsp;
The interface names were all encapsulated in objects of the <b>String</b>
class.&nbsp; All that was required was to use a version of the <b>sort()</b>
method of the <b>Arrays</b> class that already knew how to sort objects
of the <b>String</b> class in their <i>natural</i> order.
<p><b><font color="#FF0000">Need to sort PropClass objects</font></b>
<p>There is no version of the <b>sort()</b> method that inherently knows
how to sort objects of the <b>PropClass</b> without some help from me.&nbsp;
However, there is a version of the <b>sort()</b> method that can do the
job.&nbsp; That method is partially described as follows:
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td BGCOLOR="#66FFFF">
<pre><font face="Courier New,Courier">public static void <b>sort</b>(Object[] a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comparator c)

Sorts the specified array of objects&nbsp;
according to the order induced by the&nbsp;
specified comparator.

Parameters:
a - the array to be sorted.
c - the comparator to determine the&nbsp;
order of the array.</font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What does this mean?</font></b>
<p>Basically, this means that if I pass a reference to an object instantiated
from a class that implements the <b>Comparator</b> interface, the methods
of that object will be used to perform comparisons whenever comparisons
are required to execute the sorting algorithm.&nbsp; Of course, the methods
of the <b>Comparator</b> object must correctly compare two objects of my
<b>PropsClass</b>
class.
<p><b><font color="#FF0000">The Comparator interface</font></b>
<p>The <b>Comparator</b> interface declares the two methods shown in the
following box:
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td BGCOLOR="#66FFFF">
<pre><font face="Courier New,Courier">int <b>compare</b>(Object o1, Object o2)&nbsp;
Compares its two arguments for order.
Returns a negative integer, zero,&nbsp;
or a positive integer as the first
argument is less than, equal to, or
greater than the second.


boolean <b>equals</b>(Object obj)&nbsp;
Indicates whether some other object is
"equal to" this Comparator.</font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">I need a Comparator object</font></b>
<p>What I need to do is to define a class that implements the <b>Comparator</b>
interface.
<p>The <b>compare()</b> method defined in that class must be defined so
as to properly compare two objects of the <b>PropClass</b> class according
to my notion of properly ordered objects, and to return the negative, positive,
or zero value described above.
<p><b><font color="#FF0000">My notion of order</font></b>
<p>In this program, my notion is that the objects should be ordered according
to the names of the properties encapsulated in those objects, independent
of the case of the characters in the property names.
<p><i>(Although the Comparator interface also requires a definition of
the equals() method, there is nothing in this program that uses that method.&nbsp;
Therefore, I could define it as a dummy method.)</i>
<p><b><font color="#FF0000">The PropClass class</font></b>
<p>I am going to begin by discussing the <b>PropClass</b> class from which
I instantiate objects to encapsulate the name and type of each individual
property.&nbsp; The code in this class definition begins in Listing zz.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">class <b>PropClass</b> implements <b>Comparator</b>{
&nbsp; private String name;
&nbsp; private String type;
&nbsp;&nbsp;
&nbsp; public void <b>setName</b>(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String <b>getName</b>(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void <b>setType</b>(String type){
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String <b>toString</b>(){
&nbsp;&nbsp;&nbsp; return(name + "\n&nbsp; " + type);
&nbsp; }//end toString

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">An inner class</font></b>
<p>For convenience, the <b>PropClass</b> class was defined as a named inner
class of the controlling class.&nbsp; However, it could also have been
defined as a top-level class.
<p><b><font color="#FF0000">Implements Comparator</font></b>
<p><b>PropClass</b> implements the <b>Comparator</b> interface, and therefore
serves not only to encapsulate the name and type data for properties, but
also to serve as a <b>Comparator</b> object in the sorting process.
<p><b><font color="#FF0000">Plain vanilla code</font></b>
<p>The code in Listing zz above is totally plain vanilla.&nbsp; It consists
of instance variables for the name and type of a property, plus set and
get methods for the instance variables.
<p><i>(As a side note, these two instance variables along with their respective
set and get methods constitute properties of the PropClass class.)</i>
<p><b><font color="#FF0000">The overridden toString method</font></b>
<p>Listing zz above also contains an overridden <b>toString()</b> method.&nbsp;
This method returns a <b>String</b> containing name and type values in
the following format:
<p><b><tt>action</tt></b>
<br><b><tt>&nbsp; interface javax.swing.Action</tt></b>
<p><b><font color="#FF0000">The compare() method</font></b>
<p>The code in Listing zz is a little more interesting.&nbsp; This code
defines the <b>compare()</b> method that will be used by the sorting process
to arrange the objects in order on the basis of the property name. <i>(The
property type is ignored in this method, and therefore, is ignored in the
sorting process.)</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; public int <b>compare</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((PropClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().<b>compareTo</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">When is compare() called?</font></b>
<p>Whenever the sorting algorithm needs to compare two objects of the <b>PropClass</b>
class, it will call this <b>compare</b> method, passing references to the
two objects into the method.
<p><b><font color="#FF0000">Behavior of the compare() method</font></b>
<p>The <b>Compare</b> method gets the values stored in the <b>name</b>
instance variables of each of the objects.&nbsp; It converts both names
to uppercase characters, and then uses the <b>compareTo()</b> method of
the <b>String</b> class to compare the two names.
<p><b><font color="#FF0000">Behavior of the compareTo() method</font></b>
<p>According to Sun, the <b>compareTo()</b> method returns the value 0
if the two strings are lexicographically equal.&nbsp; It returns a value
less than 0 if the name value of <b>o1</b> is lexicographically less than
the name value of <b>o2</b>.&nbsp; Otherwise, it returns a value greater
than 0.
<p>That satisfies the requirements of the <b>compare()</b> method as defined
in the description of the <b>Comparator</b> interface above.
<p><b><font color="#FF0000">The equals() method</font></b>
<p>My definition of the <b>equals()</b> method is provided in Listing zz
below.
<p>As mentioned earlier, this method is required for any class that implements
<b>Comparator</b>.&nbsp;
However, it is not used in this program <i>(unless the sort() method uses
it, which I doubt)</i>.&nbsp; Therefore, I could have written it as a dummy
method returning either true or false.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)obj).getName());
&nbsp; }//end equals
}//end class PropClass

Listing zz</font></pre>
</td>
</tr>
</table>

<p>As written, the <b>equals()</b> method returns true of the name values
in the two objects are equal and returns false otherwise.
<br>&nbsp;
<p><b><font color="#FF0000">The doProperties() method</font></b>
<p>Now that you understand the definition of the <b>PropClass</b> class,
we can examine the behavior of the <b>doProperties()</b> method.
<p>The definition of the <b>doProperties()</b> method begins in Listing
zz, which declares and populates a reference variable of type <b>Vector</b>
named <b>propVector</b>.&nbsp; This <b>Vector</b> object will be used to
temporarily store objects of the <b>PropClass</b> discussed above.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; void <b>doProperties</b>(){
&nbsp;&nbsp;&nbsp; Vector <b>propVector</b> = new Vector();

Listing zz</font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The BeanInfo object</font></b>
<p>Recall that a <b>BeanInfo</b> object representing the target class and
the ceiling class was earlier stored in an instance variable named <b>beanInfo.</b>&nbsp;
The code in the <b>doProperties()</b> method uses this object to obtain
property information about the target class and its superclasses up to,
but not including the ceiling class.
<p><b><font color="#FF0000">PropertyDescriptor objects</font></b>
<p>The code in Listing zz invokes the <b>getPropertyDescriptors()</b> method
on <b>beanInfo</b> to get a reference to an array object containing references
to objects of type <b>PropertyDescriptor</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; PropertyDescriptor[] <b>propDescrip</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyDescriptors();

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>The reference to the array in Listing zz above is stored in a reference
variable named <b>propDescrip</b>.&nbsp; Each of the objects referred to
by the elements of the array describes one property of the target class
or one of its superclasses.
<p><b><font color="#FF0000">What is a PropertyDescriptor object good for?</font></b>
<p>Once you have a <b>PropertyDescriptor</b> object that describes a property,
there are about six different kinds of information that you can obtain
about the property by invoking various <b>get...()</b> methods on the object.
<p>In this program, I use only two of those methods to get the name and
type of each property.&nbsp; You might want to expand the program to get
and display some of the other kinds of information that is also available.
<p><b><font color="#FF0000">Getting and saving property data</font></b>
<p>The code in Listing zz uses a <b>for</b> loop to get and save the name
and type information for each property described by one of the <b>PropertyDescriptor</b>
objects referred to by the elements in the array object referred to by
<b>propDescrip</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; <b>for</b> (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropClass <b>propObj</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PropClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setName(propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getName</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setType("" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getPropertyType</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>propVector</b>.<b>add</b>(propObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Behavior of the loop code</font></b>
<p>The code for each iteration of the loop in Listing zz above begins by
instantiating a new object of the class <b>PropClass</b> described earlier
in this lesson.
<p>Then it invokes the <b>getName()</b> and <b>getType()</b> methods on
the <b>PropertyDescriptor</b> object referred to by an element in the array.&nbsp;
These two methods return the name and type of the property described by
that object.&nbsp; The name and type information for the property is stored
in the <b>PropClass</b> object representing that particular property.
<p>Then the <b>PropClass</b> object is added onto the end of the <b>Vector</b>
object referred to by <b>propVector</b>.
<p><b><font color="#FF0000">When the loop terminates ...</font></b>
<p>When the loop terminates, the <b>Vector</b> object referred to by <b>propVector</b>
contains one reference to a <b>PropClass</b> object for each property of
the target class and its superclasses up to, but not including the ceiling
class.
<p><b><font color="#FF0000">Convert to an array</font></b>
<p>The code in Listing zz below invokes the <b>toArray()</b> method on
the <b>Vector</b> object, which returns an array of type <b>Object</b>
containing all of the elements in the <b>Vector</b> in the correct order.&nbsp;
There is nothing new here.&nbsp; You saw this method being used in the
previous lesson.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Object[] propArray = propVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Sorting the array</font></b>
<p>The code in Listing zz below is new.&nbsp; This code uses a different
version of the <b>sort()</b> method than I have used in previous lessons.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Arrays.<b>sort</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propArray,<b>new PropClass()</b>);

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Two parameters required</font></b>
<p>The version of <b>sort()</b> used in Listing zz above requires two parameters.&nbsp;
The first parameter is a reference to an array object that is to be sorted.&nbsp;
That's not new.
<p><b><font color="#FF0000">What is the second parameter?</font></b>
<p>The second parameter must be a reference to an object instantiated from
a class that implements the <b>Comparator</b> interface.
<p>The implementation of that interface in that class must provide a concrete
definition of a method named <b>compare()</b>.
<p><b><font color="#FF0000">What is the required behavior of compare()?</font></b>
<p>The <b>compare()</b> method is invoked by the sort algorithm whenever
it needs to compare two objects to determine which is the <i>greater</i>
of the two.
<p>Therefore, the <b>compare()</b> method must make that comparison and
return a negative or positive value or zero, indicating if the two objects
are equal, and if not, which object is the <i>greater</i> of the two. <i>(I
discussed the compare() method in detail earlier in the lesson.)</i>
<p><b><font color="#FF0000">PropsClass implements Comparator</font></b>
<p>As you will recall, the <b>PropsClass</b> class implements the <b>Comparator</b>
interface.&nbsp; It provides a <b>compare()</b> method that compares two
objects of the class on the basis of the value of the property name, independent
of case.
<p>Therefore, the second parameter passed to the <b>sort()</b> method in
Listing zz above is a reference to an anonymous object of the <b>PropClass</b>
class.
<p><b><font color="#FF0000">Displaying the property information</font></b>
<p>The code in Listing zz uses a <b>for</b> loop, in conjunction with the
<b>toString()</b>
method of the <b>PropClass</b>, class to:
<ul>
<li>
Extract a <b>String</b> describing each property from the <b>Vector</b>
referred to by <b>propArray</b></li>

<li>
Append that information onto the information already in the <b>JTextArea</b>
shown at the center left in figure 1</li>
</ul>

<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append(propArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doProperties</font></pre>
</td>
</tr>
</table>

<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this and the previous lessons, I have introduced you to a program that
displays information about the following aspects of any Java class that
qualifies as a JavaBean component:
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<font color="#000000">I showed how the <b>actionPerformed()</b> method
of an action listener</font>
<br><font color="#000000">registered on the OK button in Figure 1 invokes
the following methods to obtain and display the sought-after information:</font>
<ul>
<li>
<font color="#000000">doInheritance()</font></li>

<li>
<font color="#000000">doInterfaces()</font></li>

<li>
<font color="#000000">doProperties()</font></li>

<li>
<font color="#000000">doEvents()</font></li>

<li>
<font color="#000000">doMethods()</font></li>
</ul>
<font color="#000000">In this lesson, I discussed the <b>doProperties()</b>
method in detail.&nbsp; In that discussion, I showed you how to:</font>
<ul>
<li>
<font color="#000000">Define a class named <b>PropClass</b> whose objects
encapsulate name and type information for properties.</font></li>

<li>
<font color="#000000">Implement the <b>Comparator</b> interface, making
it possible to instantiate a <b>Comparator</b> object that can be used
to control the sort order of objects of the <b>PropClass</b> class.</font></li>

<li>
<font color="#000000">Use the <b>sort()</b> method of the <b>Arrays</b>
class, in conjunction with a <b>Comparator</b> object to sort objects of
the <b>PropClass</b> class in order by property name independent of the
case of the characters in the name.</font></li>

<li>
<font color="#000000">Display the resulting information in the left-center
pane of Figure 1.</font></li>
</ul>

<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will explain how the method named <font color="#000000"><b>doEvents()</b>
obtains and displays information about the events of the target class,
in alphabetical order, in the right-center output pane in Figure 1.</font>
<p><font color="#000000">In a subsequent lesson, I will provide a similar
explanation for the <b>doMethods()</b> method.</font>
<br>&nbsp;
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing&nbsp;
zz</font>.
<br>&nbsp;
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">/*File Introspect03.java&nbsp;
Copyright 2000, R.G.Baldwin

Produces a GUI that displays&nbsp;
inheritance, interfaces, properties,
events, and methods about components,
or about any class that is a bean.

Requires JDK 1.3 or later.&nbsp; Otherwise,
must service the windowClosing event&nbsp;
to terminate the program.
Tested using JDK 1.3 under WinNT.&nbsp;&nbsp;
**************************************/
import java.io.*;
import java.beans.*;
import java.lang.reflect.*;
import java.util.*;
import java.awt.Color;
import java.awt.event.*;
import javax.swing.*;

public class Introspect03&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extends JFrame{
&nbsp; private JLabel errors =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JLabel("Errors appear here");
&nbsp; private JPanel outputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JPanel inputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JTextField targetClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JTextField ceilingClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JButton okButton =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("OK");
&nbsp;&nbsp;
&nbsp; private JTextArea inher = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INHERITANCE\n",8,17);
&nbsp; private JScrollPane inherPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(inher);
&nbsp; private JTextArea intfcs = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INTERFACES\n",8,17);
&nbsp; private JScrollPane intfcsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(intfcs);
&nbsp; private JTextArea props = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("PROPERTIES\n",8,17);
&nbsp; private JScrollPane propsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(props);
&nbsp; private JTextArea events =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("EVENTS\n",8,17);
&nbsp; private JScrollPane eventsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(events);
&nbsp; private JTextArea methods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("METHODS\n",8,17);
&nbsp; private JScrollPane methodsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(methods);
&nbsp;&nbsp;
&nbsp; private BeanInfo beanInfo;
&nbsp; private Vector intfcsVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Introspect03();

&nbsp; }//end main
&nbsp;&nbsp;
&nbsp; public Introspect03() {//constructor
&nbsp;&nbsp;&nbsp; //This require JDK 1.3 or later.
&nbsp;&nbsp;&nbsp; // Otherwise service windowClosing
&nbsp;&nbsp;&nbsp; // event to terminate the program.
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFrame.EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; outputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.green);
&nbsp;&nbsp;&nbsp; inputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.yellow);

&nbsp;&nbsp;&nbsp; outputPanel.add(inherPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(intfcsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(propsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(eventsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(methodsPane);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Set some default values
&nbsp;&nbsp;&nbsp; targetClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "javax.swing.JButton");
&nbsp;&nbsp;&nbsp; ceilingClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");

&nbsp;&nbsp;&nbsp; inputPanel.add(targetClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(ceilingClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(okButton);

&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors,"North");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputPanel,"Center");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputPanel,"South");
&nbsp;&nbsp;&nbsp; setResizable(false);
&nbsp;&nbsp;&nbsp; setSize(400,520);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2000, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner class to provide
&nbsp;&nbsp;&nbsp; // event handler for okButton
&nbsp;&nbsp;&nbsp; okButton.addActionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ActionListener(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Errors appear here");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INHERITANCE\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INTERFACES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PROPERTIES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "EVENTS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.setText("METHODS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class targetClassObject =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInheritance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInterfaces();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBeanInfo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClassObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doProperties();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doEvents();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doMethods();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(Exception ex){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex.toString());}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end actionPerformed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ActionListener
&nbsp;&nbsp;&nbsp;&nbsp; );//end addActionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInheritance()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ClassNotFoundException{
&nbsp;&nbsp;&nbsp; //Get and display inheritance
&nbsp;&nbsp;&nbsp; // hierarchy
&nbsp;&nbsp;&nbsp; Vector inherVector = new Vector();
&nbsp;&nbsp;&nbsp; String theClass = targetClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText();
&nbsp;&nbsp;&nbsp; Class theClassObj = null;
&nbsp;&nbsp;&nbsp; Class theSuperClass = null;
&nbsp;&nbsp;&nbsp; while(!(theClass.equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object"))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.add(theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassObj = Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theSuperClass = theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSuperclass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and save interfaces to be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // used later
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theClassObj.getInterfaces()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcsVector.add(theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInterfaces());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = theSuperClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName();
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; inherVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display vector contents in
&nbsp;&nbsp;&nbsp; // reverse order
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; inherVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((String)inherVector.elementAt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.size() - (i+1))));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInheritance
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInterfaces(){
&nbsp;&nbsp;&nbsp; Vector interfaceNameVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;&nbsp; //Interface information was stored
&nbsp;&nbsp;&nbsp; // in intfcsVector earlier.
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; intfcsVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class[] interfaceSet =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Class[])intfcsVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elementAt(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; interfaceSet.length;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceSet[j].getName());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop on j
&nbsp;&nbsp;&nbsp; }//end for loop on i

&nbsp;&nbsp;&nbsp; Object[] interfaceNameArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(interfaceNameArray);

&nbsp;&nbsp;&nbsp; if(interfaceNameArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; interfaceNameArray.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup interface names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInterfaces
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doProperties(){
&nbsp;&nbsp;&nbsp; Vector propVector = new Vector();
&nbsp;&nbsp;&nbsp; PropertyDescriptor[] propDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropClass propObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PropClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setName(propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setType("" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propVector.add(propObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] propArray = propVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propArray,new PropClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append(propArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doProperties
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doEvents(){
&nbsp;&nbsp;&nbsp; Vector eventVector = new Vector();
&nbsp;&nbsp;&nbsp; EventSetDescriptor[] evSetDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEventSetDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; evSetDescrip.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventClass eventObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EventClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setName(evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getListenerMethodDescriptors();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; methDescrip.length; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[j].getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventVector.add(eventObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] eventArray = eventVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventArray,new EventClass());

&nbsp;&nbsp;&nbsp; for(int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; eventArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append(eventArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doEvents
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doMethods(){
&nbsp;&nbsp;&nbsp; Vector methVector = new Vector();
&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.getMethodDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[i].getName());
&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Object[] methodArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(methodArray);

&nbsp;&nbsp;&nbsp; if(methodArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[0].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methodArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup method names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(methodArray[i].equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doMethods
//===================================//

//This inner class is used to
// encapsulate name and type
// information about properties.&nbsp; It
// also serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class PropClass implements Comparator{
&nbsp; private String name;
&nbsp; private String type;
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setType(String type){
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return(name + "\n&nbsp; " + type);
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((PropClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)obj).getName());
&nbsp; }//end equals
}//end class PropClass
//===================================//

//This inner class is used to
// encapsulate name and handler
// information about events.&nbsp; It also
// serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class EventClass implements Comparator{
&nbsp; private String name;
&nbsp; private Vector lstnrMethods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String lstnrMethod){
&nbsp;&nbsp;&nbsp; lstnrMethods.add(lstnrMethod);
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; String theString = name;

&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; lstnrMethods.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theString = theString + "\n&nbsp; " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstnrMethods.elementAt(i);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; return theString;
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((EventClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)obj).getName());
&nbsp; }//end equals
}//end EventClass inner class
&nbsp;&nbsp;
}//end controlling class Introspect03

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
