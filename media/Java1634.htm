<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                                                                 
  <meta http-equiv="Content-Language" content="en-us">
                                                                 
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                                                                 
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
                                                                 
  <meta name="ProgId" content="FrontPage.Editor.Document">
  <title>... in Java by Richard G Baldwin</title>
</head>
  <body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
                     
<h2>The Essence of OOP using Java, Instance Initializers</h2>
                                 
<p><i>Baldwin explains the use of instance initializers, static initializers
  in conjunction with constructors, and the initialization of ordinary instance
  variables. He explains and demonstrates the order in which they are executed.</i> 
 </p>
                                 
<p><b>Published:</b>&nbsp; August 19, 2003 <br>
                 <b>By <a href="mailto:baldwin@DickBaldwin.com">Richard G.
 Baldwin</a></b>        </p>
                                 
<p>Java Programming Notes # 1634 </p>
                                 
<ul>
                   <li><a href="#Preface">Preface</a></li>
                   <li><a href="#Preview">Preview</a></li>
                   <li><a href="#Discussion%20and%20Sample%20Programs">Discussion 
    and   Sample  Code</a></li>
                  <li><a href="#Run_the_Program">Run the Program<br>
                    </a></li>
                   <li><a href="#Summary">Summary</a></li>
                   <li><a href="#What%27s%20next">What's Next</a></li>
                  <li><a href="#Complete_program_listing">Complete Program
 Listing</a><br>
                  </li>
                                 
</ul>
                                 
<hr size="3" width="100%" align="center">                
<center>                 
<h2><a name="Preface"></a>Preface</h2>
                 </center>
                                 
<p>This series of lessons is designed to teach you about the essence of  Object-Oriented
Programming <i>(OOP) </i>using Java. </p>
                                 
<p>The first lesson in the series was entitled <a
 href="http://softwaredev.earthweb.com/java/article/0,,12082_935351,00.html"> 
        The Essence of OOP Using Java, Objects, and Encapsulation</a>.&nbsp; 
The previous lesson was entitled <a
 href="http://www.developer.com/java/other/article.php/2238491">The Essence
of OOP using Java, Static Initializer Blocks</a>.<!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--> 
<!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--> 
   <!-- Advanced Placement Study Guide will be posted on both Intro and Advanced--></p>
                                 
<p>You may find it useful to open another copy of this lesson in a separate
         browser window.&nbsp; That will make it easier for you to scroll
back     and   forth  among the different figures and listings while you
are reading     about them. </p>
                                 
<p>For further reading, see my extensive collection of online Java tutorials
        at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.
 A  consolidated      index is available at <font color="#000000"> <a
 href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font> </p>
                                 
<center>                 
<h2><a name="Preview"></a><font color="#000000">Preview</font></h2>
                 </center>
                                 
<p><font color="#ff0000"><b>Proper initialization is important</b></font><br>
           </p>
                     
<p>As I mentioned in the previous lesson in this series, proper initialization 
    of variables is an important aspect of programming.  &nbsp; Unlike other 
   programming languages, it is not possible to write a Java  program in which
   the variables are accidentally initialized with the garbage left over
 in memory from the programs that previously ran in the computer.<br>
           </p>
                     
<p><font color="#ff0000"><b>Automatic initialization to default values</b></font><br>
              </p>
                           
<p>Instance variables and class <i>(static)</i> variables are automatically 
    initialized   to standard default values if you fail to purposely initialize 
    them.&nbsp; Although local variables are not automatically initialized, 
    you cannot compile a program  that fails to either initialize a local 
variable    or assign a value to that  local variable before it is used.<br>
              </p>
                           
<p>Thus, Java programmers are prevented from committing the cardinal sin of
 allowing their variables to be initialized with random garbage through programming
negligence.<br>
           </p>
                     
<p><font color="#ff0000"><b>Initialization during declaration</b></font><br>
              </p>
                           
<p>You should already know that you can initialize instance variables  and 
     class variables when you declare them, by including an initialization 
  expression   in the variable declaration statement.&nbsp; Figure 1 shows 
 an  example of  a primitive instance variable named <b>simpleInitTime</b> 
 that is purposely   initialized  to a <b>long</b> value obtained by invoking 
 a static method of the <b>Init02 </b>class named <b>relTime</b>.&nbsp; <i>(You 
  will learn more about this method later.)</i><br>
         </p>
                 
<p>       </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  long simpleInitTime = Init02.relTime();</pre>
                                                                        
                                                      
      <pre><b>Figure 1</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
             <br>
         While the expression in Figure 1 is a little complex, it is still
 just   an  expression and is perfectly suitable for use in initializing
an  instance   variable when it is declared.<br>
                                          
<p><font color="#ff0000"><b>Constructor</b></font><br>
            </p>
                       
<p>What if your initialization requirements are more complex than can be
satisfied  with a single initialization expression?&nbsp; You should already
know that  you can write one or more overloaded constructors to purposely
initialize all instance variables when an object is instantiated from the
class.&nbsp; The code in a constructor  can be as complex as you need it
to be.<br>
           </p>
                     
<p><font color="#ff0000"><b>Not all classes allow constructors</b></font><br>
           </p>
                     
<p>What you may not know, however,  is that you cannot always write a constructor 
    for a class when you define it.&nbsp; For example, anonymous classes, 
which    we will study in a subsequent lesson, do not allow the definition 
of a constructor.<br>
         </p>
                 
<p>However, even anonymous classes allow you to write <i>instance initializer 
    blocks</i> when you define the class.&nbsp; The code in an instance initializer 
    block, which can also be quite complex, is executed when an object is 
instantiated    from the class.<br>
         </p>
                 
<p><font color="#ff0000"><b>Not as powerful as a constructor</b></font></p>
                 
<p>You can write any number of instance initializer blocks in your class definition.&nbsp;
However, unlike constructors, instance initializer blocks do not receive
parameters.&nbsp; Therefore, they are less powerful than constructors.&nbsp; 
In terms of power, instance initializer blocks fall between simple initialization
 expressions <i>(such as that shown in Figure 1)</i> and constructors.&nbsp; 
Because they can execute complex code, they are more powerful than simple 
initialization expressions.&nbsp; Because they cannot receive parameters, 
they are less powerful than constructors.<br>
         </p>
                 
<p><font color="#ff0000"><b>Similar to noarg constructors</b></font><br>
         </p>
                 
<p>An instance initializer block is similar to a constructor that doesn't
 receive   any parameters, except that you can write any number of instance
 initializer   blocks into your class definition, and you can only write
one  <i>noarg </i>constructor   in your class definition.<br>
         </p>
                 
<p><font color="#ff0000"><b>The order of execution</b></font><br>
         </p>
                 
<p>The code in an instance initializer block is executed after the constructor 
    for the superclass is executed, and before the constructor for the class 
   to which the initializer belongs is executed.<br>
         </p>
                 
<p>If the class definition contains a combination of instance initializer 
    blocks in combination with the declaration of instance variables with 
initialization    expressions, the code that comprises those items is executed 
in the order    in which it appears in the class definition.<br>
         </p>
                 
<p>The order of execution of instance initializers in combination with instance 
    variable initializations, constructors, and static initializer blocks 
will    be illustrated in the sample program that I will discuss later in 
this lesson.<br>
         </p>
                 
<p><font color="#ff0000"><b>What does Flanagan have to say</b></font>?<br>
         </p>
                 
<p>Here is how one of my favorite authors, David Flanagan of <u>Java in a
 Nutshell</u> fame, summarizes the situation:<br>
         </p>
                 
<blockquote>                           
  <p><i>"An instance initializer is simply a block of code inside curly braces 
    that is embedded in a class definition, where a field or method definition 
    normally appears.&nbsp; A class (any class -- not just anonymous classes) 
    can have any number of instance initializers.&nbsp; The instance initializers 
    and any variable initializers that appear in field definitions for the 
 class   are executed in the order they appear in the Java source code.&nbsp; 
These     initializers are automatically run after the superclass constructor 
has   returned  but before the constructor, if any, of the current class runs."</i><br>
           </p>
         </blockquote>
                 
<p><font color="#ff0000"><b>Why do we need instance initializers?</b></font><br>
    </p>
       
<p>Flanagan&nbsp;goes on to explain the value of instance initializers, not 
only     for anonymous classes, but also for non-anonymous classes.&nbsp; 
According     to Flanagan, <br>
         </p>
                 
<blockquote>                           
  <p><i>"Instance initializers allow you to initialize an object's fields 
    near the definition of those fields, rather than deferring that initialization 
    to a constructor defined further away in the class.&nbsp; Used in this
  way, they can sometimes   improve code readability."</i><br>
           </p>
         </blockquote>
                          
<p>The sample program that I will discuss in the next section will illustrate
       many aspects of instance initializers in combination with static initializer 
    blocks, constructors, and simple instance variable initializations.</p>
                           
<blockquote>         </blockquote>
                                    
<center>                 
<h2><a name="Discussion and Sample Programs"></a><font color="#000000"> Discussion
        and Sample Code</font></h2>
                 </center>
                                 
<p>I will discuss and explain a Java program named <b>Init02</b> in this lesson.&nbsp;
<i>(A complete listing of the program is provided in Listing 15 near the
end of the lesson.)</i> &nbsp;As mentioned above, this program illustrates
many aspects of instance initializers in combination with static initializer
blocks, constructors,   and simple instance variable initializations.<br>
         </p>
                 
<p><font color="#ff0000"><b>Description of the program</b></font><br>
         </p>
    Instance initializers behave much like <i>noarg </i>constructors.&nbsp; 
They are particularly  useful for anonymous classes, which are not allowed 
to  define any constructors,  even those that take no arguments.&nbsp; However,
   the syntax for anonymous  classes, even in the absence of instance initializers,
   is very cryptic.  &nbsp;Therefore, I decided to explain and illustrate
instance   initializers  in the context of ordinary top-level classes rather
than to  combine that  explanation with the explanation of anonymous classes
in a subsequent  lesson.<br>
       <br>
       <font color="#ff0000"><b>The class hierarchy</b></font><br>
       <br>
       This program defines a class named <b>B</b> that extends a class named 
  <b>A</b>.  &nbsp;Parameterized constructors are used in both <b>A</b> and 
  <b>B</b> to  instantiate an object of the class named <b>B</b>.  &nbsp;<br>
       <br>
       <font color="#ff0000"><b>The base time is recorded</b></font><br>
       <br>
       The controlling class defines and initializes a static variable containing 
   the time that the program starts running in milliseconds relative to&nbsp;00:00:00
  GMT, Jan 1, 1970.   This value is used as the base for computing time intervals
  later as the execution of the program progresses.<br>
       <br>
       The times that are computed and displayed later are in milliseconds
 relative   to the time at which the program started running.<br>
       <br>
       <font color="#ff0000"><b>The class loading process</b></font><br>
       <br>
       Static initializers are defined in both <b>A</b> and <b>B</b> to display 
   the time that the two classes are loaded and the order in which they are 
  loaded.&nbsp; You will see that both classes are loaded when an attempt 
is  made to instantiate an object of the subclass <b>B</b>.&nbsp; You will 
also  see that the superclass is loaded before the subclass is loaded, and 
both are loaded before the object is instantiated.<br>
       <br>
       <font color="#ff0000"><b>An initialized instance variable</b></font><br>
       <br>
       An instance variable is defined in the class named <b>B</b> and is 
initialized    <i>(using a simple initialization expression)</i> with the 
time in milliseconds    that the variable is initialized.  &nbsp;In addition, 
two separate instance    initializers are defined in the class named <b>B</b> 
that perform initialization    after the constructor for <b>A</b> completes 
execution and before the constructor    for <b>B</b> begins execution.<br>
       <br>
    In terms of physical location, the instance variable mentioned above
follows  the  first of the two instance initializers and appears   before
the second  instance initializer in the class definition.<br>
       <br>
       <font color="#ff0000"><b>The order of execution</b></font><br>
       <br>
       The first of the two instance initializers executes before the instance
   variable is initialized.  The second of the two initializers executes
after    the instance variable is initialized, demonstrating that initialization
 based  on simple  initialization expressions and instance initializers occurs
 in  the order that the code appears in the class definition.<br>
       <br>
       <font color="#ff0000"><b>Initialization time is displayed</b></font><br>
       <br>
       The two constructors <i>(for classes <b>A</b> and <b>B</b>)</i> and
 the two initializers each display time information   when they are executed
 to show the order in which the constructors and the   initializers are executed.<br>
       <br>
       <font color="#ff0000"><b>Two separate objects</b></font><br>
       <br>
       Two separate instances <i>(objects)</i> of the class named <b>B</b>
 are created, showing  not only the order in which the instance initializers
 and the constructors  are  executed, but also showing that the static initializers 
 are executed  <i>one time only</i> when the classes are first loaded.<br>
       <br>
       <font color="#ff0000"><b>Display values of instance variables</b></font><br>
       <br>
       Each time an object of the class named <b>B</b> is instantiated, an
 instance   method of the class is invoked to display the values of the instance
 variables   initialized during the process of instantiating the object<b></b>.<br>
       <br>
       <font color="#ff0000"><b>One-hundred millisecond delays</b></font><br>
       <br>
   Several one-hundred millisecond time delays are purposely inserted at
strategic   points  within the program to force the time intervals between
the different   steps in the program to be measurable.&nbsp; Otherwise, the
time intervals   between steps would be so small that it would not be possible
to distinguish   between them on the basis of time recorded in milliseconds.
       
<p>  </p>
                 
<p><font color="#ff0000"><b>Will discuss in fragments</b></font><br>
         </p>
                 
<p>I will discuss the program code in fragments.&nbsp; In discussing the
fragments, I will present much of the code in the order that it is executed,
which is not necessarily the same order that the code appears in the program.</p>
             
<p>As mentioned earlier, a complete listing of  the  program can be viewed 
 in Listing 15 near the   end of the lesson.<br>
              </p>
                           
<p><font color="#ff0000"><b>Two utility methods</b></font><br>
         </p>
                 
<p>I will begin by presenting two <b>static</b> utility methods that are used
 to simplify the code in the body of the program.&nbsp; Both of these&nbsp;methods 
 are defined in the controlling class named <b>Init02</b>.<br>
      </p>
           
<p><font color="#ff0000"><b>Relative time in milliseconds</b></font><br>
      </p>
           
<p>The utility method named <b>relTime</b>, shown in Listing 1, is used to
  compute and return the current time in milliseconds relative to a time
value   stored in a <b>static</b> variable of the controlling class named
<b>baseTime</b>.    &nbsp;As you will see later, <b>baseTime</b> contains
the time that the  program  started running.&nbsp; Thus, each time this method
is called, it  returns the  current time relative to the time that the program
started running.<br>
         </p>
                 
<p> </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  static long <b>relTime</b>(){<br>    return ((new Date().getTime()) - baseTime);<br>  }//end printTime<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                    <font color="#000000"><br>
      I relegated this code to a utility method simply due to the length
and   complexity  of the expression, and the large number of times that the
relative   time is  needed throughout the program.<br>
      <br>
      <font color="#ff0000"><b>Insert a delay</b></font><br>
      <br>
      The utility method shown in Listing 2 causes the current thread to
sleep    for one-hundred milliseconds.&nbsp; Thus, each time this method
is called,    it inserts a one-hundred millisecond delay in the execution
of the program</font>.<br>
                    
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  static void <b>delay</b>(){<br>    try{<br>      Thread.currentThread().sleep(100);<br>    }catch(Exception e){e.printStackTrace();}<br>  }//end delay<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
      This method is also called numerous times throughout the program.&nbsp; 
Once  again, therefore, I relegated this code to a utility method to simplify 
the  code in the body of the program.<br>
      <br>
      <font color="#ff0000"><b>Establish the start time</b></font><br>
      <br>
      Listing 3 shows the beginning of the controlling class named <b>Init02</b>,
   including the declaration and initialization of the class variable named
  <b>baseTime</b>. </font><font color="#000000"><br>
            </font>              
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>public class <b>Init02</b>{<br>  static long <b>baseTime </b>= new Date().getTime();<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
      According to the Sun documentation, the <b>getTime</b> method of the
 <b>Date </b>class in Listing  3<br>
      </font>      
<blockquote><font color="#000000"><i>"</i></font><i>Returns the number of
   milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date
   object.</i><font color="#000000"><i>"</i></font><br>
      </blockquote>
      <font color="#000000">Thus, this variable will contains the time in 
milliseconds   that the class named <b>Init02</b> is loaded, which is also 
the time that   the program starts running.&nbsp; This time will serve as 
the base time against  which various time intervals will be computed during 
the running of the program.<br>
      <br>
      <font color="#ff0000"><b>The main method</b></font><br>
      <br>
      The code in Listing 4 shows the beginning of the <b>main</b> method,
 which   displays the current time relative to the start time, and instantiates
 a  new object of the class named <b>B</b>.&nbsp; In addition, the code in
 Listing   4 invokes the method named <b>showData</b> on the new object.&nbsp; 
The <b>showData</b>  method displays the values stored in several instance 
values as various initialization  steps are completed during the instantiation 
of the object.</font>              
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  public static void <b>main</b>(String[] args){<br><br>    System.out.println("Instantiate first obj: "<br>                                   + <b>relTime</b>());<br><br>    new B("Construct 1").<b>showData</b>();<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
   <font color="#ff0000"><b>The output</b></font><br>
   <br>
   As you have probably already guessed, the print statement in Listing 4 
produces  the output shown in Figure 2.&nbsp; In other words, there was less 
than one   millisecond of elapsed time between the initialization of the <b>static</b>
  variable named <b>baseTime</b> and the invocation of the <b>relTime</b>
method  in Listing 4.</font>              
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Instantiate first obj: 0</pre>
                                                                        
                                                      
      <pre><b>Figure 2</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
      <font color="#ff0000"><b>Load classes A and B</b></font><br>
      <br>
      The instantiation of the new object in Listing 4 triggers a whole chain 
  of events.&nbsp; I will discuss those events in the sequence in which they 
 occur in the paragraphs  that follow.&nbsp; The first pair of interesting 
 events is the loading of  the classes named <b>A</b> and <b>B</b>.<font
 color="#000000"><font color="#ff0000"><b><br>
      <br>
      What does it mean to say that a class is loaded?</b></font><br>
           <br>
      As I explained in a previous lesson, I can't provide  a description 
of  exactly  what happens from a technical   viewpoint.&nbsp; However, I can
tell  you  what seems to happen from a functional viewpoint.<br>
           <br>
           Functionally,  an object of the class whose name is <b>Class</b> 
 is  created   and saved in  memory.&nbsp; This object represents the class 
 that  is being   loaded <i>(in  this case, two classes named <b>A</b> and 
 <b>B</b>  are loaded, so two separate <b>Class </b>objects are created).</i>&nbsp;
  From that  point forward, all static members of the class are available
to  the program  by referring to the name of the class and the name of the
member.&nbsp;   Other   information about  the class is also available by
invoking methods, such as the method named </font><b>getSuperclass</b>,<font
 color="#000000">   on a reference  to the <b>Class</b>  object.</font><br>
      <br>
      As you will see, when an attempt is made to instantiate an object of
 the   subclass named <b>B</b>, that class and its superclass named <b>A</b>
 are   both loaded.&nbsp; Furthermore, the superclass named <b>A</b> is loaded
 first.  &nbsp;The loading of both classes takes place before the other steps
 required  to instantiate the object take place.<font color="#000000"><br>
      <br>
      <font color="#ff0000"><b>A static initializer in the class named A</b></font><br>
      <br>
      Listing 5 shows the beginning of the class named <b>A</b>.&nbsp; The
 code   in Listing 5 declares an instance variable named <b>aXstrTime</b>,
 which  will be used later to record the time that the constructor for the
 class named <b>A</b> is executed.&nbsp; More important for this part of
the  discussion,   however, is the static initializer shown in Listing 5.</font><font
 color="#000000">      </font>              
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>class <b>A</b>{<br>  long aXstrTime;<br><br><b>  static{//This is a static initializer.<br>    System.out.println("Class A loaded: " +<br>                               Init02.relTime());<br>  }//End static initializer</b><br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
      You will recall from the previous lesson on static initializers that
 they   execute <i>one time only</i> when the class is loaded.&nbsp; The
static  initializer  in Listing 5 prints a message showing the time that
the class  named <b>A</b>  is loaded.<br>
      <br>
      <font color="#ff0000"><b>Class A load time</b></font><br>
      <br>
      On my machine the code in Listing 5 produced the output shown in Figure
   3.&nbsp; Presumably, the ten-millisecond delay between the start of the
  program and the point in time that the class named <b>A</b> was loaded
was   due primarily to the time required for the program to find the class
file  on the disk and to load it into memory.&nbsp; Your system may produce
a different  result depending on the speed of your computer.</font>     
        
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Class A loaded: 10</pre>
                                                                        
                                                      
      <pre><b>Figure 3</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
      <font color="#ff0000"><b>A static initializer in the class named B</b></font><br>
      <br>
      Listing 6 shows the beginning of the class named <b>B</b>.&nbsp; The
 code   in Listing 6 declares three instance variables, which will be used
 later  to record the time that the constructor and the instance initializers
 are  executed.&nbsp; More important for this part of the discussion, however,
 is the static initializer shown in Listing 6.<font color="#000000"><br>
            </font>              
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>class <b>B extends A</b>{<br>  long bXstrTime;<br>  long init1Time;<br>  long init2Time;<br><br><b>  static{//This is a static initializer.<br>    Init02.delay();<br><br>    System.out.println("Class B loaded: " +<br>                        Init02.relTime() + "\n");<br>  }//End static initializer</b><br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
   <font color="#ff0000"><b>The output</b></font><br>
   <br>
   The static initializer in Listing 6 purposely inserts a one-hundred millisecond
   delay and then prints the time that it finishes executing.&nbsp; This
is   the time that the class named <b>B</b> finishes loading.</font>    
         
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Class B loaded: 110</pre>
                                                                        
                                                      
      <pre><b>Figure 4</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
      Figure 4 shows that the class named <b>B</b> was loaded immediately 
following  the loading of the class  named <b>A</b>.<br>
      <br>
      <font color="#ff0000"><b>Create the new object of the class named B</b></font><br>
      <br>
      After the classes are loaded, the system proceeds to create the new 
instance   of the class named <b>B</b>.&nbsp; You should recall however that 
objects   are actually created beginning with the contribution from the class 
named   <b>Object</b>, and proceeding down the inheritance hierarchy to the 
class   from which the object is actually being instantiated.&nbsp; Thus, 
the next   identifiable significant event is the execution of the constructor 
for the class named <b>A</b>, which is the superclass of the class named <b>B</b>.
 &nbsp;<i>(Nothing in the program makes it possible for us to identify the
 construction of that portion of the object attributable to the superclass 
 named <b>Object</b>.)</i><br>
      <br>
   <font color="#ff0000"><b>The constructor for the class named A</b></font><br>
   <br>
   Listing 7 shows the constructor for the class named <b>A</b>.&nbsp; The
  code in the constructor purposely inserts a one-hundred millisecond delay,
  and then gets and saves the time that the constructor is executed.&nbsp; 
<i>(The   time is saved in the instance variable named <b>aXstrTime</b>, which
was  declared in Listing 5 earlier.)</i><font color="#000000"><br>
            </font>              
<p> </p>
                             
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                      <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  A(String str){//constructor<br><br>    Init02.delay();<br><br>    aXstrTime = Init02.relTime();<br>    System.out.println(str + "A:  " + aXstrTime);<br>  }//end constructor for A<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                      <font color="#000000"><br>
      Then the code in the constructor prints that time, producing the output 
  shown in Figure 5.</font><font color="#000000">      </font>           
  
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Construct 1A:  210</pre>
                                                                        
                                                      
      <pre><b>Figure 5</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
   <font color="#000000"> The important point here is that the constructor
  for the superclass is executed after the classes named <b>A</b> and <b>B
 </b>are loaded, but before the instance initializers for the subclass  named
 <b>B</b> are executed.</font><font color="#ff0000"><b><br>
   <br>
   Instance initializers in the subclass named B</b></font><br>
      <br>
     If you examine Listing 15 near the end of the lesson you will see that
  the class named <b>B</b> contains two separate instance initializers, which
  are physically separated by an ordinary instance variable declaration <i>(with 
  initialization)</i> and a constructor.&nbsp; As you will see in the discussion 
  that follows, the execution of the first instance initializer follows the 
  execution of the constructor for the superclass named <b>A</b> shown in 
Listing  7.<br>
      <br>
      Then the initialization of the ordinary instance variable takes place,
  following the execution of the first instance initializer.&nbsp; This is
 followed by the execution of the second instance initializer.<br>
      <br>
     Despite their physical placement in the code, the execution of both
instance   initializers and the initialization of the ordinary instance variable
all   take place before the constructor for the class named <b>B</b> is executed.<br>
      <br>
     <font color="#ff0000"><b>The first instance initializer</b></font><br>
      <br>
     The first instance initializer is shown in Listing 8.&nbsp; Once again, 
as described by David Flanagan, <br>
         
<blockquote>"<i>An instance initializer is simply a block of code inside curly
braces   that is embedded in a class definition, where a field or method definition
  normally appears.</i> ... <i>The instance initializers   and any variable
initializers that appear in field definitions for the class   are executed
in the order they appear in the Java source code.&nbsp; These    initializers
are automatically run after the superclass constructor has  returned  but
before the constructor, if any, of the current class runs.</i>"<font
 color="#000000"><br>
            </font></blockquote>
                 
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  {//This is an instance initializer<br>    Init02.delay();<br><br>    init1Time = Init02.relTime();<br><br>    System.out.println("Initializer-1: " +<br>                                      init1Time);<br><br>    Init02.delay();<br>  }//end instance initializer<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
     <font color="#ff0000"><b>Insert a delay<br>
   <br>
   </b></font></font><font color="#000000">The code in the instance initializer 
 in Listing 8  begins by inserting a one-hundred millisecond delay to force 
 the time interval  between the execution of the constructor for the class 
 named <b>A</b> and  </font><font color="#000000">the execution of the instance 
 initializer</font><font color="#000000"> to be distinguishable.</font><br>
   <font color="#000000"><font color="#ff0000"><b><br>
   Get, save, and display the relative time</b></font><br>
     <br>
     After sleeping for one-hundred milliseconds, the code in the initializer 
  gets and saves the current time relative to the start of the program.<br>
     <br>
     Then the code in the initializer displays that time, producing the output 
  shown in Figure 6.</font><br>
                   
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Initializer-1: 310</pre>
                                                                        
                                                      
      <pre><b>Figure 6</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
   If you compare Figure 6 with Figure 5 showing the time that the constructor 
 for  the class named <b>A</b> was executed, you will see that the printout 
  produced by the initializer followed the printout produced by the constructor 
  by the one-hundred millisecond delay introduced at the beginning of the 
initializer.  &nbsp;This confirms that the first initializer in the class 
named <b>B</b>  was executed following the execution of the constructor for 
the superclass  named <b>A</b>.<br>
     <br>
     <font color="#ff0000"><b>Insert another time delay</b></font><br>
     <br>
     Finally the instance initializer shown in Listing 8 inserts an additional 
  one-hundred millisecond delay.&nbsp; This makes it possible to distinguish 
 the time  that the ordinary instance variable <i>(to be discussed next)</i> 
 was initialized from the time that the print statement in the first instance
 initializer was executed.<br>
     <br>
     <font color="#ff0000"><b>An ordinary instance variable</b></font><br>
     <br>
     Listing 9 shows the declaration and initialization of an ordinary instance 
  variable named <b>simpleInitTime</b>.&nbsp; Recall that the physical location 
 of this  variable declaration is after the first instance initializer and 
 before  the constructor and the second instance initializer.<br>
                   
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  long simpleInitTime = Init02.relTime();<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
     Although the code in Listing 9 doesn't display the time of initialization, 
  code later in the program causes the value stored in the variable named 
<b>simpleInitTime</b>  to be displayed, producing the output shown in Figure 
7.</font>              
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>class B simple init: 410</pre>
                                                                        
                                                      
      <pre><b>Figure 7</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
     As you can see from the relative time shown in Figure 7, the instance 
  variable was initialized immediately following completion of execution of
  the first instance initializer shown in Listing 8 <i>(compare Figure 7
with Figure 6).</i><br>
     <br>
     <font color="#ff0000"><b>The second instance initializer</b></font><br>
     <br>
     An examination of Listing 15 near the end of the lesson shows that the
 class  named <b>B</b> contains a second instance initializer, separated
from  the  first instance initializer by an ordinary instance variable declaration
 and a constructor.  &nbsp;The second instance initializer is shown in Listing
 10.<br>
                   
<p> </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  {//This is another instance initializer<br><br>    Init02.delay();<br><br>    init2Time = Init02.relTime();<br><br>    System.out.println("Initializer-2: " +<br>                                      init2Time);<br>  }//end instance initializer<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                     <font color="#000000"><br>
   <font color="#ff0000"><b>Insert a delay</b></font><br>
   <br>
   This initializer begins by inserting a one-hundred millisecond delay.&nbsp; 
Then   it gets, saves, and displays the time relative to the start time for 
the  program as shown in Figure 8.</font>              
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Initializer-2: 510</pre>
                                                                        
                                                      
      <pre><b>Figure 8</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
     A comparison of the relative time shown in Figure 8 with Figure 7 confirms 
  that the second instance initializer was executed after the initialization 
  of the ordinary instance variable shown in Listing 9.&nbsp; This confirms 
  that the instance initializers   and variable initializers are executed 
in   the order they appear in the Java source code.<br>
     <br>
     <font color="#ff0000"><b>The constructor for the class named B</b></font><br>
     <br>
     The constructor for the class named <b>B</b> physically separates the
 two  instance initializers in the class definition.&nbsp; The code for the
 constructor begins in Listing  11.<br>
                   
<p> </p>
                             
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                      <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  B(String str){<br>    super(str);<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                      <font color="#000000"><br>
     The constructor begins by using the <b>super</b> keyword to invoke a 
parameterized   constructor on the superclass named <b>A</b>.<br>
     </font>     
<blockquote><font color="#000000"><i>(If you are unfamiliar with this use 
  of the <b>super </b>keyword, see Lesson 1628 entitled </i></font><i><u>The 
 Essence  of OOP using Java, The <b>this </b>and <b>super </b>Keywords</u> 
 at<font color="#000000"> <a href="http://www.DickBaldwin.com">www.DickBaldwin.com</a></font></i><font
 color="#000000"><i>.)</i></font></blockquote>
     <!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Template, remove the comments when ready
<br><a href="url">number</a> title
End Template--><!-- Advanced Placement Study Guide will be posted on both Intro and Advanced--><font
 color="#000000"><font color="#ff0000"><b>Insert a time delay</b></font></font><br>
     <br>
     The remaining code in the constructor, as shown in Listing 12, inserts 
 a  one-hundred millisecond time delay.<font color="#000000"><br>
            </font>              
<p> </p>
                             
<table border="1" cols="1" width="400" bgcolor="#ffff00">
       <tbody>
         <tr>
           <td>                                   
      <pre>    Init02.delay();<br><br>    bXstrTime = Init02.relTime();<br>    System.out.println(str + "B:  " + bXstrTime);<br>  }//end constructor for B<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                      <font color="#000000"><br>
  <font color="#ff0000"><b>Get and display the time</b></font><br>
   <br>
   Then the constructor gets, saves, and displays the time, producing the 
output   shown in Figure 9.&nbsp; A comparison of the relative time shown 
in Figure   9 with the previous figures confirms that the </font>initializers 
are run   after the superclass constructor has returned  but before the constructor 
  of the current class runs.<br>
                   
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Construct 1B:  611</pre>
                                                                        
                                                      
      <pre><b>Figure 9</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
     <font color="#ff0000"><b>      The showData method</b></font><br>
     <br>
     The class named <b>B</b> contains a method named <b>showData.&nbsp;
</b>This  method is shown in its entirety in Listing 13.&nbsp; The purpose
of this method is to summarize the order of initialization by displaying
the values stored in the various instance variables as the object was being
instantiated.<br>
                   
<p> </p>
                             
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                      <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>  void showData(){<br>    System.out.println(<br>                     "\nInitialization values:");<br>    System.out.println("class A xstr: " +<br>                                      aXstrTime);<br>    System.out.println("class B init-1: " +<br>                                      init1Time);<br>    System.out.println("class B simple init: " +<br>                                 simpleInitTime);<br>    System.out.println("class B init-2: " +<br>                                      init2Time);<br>    System.out.println("class B xstr: " +<br>                                      bXstrTime);<br>    System.out.println();//blank line<br>  }//end showData<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                      <font color="#000000"><br>
     </font><font color="#ff0000"><b>The output of the showData method</b></font><br>
     <br>
     The values stored in the instance variables are displayed in the order 
 that  the initialization steps took place during the instantiation of the 
 object.  &nbsp;Recall that the <b>showData</b> method was invoked on the 
object when  it was instantiated in the <b>main</b> method in Listing 4, producing
 the output shown in Figure 10.<br>
                   
<p>       </p>
                           
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                    <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Initialization values:<br>class A xstr: 210<br>class B init-1: 310<br>class B simple init: 410<br>class B init-2: 510<br>class B xstr: 611</pre>
                                                                        
                                                      
      <pre><b>Figure 10</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
            <br>
     An examination of Figure 10 makes it clear that the superclass constructor 
  was executed first, at a relative time of 210 milliseconds.&nbsp; This was
  followed by execution of the first instance initializer at 310 milliseconds, 
  initialization of the ordinary instance variable at 410 milliseconds, and 
  execution of the second instance initializer at 510 milliseconds.&nbsp; 
Finally   the constructor for the class named <b>B</b> was executed at a relative
time  of 611 milliseconds.<br>
     <br>
     <font color="#ff0000"><b>Instantiate another object</b></font><br>
     <br>
  Listing 14 shows the remaining code  in the <b>main</b> method, which was
 not previously discussed.<br>
                   
<p> </p>
                             
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                      <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>    delay();<br><br>    System.out.println("Instantiate second obj: "<br>                                    + relTime());<br>    new B("Construct 2").showData();<br>  }//end main<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                      <font color="#000000"><br>
     The remaining code in the <b>main</b> method inserts another one-hundred 
  millisecond delay, and then instantiates another object of the class named 
  <b>B</b>.&nbsp; As before, this triggers a whole series of events, many 
of  which produce output on the screen.<br>
     <br>
     <font color="#ff0000"><b>The screen output</b></font><br>
     <br>
     The output produced by instantiating another object is shown in its
entirety   in Figure 11.</font>              
<p>       </p>
                            
<table border="1" cols="1" width="400" bgcolor="#ccffff">
                     <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>Instantiate second obj: 711<br>Construct 2A:  811<br>Initializer-1: 911<br>Initializer-2: 1111<br>Construct 2B:  1211<br><br>Initialization values:<br>class A xstr: 811<br>class B init-1: 911<br>class B simple init: 1011<br>class B init-2: 1111<br>class B xstr: 1211</pre>
                                                                        
                                                      
      <pre><b>Figure 11</b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
             <br>
     Except for the differences in the relative time values, the output shown 
  in Figure 11 matches that shown in Figure 2 and Figures 5 through 10.&nbsp; 
Note, however, that there  is nothing in Figure 11 corresponding to the output
 previously shown in Figures  3 and 4.<br>
     <br>
     <font color="#ff0000"><b>Classes are not reloaded</b></font><br>
     <br>
     Figures 3 and 4 show the output produced by the execution of the static
  initializers in the classes named <b>A</b> and <b>B</b>.&nbsp; The process
  of instantiating another object from a set of previously loaded classes
does  not cause those classes to be reloaded.&nbsp; Since static initializers
are  executed one time only when the class is first loaded, those initializers
  are not executed when the second object is instantiated from the class
named   <b>B</b>.<br>
     <br>
     <font color="#ff0000"><b>Constructors and instance initializers are
executed   for each object</b></font><br>
     <br>
     However, constructors and instance initializers are executed, and ordinary 
  instance variables are initialized each time a new object is instantiated. 
  &nbsp;Therefore, the output shown in Figure 11 contains messages and time 
  tags corresponding to the execution of both constructors, the execution 
of   both instance initializers, and the initialization of an ordinary instance 
  variable, all in the proper order.<br>
       
<h2 align="center"><a name="Run_the_Program"></a>Run the Program</h2>
                                 
<p>       At this point, you may find it useful to compile and run the program
      shown        in Listing 15 near the end of the lesson.<br>
            </p>
                                      
<center>                
<h2><a name="Summary"></a>Summary</h2>
            </center>
                                                              
<p><font color="#ff0000"><b>Static initializer blocks</b></font><br>
           </p>
                                        
<p>A static initializer is a block of code surrounded by curly braces that 
  is embedded in a class definition and is qualified by the keyword <b>static</b>.<br>
     </p>
         
<p>You can include any number of static initializer blocks within  your class
      definition.&nbsp; They can be separated by other code such as method
  definitions    and constructors.&nbsp; The static initializer blocks will
  be  executed  in  the order that they appear in the code, regardless of
the  other code   that may separate them.<br>
     </p>
         
<p>The static initializers belonging to a class are executed <i>one time
only</i>  when the class is loaded.<br>
               </p>
           <font color="#ff0000"><b>Instance initializers</b></font><br>
           <br>
     An instance initializer is a block of code surrounded by curly braces
 that  is embedded in a class definition.&nbsp; <i>(It is not qualified by
 the keyword  <b>static</b>.)</i> &nbsp;You can include any number of instance 
 initializers  in your class definition, and the initializers may be physically 
 separated  by other items, such as constructors, method definitions, variable 
 declarations,  etc.<br>
     <br>
     Instance initializers and variable initializers, along with constructors, 
  are executed each time a new object of the class is instantiated.&nbsp; 
The   instance initializers and variable initializers are executed in the 
order   that they appear in the Java source code.&nbsp; They are executed 
after the  constructor for the superclass is executed, and before the constructor 
for  the current class is executed.<br>
     <br>
     Instance initializers are especially useful in anonymous classes <i>(to
  be explained in a future lesson).</i> &nbsp;However, they can be included
  in any class definition, and may make code more readable by initializing
 instance variables near the declaration of those variables rather than deferring
 that initialization to a constructor that is located further away in the
class definition.<br>
     <br>
                    Instance initializers are very similar to <i>noarg </i>constructors, 
  except that a class can define only one <i>noarg</i> constructor, but can 
  define any number of instance initializers.&nbsp; A class definition can 
 contain instance initializers in addition to a <i>noarg</i> constructor, 
in which case, the instance initializers will be executed before the <i>noarg</i> 
 constructor is executed.     
<center>                
<h2><a name="What's next"></a>What's Next?</h2>
                 </center>
                                 
<p>The next lesson in this series will explain and discuss inner classes, 
  with special emphasis on <i>member</i> classes.&nbsp; Subsequent lessons 
 will explain <i>local </i>classes, <i>anonymous </i>classes, and <i>top-level 
 nested</i> classes.<br>
                </p>
                               
<h2 align="center"><a name="Complete_program_listing"></a>Complete Program 
     Listing</h2>
            A complete listing of the program discussed in this lesson is 
show   in Listing 15 below.<br>
                               
<p>  </p>
                               
<table border="1" cols="1" width="400" bgcolor="#ffff00">
                   <tbody>
                    <tr>
                     <td>                                               
                                                                     
      <pre>/*File Init02.java<br>Copyright 2003 R.G.Baldwin<br><br>Illustrates the use of instance initializers.<br><br>Instance initializers behave much like noarg<br>constructors, and are particularly useful for<br>anonymous classes, which are not allowed to<br>define any constructors, even those that take no<br>arguments.<br><br>This program defines a class named B that extends<br>a class named A.  Parameterized constructors are<br>used in both A and B to instantiate an object of<br>the class named B.<br><br>The controlling class defines and initializes<br>a static variable containing the time that the<br>program starts running in msec.  This value is<br>used as the base for computing time intervals<br>later as the execution of the program progresses.<br>The times that are computed and displayed later<br>are in msec relative to the time at which the<br>program starts running.<br><br>Static initializers are defined in both A and B<br>to display the time that the two classes are<br>loaded and the order in which they are loaded.<br><br>An instance variable is defined in the class<br>named B and is initialized (using a simple<br>initialization expression) with the time in msec<br>that the variable is initialized.  The physical<br>location of the instance variable follows the<br>first of two instance initializer in the class<br>definition.<br><br>In addition, two separate instance initializers<br>are defined in the class named B that perform<br>initialization after the constructor for A<br>completes execution and before the constructor<br>for B begins execution.  The first of these<br>initializers executes before the instance<br>variable mentioned above is initialized.  The<br>second of these initializers executes after the<br>instance variable is initialized, demonstrating<br>that initialization based on simple<br>initialization expressions and instance<br>initializers occurs in the order that the code'<br>appears in the class definition.<br><br>The two constructors and the two initializers<br>each get and print time information when they are<br>executed to show the order in which the<br>constructors and the initializers are executed.<br><br>Two separate instances of the class named B are<br>created, showing not only the order in which the<br>instance initializers and the constructors are<br>executed, but also showing that the static<br>initializers are executed one time only when the<br>classes are loaded.<br><br>Each time an object of the class named B is<br>instantiated, an instance method of the class<br>is invoked to display the values of the instance<br>variables initialized during the process<br>of instantiating the object of the class named B.<br><br>100-msec time delays are purposely inserted at<br>strategic points within the program in order to<br>force the time intervals between the occurrence<br>of the different steps in the program to be<br>measurable.<br><br>The output for one run is shown below.  Your<br>results may be different depending on the speed<br>of your computer.<br><br>Instantiate first obj: 0<br>Class A loaded: 10<br>Class B loaded: 110<br><br>Construct 1A:  210<br>Initializer-1: 310<br>Initializer-2: 510<br>Construct 1B:  611<br><br>Initialization values:<br>class A xstr: 210<br>class B init-1: 310<br>class B simple init: 410<br>class B init-2: 510<br>class B xstr: 611<br><br>Instantiate second obj: 711<br>Construct 2A:  811<br>Initializer-1: 911<br>Initializer-2: 1111<br>Construct 2B:  1211<br><br>Initialization values:<br>class A xstr: 811<br>class B init-1: 911<br>class B simple init: 1011<br>class B init-2: 1111<br>class B xstr: 1211<br><br>Note the 100-msec elapsed time intervals<br>between the various steps in the execution of the<br>program.  Also note the order in which the class<br>loading operations and the initialization steps<br>occur.<br><br>Tested using SDK 1.4.1 under WinXP<br>************************************************/<br>import java.util.Date;<br><br>public class Init02{<br>  //Establish the base time in msec.<br>  static long baseTime = new Date().getTime();<br><br><br>  //This is a utility method used to insert a<br>  // 100-millisecod delay.<br>  static void delay(){<br>    try{<br>      Thread.currentThread().sleep(100);<br>    }catch(Exception e){e.printStackTrace();}<br>  }//end delay<br>  //-------------------------------------------//<br><br>  //This is a utility method used to compute the<br>  // current time relative to the value stored<br>  // in the static variable named baseTime.<br>  static long relTime(){<br>    return ((new Date().getTime()) - baseTime);<br>  }//end printTime<br><br>  //-------------------------------------------//<br><br>  public static void main(String[] args){<br>    //Invoke a parameterized constructor for the<br>    // class named B, which is a subclass of A.<br>    // Also invoke the showData method on that<br>    // object to display the values of the<br>    // instance variables that were initialized<br>    // during the construction of the object.<br>    System.out.println("Instantiate first obj: "<br>                                   + relTime());<br>    new B("Construct 1").showData();<br>    //Sleep 100 msec and then instantiate another<br>    // object.<br>    delay();<br>    System.out.println("Instantiate second obj: "<br>                                    + relTime());<br>    new B("Construct 2").showData();<br>  }//end main<br>  //-------------------------------------------//<br>}//end class Init02<br>//=============================================//<br><br>class A{<br>  long aXstrTime;<br><br>  static{//This is a static initializer, which is<br>  // run one time only when the class is loaded.<br>    //Print a message showing the time that the<br>    // class finishes loading.<br>    System.out.println("Class A loaded: " +<br>                               Init02.relTime());<br>  }//End static initializer<br>  //-------------------------------------------//<br><br>  A(String str){//constructor<br>    //Sleep for 100 msec before completing this<br>    // construction<br>    Init02.delay();<br><br>    //Record the time of construction and print<br>    // a message showing the construction time.<br>    aXstrTime = Init02.relTime();<br>    System.out.println(str + "A:  " + aXstrTime);<br>  }//end constructor for A<br><br>}//end class A<br>//=============================================//<br><br>class B extends A{<br>  long bXstrTime;<br>  long init1Time;<br>  long init2Time;<br><br>  static{//This is a static initializer, which is<br>  // run one time only when the class is loaded.<br>    //Sleep for 100 msec to show the order<br>    // that the classes named A and B are loaded.<br>    Init02.delay();<br>    //Print a message showing the time that the<br>    // class finishes loading.<br>    System.out.println("Class B loaded: " +<br>                        Init02.relTime() + "\n");<br>  }//End static initializer<br>  //-------------------------------------------//<br><br>  {//This is an instance initializer<br>    //Sleep for 100 msec before doing this<br>    // initialization.<br>    Init02.delay();<br>    //Record the time and print a message showing<br>    // the time that this instance initializer<br>    // was executed.<br>    init1Time = Init02.relTime();<br>    System.out.println("Initializer-1: " +<br>                                      init1Time);<br><br>    //Sleep for 100 msec after doing this<br>    // initialization to separate this<br>    // initialization from the initialization of<br>    // the instance variable that follows.<br>    Init02.delay();<br>  }//end instance initializer<br>  //-------------------------------------------//<br><br>  //Note that this initialized instance variable<br>  // is located after the first instance<br>  // initializer and before the second instance<br>  // initializer..<br>  long simpleInitTime = Init02.relTime();<br><br>  //-------------------------------------------//<br><br>  //Note that this constructor is physically<br>  // located between the two instance initializer<br>  // blocks.  Both initializer blocks are<br>  // executed before the constructor for this<br>  // class is executed, but after the constructor<br>  // for the superclass is executed.<br>  B(String str){<br>    //Invoke a parameterized constructor on the<br>    // superclass.<br>    super(str);<br>    //Sleep for 100 msec before constructing<br>    // this part of the object.<br>    Init02.delay();<br>    //Record the time and print a message showing<br>    // the construction time for this part of<br>    // the object.<br>    bXstrTime = Init02.relTime();<br>    System.out.println(str + "B:  " + bXstrTime);<br>  }//end constructor for B<br>  //-------------------------------------------//<br><br>  {//This is another instance initializer<br>    //Sleep for 100 msec before doing this<br>    // initialization.<br>    Init02.delay();<br>    //Record the time and print a message showing<br>    // the time that this instance initializer<br>    // was executed.<br>    init2Time = Init02.relTime();<br>    System.out.println("Initializer-2: " +<br>                                      init2Time);<br>  }//end instance initializer<br>  //-------------------------------------------//<br><br>  void showData(){<br>    //This method displays the values that were<br>    // saved in the instance variables during the<br>    // five initialization steps, one of which<br>    // was execution of the superclass<br>    // constructor.  The values are displayed<br>    // in the order that the initialization steps<br>    // occurred.<br>    System.out.println(<br>                     "\nInitialization values:");<br>    System.out.println("class A xstr: " +<br>                                      aXstrTime);<br>    System.out.println("class B init-1: " +<br>                                      init1Time);<br>    System.out.println("class B simple init: " +<br>                                 simpleInitTime);<br>    System.out.println("class B init-2: " +<br>                                      init2Time);<br>    System.out.println("class B xstr: " +<br>                                      bXstrTime);<br>    System.out.println();//blank line<br>  }//end showData<br>}//end class B<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
                     </td>
                   </tr>
                                                                 
  </tbody>                
</table>
                                          
<hr size="3" width="100%" align="center">                 
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in  any form or medium without express written permission from Richard
Baldwin is  prohibited. </p>
                                 
<h4><a name="About the author"></a>About the author</h4>
                                 
<p><b><a href="mailto:baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> 
        is a college professor (at Austin Community College in Austin, Texas) 
    and    private consultant whose primary focus is a combination of Java, 
  C#,  and   XML. In addition to the many platform and/or language independent 
  benefits     of Java and C# applications, he believes that a combination 
 of Java, C#,    and XML will become the primary driving force in the delivery 
  of structured    information on the Web.</i> </p>
                                 
<p><i>Richard has participated in numerous consulting projects, and he frequently
        provides onsite training at the high-tech companies located in and
 around       Austin, Texas.&nbsp; He is the author of Baldwin's Programming
 <a href="http://www.DickBaldwin.com">Tutorials</a>, which has gained a worldwide
        following among experienced and aspiring programmers. He has also
published        articles in JavaPro magazine.</i> </p>
                               
<p><i>Richard holds an MSEE degree from Southern Methodist University and 
        has many years of experience in the application of computer technology 
     to  real-world problems.</i> </p>
                               
<p><i><a href="mailto:baldwin@DickBaldwin.com">baldwin@DickBaldwin.com</a></i> 
        </p>
                               
<p>-end- <br>
                &nbsp;  </p>
                  <br>
                <br>
               <br>
               <br>
            <br>
           <br>
          <br>
         <br>
        <br>
       <br>
      <br>
     <br>
    <br>
   <br>
  <br>
 <br>
</body>
</html>
