<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">The DigitalPicture Interface</h2>
<i>Learn how to write programs using the methods defined in the Picture and 
SimplePicture classes that are declared in the 
DigitalPicture interface.</i><p><b>Published:</b>&nbsp; March 18, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 354</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#The_Picture_class_and_the_DigitalPicture_Interface">The 
		Picture class and the DigitalPicture Interface</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_program_named_Java354a">The program named Java354a</a></li>
	<li><a href="#The_program_named_Java354b">The program named Java354b</a></li>
	<li><a href="#The_program_named_Java354c">The program named Java354c</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="The_Picture_class_and_the_DigitalPicture_Interface">The Picture 
class and the DigitalPicture Interface</a></h3>
<p> If you have studied the earlier lessons in 
this series <i>(see <a href="#Resources">Resources</a>)</i>, you have learned all about the <b>Turtle</b> class, its superclass named <b>
SimpleTurtle</b>, and the classes from which a turtle's contained objects are 
instantiated <i>(<b>Pen</b> and <b>PathSegment</b>)</i>.&nbsp; You have 
learned how to instantiate new <b>Turtle</b> objects, placing them in either a
<b>World</b> object or a <b>Picture</b> object.&nbsp; You have learned how to 
manipulate the <b>Turtle</b> objects once you place them in their environment.</p>
<p> You also need to know about the environment in which a turtle lives.&nbsp; 
You learned all about the <b>World</b> class in the previous lesson <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
In this lesson, you will begin learning about the <b>Picture</b> class and its 
superclass named <b>SimplePicture</b>.</p>
<p> <font color="#FF0000"><b>The Picture class is relatively simple</b></font></p>
<p> In reality, there isn't much to the <b>Picture</b> class.&nbsp; It is simply 
a skeleton class that <a name="overrides_the_toString_method">overrides the <b>toString</b> method</a> and provides five 
different constructors that serve as proxies for the constructors in the 
superclass named <b>SimplePicture</b>.&nbsp; Each <b>Picture</b> constructor simply 
calls a <b>SimplePicture </b>constructor, passing the constructor parameters to the 
<b>SimplePicture </b>constructor.</p>
<p> <font color="#FF0000"><b>The real functionality lies in SimplePicture</b></font></p>
<p> All of the real functionality of a <b>Picture</b> object lies in the 
superclass named <b>SimplePicture</b>.&nbsp; Therefore, the class named <b>
SimplePicture</b> will be the target of this and the next several lessons.&nbsp; 
However, I have provided a source listing for the <b>Picture</b> class in 
Listing 30 near the end of the lesson for your examination.&nbsp; <i>(The only 
changes made to the listing were minor format changes necessary to force the 
source code to fit into this narrow publication format.)</i></p>
<p> <font color="#FF0000"><b>A large and complex class</b></font></p>
<p> The <b>SimplePicture</b> class is a large and complex class containing 
almost forty different methods.&nbsp; That is obviously too much material for a 
single lesson, so I will break the class down and 
explain it in parts.</p>
<p> A complete listing of Ericson's <b>SimplePicture</b> class is provided in 
Listing 31 near the end of the lesson.</p>
<p> <font color="#FF0000"><b><a name="The_DigitalPicture_interface">The 
DigitalPicture interface</a></b></font></p>
<p> The <b>SimplePicture</b> class implements the <b>DigitalPicture</b> interface, 
which declares the following thirteen methods:</p>
<ul>
	<li><b>String getFileName()</b>; // get the file name that the picture came 
	from</li>
	<li><b>String getTitle()</b>; // get the title of the picture</li>
	<li><b>void </b><b>setTitle(String title)</b>; // set the title of the 
	picture</li>
	<li><b>int getWidth()</b>; // get the width of the picture in pixels</li>
	<li><b>int getHeight()</b>; // get the height of the picture in pixels</li>
	<li><b>Image getImage()</b>; // get the image from the picture</li>
	<li><b>BufferedImage getBufferedImage()</b>; // get the buffered image from 
	the picture</li>
	<li><b>int </b><b>getBasicPixel(int x, int y)</b>; // get the pixel 
	information as an <b>int</b> value</li>
	<li><b>void </b><b>setBasicPixel(int x, int y, int rgb)</b>; // set the 
	pixel information as an <b>int</b> value</li>
	<li><b>Pixel </b><b>getPixel(int x, int y)</b>; // get the pixel information 
	as an object of type <b>Pixel</b></li>
	<li><b>void </b><b>load(Image image)</b>; // load the image into the picture</li>
	<li><b>boolean </b><b>load(String fileName)</b>; // load the picture from a 
	file</li>
	<li><b>void show()</b>; // show the picture</li>
</ul>
<p> <font color="#FF0000"><b><a name="My_first_attempt_to_compartmentalize">My first attempt to compartmentalize</a>...</b></font></p>
<p> As my first attempt to compartmentalize and explain the <b>SimplePicture</b> 
class, this lesson will illustrate and explain the thirteen methods in the 
<a href="#The_DigitalPicture_interface">above 
list</a> in terms of how they are implemented in the <b>Picture</b> and <b>SimplePicture</b> classes.&nbsp; 
In addition, the thirteen methods in the above list often call other methods 
belonging to the <b>SimplePicture</b> class, so I will explain those methods in 
this lesson as well.</p>
<p> There are also numerous methods defined in the <b>SimplePicture</b> class 
that are not declared in the <b>DigitalPicture</b> interface.&nbsp; I will explain 
those methods in future 
lessons.</p>
<p> A complete listing of Ericson's <b>DigitalPicture</b> interface is provided 
in Listing 32 near the end of the lesson.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Image from the file named 
	ScaledAquarium.gif. </li>
	<li><a href="#Figure_2">Figure 2</a>. Image from the file named 
	ScaledBeach.jpg. </li>
	<li><a href="#Figure_3">Figure 3</a>. Screen output from the program named 
	Java354a. </li>
	<li><a href="#Figure_4">Figure 4</a>. Text output from the program named 
	Java354a. </li>
	<li><a href="#Figure_5">Figure 5</a>. Screen output for a missing image 
	file. </li>
	<li><a href="#Figure_6">Figure 6</a>. Final Picture output from the program 
	named Java354a.</li>
	<li><a href="#Figure_7">Figure 7</a>. Sun's description of the getRGB 
	method. </li>
	<li><a href="#Figure_8">Figure 8</a>. Sun's description of the setRGB 
	method.</li>
	<li><a href="#Figure_9">Figure 9</a>. First two screen displays from the 
	program named Java354b.</li>
	<li><a href="#Figure_10">Figure 10</a>. Screen output produced by Listing 
	22. </li>
	<li><a href="#Figure_11">Figure 11</a>. Screen output produced by Listing 24.&nbsp; </li>
	<li><a href="#Figure_12">Figure 12</a>. Screen output from the program named 
	Java354c.<b> </b></li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Background color for the SimplePicture class. </li>
	<li><a href="#Listing_2">Listing 2</a>. Background color for Baldwin's code. </li>
	<li><a href="#Listing_3">Listing 3</a>. Beginning of the program named 
	Java354a. </li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the class named Runner. </li>
	<li><a href="#Listing_5">Listing 5</a>. An overloaded constructor from the 
	SimplePicture class. </li>
	<li><a href="#Listing_6">Listing 6</a>. The overloaded load method that 
	requires the name of an image file. </li>
	<li><a href="#Listing_7">Listing 7</a>. The loadOrFail method. </li>
	<li><a href="#Listing_8">Listing 8</a>. Instantiate a small Picture object. </li>
	<li><a href="#Listing_9">Listing 9</a>. Constructor for a Picture with an 
	all-white image. </li>
	<li><a href="#Listing_10">Listing 10</a>. The method named 
	setAllPixelsToAColor.</li>
	<li><a href="#Listing_11">Listing 11</a>. Load an image from a jpg file and 
	set the title.</li>
	<li><a href="#Listing_12">Listing 12</a>. The getFileName method. </li>
	<li><a href="#Listing_13">Listing 13</a>. The setTitle method. </li>
	<li><a href="#Listing_14">Listing 14</a>. Display the Picture object in the 
	explore format. </li>
	<li><a href="#Listing_15">Listing 15</a>. Copy the right half of pix1 to the 
	left half of pix2. </li>
	<li><a href="#Listing_16">Listing 16</a>. The getBasicPixel method.</li>
	<li><a href="#Listing_17">Listing 17</a>. The setBasicPixel method.</li>
	<li><a href="#Listing_18">Listing 18</a>. The getWidth and getHeight 
	methods.</li>
	<li><a href="#Listing_19">Listing 19</a>. Display some text on the system 
	console. </li>
	<li><a href="#Listing_20">Listing 20</a>. Overridden toString method of the 
	Picture class. </li>
	<li><a href="#Listing_21">Listing 21</a>. Beginning of the Runner class and 
	the run method. </li>
	<li><a href="#Listing_22">Listing 22</a>. Instantiate a Picture object using 
	a different constructor.</li>
	<li><a href="#Listing_23">Listing 23</a>. Source code for the overloaded 
	constructor. </li>
	<li><a href="#Listing_24">Listing 24</a>. Use the other overloaded load 
	method. </li>
	<li><a href="#Listing_25">Listing 25</a>. Source code for the other 
	overloaded load method. </li>
	<li><a href="#Listing_26">Listing 26</a>. Beginning of the Runner class and 
	the run method. </li>
	<li><a href="#Listing_27">Listing 27</a>. Scale the green color component 
	using bit manipulations. </li>
	<li><a href="#Listing_28">Listing 28</a>. Scale the green color component 
	using the getPixel method and methods of the Pixel class.</li>
	<li><a href="#Listing_29">Listing 29</a>. Source code for the getPixel 
	method. </li>
	<li><a href="#Listing_30">Listing 30</a>. Source code for Ericson's Picture 
	class.</li>
	<li><a href="#Listing_31.">Listing 31</a>. Source code for Ericson's 
	SimplePicture class.</li>
	<li><a href="#Listing_32">Listing 32</a>. Source code for Ericson's 
	DigitalPicture interface. </li>
	<li><a href="#Listing_33">Listing 33</a>. Source code for the program named 
	Java354a. </li>
	<li><a href="#Listing_34">Listing 34</a>. Source code for the program named 
	Java354b. </li>
	<li><a href="#Listing_35">Listing 35</a>. Source code for the program named 
	Java354c. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p dir="ltr">I will explain the methods in the above
<a href="#The_DigitalPicture_interface">list</a> and some additional methods as 
well, in the context of three sample 
programs.&nbsp; As usual, I will explain the code in fragments.&nbsp; Because I 
will be switching back and forth between code fragments extracted from Ericson's
<b>SimplePicture</b> class and code fragments extracted from my sample programs, 
things can get confusing.</p>
<p dir="ltr"><font color="#FF0000"><b>Reducing the confusion</b></font></p>
<p dir="ltr">In an attempt to reduce the confusion, I will 
present code fragments from Ericson's <b>SimplePicture</b> class against the 
background color shown in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Background color for the SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre>I will present code fragments from the SimplePicture class
against this background color.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Similarly, I will present code fragments from my sample programs against the 
background color shown in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Background color for Baldwin's code. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>I will present code fragments from my sample programs
with this background color.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>On the rare occasion that I need to display a code fragment from the <b>
Picture</b> class, I will present the code fragments against the gray background 
that you see in <a href="#Listing_20">Listing 20</a>.</p>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Image file locations</b><br />
  For simplicity, both image files were placed in the same location as the class 
	files for the program.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>A preview of the images that will be used</b></font></p>
<p>As you might expect from the names of the classes and interfaces that I will 
be explaining <i>(Picture, SimplePicture, and DigitalPicture)</i>, the sample 
programs in this lesson will deal in one way or another with pictures and images.&nbsp; Two different 
image files named <b>ScaledAquarium.gif</b> and <b>ScaledBeach.jpg</b> will be 
used in these programs.&nbsp; The images contained in the two files are shown in 
Figure 1 and Figure 2.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Image from the file named ScaledAquarium.gif. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354a.jpg" width="350" height="285"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p>
 <b><a name="Figure_2">Figure 2</a>. Image from the file named ScaledBeach.jpg. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354b.jpg" width="353" height="385"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Different display formats</b></font></p>
<p>In some cases, the sample program output will be displayed by calling 
Ericson's <b>show</b> method, which produces the display format shown in 
Figure 1.&nbsp; In other cases, the sample program output will be displayed by 
calling Ericson's <b>explore</b> method, which produces the display format shown in 
Figure 2.&nbsp; <i>(The <b>show</b> method and the <b>explore</b> method are both 
methods of the <b>SimplePicture</b> class.&nbsp; They will be explained in a 
future lesson.)</i></p>
<p><font color="#FF0000"><b>The images were scaled in advance</b></font></p>
<p>For reasons that will become apparent later, both images were scaled in 
advance to have 
a height of 256 rows of pixels.&nbsp; Through pure coincidence, that 
also caused each image to have a width of 341 pixels.&nbsp; <i>(Although I 
didn't plan it that way, the two raw images were the same size.)</i></p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Java354a">The program named Java354a</a></h3>
<p>A complete listing of this program is provided in Listing 33 near the end of 
the lesson.</p>
<p>The purpose of this program is to illustrate and <a name="explain_most">explain most</a> of the 
methods that are declared in the <b>DigitalPicture</b> interface and implemented 
in the <b>SimplePicture</b> class, along with the methods called by those 
methods.</p>
<p><font color="#FF0000"><b>Instantiate a Picture object</b></font></p>
<p>One <b>Picture</b> object is instantiated in this program by using a <b>Picture</b> 
constructor that accepts the name of an image file as a parameter and uses the 
image from that file as the image in the <b>Picture</b> object.&nbsp; That 
picture is displayed by calling the <b>show</b> method on the <b>Picture</b> 
object, producing the screen output shown in Figure 1.</p>
<p><font color="#FF0000"><b>Title matches the file name</b></font></p>
<p>Note that <a name="in_this_case">in this case</a>, the title is automatically set to the name of the image file.</p>
<p><font color="#FF0000"><b>Instantiate another Picture object</b></font></p>
<p>A second Picture object is constructed by using a <b>Picture</b> constructor 
that accepts the dimensions of the <b>Picture</b> object only and constructs a
<b>Picture</b> object with a default all-white image.&nbsp; The size of the <b>
Picture</b> object that is constructed is 1x1 pixels.</p>
<p>Then the <b>load</b> method that takes the name of an image file is called to 
load the image from an image file into the small <b>Picture</b> object.&nbsp; 
The size of the <b>Picture</b> object changes automatically to accommodate the 
size of the image.</p>
<p>In this case, the default title is &quot;None&quot;.&nbsp; In other words, 
unlike the <a href="#in_this_case">previous case</a>, the title is 
not automatically set to the name of the image file.</p>
<p>The <b>setTitle</b> and <b>getFileName</b> methods are called to set the 
title for this picture.&nbsp; Then the <b>explore</b> method is called to display 
the <b>Picture</b> object with its new image and title, producing the screen 
output shown in Figure 2.</p>
<p><font color="#FF0000"><b>A caution regarding the repetitive calling of the 
show method</b></font></p>
<p>If you call the <b>show</b> method on a picture, then modify the 
picture, and then call the show method on the picture again, only one copy of 
the picture will be displayed.&nbsp; Furthermore, the results may not be what 
you expect to see.&nbsp; However, displaying the picture in the <b>explore</b> 
format, modifying it, and then displaying it again in the <b>show</b> format 
seems to work OK.</p>
<p><font color="#FF0000"><b>Processing the Picture objects</b></font></p>
<p>A pair of nested <b>for</b> loops is used in conjunction with the <b>getBasicPixel</b> 
and <b>setBasicPixel</b> methods to copy the right half of the image in Figure 1 
into the left half of the image in Figure 2, leaving the right half of the image in 
Figure 2 undisturbed.&nbsp; 
Then the <b>show</b> method is called on the modified second <b>Picture</b> 
object to display it, producing the screen output shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Screen output from the program named 
	Java354a. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354c.jpg" width="350" height="285"></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#FF0000"><b>Text output</b></font></p>
<p>At various points along the way, the 
program calls methods dealing with the file name and the title and eventually 
prints that information on the system console as shown in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Text output from the program named 
	Java354a. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
      <pre>Picture, filename ScaledAquarium.gif height 256 width 341
pix1 Filename: ScaledAquarium.gif
Picture, filename ScaledBeach.jpg height 256 width 341
pix2 FileName: ScaledBeach.jpg
pix1 Title: ScaledAquarium.gif
pix2 Title: pix2: ScaledBeach.jpg</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Methods illustrated by the program named Java354a</b></font></p>
<p>The following methods from the 
<b>DigitalPicture</b> interface are illustrated by this program.</p>
<ul>
	<li>String getFileName()</li>
	<li>String getTitle()</li>
	<li>void setTitle(String title)</li>
	<li>int getWidth()</li>
	<li>int getHeight()</li>
	<li>int getBasicPixel(int x, int y)</li>
	<li>void setBasicPixel(int x, int y, int rgb)</li>
	<li>boolean load(String fileName)</li>
	<li>void show()</li>
</ul>
<p>The following methods that are declared in 
the <b>DigitalPicture</b> interface 
<a name="are_not_illustrated_by_this_program">are not illustrated by this program</a>.</p>
<ul>
	<li>Image getImage()</li>
	<li>BufferedImage getBufferedImage()</li>
	<li>Pixel getPixel(int x, int y)</li>
	<li>void load(Image 
image)</li>
</ul>
<p>These methods will be illustrated by the programs named Java354b and Java354c 
later in this lesson.</p>
<p><font color="#FF0000">
<b>Beginning of the program named Java354a</b></font></p>
<p>All three of the programs in this lesson begin with the code shown in Listing 
3, so I will show this code fragment only once.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of the program named Java354a. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>main</b> method for each program is defined in a class named <b>Main</b>.&nbsp; 
The <b>main</b> method instantiates an object of the <b>Runner</b> class and 
calls a method named <b>run</b> on that object.&nbsp; When the <b>run</b> method 
returns, the <b>main</b> method terminates and the program terminates.</p>
<p><font color="#FF0000">
<b>&nbsp;Beginning of the class named Runner</b></font></p>
<p>Listing 4 shows the beginning of the class named <b>Runner</b> and the 
beginning of the method named <b>run</b> for the program named Java354a.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the class named Runner. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    Picture pix1 = new Picture("ScaledAquarium.gif");
    pix1.show();//display the picture in the show format</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 4 calls one of the overloaded constructors of the <b>Picture</b> 
class to construct a new 341x256 <b>Picture</b> object passing the name of an 
image file as a parameter.&nbsp; As mentioned earlier, for simplicity, the image file was placed in the same directory 
as the class files for the program.</p>
<p><font color="#FF0000"><b>Picture constructors</b></font></p>
<p>The particular constructor called in Listing 4 requires the name of an image 
file as an incoming <b>String</b> parameter.&nbsp; As I mentioned earlier, the constructors for the <b>Picture</b> class simply 
call the corresponding constructors for the superclass named <b>SimplePicture</b> 
passing the incoming parameter to the superclass constructor.&nbsp; You can view 
the code for the <b>Picture</b> constructors in Listing 30 near the end of the lesson.</p>
<p><font color="#FF0000"><b>The SimplePicture constructor</b></font></p>
<p>Listing 5 shows the code for the corresponding constructor in the superclass 
named <b>SimplePicture</b>.&nbsp; <i>(Remember, the background color shown in 
Listing 5 indicates that the code fragment was extracted from the class named <b>
SimplePicture</b>.)</i></p>
<p>
<b><a name="Listing_5">Listing 5</a>. An overloaded constructor from the 
SimplePicture class. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * A Constructor that takes a file name and uses the
  * file to create a picture
  * @param fileName the file name to use in creating the
  * picture
  */
 public SimplePicture(String fileName)
 {
   // load the picture into the buffered image
   load(fileName);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, the code in Listing 5 simply calls one of the overloaded <b>
load</b> methods of 
the <b>SimplePicture</b> class to extract the image from the specified image file and 
load it into a <b>BufferedImage</b> object.&nbsp; The <b>BufferedImage</b> 
object is referred to by a private instance variable belonging to the <b>Picture</b> object being 
constructed.</p>
<p><font color="#FF0000"><b>Instance variables of the SimplePicture class</b></font></p>
<p>No instance variables are defined in the <b>Picture</b> class.&nbsp; The 
instance variables that are defined in the <b>SimplePicture</b> class are listed 
below:</p>
<ul>
	<li>private String <b>fileName</b>; </li>
	<li>private String <b>title</b>; </li>
	<li>private BufferedImage <b>bufferedImage</b>;
  </li>
	<li>private PictureFrame <b>pictureFrame</b>;
  </li>
	<li>private String <b>extension</b>; </li>
</ul>
<p><font color="#FF0000"><b>The overloaded load method</b></font></p>
<p>The overloaded load method called in Listing 5 is shown 
in Listing 6.&nbsp; <i>(Note that the explanatory comments for this method appear to 
be incorrect, so I did not include them in Listing 6.&nbsp; You can view those 
comments in Listing 31.)</i></p>
<p>
<b><a name="Listing_6">Listing 6</a>. The overloaded load method that requires 
the name of an image file. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre>
 public boolean load(String fileName)
 {
     try {
         this.loadOrFail(fileName);
         return true;
     } catch (Exception ex) {
         System.out.println("There was an error trying"
                                + " to open " + fileName);
         bufferedImage = new BufferedImage(600,200,
                              BufferedImage.TYPE_INT_RGB);
         addMessage("Couldn't load " + fileName,5,100);
         return false;
     }
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 6 calls the <b>loadOrFail</b> method <i>(shown in Listing 7)</i> of the <b>
SimplePicture</b> class in 
an attempt to read the file and extract the image from the file.</p>
<p><font color="#FF0000"><b>If the call to loadOrFail fails...</b></font></p>
<p>If the <b>
loadOrFail</b> method is unsuccessful in finding the specified image file, it throws an <b>IOException</b>.&nbsp; 
Therefore, the call to the <b>loadOrFail</b> method in Listing 6 is placed 
inside a <b>try</b> block.&nbsp; In the case of a failure, the <b>catch</b> block in Listing 
6 is executed.&nbsp; The code in the <b>catch</b> block:</p>
<ul>
	<li>Prints an error message on the standard output device.</li>
	<li>Instantiates a default <b>BufferedImage</b> object, storing its 
	reference in the private instance variable named <b>bufferedImage</b> that 
	belongs to the <b>Picture</b> object being constructed.</li>
<li>Calls the <b>addMessage</b> method to display an error message on the 
default <b>BufferedImage</b> object.</li>
	<li>Returns false.</li>
</ul>
<p><font color="#FF0000">
 <b>Screen output for a missing image file</b></font></p>
<p>Figure 5 shows a reduced version of the screen output that occurs as a result 
of a failure by the <b>loadOrFail</b> method to find the specified file.&nbsp;
<i>(It was necessary for me to reduce the size of this image to force it to fit 
in this narrow publication format.)</i></p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Screen output for a missing image file. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354d.jpg" width="449" height="169"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>If the loadOrFail method finds the file - but no 
image</b></font></p>
<p>If the <b>loadOrFail</b> method is successful in finding the specified image 
file, but is not successful in extracting an image from the file, a runtime error 
will be thrown without the frame shown in Figure 5 necessarily appearing on the screen.</p>
<p><font color="#FF0000"><b>If the loadOrFail method succeeds in reading an 
image...</b></font></p>
<p>If the <b>loadOrFail</b> method succeeds in reading the image from the file, 
it will encapsulate that image in a <b>BufferedImage</b> object and will store that 
object's reference in the private instance variable named <b>bufferedImage</b> 
belonging to the <b>Picture</b> object being constructed.</p>
<p><font color="#FF0000">
<b>The loadOrFail method</b></font></p>
<p>The source code for the <b>loadOrFail</b> method is shown in Listing 7.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. The loadOrFail method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to load the picture from the passed file name
  * @param fileName the file name to use to load the
  * picture from
  */
 public void loadOrFail(
                       String fileName) throws IOException
 {
    // set the current picture's file name
   this.fileName = fileName;

   // set the extension
   int posDot = fileName.indexOf('.');
   if (posDot &gt;= 0)
     this.extension = fileName.substring(posDot + 1);

   // if the current title is null use the file name
   if (title == null)
     title = fileName;

   File file = new File(this.fileName);

   if (!file.canRead())
   {
     // try adding the media path
     file = new File(
                 FileChooser.getMediaPath(this.fileName));
     if (!file.canRead())
     {
       throw new IOException(this.fileName + " could not"
       + " be opened. Check that you specified the path");
     }
   }

   bufferedImage = ImageIO.read(file);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>File IO is a major topic</b></font></p>
<p>File IO is a major topic in its own right.&nbsp; Because this tutorial is not 
intended to teach you about file IO, I won't explain the code in Listing 7 in 
detail.&nbsp; If you don't understand that code, you might want to study up on file IO 
in Java.</p>
<p><font color="#FF0000"><b>Behavior of the loadOrFail method</b></font></p>
<p>Basically, the <b>loadOrFail</b> method either throws an <b>IOException</b> 
or:</p>
<ul>
	<li>Finds the specified image file.</li>
	<li>Extracts the image from the image file.</li>
	<li>Encapsulates the image in an object of the <b>BufferedImage</b> class.</li>
	<li>Stores the object's reference in a private instance variable named <b>
	bufferedImage</b> belonging to the <b>Picture</b> object being constructed.</li>
</ul>
<p>Another possibility is that the method finds the specified file but is unable 
to extract an image from it <i>(the file may be corrupt)</i> in which case an 
error or exception will ultimately be thrown.</p>
<p><font color="#FF0000"><b>Instantiate a small Picture object</b></font></p>
<p>Having instantiated the <b>Picture</b> object based on an existing image file <i>
(see Figure 1)</i>, the 
program named Java354a instantiates a new small <b>Picture</b> object with a default 
all-white image.&nbsp; <i>(Note that the size must be at least 1x1 pixels or a 
runtime error will occur.)</i>&nbsp; This <b>Picture</b> object is instantiated 
by calling the <b>Picture</b> constructor shown in Listing 8.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Instantiate a small Picture object. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    Picture pix2 = new Picture(1,1);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Constructor for a Picture object with an all-white image</b></font></p>
<p>The source code for the <b>SimplePicture</b> constructor that is executed as 
a result of the code in Listing 8 is shown in Listing 9.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Constructor for a Picture with an 
all-white image. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * A constructor that takes the width and height desired
  * for a picture and creates a buffered image of that
  * size.  This constructor doesn't  show the picture.
  * @param width the desired width
  * @param height the desired height
  */
 public  SimplePicture(int width, int height)
 {
   bufferedImage = new BufferedImage(
               width, height, BufferedImage.TYPE_INT_RGB);
   title = "None";
   fileName = "None";
   extension = "jpg";
   setAllPixelsToAColor(Color.white);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 9 begins by instantiating a new <b>BufferedImage</b> object of a 
specified size and a particular type.</p>
<p><font color="#FF0000"><b>What is a BufferedImage object?</b></font></p>
<p>To make a long story short, a <b>BufferedImage</b> object encapsulates an 
image in a sophisticated and accessible way.&nbsp; <i>(Many methods are provided 
to access the data in the object.)</i></p>
<p><font color="#FF0000"><b>How is the image data represented?</b></font></p>
<p>There are many different ways in which image data can be represented.&nbsp; 
The code in Listing 9 specifies one of those ways.&nbsp; The parameter value <b>
BufferedImage.TYPE_INT_RGB</b> is a constant that causes the image to be 
represented with three 8-bit color components <i>(red, green, and blue)</i> packed into 
pixels of type <b>int</b>.</p>
<p><font color="#FF0000"><b>Setting default property values</b></font></p>
<p>After instantiating the <b>BufferedImage</b> object and storing its reference 
in the private instance variable named <b>bufferedImage</b>, Listing 9 sets 
default values for the <b>title</b>, <b>fileName</b>, and <b>extension</b> 
properties.</p>
<p><font color="#FF0000"><b>Set all pixels to white</b></font></p>
<p>Then Listing 9 calls the method named <b>setAllPixelsToAColor</b> to set all 
of the pixels in the new image to the color white.&nbsp; The source code for 
this method is shown in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. The method named setAllPixelsToAColor</b>.<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to set the color in the picture to the passed
  * color
  * @param color the color to set to
  */
 public void setAllPixelsToAColor(Color color){
   // loop through all x
   for (int x = 0; x &LT; this.getWidth(); x++){
     // loop through all y
     for (int y = 0; y &LT; this.getHeight(); y++){
       getPixel(x,y).setColor(color);
     }//end inner loop
   }//end outer loop
 }//end method named setAllPixelsToAColor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>With the exception of the call to the <b>getPixel</b> method, there should be 
nothing in Listing 10 that causes you any difficulty.</p>
<p><font color="#FF0000"><b>Gain access to each pixel and color it white</b></font></p>
<p>Listing 10 uses a pair of nested <b>for</b> loops and a call to the <b>
getPixel</b> method to gain access to every pixel in the image.&nbsp; I will 
explain the <b>getPixel</b> method in detail later in this lesson.&nbsp; For now suffice it to say that the <b>
getPixel</b> method encapsulates a pixel whose location in the image is specified by a pair of 
horizontal and vertical coordinates into an object of the class <b>Pixel</b>.&nbsp; 
Then the method returns a 
reference to the <b>Pixel</b> object.</p>
<p><font color="#FF0000"><b>Set the color of the pixel to white</b></font></p>
<p>The <b>Pixel</b> class provides many methods 
that can be used to manipulate the pixel.&nbsp; The code in Listing 10 calls the <b>setColor</b> method on the <b>Pixel</b> object to set the color of each pixel to white.</p>
<p><font color="#FF0000">
<b>Load an image from a jpg file and set the title.</b></font></p>
<p>Having created the small <i>(1x1)</i> <b>Picture</b> object, Listing 11 calls 
the <b>load</b> method of the <b>SimplePicture</b> class to load the image from 
an image file into the <b>BufferedImage</b> object that belongs to the <b>
Picture</b> object.&nbsp; Note that this is the same overloaded <b>load</b> method that I explained in conjunction with Listing 
6 earlier in this lesson.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Load an image from a jpg file and set 
the title.</b><table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    pix2.load("ScaledBeach.jpg");
    
    //Set the title of the picture.
    pix2.setTitle("pix2: " + pix2.getFileName());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><i>(Note that the size of the <b>Picture</b> object increases or decreases 
automatically to accommodate the size of the image.)</i></p>
<p>Listing 11 also calls the <b>getFileName</b> method and the <b>setTitle</b> 
method to set the title of the <b>Picture</b> object to that shown in the top 
banner in Figure 2.</p>
<p><font color="#FF0000">
<b>The getFileName method</b></font></p>
<p>As you can see in Listing 12, the <b>getFileName</b> method simply returns 
the current value of the <b>fileName</b> property stored in an instance variable 
having the same name.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. The getFileName method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to get the file name associated with the
  * picture
  * @return  the file name associated with the picture
  */
 public String getFileName() { return fileName; }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The setTitle method</b></font></p>
<p>The <b>setTitle</b> method, which is shown in its entirety in Listing 13, is 
only slightly more complicated.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The setTitle method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to set the title for the picture
  * @param title the title to use for the picture
  */
 public void setTitle(String title)
 {
   this.title = title;
   if (pictureFrame != null)
       pictureFrame.setTitle(title);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>setTitle</b> method begins by storing the incoming <b>String</b> 
parameter in an instance variable named <b>title</b>.</p>
<p><font color="#FF0000"><b>A PictureFrame object</b></font></p>
<p>The <b>SimplePicture</b> class has a private instance variable of type <b>
PictureFrame</b> named <b>pictureFrame</b>.&nbsp; I don't want to dwell on this 
topic in this lesson, because I will explain the <b>PictureFrame</b> class in 
some detail in a future lesson.&nbsp; For now, suffice it to say that an object 
of the <b>PictureFrame</b> class holds a reference to an object of the <b>JFrame</b> 
class.&nbsp; It is the <b>JFrame</b> object that provides the visual 
manifestation of a <b>Picture</b> object as shown in Figure 1.</p>
<p>The code in Listing 13 checks to confirm that such a<b> PictureFrame</b> 
object exists, and if so it calls the <b>setTitle</b> method on the reference to 
the <b>PictureFrame</b> 
object.&nbsp; That call, in turn, calls the <b>setTitle</b> method on the <b>
JFrame</b> object, producing the visual manifestation of a title that you see in 
the banner at the top of Figure 1.</p>
<p><font color="#FF0000">
<b>Display the Picture object in the explore format</b></font></p>
<p>Listing 14 calls the <b>explore</b> method to display the <b>Picture</b> 
object in the format shown in Figure 2.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Display the Picture object in the 
explore format. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    pix2.explore();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>SimplePicture</b> class provides two different methods that can be used to 
display a <b>Picture</b> object:</p>
<ul>
	<li><b>show</b> - produces the output format shown in Figure 1.</li>
	<li><b>explore</b> - produces the output format shown in Figure 2.</li>
</ul>
<p>I will explain both of these methods in detail in a future lesson.&nbsp; For 
now, just observe the differences between the format of Figure 1 and the format 
of Figure 2.</p>
<p><font color="#FF0000">
<b>Copy the right half of pix1 to the left half of pix2</b></font></p>
<p>Listing 15 uses a pair of nested <b>for</b> loops along with calls to the <b>
getHeight</b>, <b>getWidth</b>, <b>
getBasicPixel</b>, and <b>setBasicPixel </b>
methods to copy the right half of the image from <b>pix1</b> into the left half of 
<b>pix2</b>, leaving the right half of <b>pix2</b> undisturbed.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Copy the right half of pix1 to the left 
half of pix2. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    for(int row = 0;row &lt; pix1.getHeight();row++){
      for(int col = 0;col &lt; pix2.getWidth()/2;col++){
        pix2.setBasicPixel(col,row,pix1.getBasicPixel(
                            col + pix1.getWidth()/2,row));
      }//end inner for loop
    }//end outer for loop
    
    //Display the final result.
    pix2.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
 <b>Final Picture output from program Java354a</b></font></p>
<p>Then Listing 15 calls the <b>show</b> method on <b>pix2</b> producing the 
screen output shown in Figure 6.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Final Picture output from the program named Java354a. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354e.jpg" width="350" height="285"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see in Figure 6, the right half of the aquarium image has been 
copied into the left half of the beach image.</p>
<p><font color="#FF0000">
<b>The getBasicPixel method</b></font></p>
<p>The <b>getBasicPixel</b> method is shown in its entirety in Listing 16.&nbsp; 
This method receives a pair of x,y coordinate values and returns the color 
contents of the pixel at that location packed in a single value of type <b>int</b>.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. The getBasicPixel method.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to return the pixel value as an int for the
  * given x and y location
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @return the pixel value as an integer (alpha, red,
  * green, blue)
  */
 public int getBasicPixel(int x, int y)
 {
    return bufferedImage.getRGB(x,y);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The hard work is done by getRGB</b></font></p>
<p>The code in Listing 16 is straightforward due to the fact that all of the 
hard work is handled by a call to the <b>getRGB</b> method of the <b>BufferedImage</b> 
class.&nbsp; Sun's description of the <b>getRGB</b> method is provided in Figure 
7.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Sun's description of the getRGB method. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
Returns an integer pixel in the default RGB color model (TYPE_INT_ARGB) and 
default sRGB colorspace. Color conversion takes place if this default model does 
not match the image ColorModel. There are only 8-bits of precision 
for each color component in the returned data when using this method.</td>
    </tr>
  </tbody>
</table>
</p>
<p>I will leave it as an exercise for the student to study up on the <i>color model</i> 
and the <i>color space</i> aspects of a <b>BufferedImage</b> object in order to fully 
understand the description in Figure 7.</p>
<p><font color="#FF0000"><b>The setBasicPixel method</b></font></p>
<p>The <b>setBasicPixel</b> method is shown in Listing 17.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. The setBasicPixel method.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to set the value of a pixel in the picture
  * from an int
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @param rgb the new rgb value of the pixel (alpha, red,
  * green, blue)
  */
 public void setBasicPixel(int x, int y, int rgb)
 {
   bufferedImage.setRGB(x,y,rgb);
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, the <b>setBasicPixel</b> method delegates the hard work to the <b>
setRGB</b> method of the <b>BufferedImage</b> class.&nbsp; Sun's description of 
the <b>
setRGB</b> method is provided in Figure 8.</p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Sun's description of the setRGB method.</b><table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
      Sets a pixel in this BufferedImage to the specified RGB 
		value. The pixel is assumed to be in the default RGB color model, 
		TYPE_INT_ARGB, and default sRGB color space. For images with an
		IndexColorModel, the index with the nearest color is chosen.
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The getWidth and getHeight methods of the SimplePicture class</b></font></p>
<p>Listing 15 also calls the <b>getWidth</b> and <b>getHeight</b> methods of the
<b>SimplePicture</b> class to control the <b>for</b> loops.&nbsp; The <b>getWidth</b> 
and <b>getHeight</b> methods of the <b>SimplePicture</b> class are shown in Listing 
18.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. The getWidth and getHeight methods.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to get the width of the picture in pixels
  * @return the width of the picture in pixels
  */
 public int getWidth(){ return bufferedImage.getWidth(); }

 /**
  * Method to get the height of the picture in pixels
  * @return  the height of the picture in pixels
  */
 public int getHeight(){
  return bufferedImage.getHeight();
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Call corresponding methods on the BufferedImage 
object</b></font></p>
<p>The <b>getWidth</b> and <b>getHeight</b> methods call methods having the same names on the <b>
BufferedImage</b> object to get and return the width and the height of the <b>
BufferedImage</b> object.</p>
<p><font color="#FF0000"><b>Width and height of the image, not the JFrame</b></font></p>
<p>It is important to note that the width and height values for a <b>Picture</b> 
object obtained in this manner correspond to the dimensions of the image inside 
the <b>JFrame</b> shown in Figure 1.&nbsp; They do not correspond to the outer 
dimensions of the <b>JFrame</b> object.</p>
<p>The outer dimensions of the <b>JFrame</b> object shown in Figure 1 are 350x285 
pixels whereas the dimensions of the image are 341x256 pixels.&nbsp; The extra 
space is consumed by the borders and the banner at the top of the <b>JFrame</b> 
object.</p>
<p><font color="#FF0000">
<b>Display some text on the system console</b></font></p>
<p>The code in Listing 19 calls the <b>getFileName</b> method and the <b>getTitle</b> 
method on the <b>Picture</b> objects to print the text shown in Figure 5.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Display some text on the system console. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    System.out.println(pix1);
    System.out.println("pix1 Filename: "
                                    + pix1.getFileName());
    System.out.println(pix2);
    System.out.println("pix2 FileName: "
                                    + pix2.getFileName());
    System.out.println("pix1 Title: " + pix1.getTitle());
    System.out.println("pix2 Title: " + pix2.getTitle());

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I explained the <b>getFileName</b> method in conjunction with Listing 12 
earlier in this lesson.</p>
<p>Although I haven't shown you the code for the <b>getTitle</b> method of the
<b>SimplePicture</b> class, suffice it to say that this method simply returns 
the value stored in the private instance variable named <b>title</b>.</p>
<p><font color="#FF0000"><b>Overridden toString method of the Picture class</b></font></p>
<p>When you pass a Java object's reference to the <b>println</b> method, <i>(as 
in the first statement in Listing 19)</i>, code in 
the <b>printing</b> method calls the <b>toString</b> method on the incoming object 
reference to get a <b>String</b> object for printing.&nbsp; As I mentioned 
<a href="#overrides_the_toString_method">earlier</a>, the <b>Picture</b> class overrides the <b>toString</b> method.&nbsp; 
The overridden version of the <b>toString</b> method for the <b>Picture</b> 
class is shown in Listing 20.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Overridden toString method of the 
Picture class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  /**
   * Method to return a string with information about this
   * picture.
   * @return a string with information about the picture 
   * such as fileName, height and width.
   */
  public String toString()
  {
    String output = 
      "Picture, filename " + getFileName() +
      " height " + getHeight()
      + " width " + getWidth();
    return output;
  }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Given what you have already learned, you should have no difficulty 
understanding how the code in Listing 20 produces the string shown as the first 
line of text output in Figure 4.</p>
<p><font color="#FF0000"><b>The end of the program named Java354a</b></font></p>
<p>Listing 19 signals the end of the <b>run</b> method, the end of the <b>Runner</b> 
class, and the end of the program named Java354a.</p>
<h3><a name="The_program_named_Java354b">The program named Java354b</a></h3>
<p>A complete listing of this program is provided in Listing 34 near the end of 
the lesson.</p>
<p>The purpose of this program is to illustrate and explain most of the
<a href="#are_not_illustrated_by_this_program">remaining</a> methods that are declared in the <b>DigitalPicture</b> interface as implemented 
in the <b>Picture</b> and <b>SimplePicture</b> classes, along with methods 
called by those methods.</p>
<p>The earlier program named Java354a illustrated the use of all but the 
following four methods that are declared in the <b>DigitalPicture</b> interface</p>
<ul>
	<li>Image <b>getImage()</b></li>
	<li>BufferedImage <b>getBufferedImage()</b></li>
	<li>void <b>load(Image image)</b></li>
	<li>Pixel <b>getPixel(int x, int y)</b></li>
</ul>
<p>This program creates and displays four <b>Picture</b> objects illustrating the first 
three methods in the above list.&nbsp; This leaves only the <b>getPixel</b> 
method to be illustrated later in this lesson to satisfy the
<a href="#My_first_attempt_to_compartmentalize">initial contract</a> of the lesson.</p>
<p>This program begins just like the previous program with code that is 
identical to that shown in Listing 3.</p>
<p><font color="#FF0000">
<b>Beginning of the Runner class and the run method</b></font></p>
<p>The <b>Runner</b> class and the <b>run</b> method begin in Listing 21.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Beginning of the Runner class and the 
run method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor.
    Picture pix1 = new Picture("ScaledAquarium.gif");
    pix1.setTitle("pix1");
    pix1.show();

    //Construct another new 341x256 Picture object by
    // providing the name of an image file as a parameter
    // to the Picture constructor.
    Picture pix2 = new Picture("ScaledBeach.jpg");
    pix2.setTitle("pix2");
    pix2.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 21 creates and displays two different <b>Picture</b> objects using 
code that you have seen before.&nbsp; The screen output produced by the code in 
Listing 21 is shown in Figure 9.</p>
<p>
 <b><a name="Figure_9">Figure 9</a>. First two screen displays from the program 
	named Java354b.
	</b>
<table bgcolor="#ffffff"  border="1" cols="1" id="table1" bordercolor="#000000">
<tr><td><img border="0" src="java354f.jpg" width="350" height="290"></td></tr>
<tr><td><img border="0" src="java354g.jpg" width="350" height="291"></td></tr>
</table></p>

<p>These are the same images that you saw before.&nbsp; Only the title in the <b>
JFrame</b> object is different.</p>
<p><font color="#FF0000">
<b>Instantiate a Picture object using a different constructor</b></font></p>




<p>Listing 22 constructs a third new 341x256 <b>Picture</b> object by extracting the <b>BufferedImage</b> object 
reference from
<b>pix1</b> and passing it as a parameter to a different overloaded constructor for the
<b>Picture</b> class.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Instantiate a Picture object using a 
different overloaded constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>    Picture pix3 = new Picture(pix1.getBufferedImage());
    pix3.setTitle("pix3");
    pix3.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The call to the <b>getBufferedImage</b> method returns the reference to the
<b>BufferedImage</b> object stored in the instance variable named <b>
bufferedImage</b>.&nbsp; You can view the code for that method in Listing 31 
near the end of the lesson.</p>
<p>Listing 22 also sets the title for the new <b>Picture</b> object and calls 
the <b>show</b> method to display it.</p>
<p><font color="#FF0000">
<b>Source code for the overloaded constructor</b></font></p>
<p>Listing 23 shows the source code for the overloaded <b>Picture</b> 
constructor that is called to create the new <b>Picture</b> object in Listing 
22.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. Source code for the overloaded 
constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * A constructor that takes a buffered image
  * @param image the buffered image
  */
 public SimplePicture(BufferedImage image)
 {
   this.bufferedImage = image;
   title = "None";
   fileName = "None";
   extension = "jpg";
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This constructor receives an incoming parameter that is a reference to a <b>
BufferedImage</b> object.&nbsp; It stores that reference in its own instance 
variable named <b>bufferedImage</b>, thereby causing the referenced image to become 
the image for the new <b>Picture</b> object being constructed.</p>
<p><font color="#FF0000"><b>
<a name="Two_references_to_the_same_BufferedImage_object">Two references to the 
same BufferedImage object</a></b></font></p>
<p><a name="At_this_point">At this point</a>, we have two <b>Picture</b> objects, <b>pix1</b> and <b>pix3</b> 
sharing a common <b>BufferedImage</b> object.&nbsp; They each contain a 
reference to the same <b>BufferedImage</b> object.&nbsp; This is probably not a good idea, because any 
changes made to the pixels in the <b>BufferedImage</b> object by way of either <b>
Picture</b> 
object will show up in both pictures.&nbsp; <i>(See Listing 24 for a better 
approach.)</i></p>
<p><font color="#FF0000">
 <b>Screen output produced by Listing 22</b></font></p>
<p>The screen output produced by Listing 22 is shown in Figure 10.</p>
<p>
 <b><a name="Figure_10">Figure 10</a>. Screen output produced by Listing 22. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table2" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354h.jpg" width="350" height="291"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Identical except for the title</b></font></p>
<p>If you compare Figure 10 with the top image in Figure 9, you will see that 
they are identical except for the title.&nbsp; As described 
<a href="#Two_references_to_the_same_BufferedImage_object">above</a>, the image 
showing in both figures is a common <b>BufferedImage</b> object.&nbsp; 
Therefore, the two onscreen images are identical.</p>
<p>However, the <b>JFrame</b> 
objects that provide the onscreen visual manifestations of the two <b>Picture</b> 
objects are different, and each <b>JFrame</b> object has its own title.&nbsp; 
Therefore, the titles in the two figures are different.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Image versus BufferedImage</b><br />
  Image is the superclass of BufferedImage.&nbsp; Therefore, a BufferedImage 
	object is also an Image object.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Call the other overloaded load method</b></font></p>
<p>The <b>SimplePicture</b> class provides two overloaded methods named <b>load</b>.&nbsp; 
One of them, which was shown and discussed in Listing 6, requires a file name as an incoming 
parameter.&nbsp; The other overloaded <b>load</b> method, which is shown in Listing 25, requires a reference to an 
object of type <b>Image</b> as an incoming parameter.</p>
<p><font color="#FF0000"><b>Construct and display one more Picture object</b></font></p>
<p>Listing 24 calls this version of the <b>load</b> method to construct and 
display a fourth new 341x256 <b>Picture</b> object.&nbsp; Instead of constructing a new
<b>Picture</b> object by passing an image reference to an overloaded constructor
<i>(as in Listing 22)</i>, this code starts with an 
all-white <b>Picture</b> 
object and then loads an image extracted from <b>pix2</b>.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Use the other overloaded load method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    Image image = pix2.getImage();

    //Get the size of the image and pass those dimensions
    // to the constructor for the Picture object.
    Picture pix4 = new Picture(image.getWidth(null),
                               image.getHeight(null));
    //Now load the image into the Picture object and
    // display the picture.
    pix4.load(image);
    pix4.setTitle("pix4");
    pix4.show();

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Size is not set automatically</b></font></p>
<p>Note that unlike the load method that takes a file name as a parameter <i>
(shown in Listing 6)</i>, this version of the load 
method does not automatically set the size of the <b>Picture</b> object to match 
the size of the image.</p>
<p>Listing 24 begins by calling the <b>getImage</b> method on <b>pix2</b> to get a 
reference to the <b>Image</b> object belonging to that picture.&nbsp; <i>(The 
call actually gets a reference to a <b>BufferedImage</b> object and saves it as 
the superclass type <b>Image</b>.)</i></p>
<p>Listing 24 calls the <b>getWidth</b> and <b>getHeight</b> methods on the <b>
Image</b> object to get the dimensions of the image.&nbsp; These values are 
passed to the <b>Picture</b> constructor to create a new all-white <b>Picture</b> 
object having the same dimensions as the image.</p>
<p>Then Listing 24 calls the <b>load</b> method on the <b>Picture</b> object to 
load the image into the picture.</p>
<p><font color="#FF0000">
<b>Source code for the other overloaded load method</b></font></p>
<p>The source code for the version of the overloaded <b>load</b> method that is 
called in Listing 24 is shown in Listing 25.</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Source code for the other overloaded 
load method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to load the buffered image with the passed
  * image
  * @param image  the image to use
  */
 public void load(Image image)
 {
   // get a graphics context to use to draw on the
   // buffered image
   Graphics2D graphics2d = bufferedImage.createGraphics();

   // draw the image on the buffered image starting
   // at 0,0
   graphics2d.drawImage(image,0,0,null);

   // show the new image
   show();
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A graphics context</b><br />
  I explained the concept of a <i>graphics context</i> in the previous lesson.&nbsp; 
	(See <a href="#Resources">Resources</a>.)</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Get a graphics context</b></font></p>
<p>Listing 25 begins by calling the <b>createGraphics</b> method on the all-white <b>BufferedImage</b> object that belongs to the <b>Picture</b> object 
to get a reference to the graphics context belonging to that <b>BufferedImage</b> 
object.</p>
<p>Then Listing 25 calls the <b>drawImage</b> method on that graphics context to 
draw the image received as an incoming parameter on that graphics context.&nbsp; 
This replaces the all-white pixels with the colored pixels that describe the 
image.</p>
<p><font color="#FF0000"><b>Display the picture</b></font></p>
<p>Finally, Listing 25 calls the <b>show</b> method to automatically display the new 
picture.&nbsp; This causes the call 
to the <b>show</b> method in Listing 24 to be redundant.&nbsp; <i>(That call to 
the <b>show</b> method could be 
eliminated and the image shown in Figure 11 would still appear on the screen.)</i></p>
<p>
 <b><a name="Figure_11">Figure 11</a>. Screen output produced by Listing 24. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java354i.jpg" width="350" height="285"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Looks like the bottom image in Figure 9</b></font></p>
<p>Note once again that the image in Figure 11 looks exactly like the bottom 
image in Figure 9.&nbsp; Only the title is different.&nbsp; This is because the 
images in the pictures named <b>pix2</b> and <b>pix4</b> were <i>derived from</i> the 
same image.</p>
<p><font color="#FF0000"><b>A better approach than before</b></font></p>
<p>However, unlike the <a href="#At_this_point">earlier case</a>, future changes 
made to the image in <b>pix4</b> will not be reflected in <b>pix2</b> and vice 
versa.&nbsp; 
Although the image in pix4 <i>(shown in Figure 11)</i> is <i>derived from</i> 
the image in p<b>ix2,</b> the <b>BufferedImage</b> object referenced in <b>pix4</b> 
is a different object than the <b>BufferedImage</b> object referenced in <b>pix2</b>.&nbsp;
<i>(We do not have two references to the same <b>BufferedImage</b> object in 
this case.)</i></p>
<p><font color="#ff0000"><b>The end of the program named Java354</b></font><font color="#FF0000"><b>b</b></font></p>
<p>Listing 24 signals the end of the <b>run</b> method, the end of the <b>Runner</b> 
class, and the end of the program named Java354b.</p>
<h3><a name="The_program_named_Java354c">The program named Java354c</a></h3>
<p>A complete listing of this program is provided in Listing 35 near the end of 
the lesson.</p>
<p><font color="#FF0000"><b>Only the getPixel method remains to be explained</b></font></p>
<p>The programs named Java354a and Java354b illustrated all of the methods 
declared in the <b>DigitalPicture</b> interface other than the <b>getPixel</b> 
method.</p>
<p>The purpose of this program is to illustrate the use of the <b>getPixel</b> 
method as implemented in the <b>SimplePicture</b> class, and to compare its use 
with the <b>getBasicPixel</b> and <b>setBasicPixel</b> methods.</p>
<p><font color="#FF0000"><b>Create two Picture objects from the same image file</b></font></p>
<p>This program begins by creating two <b>Picture</b> objects containing the 
same image.&nbsp; <i>(Note however that each <b>Picture</b> object contains a 
reference to a different <b>BufferedImage</b> object.&nbsp; The images are the 
same because both <b>Picture</b> objects are created from the same image file.)</i></p>
<p><font color="#FF0000"><b>Modify the green color component for each row of 
pixels</b></font></p>
<p>Then the 
program modifies the green color component for each row of pixels in one <b>Picture</b> 
object using the <b>
getBasicPixel</b> and <b>setBasicPixel</b> methods.&nbsp; This approach requires 
a programming knowledge of <i>bit manipulations</i> along with knowledge&nbsp; of how the color components are stored in the integer that represents a pixel.</p>
<p>After that, the program makes the same modifications to the green color components 
in each row of pixels in the other <b>Picture</b> object.&nbsp; In this case, 
the modifications are&nbsp;&nbsp; made using the <b>
getPixel</b> method and methods of the <b>Pixel</b> class.</p>
<p><font color="#FF0000"><b>Compare the two approaches</b></font></p>
<p>This makes it possible to compare the two approaches.&nbsp; The comparison illustrates the reduction in complexity achieved by using the 
<b>getPixel</b> method in place of the <b>getBasicPixel</b> and <b>setBasicPixel</b> 
methods.</p>
<p><font color="#FF0000"><b>Three statements are required</b></font></p>
<p>Both approaches require three statements inside a pair of nested <b>for</b> 
loops, but the three statements involving bit manipulations are much more 
complex than the statements that call methods on the <b>Pixel</b> object.</p>
<p><font color="#FF0000"><b>The same visual results</b></font></p>
<p>Each approach produces the same visual result.&nbsp; The two modified images 
are shown in Figure 12.&nbsp; As you can see, the only differences between the 
two are the titles.&nbsp; <i>(The original images are the same as the beach 
image that I have been using throughout this lesson, so I won't show those 
images again.)</i></p>
<p>
 <b><a name="Figure_12">Figure 12</a>. Screen output from the program named 
	Java354c. </b>
<table bgcolor="#ffffff"  border="1" cols="1" bordercolor="#000000">
<tr><td><img border="0" src="java354j.jpg" width="350" height="285"></td></tr>
<tr><td><img border="0" src="java354k.jpg" width="350" height="285"></td></tr>
</table></p>

<p><font color="#FF0000"><b>Modifications to the green color component</b></font></p>




<p>The green color component for each image was scaled by zero for every pixel in the 
first row and was scaled by 1.0 for every pixel in the last row.&nbsp; <i>
(Recall that the overall size of this image was originally scaled so that it would have 256 
rows of pixels.)</i></p>
<p>The scale factor that was applied to each row between the 
first and last rows was proportional to the row number.</p>
<p>As you can see, 
this resulted in an image with a magenta tinge at the top and the correct colors at the 
bottom.&nbsp; <i>(Compare the colors in the last row of pixels in the images in 
Figure 12 with the corresponding pixels in Figure 2.)</i></p>
<p><font color="#FF0000"><b>Beginning of the Runner class and the run method</b></font></p>
<p>This program begins just like the previous two programs with code&nbsp;&nbsp;&nbsp; that is 
identical to that shown in Listing 3, so I won't show that code again.</p>
<p>Listing 26 shows the beginning of the <b>Runner</b> class and the <b>run</b> 
method.</p>
<p>
<b><a name="Listing_26">Listing 26</a>. Beginning of the Runner class and the 
run method. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor.
    Picture pic1 = new Picture("ScaledBeach.jpg");
    pic1.setTitle("pic1");
    pic1.explore();

    //Construct another new 341x256 Picture object by
    // providing the name of an image file as a parameter
    // to the Picture constructor.
    Picture pic2 = new Picture("ScaledBeach.jpg");
    pic2.setTitle("pic2");
    pic2.explore();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 26 instantiates two new <b>Picture</b> objects, having identical 
images, using code that you have seen before.&nbsp; As you can see, both <b>
Picture</b> object extract an image from the same image file, so the <b>
BufferedImage</b> objects in both <b>Picture</b> objects contain the same 
combination of colored pixels.</p>
<p><font color="#FF0000">
<b>Scale the green color component using bit manipulations</b></font></p>
<p>Listing 27 uses the <b>getBasicPixel</b> and <b>setBasicPixel</b> methods, in 
conjunction with a pair of nested <b>for</b> loop to scale the green color 
component in each row as described above.</p>
<p>
<b><a name="Listing_27">Listing 27</a>. Scale the green color component using 
bit manipulations. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>
    //Declare some working constants and variables.
    final int maskA = 0x0000FF00;//green only
    final int maskB = 0xFFFF00FF;//all but green
    int pixA = 0;
    int greenByte = 0;

    for(int row = 0;row &lt; pic1.getHeight();row++){
      for(int col = 0;col &lt; pic1.getWidth();col++){
        //Working at the bit level, scale the green byte
        // by 0.0 in the first row and 1.0 in the last row
        // with proportional scaling in between.
        pixA = pic1.getBasicPixel(col,row);
        greenByte =
             (int)(((pixA & maskA) &gt;&gt; 8)* row/255.0) &lt;&lt; 8;
        pic1.setBasicPixel(
                      col,row,(pixA & maskB) | greenByte);
      }//end inner for loop
    }//end outer for loop
    pic1.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Won't explain the bit manipulation code</b></font></p>
<p>It is not my purpose in this lesson to teach you how to do bit manipulations 
in Java.&nbsp; If you don't understand the code in Listing 27, you 
should review Java bit manipulations.&nbsp; <i>(See, for example, my earlier 
lesson titled The AWT Package, Graphics - 
Overview of Advanced Image Processing Capabilities in <a href="#Resources">
Resources</a>.)</i></p>
<p>For the purposes of this lesson, the important thing is to 
compare the complexity of the code 
inside the nested <b>for</b> loops in Listing 27 with the code inside the nested
<b>for</b> loops in Listing 28.</p>
<p><font color="#FF0000">
<b>Scale the green color component using the getPixel method</b></font></p>
<p>Listing 28 scales the green color component in each pixel by repetitively calling the <b>getPixel</b> 
method to get a reference to an object of the <b>Pixel</b> class representing 
each pixel.&nbsp; Then the
<b>getGreen</b> and <b>setGreen</b> methods are called on the <b>Pixel</b> 
object to scale the green color component in the pixel.</p>
<p>
<b><a name="Listing_28">Listing 28</a>. Scale the green color component using 
the getPixel method and methods of the Pixel class. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>    //Do the same thing to the other picture working at
    // the Pixel level.
    Pixel pixB = null;
    int greenValue = 0;
    for(int row = 0;row &lt; pic2.getHeight();row++){
      for(int col = 0;col &lt; pic2.getWidth();col++){
        pixB = pic2.getPixel(col,row);
        greenValue = (int)(pixB.getGreen() * row/255.0);
        pixB.setGreen(greenValue);
      }//end inner for loop
    }//end outer for loop
    pic2.show();

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Source code for the getPixel method</b></font></p>
<p>The source code for the <b>getPixel</b> method is shown in Listing 29.</p>
<p>
<b><a name="Listing_29">Listing 29</a>. Source code for the getPixel method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre> /**
  * Method to get a pixel object for the given x and y
  * location
  * @param x  the x location of the pixel in the picture
  * @param y  the y location of the pixel in the picture
  * @return a Pixel object for this location
  */
 public Pixel getPixel(int x, int y)
 {
   // create the pixel object for this picture and the
   // given x and y location
   Pixel pixel = new Pixel(this,x,y);
   return pixel;
 }</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 29 instantiates a new object of the <b>Pixel</b> class representing 
the physical pixel at a specified coordinate position in the image and 
returns a reference to that <b>Pixel</b> object.</p>
<p><font color="#FF0000"><b>Get and set methods for color components are 
available</b></font></p>
<p>I will explain the <b>Pixel</b> class in detail in a future lesson.&nbsp; For 
now, suffice it to say that the <b>Pixel</b> class defines <i>get</i> and <i>set</i> methods 
that make it possible to manipulate each of the three color components in the manner 
shown in Listing 28.&nbsp; For example, the <b>getGreen</b> method returns the 
value of the green color component as an eight-bit integer value stored in the 
least significant eight bits of a value of type <b>int</b>.</p>
<p>The <b>setGreen</b> method requires an incoming parameter of type <b>int</b> 
that contains the eight-bit value of the green color component as the least 
significant eight bits of the incoming parameter.&nbsp; This method causes that 
value to be set into the appropriate group of eight bits that represent the 
green color component in the <b>int</b> value that represents the pixel.</p>
<p>Note that no bit 
shifting is required to use either of these methods.&nbsp; Note also that there is no 
requirement for knowledge of how&nbsp;&nbsp;&nbsp;&nbsp; the color components are stored in the integer that represents a pixel.</p>
<p><font color="#ff0000"><b>The end of the program named Java354c</b></font></p>
<p>Listing 28 signals the end of the <b>run</b> method, the end of the <b>Runner</b> 
class, and the end of the program named Java354c.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 33 through Listing 35, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>As my first attempt to explain the <b>Picture</b> class 
and the <b>SimplePicture</b> class, this lesson has illustrated and explained 
the thirteen methods that are declared in the <b>DigitalPicture</b> interface in 
terms of how those methods are defined in the <b>SimplePicture</b> class.&nbsp; 
The lesson also explained methods that are called by those thirteen methods.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn how the <b>show</b> method of the <b>
Picture</b> class causes the image contained in a <b>Picture</b> object to be 
displayed on the screen in a <b>JFrame</b> object.&nbsp; You will also learn 
about the the <b>PictureFrame</b> class, which serves as an intermediary between 
the <b>Picture</b> object and the <b>JFrame</b> object.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 30 through Listing 35 below.
<p>
<b><a name="Listing_30">Listing 30</a>. Source code for Ericson's Picture class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.text.*;

/**
 * A class that represents a picture.  This class inherits
 * from SimplePicture and allows the student to add 
 * functionality to the Picture class.
 *
 * Copyright Georgia Institute of Technology 2004-2005
 * @author Barbara Ericson ericson@cc.gatech.edu
 */
public class Picture extends SimplePicture
{
  ///////////////////// constructors /////////////////////

  /**
   * Constructor that takes no arguments
   */
  public Picture ()
  {
    /* not needed but use it to show students the implicit
     * call to super()
     * child constructors always call a parent constructor
     */
    super();
  }

  /**
   * Constructor that takes a file name and creates the 
   * picture
   * @param fileName the name of the file to create the 
   * picture from
   */
  public Picture(String fileName)
  {
    // let the parent class handle this fileName
    super(fileName);
  }

  /**
   * Constructor that takes the width and height
   * @param width the width of the desired picture
   * @param height the height of the desired picture
   */
  public Picture(int width, int height)
  {
    // let the parent class handle this width and height
    super(width,height);
  }

  /**
   * Constructor that takes a picture and creates a
   * copy of that picture
   */
  public Picture(Picture copyPicture)
  {
    // let the parent class do the copy
    super(copyPicture);
  }

  /**
   * Constructor that takes a buffered image
   * @param image the buffered image to use
   */
  public Picture(BufferedImage image)
  {
    super(image);
  }

  ////////////////////// methods /////////////////////////

  /**
   * Method to return a string with information about this
   * picture.
   * @return a string with information about the picture 
   * such as fileName, height and width.
   */
  public String toString()
  {
    String output = 
      "Picture, filename " + getFileName() +
      " height " + getHeight()
      + " width " + getWidth();
    return output;

  }

} // this } is the end of class Picture, put all new 
  // methods before this</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_31.">Listing 31.</a> Source code for Ericson's SimplePicture class.</b><table border="1" cols="1" width="477" bgcolor="#ffffbb">
  <tbody>
    <tr>
      <td>
      <pre>import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import java.awt.*;
import java.io.*;
import java.awt.geom.*;

/**
 * A class that represents a simple picture.  A simple
 * picture may have an associated file name and a title.
 * A simple picture has pixels, width, and height.  A
 * simple picture uses a BufferedImage to hold the pixels.
 * You can show a simple picture in a PictureFrame (a
 * JFrame).
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class SimplePicture implements DigitalPicture
{

  /////////////////////// Fields /////////////////////////

  /**
   * the file name associated with the simple picture
   */
  private String fileName;

  /**
   * the title of the simple picture
   */
  private String title;

  /**
   * buffered image to hold pixels for the simple picture
   */
  private BufferedImage bufferedImage;

  /**
   * frame used to display the simple picture
   */
  private PictureFrame pictureFrame;

  /**
   * extension for this file (jpg or bmp)
   */
  private String extension;


 /////////////////////// Constructors ////////////////////

 /**
  * A Constructor that takes no arguments.  All fields
  * will be null. A no-argument constructor must be given
  * in order for a class to be able to be subclassed.  By
  * default all subclasses will implicitly call this in
  * their parent's no argument constructor unless a
  * different call to super() is explicitly made as the
  * first line of code in a constructor.
  */
 public SimplePicture()
 {this(200,100);}

 /**
  * A Constructor that takes a file name and uses the
  * file to create a picture
  * @param fileName the file name to use in creating the
  * picture
  */
 public SimplePicture(String fileName)
 {

   // load the picture into the buffered image
   load(fileName);

 }

 /**
  * A constructor that takes the width and height desired
  * for a picture and creates a buffered image of that
  * size.  This constructor doesn't  show the picture.
  * @param width the desired width
  * @param height the desired height
  */
 public  SimplePicture(int width, int height)
 {
   bufferedImage = new BufferedImage(
               width, height, BufferedImage.TYPE_INT_RGB);
   title = "None";
   fileName = "None";
   extension = "jpg";
   setAllPixelsToAColor(Color.white);
 }

 /**
  * A constructor that takes the width and height desired
  * for a picture and creates a buffered image of that
  * size.  It also takes the color to use for the
  * background of the picture.
  * @param width the desired width
  * @param height the desired height
  * @param theColor the background color for the picture
  */
 public  SimplePicture(
                    int width, int height, Color theColor)
 {
   this(width,height);
   setAllPixelsToAColor(theColor);
 }

 /**
  * A Constructor that takes a picture to copy
  * information from
  * @param copyPicture the picture to copy from
  */
 public SimplePicture(SimplePicture copyPicture)
 {
   if (copyPicture.fileName != null)
   {
      this.fileName = new String(copyPicture.fileName);
      this.extension = copyPicture.extension;
   }
   if (copyPicture.title != null)
      this.title = new String(copyPicture.title);
   if (copyPicture.bufferedImage != null)
   {
     this.bufferedImage =
                 new BufferedImage(copyPicture.getWidth(),
                                  copyPicture.getHeight(),
                              BufferedImage.TYPE_INT_RGB);
     this.copyPicture(copyPicture);
   }
 }

 /**
  * A constructor that takes a buffered image
  * @param image the buffered image
  */
 public SimplePicture(BufferedImage image)
 {
   this.bufferedImage = image;
   title = "None";
   fileName = "None";
   extension = "jpg";
 }

 ////////////////////////// Methods //////////////////////

 /**
  * Method to get the extension for this picture
  * @return the extendsion (jpg or bmp)
  */
 public String getExtension() { return extension; }


 /**
  * Method that will copy all of the passed source
  * picture into the current picture object
  * @param sourcePicture  the picture object to copy
  */
 public void copyPicture(SimplePicture sourcePicture)
 {
   Pixel sourcePixel = null;
   Pixel targetPixel = null;

   // loop through the columns
   for (int sourceX = 0, targetX = 0;
        sourceX &LT; sourcePicture.getWidth() &&
        targetX &LT; this.getWidth();
        sourceX++, targetX++)
   {
     // loop through the rows
     for (int sourceY = 0, targetY = 0;
          sourceY &LT; sourcePicture.getHeight() &&
          targetY &LT; this.getHeight();
          sourceY++, targetY++)
     {
       sourcePixel =
                  sourcePicture.getPixel(sourceX,sourceY);
       targetPixel = this.getPixel(targetX,targetY);
       targetPixel.setColor(sourcePixel.getColor());
     }
   }

 }

 /**
  * Method to set the color in the picture to the passed
  * color
  * @param color the color to set to
  */
 public void setAllPixelsToAColor(Color color)
 {
   // loop through all x
   for (int x = 0; x &LT; this.getWidth(); x++)
   {
     // loop through all y
     for (int y = 0; y &LT; this.getHeight(); y++)
     {
       getPixel(x,y).setColor(color);
     }
   }
 }

 /**
  * Method to get the buffered image
  * @return the buffered image
  */
 public BufferedImage getBufferedImage()
 {
    return bufferedImage;
 }

 /**
  * Method to get a graphics object for this picture to
  * use to draw on
  * @return a graphics object to use for drawing
  */
 public Graphics getGraphics()
 {
   return bufferedImage.getGraphics();
 }

 /**
  * Method to get a Graphics2D object for this picture
  * which can be used to do 2D drawing on the picture
  */
 public Graphics2D createGraphics()
 {
   return bufferedImage.createGraphics();
 }

 /**
  * Method to get the file name associated with the
  * picture
  * @return  the file name associated with the picture
  */
 public String getFileName() { return fileName; }

 /**
  * Method to set the file name
  * @param name the full pathname of the file
  */
 public void setFileName(String name)
 {
   fileName = name;
 }

 /**
  * Method to get the title of the picture
  * @return the title of the picture
  */
 public String getTitle()
 { return title; }

 /**
  * Method to set the title for the picture
  * @param title the title to use for the picture
  */
 public void setTitle(String title)
 {
   this.title = title;
   if (pictureFrame != null)
       pictureFrame.setTitle(title);
 }

 /**
  * Method to get the width of the picture in pixels
  * @return the width of the picture in pixels
  */
 public int getWidth(){ return bufferedImage.getWidth(); }

 /**
  * Method to get the height of the picture in pixels
  * @return  the height of the picture in pixels
  */
 public int getHeight(){
  return bufferedImage.getHeight();
 }

 /**
  * Method to get the picture frame for the picture
  * @return the picture frame associated with this
  * picture (it may be null)
  */
 public PictureFrame getPictureFrame()
                                  { return pictureFrame; }

 /**
  * Method to set the picture frame for this picture
  * @param pictureFrame the picture frame to use
  */
 public void setPictureFrame(PictureFrame pictureFrame)
 {
   // set this picture objects' picture frame to the
   // passed one
   this.pictureFrame = pictureFrame;
 }

 /**
  * Method to get an image from the picture
  * @return  the buffered image since it is an image
  */
 public Image getImage()
 {
   return bufferedImage;
 }

 /**
  * Method to return the pixel value as an int for the
  * given x and y location
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @return the pixel value as an integer (alpha, red,
  * green, blue)
  */
 public int getBasicPixel(int x, int y)
 {
    return bufferedImage.getRGB(x,y);
 }

 /**
  * Method to set the value of a pixel in the picture
  * from an int
  * @param x the x coordinate of the pixel
  * @param y the y coordinate of the pixel
  * @param rgb the new rgb value of the pixel (alpha, red,
  * green, blue)
  */
 public void setBasicPixel(int x, int y, int rgb)
 {
   bufferedImage.setRGB(x,y,rgb);
 }

 /**
  * Method to get a pixel object for the given x and y
  * location
  * @param x  the x location of the pixel in the picture
  * @param y  the y location of the pixel in the picture
  * @return a Pixel object for this location
  */
 public Pixel getPixel(int x, int y)
 {
   // create the pixel object for this picture and the
   // given x and y location
   Pixel pixel = new Pixel(this,x,y);
   return pixel;
 }

 /**
  * Method to get a one-dimensional array of Pixels for
  * this simple picture
  * @return a one-dimensional array of Pixel objects
  * starting with y=0
  * to y=height-1 and x=0 to x=width-1.
  */
 public Pixel[] getPixels()
 {
   int width = getWidth();
   int height = getHeight();
   Pixel[] pixelArray = new Pixel[width * height];

   // loop through height rows from top to bottom
   for (int row = 0; row &LT; height; row++)
     for (int col = 0; col &LT; width; col++)
       pixelArray[row * width + col] =
                                  new Pixel(this,col,row);

   return pixelArray;
 }



 /**
  * Method to load the buffered image with the passed
  * image
  * @param image  the image to use
  */
 public void load(Image image)
 {
   // get a graphics context to use to draw on the
   // buffered image
   Graphics2D graphics2d = bufferedImage.createGraphics();

   // draw the image on the buffered image starting
   // at 0,0
   graphics2d.drawImage(image,0,0,null);

   // show the new image
   show();
 }

 /**
  * Method to show the picture in a picture frame
  */
 public void show()
 {
    // if there is a current picture frame then use it
   if (pictureFrame != null)
     pictureFrame.updateImageAndShowIt();

   // else create a new picture frame with this picture
   else
     pictureFrame = new PictureFrame(this);
 }

 /**
  * Method to hide the picture
  */
 public void hide()
 {
   if (pictureFrame != null)
     pictureFrame.setVisible(false);
 }

 /**
  * Method to make this picture visible or not
  * @param flag true if you want it visible else false
  */
 public void setVisible(boolean flag)
 {
   if (flag)
     this.show();
   else
     this.hide();
 }

 /**
  * Method to open a picture explorer on a copy of this
  * simple picture
  */
 public void explore()
 {
   // create a copy of the current picture and explore it
   new PictureExplorer(new SimplePicture(this));
 }

 /**
  * Method to force the picture to redraw itself.  This is
  * very useful after you have changed the pixels in a
  * picture.
  */
 public void repaint()
 {
   // if there is a picture frame tell it to repaint
   if (pictureFrame != null)
     pictureFrame.repaint();

   // else create a new picture frame
   else
     pictureFrame = new PictureFrame(this);
 }

 /**
  * Method to load the picture from the passed file name
  * @param fileName the file name to use to load the
  * picture from
  */
 public void loadOrFail(
                       String fileName) throws IOException
 {
    // set the current picture's file name
   this.fileName = fileName;

   // set the extension
   int posDot = fileName.indexOf('.');
   if (posDot &gt;= 0)
     this.extension = fileName.substring(posDot + 1);

   // if the current title is null use the file name
   if (title == null)
     title = fileName;

   File file = new File(this.fileName);

   if (!file.canRead())
   {
     // try adding the media path
     file = new File(
                 FileChooser.getMediaPath(this.fileName));
     if (!file.canRead())
     {
       throw new IOException(this.fileName + " could not"
       + " be opened. Check that you specified the path");
     }
   }

   bufferedImage = ImageIO.read(file);
 }


 /**
  * Method to write the contents of the picture to a file
  * with the passed name without throwing errors
  * (THIS MAY NOT BE A VALID DESCRIPTION - RGB)
  * @param fileName the name of the file to write the
  * picture to
  * @return true if success else false
  */
 public boolean load(String fileName)
 {
     try {
         this.loadOrFail(fileName);
         return true;

     } catch (Exception ex) {
         System.out.println("There was an error trying"
                                + " to open " + fileName);
         bufferedImage = new BufferedImage(600,200,
                              BufferedImage.TYPE_INT_RGB);
         addMessage("Couldn't load " + fileName,5,100);
         return false;
     }

 }


 /**
  * Method to load the picture from the passed file name
  * this just calls load(fileName) and is for name
  * compatibility
  * @param fileName the file name to use to load the
  * picture from
  * @return true if success else false
  */
 public boolean loadImage(String fileName)
 {
     return load(fileName);
}

 /**
  * Method to draw a message as a string on the buffered
  * image
  * @param message the message to draw on the buffered
  * image
  * @param xPos  the leftmost point of the string in x
  * @param yPos  the bottom of the string in y
  */
 public void addMessage(
                       String message, int xPos, int yPos)
 {
   // get a graphics context to use to draw on the
   // buffered image
   Graphics2D graphics2d = bufferedImage.createGraphics();

   // set the color to white
   graphics2d.setPaint(Color.white);

   // set the font to Helvetica bold style and size 16
   graphics2d.setFont(new Font("Helvetica",Font.BOLD,16));

   // draw the message
   graphics2d.drawString(message,xPos,yPos);

 }

 /**
  * Method to draw a string at the given location on the
  * picture
  * @param text the text to draw
  * @param xPos the left x for the text
  * @param yPos the top y for the text
  */
 public void drawString(String text, int xPos, int yPos)
 {
   addMessage(text,xPos,yPos);
 }

 /**
   * Method to create a new picture by scaling the
   * current picture by the given x and y factors
   * @param xFactor the amount to scale in x
   * @param yFactor the amount to scale in y
   * @return the resulting picture
   */
  public Picture scale(double xFactor, double yFactor)
  {
    // set up the scale tranform
    AffineTransform scaleTransform =
                                    new AffineTransform();
    scaleTransform.scale(xFactor,yFactor);

    // create a new picture object that is the right size
    Picture result = new Picture(
                           (int) (getWidth() * xFactor),
                           (int) (getHeight() * yFactor));

    // get the graphics 2d object to draw on the result
    Graphics graphics = result.getGraphics();
    Graphics2D g2 = (Graphics2D) graphics;

    // draw the current image onto the result image
    // scaled
    g2.drawImage(this.getImage(),scaleTransform,null);

    return result;
  }

  /**
   * Method to create a new picture of the passed width.
   * The aspect ratio of the width and height will stay
   * the same.
   * @param width the desired width
   * @return the resulting picture
   */
  public Picture getPictureWithWidth(int width)
  {
    // set up the scale tranform
    double xFactor = (double) width / this.getWidth();
    Picture result = scale(xFactor,xFactor);
    return result;
  }

  /**
   * Method to create a new picture of the passed height.
   * The aspect ratio of the width and height will stay
   * the same.
   * @param height the desired height
   * @return the resulting picture
   */
  public Picture getPictureWithHeight(int height)
  {
    // set up the scale tranform
    double yFactor = (double) height / this.getHeight();
    Picture result = scale(yFactor,yFactor);
    return result;
  }

 /**
  * Method to load a picture from a file name and show it
  * in a picture frame
  * @param fileName the file name to load the picture
  * from
  * @return true if success else false
  */
 public boolean loadPictureAndShowIt(String fileName)
 {
   boolean result = true;// the default is that it worked

   // try to load the picture into the buffered image from
   // the file name
   result = load(fileName);

   // show the picture in a picture frame
   show();

   return result;
 }

 /**
  * Method to write the contents of the picture to a file
  * with the passed name
  * @param fileName the name of the file to write the
  * picture to
  */
 public void writeOrFail(String fileName)
                                        throws IOException
 {
   //the default is current
   String extension = this.extension;

   // create the file object
   File file = new File(fileName);
   File fileLoc = file.getParentFile();

   // canWrite is true only when the file exists
   // already! (alexr)
   if (!fileLoc.canWrite()) {
       // System.err.println(
       // "can't write the file but trying anyway? ...");
        throw new IOException(fileName +
        " could not be opened. Check to see if you can"
        + " write to the directory.");
   }

   // get the extension
   int posDot = fileName.indexOf('.');
   if (posDot &gt;= 0)
       extension = fileName.substring(posDot + 1);

   //write the contents of the buffered image to the file
   // as jpeg
   ImageIO.write(bufferedImage, extension, file);

 }

 /**
  * Method to write the contents of the picture to a file
  * with the passed name without throwing errors
  * @param fileName the name of the file to write the
  * picture to
  * @return true if success else false
  */
 public boolean write(String fileName)
 {
     try {
         this.writeOrFail(fileName);
         return true;
     } catch (Exception ex) {
         System.out.println(
                     "There was an error trying to write "
                     + fileName);
         return false;
     }

 }

 /**
  * Method to set the media path by setting the directory
  * to use
  * @param directory the directory to use for the media
  * path
  */
 public static void setMediaPath(String directory) {
   FileChooser.setMediaPath(directory);
 }

 /**
  * Method to get the directory for the media
  * @param fileName the base file name to use
  * @return the full path name by appending
  * the file name to the media directory
  */
 public static String getMediaPath(String fileName) {
   return FileChooser.getMediaPath(fileName);
 }

  /**
   * Method to get the coordinates of the enclosing
   * rectangle after this transformation is applied to
   * the current picture
   * @return the enclosing rectangle
   */
  public Rectangle2D getTransformEnclosingRect(
                                    AffineTransform trans)
  {
    int width = getWidth();
    int height = getHeight();
    double maxX = width - 1;
    double maxY = height - 1;
    double minX, minY;
    Point2D.Double p1 = new Point2D.Double(0,0);
    Point2D.Double p2 = new Point2D.Double(maxX,0);
    Point2D.Double p3 = new Point2D.Double(maxX,maxY);
    Point2D.Double p4 = new Point2D.Double(0,maxY);
    Point2D.Double result = new Point2D.Double(0,0);
    Rectangle2D.Double rect = null;

    // get the new points and min x and y and max x and y
    trans.deltaTransform(p1,result);
    minX = result.getX();
    maxX = result.getX();
    minY = result.getY();
    maxY = result.getY();
    trans.deltaTransform(p2,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p3,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());
    trans.deltaTransform(p4,result);
    minX = Math.min(minX,result.getX());
    maxX = Math.max(maxX,result.getX());
    minY = Math.min(minY,result.getY());
    maxY = Math.max(maxY,result.getY());

    // create the bounding rectangle to return
    rect = new Rectangle2D.Double(
              minX,minY,maxX - minX + 1, maxY - minY + 1);
    return rect;
  }

 /**
  * Method to return a string with information about this
  * picture
  * @return a string with information about the picture
  */
 public String toString()
 {
   String output =
     "Simple Picture, filename " + fileName +
     " height " + getHeight() + " width " + getWidth();
   return output;
 }

} // end of SimplePicture class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_32">Listing 32</a>. Source code for Ericson's DigitalPicture interface.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.Image;
import java.awt.image.BufferedImage;

/**
 * Interface to describe a digital picture.  A digital
 * picture can have a associated file name.  It can have
 * a title.  It has pixels associated with it and you can
 * get and set the pixels.  You can get an Image from a
 * picture or a BufferedImage.  You can load it from a
 * file name or image.  You can show a picture.  You can 
 * create a new image for it.
 * 
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public interface DigitalPicture 
{
 // get the file name that the picture came from  
 public String getFileName(); 
 
 // get the title of the picture 
 public String getTitle(); 

 // set the title of the picture
 public void setTitle(String title); 

 // get the width of the picture in pixels
 public int getWidth(); 

 // get the height of the picture in pixels
 public int getHeight(); 

 // get the image from the picture
 public Image getImage(); 

 // get the buffered image
 public BufferedImage getBufferedImage(); 

 // get the pixel information as an int   
 public int getBasicPixel(int x, int y); 

 // set the pixel information
 public void setBasicPixel(int x, int y, int rgb); 

 // get the pixel information as an object
 public Pixel getPixel(int x, int y); 

 // load the image into the picture
 public void load(Image image); 

 // load the picture from a file
 public boolean load(String fileName); 

 // show the picture 
 public void show(); 
}</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_33">Listing 33</a>. Source code for the program named 
Java354a. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>/*Program Java354a
Copyright R.G.Baldwin 2009

The purpose of this program is to illustrate the use of
several of the methods that are declared in the
DigitalPicture interface as implemented in the Picture
class.

One Picture object is constructed by using a Picture
constructor that accepts the name of an image file as a
parameter and uses the image from that file as the
image in the Picture object. The picture is displayed by
calling the show method on the Picture object.

In this case, the title is automatically set to the name
of the image file.

A second Picture object is constructed by using a Picture
constructor that accepts the dimensions of the Picture
object only and constructs a Picture object with a default
all-white image. The size of the Picture object that is
constructed is only 1x1.

Then the load method that takes the name of an image file
is called to load the image from an image file into the
small Picture object. The size of the picture object
changes to accommodate the size of the image.

In this case, the default title is "None". The setTitle 
and getFileName methods are used to set the title for the
picture. Then the explore method is called to display the
Picture object with its new image and title.

Note that if you call the show method on a picture,
modify the picture, and call the show method on the 
picture again, only one copy of the picture is displayed 
and the results may not be what you expect to see.
However, displaying the picture in the explore format, 
modifying it, and then displaying it again in the show 
format seems to work OK.

A pair of nested for loops is used in conjunction with the
getBasicPixel and setBasicPixel methods to copy the right
half of the image in the first Picture object into the
left half of the second Picture object, leaving the right
half of the second Picture object undisturbed.

Then the show method is called on the modified second
picture object to display it.

Note that both image files are in the current directory.

Along the way, the program calls methods dealing with the
file name and the title and eventually prints that
information on the system console.

The following methods from the DigitalPicture interface
are used in this program.
* String getFileName()
* String getTitle()
* void setTitle(String title)
* int getWidth()
* int getHeight()
* int getBasicPixel(int x, int y)
* void setBasicPixel(int x, int y, int rgb)
* boolean load(String fileName)
* void show()

The following methods that are declared in the
DigitalPicture interface are not used in this program.
* Image getImage()
* BufferedImage getBufferedImage()
* Pixel getPixel(int x, int y)
* void load(Image image)

Tested using Windows Vista Premium Home edition and
Ericson's multimedia library.
*********************************************************/

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  void run(){
    //Construct a new 341x256 Picture object providing the
    // name of an image file as a parameter.
    Picture pix1 = new Picture("ScaledAquarium.gif");
    pix1.show();//display the picture in the show format

    //Create a new small Picture object with a default
    // all-white image. It must be at least 1x1 or a
    // runtime error will occur.
    Picture pix2 = new Picture(1,1);
    
    //Load a 341x256 image from a jpg file into the small
    // Picture object. Note that the size of the Picture
    // object increases or decreases to accommodate the
    // size of the image.
    pix2.load("ScaledBeach.jpg");
    
    //Set the title of the picture.
    pix2.setTitle("pix2: " + pix2.getFileName());
    
    //Note that if you call the show method on a picture,
    // modify the picture, and call the show method on the
    // picture again, only one copy of the picture is
    // displayed and the results may not be what you
    // expect to see. However, displaying the picture in
    // the explore format, modifying it, and then
    // displaying it again in the show format seems to
    // work OK.
    pix2.explore();

    //Use the getBasicPixel and setBasicPixel methods to
    // copy the right half of the image from pix1 into the
    // left half of pix2, leaving the right half of pix2 
    // undisturbed.
    for(int row = 0;row &lt; pix1.getHeight();row++){
      for(int col = 0;col &lt; pix2.getWidth()/2;col++){
        pix2.setBasicPixel(col,row,pix1.getBasicPixel(
                            col + pix1.getWidth()/2,row));
      }//end inner for loop
    }//end outer for loop
    //Display the final result.
    pix2.show();

    //Display some text on the system console.
    System.out.println(pix1);
    System.out.println("pix1 Filename: "
                                    + pix1.getFileName());
    System.out.println(pix2);
    System.out.println("pix2 FileName: "
                                    + pix2.getFileName());
    System.out.println("pix1 Title: " + pix1.getTitle());
    System.out.println("pix2 Title: " + pix2.getTitle());

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_34">Listing 34</a>. Source code for the program named 
Java354b. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>/*Program Java354b
Copyright R.G.Baldwin 2009

The purpose of this program is to illustrate the use of
several of the methods that are declared in the
DigitalPicture interface as implemented in the Picture
class.

The earlier program named Java354a illustrated the use of
all but the following four methods that are declared in
the DigitalPicture interface
* Image getImage()
* BufferedImage getBufferedImage()
* void load(Image image)
* Pixel getPixel(int x, int y)

This program creates and displays four Picture objects
using the first three methods in the above list, leaving
only the following method to be illustrated in another
program.
* Pixel getPixel(int x, int y)

Tested using Windows Vista Premium Home edition and
Ericson's multimedia library.
*********************************************************/
import java.awt.Image;
public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor.
    Picture pix1 = new Picture("ScaledAquarium.gif");
    pix1.setTitle("pix1");
    pix1.show();

    //Construct another new 341x256 Picture object by
    // providing the name of an image file as a parameter
    // to the Picture constructor.
    Picture pix2 = new Picture("ScaledBeach.jpg");
    pix2.setTitle("pix2");
    pix2.show();

    //Construct a third new 341x256 Picture object by
    // extracting the BufferedImage object from pix1 and
    // passing it as a parameter to the constructor for
    // the Picture constructor.
    Picture pix3 = new Picture(pix1.getBufferedImage());
    pix3.setTitle("pix3");
    pix3.show();

    //Construct a fourth new 341x256 Picture object by
    // starting with an all-white Picture object and
    // loading an image extracted from pix2.
    Image image = pix2.getImage();

    //Note that unlike the load method that takes a file
    // name as a parameter, this version of the load
    // method does not automatically set the size of the
    // Picture object to match the size of the image.
    //Get the size of the image and pass those dimensions
    // to the constructor for the Picture object.
    Picture pix4 = new Picture(image.getWidth(null),
                               image.getHeight(null));
    //Now load the image into the Picture object and
    // display the picture.
    pix4.load(image);
    pix4.setTitle("pix4");
    pix4.show();

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_35">Listing 35</a>. Source code for the program named 
Java354c. </b>
<table border="1" cols="1" width="477" bgcolor="#ddffff">
  <tbody>
    <tr>
      <td>
      <pre>/*Program Java354c
Copyright R.G.Baldwin 2009

The programs named Java354a and Java354b illustrated all
of the methods declared in the DigitalPicture interface
other than the getPixel method.

The purpose of this program is to illustrate the use of
the getPixel method as implemented in the Picture class,
and to compare its use with the getBasicPixel and
setBasicPixel methods.

This program begins by creating two Picture objects
containing the same image. Then the program modifies the
green component for each row of one picture using the
getBasicPixel and setBasicPixel methods. This approach
requires a programming knowledge of bit manipulations.

Then the program does the same thing to the other picture
using the getPixel method and methods of the Pixel class.
This illustrates the reduction in complexity achieved
by using the getPixel method in place of the getBasicPixel
method.

Both approaches require three statements inside a pair of
nested for loops, but the three statements involving bit
manipulations are much more complex. Both processes
produce the same visual result.

With regard to the modification of the green color
component in the two pictures, the green color component
is scaled by zero for every pixel in the first row and is
scaled by 1.0 for every pixel in the bottom row with the
scale factors between the first and last row being
proportional to the row number. This results in an image
with a purple tinge at the top and the correct colors at
the bottom.

Tested using Windows Vista Premium Home edition and
Ericson's multimedia library.
*********************************************************/
import java.awt.Image;
public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  void run(){
    //Construct a new 341x256 Picture object by providing
    // the name of an image file as a parameter to the
    // Picture constructor.
    Picture pic1 = new Picture("ScaledBeach.jpg");
    pic1.setTitle("pic1");
    pic1.explore();

    //Construct another new 341x256 Picture object by
    // providing the name of an image file as a parameter
    // to the Picture constructor.
    Picture pic2 = new Picture("ScaledBeach.jpg");
    pic2.setTitle("pic2");
    pic2.explore();

    //Modify the green component for each row separately
    // using the getBasicPixel and setBasicPixel methods.
    // This approach requires a programming knowledge of
    // bit manipulations.
    //Do the same thing using the getPixel method to
    // illustrate the reduction in complexity achieved
    // by using the getPixel method.
    //Both approaches require three statements inside a
    // pair of nested for loops, but the three statements
    // involving bit manipulations are much more complex.
    //Note that both Picture objects contain the same
    // image and both processes produce the same visual
    // output.

    //The green color component is scaled by zero for
    // every pixel in the first row and is scaled by
    // 1.0 for every pixel in the bottom row with the
    // scale factors between the first and last row being
    // proportional to the row number. This results in an
    // image with a purple tinge at the top and the
    // correct colors at the bottom.

    //Declare some working constants and variables.
    final int maskA = 0x0000FF00;//green only
    final int maskB = 0xFFFF00FF;//all but green
    int pixA = 0;
    int greenByte = 0;



    for(int row = 0;row &lt; pic1.getHeight();row++){
      for(int col = 0;col &lt; pic1.getWidth();col++){
        //Working at the bit level, scale the green byte
        // by 0.0 in the first row and 1.0 in the last row
        // with proportional scaling in between.
        pixA = pic1.getBasicPixel(col,row);
        greenByte =
             (int)(((pixA & maskA) &gt;&gt; 8)* row/255.0) &lt;&lt; 8;
        pic1.setBasicPixel(
                      col,row,(pixA & maskB) | greenByte);
      }//end inner for loop
    }//end outer for loop
    pic1.show();

    //Do the same thing to the other picture working at
    // the Pixel level.
    Pixel pixB = null;
    int greenValue = 0;
    for(int row = 0;row &lt; pic2.getHeight();row++){
      for(int col = 0;col &lt; pic2.getWidth();col++){
        //Working at the Pixel level, do the same thing.
        pixB = pic2.getPixel(col,row);
        greenValue = (int)(pixB.getGreen() * row/255.0);
        pixB.setGreen(greenValue);
      }//end inner for loop
    }//end outer for loop
    pic2.show();

  }//end run
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
