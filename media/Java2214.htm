<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">An improved approach for creating SVG/XML code and SVG/XML 
DOM nodes using Java</h2>
<i>Continuing with the SVG graphics library from the previous lesson, learn to 
write a method that deals with the escape sequences required for the quotation 
marks that surround attribute values in XML and a method that makes it possible 
to create a general node in the DOM tree being used to represent an SVG graphic.</i>
<p><b>Published:</b>&nbsp; March 13, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2214</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_Svg07_program">The Svg07 program</a></li>
		<li><a href="#The_Svg08_program">The Svg08 program</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p> This is the second lesson in a series designed to teach you how to write 
servlets to produce SVG code that will be rendered in graphic form by an 
SVG-compatible browser.</p>
<p> <font color="#FF0000"><b>An SVG graphics library</b></font></p>
<p> In the previous lesson titled &quot;Java JAXP, Creating graphics using Java and 
SVG&quot; <i>(see <a href="#Resources">Resources</a>)</i> I taught you how write your 
own SVG graphics library to eliminate, or at least alleviate the requirement to 
write raw XML code or raw JAXP DOM code, making it possible for you to produce 
SVG output simply by making typical Java method calls.</p>
<p> At the end of the previous lesson, I promised that this lesson would teach 
you how to take what you learned in the previous lesson and apply it to the 
generation of XHTML files containing in-line SVG/XML code.&nbsp; I also promised that 
this lesson would teach you how to apply that knowledge to the writing of 
servlets that produce XHTML output containing in-line SVG/XML code.&nbsp; Upon 
further consideration, however, I decided to delay that material until the 
lesson following this one.</p>
<p> <font color="#FF0000"><b>Upgrading the SVG graphics library</b></font></p>
<p> In this lesson, I will provide two more methods for the SVG graphics library 
that make it even easier to write servlets to produce SVG output.&nbsp; The 
first method eliminates the frustration of dealing with the escape sequences 
required for the quotation marks that surround attribute values in XML.&nbsp; 
The second method makes it possible to create a general node in the DOM tree 
being used to represent an SVG graphic.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.&nbsp; You may also find it useful 
to open a third browser window at the <a href="#Resources">Resources</a> section near the end of the 
document.&nbsp; That will make it easy for you to open those resources when they 
are mentioned in the text.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Svg07 screen output.</li>
	<li><a href="#Figure_2">Figure 2</a>. Recommended usage of the makeElement 
	method.</li>
	<li><a href="#Figure_3">Figure 3</a>. Graphic output from Svg08.</li>
	<li><a href="#Figure_4">Figure 4</a>. Recommended usage of the makeNode 
	method.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the class named Svg07.</li>
	<li><a href="#Listing_2">Listing 2</a>. The beginning of the makeElement 
	method.</li>
	<li><a href="#Listing_3">Listing 3</a>. Dealing with elements that have no 
	attributes.</li>
	<li><a href="#Listing_4">Listing 4</a>. Processing the attributes.</li>
	<li><a href="#Listing_5">Listing 5</a>. Decision: empty element or non-empty 
	element.</li>
	<li><a href="#Listing_6">Listing 6</a>. Remaining code in the main method.</li>
	<li><a href="#Listing_7">Listing 7</a>. Begin creating the DOM tree.</li>
	<li><a href="#Listing_8">Listing 8</a>. Create the root node named svg.</li>
	<li><a href="#Listing_9">Listing 9</a>. Beginning of the makeNode method.</li>
	<li><a href="#Listing_10">Listing 10</a>. Append new node to its parent.</li>
	<li><a href="#Listing_11">Listing 11</a>. Nodes that have no attributes.</li>
	<li><a href="#Listing_12">Listing 12</a>. Processing the attribute names and 
	values.</li>
	<li><a href="#Listing_13">Listing 13</a>. Show outline of the canvas.</li>
	<li><a href="#Listing_14">Listing 14</a>. Create a group container named g.</li>
	<li><a href="#Listing_15">Listing 15</a>. Draw a blue line.</li>
	<li><a href="#Listing_16">Listing 16</a>. The makeLine method. </li>
	<li><a href="#Listing_17">Listing 17</a>. Draw the black ellipse.</li>
	<li><a href="#Listing_18">Listing 18</a>. The makeEllipse method.</li>
	<li><a href="#Listing_19">Listing 19</a>. Draw the red ellipse.</li>
	<li><a href="#Listing_20">Listing 20</a>. Draw the green rotated ellipse.</li>
	<li><a href="#Listing_21">Listing 21</a>. Transform the DOM and write the 
	output file.</li>
	<li><a href="#Listing_22">Listing 22</a>. The program named Svg07.</li>
	<li><a href="#Listing_23">Listing 23</a>. The program named Svg08.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#FF0000"><b>According to the W3C</b></font></p>
<p>&quot;SVG is a language for describing two-dimensional graphics in XML. SVG allows 
for three types of graphic objects: vector graphic shapes (e.g., paths 
consisting of straight lines and curves), images and text. Graphical objects can 
be grouped, styled, transformed and composited into previously rendered objects. 
The feature set includes nested transformations, clipping paths, alpha masks, 
filter effects and template objects.&quot;</p>
<p><font color="#FF0000"><b>Not easy reading</b></font></p>
<p>The <a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a> is extensive.&nbsp; Unfortunately, a person needs a fairly 
strong background in XML to be able to understand much of the information in the 
specification, thereby reducing the accessibility of that information to Java 
programmers who lack such a background in XML.</p>
<p><font color="#FF0000"><b>Will present in a more understandable form</b></font></p>
<p>While I don't claim to have expertise in XML, I do know enough about the 
topic that I can usually make sense of the material provided in the SVG 
specification.&nbsp; One of my objectives for this series is to extract much of the important 
information from the specification and to present it in such a way as to make it 
accessible to Java programmers who lack a strong background in XML and who don't 
have the time available to gain that background knowledge.</p>
<p><font color="#FF0000"><b>The bottom line - great graphics in the browser</b></font></p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>No experience with IE/SVG plug-in</b><br />
  Please note that because I am not a frequent user of Internet Explorer, I have 
	not installed and tested the SVG plug-in for IE.&nbsp; The sample programs 
	in this series were tested using Firefox 1.5.&nbsp; I have read, however, 
	that IE can be made SVG compatible by installing the plug-in.</td></tr></table>
</td>
</tr>
</table>

The bottom line is that Java programs can be written to produce XML 
output, which, when presented to an SVG rendering engine, <i>(such as Firefox 1.5 or 
IE 6 with the SVG plug-in installed)</i>, will cause the display of graphic material 
in the following three categories:</p>
<ul>
	<li>Vector graphic shapes</li>
	<li>Images</li>
	<li>Text</li>
</ul>
<p>As a practical matter, when combined with the use of servlets, this makes it 
possible to display graphic material in the client area of a web browser that 
competes favorably with the graphic material that can be displayed using the 
Java 2D API in desktop applications.&nbsp; </p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Escape sequences for quotation marks</b><br />
  Actually, it isn't too difficult to write the code to create escape sequences 
	for quotation marks surrounding XML attributes.&nbsp; What I find difficult 
	is to understand that code when I have to go back and make sense of it 
	later.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>The program named Svg07</b></font></p>
<p>


Despite your best intentions, when you are writing Java programs that produce 
XML output, you must occasionally write an output statement that produces raw 
XML code, often in the form of a very complex XML element having multiple 
attributes.&nbsp; One of the most frustrating things about writing Java code to 
create elements in XML <i>(also XHTML and HTML)</i> is having to deal with the 
escape sequences for the many required quotation marks that surround attribute 
values.&nbsp; </p>
<p>The program named <b>Svg07</b> demonstrates a method that I will add to my 
SVG graphics library, which can be used to easily create XML elements without 
having to deal with those escape sequences.&nbsp; The elements produced by the 
method may or may not be empty, and may or may not have attributes.</p>
<p><font color="#FF0000"><b>The program named Svg08</b></font></p>
<p>The program named <b>Svg08</b> uses a similar technique as <b>Svg07</b> to deal with another issue that frequently 
surfaces when using Java to create SVG graphics.&nbsp; This issue has to do with 
the accommodation of a very large number of possible attributes that can be 
applied to each node in the DOM tree.</p>
<p><font color="#FF0000"><b>My original SVG graphics library</b></font></p>
<p>The previous lesson <i>(see <a href="#Resources">Resources</a>)</i> presented 
a small <i>proof-of-concept</i> SVG graphics library that provided method calls 
for the creation of the following DOM tree nodes:</p>
<ul>
	<li>A simple element with no attributes.</li>
	<li>A linear gradient element.</li>
	<li>An ellipse.</li>
	<li>A circle.</li>
</ul>
<p>Once the DOM tree representing a particular graphic image has been created, 
it can easily be transformed into an output SVG file containing the XML code 
required for rendering the graphic using an SVG rendering engine such as Firefox 1.5.</p>
<p><font color="#FF0000"><b>An expanded SVG graphics library</b></font></p>
<p>The next lesson in this series will expand my SVG graphics library to provide 
method calls for all of the <a href="http://www.w3.org/TR/SVG/shapes.html">Basic 
Shapes</a> in the SVG specification <i>(see <a href="#Resources">Resources</a>)</i>, plus some other elements as well.&nbsp; 
This will include the following basic shapes:</p>
<ul>
	<li>rect</li>
	<li>circle</li>
	<li>ellipse</li>
	<li>line</li>
	<li>polyline</li>
	<li>polygon</li>
</ul>
<p><font color="#FF0000"><b>Many attributes for each shape</b></font></p>
<p>When programming with raw SVG/XML code, there are a dozen or more attributes that can 
be applied to each shape when it is rendered.</p>
<p>A programmer calling a higher level method 
to create a shape, <i>(such as an ellipse for example)</i>, would usually prefer not to have to routinely deal 
with more than a dozen attributes for each ellipse.&nbsp; That programmer would 
probably prefer to routinely deal with only those attributes that are most 
likely to be different from one ellipse to the next.</p>
<p>Therefore, 
the methods in my SVG graphics library attempt to default most of the attributes 
and require the programmer to deal only with the attributes that are most likely 
to be different from one instance of the shape to the next.</p>
<p><font color="#FF0000"><b>Must provide a fallback position</b></font></p>
<p>Having taken that approach, however, it is necessary to provide the 
programmer with a method that can be used to create a shape dealing with 
all or any combination of the available attributes.&nbsp; The program named <b>
Svg08</b> demonstrates an SVG graphics method that can be used to create a 
general DOM tree node having any name and any number of attributes with any 
attribute names and any <b>String</b> value for each attribute.&nbsp; I will 
also add this method to my SVG graphics library to be used in the next and all 
subsequent lessons in this series.</p>
<p>This program produces an SVG file as its output.&nbsp; The file can be 
rendered using Firefox 1.5.&nbsp; Note, however, that the method is equally appropriate for 
use in producing XHTML output code, which I plan to explain in the next lesson.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_Svg07_program">The Svg07 program</a></h3>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>As I mentioned earlier, one of the most frustrating things about using Java 
to create raw code elements in XML, XHTML, or HTML is having to deal with the 
escape sequences for the many required quotation marks that surround attribute 
values.&nbsp; This program demonstrates a method that can be used to easily 
create raw XML code elements without having to deal with those escape sequences.&nbsp; 
The elements produced by the method may or may not be empty, and may or may not 
have attributes.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Color and boldface</b><br />
  The program named Svg07 does not produce the color and boldface shown in 
	Figure 1.&nbsp; I added those features manually to make it easier to refer 
	back to the contents of Figure 1 later.
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000">
 <b>Svg07 screen output</b></font></p>
<p>The screen output of the program named <b>Svg07</b> is shown in Figure 1.&nbsp;I will refer back to this screen output as I discuss the program code.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Svg07 screen output. </b>
<table border="1" cols="1" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
Demo empty element with attributes.
<b>&lt;ElementName color="Color.RED" width="10" height="20" /&gt;</b>

Demo empty element with no attributes.
Probably doesn't make any sense.
<b>&lt;ElementName /&gt;</b>

Demo non-empty element with attributes.
<b>&lt;ElementName color="Color.RED" width="10" height="20" &gt;</b>
<b><font color="#FF0000">Content of element.
&lt;/ElementName&gt;</font></b>

Demo non-empty element with no attributes.
<b>&lt;ElementName &gt;</b>
<b><font color="#FF0000">Content of element.
&lt;/ElementName></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This program was tested using J2SE 5.0 and WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As is my custom, I will discuss and explain this program in fragments.&nbsp; 
<i>(You can view the entire program in Listing 22 near the end of the lesson.)</i>&nbsp; The first fragment in Listing 1 shows the beginning of the class and the 
beginning of the <b>main</b> method.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the class named Svg07. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Svg07{
  public static void main(String argv[]){
    String name = "ElementName";
    System.out.println(
                   "Demo empty element with attributes.");

    String emptyElement = makeElement(true,name,
                         new String[]{"Color","Color.RED",
                                      "width","10",
                                      "height","20"});
    System.out.println(emptyElement);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>No requirement to program using the escape sequence</b></font></p>
<p>The code in Listing 1 produces the first block of output text shown in Figure 
1.&nbsp; Note the correspondence between the values in the elements of the array 
object of type <b>String[]</b> in Listing 1 and the attribute names and values 
in the first block of output text in Figure 1.&nbsp; Note also that there was no 
requirement in Listing 1 to create string data using the escape sequence for 
quotation marks as shown below:</p>
<p><pre>"color=\"Color.RED\" width=\"10\" height=\"20\""</pre></p>
<p>Instead, each attribute name and each attribute value was specified as a 
simple <b>String</b> in Listing 1, and the method named <b>makeElement</b> 
produced the required output format shown in the first block of text in Figure 
1.&nbsp; While this method is very simple, it is also extremely useful.&nbsp; <i>
(Sometimes the most useful things are the simplest.)</i></p>
<p><font color="#FF0000"><b>The method named makeElement</b></font></p>
<p>At this point, I am going to put the <b>main</b> method on the back burner 
and explain the method named <b>makeElement</b>.</p>
<p>As mentioned earlier, one of the most frustrating things about using Java to 
create raw elements in XML, XHTML, or HTML is having to deal with the escape 
sequences for the many required quotation marks that surround attribute values. 
The method named <b>makeElement</b> constructs an element, which may or may not 
have attributes. Also, the element may or may not be empty.</p>
<p>The user of this method does not have to deal with the required quotation 
marks surrounding attribute values and the corresponding escape sequences. </p>
<p><font color="#FF0000">
 <b>Recommended usage of the makeElement method</b></font></p>
<p>The recommended usage of the <b>makeElement</b> method is shown in Figure 2.&nbsp; </p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Recommended usage of the makeElement method. </b>
<table border="1" cols="1" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>String newElement = makeElement(
                         true/false,
                         name,
                         new String[]{"name","value",
                                      "name","value",
                                      "name","value",
                                      ...
                                      "name","value",
                                     });</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><i>(Note that the ellipses (...) in Figure 2 indicate that any number of 
name/value pairs is allowed.)</i></p>
<p><font color="#FF0000"><b>The first parameter to the method</b></font></p>
<p>The first parameter must be <i>true</i> if the element is empty and <i>false</i> 
if the element is not empty.</p>
<p>If the first parameter is true, the element is 
sealed off in the required manner for an empty element <i>(see the end of the 
black boldface text in the first block of text in Figure 1)</i>.</p>
<p>If the first parameter 
is false, the method returns the complete start tag for the element but does not 
return a complete element.&nbsp; <i>(See the black boldface text in the third 
and fourth blocks of text in Figure 1.)</i>&nbsp;&nbsp; In this case, it is the responsibility of the calling method to 
provide the content and the end tag for the element.&nbsp; <i>(See 
the red text in the third and fourth blocks of text in Figure 1.)</i></p>
<p><font color="#FF0000"><b>The second parameter to the method</b></font></p>
<p>The second parameter to the 
<b>makeElement</b> method must be a <b>String</b> that specifies the name of the element.</p>
<p><font color="#FF0000"><b>The third parameter to the method</b></font></p>
<p>The third 
parameter to the <b>makeElement</b> method must be a reference to an array object of type <b>String[]</b> 
or null.</p>
<p>This array must contain an even number of elements.&nbsp; Each pair of array elements 
constitutes the name and the value of an attribute, in the order <i>name, value, 
name, value,</i> etc.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Start tag for an element with no attributes</b><br />
  Although this is one of the possible combinations, it is probably easier to 
	hard-code such a start tag in the Java code rather than to make a call to 
	the makeElement method.</td></tr></table>
</td>
</tr>
</table>

If the reference to the array object is null and the first 
parameter is false, the method returns the start tag for an element that has no 
attributes and is not empty. <i>(See the black boldface text in the fourth block 
of text in Figure 1.)</i>&nbsp; </p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>An empty element with no attributes</b><br />
  This combination probably won't be heavily used because there isn't a lot of 
	demand for XML elements that are empty with no attributes.</td></tr></table>
</td>
</tr>
</table>

If the reference to the array object is null and the first parameter is 
true, the method returns a complete empty element with no attributes <i>(see the 
black boldface text in the second block of text in Figure 1)</i>.&nbsp; </p>
<p><font color="#FF0000"><b>The most useful combinations</b></font></p>
<p>Because the purpose of the method is to make it easier to deal with the 
quotation marks that must surround attribute values in XML elements, the most 
useful combinations are represented by the first and third blocks of text in 
Figure 1, which are respectively:</p>
<ul>
	<li>An empty element with attributes.</li>
	<li>An element with attributes that is not empty.</li>
</ul>
<p><font color="#FF0000">
<b>The beginning of the makeElement method</b></font></p>
<p>The method named <b>makeElement</b> begins in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. The beginning of the makeElement method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
<pre>  static String makeElement(boolean empty,
                            String elementName,
                            String[] data){

    //Begin constructing the start tag.
    String element = "&lt;" + elementName + " ";</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The StringBuffer class</b><br />
  Another, and possibly more efficient way to construct the String object 
	that represents the element would be to use the append method of 
	the StringBuffer class.</td></tr></table>
</td>
</tr>
</table>

The code in Listing 2 instantiates a <b>String</b> object, which consists of 
a left angle bracket concatenated with the name of the element.&nbsp; This 
object will be used to create a succession of new <b>String</b> objects 
containing attribute names and values as the method executes.<p>
<font color="#FF0000">
<b>Dealing with elements that have no attributes</b></font></p>
<p>Listing 3 deals with elements that have no attributes on the basis of the 
values of the first and third parameters.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Dealing with elements that have no 
attributes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    if((empty==false) &amp;&amp; (data == null)){
      //Return a complete start tag.
      return element + "&gt;";
    }else if((empty==true) &amp;&amp; (data == null)){
      //Return a complete empty element.
      return element + "/&gt;";
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 3 is straightforward.&nbsp; Because there are no 
attributes, no further processing within the method is required.&nbsp; Depending 
on the combination of parameter values, this code will return the <b>String</b> 
object shown by the black boldface text in either the second block of text or 
the fourth block of text in Figure 1.</p>
<p><font color="#FF0000">
<b>Processing the attributes</b></font></p>
<p>The code in Listing 4 is executed when the third parameter is not null, 
meaning that there are attribute names and values in the array object referenced by the value 
of the third parameter.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Processing the attributes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element += name + "=" + "\"" + value + "\" ";
    }//end for loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 4 extracts the values from the array in pairs and uses 
those pairs of values to successively create extended <b>String</b> objects that 
are formatted properly for the specification of XML element attribute names and 
values.&nbsp; <i>(See the black boldface text in the first and third blocks of 
text in Figure 1.)</i>&nbsp; Note that the code in Listing 4 uses the escape 
sequence to properly surround the attribute values with quotation marks, thus 
relieving the using programmer of the requirement to perform this task.</p>
<p><font color="#FF0000">
<b>Decision time: empty element or non-empty element</b></font></p>
<p>When the loop in Listing 4 terminates, the element has been constructed out 
to the point where it is necessary to decide whether to seal it off as an empty 
element (/&gt;) or to seal it off as the end of the start tag (&gt;) for an element 
that is not empty.&nbsp; That decision is made by the code in Listing 5 on the 
basis of the value of the first parameter.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Decision: empty element or non-empty 
element.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    if(empty){
      //Terminate the element appropriately for an
      // empty element. A complete empty element will
      // be returned.
      element += "/&gt;";
    }else{
      //End the start tag for an element that is not
      // empty. In this case, only the start tag will
      // be returned.  The calling program must provide
      // the content for the element as well as the end
      // tag for the element.
      element += "&gt;";
    }//end else
    
    return element;
  }//end makeElement</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 5 is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>Return the element and terminate the method</b></font></p>
<p>Listing 5 also returns a reference to the <b>String</b> object containing the 
newly-constructed element and terminates the method named <b>makeElement</b>.</p>
<p><font color="#FF0000">
<b>Remaining code in the main method</b></font></p>
<p>Now that you understand how the method named <b>makeElement</b> works, you 
shouldn't have any difficulty understanding the remaining code in the <b>main</b> 
method, which is shown in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Remaining code in the main method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    System.out.println();
    System.out.println(
                "Demo empty element with no attributes.");
    System.out.println(
                      "Probably doesn't make any sense.");
    emptyElement = <b>makeElement(true,name,null);</b>
    System.out.println(emptyElement);

    System.out.println();
    System.out.println(
               "Demo non-empty element with attributes.");
    String elementStartTag = <b>makeElement(false,name,
                         new String[]{"Color","Color.RED",
                                      "width","10",
                                      "height","20"});</b>
    System.out.println(elementStartTag);
    System.out.println("Content of element.");
    //Create end tag for element
    System.out.println("&lt;/" + name + "&gt;");

    System.out.println();
    System.out.println(
            "Demo non-empty element with no attributes.");
    elementStartTag = <b>makeElement(false,name,null);</b>
    System.out.println(elementStartTag);
    System.out.println("Content of element.");
    //Create end tag for element
    System.out.println("&lt;/" + name + "&gt;");

  }// end main()</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 6 calls the <b>makeElement</b> method three times to 
produce the screen output shown in Figure 1.&nbsp; You should have no difficulty 
correlating the code in Listing 6 with the screen output shown in Figure 1.</p>
<p><font color="#FF0000"><b>Displayed on the screen for illustration</b></font></p>
<p>For illustration purposes, this program has simply used a <b>println</b> 
statement to display the XML elements produced by the <b>makeElement</b> method 
on the screen.&nbsp; In future lessons, those elements will either be written 
into SVG files as part of the SVG code required to render a graphic image, or 
sent from a servlet to a browser as part of the SVG code produced by the 
servlet.</p>
<h3><a name="The_Svg08_program">The Svg08 program</a></h3>
<p><font color="#FF0000">
 <b>Graphic output from Svg08</b></font></p>
<p>Before getting into the details of the program code for the program named <b>
Svg08</b>, I want to show you the 
graphic output from this program and explain what it mean.&nbsp; That output is 
shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Graphic output from Svg08. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2214a01.jpg" width="233" height="578"></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#FF0000"><b>The first way to draw an ellipse</b></font></p>
<p>Basically, this program illustrates three different ways to use the methods 
in my SVG graphics library to draw an ellipse.&nbsp; The first way is to call 
the method named <b>makeEllipse</b>, providing attribute values for the 
coordinates that define the center of the ellipse, the width of the ellipse, and 
the height of the ellipse, and accept the default attribute 
values for all of the other attributes.&nbsp; This approach resulted in the black ellipse at 
the top of Figure 3.&nbsp; As you can see, this ellipse is completely opaque, 
and the blue line beneath it does not show through.</p>
<p><font color="#FF0000"><b>The second way to draw an ellipse</b></font></p>
<p>The second way to draw an ellipse is to do the same thing as above, but to 
follow that up by making two successive calls to the <b>setAttribute</b> method 
to set the <b>style</b> attribute to <b>fill:red</b>, and to set the <b>opacity</b> 
attribute to <b>0.6</b>, <i>(or 60-percent opaque)</i>.&nbsp; This resulted in 
the pink ellipse in the center of Figure 3, with the white background and the 
wide blue line beneath the ellipse showing through.</p>
<p><font color="#FF0000"><b>The third way to draw an ellipse</b></font></p>
<p>The third way to draw an ellipse is to call the <b>makeNode</b> method to 
draw an ellipse with the following attributes names and values:</p>
<ul>
	<li>cx: 110 <i>(coordinate of center along the x-axis)</i></li>
	<li>cy 300 <i>(coordinate of center along the y-axis)</i></li>
	<li>rx: 100 <i>(radius along the x-axis)</i></li>
	<li>ry: 40 <i>(radius along the y-axis)</i></li>
	<li>style: fill:green <i>(fill color for the ellipse)</i></li>
	<li>opacity: 0.6 <i>(opacity attribute value)</i></li>
	<li>transform: translate(110,300) rotate(15) translate(-110,-300)</li>
</ul>
<p>This resulted in the rotated green ellipse at the bottom of Figure 3.</p>
<p>The first four attributes in the above list are the same attributes for which 
the values were set for the black ellipse <i>(but with different attribute 
values)</i>.</p>
<p>The first six attributes in the above list are the same attributes for which 
the values were set for the red ellipse <i>(again with different attribute 
values)</i>.</p>
<p>The last attribute in the above list was an extra attribute that was set on 
the third (green) ellipse to cause it to be rotated by 15 degrees clockwise 
about its center.&nbsp; This attribute was not set for either the black ellipse 
or the red ellipse.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A bit of trivia</b><br />
  Although I never realized it until just this moment, the word ellipses can 
	describe either <a href="http://www.gtscompanies.com/printa_e.html#e">three 
	spaced periods indicating the omission of text</a> or the
	<a href="http://mathworld.wolfram.com/Ellipse.html">plural of ellipse</a>.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Other graphic elements</b></font></p>
<p>In addition to the three ellipses that were drawn by this program, a 
wide blue line was drawn underneath the three ellipses in order to demonstrate the transparency that 
results from setting the <b>opacity</b> attribute value to less than 1.0.</p>
<p>Also, a black border, one pixel wide, was drawn to outline the canvas on which 
the ellipses and the line were drawn.</p>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>The purpose of this program is to demonstrate the use of a graphics 
method named <b>makeNode</b> that can be used to create a general DOM tree node having 
any name and any number of attributes with any attribute names and any <b>String</b> 
values for the attributes.</p>
<p>The program creates a DOM tree describing the graphic image shown in Figure 3 
in SVG format.&nbsp; Then the program transforms the DOM tree into raw XML code 
and writes the XML code out into an XML file named <b>junk.svg</b>.</p>
<p>The program illustrates three different ways to use the methods of the SVG 
graphics library to draw ellipses having different attribute values. The output 
file produced by this program can be rendered by loading it into Firefox 1.5. </p>
<p>The program was tested using J2SE 5.0, Firefox v1.5.0.8, and WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As before, I will present and explain the program in fragments.&nbsp; <i>(You 
can view the entire program in Listing 23 near the end of the lesson.)</i></p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The getDocument method</b><br />
  The method named getDocument was explained in an earlier lesson.&nbsp; 
That explanation won't be repeated here.</td></tr></table>
</td>
</tr>
</table>

The first fragment is shown in Listing 7.&nbsp; This fragment shows the 
beginning of the class and the <b>main</b> method, along with the beginning of 
the code required to create the DOM tree.&nbsp; </p>
<p>
<b><a name="Listing_7">Listing 7</a>. Begin creating the DOM tree. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Svg08 {

  public static void <b>main</b>(String[] args){

    //Begin by creating a DOM tree that represents the XML
    // code that will be rendered to produce the image of
    // interest.

    //Get the Document object.
    Document document = SvgGraphics.<b>getDocument</b>();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the root node named svg</b></font></p>
<p>Listing 8 calls the <b>makeNode</b> method to create the root node named <b>
svg</b> and to append it to the document.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Create the root node named svg. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element svg = SvgGraphics.<b>makeNode</b>(
        document,
        null,//parent
        "svg",//node type
        new String[]{"xmlns","http://www.w3.org/2000/svg",
                     "version","1.1",
                     "width","220",
                     "height","440",
                     "position","absolute",
                     "top","0",
                     "left","0",
                    });//end makeNode method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>For this special case where the new node needs to be a child of the document, null is passed as the second parameter 
<i>(that specifies the 
parent)</i>.&nbsp; Otherwise, a reference to the actual parent node should be passed as 
the 
second parameter.</p>
<p>With the exception of the attributes named <b>xmlns</b> and <b>position</b>, 
you can probably pretty well surmise what the purpose of each attribute is.&nbsp; 
I will leave it as an exercise for the reader to go to the SVG specification <i>
(see <a href="#Resources">Resources</a>)</i> to learn about those attributes.</p>
<p><font color="#FF0000"><b>The makeNode method</b></font></p>
<p>At this point, I am going to put the discussion of the <b>main</b> method on 
the back burner while I present and explain the <b>makeNode</b> method.</p>
<p>The purpose of this method is to create a general node having any name and 
any number of attributes with any attribute names and any <b>String</b> values 
for the attributes.</p>
<p><font color="#FF0000">
 <b>Recommended usage of the makeNode method</b></font></p>
<p>Figure 4 shows an example of the recommended usage for the <b>makeNode</b> 
method.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Recommended usage of the makeNode method. </b>
<table border="1" cols="1" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element abc = SvgGraphics.makeNode(
                      document,
                      def,//parent could be null
                      "ghi",//node type
                      new String[]{"name","value",
                                   "name","value",
                                   ...
                                   "name","value",
                                  });//end makeNode method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first parameter is a reference to the document to which the new node 
belongs</p>
<p>The second parameter is a reference to the parent node to which this node is 
to be appended so as to become a child of that node.&nbsp; If this parameter is 
null, the new node is appended to the document.&nbsp; Otherwise, it is appended 
to the specified parent node.</p>
<p>The third parameter is a <b>String</b> that specifies the type of the new node.</p>
<p><font color="#FF0000"><b>Reference to a String array object</b></font></p>
<p>The fourth parameter must be a reference to an array object of type <b>String</b> 
or it must be null.&nbsp; This array must contain an even number of elements.&nbsp; 
Each pair of elements constitutes the name and the value of an attribute, in the 
following order: <i>name, value, name, value,</i> etc.&nbsp; <i>(Any number of 
name/value pairs is allowed.)</i></p>
<p>Referring back to Listing 8, you see a call to the <b>makeNode</b> method to 
create a new node of type <b>svg</b> and append it to <i>(make it a child node 
of)</i> the document node.</p>
<p>A reference to an array object of type <b>String[]</b> was passed as the 
fourth parameter.&nbsp; The array object in Listing 8 contained seven different pairs of 
strings specifying the attribute names and corresponding attribute values for 
seven different attributes.</p>
<p>Note the values of the <a name="width">width</a>, height, top, 
and left attributes in Listing 8.&nbsp; Basically, these values specify the location and 
dimensions of the canvas upon which the ellipses will be drawn.&nbsp; These 
values will 
become important when I return to the discussion of the code in the <b>main</b> 
method.</p>
<p><font color="#FF0000">
<b>Beginning of the makeNode method</b></font></p>
<p>Listing 9 shows the beginning of the <b>makeNode</b> method, including the 
creation of the new node of type <b>Element</b>.&nbsp; The node is bare at 
this point, but will be dressed up to contain attribute nodes, etc., as the execution of the method progresses.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Beginning of the makeNode method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeNode</b>(Document document,
                          Element parent,
                          String nodeType,
                          String[] data){
  
    Element element = 
                (Element)document.createElement(nodeType);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Append new node to its parent</b></font></p>
<p>Listing 10 calls the <b>appendChild</b> method, to cause the new node to 
become a child node of the specified parent.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Append new node to its parent. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    if(parent == null){
      //For the special case of parent equal to null,
      // append the new node to the document.
      document.<b>appendChild</b>(element);
    }else{
      //Otherwise, append the new node to the specified
      // parent.
      parent.<b>appendChild</b>(element);
    }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>For the special case where the parent is specified as null, the new node is 
appended to the document.&nbsp; Otherwise, it is appended to the specified 
parent node.</p>
<p><font color="#FF0000">
<b>Nodes that have no attributes</b></font></p>
<p>Listing 11 deals with the case where the reference to the array object is 
null, indicating that this new node has no attributes.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Nodes that have no attributes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>For this case, the node that was created in Listing 10 and appended to its 
parent in Listing 11 is all that is required.&nbsp; Therefore, the code in 
Listing 11 simply returns a reference to that node and the method terminates.</p>
<p><font color="#FF0000">
<b>Processing the attribute names and values</b></font></p>
<p>The <b>for</b> loop in Listing 12 extracts each attribute-name/value pair 
from the array object and uses that information to set an attribute on the new 
node with a matching name and a matching value.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Processing the attribute names and 
values. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>At this point, you could set an attribute on the node having just about any 
name and just about any <b>String</b> value on the new node.&nbsp; However, in 
order for an attribute to be effective in the ultimate rendering of the graphic 
image, the name and value must be included in the names and values that are allowed 
by the SVG specification for an element of that type <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Return the new node</b></font></p>
<p>Listing 12 also returns a reference to the new node and terminates the 
method.</p>
<p><font color="#FF0000">
<b>Show outline of the canvas</b></font></p>
<p>Now, returning to the discussion of the <b>main</b> method and continuing 
from where we left off in Listing 8, Listing 13 calls the <b>makeNode</b> method to 
draw the rectangular outline at the edge of the drawing canvas shown in Figure 
3.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Show outline of the canvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element outline = SvgGraphics.makeNode(document,
                                         svg,//parent
                                         "rect",//type
        new String[]{"x","0",
                     "y","0",
                     "width","220",
                     "height","440",
                     "fill","none",
                     "stroke","black",
                     "stroke-width","1",
                    });//end makeNode method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The attribute values</b></font></p>
<p>The earlier code in Listing 8 created the canvas at the location and with the 
dimensions that I pointed out <a href="#width">earlier</a>.&nbsp; Note that the 
location and dimensions of the rectangular outline drawn by the code in Listing 
13 matches the location and dimensions of the canvas created in Listing 8.</p>
<p>The <b>fill</b> attribute specifies what is to be used to fill the interior 
of the rectangle, and in this case, <i>&quot;none&quot;</i> is specified.</p>
<p>The <b>stroke</b> attribute specifies information about the <i>stroke</i> 
that forms the outline of the rectangle.&nbsp; In this case it was simply 
specified as <i>&quot;black.&quot;</i></p>
<p>The <b>stroke-width</b> attribute specifies the thickness of the stroke that 
forms the outline of the rectangle.&nbsp; In this case the width was specified 
to be the width of a single pixel.</p>
<p><font color="#FF0000">
<b>Create a group container named g</b></font></p>
<p>Listing 14 calls the <b>makeNode</b> method to create a non-visual node named
<b>g</b>.&nbsp; This node will be the parent for a line and three ellipses.&nbsp; 
Although I won't demonstrate it in this program, having assigned the three 
visual components to the same group, it would be possible for me to manipulate 
them as a group in various ways.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Create a group container named g. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element g = SvgGraphics.<b>makeNode</b>(document,
                                     svg,//parent
                                     "g",
                                     null);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that Listing 14 passes null in place of a reference to an array object 
containing attribute name/value pairs.&nbsp; As a result, the node named <b>g</b> 
is constructed with no attributes.</p>
<p><font color="#FF0000">
<b>Draw a blue line</b></font></p>
<p>Listing 15 draws the blue line shown in Figure 3 beginning at the upper left 
corner of the canvas and extending to the lower right corner of the canvas.&nbsp; 
The line is 12 pixels wide.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Draw a blue line. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element line = SvgGraphics.<b>makeLine</b>(document,
                                        g,   //owner
                                        0,   //x1
                                        0,   //y1
                                        220, //x2
                                        440);//y2
    line.setAttribute("stroke","blue");
    line.setAttribute("stroke-width","12");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The makeLine method</b><br />
  Note that the <b>makeLine</b> method 
is much less general than the <b>makeNode</b> method, which could also have been 
	used to draw this line.&nbsp; The choice between the two is based on 
	programmer preference.</td></tr></table>
</td>
</tr>
</table>

The drawing of the line is accomplished in three steps.&nbsp; The first step is 
to draw the line as a default black line one pixel wide by calling the<b> makeLine</b> 
method, passing the coordinates for the beginning and end points of the line as 
parameters to the method.&nbsp; </p>
<p>The second step is to call the <b>setAttribute</b> method to change 
the color from black to blue.</p>
<p>The third step is to call the <b>setAttribute</b> method again to change the line 
width from one pixel to twelve pixels.</p>
<p>This is a case of originally drawing the image by calling a very specialized 
method, and then supplementing that call by two successive calls to a general 
method that can be used to set attribute values, one attribute at a time.</p>
<p><font color="#FF0000"><b>The makeLine method</b></font></p>
<p>Once again, let's put the discussion of the <b>main</b> method on the back 
burner while we take a look at the code in the <b>makeLine</b> method, which is 
shown in its entirety in Listing 16.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. The makeLine method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element makeLine(Document document,
                          Element parent,
                          int x1,
                          int y1,
                          int x2,
                          int y2){
    Element line  = 
                  (Element)document.createElement("line");
    parent.appendChild(line);
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    return line;
  }//end makeLine</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The parameter values</b></font></p>
<p>This method returns a reference to a line. The parameters <b>x1</b> and <b>y1</b> 
specify the starting point of the line.&nbsp; The parameters <b>x2</b> and <b>y2</b> 
specify the end point of the line.&nbsp; <i>(The line could be rotated and 
translated later to make it appear differently but that wasn't done in this 
case.) </i>&nbsp; By default, the stroke is set to black one pixel wide.</p>
<p>There is nothing complicated in Listing 16, so it shouldn't require further 
explanation.</p>
<p><font color="#FF0000">
<b>Draw the black ellipse</b></font></p>
<p>Returning now to the <b>main</b> method, Listing 17 calls the <b>makeEllipse</b> 
method to draw the black ellipse at the top in Figure 3.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Draw the black ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    SvgGraphics.<b>makeEllipse</b>(document,//This document
                            g,//Owner
                            110,//Center x-coordinate
                            100,//Center y-coordinate
                            100,//Width
                            40); //Height
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The call to the <b>makeEllipse</b> method in Listing 17 passes parameter 
values for four of the attributes.&nbsp; These four attributes, which are set by 
the <b>makeEllipse</b> method, specify the location and size of the ellipse. The 
ellipse is black because the attribute that controls the color was not set.</p>
<p><font color="#FF0000"><b>The makeEllipse method</b></font></p>
<p>The <b>makeEllipse</b> method is shown in its entirety in Listing 18.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. The makeEllipse method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element makeEllipse(Document document,
                             Element parent,
                             int xCoor,
                             int yCoor,
                             int xRadius,
                             int yRadius){
    Element ellipse  = 
               (Element)document.createElement("ellipse");
    parent.appendChild(ellipse);
    ellipse.setAttribute("cx",""+xCoor);
    ellipse.setAttribute("cy",""+yCoor);
    ellipse.setAttribute("rx",""+xRadius);
    ellipse.setAttribute("ry",""+yRadius);
    return ellipse;
  }//end makeEllipse</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This <b>makeEllipse</b> method returns a reference to an ellipse. The <b>
xCoor</b> and <b>yCoor</b> parameters specify the center of the ellipse. The <b>
xRadius</b> and <b>yRadius</b> parameters specify the width and height of the 
ellipse respectively.&nbsp; The code in 
Listing 18 is straightforward and shouldn't require further explanation.</p>
<p><font color="#FF0000">
<b>Draw the red ellipse</b></font></p>
<p>Returning once more to the <b>main</b> method, Listing 19 draws the red <i>
(pink)</i> ellipse in the middle of Figure 3.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Draw the red ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element ellipse2 = SvgGraphics.<b>makeEllipse</b>(
                           document,
                           g,//Owner
                           110,//Center x-coordinate
                           200,//Center y-coordinate
                           100,//Width
                           40); //Height
    ellipse2.setAttribute("style","fill:red");
    ellipse2.setAttribute("opacity","0.6");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As with the line that was drawn earlier, the red ellipse in Figure 3 was 
drawn in three steps.&nbsp; The first step was to call the <b>makeEllipse</b> 
method to draw a black ellipse in the correct position with the correct shape.</p>
<p>The second step was to call the <span lang="en-us"></span><b>setAttribute</b> method to change the 
fill color from black to red.</p>
<p>The third step was to call the <b>setAttribute</b> method again to change the 
opacity from the default value of 100-percent opaque to a new value of 
60-percent opaque <i>(0.6)</i>.</p>
<p><font color="#FF0000">
<b>Draw the green rotated ellipse</b></font></p>
<p>The green rotated ellipse shown at the bottom of Figure 3 could have been 
drawn using the same approach as for the red ellipse and adding one more call to 
the <b>setAttribute</b> method to accomplish the rotation.&nbsp; However, 
instead of drawing it that way, as shown in Listing 20, the green ellipse was 
drawn by calling the <b>makeNode</b> method, and passing all of the relevant 
attribute names and attribute values as the contents of an array object.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Draw the green rotated ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element ellipse3 = SvgGraphics.makeNode(
      document,
      g,//parent
      "ellipse",//node type
      new String[]{"cx","110",
                   "cy","300",
                   "rx","100",
                   "ry","40",
                   "style","fill:green",
                   "opacity","0.6",
                   "transform","translate(110,300) "
                             + "rotate(15) "
                             + "translate(-110,-300)"
                  });//end makeNode method </pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The transform attribute</b><br />
  The transform attribute can be used to perform a variety of transformations on 
	a shape, such as rotate, scale, translate, and skew.&nbsp; See section 7 of 
	the SVG specification in <a href="#Resources">Resources</a>.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>The makeNode method</b></font></p>
<p>If you examine the code in Listing 20 carefully, and compare it with the code 
for the <b>makeNode</b> method in Listing 9 through Listing 12, you will see 
that it draws a green ellipse with 60% opacity rotated by 15-degrees clockwise 
relative to its center.</p>
<p>As I explained earlier, the <b>makeNode</b> method lets you set all, none, or 
any combination of attribute values in order to take advantage of any combination 
of available attributes with no assumptions being made about any of 
the attributes. This is the most general of the three approaches presented and 
discussed in this lesson.</p>
<p><font color="#FF0000">
<b>Transform the DOM and write the output file</b></font></p>
<p>Listing 21 transforms the DOM tree into raw XML code and writes that XML code 
into an output file named <b>junk.svg</b>.&nbsp; </p>
<p>
<b><a name="Listing_21">Listing 21</a>. Transform the DOM and write the output file.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    SvgGraphics.<b>transformTheDom</b>(document,"junk.svg");

  }// end main()</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>transformTheDom</b> was explained in an earlier lesson.&nbsp; 
That explanation won't be repeated here.</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p>Listing 21 also signals the end of the <b>main</b> method and the end of the 
program.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 22 and Listing 23 into your text
editor, compile it, and execute it.&nbsp; Then view the resulting SVG files in 
Firefox 1.5, or some other suitable SVG rendering engine.&nbsp; Experiment with the 
code, making changes, and observing the results of your changes. </p>
<p>Above all, enjoy the process. Programming can be fun.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>Continuing with the SVG graphics library from the previous lesson, I taught 
you how to write a method that deals with the escape sequences required for the 
quotation marks that surround attribute values in XML thereby making it much 
easier to write Java code that generates XML code.</p>
<p>I also taught you how to write a method that makes it possible to create a 
general node in the DOM tree being constructed to represent an SVG graphic, 
making no prior assumptions about the number of attributes, the names of the 
attributes, or the values of the attributes.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The next lesson in this series will show you how to take what you have learned in 
this and the previous lesson and to apply that knowledge to the generation of 
XHTML files containing in-line SVG/XML code.&nbsp; The next lesson will also teach 
you how to apply that knowledge to the writing of servlets that produce XHTML 
output containing in-line SVG/XML code.</p>
<p>Future lessons will teach you how to write servlets that:</p>
<ul>
	<li>Produce XHTML output containing references to external SVG files, some 
	of which are created on-the-fly during the execution of the servlet.</li>
	<li>Create and re-use graphic elements.</li>
	<li>Use SVG <i>symbols</i>.</li>
	<li>Deal with stroke caps in SVG in comparison with similar caps in Java 2D.</li>
	<li>Use the <i>switch</i> element in SVG.</li>
	<li>Deal with bit-mapped images in SVG.</li>
	<li>Deal with text in SVG.</li>
	<li>Deal with other features such as animation in SVG.</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 22 and Listing 23 below.
<p>
<b><a name="Listing_22">Listing 22</a>. The program named Svg07. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg07.java
Copyright 2006, R.G.Baldwin

One of the most frustrating things about using Java to
create elements in XML, XHTML, or HTML is having to deal
with the escape characters for the many required
quotation marks that surround attribute values.  This 
program demonstrates a method that can be used to easily 
create elements without having to deal with those escape 
characters. The element produced by the method may or may 
not be empty, and may or may not have attributes.

This program produces the following output:

Demo empty element with attributes.
&lt;ElementName color="Color.RED" width="10" height="20" /&gt;

Demo empty element with no attributes.
Probably doesn't make any sense.
&lt;ElementName /&gt;

Demo non-empty element with attributes.
&lt;ElementName color="Color.RED" width="10" height="20" &gt;
Content of element.
&lt;/ElementName&gt;

Demo non-empty element with no attributes.
&lt;ElementName &gt;
Content of element.
&lt;/ElementName&gt;

Tested using J2SE 5.0, Firefox v1.5.0.9, and WinXP.
*********************************************************/
import java.io.*;

public class Svg07{
  public static void main(String argv[]){
    String name = "ElementName";
    System.out.println(
                   "Demo empty element with attributes.");

    String emptyElement = makeElement(true,name,
                         new String[]{"Color","Color.RED",
                                      "width","10",
                                      "height","20"});
    System.out.println(emptyElement);

    System.out.println();
    System.out.println(
                "Demo empty element with no attributes.");
    System.out.println(
                      "Probably doesn't make any sense.");
    emptyElement = makeElement(true,name,null);
    System.out.println(emptyElement);

    System.out.println();
    System.out.println(
               "Demo non-empty element with attributes.");
    String elementStartTag = makeElement(false,name,
                         new String[]{"Color","Color.RED",
                                      "width","10",
                                      "height","20"});
    System.out.println(elementStartTag);
    System.out.println("Content of element.");
    //Create end tag for element
    System.out.println("&lt;/" + name + "&gt;");

    System.out.println();
    System.out.println(
            "Demo non-empty element with no attributes.");
    elementStartTag = makeElement(false,name,null);
    System.out.println(elementStartTag);
    System.out.println("Content of element.");
    //Create end tag for element
    System.out.println("&lt;/" + name + "&gt;");

  }// end main()
  //----------------------------------------------------//
  /*
  One of the most frustrating things about using Java
   to create elements in XML, XHTML, or HTML is having
   to deal with the escape characters for the many
   required quotation marks. This method constructs an
   element, which may or may not have attributes. Also,
   the element may or may not be empty.
  The user of this method does not have to deal with the
   required quotation marks surrounding attribute values
   and the corresponding escape characters     
  The first incoming parameter must be true if the
   element is empty and false if the element is not
   empty.
  If the first parameter is true, the element is sealed
   off in the required manner for an empty element. If
   the first parameter is false, the method returns the
   complete start tag for the element but does not
   return a complete element. It is the responsibility
   of the calling method to provide the content and the
   end tag for the element.
  The second parameter to the method must be a String
   that specifies the name of the element.
  The third parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.

  If the reference to the array object is null and the
   first parameter is false, the method returns the start
   tag for an element that has no attributes and is not 
   empty.
  If the reference is null and the first parameter is
   true, the method returns a complete empty element with 
   no attributes (which probably doesn't make any sense).
   
  An example of the recommended usage of the method
   follows:
   
  String newElement = makeElement(
                         true/false,
                         name,
                         new String[]{"name","value",
                                      "name","value",
                                      "name","value",
                                     });
   
  */
  
  static String makeElement(
          boolean empty,String elementName,String[] data){

    //Begin constructing the start tag.
    String element = "&lt;" + elementName + " ";
    
    //Deal with elements that have no attributes.
    if((empty==false) &amp;&amp; (data == null)){
      //Return a complete start tag.
      return element + "&gt;";
    }else if((empty==true) &amp;&amp; (data == null)){
      //Return a complete empty element.
      return element + "/&gt;";
    }//end if

    for(int cnt=0;cnt&lt;data.length;cnt+=2){

      String name = data[cnt];
      String value = data[cnt+1];
      element += name + "=" + "\"" + value + "\" ";
    }//end for loop
    
    if(empty){
      //Terminate the element appropriately for an
      // empty element. A complete empty element will
      // be returned.
      element += "/&gt;";
    }else{
      //End the start tag for an element that is not
      // empty. In this case, only the start tag will
      // be returned.  The calling program must provide
      // the content for the element as well as the end
      // tag for the element.
      element += "&gt;";
    }//end else
      
  return element;
  }//end makeElement

}//end Svg07
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_23">Listing 23</a>. The program named Svg08. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg08.java
Copyright 2006 R.G.Baldwin

The purpose of this program is to demonstrate the use of 
a new graphics method that can be used to create a general
node having any name, and any number of attributes with 
any attribute names and any String values for the 
attributes, or no attributes at all.

The program creates a DOM tree describing a specific 
graphic image in SVG format and writes it out into an XML 
file named junk.svg.

The program illustrates three different ways to use the
methods of the SVG graphics library to create ellipses
having different attribute values.

The output file produced by this program can be rendered 
by loading it into Firefox 1.5.

Tested using J2SE 5.0, Firefox v1.5.0.8, and WinXP.
*********************************************************/

import javax.xml.parsers.*;
import org.w3c.dom.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;

public class Svg08 {

  public static void main(String[] args){

    //Begin by creating a DOM tree that represents the XML
    // code that will render to produce the image of
    // interest.

    //Get the Document object.
    Document document = SvgGraphics.getDocument();

    //Create the root node named svg and append it to the
    // document.  Specify the parent as null for the
    // special case where the parent is the document.
    // Otherwise, specify the actual parent node.
    Element svg = SvgGraphics.makeNode(
        document,
        null,//parent
        "svg",//node type
        new String[]{"xmlns","http://www.w3.org/2000/svg",
                     "version","1.1",
                     "width","220",
                     "height","440",
                     "position","absolute",
                     "top","0",
                     "left","0",
                    });//end makeNode method



      //Show outline of canvas using 'rect' element
      Element outline = SvgGraphics.makeNode(document,
                                         svg,//parent
                                         "rect",//type
        new String[]{"x","0",
                     "y","0",
                     "width","220",
                     "height","440",
                     "fill","none",
                     "stroke","black",
                     "stroke-width","1",
                    });//end makeNode method

    //Create a node named g, which will be the parent for
    // an ellipse. Pass null for the reference to the
    // array object for the special case where the node
    // has no attributes.
    Element g = SvgGraphics.makeNode(document,
                                     svg,//parent
                                     "g",
                                     null);
                                     
    //Draw a blue line 12 pixels wide.  First define the
    // line by providing values for the four default
    // attributes of the makeLine method that specify the
    // end point locations of the line.  Then supplement
    // those attributes by invoking the setAttribute
    // method twice in succession on the reference to the
    // line to set the stroke and stroke-width attributes,
    // causing the line to be blue with a width of 12
    // pixels.
    Element line = SvgGraphics.makeLine(document,
                                        g,   //owner
                                        0,   //x1
                                        0,   //y1
                                        220, //x2
                                        440);//y2
    line.setAttribute("stroke","blue");
    line.setAttribute("stroke-width","12");
    

    //Draw a black ellipse by providing values for the
    // four default attributes of the makeEllipse method
    // that specify the location and size of the ellipse.
    // The ellipse is black because the attribute that
    // controls the color was not set.
    SvgGraphics.makeEllipse(document,//This document
                            g,//Owner
                            110,//Center x-coordinate
                            100,//Center y-coordinate
                            100,//Width
                            40); //Height

    //Draw an ellipse by providing values for the four
    // default attributes of the makeEllipse method that
    // specify the location and size of the ellipse. Then
    // supplement those attributes by invoking the
    // setAttribute method on the reference to the ellipse
    // twice to fill the ellipse with red color and to
    // cause the filled ellipse to have 60% opacity.
    Element ellipse2 = SvgGraphics.makeEllipse(
                           document,
                           g,//Owner
                           110,//Center x-coordinate
                           200,//Center y-coordinate
                           100,//Width
                           40); //Height
    ellipse2.setAttribute("style","fill:red");
    ellipse2.setAttribute("opacity","0.6");
    
    //Draw a green ellipse with 60% opacity rotated by
    // 15-degrees clockwise, using the makeNode method,
    // for which there are no default attributes.
    //This method lets you set all, none, or any
    // combination of attribute values in order to
    // take advantage of none, any, or all of the
    // available attributes with no assumptions being
    // made about any of the attributes. This is the
    // most general of the three approaches.
    
    Element ellipse3 = SvgGraphics.makeNode(
      document,
      g,//parent
      "ellipse",//node type
      new String[]{"cx","110",
                   "cy","300",
                   "rx","100",
                   "ry","40",
                   "style","fill:green",
                   "opacity","0.6",
                   "transform","translate(110,300) "
                             + "rotate(15) "
                             + "translate(-110,-300)"
                  });//end makeNode method  
    
    //Transform the DOM and write the output file.
    SvgGraphics.transformTheDom(document,"junk.svg");

  }// end main()
  //----------------------------------------------------//
  
}// class Svg08
//======================================================//

//This is an abbreviated library used solely to support 
// this program for the purpose of demonstrating the
// method named makeNode.
class SvgGraphics{
  //----------------------------------------------------//
  
  /*
  The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
   
  The first parameter is a reference to the document to
   which the new node belongs.
  
  The second parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node. If this parameter is null, the new
   node is appended to the document.  Otherwise, it is
   appended to the specified parent node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
  
  An example of the recommended usage of the method
   follows:
    Element abc = SvgGraphics.makeNode(
                      document,
                      def,//parent could be null
                      "ghi",//node type
                      new String[]{"name","value",
                                   "name","value",
                                   "name","value",
                                  });//end makeNode method
  */
  static Element makeNode(Document document,
                                Element parent,
                                String nodeType,
                                String[] data){
  
    Element element = 
                (Element)document.createElement(nodeType);
    
    if(parent == null){
      //For the special case of parent equal to null,
      // append the new node to the document.
      document.appendChild(element);
    }else{
      //Otherwise, append the new node to the specified
      // parent.
      parent.appendChild(element);
    }//end else
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//

  //This method returns a reference to an ellipse. The
  // xCoor and yCoor parameters specify the center of the
  // ellipse.  The xRadius and yRadius parameters specify
  // the width and height of the  ellipse respectively
  // while it is in the horizontal plane before being
  // rotated.  Numeric attributes are set at type String.
  static Element makeEllipse(Document document,
                             Element parent,
                             int xCoor,
                             int yCoor,
                             int xRadius,
                             int yRadius){
    Element ellipse  = 
               (Element)document.createElement("ellipse");
    parent.appendChild(ellipse);
    ellipse.setAttribute("cx",""+xCoor);
    ellipse.setAttribute("cy",""+yCoor);
    ellipse.setAttribute("rx",""+xRadius);
    ellipse.setAttribute("ry",""+yRadius);
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced. This method is not new to this
  // program.
  static Document getDocument(){
    Document document = null;
    try{
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      document = builder.newDocument();
      document.setXmlStandalone(false);
    }catch(Exception e){
      e.printStackTrace(System.err);
      System.exit(0);
    }//end catch
    return document;
  }//end getDocument
  //----------------------------------------------------//
  
  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced.  This method transforms the DOM into
  // raw XML code and writes that code into the output
  // file. This method is not new to this program.
  static void transformTheDom(Document document,
                              String filename){
    try{
      //Get a TransformerFactory object.
      TransformerFactory xformFactory =
                         TransformerFactory.newInstance();
           
      //Get an XSL Transformer object.
      Transformer transformer = 
                            xformFactory.newTransformer();
      
      //Sets the standalone property in the first line of
      // the output file.
      transformer.setOutputProperty(
                              OutputKeys.STANDALONE,"no");
      
      //Get a DOMSource object that represents the
      // Document object
      DOMSource source = new DOMSource(document);


      //Get an output stream for the output file.
      PrintWriter outStream = new PrintWriter(filename);

      //Get a StreamResult object that points to the
      // output file.  Then transform the DOM sending XML
      // code to <span lang="en-us"></span>the file
      StreamResult fileResult = 
                              new StreamResult(outStream);
      transformer.transform(source,fileResult);
    }//end try block

    catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch
  }//end transformTheDom
  //----------------------------------------------------//
  
  //This method returns a reference to a line. x1 and y1
  // specify the starting point of the line before it is
  // rotated. x2 and y2 specify the end point.  By
  // default, the stroke is set to black one pixel wide.
  // This can be overridden to specify other colors and
  // other widths if you need to do so.
  static Element makeLine(Document document,
                          Element parent,
                          int x1,
                          int y1,
                          int x2,
                          int y2){
    Element line  = 
                  (Element)document.createElement("line");
    parent.appendChild(line);
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    return line;
  }//end makeLine
  //----------------------------------------------------//
  
}//end class SvgGraphics
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<p><b>Java 2D Graphics</b><br>
<a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D Graphics, 
Nested Top-Level Classes and Interfaces&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D Graphics, 
The Point2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D Graphics, 
The Graphics2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D Graphics, 
Simple Affine Transforms&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D Graphics, 
The Shape Interface, Part 1&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D Graphics, 
The Shape Interface, Part 2&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D Graphics, 
Solid Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D Graphics, 
Gradient Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D Graphics, 
Texture Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D Graphics, 
The Stroke Interface&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D Graphics, 
The Composite Interface and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D Graphics, 
The Composite Interface, GradientPaint, and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D Graphics, 
The Color Constructors and Transparency<br>
<a href="http://java.sun.com/j2se/1.5.0/docs/guide/2d/spec.html">Java 2D API 
Specification</a><br>
<a href="http://java.sun.com/products/java-media/2D/">Java 2D API</a></p>
<p><b>Java API for XML Processing (JAXP)</b><br>
<a href="http://www.developer.com/java/other/article.php/3099751">2200</a> Java 
API for XML Processing (JAXP), Getting Started<br>
<a href="http://www.developer.com/xml/article.php/3113351">2202</a> Getting 
Started with Java JAXP and XSL Transformations (XSLT)<br>
<a href="http://www.developer.com/java/other/article.php/3292751">2204</a> Java 
JAXP, Exposing a DOM Tree<br>
<a href="http://www.developer.com/java/other/article.php/3313341">2206</a> Java 
JAXP, Implementing Default XSLT Behavior in Java<br>
<a href="http://www.developer.com/java/other/article.php/3361261">2208</a> Java 
JAXP, Writing Java Code to Emulate an XSLT Transformation<br>
<a href="http://www.developer.com/java/data/article.php/3398741">2210</a> Java 
JAXP, Transforming XML to XHTML<br>
<a href="http://www.dickbaldwin.com/tocxml.htm">Links to numerous XML tutorials 
by Richard G. Baldwin</a><br>
<br>
<b>Scalable Vector Graphics (SVG)</b><br>
<a href="http://www.developer.com/java/other/article.php/3655506">Java JAXP, Creating graphics using Java and SVG</a><br>
<a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a><br>
<a href="http://www.adobe.com/svg/">Adobe SVG Viewer plug-in</a><br>
<a href="https://www6.software.ibm.com/developerworks/education/x-svggraphics/index.html">
Create vector graphics in the browser with SVG</a> by Uche Ogbuji<br>
<a href="http://www.w3schools.com/svg/default.asp">SVG Tutorial</a><br>
<a href="http://www.svgbasics.com/shapes.html">SVG Basics</a></p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java jaxp svg &quot;scalable vector graphics&quot;</p>
<p>-end- </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
