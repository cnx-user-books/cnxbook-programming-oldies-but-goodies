<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">3D Displays, Color Distance, and Edge Detection</h2>
<i>Learn about color distance, projecting 3D coordinates onto a 2D display plane, 
and edge detection. Understanding these concepts will help you to better understand modern 
image processing.</i><p><b>Published:</b>&nbsp; January 27, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 350</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Lets_have_some_fun">Let's have some fun</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a><ul>
	<li><a href="#Edge_detection">Edge detection</a></li>
	<li><a href="#Color_distance_and_3D_projections">Color distance and 3D 
	projections</a></li>
	<li><a href="#Color_distance_for_a_very_simple_case">Color distance results for a 
	very simple case</a></li>
	<li><a href="#Color_distance_for_an_image_of_a_butterfly">Color distance 
	results for 
	an image of a butterfly</a></li>
</ul>
	</li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_program_named_Java350a">The program named Java350a</a></li>
	<li><a href="#The_program_named_Java_350b">The program named Java 350b</a></li>
	<li><a href="#The_program_named_Java_350c">The program named Java 350c</a></li>
	<li><a href="#The_program_named_Java_350d">The program named Java 350d</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="Lets_have_some_fun">Let's have some fun</a></h3>
<p>You've been working very hard if you have studied all of the earlier lessons 
in this series <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp;&nbsp; You have learned all about the <b>Turtle</b> class, its superclass 
named <b>
SimpleTurtle</b>, and the classes from which a turtle's contained objects are 
instantiated <i>(<b>Pen</b> and <b>PathSegment</b>)</i>.</p>
<p>You have 
learned how to instantiate new <b>Turtle</b> objects, placing them in either a
<b>World</b> object or a <b>Picture</b> object.&nbsp; You have learned how to 
manipulate the <b>Turtle</b> objects once you place them in their environment.</p>
<p>It's time to take a break and have some fun by writing non-trivial programs 
that make use of what you have learned so far.&nbsp; That's what we are going to 
do in this lesson.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Raw image from the program named 
	Java350d. </li>
	<li><a href="#Figure_2">Figure 2</a>. Final output from the program named 
	Java350d. </li>
	<li><a href="#Figure_3">Figure 3</a>. Screen output from the program named 
	Java350a. </li>
	<li><a href="#Figure_4">Figure 4</a>. Screen output from the program named 
	Java350b. </li>
	<li><a href="#Figure_5">Figure 5</a>. Screen output from the program named 
	Java350c.</li>
	<li><a href="#Figure_6">Figure 6</a>. Numeric color distance values. </li>
	<li><a href="#Figure_7">Figure 7</a>. Another variation on edge detection. </li>
	<li><a href="#Figure_8">Figure 8</a>. Butterfly with red outline and color 
	inversion. </li>
	<li><a href="#Figure_9">Figure 9</a>. Butterfly with cyan outline and color 
	inversion. </li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the program named 
	Java350a. </li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the class named Runner. </li>
	<li><a href="#Listing_3">Listing 3</a>. Methods to project 3D coordinate 
	value onto 2D plane. </li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the run method. </li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the drawLines method. </li>
	<li><a href="#Listing_6">Listing 6</a>. Draw black lines that outline the 
	cube. </li>
	<li><a href="#Listing_7">Listing 7</a>. Paint the top surface of the cube. </li>
	<li><a href="#Listing_8">Listing 8</a>. Paint the front and right surfaces 
	of the cube. </li>
	<li><a href="#Listing_9">Listing 9</a>. Beginning of the program named 
	Java350b </li>
	<li><a href="#Listing_10">Listing 10</a>. Beginning of the Runner class and 
	the run method. </li>
	<li><a href="#Listing_11">Listing 11</a>. The getColorDistance method. </li>
	<li><a href="#Listing_12">Listing 12</a>. Source code for the Pixel's 
	colorDistance method.</li>
	<li><a href="#Listing_13">Listing 13</a>. Plot the red wiggly line. </li>
	<li><a href="#Listing_14">Listing 14</a>. Beginning of the Runner class and 
	run method for Java350d. </li>
	<li><a href="#Listing_15">Listing 15</a>. Perform edge detection on the 
	image. </li>
	<li><a href="#Listing_16">Listing 16</a>. The edge detector method. </li>
	<li><a href="#Listing_17">Listing 17</a>. Source code for the program named 
	Java350a. </li>
	<li><a href="#Listing_18">Listing 18</a>. Source code for the program named 
	Java350b.</li>
	<li><a href="#Listing_19">Listing 19</a>. Source code for the program named 
	Java350c.</li>
	<li><a href="#Listing_20">Listing 20</a>. Source code for the program named 
	Java350d.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<h3><a name="Edge_detection">Edge detection</a></h3>
<p>I will present and explain four different programs in this lesson.&nbsp; The 
last program will teach you one of several ways to do <i>edge detection</i> on 
an image.&nbsp; By edge detection, I mean the ability to convert the image shown 
in Figure 1 into the image shown in Figure 2.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Raw image from the program named 
	Java350d. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table1" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350a.jpg" width="431" height="493"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Final output from the program named 
	Java350d. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table2" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350b.jpg" width="429" height="528"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A black and white pencil drawing</b></font></p>
<p>As you can see, this form of edge detection converts a full-colored 
photographic image into something that resembles a black and white pencil drawing.&nbsp; 
While you may not be anxious to convert your digital images of friends and 
family to pencil drawings, understanding how this is done will help you to 
understand a great deal about image manipulation in general as well as image 
manipulation using Ericson's multimedia Java 
library.</p>
<h3><a name="Color_distance_and_3D_projections">Color distance and 3D 
projections</a></h3>
<p>Before you can understand how to do edge detection using 
this approach, you must first understand the concept of <i>color distance</i>.</p>
<p>I will begin by explaining the concept of color distance using a 3D 
color cube as a model.&nbsp; Therefore, in addition to learning how to do edge 
detection, you will also learn how to project 3D coordinate values onto 
a 2D display and how to color the surfaces of a 3D color cube as shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Screen output from the program named 
	Java350a. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table3" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350c.jpg" width="469" height="495"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h3><a name="Color_distance_for_a_very_simple_case">Color distance results for a very 
simple case</a></h3>
<p>It will be much easier to understand the concept of color distance by 
beginning with some very simple synthetic images.&nbsp; Therefore, the second 
program that I will explain creates an image containing several groups of 
adjacent black pixels on a white background.&nbsp; Then the program computes and 
plots the 
color distance between each pair of adjacent pixels moving from left to right 
across the image along a row of pixels.</p>
<p>The interesting results occur where there is a white pixel adjacent to a black pixel at each end of each 
group of black pixels.&nbsp; The results are shown in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Screen output from the program named 
	Java350b. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table4" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350d.jpg" width="429" height="528"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Look very closely</b></font></p>
<p>If you look very closely, you will see a single black pixel immediately 
below the center of the red line near the top of Figure 4.&nbsp; Similarly, if you 
look closely, you will also see a row of four black pixels below the center of 
the bottom red line.&nbsp; There are also rows of two and three black pixels 
immediately below the center of the second and third red lines respectively.</p>
<p>The red lines in Figure 4 plot the value of the color distance between pairs of adjacent 
pixels.&nbsp; The color distance between two 
white pixels is zero, and the color distance between two black pixels is zero.&nbsp; 
However, the value of the color distance between a white pixel and a black pixel 
is large as Figure 4 indicates.&nbsp; <i>(I will tell you how large
<a href="#441_units">later</a> in this lesson.)</i></p>
<h3><a name="Color_distance_for_an_image_of_a_butterfly">Color distance results for an 
image of a butterfly</a></h3>
<p>Figure 5 shows the same color-distance computation applied to an image of a 
butterfly instead of being applied to a simple synthetic image as was the case in Figure 4.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Screen output from the program named 
	Java350c.</b><table border="0" cols="1" bgcolor="#ffffff" id="table5" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350e.jpg" width="429" height="528"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Plots of the color-distance values</b></font></p>
<p>Each of the red lines in Figure 5 plots the color distance values between each successive pair of pixels, moving from left to right across a row 
of pixels.&nbsp; As you can see, there are strong peaks at each point where 
there is an abrupt change in color, <i>(as when the color changes from dark gray to 
almost white for example)</i>.&nbsp; Less abrupt changes in color result in 
lower peaks.&nbsp; There are few, if any peaks in those areas where the color is 
generally the same.</p>
<p>Once you understand how the results shown in Figure 5 were obtained, you will 
also be in a position to understand how the results shown in Figure 2 were obtained.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Java350a">The program named Java350a</a></h3>
<p>Before you can understand how to do edge detection using <i>color distance</i> 
as the determining factor, you must first understand the concept of color 
distance.</p>
<p><font color="#FF0000"><b>Color distance and a 3D cube</b></font></p>
<p>I will begin by explaining the concept of color distance using a 3D cube as a 
model.&nbsp; <i>(In addition to learning how to do edge detection in this lesson, you 
will also learn how to project 3D coordinate values onto a 2D display.)</i>&nbsp; 
You will also learn how to color the visible surfaces of a 3D cube as shown in 
Figure 3.</p>
<p>You can think of the red, green, and blue color-component values in a <b>
Color</b> object as representing a single point in 3D space, where the three 
axes are <i><b>red</b></i>, <i><b>green</b></i>, and <i><b>blue</b></i>.&nbsp; Given that each color-component value 
ranges between 0 and 255, the set of all possible combinations of the 
three colors fall within a 3D cube with dimensions of 256 along each edge as 
shown in Figure 3.</p>
<p><font color="#FF0000"><b>The color black is at the origin</b></font></p>
<p>The color black with RGB values of 0,0,0 is a point at the origin of the 3D 
color space.&nbsp; <i>
(The color black is not visible in Figure 3 because the origin is on the back 
face of the cube.&nbsp; Only the front, top, and right side faces of the cube 
are visible in Figure 3.)</i></p>
<p><font color="#FF0000"><b>Yellow and white</b></font></p>
<p>The color yellow, represented by the RGB value 255,255,0 
appears at the top back right-hand corner of Figure 3.&nbsp; Similarly, the 
color white, represented by the RGB value 255,255,255 appears at the top front 
right-hand corner in Figure 3.</p>
<p><font color="#FF0000"><b>Colors of the eight vertices</b></font></p>
<p>The eight vertices of the cube in Figure 3 represent the following color 
values:</p>
<ol>
	<li>0,0,0 (<b>black</b> - <a name="bottom_back_left_corner">bottom back left corner</a>)</li>
	<li>0,255,0 (<b>green</b> - <a name="top_back_left_corner">top back left corner</a>)</li>
	<li>0,255,255 (<b>cyan</b> - <a name="top_front_left_corner">top front left corner</a>)</li>
	<li>0,255,0 (<b>blue</b> - <a name="bottom_front_left_corner">bottom front left corner</a>)</li>
	<li>255,0,255 (<b>magenta</b> - <a name="bottom_front_right_corner">bottom front right corner</a>)</li>
	<li>255,255,255 (<b>white</b> - <a name="top_front_right_corner">top front right corner</a>)</li>
	<li>255,255,0 (<b>yellow</b> - <a name="top_back_right_corner">top back right corner</a>)</li>
	<li>255,0,0 (<b>red</b> - <a name="bottom_back_right_corner">bottom back right corner</a>)</li>
</ol>
<p><font color="#FF0000"><b>More than 16-million colors</b></font></p>
<p>Every one of more than 16-million possible colors is represented by a 
point that is either inside the cube or on one of the faces of the cube in 
Figure 3.</p>
<p><font color="#FF0000"><b>The color distance</b></font></p>
<p>The <i>color distance</i> between two pixels is the positive length of a line 
segment that connects two points in Figure 3, where each point represents the 
color of a pixel.&nbsp; <i>(I will explain later how you can compute the length 
of that line segment.)</i>&nbsp; It should be clear, however, that the largest 
possible color distance is represented by a line segment that extends diagonally 
through the cube from one vertex to another.&nbsp; One such diagonal line 
extends from the origin <i>(black)</i> to the upper-right corner <i>(white)</i>.&nbsp; 
Another extends from the blue vertex to the yellow vertex, and a third extends 
from the magenta vertex to the green vertex.&nbsp; The length of each such 
diagonal line segment is approximately <a name="441_units">441 units</a>.</p>
<p><font color="#FF0000"><b>Behavior and purpose of the program</b></font></p>
<p>This program creates and displays the 3D color cube shown in Figure 3.&nbsp; 
The cube displays shows various combinations of red, green, and blue on the top 
face, the front face, and the right-most face of the cube.</p>
<p>The purpose of the program is to provide a springboard for discussing the 
concept of the distance between two colors as points in 3D space.</p>
<p><font color="#FF0000"><b>The 3D space and cube parameters</b></font></p>
<p>The positive red axis is toward the right as shown by the tiny stub 
protruding from the cube on the right side of Figure 3.&nbsp; The positive green 
axis is up, and the positive blue axis protrudes toward the left side of 
the viewer.</p>
<p>The type of projection that was used to project the 3D coordinate data onto 
the 2D display is a Cavalier projection with the angle phi equal to 45 degrees.&nbsp;
<i>(See Classification of 3D to 2D projections in <a href="#Resources">Resources</a>, for 
more information on projection types.)</i></p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>A complete listing of this program is provided in Listing 17 near the end of 
the lesson.&nbsp; As is my practice, I will discuss and explain the program in 
fragments, beginning with the fragment in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the program named Java350a. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table6">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 1 is straightforward and shouldn't require an 
explanation.</p>
<p><font color="#FF0000">
<b>Beginning of the class named Runner</b></font></p>
<p>Listing 1 instantiates a new object of the class named <b>Runner</b> and 
calls a method named <b>run</b> on that object.&nbsp; The class named <b>Runner</b> 
begins in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the class named Runner. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table7">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  final double sin45 = 0.7071067811865476;
  final double cos45 = 0.7071067811865476;
  final int width = 460;
  final int height = 460;
  final int originX = (int)(0.42*width);
  final int originY = (int)(0.59*height);
  World mars = null;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 2 declares and initializes several constants along with one 
instance variable.&nbsp; These constants and the variable are used later in the program.</p>
<p><font color="#FF0000"><b>Projecting 3D coordinate values onto a 2D display 
plane</b></font></p>
<p>Listing 3 shows two methods that are used to project a 3D coordinate value 
onto a 2D display plane.&nbsp; The method named <b>p3dX</b> receives the 3D 
coordinates of a point in the RGB color space and returns the x-axis coordinate at 
which the point should be located on the 2D display plane.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Methods to project 3D coordinate value 
onto 2D plane. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table8">
  <tbody>
    <tr>
      <td>
      <pre>
  int p3dX(int red,int green,int blue){
    return (int)(red-blue*sin45);
  }//end p3Dx
  //----------------------------------------------------//
  
  int p3dY(int red,int green,int blue){
    //Reverse the sign to account for the fact that
    // positive y-coordinates go down the screen
    return -(int)(green-blue*cos45);
  }//end p3dY</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Similarly, the method named <b>p3dY</b> receives the 3D coordinates of a 
point in RGB color space, and returns the y-axis coordinate at which the point 
should be located on the 2D display plane.&nbsp; </p>
<p>Both methods must be 
called with the coordinates of the point in 3D color space to determine the x and 
y coordinates at which the point should be located on the 2D display plane.</p>
<p><font color="#FF0000"><b>An exercise for the student</b></font></p>
<p>As you can see, each of the methods in Listing 3 consists of a single 
statement.&nbsp; I'm not going to try to explain why these mathematical 
expressions succeed in projecting a 3D coordinate value onto a 2D display plane.&nbsp; 
I'll leave that as an exercise for the student.&nbsp; Just be aware that there 
are several different ways to project a 3D coordinate value onto a 2D 
display plane and this is only one of those ways. <i>&nbsp;(See Classification of 
3D to 2D projections in <a href="#Resources">Resources</a>, for example.)</i></p>
<p><font color="#FF0000">
<b>Beginning of the run method</b></font></p>
<p>As you saw in Listing 1, the <b>main</b> method in this program instantiates 
a new object of the <b>Runner</b> class and calls the <b>run</b> method on that 
object.&nbsp; The beginning of the <b>run</b> method is shown in Listing 4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the run method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table9">
  <tbody>
    <tr>
      <td>
      <pre>  void run(){
    //Create a new World object.
    mars = new World(width,height);
    
    //Place a new turtle on the right edge of the World 
    // and make it invisible.
    Turtle joe = new Turtle(width,originY,mars);
    joe.setVisible(false);
    
    //Draw colored axes and black lines that outline the 
    // cube.
    drawLines(joe);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Everything in Listing 4 down to the call to the method named <b>drawLines</b> 
should be familiar to you by now, so I won't discuss it further.&nbsp; However, 
the <b>drawLines</b> method is new, so I will put the explanation of the <b>run</b> 
method on hold temporarily and explain the <b>drawLines</b> method.</p>
<p>


<p><font color="#FF0000"><b>The drawLines method</b></font></p>
<p>The <b>drawLines</b> method, which begins in Listing 5, is rather long and 
boring, so I broke it out into a separate method simply to improve the 
organization of the program.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The origin of the 3D projection</b><br />
  The purpose of the constants named originX and originY, defined in Listing 2, 
	is to establish the location of the origin of the 3D projection on the 2D 
	display plane.</td></tr></table>
</td>
</tr>
</table>
<p>Note that the <b>drawLines</b> method receives a reference to the <b>Turtle</b> 
object that was instantiated in Listing 4 and which was placed&nbsp; at the right edge of 
the <b>World</b> object immediately to the right of the origin of the 3D 
projection shown in Figure 3.&nbsp; </p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the drawLines method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table10">
  <tbody>
    <tr>
      <td>
      <pre>
  void drawLines(Turtle joe){
    //Draw red x-axis by moving the turtle from the right
    // edge to the origin of the 3D world.
    joe.setPenWidth(2);//Draw the colored axes wide.
    joe.setPenColor(Color.RED);
    joe.moveTo(p3dX(0,0,0)+originX,p3dY(0,0,0)+originY);
    
    //Draw green y-axis by moving the turtle to near the
    // top edge of the 3D world and then return to the
    // origin.
    joe.setPenColor(Color.GREEN);
    joe.moveTo(p3dX(0,265,0)+originX,
               p3dY(0,265,0)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);
    
    //Draw blue z-axis and return turtle to the origin of
    // the 3D world.
    joe.setPenColor(Color.BLUE);
    joe.moveTo(p3dX(0,0,265)+originX,
               p3dY(0,0,265)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Draw the colored 3D axes lines</b></font></p>
<p>The purpose of the code in Listing 5 is to draw colored lines that represent 
the axes in 3D space.&nbsp; <i>(The ends of those axes can be seen protruding 
from the right, front, and top of the cube in Figure 3.)</i></p>
<p>The lines are drawn by causing the turtle to move from one location to 
another and causing the turtle tracks to be visible.&nbsp; The colors of the 
turtle tracks are controlled by calls to the turtle's <b>setPenColor</b> method.&nbsp; 
The width of the lines is set to two pixels by a call to the turtle's <b>
setPenWidth</b> method.&nbsp; I explained both of these methods in the previous 
lesson.&nbsp; <i>(See The Pen and PathSegment Classes in <a href="#Resources">Resources</a>.)</i></p>
<p><font color="#FF0000"><b>An illusion of transparency</b></font></p>
<p>Note that because of the sequence in which the world repaints itself, with 
the historical turtle tracks being drawn last, these lines are drawn on top of 
the colored pixels that color the sides of the cube in Figure 3. <i>(I also 
explained the sequence in which the world repaints itself in an earlier lesson.)</i>&nbsp; 
This makes it look as though the faces of the cube in Figure 3 are transparent, 
allowing the lines to show through the faces of the cube.</p>
<p><font color="#FF0000"><b>Projecting the line's coordinates onto the 2D 
display plane</b></font></p>
<p>The turtle's <b>moveTo</b> method, which is called several times in Listing 
5, knows nothing about 3D space.&nbsp; Rather, it requires a pair of x and y 
coordinate values on the 2D display plane.</p>
<p>Each time the <b>moveTo</b> method is called in Listing 5, calls to the <b>
p3Dx</b> and <b>p3Dy</b> methods <i>(see Listing 3)</i> are made to project the 
3D coordinate values that define the end of the move to coordinates on the 2D 
display plane.&nbsp; Then the values of the constants named <b>originX</b> and
<b>originY</b> are added to the 2D coordinate values to translate the origin in 
3D space from the upper-left corner of the 2D display plane to the location 
shown in Figure 3.</p>
<p><font color="#FF0000">
<b>Draw black lines that outline the cube</b></font></p>
<p>The purpose of the code in Listing 6 is to draw the black lines that outline the cube 
shown in Figure 3.&nbsp; If you understand the code in Listing 5, you should 
have no problems with the code in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Draw black lines that outline the cube. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    joe.setPenWidth(1);//Draw narrow black lines.
    joe.setPenColor(Color.BLACK);
    
    //Draw four lines that outline the base of a cube. The
    // size of the cube is 256 pixels on each side.
    joe.moveTo(p3dX(0,0,255)+originX,
               p3dY(0,0,255)+originY);
    joe.moveTo(p3dX(255,0,255)+originX,
               p3dY(255,0,255)+originY);
    joe.moveTo(p3dX(255,0,0)+originX,
               p3dY(255,0,0)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);
    
    //Move up and draw four lines that outline the top of
    // the cube.
    joe.moveTo(p3dX(0,255,0)+originX,
               p3dY(0,255,0)+originY);
    joe.moveTo(p3dX(0,255,255)+originX,
               p3dY(0,255,255)+originY);
    joe.moveTo(p3dX(255,255,255)+originX,
               p3dY(255,255,255)+originY);
    joe.moveTo(p3dX(255,255,0)+originX,
               p3dY(255,255,0)+originY);
    joe.moveTo(p3dX(0,255,0)+originX,
               p3dY(0,255,0)+originY);
    
    //Draw three vertical lines at the corners.
    joe.moveTo(p3dX(0,255,255)+originX,
               p3dY(0,255,255)+originY);
    joe.moveTo(p3dX(0,0,255)+originX,
               p3dY(0,0,255)+originY);
    
    joe.moveTo(p3dX(255,0,255)+originX,
               p3dY(255,0,255)+originY);
    joe.moveTo(p3dX(255,255,255)+originX,
               p3dY(255,255,255)+originY);
    
    joe.moveTo(p3dX(255,255,0)+originX,
               p3dY(255,255,0)+originY);
    joe.moveTo(p3dX(255,0,0)+originX,
               p3dY(255,0,0)+originY);
  
  }//end drawLines</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 6 also signals the end of the method named <b>drawLines</b>.</p>
<p><font color="#FF0000"><b>Return to the method named run</b></font></p>
<p>Now, returning to the method named <b>run</b> that began in Listing 4, 
Listing 7 paints the top surface of the cube shown in Figure 3.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Paint the top surface of the cube. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Paint the top of the cube. Begin by getting a 
    // reference to the Picture object that belongs to the
    // world by default.
    Picture picture = mars.getPicture();
    
    Pixel pixel = null;//a working variable
    
    for(int blu = 0;blu &lt; 256;blu++){
      for(int rd = 0;rd &lt; 256;rd++){
        //Hold the green coordinate constant.
        int grn = 255;
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The background image of a World object</b></font></p>
<p>As you will learn when I explain the <b>World</b> class in a future lesson, 
every <b>World</b> object contains a reference to an object of the class named
<b>Picture</b>.&nbsp; <i>(Picture is a large and complex class that I will also 
explain in a future lesson.)</i>&nbsp; As the name implies, the <b>Picture</b> object provides a 
background image for the world.</p>
<p>By default, the background image is simply all white.&nbsp; However, as you 
can see in Figure 5, the default all-white background image can be replaced by any image that we 
want to place there.</p>
<p>In this program, we begin with an all-white default background image and change the colors 
of selected pixels to produce the image shown in Figure 3.&nbsp; <i>(Note 
however, that as I 
explained in an earlier lesson, turtle tracks do not become a permanent part of 
the background image of a <b>World</b> object.)</i></p>
<p><font color="#FF0000">
<b>Paint the top surface of the cube</b></font></p>
<p>Listing 7 begins by getting a reference to the world's <b>Picture</b> object.&nbsp; 
Then Listing 7 uses a pair of nested <b>for</b> loops to change the color of 
every pixel on the top surface of the cube.&nbsp; As before, calls to the methods 
named <b>p3dX</b> and <b>p3dY</b> are called to project 3D coordinate values on 
the top surface of the cube to x and y coordinate values on the 2D display plane.</p>
<p><font color="#FF0000"><b>The set of all possible 3D color coordinates for 
which...</b></font></p>
<p>The top plane of the cube in Figure 3 represents the set of all possible 3D 
color coordinates for which the green or vertical coordinate value is held 
constant at a value of 255.</p>
<p>Hence the code in Listing 7 iterates through all possible combinations of 
red, green, and blue for a constant value of 255 for green.&nbsp; <i>(There are 
65,536 such coordinates.)</i></p>
<p>This process results in a color of pure green at the <a href="#top_back_left_corner">
top back left corner</a> of the cube in Figure 3 and a color of white at the
<a href="#top_front_right_corner">top front right corner</a> of the cube.&nbsp; 
Similarly, it results in a color of yellow at the
<a href="#top_back_right_corner">top back right corner</a> and a color of cyan 
at the <a href="#top_front_left_corner">top front left corner</a>.</p>
<p><font color="#FF0000"><b>Changing the color of a pixel</b></font></p>
<p>As mentioned earlier, the color of every pixel in the default background 
picture of a <b>World</b> object is white.&nbsp; The picture's <b>getPixel</b> 
method is called repeatedly in Listing 7 to get access to the individual pixels 
that make up the top surface of the cube.&nbsp; The pixel's <b>setColor</b> 
method is called to set the color component values for each pixel to the desired 
values.</p>
<p><font color="#FF0000">
<b>Paint the front and right surfaces of the cube</b></font></p>
<p>Listing 8 uses code similar to the code in Listing 7 to paint the front and 
right surfaces of the cube in Figure 3.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Paint the front and right surfaces of the 
cube. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    //Paint the front surface of the cube    
    for(int grn = 0;grn &lt; 256;grn++){
      for(int rd = 0;rd &lt; 256;rd++){
        int blu = 255;//hold the blue coordinate constant.
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop
    
    //Paint the right-most surface of the cube
    for(int grn = 0;grn &lt; 256;grn++){
      for(int blu = 0;blu &lt; 256;blu++){
        int rd = 255;//hold the red coordinate constant
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop
    
    //Force the world to repaint itself.
    mars.setVisible(false);
    mars.setVisible(true);
  }//end run
  //----------------------------------------------------//
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you understood the code in Listing 7, you should have no difficulty 
understanding the code in Listing 8.</p>
<p>Listing 8 also signals the end of the class named <b>Runner</b> and the end 
of the program.</p>
<h3><a name="The_program_named_Java_350b">The program named Java 350b</a></h3>
<p>The purpose of this program is to plot and display the values that result from 
computing the color-distances between a white pixel and an adjacent black pixel.&nbsp; 
The program also illustrates the usefulness of a <b>Turtle</b> object for 
plotting <i>wiggly-line</i> data, such as the red plots shown in Figure 5.</p>
<p><font color="#FF0000"><b>Black pixels on a white background</b></font></p>
<p>In this program, four groups of black pixels are placed in a white picture in a world.&nbsp;
<i>(If you look very closely, you can see the black pixels immediately below the 
centers of the red lines in Figure 4.)</i>&nbsp; </p>
<p>The first group of black pixels actually isn't a group at all.&nbsp; Instead, it is a single 
black pixel on a horizontal row of white pixels near the top of Figure 4.&nbsp; The 
second group consists of two adjacent black pixels on a horizontal row of 
white pixels.&nbsp; The third group consists of three adjacent black pixels on a 
row of white pixels, and the 
fourth group consists of four adjacent black pixels on a row of white pixels at the bottom of Figure 4.</p>
<p><font color="#FF0000"><b>Compute and plot the color distances</b></font></p>
<p>The color-distance between adjacent pixels is computed and plotted as a 
red wiggly-line plot for each of the four rows of pixels containing 
black pixels in Figure 4.</p>
<p>The value of the color distance between adjacent white pixels or between 
adjacent black pixels is zero.&nbsp; The value of the color distance between a 
white pixel and a black pixel <i>(regardless of the order)</i> is approximately 
441.67.&nbsp; This results in the red peaks <i>(at the locations of the black 
pixels)</i> in the wiggly-line plots shown in Figure 4 being quite large.</p>
<p><font color="#FF0000"><b>A more detailed description of the procedure</b></font></p>
<p>More specifically, the program traverses four specific rows of pixels from 
left to right on the 
image, computing the color distance between the color of the current pixel and 
the color of the pixel immediately to its right.</p>
<p>The color distance values for each traversal are 
saved in an array of type <b>double</b>.&nbsp; Then the program uses a turtle to plot 
the distance values as a red wiggly-line plot across the image with the baseline of 
the plot being one pixel above the row of pixels for which the distance values 
were computed.</p>
<p>As mentioned above, the peaks in the wiggly line correspond to locations on the 
row of pixels where there are abrupt changes in the color values from white to 
black or black to white.</p>
<p><font color="#FF0000"><b>The numeric results</b></font></p>
<p>I temporarily modified the program to print the numeric color-distance values 
as the program was running.&nbsp; The numeric values produced by the computation
<i>(in the 
vicinity of each group of black pixels)</i> are shown in Figure 6.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Numeric color distance values. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
      <pre>
<u><b>Row Pix Color distance</b></u>
123 208 0
123 209 441.6729559300637
123 210 441.6729559300637
123 211 0

246 208 0
246 209 441.6729559300637
246 210 0
246 211 441.6729559300637
246 212 0

369 208 0
369 209 441.6729559300637
369 210 0
369 211 0
369 212 441.6729559300637
369 213 0

492 208 0
492 209 441.6729559300637
492 210 0
492 211 0
492 212 0
492 213 441.6729559300637
492 214 0
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>And the numeric results were...</b></font></p>
<p>For the case of a single black pixel surrounded by white pixels in row 123, the 
color-distance computation resulted in two peaks with values of approximately 441.67 
surrounded by values of zero.&nbsp; <i>(The two peaks run together and 
appear as a single peak that is two pixels wide in Figure 4.)</i></p>
<p>For the case of two adjacent black pixels surrounded by white pixels in row 
246, the color distance computation again resulted in two peaks with values of 
441.67 surrounded by values of zero.&nbsp; However, in this case, the two peak 
values&nbsp;were separated by a value of zero and the two peaks are visually 
separable in Figure 4.</p>
<p>Finally, for the case of four adjacent black pixels surrounded by white 
pixels in row 492, the color distance computation resulted in two peaks with 
values of 441.67 surrounded by values of zero.&nbsp; In this case the two peak 
values were separated by three values of zero and are clearly visually separable in the 
bottom red plot in Figure 4.</p>
<p><font color="#FF0000"><b>An interpretation of the results</b></font></p>
<p>The interpretation of these results is that as the computation of color 
distance moves across a row of pixels from left to right, a strong peak is 
produced by the abrupt change from white to black and again by the abrupt change 
from black to white.&nbsp; In those areas where the color of two adjacent pixels 
is either white or black, the output of the color-distance computation is zero.</p>
<p>This knowledge can be used to understand the results that you saw in Figure 5 
where you can see peaks on both sides of the nearly white spots on the nearly 
black butterfly wings.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>A complete listing of the program named Java350b is provided in Listing 18 
near the end of the lesson.&nbsp; As usual, I will explain the code in 
fragments.</p>
<p>The program begins in Listing 9 with code that is essentially the same as in the 
previous program.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Beginning of the program named Java350b </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 9 instantiates a new object of the <b>Runner</b> class and calls the
<b>run</b> method on that object.</p>
<p><font color="#FF0000">
<b>Beginning of the Runner class and the run method</b></font></p>
<p>Listing 10 shows the beginning of the <b>Runner</b> class and the <b>run</b> 
method.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Beginning of the Runner class and the 
run method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    
    //Create a new World object containing a default white
    // Picture object.
    int width = 420;
    int height = 493;
    World mars = new World(width,height);
    
    //Get a reference to the all-white picture that is 
    // contained in the World object by default.
    Picture picture = mars.getPicture();
    
    //Create a new Turtle object and place it in the 
    // default location at the center of the world. Make 
    // the turtle invisible and set its pen color to RED.
    Turtle joe = new Turtle(mars);
    joe.setVisible(false);
    joe.setPenColor(Color.RED);

    //Create an array for storage of the color-distance 
    // data.
    double[] distance = new double[width];
    
    //Loop and process four horizontal rows of pixels.
    for(int row = height/4,num = 1;row &lt; height;
                                   row += height/4,num++){
      
      //Place adjacent black pixels at the center of each 
      // row with the number of pixels ranging from 1 on 
      // the first row to 4 on the last row.
      Pixel pix = null;
      for(int cntr = 0;cntr &lt; num;cntr++){
        pix = picture.getPixel(cntr + width/2,row);
        pix.setColor(Color.BLACK);
      }//end for loop
      
      //Populate the array with the color-distances 
      // between adjacent pixels for the specified row.
      <b>getColorDistance</b>(picture,row,distance);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Nothing new here</b></font></p>
<p>With the exception of the call to the <b>getColorDistance</b> method, there 
is nothing in Listing 10 that you haven't seen before.&nbsp; Therefore, this 
code shouldn't require much of an explanation beyond the embedded comments.</p>
<p>As before, this program instantiates a new <b>World</b> object containing a 
default <b>Picture</b> object producing an all white background.&nbsp; Then the 
code executes a <b>for</b> loop to process the four rows of pixels indicated by 
the red horizontal lines in Figure 4.</p>
<p>Near the beginning of this <b>for</b> loop, the program uses another short <b>for </b>loop to place the black pixels in the white background as 
explained earlier.</p>
<p>Then Listing 10 calls the <b>getColorDistance</b> method to compute the 
color-distance values for a specific row of pixels and uses that data to populate 
an array object of type <b>double</b>.&nbsp; At this point, I will put the <b>
run</b> method on and explain the method named <b>
getColorDistance</b>, which is shown in its entirety in Listing 11.</p>
<p><font color="#FF0000">
<b>The getColorDistance method</b></font></p>
<p>  This method populates an array of type <b>double</b> with the color distances between adjacent pixels on a specified row of a specified 
<b>Picture</b> object.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. The getColorDistance method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  void getColorDistance(
               Picture picture,int row,double[] distance){
    Pixel pix1;
    Pixel pix2;
    for(int cnt = 0;cnt &lt; distance.length-1;cnt++){
      //Get two adjacent pixels in the specified row.
      pix1 = picture.getPixel(cnt,row);
      pix2 = picture.getPixel(cnt + 1,row);
      //Get and save the color distance between the two
      // pixels.
      distance[cnt] = pix1.<b>colorDistance</b>(pix2.getColor());
    }//end for loop
  }//end getColorDistance</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Once again, what is the color distance?</b></font></p>
<p>I told you earlier that the <i>color distance</i> between two pixels is the 
positive length of a line segment that connects two points inside of or on the 
surface of the 3D color cube in Figure 3, where each point represents the color 
of a pixel.&nbsp; However, I didn't tell you how to compute that distance.</p>
<p><font color="#FF0000"><b>Ericson's colorDistance method</b></font></p>
<p>The truth is that you really don't need to know how to compute the color 
distance to program using Ericson's multimedia library.&nbsp; An object of 
Ericson's <b>Pixel</b> class provides a method named <b>colorDistance</b> that 
can be called to return the color distance between the current pixel and the 
color of another pixel.&nbsp; Listing 11 calls that method to compute the color 
distance between each pixel on the row and its neighbor immediately to its 
right.</p>
<p><font color="#FF0000"><b>Some insight might be helpful</b></font></p>
<p>However, I will provide some insight as to how the color distance is 
computed.&nbsp; You are probably already aware that you can use the
<a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean Theorem</a> 
to compute the distance between any two points in a 2D coordinate system.&nbsp; 
Using the x and y coordinates of the two points, you can construct the base and 
the opposite side of a right triangle where the hypotenuse of the triangle is 
the line segment that joins the two points.&nbsp; Then you can apply the 
Pythagorean Theorem to compute the length of the hypotenuse as the square root 
of the sum of the squares of the base and the opposite side of the right 
triangle.&nbsp; This will give you the distance between the two points.</p>
<p><font color="#FF0000"><b>A very similar process</b></font></p>
<p>Computing the distance between two points in 3D space involves a very similar 
process.&nbsp; Rather than to try to describe the process in words, I will 
simply show you Ericson's source code for the <b>colorDistance</b> method of the
<b>Pixel</b> class <i>(see Listing 12)</i>.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Source code for the Pixel's 
colorDistance method.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
public double colorDistance(Color testColor){
  double redDistance = this.getRed() - testColor.getRed();
  double greenDistance = 
                   this.getGreen() - testColor.getGreen();
  double blueDistance = 
                     this.getBlue() - testColor.getBlue();
  double distance = Math.sqrt(
                           redDistance * redDistance + 
                           greenDistance * greenDistance +
                           blueDistance * blueDistance);
  return distance;
}//end color distance method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you examine the code in Listing 12, you should be able to see the 
similarity between this code and code that you would write to compute the 
distance between two points in 2D space.</p>
<p><font color="#FF0000"><b>Returning to the run method</b></font></p>
<p>Returning now to the <b>run</b> method, Listing 13 uses the turtle object in 
conjunction with the color distance data in the array referred to by the 
variable named <b>distance</b> to draw the red lines shown in Figure 4.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Plot the red wiggly line. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Baseline for wiggly line plot.
      int baseline = row-1;
      
      //Move the turtle to the right edge of the World
      // one pixel above the value of the row. Don't leave
      // a turtle track in the process.
      joe.setPenDown(false);
      joe.moveTo(width,baseline);
      joe.setPenDown(true);
      
      //Draw a baseline by moving turtle to the left side
      // of the world.
      joe.moveTo(0,baseline);
      
      //Draw the wiggly line. Change the sign of the
      // distance values to cause positive values to
      // peak upward on the screen.  Scale the distance
      // values down by a factor of 4. This should result
      // in a peak value of 110 pixels
      for(int cnt = 0;cnt &lt; distance.length;cnt++){
        joe.moveTo(cnt+1,baseline-(int)(distance[cnt]/4));
      }//end inner for loop
    
    }//end outer for loop

  }//end run method
  //----------------------------------------------------//
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing in Listing 13 that you haven't seen before, so no 
explanation should be required beyond the embedded comments.</p>
<p>Listing 13 also signals the end of the <b>run</b> method and the end of the 
program.</p>
<h3><a name="The_program_named_Java_350c">The program named Java 350c</a></h3>
<p>The purpose of this program is to provide a springboard for explaining the 
behavior of the edge-detection program that I will explain later.</p>
<p>This program displays an image of a 
butterfly on a <b>World</b> object as shown in Figure 5.&nbsp; Then it traverses 
four specific horizontal rows of pixels on the image, computing the color 
distance between the current pixel and the pixel 
immediately to its right.&nbsp; As in the previous program, the distance values 
are saved in an array of type <b>double</b>.</p>
<p><font color="#FF0000"><b>Plot color distance data as wiggly-line plots</b></font></p>
<p>Then the program uses a turtle to plot the distance values as a wiggly line 
across the image with the baseline of the plot being one pixel above the row of 
pixels for which the distance values were computed.&nbsp; The peaks in the 
wiggly line correspond to locations on the row of pixels where there are abrupt 
changes in the color values.</p>
<p>The color-distance values in Figure 5 are plotted to the same scale as the 
color distance values plotted by the program named Java350b in Figure 4.&nbsp; 
Therefore, those values, which show the maximum distance between a white pixel 
and a black pixel in Figure 4, can be used to visually calibrate the color 
distances associated with color changes in the butterfly image.&nbsp; None of 
the peaks in Figure 5 are as tall as the peaks in Figure 4, meaning that there 
are no cases in Figure 5 where the color changes from absolute black to absolute 
white.</p>
<p><font color="#FF0000"><b>Useful for edge detection</b></font></p>
<p>As you will see later, this technique is very useful for doing edge detection in 
order to produce results similar to those shown in Figure 2.</p>
<p><font color="#FF0000"><b>Very similar program code</b></font></p>
<p>As you may have guessed, this program is very similar to the program 
named Java350b.&nbsp; About the only difference is that this program loads the 
image of the butterfly into the world's <b>Picture</b> object instead of 
creating an image using program code by placing groups of black pixels on the 
default world's picture having a white background.&nbsp; Therefore, I won't bore 
you by explaining the code for this program.&nbsp; You will find a complete 
listing of the code in Listing 19 near the end of the lesson.</p>
<h3><a name="The_program_named_Java_350d">The program named Java 350d</a></h3>
<p>This is an edge-detection program.&nbsp; The program displays an image of a 
butterfly on a World object as shown in Figure 1.&nbsp; Then it traverses each 
horizontal row of pixels on the image, computing the color-distance between the 
color of the current pixel and the color of the pixel immediately to its right.</p>
<p><font color="#FF0000"><b>White pixels and black pixels</b></font></p>
<p>If the color-distance value is greater than a specified threshold, the color of 
the left-most pixel in the pair is changed to black.&nbsp; Otherwise, it is 
changed to white.&nbsp; The result is a picture resembling a pencil drawing of 
the butterfly as shown in Figure 2.&nbsp; Increasing the threshold value 
will decrease the number of black pixels in the output.</p>
<p><font color="#FF0000"><b>A relatively simple program</b></font></p>
<p>After having worked your way through the three earlier programs in this lesson, you may 
be surprised to learn how simple this edge-detection program really is.&nbsp; I suppose 
that 
means that it is much more difficult to explain how edge detection works than it 
is to actually perform edge detection on an image once you understand the 
process.</p>
<p><font color="#FF0000"><b>Source code for the program named Java350d</b></font></p>
<p>A complete listing of this program is provided in Listing 20 near the end of 
the lesson.&nbsp; This program begins just like the other programs in this 
lesson by instantiating an object of the <b>Runner</b> class and calling the <b>
run</b> method on that object.&nbsp; The source code for the <b>Runner</b> 
method and the <b>run</b> class begins in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Beginning of the Runner class and run 
method for Java350d. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  void run(){
    //Clipping threshold for edge detection.
    int threshold = 18;
    
    //Create and display a Picture object using an image 
    // file in the current directory.
    Picture picture = new Picture("butterfly1.jpg");
    picture.show();
    
    //Create a new World object and assign the above 
    // Picture object to the World picture. Note that the
    // size of the world was set to be slightly smaller
    // than the size of the image, which is 422x497.
    int width = 420;
    int height = 493;
    World mars = new World(width,height);
    mars.setPicture(picture);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The variable named threshold</b></font></p>
<p>With the exception of the declaration of the variable named <b>threshold</b>, 
there is nothing new in Listing 14.&nbsp; As you will see later, the color 
distance values are compared to the threshold value to determine whether to 
replace the current pixel with a black pixel or a white pixel.&nbsp; Increasing 
the threshold value will typically decrease the number of black pixels.</p>
<p><font color="#FF0000">
<b>Perform edge detection on the image</b></font></p>
<p>The remainder of the <b>run</b> method is shown in Listing 15.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Perform edge detection on the image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Loop and process each horizontal rows of pixels
    // to produce the edge-detected output.
    for(int row = 0;row &lt; height;row++){
      <b>edgeDetector</b>(picture,row,width,threshold);
    }//end outer for loop
    
    //Force a repaint
    mars.setVisible(false);
    mars.setVisible(true);

  }//end run method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 15 uses a <b>for</b> loop to call the method named <b>edgeDetector</b> 
once for each row of pixels in the image.&nbsp; I'll explain that method shortly.</p>
<p><font color="#FF0000"><b>Force a repaint</b></font></p>
<p>In the meantime, the last two statements in Listing 15 force the world to be 
repainted.&nbsp; I found that without this code on my computer, the world is 
sometimes displayed in an incomplete state with part of the image having been 
edge-detected and part of the image still in its raw form.&nbsp; I also found 
that to be true for one of the earlier programs as well, but I forgot to mention 
it when I was explaining that program.</p>
<p><font color="#FF0000">
<b>The edge detector method</b></font></p>
<p>The edge detector method is shown in its entirety in Listing 16.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. The edge detector method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  void edgeDetector(
         Picture picture,int row,int width,int threshold){
    Pixel pix1;
    Pixel pix2;
    for(int cnt = 0;cnt &lt; width-1;cnt++){
      //Get two adjacent pixels in the specified row.
      pix1 = picture.getPixel(cnt,row);
      pix2 = picture.getPixel(cnt + 1,row);
      //Get and save the color distance between the two
      // pixels.
      double distance = 
                      pix1.colorDistance(pix2.getColor());
      
      //Compare the color distance to the threshold and 
      // change pixel color accordingly.
      if(distance &gt; threshold){
        pix1.setColor(Color.BLACK);
      }else{
        pix1.setColor(Color.WHITE);
      }//end else
      
    }//end for loop
  }//end edgeDetector
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Change pixels to either black or white</b></font></p>
<p>This method computes the color-distances between each pair of adjacent pixels 
on a specified row of a specified <b>Picture</b> object in a manner similar to 
the earlier program.&nbsp; However, in this case, if the value of the color 
distance is greater than a specified threshold, the color of the left-most pixel 
in the pair is changed to black.&nbsp; Otherwise, it is changed to white.&nbsp; 
This converts the image shown in Figure 1 into the image shown in Figure 2.</p>
<p><font color="#FF0000"><b>Other interesting variations on the same theme</b></font></p>
<p>There are many interesting variations that you can apply to this process.&nbsp; 
For example, if you increase the threshold value to 54, change the color from 
BLACK to RED in Listing 16, and eliminate the <b>else</b> clause in Listing 16, you will produce the output image shown in Figure 
7.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Another variation on edge detection. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350f.jpg" width="429" height="522"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Butterfly with red outline and color inversion</b></font></p>
<p>If you increase the threshold value to 54, change the color from BLACK to RED 
in Listing 16, and invert the color of all the pixels that fall below the 
threshold, you will produce the output image shown in Figure 8.&nbsp; <i>(I will 
explain how to invert pixel colors in a future lesson.)</i></p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Butterfly with red outline and color 
	inversion. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350g.jpg" width="429" height="522"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Be adventuresome</b><br />
  For a little adventure, open this HTML file in Microsoft Word and<i> select</i> 
	Figure 9.&nbsp; You should see a very strong resemblance between that image 
	and a raw version of Figure 7.&nbsp; Alternately, select Figure 7 in Word 
	and compare it with the raw version of Figure 9.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
 <b>Butterfly with cyan outline and color inversion</b></font></p>
<p>If you increase the threshold value to 54, change the color from BLACK to 
CYAN 
in Listing 16, and invert the color of all the pixels that fall below the 
threshold, you will produce the output image shown in Figure 9.</p>
<p>
 <b><a name="Figure_9">Figure 9</a>. Butterfly with cyan outline and color 
	inversion. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java350h.jpg" width="429" height="522"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>And that's a wrap</b></font></p>
<p>That is the end of the program, and almost the end of the lesson.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 17 through Listing 20, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I presented and explained four different programs in this lesson.&nbsp; The last 
program taught you how to do <i>edge detection</i> on an image.&nbsp; The first three 
programs were designed to help you understand how edge detection works.&nbsp; 
Those programs also taught you about <i>color distance</i>, and how to project 
3D coordinates onto a 2D display plane.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn how to write a Java program to apply a blurring or softening filter to 
your digital photos with the amount of softening being controlled by a slider.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a rel="license" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a href="http://coweb.cc.gatech.edu/mediaComp-plan/101">Media 
	Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a href="http://drjava.sourceforge.net/">DrJava</a> download site</li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, the JavaPLT 
	group at Rice University</a></li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava Open Source 
	License</a></li>
	<li><a href="http://www.developer.com/java/article.php/1440571">The Essence 
	of OOP using Java, The this and super Keywords</a></li>
	<li><font color="#000000">
	<a href="http://www.dickbaldwin.com/java/Java058.htm">Threads of Control</a></font></li>
	<li><a href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Swing</a></li>
	<li><a href="http://en.wikipedia.org/wiki/Turtle_graphics/">Wikipedia Turtle 
	Graphics</a></li>
	<li><a href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li><a href="http://www.vectorcad3d.com/support/lathetutorial.htm">Vector 
	Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li><a href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable&nbsp; </li>
	<li><a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D 
	Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D 
	Graphics, The Point2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D 
	Graphics, The Graphics2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D 
	Graphics, Simple Affine Transforms</li>
	<li><a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D 
	Graphics, The Shape Interface, Part 1</li>
	<li><a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D 
	Graphics, The Shape Interface, Part 2</li>
	<li><a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D 
	Graphics, Solid Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D 
	Graphics, Gradient Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D 
	Graphics, Texture Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D 
	Graphics, The Stroke Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D 
	Graphics, The Composite Interface and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D 
	Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D 
	Graphics, The Color Constructors and Transparency</li>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started&nbsp;</li>
	<li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight&nbsp; </li>
	<li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</li>
	<li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion </li>
	<li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java</li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1 </li>
	<li><a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2</li>
	<li><a href="http://www.developer.com/java/other/article.php/3640776">416</a> 
	Processing Image Pixels, An Improved Image-Processing Framework in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3650011">418</a> 
	Processing Image Pixels, Creating Visible Watermarks in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3645761">450</a> 
	A Framework for Experimenting with Java 2D Image-Processing Filters</li>
	<li><a href="http://www.developer.com/java/other/article.php/3654171">452</a> 
	Using the Java 2D LookupOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3670696">454</a> 
	Using the Java 2D AffineTransformOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3681466">456</a> 
	Using the Java 2D LookupOp Filter Class to Scramble and Unscramble Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3686856">458</a> 
	Using the Java 2D BandCombineOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3696676">460</a> 
	Using the Java 2D ConvolveOp Filter Class to Process Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3698981">462</a> 
	Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to Process 
	Images</li>
	<li><a href="http://www.dickbaldwin.com/java/Java506.htm">506</a> JavaBeans, 
	Introspection</li>
	<li><a href="http://www.developer.com/java/other/article.php/2114451">2100</a> 
	Understanding Properties in Java and C#</li>
	<li><a href="http://www.developer.com/java/other/article.php/3495121">2300</a> 
	Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3793401">346</a> 
	Wrapping Up the SimpleTurtle Class:&nbsp; Multimedia Programming with Java</li>
	<li><a href="http://www.dickbaldwin.com/java/Java348.htm">348</a> The Pen and PathSegment Classes:&nbsp; Multimedia Programming with Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3795761">349</a> A Pixel Editor Program in Java:&nbsp; Multimedia Programming with 
	Java</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 17 through Listing 20 below.
<p>
<b><a name="Listing_17">Listing 17</a>. Source code for the program named Java350a. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*********************************************************
Program Java350a
Copyright R.G.Baldwin, 2009
This program creates and displays a 3D color cube that 
displays various combinations of red, green, and blue on 
the top, the front, and the right-most side of the cube.

The purpose of the program is to provide a platform for 
discussing the concept of the distance between two colors
as points in 3D space.  The positive red axis is toward 
the right.  The positive green axis is up, and the 
positive blue axis is toward the viewer.  The type of 
projection that was used is a Cavalier projection with the
angle phi equal to 45 degrees.  

See http://local.wasp.uwa.edu.au/~pbourke/geometry
/classification/ for more information on  projection 
types.

Tested under Win XP using the Ericson multimedia library.
*********************************************************/
import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main
//======================================================//

class Runner{
  final double sin45 = 0.7071067811865476;
  final double cos45 = 0.7071067811865476;
  final int width = 460;
  final int height = 460;
  final int originX = (int)(0.42*width);
  final int originY = (int)(0.59*height);
  World mars = null;
  //----------------------------------------------------//
  
  //The purpose of each of the following two methods is to
  // project a point in 3D space onto a 2D surface for 
  // display using a Cavalier projection with the angle 
  // phi equal to 45 degrees. This method returns the 
  // 2D x-coordinate where the point is to be plotted.
  int p3dX(int red,int green,int blue){
    return (int)(red-blue*sin45);
  }//end p3Dx
  //----------------------------------------------------//
  
  //This method returns the 2D y-coordinate where the 
  // point is to be plotted.
  int p3dY(int red,int green,int blue){
    //Reverse the sign to account for the fact that
    // positive y-coordinates go down the screen
    return -(int)(green-blue*cos45);
  }//end p3dY
  //----------------------------------------------------//
  
  void run(){
    //Create a new World object.
    mars = new World(width,height);
    
    //Place a new turtle on the right edge of the World 
    // and make it invisible.
    Turtle joe = new Turtle(width,originY,mars);
    joe.setVisible(false);
    
    //Draw colored axes and black lines that outline the 
    // cube.
    drawLines(joe);
   
    //Paint the top of the cube. Begin by getting a 
    // reference to the Picture object that belongs to the
    // world by default.
    Picture picture = mars.getPicture();
    
    Pixel pixel = null;//a working variable
    
    for(int blu = 0;blu &lt; 256;blu++){
      for(int rd = 0;rd &lt; 256;rd++){
        //Hold the green coordinate constant.
        int grn = 255;
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop
    
    //Paint the front surface of the cube
    for(int grn = 0;grn &lt; 256;grn++){
      for(int rd = 0;rd &lt; 256;rd++){
        int blu = 255;//hold the blue coordinate constant.
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop
    
    //Paint the right-most surface of the cube
    for(int grn = 0;grn &lt; 256;grn++){
      for(int blu = 0;blu &lt; 256;blu++){
        int rd = 255;//hold the red coordinate constant
        pixel = picture.getPixel(p3dX(rd,grn,blu)+originX,
                                p3dY(rd,grn,blu)+originY);
        pixel.setColor(new Color(rd,grn,blu));
      }//end for loop
    }//end outer loop
    
    //Force the world to repaint itself.
    mars.setVisible(false);
    mars.setVisible(true);
  }//end run
  //----------------------------------------------------//
  
  //The purpose of this method is to draw colored axes 
  // that represent the 3D space and black lines that 
  // outline the cube. This is accomplished with turtle 
  // tracks.  Note that because of the sequence in which 
  // the world repaints itself, with the historical turtle
  // tracks being drawn last, these lines will be drawn on
  // top of the colored pixels that color the sides of the
  // cube. This makes it look like the sides of the cube 
  // are transparent. I put this code in a separate method
  // simply to provide better organization for the 
  // program.
  void drawLines(Turtle joe){
    //Draw red x-axis by moving the turtle from the right
    // edge to the origin of the 3D world.
    joe.setPenWidth(2);//Draw the colored axes wide.
    joe.setPenColor(Color.RED);
    joe.moveTo(p3dX(0,0,0)+originX,p3dY(0,0,0)+originY);
    
    //Draw green y-axis by moving the turtle to near the
    // top edge of the 3D world and then return to the
    // origin.
    joe.setPenColor(Color.GREEN);
    joe.moveTo(p3dX(0,265,0)+originX,
               p3dY(0,265,0)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);
    
    //Draw blue axis and return turtle to the origin of
    // the 3D world.
    joe.setPenColor(Color.BLUE);
    joe.moveTo(p3dX(0,0,265)+originX,
               p3dY(0,0,265)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);
    
    joe.setPenWidth(1);//Draw narrow black lines.
    joe.setPenColor(Color.BLACK);
    
    //Draw four lines that outline the base of a cube. The
    // size of the cube is 256 pixels on each side.
    joe.moveTo(p3dX(0,0,255)+originX,
               p3dY(0,0,255)+originY);
    joe.moveTo(p3dX(255,0,255)+originX,
               p3dY(255,0,255)+originY);
    joe.moveTo(p3dX(255,0,0)+originX,
               p3dY(255,0,0)+originY);
    joe.moveTo(p3dX(0,0,0)+originX,
               p3dY(0,0,0)+originY);
    
    //Move up and draw four lines that outline the top of
    // the cube.
    joe.moveTo(p3dX(0,255,0)+originX,
               p3dY(0,255,0)+originY);
    joe.moveTo(p3dX(0,255,255)+originX,
               p3dY(0,255,255)+originY);
    joe.moveTo(p3dX(255,255,255)+originX,
               p3dY(255,255,255)+originY);
    joe.moveTo(p3dX(255,255,0)+originX,
               p3dY(255,255,0)+originY);
    joe.moveTo(p3dX(0,255,0)+originX,
               p3dY(0,255,0)+originY);
    
    //Draw three vertical lines at the corners.
    joe.moveTo(p3dX(0,255,255)+originX,
               p3dY(0,255,255)+originY);
    joe.moveTo(p3dX(0,0,255)+originX,
               p3dY(0,0,255)+originY);
    
    joe.moveTo(p3dX(255,0,255)+originX,
               p3dY(255,0,255)+originY);
    joe.moveTo(p3dX(255,255,255)+originX,
               p3dY(255,255,255)+originY);
    
    joe.moveTo(p3dX(255,255,0)+originX,
               p3dY(255,255,0)+originY);
    joe.moveTo(p3dX(255,0,0)+originX,
               p3dY(255,0,0)+originY);
  
  }//end drawLines
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Source code for the program named Java350b.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*********************************************************
Program Java350b
Copyright R.G.Baldwin, 2009

The purpose of this program is to plot and display the 
values resulting from computing the color-distances
between white pixels and black pixel.

The program also illustrates the usefulness of a Turtle 
object for plotting wiggly-line data.

Four groups of black pixels are placed in a white picture.
The first group is a single black pixel on a horizontal 
row of pixels.  The second group consists of two adjacent 
black pixels on a horizontal row of pixels.  The third 
group consists of three adjacent black pixels, and the 
fourth group consists of four adjacent black pixels.

The color-distance between adjacent pixels is computed, 
plotted, and displayed for each row of pixels containing 
black pixels.

The color distance between a white pixel and a black pixel
is 441.67.

More specifically, the program traverses four specific 
rows of pixels on the image, computing the color distance 
between the color of the current pixel and the color of 
the pixel immediately to its right.  The distance values 
are saved in an array of type double.  Then the program 
uses a turtle to plot the distance values as a wiggly 
line across the image with the baseline of the plot being 
one pixel above the row of pixels for which the distance 
values were computed.

The peaks in the wiggly line correspond to locations on 
the row of pixels where there are abrupt changes in the 
color values.

Tested under Win XP using the Ericson multimedia library.
*********************************************************/
import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main
//======================================================//

class Runner{
  void run(){
    
    //Create a new World object containing a default white
    // Picture object.
    int width = 420;
    int height = 493;
    World mars = new World(width,height);
    
    //Get a reference to the all-white picture that is 
    // contained in the World object by default.
    Picture picture = mars.getPicture();
    
    //Create a new Turtle object and place it in the 
    // default location at the center of the world. Make 
    // the turtle invisible and set its pen color to RED.
    Turtle joe = new Turtle(mars);
    joe.setVisible(false);
    joe.setPenColor(Color.RED);

    //Create an array for storage of the color-distance 
    // data.
    double[] distance = new double[width];
    
    //Loop and process four horizontal rows of pixels.
    for(int row = height/4,num = 1;row &lt; height;
                                   row += height/4,num++){
      
      //Place adjacent black pixels at the center of each 
      // row with the number of pixels ranging from 1 on 
      // the first row to 4 on the last row.
      Pixel pix = null;
      for(int cntr = 0;cntr &lt; num;cntr++){
        pix = picture.getPixel(cntr + width/2,row);
        pix.setColor(Color.BLACK);
      }//end for loop
      
      //Populate the array with the color-distances 
      // between adjacent pixels for the specified row.
      getColorDistance(picture,row,distance);
    
      //Baseline for wiggly line plot.
      int baseline = row-1;
      
      //Move the turtle to the right edge of the World
      // one pixel above the value of the row. Don't leave
      // a turtle track in the process.
      joe.setPenDown(false);
      joe.moveTo(width,baseline);
      joe.setPenDown(true);
      
      //Draw a baseline by moving turtle to the left side
      // of the world.
      joe.moveTo(0,baseline);
      
      //Draw the wiggly line. Change the sign of the
      // distance values to cause positive values to
      // peak upward on the screen.  Scale the distance
      // values down by a factor of 4. This should result
      // in a peak value of 110 pixels
      for(int cnt = 0;cnt &lt; distance.length;cnt++){
        joe.moveTo(cnt+1,baseline-(int)(distance[cnt]/4));
      }//end inner for loop
    
    }//end outer for loop

  }//end run method
  //----------------------------------------------------//
  
  //This method populates an array of type double with the
  // color distances between adjacent pixels on a
  // specified row of a specified Picture object.
  void getColorDistance(
               Picture picture,int row,double[] distance){
    Pixel pix1;
    Pixel pix2;
    for(int cnt = 0;cnt &lt; distance.length-1;cnt++){
      //Get two adjacent pixels in the specified row.
      pix1 = picture.getPixel(cnt,row);
      pix2 = picture.getPixel(cnt + 1,row);
      //Get and save the color distance between the two
      // pixels.
      distance[cnt] = pix1.colorDistance(pix2.getColor());
    }//end for loop
  }//end getColorDistance
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Source code for the program named Java350c.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*********************************************************
Program Java350c
Copyright R.G.Baldwin, 2009

The purpose of this program is to provide a platform for 
explaining the behavior of edge-detection programs.

The program displays an image of a butterfly on a World 
object.  Then it traverses four specific horizontal rows 
of pixels on the image, computing the color distance 
between the color of the current pixel and the color of 
the pixel immediately to its right.  The distance values 
are saved in an array of type double.  Then the program 
uses a turtle to plot the distance values as a wiggly line
across the image with the baseline of the plot being one 
pixel above the row of pixels for which the distance 
values were computed.

The peaks in the wiggly line correspond to locations on 
the row of pixels where there are abrupt changes in the 
color values. The color-distance values are plotted to the
same scale as the values plotted in the program named 
Java350b.  Therefore, those values, which show the maximum
distance between a white pixel and a black pixel, can be 
used to visually calibrate the color distances associated 
with color changes in the butterfly image.

This technique is useful for doing edge detection.

Tested under Win XP using the Ericson multimedia library.
*********************************************************/
import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main
//======================================================//

class Runner{
  void run(){
    //Create a Picture object using an image file in the
    // current directory.
    Picture picture = new Picture("butterfly1.jpg");
    
    //Create a new World object and assign the above 
    // Picture object to the World picture. Note that the 
    // size of the world was matched to the size of the 
    // image.
    int width = 420;
    int height = 493;
    World mars = new World(width,height);
    mars.setPicture(picture);
    
    //Create a new Turtle object and place it in the 
    // default location at the center of the world. Make 
    // the turtle invisible and set its pen color to 
    // RED.
    Turtle joe = new Turtle(mars);
    joe.setVisible(false);
    joe.setPenColor(Color.RED);

    //Create an array for storage of the color-distance 
    // data.
    double[] distance = new double[width];
    
    //Loop and process four horizontal rows of pixels.
    for(int row = height/4;row &lt; height;row += height/4){
      
      //Populate the array with the color-distances 
      // between adjacent pixels for the specified row.
      getColorDistance(picture,row,distance);
    
      //Baseline for wiggly line plot.
      int baseline = row-1;
      
      //Move the turtle to the right edge of the World
      // one pixel above the value of the row. Don't leave
      // a turtle track in the process.
      joe.setPenDown(false);
      joe.moveTo(width,baseline);
      joe.setPenDown(true);
      
      //Draw a baseline by moving the turtle to the left 
      // side of the world.
      joe.moveTo(0,baseline);
      
      //Draw the wiggly line. Change the sign of the
      // distance values to cause positive values to
      // peak upward on the screen.  Scale the distance
      // values down by a factor of 4.
      for(int cnt = 0;cnt &lt; distance.length-1;cnt++){
        joe.moveTo(cnt+1,baseline-(int)(distance[cnt]/4));
      }//end inner for loop
    
    }//end outer for loop

  }//end run method
  //----------------------------------------------------//
  
  //This method populates an array of type double with the
  // color distances between adjacent pixels on a
  // specified row of a specified Picture object.
  void getColorDistance(
               Picture picture,int row,double[] distance){
    Pixel pix1;
    Pixel pix2;
    for(int cnt = 0;cnt &lt; distance.length-1;cnt++){
      //Get two adjacent pixels in the specified row.
      pix1 = picture.getPixel(cnt,row);
      pix2 = picture.getPixel(cnt + 1,row);
      //Get and save the color distance between the two
      // pixels.
      distance[cnt] = pix1.colorDistance(pix2.getColor());
    }//end for loop
  }//end getColorDistance
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Source code for the program named Java350d.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*********************************************************
Program Java350c
Copyright R.G.Baldwin, 2009

This is an edge-detection program.

The program displays an image of a butterfly on a World 
object.  Then it traverses each horizontal row of pixels 
on the image, computing the color-distance between the 
color of the current pixel and the color of the pixel 
immediately to its right.  If the color-distance value is
greater than a specified threshold, the color of the 
left-most pixel in the pair is changed to black.  
Otherwise, it is changed to white.

The result is a picture resembling a pencil drawing of the
butterfly. Increasing the threshold value decreases the 
number of black pixels in the output.

Tested under Win XP using the Ericson multimedia library.
*********************************************************/
import java.awt.*;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main
}//end class Main
//======================================================//

class Runner{
  void run(){
    //Clipping threshold for edge detection.
    int threshold = 18;
    
    //Create and display a Picture object using an image 
    // file in the current directory.
    Picture picture = new Picture("butterfly1.jpg");
    picture.show();
    
    //Create a new World object and assign the above 
    // Picture object to the World picture. Note that the
    // size of the world was set to be slightly smaller
    // than the size of the image, which is 422x497.
    int width = 420;
    int height = 493;
    World mars = new World(width,height);
    mars.setPicture(picture);

    //Loop and process each horizontal rows of pixels
    // to produce the edge-detected output.
    for(int row = 0;row &lt; height;row++){
      edgeDetector(picture,row,width,threshold);
    }//end outer for loop
    
    //Force a repaint
    mars.setVisible(false);
    mars.setVisible(true);

  }//end run method
  //----------------------------------------------------//
  
  //This method computes the color-distances between each
  // pair of adjacent pixels on a specified row of a 
  // specified Picture object. If the value is greater 
  // than a specified threshold, the color of the 
  // left-most pixel in the pair is changed to black.
  // Otherwise, it is changed to white.
  void edgeDetector(
         Picture picture,int row,int width,int threshold){
    Pixel pix1;
    Pixel pix2;
    for(int cnt = 0;cnt &lt; width-1;cnt++){
      //Get two adjacent pixels in the specified row.
      pix1 = picture.getPixel(cnt,row);
      pix2 = picture.getPixel(cnt + 1,row);
      //Get and save the color distance between the two
      // pixels.
      double distance = 
                      pix1.colorDistance(pix2.getColor());
      
      //Compare the color distance to the threshold and 
      // change pixel color accordingly.
      if(distance &gt; threshold){
        pix1.setColor(Color.BLACK);
      }else{
        pix1.setColor(Color.WHITE);
      }//end else
      
    }//end for loop
  }//end edgeDetector
  
}//end class Runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp; </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
