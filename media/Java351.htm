<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">A Slider-Controlled Softening Program for Digital 
Photos</h2>
<i>Learn how to write a Java program to apply a blurring or softening filter to 
your digital photos&nbsp; The amount of softening is controlled by the user with 
a slider.</i>
<p><b>Published:</b>&nbsp; February 10, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 351</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_so_far">What you have learned from 
		earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_program_named_SingleSliderTemplate01">The program named 
	SingleSliderTemplate01</a></li>
	<li><a href="#The_program_named_Blur01">The program named Blur01</a></li>
	<li><a href="#The_program_named_Blur02">The program named Blur02</a></li>
</ul></li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_so_far">What you have learned from earlier 
lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> in this 
series, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>Many aspects of image processing, including color distance, projecting 3D coordinates onto a 2D display plane, 
	and edge detection.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p>You will learn how to write a Java program to apply a blurring or softening 
filter to your digital photos with the amount of softening being controlled by a 
slider.</p>
<p>In addition, you will learn how to write a general-purpose slider-controlled 
programming template that makes it relatively easy to apply slider control to a 
variety of digital image-processing tasks</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Sample output from 
	SingleSliderTemplate01.</li>
	<li><a href="#Figure_2">Figure 2</a>. Red color reduced to ten-percent of 
	its original value.</li>
	<li><a href="#Figure_3">Figure 3</a>. Example of blurring a butterfly image.</li>
	<li><a href="#Figure_4">Figure 4</a>. Comparison of programs Blur01 and 
	Blur02. </li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the program named 
	SingleSliderTemplate01.</li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the constructor for 
	SingleSliderTemplate01. </li>
	<li><a href="#Listing_3">Listing 3</a>. Registration of an 
	ActionListener on the text field. </li>
	<li><a href="#Listing_4">Listing 4</a>. Write first copy of backup file. </li>
	<li><a href="#Listing_5">Listing 5</a>. Get filename extension and decorate 
	the GUI. </li>
	<li><a href="#Listing_6">Listing 6</a>. Create the display picture. </li>
	<li><a href="#Listing_7">Listing 7</a>. Draw the initial display and show 
	it. </li>
	<li><a href="#Listing_8">Listing 8</a>. Adjust the width and relocate the 
	GUI. </li>
	<li><a href="#Listing_9">Listing 9</a>. Enable the slider and the button. </li>
	<li><a href="#Listing_10">Listing 10</a>. Register an ActionListener on the 
	Write button. </li>
	<li><a href="#Listing_11">Listing 11</a>. Register a WindowListener object 
	on the JFrame object.</li>
	<li><a href="#Listing_12">Listing 12</a>. Register a ChangeListener object 
	on the JSlider object. </li>
	<li><a href="#Listing_13">Listing 13</a>. The processThePicture method for 
	SingleSliderTemplate01. </li>
	<li><a href="#Listing_14">Listing 14</a>. Beginning of the processThePicture 
	method for Blur01. </li>
	<li><a href="#Listing_15">Listing 15</a>. Working variables. </li>
	<li><a href="#Listing_16">Listing 16</a>. Process each 3x3 square of pixels. </li>
	<li><a href="#Listing_17">Listing 17</a>. Compute the weighted sum of the 
	red color values. </li>
	<li><a href="#Listing_18">Listing 18</a>. Do the same for the green and blue 
	colors. </li>
	<li><a href="#Listing_19">Listing 19</a>. Source code for the program named 
	SingleSliderTemplate01. </li>
	<li><a href="#Listing_20">Listing 20</a>. Source code for the program named 
	Blur01. </li>
	<li><a href="#Listing_21">Listing 21</a>. Source code for the program named 
	Blur02. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#FF0000"><b>Three programs</b></font></p>
<p>I will present and explain three different programs in this lesson.&nbsp; In 
the first program, I will show you how to write a general-purpose template 
program in which some attribute of a digital image is varied through a range of 
values using a slider.&nbsp; The results of varying the attributes are 
immediately visible in a display of the image for which the attributes are being 
varied as shown in Figure 1.</p>
<p><font color="#FF0000"><b>Purpose of the template program</b></font></p>
<p>The main purpose of this template program is to make it possible for you to 
write image processing programs with a minimum of effort.&nbsp; Ideally, by 
using this template, you will be able to concentrate on the image-processing 
logic of such programs and not have to deal with the logistics involved in the 
overall program.</p>
<p><font color="#FF0000"><b>A blurring or softening filter</b></font></p>
<p>The purpose of the second and third programs is to teach you how to write a program to 
apply a blurring or softening filter to your digital photos with the amount of 
softening being controlled by a slider.&nbsp; Once again, the results are 
visible in a display of the image to which the softening filter is being 
applied as shown in Figure 3.</p>
<p><b><font color="#FF0000">A more aggressive blurring filter</font></b></p>
<p>The third program is very similar to the second program.&nbsp; However, the third program applies a 
much more aggressive blurring algorithm to the image.&nbsp; In other words, much 
more blurring occurs for the same travel distance of the slider as shown by the 
comparative output images in Figure 4.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_SingleSliderTemplate01">The program named 
SingleSliderTemplate01</a></h3>
<p>This is a template program, designed to teach you how to structure a program 
in which some attribute of a digital image is varied through a range of values 
using a slider.</p>
<p><font color="#FF0000"><b>The main purpose</b></font></p>
<p>The main purpose of this programming template is to make it possible for you 
to write image processing programs with a minimum of effort.&nbsp; Ideally, by 
using this template, you will be able to concentrate on the image-processing 
logic and not have to deal with the logistics involved in the overall program.&nbsp; 
Note that the template program requires access to Ericson's multimedia library.</p>
<p><font color="#FF0000"><b>Programming and image processing concepts</b></font></p>
<p>The speed and smoothness of programs that you write using this template 
program will depend on a combination of your programming skills and the speed of 
your computer.</p>
<p>This template program is intended to teach programming and 
image processing concepts.&nbsp; It is not intended to make it possible for you 
to write programs that will compete on a speed and convenience basis with 
commercially-available photograph processing programs such as Adobe Photoshop 
Elements.</p>
<p><font color="#FF0000"><b>A two-part screen output</b></font></p>
<p>The screen output produced by the template program consists of the two parts 
shown in Figure 1:</p>
<ul>
	<li>A display of the picture being processed</li>
<li>A GUI containing a slider, a button, and a text field.</li>
</ul>
<p>
 <b>
 <a name="Figure_1">Figure 1</a>. Sample output from SingleSliderTemplate01.</b>
<table bgcolor="#EFE9B8"  border="1" cols="1">
<tr><td><img border="0" src="java351a.jpg" width="329" height="271"></td></tr>
<tr><td><img border="0" src="java351b.jpg" width="328" height="126"></td></tr>
</table></p>

<p><font color="#FF0000"><b>The GUI</b></font></p>
<p>More specifically, the GUI consists of the following components:</p>
<ul>
	<li>A <b>JLabel</b> object that briefly 
describes the purpose of the slider.</li>
<li>The <b>JSlider</b> object.</li>
	<li>A <b>JButton</b> that can be clicked to write backup files.</li>
<li>A <b>JTextField</b> into 
which the user enters the name of the input file.</li>
</ul>
<p><font color="#FF0000"><b>Backup image files</b></font></p>
<p>Each time the user click the button in the GUI, a backup image file 
containing a copy of the current state of the display is written into the same 
directory from which the original image file was read.&nbsp; </p>
<p><font color="#FF0000"><b>Five backup files are saved</b></font></p>
<p>The five most recent backup 
files are saved.&nbsp; The backup files are written in bmp format regardless of the 
format of the original image file in order to avoid the color corruption that can 
occur when images are compressed into JPEG format.</p>
<p><font color="#FF0000"><b>The names of the backup files</b></font></p>
<p>The names of the backup files 
are the same as the name of the original image file except that BAKn is inserted 
immediately ahead of the extension where n is a digit ranging from 0 to 4.&nbsp; The 
value of n rolls over and starts back at 0 when it exceeds 4.</p>
<p><font color="#FF0000"><b>Support for different input file types</b></font></p>
<p>Input files of type jpg, bmp, and png are supported.&nbsp; Other image-file types may be supported 
also but the program has only been tested for the three image-file types listed above.</p>
<p><font color="#FF0000"><b>Location of the GUI</b></font></p>
<p>The GUI appears in the 
upper-left corner of the screen when the program starts running.&nbsp; At this point, both the slider and the button 
are disabled.</p>
<p>When the user enters the name of the input file, a display of the 
image contained in that file appears in the upper-left corner of the screen and 
the GUI is relocated to a position immediately below the display.</p>
<p><font color="#FF0000"><b>When the GUI is ready for image processing</b></font></p>
<p>When the GUI is relocated to the position below the display, 
the slider and the button are enabled and the text field is disabled. </p>
<p>The width of 
the GUI is changed to match the width of the display if possible.&nbsp; For 
example, this is possible in Figure 1 where the display and the GUI have the 
same width.&nbsp; However, 
if the width of the 
display is less than the preferred width of the GUI, the GUI appears 
at its preferred width.&nbsp; This is the case in Figure 3 where the width of 
the GUI is a little greater than the width of the display of the butterfly above 
it.</p>
<p><font color="#FF0000"><b>Location of input files</b></font></p>
<p>If the input file 
is in the current directory, only the file name and extension must be entered 
into the text field.&nbsp; 
Otherwise, a complete path and file name with extension must be entered by 
the user.</p>
<p><font color="#FF0000"><b>Behavior of the demonstration program</b></font></p>
<p>The minimum, maximum, and starting point for the slider is easily controlled 
through program code.</p>
<p>For this demonstration program, the slider 
ranges from 0 to 100 with the initial position of the slider at 100.&nbsp; As the slider 
is moved toward zero, the value of the red color component for every pixel in the 
image is reduced linearly and the display changes to reflect that change in the 
value of the red color component.&nbsp; <i>(The smoothness or lack thereof of the operation 
will depend on the speed of the computer.)</i></p>
<p>When the slider is at the 0 position <i>(full left)</i>, the 
pixels in the image are completely devoid of red color.</p>
<p><font color="#FF0000"><b>Writing a backup file</b></font></p>
<p>Positioning the slider at 
some point along its range and clicking the <b>Write</b> button causes a backup file to be written containing the current state of the display.</p>
<p><font color="#FF0000"><b>Terminating the program</b></font></p>
<p>Clicking the large X in 
the upper-right corner of the display doesn't terminate the program.&nbsp; It simply hides the display and is of no 
practical value.&nbsp; The program is terminated by clicking the large X in the upper-right 
corner of the GUI.</p>
<p><font color="#FF0000"><b>Writing the final output file</b></font></p>
<p>Before terminating, the program writes an output file 
containing the final state of the display in the same format as the input 
file.&nbsp; </p>
<p>The name of the final output file is the same as the name of the original input 
file except that the word FINAL is inserted immediately ahead of the 
extension.&nbsp; <i>(Note that this program does not modify the contents of the original input file.)</i></p>
<p><font color="#FF0000"><b>A ChangeListener object</b></font></p>
<p>A 
<b>ChangeListener</b> object is registered on the slider.&nbsp; Each time the slider fires a 
<b>ChangeEvent</b>, the event handler creates a new display, which is a copy of the original 
picture.&nbsp; Then it calls a method named <b>processThePicture</b>.&nbsp; This 
method is where 
you should write your image processing code.</p>
<p><font color="#FF0000"><b>Using the template program</b></font></p>
<p>The main purpose of this 
template program is to make it possible for you to write image processing 
programs with a minimum of effort.&nbsp; For many different kinds of image processing 
programs, you should be able to confine your programming effort to the following 
three tasks and leave the remainder of the template program intact.</p>
<ul>
	<li>Rewrite the method named <b>processThePicture</b>.</li>
	<li>Reconfigure the minimum, maximum, and starting point values for the 
	slider if necessary.</li>
	<li>Modify the text that appears immediately above the slider in Figure 1.</li>
</ul>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>I will explain this program code in fragments.&nbsp; A complete listing of 
the program is provided in Listing 19 near the end of the lesson.&nbsp; </p>
<p>The 
program begins in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the program named 
SingleSliderTemplate01.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class SingleSliderTemplate01 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =
                new JLabel("<b>Purpose of Slider goes Here</b>");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
             new JTextField("SingleSliderTemplate01.jpg");
  //This slider will extend from 0 to 100 with the initial
  // position at 100. See the documentation to learn how
  // to configure it differently.
  private JSlider slider = new JSlider(0,100,100);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new SingleSliderTemplate01();
  }//end main method
  //----------------------------------------------------//</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 1 consists of the declaration of a large number of instance variables 
and a very simple <b>main</b> method.&nbsp; The embedded comment should suffice 
to tell you what you need to know at this point about the instance variables and 
the <b>main</b> method.</p>
<p><font color="#FF0000">
<b>Beginning of the constructor for the template program</b></font></p>
<p>The constructor for the template program begins in Listing 2.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the constructor for 
SingleSliderTemplate01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public SingleSliderTemplate01(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(10);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(new JLabel("File Name:"));
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>While Listing 2 is rather long and tedious, it is not complicated.&nbsp; 
Hopefully you can understand everything in Listing 2 without further explanation 
from me.</p>
<p><font color="#FF0000"><b>Registration of an ActionListener on the text field</b></font></p>
<p>Things start to get interesting in Listing 3, which begins the process of 
registering an <b>ActionListener</b> object on the text field.</p>
<p>When the user enters the file name in the text field, the <b>actionPerformed</b> 
method that begins in Listing 3 is executed.</p>
<p>The code in the <b>actionPerformed</b> method sets everything up properly so that the program will function as an event-driven picture-manipulation program until the user clicks the large X in the upper-right 
corner of the GUI. </p>
<p align="left">
<b><a name="Listing_3">Listing 3</a>. Registration of an 
ActionListener on the text field. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Straightforward code</b></font></p>
<p>The code in Listing 3 is relatively straightforward.&nbsp; Assuming that you know about anonymous classes 
and event-driven programming in 
Java, and assuming that you have studied the earlier lessons in this series, you should 
have no difficulty understanding the code in Listing 3.</p>
<p><font color="#FF0000">
<b>Write first copy of backup file</b></font></p>
<p>Continuing with the code in the <b>actionPerformed</b> method, the code in Listing 4 writes the first copy of a backup file into the same 
directory from which the input file was read.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Write first copy of backup file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><b><font color="#FF0000">What is the issue here?</font></b></p>
<p>The big issue in Listing 4 is getting a programmatic handle on the directory 
from which the input file was read.&nbsp; Some of the code in Listing 4 may be 
new to you, particularly if you haven't done a lot of file IO in Java.&nbsp; All 
I can tell you is that if you will pull out the trusty Sun documentation and 
look up the class and method names used in Listing 4, it should all make sense.</p>
<p>Be aware, however, that the <b>write</b> method that is called in the last 
statement in Listing 4 is a method of Ericson's <b>Picture</b> class.&nbsp; You 
won't find it in Sun's standard library.&nbsp; Also note that the <b>writeCounter</b> 
variable that we saw in Listing 1 is used to construct the output file name and 
is incremented immediately after it is used.</p>
<p><font color="#FF0000">
<b>Get filename extension and decorate the GUI</b></font></p>
<p>Listing 5 gets and saves the filename extension to be used later when the 
final output file is written.&nbsp; Listing 5 also sets a title on the GUI.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Get filename extension and decorate the 
GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the display picture</b></font></p>
<p>Listing 6 instantiates a new <b>Picture</b> object having the same dimensions 
at the image that was read from the input file and stores the object's reference 
in an instance variable named <b>display</b>.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Create the display picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is the <b>Picture</b> object that will be modified by the method named
<b>processThePicture</b> later.&nbsp; The image that you see in Figure 1 is 
contained in this object.</p>
<p>Neither the original image file nor the <b>Picture</b> object created from 
the image file are modified by this program.</p>
<p><font color="#FF0000">
<b>Draw the initial display</b></font></p>
<p>Listing 7 copies the image from the original <b>Picture</b> object onto the
<b>Picture</b> object referred to by <b>display</b>.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Draw the initial display and show it. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          
          display.show();
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 7 calls the <b>show</b> method on the <b>display</b> picture to 
display it in the format shown in the top image in Figure 1.</p>
<p><font color="#FF0000">
<b>Adjust the width and relocate the GUI</b></font></p>
<p>Listing 8 relocates the GUI to a position immediately below the display.&nbsp; 
In the process, Listing 8 attempts to change the width of the GUI to make it 
match the display.&nbsp; However, if the display is too narrow for the GUI, this 
effort is abandoned and the GUI is displayed in its preferred width.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Adjust the width and relocate the GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Enable the slider and the button</b></font></p>
<p>Listing 9 enables the slider and the button to prepare the GUI for use in 
processing the image.&nbsp; Note that the text field was disabled at the 
beginning of Listing 3.&nbsp; The user has only one opportunity to enter a file 
name in this program.&nbsp; To process a second image file, it is necessary to 
terminate and restart the program.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Enable the slider and the button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 9 also signals the end of the registration of the <b>ActionListener</b> 
object on 
the text field.&nbsp; Once the registration is complete, the program simply 
waits for the user to enter a file name in the text field.&nbsp; When the user enters the file name into the text field, 
the code in the <b>actionPerformed</b> method that began in Listing 3 and ended 
in Listing 9 is executed.&nbsp; Once the <b>actionPerformed</b> method 
terminates, the program simply waits for the user to either move the slider or 
click the button in the GUI.</p>
<p><font color="#FF0000">
<b>Register an ActionListener on the Write button</b></font></p>
<p>Speaking of clicking the button in the GUI, Listing 10 registers an <b>
ActionListener</b> object on that button to define what will happen when the 
user clicks the button.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Register an ActionListener on the Write 
button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Write an output file</b></font></p>
<p>Each time the user clicks the button in the GUI shown in Figure 1, a backup image file of type <i>bmp</i> 
containing the current state of the display is written into the directory from 
which the original picture was read.&nbsp; Although a bmp file is larger in size 
than a jpg file, a bmp file 
was chosen in place of a jpg file to avoid the color corruption that can occur when an image is compressed into a 
jpg file.</p>
<p><font color="#FF0000"><b>Five backup files are saved</b></font></p>
<p>The five most recent backup files are saved.&nbsp; The names of the backup 
files are the same as the name of the original input file except that BAKn is 
inserted immediately ahead of the extension.&nbsp; The character n is a digit 
ranging from 0 to 4.&nbsp; The value of n rolls over at 4 and starts back at 0.</p>
<p>Given the above description and the embedded comments, you should have no 
difficulty understanding the code in Listing 10.</p>
<p><font color="#FF0000">
<b>Register a WindowListener object on the JFrame object</b></font></p>
<p>Listing 11 registers a <b>WindowListener</b> object on the <b>JFrame</b> 
object <i>(that constitutes the GUI)</i> to define what will happen when the 
user clicks the large X in the upper-right corner of the GUI.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Register a WindowListener object on the 
JFrame object.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When that happens, the <b>windowClosing</b> method shown in Listing 11 will 
be executed.&nbsp; This method will write the final state of the display into an 
output file of the same type as the original input file.&nbsp; The name will be 
the same as the name of the input file except that the word FINAL will be 
inserted immediately ahead of the extension.</p>
<p>Then the <b>windowClosing</b> method will cause the program to terminate.</p>
<p><font color="#FF0000">
<b>Register a ChangeListener object on the JSlider object</b></font></p>
<p>We have finally made our way to the reason 
for the existence of this template program.&nbsp; Listing 12 registers a <b>
ChangeListener</b> object on the slider.&nbsp; Each time the user moves the 
slider, it fires a series of events of type <b>ChangeEvent</b>.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Register a ChangeListener object on the 
JSlider object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Execute the stateChanged method</b></font></p>
<p>Each time the slider fires a <b>ChangeEvent</b>, the <b>stateChanged</b> 
method in Listing 12 is executed.&nbsp; Each time the method is executed, it 
draws a new copy of the original picture on the <b>Picture</b> object referred 
to by <b>display</b> and then calls the method named <b>processThePicture</b>.</p>
<p>The intent is that the code in the method named <b>processThePicture</b> will 
be customized to perform the image processing task that is the purpose of the 
program and then cause the display to be repainted on the screen.</p>
<p><font color="#FF0000">
<b>The processThePicture method</b></font></p>
<p>A demonstration version of the method named <b>processThePicture</b> is 
included in the program named
<b>SingleSliderTemplate01.</b>&nbsp; That&nbsp; method is shown in 
Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The processThePicture method for 
SingleSliderTemplate01.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>

  private void processThePicture(){
    //Adjust the value of the red color component on the
    // basis of the current value of the slider.
    pixels = display.getPixels();
    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      red = (int)(pixels[cnt].getRed()
                               * slider.getValue()/100.0);
      pixels[cnt].setRed(red);
    }//end for loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class SingleSliderTemplate01</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#FF0000"><b>A demonstration version</b></font></p>
<p>This demonstration version of the method named <b>processThePicture</b> is designed for 
illustration purposes only.&nbsp; As I explained earlier, the method is called 
each time the slider fires a <b>stateChanged</b> event.&nbsp; Immediately before 
this method is called, a new display is created containing a fresh copy of the original 
picture.</p>
<p><font color="#FF0000"><b>Reduce the red color in the picture</b></font></p>
<p>This method operates only on the <b>Picture</b> object referred to by <b>
display</b>. Each time this version of the method is called, it gets the current 
value of the slider and uses that value as a multiplicative factor to reduce the 
red color value in every pixel in the current display. Depending on 
the position of the slider when the event is fired, the red color component 
value for every pixel in the current display will be set to a value ranging from 
zero to 100 percent of its original value.</p>
<p><font color="#FF0000"><b>Example output</b></font></p>
<p>For example, Figure 1 shows the result of using the slider to reduce the red 
color value of every pixel to 60-percent of its original value.</p>
<p>Figure 2 shows the result of using the slider to reduce the red color 
value of every pixel to ten-percent of its original value.&nbsp; <i>(Note 
the position of the slider in Figure 1 and Figure 2.)</i></p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Red color reduced to ten-percent of its 
	original value.</b>
<table bgcolor="#EFE9B8"  border="1" cols="1">
<tr><td><img border="0" src="java351c.jpg" width="329" height="271"></td></tr>
<tr><td><img border="0" src="java351d.jpg" width="328" height="126"></td></tr>
</table></p>

<p>If you compare Figure 2 with Figure 1, you should be able to see that there 
is less red in Figure 2 than in Figure 1.</p>
<p><font color="#FF0000"><b>The code is straightforward</b></font></p>
<p>Assuming that you have studied the earlier lessons in this series, you should 
have no difficulty understanding the code in Listing 13.</p>




<p><font color="#FF0000"><b>Leave the original Picture object alone</b></font></p>
<p>In most cases, methods that are written for this part of the program using this programming 
template should not access the original <b>Picture</b> object directly, but 
should confine their operations to the <b>Picture</b> object referred to by the 
variable named <b>display</b>.</p>
<h3><a name="The_program_named_Blur01">The program named Blur01</a></h3>
<p>Now that you have learned all about the programming template, it is time to 
examine a program based on that template, which accomplishes a task that is 
commonly performed by persons working to improve digital photographs.&nbsp; 
This program can be used to blur or soften a digital photograph.</p>
<p><font color="#FF0000"><b>A more complex program</b></font></p>
<p>As you 
might expect, this program is somewhat more complex than the demonstration program discussed 
above that simply reduced the red color component in all pixels in an image.&nbsp; 
Fortunately, since you already know all about the template, all I will need to 
explain for this program is the method named <b>processThePicture</b>, <i>(plus a couple of remarks 
about minor changes that were made to the template)</i>.</p>
<p>As mentioned above, this program was created using code from the program 
named <b>SingleSliderTemplate01</b> as the starting point.</p>
<p><font color="#FF0000"><b>Purpose is to blur or soften a digital photo</b></font></p>
<p>The purpose of this program is to teach you how to write a program to apply a 
blurring or softening filter to your digital photos with the amount of softening 
controlled by the user with a slider.&nbsp; The program requires access to Ericson's 
multimedia library.</p>
<p><font color="#FF0000"><b>Emphasizes understand over execution speed</b></font></p>
<p>The speed and smoothness of programs that you write using the template 
program will depend on a combination of your programming skills and the speed of 
your computer.&nbsp; This program was designed to emphasize an understanding of 
the image blurring process and was not designed for speed.&nbsp; <i>(Improving 
the speed would be a good project for the students.)</i></p>
<p><font color="#FF0000"><b>Two minor changes to the template</b></font></p>
<p>As you learned earlier, the screen output produced by programs based on this 
template consists of two parts:</p>
<ul>
	<li>A display of the picture being processed.</li>
	<li>A GUI for user input and control.</li>
</ul>
<p>For this program, the slider ranges from 0 to 100 with the initial position 
of the slider at 1 <i>(and not 100)</i>.&nbsp; This is one of the minor changes that I made to the 
template.&nbsp; The other minor change was to change the text that appears above 
the slider.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Algorithms</b><br />
  See lessons 400 through 462 in <a href="#Resources">Resources</a> for a wealth 
	of information on image processing algorithms.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Many possible blurring algorithms</b></font></p>
<p>This program applies one of many possible blurring or softening algorithms to 
an image that is read from an image file.&nbsp; The algorithm is applied 
separately to the red, green, and blue color components of the pixels.&nbsp; In 
other words, each color component is blurred independently of the other two 
color components but all three are blurred by the same amount.</p>
<p><font color="#FF0000"><b>Comparing two points on the slider</b></font></p>
<p>Figure 3 shows the same butterfly output image for two positions of the slider.</p>

<p><b><a name="Figure_3">Figure 3</a>. Example of blurring a butterfly image.</b><table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java351e.jpg" width="220" height="280"></td>
		<td>
		<p align="center">
		<img border="0" src="java351g.jpg" width="220" height="280"></td>
	</tr>
		<tr>
		<td><img border="0" src="java351f.jpg" width="227" height="126"></td>
		<td><img border="0" src="java351h.jpg" width="227" height="126"></td>
	</tr>
</table>
</p>


<p><font color="#FF0000"><b>No blurring versus maximum blurring</b></font></p>
<p>I will provide a detailed explanation of the blurring algorithm later.&nbsp; 
For now, suffice to say that no blurring is applied when the slider is set to 
the left end at 0.&nbsp; This is illustrated by the two images in the left side 
of Figure 3.&nbsp; Maximum blurring for this algorithm occurs when the slider is 
moved to the right end at 100.&nbsp; This is illustrated by the two images in 
the right side of Figure 3.</p>
<p><font color="#FF0000"><b>Not an aggressive algorithm</b></font></p>
<p>This particular algorithm is not particularly aggressive in blurring the 
image.&nbsp; The algorithm that I will show you in the third program is much 
more aggressive <i>(see Figure 4)</i>.&nbsp; In other words, with the third program, blurring is more 
pronounced as the slider shown in Figure 3 is moved from the left end toward the 
right end.&nbsp; Other algorithms can be even more aggressive, producing images that 
are hardly recognizable when set to maximum blurring.</p>
<p><font color="#FF0000"><b>Writing an output file</b></font></p>
<p>As you learned earlier, positioning the slider at some point along its range 
and clicking the <b>Write</b> button causes a backup file to be written 
containing the current state of the display.</p>
<p><font color="#FF0000"><b>Terminating the program</b></font></p>
<p>Also as you learned earlier, clicking the large X in the upper-right corner 
of the display simply hides the display and does not terminate the program.&nbsp; The 
program is terminated by clicking the large X in the upper-right corner of the 
GUI.&nbsp; Before terminating, the program writes an output file containing the 
final state of the display in the same graphics format as the input file.</p>
<p><b><font color="#FF0000">Will explain in fragments</font></b></p>
<p>As is my custom, I will explain this program in fragments.&nbsp; A complete listing of the 
program is provided in Listing 20 near the end of the lesson.</p>
<p>As mentioned earlier, all that I need to explain is the method named <b>
processThePicture</b>.</p>
<p><font color="#FF0000"><b>The blurring algorithm</b></font></p>
<p>This version of the <b>processThePicture</b> method applies one of many 
possible blurring or softening algorithms to the image.&nbsp; In technical 
terms, this method convolves the pixels in the image with a nine-point, two-dimensional 
convolution filter having very specific characteristics.&nbsp; The convolution 
filter is applied separately to the red, green, and blue color components of the 
pixels.</p>
<p><font color="#FF0000"><b>More familiar terminology</b></font></p>
<p>Using terminology that may be more familiar to you, each color value for each pixel is replaced by a weighted sum of the color value 
for that pixel <i>(referred to as the center pixel)</i> and the color values for its eight nearest neighbors.&nbsp; In other words, output pixels are 
produced as a weighted average of nine adjacent input pixels that form a 3x3 
square of pixels.</p>
<p><font color="#FF0000"><b>The values of the weighting factors</b></font></p>
<p>Equal weights are applied to each of the eight pixels on the outside of the 
3x3 square.&nbsp; A different weight is usually applied to the pixel in the 
center of the square.&nbsp; The values of the weights are adjusted so that the sum of 
the weights applied to the center pixel and its eight neighbors is 1.0.</p>
<p><font color="#FF0000"><b>Computing the weighting factors</b></font></p>
<p>The current value of the slider is used with a logarithmic algorithm to 
compute the two weights that are applied to the center pixel and its eight 
neighbors to produce each output pixel.</p>
<p>For example, when the slider value 
is 1 or less, a weight of 1.0 is applied to the center pixel and weights of 0.0 are 
applied to each of the eight neighboring pixels.&nbsp; No blurring occurs for 
this case.</p>
<p>When the slider value is 100, a weight of 0.0 is applied to the center pixel 
and weights of 0.125 are applied to the other eight pixels.&nbsp; Maximum 
blurring occurs for this case.</p>
<p><font color="#FF0000"><b>A table of example weights</b></font></p>
<p>A table is provided in the program comments in Listing 20 that shows more 
examples of the relationship between slider values and the weight applied to the 
center pixel.&nbsp; Given the weight that is applied to the center pixel and 
knowing that the sum of all nine weights is 1.0, you should be able to calculate 
the weights that are applied to each of the other eight pixels for each of the slider values in the table.</p>
<p><font color="#FF0000"><b>Blurring versus slider position</b></font></p>
<p>As mentioned earlier, there is no blurring when the slider is at the far left or 0 position.&nbsp; 
The farther the slider moves toward the right, the greater is the 
relative contribution of the eight outer pixels to the weighted sum, and 
the greater will be the blurring or softening effect.&nbsp; Maximum blurring 
occurs when the slider is at the far right in the 100 position.</p>
<p><font color="#FF0000">
<b>Beginning of the processThePicture method</b></font></p>
<p>The <b>processThePicture</b> method begins in Listing 14.&nbsp; The code in 
Listing 14 uses the 
current value of the slider to compute the weights 
that will be applied to the center pixel and to each of its eight nearest 
neighbors.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Beginning of the processThePicture 
	method for Blur01.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  private void processThePicture(){
    //Compute the weights to be applied to the center
    // pixel and its eight closest neighbors.
    double value = (double)(slider.getValue());
    double centerWeight = 0.0;

    //Convert the slider value to a scaled log value with
    // a maximum value of 1.0.
    if(value &gt; 1.0){
      centerWeight = 1.0 - Math.log10(value)/2;
    }else{
      centerWeight = 1.0 - Math.log10(1.0)/2;
    }//end else

    //Compute the weight that is applied to each of the
    // eight neighboring pixels.
    double neighborWeight = (1.0 - centerWeight)/8.0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>If you understand logarithms...</b></font></p>
<p>If you understand logarithms, you shouldn't have too much difficulty 
understanding the code in Listing 14.&nbsp; The bottom line is that when the 
code in Listing 14 has been executed, two weighting factors have been computed.&nbsp; 
One weighting factor will be applied to the center pixel in each 3x3 square of nine pixels and the other weighting factor will be applied to the eight 
pixels at the outer edge of the square.</p>
<p><font color="#FF0000"><b>Why convert to a logarithmic scale?</b></font></p>
<p>I'm not going to explain why I converted from a linear scale to a logarithmic 
scale because such an explanation would require several pages of text and would be beyond the scope of this lesson.&nbsp; 
If you have a physics or engineering background, you probably already know the 
answer.&nbsp; If not, suffice it to say that this makes better use of the full 
traversal length of the slider as an adjustment device in this case.</p>
<p><font color="#FF0000">
<b>Working variables</b></font></p>
<p>Listing 15 declares some working variables that will be used later in the 
method.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Working variables. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Declare some working varibles.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[8];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 15 also creates another copy of the picture and stores its reference in 
a reference variable named <b>temp</b>.&nbsp; I will explain the use of this 
copy of the picture later.</p>
<p><font color="#FF0000">
<b>Process each 3x3 square of pixels</b></font></p>
<p>Listing 16 begins a pair of nested <b>for</b> loops that iterate through the 
picture, one pixel at a time, processing each 3x3 square of pixels.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Process each 3x3 square of pixels. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    for(int col = 1;col &lt; width-1;col++){
      for(int row = 1;row &lt; height - 1;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the eight surrounding pixels.
        pixels[0] = temp.getPixel(col-1,row-1);
        pixels[1] = temp.getPixel(col,row-1);
        pixels[2] = temp.getPixel(col+1,row-1);

        pixels[3] = temp.getPixel(col-1,row);
        pixels[4] = temp.getPixel(col+1 ,row);

        pixels[5] = temp.getPixel(col-1,row+1);
        pixels[6] = temp.getPixel(col,row+1);
        pixels[7] = temp.getPixel(col+1,row+1);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code inside the inner loop begins by saving a reference to the pixel that 
is in the center of a 3x3 square containing nine pixels.&nbsp; Then it saves 
references to the eight pixels that form the border of the 3x3 square in the 
eight-element array that was created at the end of Listing 15.</p>
<p><b><font color="#FF0000">Note the indices</font></b></p>
<p>Note that the indices in the <b>for</b> loops in Listing 16 begin with 1 <i>
(not 0)</i> and end with (width-1) and (height-1).&nbsp; This was done so that the code in the body 
of the inner loop won't attempt to access pixels that are outside the bounds of 
the picture.&nbsp; In other words, for this nine-element convolution filter, the 
pixels in the outermost rows and columns of the image are never used as the center pixel in 
a 
3x3 square of pixels.</p>
<p><font color="#FF0000">
<b>Compute the weighted sum of the red color values</b></font></p>
<p>The next step is to compute a weighted sum of the red color values of the 
nine pixels that form a 3x3 square of pixels.&nbsp; The center pixel must be 
multiplied by the factor named <b>centerWeight</b> that was computed in Listing 
14.&nbsp; Each of the other eight pixels must be multiplied by the factor 
named <b>neighborWeight</b> that was also computed in Listing 14.&nbsp; Then the 
resulting products must be added.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Compute the weighted sum of the red 
color values. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
        red = 0;
        
        //First compute the sum of the color values for
        // the eight neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        pixel.setRed(red);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Should you multiply first or add first?</b></font></p>
<p>Because the eight pixels on the outer edge of the 3x3 square must all be multiplied by the same 
factor before adding their products, it doesn't matter whether you multiply and 
then add, or add and then multiply.&nbsp; The numeric result will be the same 
either way.&nbsp; However, multiplication tends to be more computationally 
expensive than addition, so from a speed viewpoint, it is better to add and then 
multiply.</p>
<p><font color="#FF0000"><b>Loop and add the eight red values</b></font></p>
<p>Listing 17 uses a <b>for</b> loop to compute the sum of the red values 
belonging to the 
eight pixels whose references were stored in the array named <b>temp</b>.&nbsp; 
These are the pixels from the outer edge of the 3x3 square of pixels.</p>
<p>Then Listing 17 multiplies that sum by the factor <b>neighborWeight</b> and 
adds that product to the product of <b>centerWeight</b> and the red color value 
belonging to the pixel that is at the center of the 3x3 square of pixels.</p>
<p>This produces the new red color value, which is stored in the pixel at the 
center of the 3x3 square of pixels in the display, replacing the value that was originally 
there.</p>
<p><font color="#FF0000">
<b>Do the same for the green and blue colors</b></font></p>
<p>Still inside the inner loop, Listing 18 computes new green and blue values&nbsp;&nbsp; for the 
pixel at the center of the 3x3 square of pixels using exactly the same 
computational algorithm.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Do the same for the green and blue 
colors. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        //Compute the weighted average of the green
        // values. This is essentially the same algorithm
        // as for the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        pixel.setGreen(green);

        //Compute the weighted average of the blue values.
        // This is essentially the same algorighm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        pixel.setBlue(blue);

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class Blur01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Back to the top of the loop</b></font></p>
<p>Then control transfers back to the top of the loop.&nbsp; This iteration 
process continues until every 3x3 square of pixels has been processed.&nbsp; 
Each 3x3 square of pixels is used to produce one pixel in the output picture 
referred to by <b>display</b>.</p>
<p><font color="#FF0000"><b>Repaint the display</b></font></p>
<p>When the outer loop terminates, Listing 18 repaints the display shown by the 
top two images in Figure 3 and the method named <b>processThePicture</b> 
terminates. This returns control to Listing 12, which promptly terminates.</p>
<p>This happens over and over as the user moves the slider causing the <b>
JSlider</b> object shown by the bottom two images in Figure 3 to fire <b>stateChanged</b> 
events.</p>
<h3><a name="The_program_named_Blur02">The program named Blur02</a></h3>
<p>A complete listing of the program named <b>Blur02</b> is provided in Listing 
21 near the end of the lesson.</p>
<p><b>Blur02</b> is an update&nbsp; to the program named <b>Blur01</b>, which 
causes the blurring algorithm to be more aggressive. As I described in detail 
above, the program named <b>Blur01</b> computes a weighted sum of a center pixel and its eight closest neighbors 
in a 3x3 square of pixels.&nbsp; <b>Blur02</b> computes a weighted sum of a center pixel and its 24 closest neighbors 
in a 5x5 square of pixels.</p>
<p>I'm not going to explain the details of the changes in the code that were 
required to accomplish this, but all the changes were made in the method 
named <b>processThePicture</b>.&nbsp; You should be able to understand the 
changes by comparing the method named <b>processThePicture</b> in Listing 20 
with the method having the same name in Listing 21.</p>
<p><font color="#FF0000"><b>Comparison of programs Blur01 and Blur02</b></font></p>
<p>Figure 4 compares the output images produced by the two programs for four 
different settings of the slider.&nbsp; The output produced by <b>Blur01</b> is 
shown in the left column of images, and the output produced by <b>Blur02</b> is 
shown in the right column.</p>




<p><b><a name="Figure_4">Figure 4</a>. Comparison of programs Blur01 and Blur02.
</b>
<table border="1" bgcolor="#EFE9B8" >
	<tr>
		<td><img border="0" src="java351m.jpg" width="220" height="280"></td>
		<td><img border="0" src="java351n.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java351o.jpg" width="220" height="280"></td>
		<td><img border="0" src="java351p.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java351q.jpg" width="220" height="280"></td>
		<td><img border="0" src="java351r.jpg" width="220" height="280"></td>
	</tr>
	<tr>
		<td><img border="0" src="java351s.jpg" width="220" height="280"></td>
		<td><img border="0" src="java351t.jpg" width="220" height="280"></td>
	</tr>
</table></p>
<p>Starting at the top and going down the page, the pairs of images correspond to slider 
settings of 0, 33, 66, and 100.&nbsp; A comparison of the bottom pair of images 
shows that much more blurring occurred with <b>Blur02</b> <i>(right column)</i> 
than with <b>Blur01</b> <i>(left column)</i>.</p>
<p><font color="#FF0000"><b>Which blurring algorithm is the best?</b></font></p>
<p>It depends entirely on what your needs are which algorithm is the better one 
for you.&nbsp; 
If you can accomplish your needs using the algorithm on the left, that is 
probably the better algorithm for you.&nbsp; Of the two, it is less 
computationally demanding and runs faster.</p>
<p>On the other hand, if you need more blurring, the second algorithm, or 
perhaps one that is even more aggressive than that one might be the best one for 
you.</p>
<p>Keep in mind that there are parameters other than simply the number of pixels 
included in the weighted sum that can be brought into play when designing the 
algorithm.&nbsp; However, the design of blurring algorithms is beyond the scope 
of this lesson.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 19 through Listing 21, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<p>See if you can find ways to modify the algorithms so as to improve the speed 
without changing the behavior.&nbsp; For example, consider using the techniques 
described in the lesson titled <i>Using the Java 2D ConvolveOp Filter Class to 
Process Images (see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I explained three different programs in this lesson.&nbsp; In 
the first program, I showed you how to write a general-purpose template 
program in which some attribute of a digital image is varied through a range of 
values using a slider.&nbsp; The results of varying the attributes are 
immediately visible in a display of the image for which the attributes are being 
varied.</p>
<p>The main purpose of this template program is to make it possible for you to 
write image processing programs with a minimum of effort.&nbsp; Ideally, by 
using this template, you will be able to concentrate on the image-processing 
logic of such programs and will not have to deal with the logistics involved in the 
overall program.</p>
<p>The purpose of the second and third programs is to teach you how to write a 
program to apply a blurring or softening filter to your digital photos with the 
amount of softening being controlled by user with a slider.</p>
<p>The third program is very similar to the second program.&nbsp; However, the third program applies a 
much more aggressive blurring algorithm to the image.&nbsp; In other words, much 
more blurring occurs for the same travel distance of the slider.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn how to write an animated flocking program where seven 
marine creatures chase a lead creature as it moves randomly in an aquarium.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a rel="license" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a href="http://coweb.cc.gatech.edu/mediaComp-plan/101">Media 
	Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a href="http://drjava.sourceforge.net/">DrJava</a> download site</li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, the JavaPLT 
	group at Rice University</a></li>
	<li><a href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava Open Source 
	License</a></li>
	<li><a href="http://www.developer.com/java/article.php/1440571">The Essence 
	of OOP using Java, The this and super Keywords</a></li>
	<li><font color="#000000">
	<a href="http://www.dickbaldwin.com/java/Java058.htm">Threads of Control</a></font></li>
	<li><a href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Swing</a></li>
	<li><a href="http://en.wikipedia.org/wiki/Turtle_graphics/">Wikipedia Turtle 
	Graphics</a></li>
	<li><a href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li><a href="http://www.vectorcad3d.com/support/lathetutorial.htm">Vector 
	Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li><a href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable&nbsp; </li>
	<li><a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D 
	Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D 
	Graphics, The Point2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D 
	Graphics, The Graphics2D Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D 
	Graphics, Simple Affine Transforms</li>
	<li><a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D 
	Graphics, The Shape Interface, Part 1</li>
	<li><a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D 
	Graphics, The Shape Interface, Part 2</li>
	<li><a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D 
	Graphics, Solid Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D 
	Graphics, Gradient Color Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D 
	Graphics, Texture Fill</li>
	<li><a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D 
	Graphics, The Stroke Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D 
	Graphics, The Composite Interface and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D 
	Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D 
	Graphics, The Color Constructors and Transparency</li>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started&nbsp; <br>
	<a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight&nbsp; <br>
	<a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness<br>
	<a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images<br>
	<a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1 <br>
	<a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a href="http://www.developer.com/java/other/article.php/3640776">416</a> 
	Processing Image Pixels, An Improved Image-Processing Framework in Java<br>
	<a href="http://www.developer.com/java/other/article.php/3650011">418</a> 
	Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a href="http://www.developer.com/java/other/article.php/3645761">450</a> A 
	Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a href="http://www.developer.com/java/other/article.php/3654171">452</a> 
	Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a href="http://www.developer.com/java/other/article.php/3670696">454</a> 
	Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a href="http://www.developer.com/java/other/article.php/3681466">456</a> 
	Using the Java 2D LookupOp Filter Class to Scramble and Unscramble Images<br>
	<a href="http://www.developer.com/java/other/article.php/3686856">458</a> 
	Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a href="http://www.developer.com/java/other/article.php/3696676">460</a> 
	Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a href="http://www.developer.com/java/other/article.php/3698981">462</a> 
	Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to Process 
	Images</li>
	<li><a href="http://www.dickbaldwin.com/java/Java506.htm">506</a> JavaBeans, 
	Introspection</li>
	<li><a href="http://www.developer.com/java/other/article.php/2114451">2100</a> 
	Understanding Properties in Java and C#</li>
	<li><a href="http://www.developer.com/java/other/article.php/3495121">2300</a> 
	Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3793401">346</a> 
	Wrapping Up the SimpleTurtle Class:&nbsp; Multimedia Programming with Java</li>
	<li><a href="http://www.dickbaldwin.com/java/Java348.htm">348</a> The Pen 
	and PathSegment Classes:&nbsp; Multimedia Programming with Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3795761">349</a> 
	A Pixel Editor Program in Java:&nbsp; Multimedia Programming with Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3798646">350</a> 3D Displays, Color Distance, and Edge Detection</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 19 through Listing 21 below.
<p>
<b><a name="Listing_19">Listing 19</a>. Source code for the program named SingleSliderTemplate01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File SingleSliderTemplate01 Copyright 2009 R.G.Baldwin

This is a template program, designed to show you how to
structure a program in which some attribute of a digital
image is varied through a range of values using a slider.

The main purpose of this template program is to make it
possible for you to write image processing programs with a
minimum of effort. Ideally, by using this template, you
will be able to concentrate on the image-processing logic
and not have to deal with the logistics involved in
the overall program.

The template program requires access to Ericson's
multimedia library.

The speed and smoothness of programs that you write using
this template program will depend on a combination of your
programming skills and the speed of your computer. This
template program is intended to teach programming and
image processing concepts. It is not intended to make it
possible for you to write programs that will compete on a
speed basis with commercially-available photograph
processing programs.

The screen output produced by the template program
consists of two parts: a display of the picture being
processed and a GUI.

The GUI consists of the following components:
~A JLabel object that briefly describes the purpose of the
slider.
~The slider itself.
~A JButton that can be used to write backup copies of the
current state of the display into the same directory from
which the original image file was read. The five most
recent backup files are saved. The backup files are
written in bmp format regardless of the format of the
original image file in order to avoid the color corruption
that can occur when images are compressed into JPEG
format. The names of the backup files are the same as the
name of the original image file except that BAKn is
inserted immediately ahead of the extension where n is a
digit ranging from 0 to 4. The value of n rolls over and
starts back at 0 when it exceeds 4.
~A JTextField into which the user enters the name of the
input file. Files of type jpg, bmp, png are supported.
Other file types may be supported as well but the program
hasn't been tested for types other than those listed
above.

The GUI originally appears in the upper-left corner of the
screen. At this point, both the slider and the button are
disabled. When the user enters the name of the input file,
a display of the image contained in that file appears in
the upper-left corner of the screen and the GUI is
relocated to a position immediately below the display. If
the input file is not in the current directory, a complete
path and file name must be entered by the user.

When the GUI is relocated to the position immediately
below the display, the slider and the button are enabled
and the text field is disabled. The width of the GUI is
changed to match the width of the display unless the width
of the display is less than the preferred width of the
GUI. In that case, the GUI appears at its preferred width.

For this demonstration template program, the slider ranges
from 0 to 100 with the initial position of the slider at
100. As the slider is moved toward zero, the value of the
red color component for every pixel in the image is
reduced linearly and the display changes to reflect that
change in the value of the red color component. The
smoothness, or lack thereof of the operation will depend
on the speed of the computer. When the slider is at the 0
position, the pixels in the image are completely devoid of
red color.

Positioning the slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display.

Clicking the large X in the upper-right corner of the
display simply hides the display and is of no practical
value.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
original input file except that the word FINAL is inserted
immediately ahead of the extension.

This program does not modify the contents of the original
input file.

A change listener is registered on the slider. Each time
the slider fires a ChangeEvent, the event handler creates
a new display as a copy of the original picture and calls
a method named processThePicture.

The main purpose of this template program is to make it
possible for you to write image processing programs with a
minimum of effort. For many different kinds of image
processing programs, you should be able to confine your
programming effort to rewriting the method named
processThePicture (and change the text in the JLabel
referred to by purposeLabel) and leave the remainder of
the template program intact.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class SingleSliderTemplate01 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =
                new JLabel("Purpose of Slider goes Here");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
             new JTextField("SingleSliderTemplate01.jpg");
  //This slider will extend from 0 to 100 with the initial
  // position at 100. See the documentation to learn how
  // to configure it differently.
  private JSlider slider = new JSlider(0,100,100);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new SingleSliderTemplate01();
  }//end main method
  //----------------------------------------------------//

  public SingleSliderTemplate01(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(10);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(new JLabel("File Name:"));
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the slider.
    //Each time the slider fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // processThePicture.
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  //This version of the method named processThePicture is
  // designed for illustration purposes only. The method
  // is called each time the slider fires a stateChanged
  // event.
  //Immediately before this method is called, a new
  // display is created as a copy of the original picture.
  // This method operates only on the display. Each time
  // the method is called, it gets the value of the
  // slider and uses that value as a multiplicative factor
  // to reduce the red color component value in every
  // pixel in the current display. Thus, depending on the
  // position of the slider when the event is fired, the
  // red color component value for every pixel in the
  // current display will be set to a value ranging from
  // zero to 100 percent of its original value. Methods
  // that are written for this part of the program should
  // never access the original Picture object directly,
  // but should confine their operations to the Picture
  // object referred to by the variable named display.

  private void processThePicture(){
    //Adjust the value of the red color component on the
    // basis of the current value of the slider.
    pixels = display.getPixels();
    for(int cnt = 0;cnt &lt; pixels.length;cnt++){
      red = (int)(pixels[cnt].getRed()
                               * slider.getValue()/100.0);
      pixels[cnt].setRed(red);
    }//end for loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class SingleSliderTemplate01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Source code for the program named Blur01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Blur01 Copyright 2009 R.G.Baldwin

This program was created using the program named
SingleSliderTemplate01 as the starting point.

The purpose of this program is to teach you how to write a
slider-driven program to apply a blurring or softening
filter to your digital photos with the amount of softening
being controlled by a slider.

The  program requires access to Ericson's multimedia
library.

The speed and smoothness of programs that you write using
the template program will depend on a combination of your
programming skills and the speed of your computer. This
program was designed to emphasize an understanding of the
image blurring process and was not designed for speed.
Improving the speed would be a good project for the
student.

The screen output produced by the program consists of two
parts: a display of the picture being processed and a GUI.

See the comments at the beginning of the program named
SingleSliderTemplate01 for a detailed discussion of the
components in the GUI.

For this program, the slider ranges from 0 to 100 with the
initial position of the slider at 1.  The program applies
one of many possible blurring or softening algorithms to
an image that is read from an image file. The algorithm is
applied separately to the red, green, and blue color
components of the pixels.

A detailed description of the algorithm is provided in the
comments at the beginning of the method named
processThePicture. There is no blurring when the slider is
at the far left or 0 position.  Blurring increases non-
linearly as the slider is moved to the right. Maximum
blurring occurs when the slider is at the far right in the
100 position.

Positioning the slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display. See
the program named SingleSliderTemplate01 for information
regarding the number of sequential backup files that are
saved and the names of those files.

Clicking the large X in the upper-right corner of the
display simply hides the display and is of no practical
value.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension.

This program does not modify the contents of the original
input file.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class Blur01 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =
                   new JLabel("Apply a blurring filter.");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
             new JTextField("Blur01.jpg");
  //This slider will extend from 0 to 100 with the initial
  // position at 1. See the documentation to learn how
  // to configure it differently.
  private JSlider slider = new JSlider(0,100,1);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new Blur01();
  }//end main method
  //----------------------------------------------------//

  public Blur01(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(10);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(new JLabel("File Name:"));
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the slider.
    //Each time the slider fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // processThePicture.
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  //This version of the processThePicture method applies
  // one of many possible blurring or softening algorithms
  // to the image. In pure technical terms, this method
  // convolves the pixels in the image with a nine-point,
  // two-dimensional convolution filter having very
  // specific characteristics. The convolution filter is
  // applied separately to the red, green, and blue color
  // components of the pixels.
  //Using terminology that may be more familiar to you,
  // each color component value for each pixel is replaced
  // by a weighted sum of the color component value for
  // that pixel (referred to as the center pixel) and the
  // color component values for its eight closest
  // neighbors. Equal weights are applied to each of the
  // eight neighbors. The sum of the weights applied to
  // the center pixel and its eight neighbors is 1.0.
  //The current value of the slider is used with a
  // logarithmic algorithm to compute the set of weights
  // that are applied to the pixel and its eight
  // neighbors. For example, when the slider value is 0 or
  // 1, a weight of 1.0 is applied to the center pixel and
  // weights of 0.0 are applied to the neighbors. For this
  // case, no blurring occurs.
  //The following table shows a sampling of the
  // relationship between slider values in the first
  // column and the weight applied to the center pixel in
  // the second column.
  //   0 1.00
  //   1 1.00
  //   2 0.85
  //   4 0.70
  //   8 0.55
  //  16 0.40
  //  32 0.25
  //  50 0.15
  //  75 0.06
  // 100 0.00
  //Given the weight that is applied to the center pixel
  // and knowing that the sum of all nine weights is 1.0,
  // you should be able to calculate the weights that are
  // applied to the neighboring pixels.
  //There is no blurring when the slider is at the far
  // left or 0 position.  The farther to the right the
  // slider moves, the greater will be the relative
  // contribution of the eight neighboring pixels to the
  // weighted sum, and the greater will be the blurring or
  // softening effect. Maximum blurring occurs when the
  // slider is at the far right in the 100 position.
  private void processThePicture(){
    //Compute the weights to be applied to the center
    // pixel and its eight closest neighbors.
    double value = (double)(slider.getValue());
    double centerWeight = 0.0;

    //Convert the slider value to a scaled log value with
    // a maximum value of 1.0.
    if(value &gt; 1.0){
      centerWeight = 1.0 - Math.log10(value)/2;
    }else{
      centerWeight = 1.0 - Math.log10(1.0)/2;
    }//end else

    //Compute the weight that is applied to each of the
    // eight neighboring pixels.
    double neighborWeight = (1.0 - centerWeight)/8.0;

    //Declare some working varibles.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[8];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);

    //Process each pixel.
    for(int col = 1;col &lt; width -1;col++){
      for(int row = 1;row &lt; height - 1;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the eight surrounding pixels.
        pixels[0] = temp.getPixel(col-1,row-1);
        pixels[1] = temp.getPixel(col,row-1);
        pixels[2] = temp.getPixel(col+1,row-1);

        pixels[3] = temp.getPixel(col-1,row);
        pixels[4] = temp.getPixel(col+1 ,row);

        pixels[5] = temp.getPixel(col-1,row+1);
        pixels[6] = temp.getPixel(col,row+1);
        pixels[7] = temp.getPixel(col+1,row+1);

        //Compute the weighted average of the red values.
        red = 0;
        //First compute the sum of the color values for
        // the eight neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        pixel.setRed(red);

        //Compute the weighted average of the green
        // values. This is essentially the same algorighm
        // as for the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        pixel.setGreen(green);

        //Compute the weighted average of the blue values.
        // This is essentially the same algorighm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        pixel.setBlue(blue);

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class Blur01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Source code for the program named Blur02.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Blur02 Copyright 2009 R.G.Baldwin

This is an update to the program named Blur01 to make the
blurring algorithm more aggressive. The program named
Blur01 computes a weighted sum of a center pixel and its
eight closest neighbors. This program computes a weighted
sum of a center pixel and its 24 closest neighbors.

This program was created using the program named
SingleSliderTemplate01 as the starting point.

The purpose of this program is to teach you how to write a
slider-driven program to apply a blurring or softening
filter to your digital photos with the amount of softening
being controlled by a slider.

The  program requires access to Ericson's multimedia
library.

The speed and smoothness of programs that you write using
the template program will depend on a combination of your
programming skills and the speed of your computer. This
program was designed to emphasize an understanding of the
image blurring process and was not designed for speed.
Improving the speed would be a good project for the
student.

The screen output produced by the program consists of two
parts: a display of the picture being processed and a GUI.

See the comments at the beginning of the program named
SingleSliderTemplate01 for a detailed discussion of the
components in the GUI.

For this program, the slider ranges from 0 to 100 with the
initial position of the slider at 1.  The program applies
one of many possible blurring or softening algorithms to
an image that is read from an image file. The algorithm is
applied separately to the red, green, and blue color
components of the pixels.

A detailed description of the algorithm is provided in the
comments at the beginning of the method named
processThePicture. There is no blurring when the slider is
at the far left or 0 position.  Blurring increases non-
linearly as the slider is moved to the right. Maximum
blurring occurs when the slider is at the far right in the
100 position.

Positioning the slider at some point along its range and
clicking the Write button causes a backup file to be
written containing the current state of the display. See
the program named SingleSliderTemplate01 for information
regarding the number of sequential backup files that are
saved and the names of those files.

Clicking the large X in the upper-right corner of the
display simply hides the display and is of no practical
value.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately ahead of the extension.

This program does not modify the contents of the original
input file.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.WindowConstants;

import java.io.File;

public class Blur02 extends JFrame{
  private JPanel mainPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JLabel purposeLabel =
                   new JLabel("Apply a blurring filter.");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
             new JTextField("Blur02.jpg");
  //This slider will extend from 0 to 100 with the initial
  // position at 1. See the documentation to learn how
  // to configure it differently.
  private JSlider slider = new JSlider(0,100,1);

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;
  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables.
  private Image image = null;
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int red = 0;
  private int writeCounter = 0;

  private Pixel[] pixels = null;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;
  //----------------------------------------------------//

  public static void main(String[] args){
    new Blur02();
  }//end main method
  //----------------------------------------------------//

  public Blur02(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Put the decorations on the slider. See the
    // documentation to learn how to decorate the slider
    // differently.
    slider.setMajorTickSpacing(10);
    slider.setMinorTickSpacing(5);
    slider.setPaintTicks(true);
    slider.setPaintLabels(true);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    mainPanel.add(purposeLabel,BorderLayout.NORTH);
    mainPanel.add(slider,BorderLayout.CENTER);

    southPanel.add(writeButton);
    southPanel.add(new JLabel("File Name:"));
    southPanel.add(fileNameField);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Disable the slider and the writeButton until the
    // user enters the file name. Put the focus on the
    // text field where the user will enter the file
    // name.
    slider.setEnabled(false);
    writeButton.setEnabled(false);
    fileNameField.requestFocus();

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field to prevent the user
          // from entering anything else in it.
          fileNameField.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be processed.
          // Note that the original image file is not
          // modified by this program.
          int pictureWidth = picture.getWidth();
          int pictureHeight = picture.getHeight();
          display = new Picture(
                              pictureWidth,pictureHeight);

          //Draw the initial display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.show();

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          slider.setEnabled(true);
          writeButton.setEnabled(true);

        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//
    //Register a ChangeListener object on the slider.
    //Each time the slider fires a ChangeEvent, this event
    // handler creates a new display as a copy of the
    // original picture and calls a method named
    // processThePicture.
    slider.addChangeListener(
      new ChangeListener(){
        public void stateChanged(ChangeEvent e){
          //Draw a new copy of the picture on the display.
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          processThePicture();
        }//end stateChanged
      }//end new ChangeListener
    );//end addChangeListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  //This version of the processThePicture method applies
  // one of many possible blurring or softening algorithms
  // to the image. In pure technical terms, this method
  // convolves the pixels in the image with a 25-point,
  // two-dimensional convolution filter having very
  // specific characteristics. The convolution filter is
  // applied separately to the red, green, and blue color
  // components of the pixels.
  //Using terminology that may be more familiar to you,
  // each color component value for each pixel is replaced
  // by a weighted sum of the color component value for
  // that pixel (referred to as the center pixel) and the
  // color component values for its 24 closest
  // neighbors. Equal weights are applied to each of the
  // 24 neighbors. The sum of the weights applied to
  // the center pixel and its 24 neighbors is 1.0.
  //The current value of the slider is used with a
  // logarithmic algorithm to compute the set of weights
  // that are applied to the pixel and its 24
  // neighbors. For example, when the slider value is 0 or
  // 1, a weight of 1.0 is applied to the center pixel and
  // weights of 0.0 are applied to the neighbors. For this
  // case, no blurring occurs.
  //There is no blurring when the slider is at the far
  // left or 0 position.  The farther to the right the
  // slider moves, the greater will be the relative
  // contribution of the 24 neighboring pixels to the
  // weighted sum, and the greater will be the blurring or
  // softening effect. Maximum blurring occurs when the
  // slider is at the far right in the 100 position.
  private void processThePicture(){
    //Compute the weights to be applied to the center
    // pixel and its 24 closest neighbors.
    double value = (double)(slider.getValue());
    double centerWeight = 0.0;

    //Convert the slider value to a scaled log value with
    // a maximum value of 1.0.
    if(value &gt; 1.0){
      centerWeight = 1.0 - Math.log10(value)/2;
    }else{
      centerWeight = 1.0 - Math.log10(1.0)/2;
    }//end else

    //Compute the weight that is applied to each of the
    // twenty-four neighboring pixels.
    double neighborWeight = (1.0 - centerWeight)/24.0;

    //Declare some working varibles.
    int width = display.getWidth();
    int height = display.getHeight();
    int red = 0;
    int green = 0;
    int blue = 0;
    Pixel pixel = null;
    Pixel[] pixels = new Pixel[24];

    //Create a temporary copy of the display to serve as
    // input to the computations that follow. This will
    // prevent the processing of one row from having an
    // influence on the processing of the next row.
    Picture temp = new Picture(display);

    //Process each pixel.
    for(int col = 2;col &lt; width - 2;col++){
      for(int row = 2;row &lt; height - 2;row++){
        //Get and save the pixel at the center of the
        // current nine-pixel group.
        pixel = display.getPixel(col,row);

        //Get and save the 24 neighboring pixels.
        pixels[0] = temp.getPixel(col-2,row-2);
        pixels[1] = temp.getPixel(col-1,row-2);
        pixels[2] = temp.getPixel(col,row-2);
        pixels[3] = temp.getPixel(col+1,row-2);
        pixels[4] = temp.getPixel(col+2,row-2);

        pixels[5] = temp.getPixel(col-2,row-1);
        pixels[6] = temp.getPixel(col-1,row-1);
        pixels[7] = temp.getPixel(col,row-1);
        pixels[8] = temp.getPixel(col+1,row-1);
        pixels[9] = temp.getPixel(col+2,row-1);

        pixels[10] = temp.getPixel(col-2,row);
        pixels[11] = temp.getPixel(col-1,row);
        pixels[12] = temp.getPixel(col+1,row);
        pixels[13] = temp.getPixel(col+2,row);

        pixels[14] = temp.getPixel(col-2,row+1);
        pixels[15] = temp.getPixel(col-1,row+1);
        pixels[16] = temp.getPixel(col,row+1);
        pixels[17] = temp.getPixel(col+1,row+1);
        pixels[18] = temp.getPixel(col+2,row+1);

        pixels[19] = temp.getPixel(col-2,row+2);
        pixels[20] = temp.getPixel(col-1,row+2);
        pixels[21] = temp.getPixel(col,row+2);
        pixels[22] = temp.getPixel(col+1,row+2);
        pixels[23] = temp.getPixel(col+2,row+2);

        //Compute the weighted average of the red values.
        red = 0;
        //First compute the sum of the color values for
        // the 24 neighboring pixels.
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          red += pixels[cnt].getRed();
        }//end for loop
        //Now apply the weights and store the resulting
        // value in the center pixel of the nine-pixel
        // group in the display.
        red = (int)(red*neighborWeight
                           + pixel.getRed()*centerWeight);
        pixel.setRed(red);

        //Compute the weighted average of the green
        // values. This is essentially the same algorighm
        // as for the red values.
        green = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          green += pixels[cnt].getGreen();
        }//end for loop
        green = (int)(green*neighborWeight
                         + pixel.getGreen()*centerWeight);
        pixel.setGreen(green);

        //Compute the weighted average of the blue values.
        // This is essentially the same algorighm as for
        // the red values.
        blue = 0;
        for(int cnt = 0;cnt &lt; pixels.length;cnt++){
          blue += pixels[cnt].getBlue();
        }//end for loop
        blue = (int)(blue*neighborWeight
                          + pixel.getBlue()*centerWeight);
        pixel.setBlue(blue);

      }//end inner loop
    }//end outer loop

    display.repaint();

  }//end processThePicture
  //----------------------------------------------------//

}//end class Blur02</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
