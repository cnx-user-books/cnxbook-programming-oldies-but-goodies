<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->The AWT Package, Graphics- The Utility Methods<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 164, Revised 02/06/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#getting a graphics context">Getting a Graphics Context</a></li>

<ul><li><a href="#sample program to get and use a graphics context">Sample Program
to Get and Use a Graphics Context</a></li></ul>

<li><a href="#copying and clearing in a graphics">Copying and Clearing a Graphics
Context</a></li>

<ul><li><a href="#sample program to illustrate copying and clearing">Sample Program
to Illustrate Copying and Clearing</a></li></ul>

<li><a href="#creating a new graphics object">Creating a new Graphics Object</a></li>

<ul><li><a href="#sample programs to illustrate creating a new">Sample Programs
to Illustrate Creating a new Graphics Object</a></li></ul>

<li><a href="#using the translate() method">Using the <b>translate()</b> Method</a></li>

<ul><li><a href="#sample program to illustrate use of the translate() method">Sample
Program to Illustrate use of the <b>translate()</b> Method</a></li></ul>

<li><a href="#xor mode vs paint mode">XOR Mode vs Paint Mode</a></li>

<ul><li><a href="#sample program to illustrate use of xor and paint modes">Sample
Program to Illustrate use of XOR and Paint modes</a></li></ul>

<li><a href="#summary">Summary</a></li></ul>

<hr width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b>Advanced Java Programming</b> classes at
ACC are responsible for knowing and understanding all of the material in
this lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
A previous lesson provided an overview of the <b>Graphics</b> class, and
grouped the methods of that class into several different categories. This
lesson will explore some of the methods in the category of graphics <u>utility</u>
methods.

<p>To review, the following methods were put into the utility category:
<table border bgcolor="#80ffff" ><tr><td><b>clearRect</b>(int, int, int, int) - Clears the specified rectangle
by filling it with the background color of the current drawing surface.&nbsp;

<p><b>copyArea</b>(int, int, int, int, int, int) - Copies an area of the
component specified by the first four parameters to another location on
the graphics context at a distance specified by the last two parameters.&nbsp;

<p><b>create</b>() - Creates a new <b>Graphics</b> object that is a copy
of the <b>Graphics</b> object on which it is invoked.&nbsp;

<p><b>dispose</b>() - Disposes of the graphics context on which it is invoked
and releases any system resources that it is using. This includes system
resources <u>other than memory</u>. A Graphics object cannot be used after
dispose has been called. It is important that you manually dispose of your
<b>Graphics</b> objects (created directly from a component or other <b>Graphics</b>
object) when you no longer need them rather than to wait for finalization.&nbsp;

<p><b>finalize</b>() - Disposes of this graphics context once it is no
longer referenced.&nbsp;

<p><b>getColor</b>() - Gets this graphics context's current color.&nbsp;

<p><b>setColor</b>(Color) - Sets this graphics context's current color
to the specified color. Subsequent graphics operations using this graphics
context use this specified color.&nbsp;

<p><b>setPaintMode</b>() - Sets the paint mode of this graphics context
to overwrite the destination with this graphics context's current color
(as opposed to XORMODE). Subsequent rendering operations will overwrite
the destination with the current color.&nbsp;

<p><b>setXORMode</b>(Color) - Sets the paint mode of this graphics context
to alternate between this graphics context's current color and the new
specified color.&nbsp;

<p><b>toString</b>() - Returns a <b>String </b>object representing this
<b>Graphics</b> object's value.&nbsp;

<p><b>translate</b>(int, int) - Translates the origin of the graphics context
to the point (<i>x</i>, <i>y</i>) in the current coordinate system.</td></tr></table>

<center><h2><a name="getting a graphics context"></a><font color="#ff0000">Getting
a Graphics Context</font></h2></center>
What does it mean to "get a graphics context?" In layman's terms, this
means that your application has gained the ability to draw or place images
on a component that has the ability to support drawing and images.

<p>According to <u>Java Software Solutions</u> by Lewis and Loftus:
<table border bgcolor="#80ffff" ><tr><td>"Each <b>Graphics</b> object represents a particular drawing surface.
... The <b>Graphics</b> object defines a <i>graphics context</i> through
which we manage all graphic activities on that surface."</td></tr></table>
According to <u>Just Java 1.1 and Beyond</u> by Peter van der Linden:
<table border bgcolor="#80ffff" ><tr><td>"A <b>Graphics</b> object is what you ultimately draw lines, shapes,
and text on. It is also called a "graphics context" in some window systems
because it bundles together information about a drawable area, plus font,
color, clipping region, and other situational factors."</td></tr></table>
Now that we know what a <i>graphics context </i>is, how do we get one?

<p>To begin with, we <u>don't</u> get one by instantiating an object of
type <b>Graphics</b>. The <b>Graphics</b> class cannot be directly instantiated
by the code that you write for your application. Rather, we can get a graphics
context in one of several indirect ways.

<p>One way to get a graphics context is to invoke the <b>getGraphics()</b>
method on another object. However, according to <u>Java AWT Reference</u>
by John Zukowski:
<table border bgcolor="#80ffff" ><tr><td>"The <b>getGraphics()</b> method returns the image's graphics context.
The method <b>getGraphics()</b> works only for <b>Image</b> objects created
in memory with <b>Component.createImage(int, int)</b>."</td></tr></table>
The <b>getGraphics()</b> method is commonly used when images are being
created in memory and then transferred to the screen (double buffering).
We will see some examples of double buffering in a subsequent lesson.

<p>This leaves us with two other ways to get a graphics context and they
are surprisingly simple.

<p>When you override either the <b>paint(Graphics g)</b> method or the
<b>update(Graphics g)</b> method, the graphics context of the object on
which the method is overridden is automatically passed in as a parameter.

<p>We typically override the <b>paint()</b> method whenever we want to
place graphics material on the screen. While it is possible to also override
<b>update()</b> this is usually done only in special circumstances (such
as animation and double buffering).

<p>The normal approach to displaying graphics material is to place code
in the overridden <b>paint()</b> method to do the job and then to invoke
<b>repaint()</b> to ask the system to paint the new material on the screen.
Note that the <b>paint()</b> method can also be invoked due to external
causes (such as the user moving things around on the screen) totally outside
the control of your program.

<p>Hopefully the following three quotations from <u>AWT Reference</u> by
John Zukowski will help to make this more clear.
<table border bgcolor="#80ffff" ><tr><td><b>public void repaint() </b>- The <b>repaint()</b> method requests
the scheduler to redraw the component as soon as possible. This will result
in <b>update()</b> getting called soon thereafter. There is not a one-to-one
correlation between <b>repaint()</b> and <b>update()</b> calls. It is possible
that multiple <b>repaint()</b> calls can result in a single <b>update()</b>
- Zukowski</td></tr></table>
&nbsp;
<table border bgcolor="#80ffff" ><tr><td><b>public void update(Graphics g)</b> - The <b>update()</b> method
is automatically called when you ask to repaint the <b>Component</b>. If
the component is not lightweight, the default implementation of <b>update()</b>
clears graphics context <b>g</b> by drawing a filled rectangle in the background
color, resetting the color to the current foreground color, and calling
<b>paint()</b>. If you do not override <b>update()</b> when you do animation,
you will see some flickering because <b>Component</b> clears the screen.
- Zukowski</td></tr></table>
&nbsp;
<table border bgcolor="#80ffff" ><tr><td><b>public void paint(Graphics g)</b> - The <b>paint()</b> method is
offered so the system can display whatever you want in a <b>Component</b>.
In the base <b>Component</b> class, this method does absolutely nothing.
Ordinarily, it would be overridden in an applet to do something other than
the default, which is display a box in the current background color. <b>g</b>
is the graphics context of the component being drawn upon. - Zukowski</td></tr></table>

<center><h3><a name="sample program to get and use a graphics context"></a><font color="#ff0000">Sample
Program to Get and Use a Graphics Context</font></h3></center>
So, let's see some code, and lets start out by making it simple from a
graphics viewpoint. The following sample program illustrates getting and
using a graphics context.

<p>The <b>drawString()</b> method in the following sample program is invoked
on the graphics context of a <b>Frame </b>object to display the string
"<b>Hello World</b>".

<p>When you compile and run this program, a <b>Frame </b>object will appear
on the screen. The client area of the <b>Frame </b>object will display
the words "Hello World".

<p>When you press the close button on the <b>Frame </b>object, the program
will terminate and control will be returned to the operating system.

<p>The key item in this program, from a graphics viewpoint, is the overridden
<b>paint()</b> method that draws the string data on the graphics context
passed in as a parameter to <b>paint()</b>. That material is highlighted
in <b>boldface</b> so that you can locate it easily.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics01.java
Copyright 1997, R.G.Baldwin

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Graphics01 extends Frame{ //controlling class

&nbsp; //Override the paint method to display the string "Hello
&nbsp; // World" on the graphics context of the Frame object.
<b>&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; g.drawString("Hello World",100,40);
&nbsp; }//end paint()

</b>&nbsp; public <b>Graphics01()</b>{//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(350,50);
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener

&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void <b>main</b>(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics01();//instantiate this object
&nbsp; }//end main
}//end Graphics01 class
//=======================================================//</pre></td></tr></table>
What about that anonymous inner-class listener statement. Well, I told
you that the program was going to be simple <i><u>from a graphics viewpoint</u></i>.
At least the <b>paint() </b>method is simple. In case you don't know about
inner-classes, you can learn about them in one of my earlier lessons.
<center><h2><a name="copying and clearing in a graphics"></a><font color="#ff0000">Copying
and Clearing in a Graphics Context</font></h2></center>
The two methods that are of primary interest in this section are <b>copyArea()</b>
and <b>clearRect()</b>.

<p>We'll begin with <b>clearRect()</b> because it is the simpler of the
two. This method clears a specified rectangle by filling it with the background
color of the current drawing surface. The method has four parameters as
follows:
<table border bgcolor="#80ffff" ><tr><td><dl><dl><dt><b>Parameters:</b>&nbsp;</dt>

<dd><b>x </b>- the <i>x</i> coordinate of the rectangle to clear.&nbsp;</dd>

<dd><b>y </b>- the <i>y</i> coordinate of the rectangle to clear.&nbsp;</dd>

<dd><b>width </b>- the width of the rectangle to clear.&nbsp;</dd>

<br><b>height </b>- the height of the rectangle to clear.&nbsp;</dl></dl></td></tr></table>
As in virtually all graphics methods in Java, the <b>x </b>and <b>y </b>coordinates
refer to the upper left-hand corner of the rectangular area to be cleared.

<p>Now consider the method named <b>copyArea()</b>. This method copies
a rectangular area of the current drawing surface to another area which
is separated from the first by a distance specified by <b>dx</b> and <b>dy</b>.
The method copies downwards and to the right. To copy an area of the drawing
surface to the left or upwards, specify a negative value for <b>dx</b>
or <b>dy</b>. Any portion of the source rectangle that is outside the current
drawing surface won't be copied.

<p>This method has six parameters as shown below.
<table border bgcolor="#80ffff" ><tr><td><dl><dl><dt><b>Parameters:</b>&nbsp;</dt>

<dd><b>x </b>- the <i>x</i> coordinate of the source rectangle.&nbsp;</dd>

<dd><b>y </b>- the <i>y</i> coordinate of the source rectangle.&nbsp;</dd>

<dd><b>width </b>- the width of the source rectangle.&nbsp;</dd>

<dd><b>height </b>- the height of the source rectangle.&nbsp;</dd>

<dd><b>dx </b>- the horizontal distance to copy the pixels.&nbsp;</dd>

<dd><b>dy </b>- the vertical distance to copy the pixels.&nbsp;</dd></dl></dl></td></tr></table>

<center><h3><a name="sample program to illustrate copying and clearing"></a><font color="#ff0000">Sample
Program to Illustrate Copying and Clearing</font></h3></center>
The following program illustrates the use of the <b>copyArea()</b> and
<b>clearRect()</b> methods of the <b>Graphics </b>class.

<p>This program draws the string "<b>Hello World</b>" in the upper left
corner of a <b>Frame </b>object. Then it uses the <b>copyArea()</b> method
to make two additional copies of the drawing by copying a rectangular area
from the upper left corner to two other areas.

<p>Then it uses the <b>clearRect()</b> method to erase most of the letter
"H" from the second copy by clearing a rectangular portion of the screen
that contains part of the drawing of the letter "H".

<p>When you compile and run this program, a <b>Frame </b>object will appear
on the screen. The client area of the <b>Frame </b>object will display
the words <b>Hello World</b> in two different locations, and the same words
with part of the "<b>H</b>" missing in another location.

<p>When you press the close button on the <b>Frame </b>object, the program
will terminate and control will be returned to the operating system.

<p>A listing of the program follows with interesting code fragments highlighted
in <b>boldface</b>.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics02.java
Copyright 1997, R.G.Baldwin

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Graphics02 extends Frame{ //controlling class

&nbsp; //Override the paint method to display the string "Hello
&nbsp; // World" on the graphics context of the Frame object.
&nbsp; public void <b>paint</b>(Graphics g){
&nbsp;&nbsp;&nbsp; g.drawString("Hello World",10,40);//draw the string
<b>&nbsp;&nbsp;&nbsp; g.copyArea(0,0,100,100,100,0); //copy to another spot
&nbsp;&nbsp;&nbsp; g.copyArea(0,0,100,100,100,50); //copy to another spot
&nbsp;&nbsp;&nbsp; g.clearRect(100,50,15,50); //erase part of second copy
</b>&nbsp; }//end paint()

&nbsp; public <b>Graphics02</b>(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(350,150);
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void <b>main</b>(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics02();//instantiate this object
&nbsp; }//end main
}//end Graphics02 class
//=======================================================//</pre></td></tr></table>

<center><h2><a name="creating a new graphics object"></a><font color="#ff0000">Creating
a new Graphics Object</font></h2></center>
According to some authors, the <b>create</b>() method creates a new <b>Graphics</b>
object that is a copy of the <b>Graphics</b> object on which it is invoked.
It might be more appropriate to say that it creates a second reference
to the <b>Graphics</b> object on which it is invoked because figures drawn
using the new reference appear on the original graphics context when it
is rendered.

<p>Whether it is a new object, or simply a second reference to the original
object, we will see that in many ways, it <u>behaves as though it is a
second reference to the original object</u>.

<p>The primary purpose of this section is to illustrate the use of the
<b>create()</b> method. Along the way, we will also illustrate a number
of other concepts:
<ul><li>
The requirement to contend with <i>insets </i>when drawing on objects that
have borders, such as <b>Frame </b>objects.</li>

<li>
The use of <b>clipping</b>.</li>

<li>
The use of <b>setColor()</b> to change the current drawing color.</li>

<li>
The use of the <b>dispose()</b> method to return <i>graphics context</i>
resources to the operating system.</li></ul>
We will see two sample programs in the next section. The first program
will deal with the <i>insets</i> problem by <u>adding compensating offset
values</u> to coordinates as parameters to method calls. The second program
will avoid the <i>insets</i> problem by <u>overlaying the client area of
a <b>Frame </b>object with a <b>Canvas</b> object</u> for which there are
no <i>insets</i>. (A sample program in a later section will eliminate the
<i>insets</i> problem through use of the <b>translate()</b> method.

<p>Also at this point we should say a few words about the use of the <b>dispose()</b>
method. Since the different books seem to have different explanations for
the need to dispose of the graphics contexts that you create, probably
the best thing to do is simply to provide the following material extracted
directly from the JavaSoft documentation for JDK 1.1.3
<table border bgcolor="#80ffff" ><tr><td><b>dispose()</b>&nbsp;

<p>Disposes of this graphics context and releases any system resources
that it is using. A Graphics object cannot be used after dispose has been
called.&nbsp;

<p>When a Java program runs, a large number of Graphics objects can be
created within a short time frame. Although the finalization process of
the garbage collector also disposes of the same system resources, it is
preferable to manually free the associated resources by calling this method
rather than to rely on a finalization process which may not run to completion
for a long period of time.&nbsp;

<p>Graphics objects which are provided as arguments to the paint and update
methods of components are automatically released by the system when those
methods return. For efficiency, programmers should call dispose when finished
using a Graphics object only if it was created directly from a component
or another Graphics object.</td></tr></table>

<center><h3><a name="sample programs to illustrate creating a new"></a><font color="#ff0000">Sample
Programs to Illustrate Creating a new Graphics Object</font></h3></center>
The idea for the example programs in this section is based on an applet
from the book entitled <u>AWT Reference</u> by John Zukowski. Mr. Zukowski
designed his applet to explain the use of clipping in Java. It was modified
here to include insets, color, etc.

<p>The first program illustrates the following graphics concepts:
<ul><li>
Creation of a second reference to a graphics context.</li>

<li>
The requirement to contend with insets when drawing on objects that have
borders, such as <b>Frame </b>objects.</li>

<li>
Drawing rectangles and lines.</li>

<li>
The use of <b>clipping</b>.</li>

<li>
The use of <b>setColor()</b> to change the current drawing color.</li>

<li>
The use of the <b>dispose()</b> method to return graphics context resources
to the operating system.</li></ul>
The <b>paint()</b> method in an extended <b>Frame </b>class is overridden
to perform the following tasks in order:
<ul><li>
Get the left and top insets of a <b>Frame </b>object so that they can be
used as arithmetic offsets later when drawing in the <b>Frame </b>object.</li>

<li>
Set the drawing color to red.</li>

<li>
Create a second reference to the graphics context passed to the <b>paint()</b>
method.</li>

<li>
Use the second reference to draw the outline of a red square 100 pixels
on each side.</li>

<li>
Set the drawing color for the second reference to blue.</li>

<li>
Clip the drawing area for the second reference to a square 50 pixels on
each side centered in the original square.</li>

<li>
Use the second reference to <u>attempt to draw</u> a blue line from the
upper left-hand corner to the lower right-hand corner of the original rectangle.
<u>Only that portion</u> of the line that is inside the new clipped drawing
area will actually be drawn.</li>

<li>
Call the <b>dispose()</b> method to return the resources occupied by the
second reference to the operating system.</li>

<li>
Set the second reference to <b>null </b>so that it will become eligible
for <i>garbage collection</i>.</li>

<li>
Use the original graphics context to set the drawing color to green.</li>

<li>
Use the original graphics context to draw a green line from the lower left-hand
corner to the upper right-hand corner of the original red rectangle. This
entire line will be visible because the clipping area does not apply to
the original graphics context.</li></ul>
When you compile and run this program, a <b>Frame </b>object will appear
on the screen. A red square will appear in the upper left portion of the
client area of the <b>Frame</b>.

<p>A green line will run from the bottom left corner to the upper right
corner within the square.

<p>A <u>segment</u> of a blue line will appear as the center portion of
an <u>imaginary line</u> that runs from the top left corner to the lower
right corner within the square. This blue line <u>segment</u> is the result
of clipping the line at the boundaries of the clipping area that was applied
to the second reference to the graphics context.

<p>When you press the close button on the <b>Frame </b>object, the program
will terminate and control will be returned to the operating system.

<p>This program was tested using JDK 1.1.3 under Win95.

<p>A complete listing follows with interesting code fragments highlighted
in <b>boldface</b>.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics03.java
Copyright 1997, R.G.Baldwin

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Graphics03 extends Frame{ //controlling class
&nbsp; //Override the paint method
&nbsp; public void <b>paint</b>(Graphics g){
&nbsp;&nbsp;&nbsp; int <b>top </b>= this.<b>getInsets</b>().<b>top</b>;//get top inset value
&nbsp;&nbsp;&nbsp; int <b>left </b>= this.<b>getInsets</b>().<b>left</b>;//get left inset value
&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(Color.red);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create another reference to the Graphics context g
&nbsp;&nbsp;&nbsp; Graphics <b>clpArea = g.create()</b>;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use original clpArea reference to draw a&nbsp;
&nbsp;&nbsp;&nbsp; // red rectangle
&nbsp;&nbsp;&nbsp; clpArea.<b>drawRect</b>(0+<b>left</b>,0+<b>top</b>,100,100);

&nbsp;&nbsp;&nbsp; clpArea.<b>setColor</b>(Color.blue);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Reduce clpArea reference to rectangle shown
&nbsp;&nbsp;&nbsp; clpArea.<b>clipRect</b>(25+<b>left</b>,25+<b>top</b>,50,50);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use clpArea ref to <b>try to draw</b> a blue diagonal line
&nbsp;&nbsp;&nbsp; // across the entire original rectangle.&nbsp; <i>Only middle
&nbsp;&nbsp;&nbsp; // portion actually gets drawn</i>.
&nbsp;&nbsp;&nbsp; clpArea.<b>drawLine</b>(0+<b>left</b>,0+<b>top</b>,100+<b>left</b>,100+<b>top</b>);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; clpArea.<b>dispose</b>();//free system resources
&nbsp;&nbsp;&nbsp; clpArea = <b>null</b>;//make eligible for garbage collection
&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(Color.green);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the original graphics context to draw a green
&nbsp;&nbsp;&nbsp; // diagonal line across the entire rectangle.
&nbsp;&nbsp;&nbsp; g.<b>drawLine</b>(0+<b>left</b>,100+<b>top</b>,100+<b>left</b>,0+<b>top</b>);
&nbsp; }//end paint()

&nbsp; public Graphics03(){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(300,150);
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void <b>main</b>(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics03();//instantiate this object
&nbsp; }//end main
}//end Graphics03 class
//=======================================================//</pre></td></tr></table>
The second program illustrates the use of a <b>Canvas</b> object as the
<i>drawing surface</i> in order to eliminate the <i>insets</i> problem.
Otherwise, it is very similar to the first program.

<p>Use of the <b>Canvas</b> object as a drawing surface eliminates the
<i>insets</i> problem simply because a <b>Canvas</b> object doesn't have
any borders.

<p>The <i>insets</i><b> </b>result from the fact that some containers,
such as a <b>Frame</b> object, have borders, and the area covered by the
borders is considered to be a part of the drawing surface, insofar as coordinate
values are concerned.

<p>In other words, the 0,0 coordinate position is the upper left-hand corner
of the container, outside the borders if it has borders.

<p>The <b>getInsets()</b> method provides the width in pixels of the four
borders which makes it possible to compensate arithmetically for the borders
when working with coordinate values.

<p>In order to be able to use a <b>Canvas</b> object as a drawing surface,
it is necessary to extend the <b>Canvas</b> class so that the <b>paint()</b>
method can be overridden. In the following program, the <b>Canvas</b> class
was extended into a new class named <b>MyClass</b> where the <b>paint()</b>
method was overridden to perform the graphics operations.

<p>An object of the <b>MyCanvas</b> class was instantiated, made yellow,
and added to the <b>Frame</b> object in such a way as to cover the entire
client area of the <b>Frame</b> object and act as a drawing surface on
top of the <b>Frame</b> object. Since the <b>MyCanvas</b> object has no
borders, the <i>insets</i> problem was eliminated.

<p>As with the first program, the idea for this program was based on an
applet from the book entitled <u>AWT Reference </u>by John Zukowski.

<p>A complete listing of the program follows with interesting code fragments
highlighted in <b>boldface</b>.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics04.java
Copyright 1997, R.G.Baldwin

This sample program replicates the functionality of the
program named Graphics03.&nbsp; However, it was modified to
eliminate the nuisance of having to contend with insets
when drawing on a Frame object.

The requirement to contend with insets was eliminated by
adding a Canvas object to the Frame object and drawing on
the Canvas object instead of on the Frame object.&nbsp; A
Canvas object doesn't have borders, so there are no insets
to contend with.

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

//Extend Canvas in order to make it possible to override
// the paint() method.
<b>class</b> <b>MyCanvas extends Canvas</b>{
&nbsp; //Override the paint method
&nbsp; public void <b>paint</b>(Graphics g){
&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(Color.red);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create another reference to the Graphics context g
&nbsp;&nbsp;&nbsp; Graphics clpArea = g.<b>create</b>();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use original clpArea reference to draw a&nbsp;
&nbsp;&nbsp;&nbsp; // red rectangle
&nbsp;&nbsp;&nbsp; clpArea.<b>drawRect</b>(0,0,100,100);
&nbsp;&nbsp;&nbsp; clpArea.<b>setColor</b>(Color.blue);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Reduce clpArea reference to rectangle shown
&nbsp;&nbsp;&nbsp; clpArea.<b>clipRect</b>(25,25,50,50);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use clpArea ref to try to draw a blue diagonal line
&nbsp;&nbsp;&nbsp; // across the entire original rectangle.&nbsp; Only middle
&nbsp;&nbsp;&nbsp; // portion actually gets drawn.
&nbsp;&nbsp;&nbsp; clpArea.<b>drawLine</b>(0,0,100,100);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; clpArea.<b>dispose</b>();//free system resources
&nbsp;&nbsp;&nbsp; clpArea = <b>null</b>;//make eligible for garbage collection
&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(Color.green);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the original graphics context to draw a green
&nbsp;&nbsp;&nbsp; // diagonal line across the entire rectangle.
&nbsp;&nbsp;&nbsp; g.<b>drawLine</b>(0,100,100,0);
&nbsp; }//end paint()
&nbsp;&nbsp;
}//end class MyCanvas

//=======================================================//
class Graphics04 extends Frame{ //controlling class

&nbsp; public Graphics04(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(300,150);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a yellow drawing surface and use it to cover
&nbsp;&nbsp;&nbsp; // the client area of the Frame object.
<b>&nbsp;&nbsp;&nbsp; MyCanvas myDrawingSurface = new MyCanvas();
&nbsp;&nbsp;&nbsp; myDrawingSurface.setBackground(Color.yellow);
&nbsp;&nbsp;&nbsp; this.add(myDrawingSurface);
</b>&nbsp;&nbsp;&nbsp; this.setVisible(true);&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics04();//instantiate this object
&nbsp; }//end main
}//end Graphics04 class

//=======================================================//</pre></td></tr></table>

<center><h2><a name="using the translate() method"></a><font color="#ff0000">Using
the translate() Method</font></h2></center>
The <b>translate(int x, int y)</b> method translates the origin of the
graphics context to the point (<b>x</b>, <b>y</b>) in the current coordinate
system. The method <u>modifies</u> the graphics context so that its new
origin corresponds to the point (<b>x</b>, <b>y</b>) in this graphics context's
<u>original coordinate system</u>.

<p>All coordinates used in subsequent rendering operations on the graphics
context (or a copy or second reference to the graphics context made after
the translation takes place) will be relative to the new origin.
<center><h3><a name="sample program to illustrate use of the translate() method"></a><font color="#ff0000">Sample
Program to Illustrate Use of the translate() Method</font></h3></center>
The <b>translate()</b> method provides another useful way to eliminate
the <i>insets</i> problem. In particular, the method can be used to translate
the origin of the graphics context to the upper left-hand corner of the
client area of the <b>Frame</b> object (inside the borders).

<p>The following program replicates the functionality of the program named
<b>Graphics03</b>. However, it eliminates the problem of <i>insets </i>by
invoking the <b>translate()</b> method on the original graphics context
to shift the origin to the upper left- hand corner of the the client area
of the <b>Frame </b>object (inside the borders).

<p>The program illustrates the same concepts as previous programs, and
in addition illustrates the use of the <b>translate()</b> method to shift
the 0,0 coordinate position to a different spot on the graphics context.

<p>Minimal changes were required to the original program named <b>Graphics03</b>
to implement this solution to the <i>insets</i> problem. Those changes
are highlighted in <b>boldface </b>in the program listing that follows.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics05.java
Copyright 1997, R.G.Baldwin

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Graphics05 extends Frame{ //controlling class
&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; g.setColor(Color.red);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Translate the 0,0 coordinate of the graphics context
&nbsp;&nbsp;&nbsp; // to the upper left-hand corner of the client area of
&nbsp;&nbsp;&nbsp; // the Frame object.
<b>&nbsp;&nbsp;&nbsp; g.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getInsets().left,this.getInsets().top);
</b>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create another reference to the Graphics context g
&nbsp;&nbsp;&nbsp; Graphics clpArea = g.create();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use original clpArea reference to draw a&nbsp;
&nbsp;&nbsp;&nbsp; // red rectangle
&nbsp;&nbsp;&nbsp; clpArea.drawRect(0,0,100,100);
&nbsp;&nbsp;&nbsp; clpArea.setColor(Color.blue);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Reduce clpArea reference to rectangle shown
&nbsp;&nbsp;&nbsp; clpArea.clipRect(25,25,50,50);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use clpArea ref to try to draw a blue diagonal line
&nbsp;&nbsp;&nbsp; // across the entire original rectangle.&nbsp; Only middle
&nbsp;&nbsp;&nbsp; // portion actually gets drawn.
&nbsp;&nbsp;&nbsp; clpArea.drawLine(0,0,100,100);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; clpArea.dispose();//free system resources
&nbsp;&nbsp;&nbsp; clpArea = null;//make eligible for garbage collection
&nbsp;&nbsp;&nbsp; g.setColor(Color.green);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the original graphics context to draw a green
&nbsp;&nbsp;&nbsp; // diagonal line across the entire rectangle.
&nbsp;&nbsp;&nbsp; g.drawLine(0,100,100,0);
&nbsp; }//end paint()

&nbsp; public Graphics05(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(300,150);
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics05();//instantiate this object
&nbsp; }//end main
}//end Graphics05 class
//=======================================================//</pre></td></tr></table><font color="#000000">.</font><center><h2><a name="xor mode vs paint mode"></a><font color="#ff0000">XOR Mode vs
Paint Mode</font></h2></center>
This section of this lesson explains "<b>how </b>to do it" and not "<b>why
</b>to do it". If you don't already know that you need to render your drawing
in <b>XOR </b><i>(exclusive or)</i> mode, you probably don't need to render
it in <b>XOR </b>mode.

<p>The <b>Paint</b> mode that results from invoking the <b>setPaintMode()</b>
method is easy to explain. Each new pixel that you render simply replaces
the existing pixel with the color of the new pixel.

<p>However, the <b>XOR </b>mode that results from invoking the <b>setXORMode()</b>
method is much more complex and requires an explanation.

<p>In this section, we will look at some specific examples of performing
an <i>exclusive or</i> on selected bit patterns. The results will be important
in understanding the programming example in the next section.

<p>The rules for the determining the <i>exclusive or</i> of two bits are
shown in the following box:
<table border bgcolor="#80ffff" ><tr><td><pre>0 or 0 = 0
1 or 0 = 1
0 or 1 = 1
1 or 1 = 0</pre></td></tr></table>
In other words, if either but not both of the bits is a 1, the output is
a 1. Otherwise, the output is a 0.

<p>The following box shows the bit patterns for the 24 bits that comprise
the color portion of four different Java RGB color values (the remaining
eight bits are not shown).
<table border bgcolor="#80ffff" ><tr><td><pre>111111110000000000000000 = red
000000001111111100000000 = green
000000000000000011111111 = blue
111111111111111111111111 = white</pre></td></tr></table>
When you invoke the <b>setXORMode(Color altColor)</b> method, the color
for each pixel that is rendered thereafter is determined by the <b>XOR
</b>of three color values:
<ul><li>
the current drawing color,</li>

<li>
the <b>altColor </b>value passed as a parameter to the <b>setXORMode()</b>
mode, and</li>

<li>
the current color of the pixel.</li></ul>
Consider the following <b>XOR </b>example of rendering a new <i>red </i>pixel
on an existing <i>red </i>pixel where the <b>XOR altColor</b> value has
been set to <i>green</i>. The three color values are shown below along
with the intermediate and final <b>XOR </b>of the three.
<table border bgcolor="#80ffff" ><tr><td><pre>111111110000000000000000 = red
111111110000000000000000 = red
000000000000000000000000 = intermediate result
000000001111111100000000 = green
000000001111111100000000 = final result which is green</pre></td></tr></table>
As you can see, the <b>XOR Mode</b> result of drawing <i>red </i>on <i>red
</i>produces the value of the third color which in this case is the <b>altColor
</b>value passed to the <b>setXORMode()</b> method.

<p>Thus, if we are in <b>XOR Mode</b> and draw <i>red</i> on <i>red</i>,
the actual color rendered will be the color that was passed to the <b>setXORMode()
</b>method when it was invoked. This will be true when drawing any color
on top of the same color.

<p>Now consider the following <b>XOR </b>example of rendering a <i>red
</i>pixel on a <i>white </i>pixel where the <b>XOR altColor </b>value has
been set to <i>green</i>. The three color values are shown below along
with the intermediate and final <b>XOR </b>of the three.
<table border bgcolor="#80ffff" ><tr><td><pre>111111110000000000000000 = red
111111111111111111111111 = white
000000001111111111111111 = intermediate result
000000001111111100000000 = green
000000000000000011111111 = final result which is blue</pre></td></tr></table>
As you can see, the <b>XOR </b>of <i>red</i>, <i>white</i>, and <i>green
</i>produces the color value for <i>blue</i>. Using this scheme, you should
be able to determine the numeric value of the color value that will be
produced for the <b>XOR</b> of any three colors.

<p>One of the reasons for using <b>XOR</b> rendering is the fact that when
a figure is redrawn on itself in <b>XOR</b> mode, the result is to <u>erase
the figure</u> and restore the background to its state prior to the drawing
of the figure in the first place. This is true even for multi-colored backgrounds.
This is sometimes used in animation processes as a way to draw and erase
a figure very quickly. With this concept in mind, consider the process
of performing the same <b>XOR </b>two times in succession. Use the <i>red-red-green
</i>case as an example.
<table border bgcolor="#80ffff" ><tr><td><pre><font size=-1>111111110000000000000000 = red
111111110000000000000000 = red
000000000000000000000000 = intermediate result
000000001111111100000000 = green
000000001111111100000000 = final result which is green

Now starting with green, XOR the same red pixel

000000001111111100000000 = green
111111110000000000000000 = red
111111111111111100000000 = intermediate result
000000001111111100000000 = green
111111110000000000000000 = red which is the original color of the pixel</font></pre></td></tr></table>
As you can see, the final color of the pixel is the same that it was before
the new pixel color was rendered twice in succession. This is as we would
expect based on the previous discussion of the figure erasing itself on
the second rendering in <b>XOR</b> mode.
<center><h3><a name="sample program to illustrate use of xor and paint modes"></a><font color="#ff0000">Sample
Program to Illustrate use of XOR and Paint Modes</font></h3></center>
This section contains a sample program that matches the <b>XOR</b> bit-pattern
examples given above.

<p>This program illustrates the use of <b>setXORMode()</b> and <b>setPaintMode()</b>.
It shows the result of overlapping drawings in both modes. It also shows
the result of redrawing a figure that was originally drawn in <b>XOR </b>mode.

<p>It is strongly recommended that you compile and run this program because
you will probably need to see the display to understand the following description.

<p>This program draws <u>two sets</u> of four overlapping filled squares
at different locations on the screen with a drawing color of red. The current
drawing color is not changed during the entire sequence of drawing squares.

<p>For both sets, the first two overlapping squares are drawn in the default
<b>Paint </b>mode. This produces two red squares which overlap and merge
in the overlapping area. Except for the fact that you know they are squares
(because I told you so), it is not possible to discern the shape of the
overlapping area. If they were overlapping polygons, for example, you would
not be able to discern the shape of the overlapping area.

<p>Then the mode is changed to <b>XOR </b>with an <b>XOR altColor</b> value
of green and a third overlapping square is drawn with the current drawing
color being red.

<p>In this case, <u>the overlap between the two squares is green</u>. (You
should have expected this based on the discussion in the previous section.)
Thus, it is now possible to discern the shape of of the overlapping area.

<p>In addition, that portion of the square that doesn't overlap the red
square but is drawn on the white background is rendered in blue. (Again,
you should have expected this on the basis of the discussion in the previous
section.)

<p>Then the mode is reset to <b>Paint </b>and a fourth overlapping square
is drawn. It simply overdraws the blue square with red in the intersecting
area as would be expected for the <b>Paint</b> mode.

<p>To demonstrate the manner in which drawing the same figure twice in
the <b>XOR </b>mode causes it to be erased, the same sequence is repeated
again in a location further to the right on the screen.

<p>However, in this case, after all four squares have been drawn, the mode
is set to <b>XOR </b>and another square is drawn in the exact location
of the third square in the sequence (the one previously drawn in <b>XOR</b>
mode). In other words, the third square is redrawn in <b>XOR </b>mode.

<p>This causes the green and blue portions of that square to be replaced
by red and white, effectively erasing the square and returning the display
to its original form (as you should expect).

<p>However, that portion of the third square that was previously overlapped
by the fourth square (causing it to be red instead of blue), was rendered
as green because the fourth square wasn't there when the third square was
originally drawn. Therefore, redrawing it causes the redrawn square to
overlap the fourth square and produce the green overlap area.

<p>A program listing follows. Interesting code fragments are highlighted
in <b>boldface</b>.
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Graphics06.java
Copyright 1997, R.G.Baldwin

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Graphics06 extends Frame{ //controlling class
&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; g.setColor(Color.red);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Translate the 0,0 coordinate of the graphics context
&nbsp;&nbsp;&nbsp; // to the upper left-hand corner of the client area of
&nbsp;&nbsp;&nbsp; // the Frame object.
&nbsp;&nbsp;&nbsp; g.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getInsets().left,this.getInsets().top);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //<b>Draw first set</b> of four overlapping filled red&nbsp;
&nbsp;&nbsp;&nbsp; // squares.&nbsp; Start drawing in the default Paint mode.
<b>&nbsp;&nbsp;&nbsp; g.fillRect(0,0,50,50);
&nbsp;&nbsp;&nbsp; g.fillRect(25,25,50,50);
</b>&nbsp;&nbsp;&nbsp; //Set to XOR mode and draw another overlapping square
&nbsp;&nbsp;&nbsp; // with the drawing color set to red and the XOR color
&nbsp;&nbsp;&nbsp; // set to green.&nbsp; This will produce a square that is&nbsp;
&nbsp;&nbsp;&nbsp; // green where it overlaps a red square and is blue
&nbsp;&nbsp;&nbsp; // where it doesn't overlap the red square but is
&nbsp;&nbsp;&nbsp; // being drawn on the white background.
<b>&nbsp;&nbsp;&nbsp; g.setXORMode(Color.green);
&nbsp;&nbsp;&nbsp; g.fillRect(50,50,50,50);
</b>&nbsp;&nbsp;&nbsp; //Reset to default Paint mode and draw another&nbsp;
&nbsp;&nbsp;&nbsp; // overlapping square. This will simply draw a red
&nbsp;&nbsp;&nbsp; // square covering part of the blue square and covering
&nbsp;&nbsp;&nbsp; // the white background
<b>&nbsp;&nbsp;&nbsp; g.setPaintMode();
&nbsp;&nbsp;&nbsp; g.fillRect(75,75,50,50);
</b>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now <b>demonstrate the cancelling effect</b> of redrawing
&nbsp;&nbsp;&nbsp; // a square in XOR mode.
&nbsp;&nbsp;&nbsp; //<b>Draw second set</b> of four overlapping filled red&nbsp;
&nbsp;&nbsp;&nbsp; // squares <b>exactly as before</b> but at a different&nbsp;
&nbsp;&nbsp;&nbsp; // location on the screen.
&nbsp;&nbsp;&nbsp; g.fillRect(200,0,50,50);
&nbsp;&nbsp;&nbsp; g.fillRect(225,25,50,50);
&nbsp;&nbsp;&nbsp; g.setXORMode(Color.green);
&nbsp;&nbsp;&nbsp; g.fillRect(250,50,50,50);
&nbsp;&nbsp;&nbsp; g.setPaintMode();
&nbsp;&nbsp;&nbsp; g.fillRect(275,75,50,50);
<b>&nbsp;&nbsp;&nbsp; //***Important concept demonstrated here ***
</b>&nbsp;&nbsp;&nbsp; //Now <b>redraw the third square</b> in the second set
&nbsp;&nbsp;&nbsp; // in <b>XOR mode</b>.&nbsp; This will erase the one originally
&nbsp;&nbsp;&nbsp; // drawn except where it overlaps the fourth square.
&nbsp;&nbsp;&nbsp; // That overlap will be green.
<b>&nbsp;&nbsp;&nbsp; g.setXORMode(Color.green);
&nbsp;&nbsp;&nbsp; g.fillRect(250,50,50,50);

</b>&nbsp; }//end paint()

&nbsp; public Graphics06(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(350,200);
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Graphics06();//instantiate this object
&nbsp; }//end main
}//end Graphics06 class
//=======================================================//</pre></td></tr></table>

<center><h2><a name="summary"></a><font color="#ff0000">Summary</font></h2></center>
This lesson has explained and illustrated the use of the following methods
from the original list of <b>Graphics</b> utility methods given at the
beginning of the lesson:
<ul><li><b>clearRect</b>(int, int, int, int)</li>

<li><b>copyArea</b>(int, int, int, int, int, int)</li>

<li><b>create</b>()</li>

<li><b>dispose</b>()</li>

<li><b>setColor</b>(Color)</li>

<li><b>translate</b>(int, int)</li>

<li><b>setPaintMode</b>()</li>

<li><b>setXORMode</b>(Color)</li></ul>
We did not illustrate or explain the use of the following methods:
<ul><li><b>toString</b>()</li>

<li><b>getColor</b>()</li>

<li><b>finalize</b>()</li></ul>
The <b>toString() </b>method is simply overridden to return a <b>String</b>
object that describes a <b>Graphics</b> object. We have seen many examples
of the overridden <b>toString()</b> method in earlier lessons.

<p>The <b>getColor() </b>method is the flip side of the <b>setColor()</b>
method and should not be difficult for you to understand on your own.

<p>The <b>finalize() </b>method is overridden to dispose of the <b>Graphics</b>
object prior to garbage collection. However, as explained above, you should
manually dispose of the <b>Graphics</b> objects that you create and not
wait for finalization to take place.

<p>-end-<!--end--></body></html>