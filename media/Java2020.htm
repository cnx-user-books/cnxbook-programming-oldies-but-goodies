<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">
<h2>
Java Sound, Writing More Robust Audio Programs</h2>
<i>Baldwin shows you how to write more robust audio programs by using the 
getAudioFileTypes method of the AudioSystem class to limit the file-type choices 
presented to the user.&nbsp; This eliminates the possibility that the user will 
select a file type that is not supported by the system.</i><p><b>Published:</b>&nbsp; 
May 6, 2003<br><b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
<p>Java Programming Notes # 2020<ul >
<li>
<a href="#Preface">Preface</a></li>
<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Code</a></li>

<li>
<a href="#Run the program">Run the Program</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<p>
This  series of lessons is designed to teach you how to use the 
Java Sound API.&nbsp; The first lesson in the series was entitled 
<a href="http://www.developer.com/java/other/article.php/1565671">Java Sound, An 
Introduction</a>.&nbsp; The 
previous lesson was entitled
<a href="http://www.developer.com/java/other/article.php/2191351">Java Sound, 
Using Audio Line Events</a>.</p>
<p><font color="#FF0000"><b>Two types of audio data</b></font></p>
<p>
Two  different 
types of audio data are supported by the Java Sound API:<ul>
  <li>Sampled audio data</li>
  <li>Musical Instrument Digital Interface (MIDI) data</li>
  </ul>
  <p>The two types of audio data are very different.&nbsp;  I 
  am concentrating on sampled audio data at this point in time.&nbsp; I will defer 
  my discussion of 
      MIDI    until later.<p>
<b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings and figures while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at <font color="#000000">
<a href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font><p>
<font color="#FF0000"><b>Material in earlier lessons</b></font><p>Earlier lessons in the series 
showed you how to:<ul>
  <li>Play back audio files, including those that you create using a Java 
  program, and those that you acquire from other sources.</li>
  <li>Capture microphone data into audio files types of your own choosing.</li>
  <li>Capture microphone data into a <b>ByteArrayOutputStream</b> object.</li>
  <li>Use the Sound API to play back previously captured audio data.</li>
  <li>Identify the mixers available on your system.</li>
  <li>Specify a 
  particular mixer for use in the acquisition of audio data from a microphone.</li>
  <li>Understand the use of lines and mixers in the Java Sound API.</li>
  </ul>
  <h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
  <p><font color="#FF0000"><b>Previous programs were simple and not very robust</b></font><p>
In the interest of simplicity, the sample programs that I have provided in 
earlier lessons have not been particularly robust.&nbsp; For example, in the 
previous programs, if the program attempts to capture data using an audio format 
that is not supported by the system, the program simply throws an error and 
aborts.&nbsp; Similarly, if the program attempts to write an audio file as a 
file type that is not supported by the system, the program  throws an error and aborts.<p>
<font color="#FF0000"><b>Your programs need to be more robust</b></font><p>
Obviously, programs that you write for the real world must be more robust than 
those that I have provided.&nbsp; Fortunately, the <b>AudioSystem</b> class 
provides methods, such as <b>getAudioFileTypes</b>,<b> isFileTypeSupported</b>, 
and <b>isConversionSupported</b>, which can be used to write more robust 
programs.&nbsp; Methods such as this can be used to limit the choices presented 
to the user, or to test the choices made by the user before trying to execute 
code that implements those choices.<p><font color="#FF0000"><b>Limiting the 
choice of output file types</b></font><p>In this lesson, I will teach you how to 
use the <b>getAudioFileTypes</b> method of the <b>AudioSystem</b> class to limit 
the file-type choices presented to the user, thus eliminating the possibility 
that the user will select an output file type that is not supported by the 
system.&nbsp; 
Hopefully, this example will suggest other ways in which you can use  methods of the <b>
AudioSystem</b> class to make your audio programs more robust.<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2></center>
<p>
<font color="#FF0000"><b>The user interface</b></font><p>
The user interface for the sample program that I will discuss in this lesson is shown in Figure 1.<p align="center">
<img border="0" src="java2020a.gif" width="301" height="121"><p align="center">
Figure 1&nbsp; GUI for current version of the program<p>
<font color="#FF0000"><b>More robust update of an earlier program</b></font><p>
This is an update of the program named <b>AudioRecorder02</b>, which was 
discussed in a previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/2105421">Java Sound, Capturing Microphone Data 
into an Audio File</a>.<p>
This updated version is more 
robust than the original version.&nbsp; In particular, this updated version demonstrates how to limit the file-type choices to 
only those that are supported by the system.&nbsp; This eliminates the 
possibility that the user might select an audio file type that is not supported 
by the system.<p>
<font color="#FF0000"><b>Compare GUI with earlier program</b></font><p>
The GUI for the earlier program named <b>AudioRecorder02</b> is shown in Figure 
2.&nbsp; In both Figure 1 and Figure 2, the user selects a file type by 
selecting a radio button from among those exposed by the GUI.<p align="center">
<img border="0" src="java2020b.gif" width="301" height="121"><p align="center">
Figure 2&nbsp; GUI from earlier version of the program<p>
If you compare Figure 2 with Figure 1, you will see that the GUI shown in Figure 
1 limits the user to the three file types supported by my system, whereas the 
GUI in Figure 2 allows the user to select file types that are not supported by 
my system.&nbsp; Selecting file types that are not supported by the system 
results in runtime errors which, if not handled properly, will cause the program 
to abort.<blockquote>
  <p>
<i>(Because your system may support a different set of file types, your GUI may 
not look exactly like Figure 1.&nbsp; In particular, your GUI may display a 
different set of radio buttons.)</i></blockquote>
<p>
<font color="#FF0000"><b>Basic operation</b></font><p>
This program demonstrates the capture of audio data from a microphone into an audio file 
type of the user's choosing.<p>
When the program starts, a GUI appears on the screen containing the following buttons, 
as shown in Figure 1:<ul>
  <li>Capture</li>
  <li>Stop</li>
  </ul>
  <p>
In addition, up to five radio buttons appear in the GUI, allowing the user to select 
from among the following five audio  file types:<ul>
    <li>AIFC</li>
    <li>AIFF</li>
    <li>AU</li>
    <li>SND</li>
    <li>WAVE</li>
    </ul>
    <blockquote>
    <p>
<i>(These are the common file types supported by Java SDK version 1.4.1.&nbsp; A 
future version of the SDK might support additional file types that are not included 
in the above list.&nbsp; If so, this program will default to writing 
file type AU in place of the new file types that are not included in the above list.)</i></blockquote>
    <p>
<font color="#FF0000"><b>User's choice is limited</b></font><p>
Only those file types that are supported by the system are presented to the user 
in the GUI <i>(see Figure 1).</i>&nbsp; Therefore, only those file types supported by the 
system can be selected by the user.<p>
<font color="#FF0000"><b>Capturing data from the microphone</b></font><p>
When the user clicks the <b>Capture</b> button, input data from a microphone is captured and saved in an audio file named junk.xx having the specified file format.<blockquote>
      <p>
<i>(xx is the common file name extension for the specified file type.&nbsp; You can easily 
modify the program to change the file name to something other than junk if you choose to do so.)</i></blockquote>
    <p>
Data capture stops and the output file is closed when the user clicks the <b>Stop</b> button.<p>
<font color="#FF0000"><b>Playing back the audio data</b></font><p>
It should be possible for you to play back the audio file using any of a variety of readily available media players, such as the Windows Media Player.<p>
<font color="#FF0000"><b>Using a Java audio player</b></font><p>
I  showed you how to write a Java program to play back audio files in the 
lesson entitled
<a href="http://www.developer.com/java/other/article.php/2173111">Java Sound, Playing Back Audio Files using Java</a>.&nbsp; You can also use that program to play back the audio file produced by 
this program.<p>
<font color="#FF0000"><b>Will discuss the program in fragments</b></font><p>
As usual, I will discuss this program in fragments.&nbsp; A complete listing of 
the program is shown in Listing 14 near the end of the lesson.<p>
<font color="#FF0000"><b>Updated version of a previously-discussed program</b></font><p>
The program that I will discuss in this lesson is an updated version of the 
program named <b>AudioRecorder02</b>, which I discussed in detail in the lesson entitled
<a href="http://www.developer.com/java/other/article.php/2105421">Java Sound, Capturing Microphone Data into an Audio File</a>.<p>
Although I will discuss the entire program  briefly to establish the 
context, I will concentrate my detailed discussion on those aspects of the 
new program that were updated to make the program more robust.&nbsp; I recommend 
that you refer back to the lesson listed above for a detailed discussion of the 
other parts of the program.<p>
<font color="#FF0000"><b>The program named AudioRecorder03</b></font><p>
The new program, named <b>AudioRecorder03</b>, demonstrates the use of a Java program 
to capture audio data from a microphone into an audio file type of the user's 
choosing, where the choices presented to the user are limited to only those file 
types supported by the system.&nbsp; Thus, the user is prevented from choosing 
file types that are not supported by the system,  which would result in 
runtime errors if selected.<p>
<font color="#FF0000"><b>The controlling class named AudioRecorder03</b></font><p>
The class definition for the controlling class begins in Listing 1.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public class <b>AudioRecorder03</b> extends JFrame{

  AudioFormat audioFormat;
  TargetDataLine targetDataLine;

  final JButton captureBtn =
                          new JButton("Capture");
  final JButton stopBtn = new JButton("Stop");

  final JPanel btnPanel = new JPanel();
  final ButtonGroup btnGroup = new ButtonGroup();

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p>
The class definition begins by declaring <i>(and initializing)</i> several 
instance variables.&nbsp; The instance variables in Listing 1 were discussed in 
the earlier lesson, so I won't discuss them further here.<p>
<font color="#FF0000"><b>New instance variables</b></font><p>
The code in Listing 2 declares two new instance variables that were not 
included in the program in the earlier lesson.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  JRadioButton[] radioBtnArray;
  AudioFileFormat.Type[] fileTypes;

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>An array of JRadioButton objects</b></font><p>
The program in the earlier lesson displayed five radio buttons on the user 
interface, regardless of the number of audio file types supported by the system.&nbsp; 
Since the number of radio buttons was known at compile time, a different instance variable 
was declared to contain a reference to each of the five radio buttons.<p>
<font color="#FF0000"><b>Number of radio buttons is unknown at compile time</b></font><p>
In this version of the program, one radio button is required for each file type 
supported by the system.&nbsp; Therefore, the number of required radio buttons 
is not known at compile time.&nbsp; The number of file types supported by the 
system cannot be determined until runtime.<p>
Since the required number of radio buttons cannot be 
determined until runtime, it is necessary to accommodate the 
uncertainty in the program code.<p>
<font color="#FF0000"><b>A reference variable for an array object</b></font><p>
The code in Listing 2 declares a reference variable capable of holding a 
reference to an array object of type <b>JRadioButton</b>.&nbsp; The actual size 
of the array is established at runtime when it is determined how many radio 
buttons are to be displayed.<p>
An array object is instantiated at runtime, and that object's reference is 
stored in the reference variable named <b>radioBtnArray</b> in Listing 2.&nbsp; 
Then the references to the individual radio buttons are stored in the elements 
of the array object.&nbsp; We will see the code that accomplishes this later.<p>
<font color="#FF0000"><b>An array of tile types</b></font><p>
The second instance variable declared in Listing 2, named <b>fileTypes</b>, is a 
reference variable capable of holding a reference to an array object.&nbsp; The 
array object is capable of holding references to objects of type<b> 
AudioFileFormat.Type</b>.<p>
An array object will be instantiated at runtime with the size of the array equal 
to the number of file types supported by the system.&nbsp; The array object's 
reference will be assigned to the reference variable named <b>fileTypes</b>.&nbsp; 
A reference to one of the supported file types will be stored in each element of 
the array.<p>
<font color="#FF0000"><b>The main method</b></font><p>
The <b>main </b>method shown in Listing 3 is identical to that used in the 
program in the earlier lesson, so I won't discuss it further.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public static void main( String args[]){
    new AudioRecorder03();
  }//end main

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The constructor</b></font><p>
The constructor begins in Listing 4.&nbsp; That portion of the constructor shown 
in Listing 4 is the same as was used in the program in the earlier lesson.&nbsp; 
If you don't understand something in Listing 4, you should refer back to the 
earlier lesson for a detailed discussion.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public <b>AudioRecorder03</b>(){//constructor
    captureBtn.setEnabled(true);
    stopBtn.setEnabled(false);

    //Register anonymous listeners
    captureBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(false);
          stopBtn.setEnabled(true);
          //Capture input data from the
          // microphone until the Stop button is
          // clicked.
          <b>captureAudio();</b>
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()

    stopBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(true);
          stopBtn.setEnabled(false);
          //Terminate the capturing of input data
          // from the microphone.
          targetDataLine.stop();
          targetDataLine.close();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()

    //Put the buttons in the JFrame
    getContentPane().add(captureBtn);
    getContentPane().add(stopBtn);

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Get the supported file types</b></font><p>
Continuing with the discussion of the constructor, the code in Listings 5 
through 8 is new to this version of the 
program.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    fileTypes = <b>AudioSystem.getAudioFileTypes()</b>;
       
<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 5 invokes the static<b> getAudioFileTypes</b> method of the
<b>AudioSystem</b> class to get and save the file types for which file writing 
support is provided by the system.<p>
<font color="#FF0000"><b>Returns an array of type AudioFileFormat.Type</b></font><p>
This method returns a reference to an array object of type <b>
AudioFileFormat.Type</b>.&nbsp; The reference is assigned to the instance 
variable named <b>fileTypes</b>, which was declared in Listing 2.<p>
According to the documentation, <i>&quot;If no file types are supported, an array of 
length 0 is returned.&quot;</i><blockquote>
  <p>
<i>(That is a 
possibility that I didn't explicitly take into account in this version of the 
program, and affords another opportunity to make the program more robust.)</i></blockquote>
<p>
Once the statement in Listing 5 has finished execution, the program has 
identified the number and the types of files that can be written by the system.&nbsp; 
That information is contained in the array object referred to by the reference 
variable named <b>fileTypes</b>.&nbsp; We will make use of this information at 
several points later in the program.<p>
<font color="#FF0000"><b>Create and array of JRadioButton objects</b></font><p>
Now we know <i>(or can easily determine)</i> how many radio buttons we need.&nbsp; We need one radio button for 
each element in the array of supported file types.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    radioBtnArray = <b>new JRadioButton[
                               fileTypes.length];</b>
    
    <b>for</b>(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      String strType = <b>fileTypes[cnt].toString()</b>;
      if(cnt == 0){
        radioBtnArray[cnt] = <b>new JRadioButton(
                                   strType,true);</b>
      }else{
        radioBtnArray[cnt] = <b>new JRadioButton(
                                        strType);</b>
      }//end else
      radioBtnArray[cnt].<b>setActionCommand(
                                        strType)</b>;
    }//end for loop
<b><font face="Courier New,Courier">
Listing 6</font></b></pre>
</td>
</tr>
</table>

<p>
The code in Listing 6:<ul>
  <li>Instantiates a new array object of type <b>
JRadioButton</b>.</li>
  <li>Assigns the object's reference to the instance variable named <b>
  radioBtnArray</b> <i>(see Listing 2).</i></li>
  <li>Populates each element in the array with a reference to a 
new <b>JRadioButton</b> object.</li>
  </ul>
  <p>
<font color="#FF0000"><b>Populate the array</b></font><p>
A <b>for</b> loop is used in Listing 6 to populate each of the elements in the 
array with a reference to a new <b>JRadioButton</b> object.&nbsp; There are some 
special requirements that apply to the radio buttons:<ul>
      <li>It must be possible for the user to identify the file type associated 
      with each radio button.</li>
      <li>It must be possible for the program to identify the file type 
      associated with a radio button that has been selected by the user.</li>
      </ul>

<p>
I accomplished both of these requirements using a <b>String</b> representation of the 
file type associated with each button.<p>
During each iteration of the <b>for</b> 
loop in Listing 6, a <b>String</b> representation of the file type stored in the 
corresponding element of the array of file types was created by invoking the <b>
toString</b> method on the file-type element.<p>
<font color="#FF0000"><b>User identification of the radio buttons</b></font><p>
The string returned by the <b>toString</b> method was passed to the constructor 
for the corresponding <b>JRadioButton</b> object.&nbsp; This produced a label 
next to the radio button, which provides the visual 
relationship between the button and the file type.<blockquote>
  <p>
<i>(Note also that the constructor used for the first radio button that was 
instantiated requires an incoming <b>boolean</b> parameter in addition to the <b>
String</b> parameter.&nbsp; This causes the first radio button to be in the 
&quot;selected&quot; state when the group of radio buttons first appears on the screen.&nbsp; 
See Figure 1.)</i></blockquote>
<p>
<font color="#FF0000"><b>Program identification of a selected button</b></font><p>
The <b>String</b> returned by the <b>toString</b> method was also passed to the <b>
setActionCommand</b> method of the new <b>JRadioButton</b> object in Listing 6.<p>
If you are familiar with JavaBeans component properties, you will recognize that 
this sets the value of the <b>actionCommand</b> property of the radio button to 
the specified <b>String</b> value.&nbsp; This value can later be retrieved by 
invoking the <b>getActionCommand</b> method on a reference to the model that 
represents a selected radio button <i>(more on this later).</i><p>
Assuming that the <b>String</b> value returned by the <b>toString</b> method is 
unique, this provides a methodology for uniquely identifying the button that was 
selected by the user.&nbsp; This is probably a safe assumption, since the <b>
String</b> value that is returned is intended to uniquely identify a specific 
audio file type.<p>
<font color="#FF0000"><b>Include the radio buttons in a group</b></font><p>
As explained in the earlier lesson, the radio buttons are caused to participate 
in a mutually-exclusive group by adding them to a <b>ButtonGroup</b> object.&nbsp; 
This is accomplished in Listing 7, which uses a <b>for</b> loop to add each 
radio button to the group.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    <b>for</b>(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      btnGroup.<b>add</b>(radioBtnArray[cnt]);
    }//end for loop

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Add the radio buttons to the JPanel object</b></font><p>
Also, as explained in the earlier lesson, simply adding the radio buttons to a
<b>ButtonGroup</b> object doesn't accomplish a physical grouping of the radio 
buttons on the screen.&nbsp; This is accomplished in Listing 8 by adding the 
radio buttons to a <b>JPanel</b> object.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    for(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      btnPanel.<b>add</b>(radioBtnArray[cnt]);
    }//end for loop

<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Finish the GUI and the constructor</b></font><p>
The code in Listings 5 through 8 was different from the code in the similar 
program discussed in the earlier lesson, due to upgrading the program to make it 
more robust.<p>
The code in Listing 9 is very similar to the code that was discussed in the 
earlier lesson, and won't be discussed further in this lesson.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    //Put the JPanel in the JFrame
    getContentPane().add(btnPanel);

    //Finish the GUI and make it visible
    getContentPane().setLayout(new FlowLayout());
    setTitle("Copyright 2003, R.G.Baldwin");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setSize(300,120);
    setVisible(true);
  }//end constructor

<b><font face="Courier New,Courier">Listing 9</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The captureAudio method</b></font><p>
The method named <b>captureAudio</b> is invoked by the event handler on the <b>
Capture</b> button <i>(see the boldface statement in Listing 4).</i>&nbsp; This method captures audio data from a microphone and 
causes that data to be saved in an audio file.&nbsp; The version of the <b>
captureAudio</b> method used in this lesson is very similar to the version used 
in the corresponding program in the earlier lesson.&nbsp; Therefore, I will 
discuss this method only briefly in this lesson.<p>
An abbreviated version of the <b>captureAudio</b> method is shown in Listing 10.<blockquote>
    <p>
<i>(Note that much of 
the code has been deleted from Listing 10 for brevity.&nbsp; The entire method 
can be viewed in Listing 14 near the end of the lesson.)</i></blockquote>
  <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  private void <b>captureAudio</b>(){
    try{
      //Code deleted for brevity.

      <b>new CaptureThread().start();</b>
    
      //Code deleted for brevity
    }//end catch
  }//end captureAudio method

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>Spawn a thread to do the actual work</b></font><p>
The code in Listing 10 spawns a new <b>Thread</b> object and starts it running.&nbsp; 
The <b>run</b> method of the <b>Thread</b> object actually does the work to 
capture audio data from a microphone and 
to write that data into an audio file.&nbsp; The thread's <b>run</b> method will 
continue running and capturing audio data until the <b>Stop</b> button is 
clicked by the user <i>(see Figure 1).</i><p>
<font color="#FF0000"><b>Spawning a thread is very important</b></font><p>
When writing event-driven programs in Java, if an event handler is going to 
require any significant amount of time to complete, that handler should spawn a 
thread to do the work of responding to the event, and then return as quickly as 
possible.&nbsp; This makes it possible for the system to respond to other events 
that may occur on the event-handling thread.<p>
The <b>captureAudio</b> method returns control to the event handler on the <b>
Capture</b> button immediately after starting the thread.&nbsp; The event 
handler on the <b>Capture</b> button terminates and returns very quickly thereafter, making 
it possible for the event-handling thread to respond when the <b>Stop</b> button 
is clicked by the user.<p>
<font color="#FF0000"><b>The CaptureThread class</b></font><p>
The <b>Thread</b> object used to actually capture the audio data from the 
microphone and store it in an audio file is instantiated from the class named <b>
CaptureThread</b>.&nbsp; The definition of the <b>CaptureThread</b> class and 
its <b>run</b> method begins in Listing 11.&nbsp; Portions of this class are 
significantly different from the similar but less-robust version discussed in 
the earlier lesson.&nbsp; I will discuss those portions that are different in 
detail.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>CaptureThread</b> extends Thread{
  public void <b>run</b>(){
    AudioFileFormat.Type <b>fileType</b> = null;
    File <b>audioFile</b> = null;

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The run method</b></font><p>
The <b>run</b> method in this version begins just like the earlier version, by 
declaring two local variables and initializing their values to null.<p>
The first local variable, named <b>fileType</b>, will be used later to hold a 
reference to the selected file type as <b>AudioFileFormat.Type</b>.<p>
The second local variable, named <b>audioFile</b>, will be used later to hold 
a reference to a <b>File</b> object that represents the physical audio file.<p>
<font color="#FF0000"><b>Get the selected file type</b></font><p>
The code in Listing 12 is significantly different from the code in the similar 
program in the earlier lesson.<p>
In operation, the user selects a radio button <i>(see Figure 1)</i> from a group 
of radio buttons to specify the type of the audio file.&nbsp; The code in 
Listing 12 gets the selected file type identified as a <b>String</b>.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    String strType = <b>btnGroup.getSelection().
                              getActionCommand()</b>;

<b><font face="Courier New,Courier">Listing 12</font></b></pre>
</td>
</tr>
</table>

<p>
<font color="#FF0000"><b>The getSelection method</b></font><p>
Recall that all of the radio buttons belong to a <b>ButtonGroup</b> object.&nbsp; 
That object's reference is held in a reference variable named <b>btnGroup</b>.<p>
The code in Listing 12 begins by invoking the <b>getSelection</b> method on the 
reference to the <b>ButtonGroup</b> object.&nbsp; According to Sun, this method
<i>&quot;Returns the model of the selected button&quot;</i> as type <b>ButtonModel</b>.<p>
<font color="#FF0000"><b>What is a ButtonModel?</b></font><p>
Swing components, such as <b>JRadioButton</b>, are created using a modified <i>
model-view-control</i> paradigm.&nbsp; Briefly, the code behind each component 
consists of a model and a view <i>(which contains a built-in control).</i><blockquote>

<p>
<i>(If you want to know more about the general model-view-control paradigm, see 
the lessons on that topic on my <a href="http://www.dickbaldwin.com">web site</a>.)</i></blockquote>

<p>
The model contains the information that describes the component, while the view 
is responsible for rendering the component according to the information stored 
in the model.<p>
<font color="#FF0000"><b>What does Sun have to say?</b></font><p>
Here is part of what Sun has to say about the <b>ButtonModel</b> class.<blockquote>

<p>
<i>&quot;State Model for buttons. This model is used for check boxes and radio 
buttons, which are special kinds of buttons, as well as for normal buttons. For 
check boxes and radio buttons, pressing the mouse selects the button... In use, 
a UI will invoke setSelected(boolean) when a mouse click occurs 
over a check box or radio button. ...&quot;</i></blockquote>

<p>
Hopefully, Sun's description, when combined with my earlier explanation, will 
help you to understand the concept of a <i>model.</i><p>
<font color="#FF0000"><b>The getActionCommand method</b></font><p>
My objective is to first identify the selected radio button, and then to 
identify the audio file type associated with that button.&nbsp; The <b>
getSelection</b> method discussed above returns a reference to the model that 
represents the selected radio button.<p>
Once I have identified the model belonging to the selected radio button, I can 
invoke the <b>getActionCommand</b> method on that model to get the value of the <b>
actionCommand</b> property.<p>
In Listing 6 discussed earlier, I set the <b>actionCommand</b> property 
belonging to each radio button to a value that identifies the file type 
represented by that button.&nbsp; The code in Listing 12 retrieves that value 
and saves it in the <b>String</b> variable named <b>strType.</b><p>
<font color="#FF0000"><b>Set the file type and extension</b></font><p>
Next, I need to set the file type and file extension based on the selected 
radio button.&nbsp; The code in Listing 13 tests the  specified file type 
against the five common audio file types supported by the Java SDK version 1.4.1.&nbsp; 
If a match is found, the file type and extension is set accordingly.&nbsp; If a 
match is not found, the file type and extension is set to the default file type 
AU.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    <b>if(strType.equals("AIFC")</b>){
      fileType = <b>AudioFileFormat.Type.AIFC</b>;
      audioFile = <b>new File("junk." + 
                        fileType.getExtension()</b>);
    }else if(strType.equals("AIFF")){
      fileType = AudioFileFormat.Type.AIFF;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("AU")){
      fileType = AudioFileFormat.Type.AU;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("SND")){
      fileType = AudioFileFormat.Type.SND;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("WAVE")){
      fileType = AudioFileFormat.Type.WAVE;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else{
      System.out.println(
         "<b>File type not recognized by program.</b>");
      System.out.println(
                     "<b>Creating default type AU</b>");
      fileType = <b>AudioFileFormat.Type.AU</b>;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }//end else

<b><font face="Courier New,Courier">Listing 13</font></b></pre>
</td>
</tr>
</table>

<p>
Although the code in Listing 13 is long, it is  repetitive and relatively 
straightforward.<p>
The code in Listing 13 consists of a series of <b>if-else</b> statements.&nbsp; 
If the <b>String</b> representation of the file type <b>equals</b> the literal
<b>String</b> in the conditional clause of an <b>if</b> statement:<ul>
  <li>The file type is set to a matching type using a constant provided by the
  <b>AudioFileFormat.Type</b> class.</li>
  <li>A new <b>File</b> object is created that specifies the name and extension 
  of the audio file as explained below.</li>
  </ul>
  <p>
<font color="#FF0000"><b>The name of the file</b></font><p>
The name and extension of the audio file are created using <b>String</b> 
concatenation.&nbsp; The name of the audio file is the literal string&nbsp; <b>
&quot;junk&quot;</b>.<blockquote>
    <p>
<i>(Obviously you could add a text field to the GUI in Figure 1, and use the 
contents of the text field as the file name in place of<b> junk </b>if you so choose.)</i></blockquote>
  <p>
<font color="#FF0000"><b>The file extension</b></font><p>
The file extension is created by invoking the <b>getExtension</b> method on the
<b>AudioFileFormat.Type</b> object created in the previous statement.<p>
The <b>getExtension</b> method returns a reference to a <b>String</b> object 
that encapsulates the extension.&nbsp; The <b>String</b> returned by the <b>
getExtension</b> method is concatenated onto the literal string <b>&quot;junk&quot;</b> to 
form the entire file name and extension. <p>
Here is what Sun has to say about the <b>getExtension</b> method.<blockquote>
    <p>
<i>&quot;Obtains the common file name extension for this file type.&quot;</i></blockquote>
  <p>
<font color="#FF0000"><b>The default case</b></font><p>
In the event that the <b>String</b> representation of the file type fails to 
match any of the five common types, the final <b>else</b> clause is executed.&nbsp; 
The code in this clause displays a message on the screen notifying the user that 
the default type <b>AU</b> will be created, and then proceeds to do just that.<blockquote>
    <p>
<i>(This could happen if the <b>getAudioFileTypes</b> method of the <b>
AudioSystem</b> class were to return a supported file type that is not one of 
the five common file types supported by the Java SDK version 1.4.1.&nbsp; For 
example, this could happen with a later version of the SDK if Sun decides to 
support additional file types.&nbsp; Unfortunately, in that case, this program 
would have to be modified to make it able to write the new file types.&nbsp; 
With a little additional thought, it should be possible to rewrite this program 
to make it handle that eventuality as well.&nbsp; It seems there are enumerable 
opportunities to make a program more robust.)</i></blockquote>
  <p>
<font color="#FF0000"><b>The remaining code</b></font><p>
The remaining code in the <b>Thread</b> class is very similar to that discussed 
in the program in the earlier lesson.&nbsp; Therefore, I won't discuss this code 
further in this lesson.<p>
Similarly, the method named <b>getAudioFormat</b> is identical to that used in 
the program in the earlier lesson, so I won't discuss it here.<p>
<font color="#FF0000"><b>Possible audio format compatibility problems</b></font><p>
As mentioned earlier, a complete listing of this program is provided in Listing 14 near the end of the 
lesson.&nbsp; If this program fails to run on your machine due to an audio 
format compatibility problem, you should examine the comments in the <b>
getAudioFormat</b> method and try modifying the program to use a different audio 
format.&nbsp; I have been advised by some readers of the previous lessons that 
the audio format returned by the <b>getAudioFormat</b> method doesn't work well 
on all systems.<blockquote>
    <p>
<i>(Obviously, this is another area where the program could be made more robust 
by making certain that the program uses an audio format that is supported on the 
system.)</i></blockquote>
  <center>
<h2>
<a NAME="Run the program"></a>Run the Program</h2></center>
        <p>
      At this point, you may find it useful to compile and run the program shown 
      in Listing 14 near the end of the lesson.&nbsp; Operating instructions 
      were provided earlier in the section entitled <b>Basic operation</b>.<p>
If you use a media player, such as the Windows Media Player, to play back your 
file, be sure to release the old file from the media player before attempting to create a new file with the same 
name and extension.&nbsp; Otherwise, the program will not be able to create the 
new file, and a runtime error will occur.<h2 align="center"><a name="Summary">Summary</a></h2>
  <p>In this lesson, I showed you how to use the <b>getAudioFileTypes</b> method 
  of the <b>AudioSystem</b> class to limit the file-type choices presented to 
  the user, thus eliminating the possibility that the user will select an output 
  file type that is not supported by the system.&nbsp; Hopefully, this example will 
  suggest how you can use other methods of the <b>AudioSystem</b> class to deal 
  with other issues involving the need for improved robustness in your code.</p>
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
        A complete listing of the program is shown in Listing 14.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File AudioRecorder03.java
Copyright 2003, Richard G. Baldwin

This is an update of the program named
AudioRecorder02.  This version demonstrates how
to limit the file type choices to those that are
supported by the system.

This program demonstrates the capture of audio
data from a microphone into an audio file.

A GUI appears on the screen containing the
following buttons:
  Capture
  Stop

In addition, up to five radio buttons appear on
the screen allowing the user to select one of the
following five audio output file formats:

  AIFC
  AIFF
  AU
  SND
  WAVE

Only those file formats supported by the system
are presented to the user.  Therefore, only those
file formats supported by the system can be
selected.

When the user clicks the Capture button, input
data from a microphone is captured and saved in
an audio file named junk.xx having the specified
file format.  (xx is the file extension for the
specified file format.  You can easily change the
file name to something other than junk if you
choose to do so.)

Data capture stops and the output file is closed
when the user clicks the Stop button.

It should be possible to play the audio file
using any of a variety of readily available
media players, such as the Windows Media Player.

Be sure to release the old file from the media
player before attempting to create a new file
with the same extension.  Otherwise, a runtime
error will occur when the program attempts to
create the new file.

Tested using SDK 1.4.1 under Win2000
************************************************/

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.sound.sampled.*;

public class AudioRecorder03 extends JFrame{

  AudioFormat audioFormat;
  TargetDataLine targetDataLine;

  final JButton captureBtn =
                          new JButton("Capture");
  final JButton stopBtn = new JButton("Stop");

  final JPanel btnPanel = new JPanel();
  final ButtonGroup btnGroup = new ButtonGroup();
  JRadioButton[] radioBtnArray;
  AudioFileFormat.Type[] fileTypes;
  
  public static void main( String args[]){
    new AudioRecorder03();
  }//end main

  public AudioRecorder03(){//constructor
    captureBtn.setEnabled(true);
    stopBtn.setEnabled(false);

    //Register anonymous listeners
    captureBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(false);
          stopBtn.setEnabled(true);
          //Capture input data from the
          // microphone until the Stop button is
          // clicked.
          captureAudio();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()

    stopBtn.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          captureBtn.setEnabled(true);
          stopBtn.setEnabled(false);
          //Terminate the capturing of input data
          // from the microphone.
          targetDataLine.stop();
          targetDataLine.close();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener()

    //Put the buttons in the JFrame
    getContentPane().add(captureBtn);
    getContentPane().add(stopBtn);
    
    //Get the file types for which file writing
    // support is provided by the system.
    fileTypes = AudioSystem.getAudioFileTypes();
       
    //Create an array of radio buttons
    radioBtnArray = new JRadioButton[
                               fileTypes.length];
    
    for(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      String strType = fileTypes[cnt].toString();
      if(cnt == 0){
        radioBtnArray[cnt] = new JRadioButton(
                                   strType,true);
      }else{
        radioBtnArray[cnt] = new JRadioButton(
                                        strType);
      }//end else
      radioBtnArray[cnt].setActionCommand(
                                        strType);
    }//end for loop

    //Include the radio buttons in a group
    for(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      btnGroup.add(radioBtnArray[cnt]);
    }//end for loop

    //Add the radio buttons to the JPanel
    for(int cnt = 0; cnt < fileTypes.length; 
                                          cnt++){
      btnPanel.add(radioBtnArray[cnt]);
    }//end for loop

    //Put the JPanel in the JFrame
    getContentPane().add(btnPanel);

    //Finish the GUI and make it visible
    getContentPane().setLayout(new FlowLayout());
    setTitle("Copyright 2003, R.G.Baldwin");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setSize(300,120);
    setVisible(true);
  }//end constructor

  //This method captures audio input from a
  // microphone and saves it in an audio file.
  private void captureAudio(){
    try{
      //Get things set up for capture
      audioFormat = getAudioFormat();
      DataLine.Info dataLineInfo =
                          new DataLine.Info(
                            TargetDataLine.class,
                            audioFormat);
      targetDataLine = (TargetDataLine)
               AudioSystem.getLine(dataLineInfo);

      //Create a thread to capture the microphone
      // data into an audio file and start the
      // thread running.  It will run until the
      // Stop button is clicked.  This method
      // will return after starting the thread.
      new CaptureThread().start();
    }catch (Exception e) {
      e.printStackTrace();
      System.exit(0);
    }//end catch
  }//end captureAudio method

  //This method creates and returns an
  // AudioFormat object for a given set of format
  // parameters.  If these parameters don't work
  // well for you, try some of the other
  // allowable parameter values, which are shown
  // in comments following the declarations.
  private AudioFormat getAudioFormat(){
    float sampleRate = 8000.0F;
    //8000,11025,16000,22050,44100
    int sampleSizeInBits = 16;
    //8,16
    int channels = 1;
    //1,2
    boolean signed = true;
    //true,false
    boolean bigEndian = false;
    //true,false
    return new AudioFormat(sampleRate,
                           sampleSizeInBits,
                           channels,
                           signed,
                           bigEndian);
  }//end getAudioFormat
//=============================================//

//Inner class to capture data from microphone
// and write it to an output audio file.
class CaptureThread extends Thread{
  public void run(){
    AudioFileFormat.Type fileType = null;
    File audioFile = null;

    //Get the selected file type described as 
    // a String
    String strType = btnGroup.getSelection().
                              getActionCommand();
    //Set the file type and the file extension
    // based on the selected radio button.  Test
    // for the common audio file types supported
    // by Java SDK version 1.4.1.  If the type
    // doesn't match one of the common types,
    // create a file of the default type AU.
    if(strType.equals("AIFC")){
      fileType = AudioFileFormat.Type.AIFC;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("AIFF")){
      fileType = AudioFileFormat.Type.AIFF;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("AU")){
      fileType = AudioFileFormat.Type.AU;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("SND")){
      fileType = AudioFileFormat.Type.SND;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else if(strType.equals("WAVE")){
      fileType = AudioFileFormat.Type.WAVE;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }else{
      System.out.println(
         "File type not recognized by program.");
      System.out.println(
                     "Creating default type AU");
      fileType = AudioFileFormat.Type.AU;
      audioFile = new File("junk." + 
                        fileType.getExtension());
    }//end else

    try{
      targetDataLine.open(audioFormat);
      targetDataLine.start();
      AudioSystem.write(
            new AudioInputStream(targetDataLine),
            fileType,
            audioFile);
    }catch (Exception e){
      e.printStackTrace();
    }//end catch

  }//end run
}//end inner class CaptureThread
//=============================================//

}//end outer class AudioRecorder03.java

<b><font face="Courier New,Courier">Listing 14</font></b></pre>
</td>
</tr>
</table>

   <hr size=3 width="100%" align=center>
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. <h4>
<a NAME="About the author"></a>About the author</h4>
<i><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a> is a college professor (at Austin Community College in Austin, TX) and private consultant whose primary focus is a combination of Java, C#, and XML. In addition to the many platform and/or language independent benefits of Java and C# applications, he believes that a combination of Java, C#, and XML will become the primary driving force in the delivery of structured information on the Web.</i><br><p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a href="http://www.DickBaldwin.com">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring programmers.
He has also published articles in JavaPro magazine.</i> <p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i> <p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i> <p>-end- </body></html>