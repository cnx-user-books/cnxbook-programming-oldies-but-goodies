<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Java JAXP, Creating graphics using Java and SVG</h2>
<i>Part 1 of a two-part series designed to teach you how to write servlets to 
produce SVG code that will be rendered in graphic form by an SVG-compatible 
browser.&nbsp; Learn how write your own SVG graphics library to eliminate or at 
least alleviate the requirement to write raw XML code or raw JAXP DOM code, 
making it possible for you to produce SVG output simply by making Java method 
calls.</i><p><b>Published:</b>&nbsp; January 30, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2212</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_Svg01_program">The Svg01 program</a></li>
		<li><a href="#The_Svg02_program">The Svg02 program</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>

<h3> <a name="General">General</a></h3>
<p>


This is the first lesson in a two-part series designed to teach you how to write 
servlets to produce SVG code that will be rendered in graphic form by an 
SVG-compatible browser.</p>
<p>


In this lesson, you will learn how write an SVG graphics library to eliminate or 
at least alleviate the requirement to write raw XML code or raw JAXP DOM code.&nbsp; 
This tutorial will introduce you to the beginnings of an SVG graphics library 
that makes it possible for you to produce SVG output simply by making Java 
method calls.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.&nbsp; You may also find it useful 
to open a third browser window at the <a href="#Resources">Resources</a> section near the end of the 
document.&nbsp; That will make it easy for you to open those resources when they 
are mentioned in the text.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. The basic image.</li>
	<li><a href="#Figure_2">Figure 2</a>. Image with horizontally compressed 
	gradient.</li>
	<li><a href="#Figure_3">Figure 3</a>. A cropped version of Figure 1.</li>
	<li><a href="#Figure_4">Figure 4</a>. Viewing the SVG/XML file in IE 6.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Abbreviated SVG/XML code for Figure 
	1.</li>
	<li><a href="#Listing_2">Listing 2</a>. Abbreviated defs element.</li>
	<li><a href="#Listing_3">Listing 3</a>. One complete linearGradient element.</li>
	<li><a href="#Listing_4">Listing 4</a>. Another complete linearGradient 
	element.</li>
	<li><a href="#Listing_5">Listing 5</a>. The ellipse and circle elements.</li>
	<li><a href="#Listing_6">Listing 6</a>. The complete contents of the SVG/XML 
	file.</li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the class for Svg01.</li>
	<li><a href="#Listing_8">Listing 8</a>. Create root node named svg.</li>
	<li><a href="#Listing_9">Listing 9</a>. Create the defs node.</li>
	<li><a href="#Listing_10">Listing 10</a>. Create a linearGradient node.</li>
	<li><a href="#Listing_11">Listing 11</a>. Create the first stop node.</li>
	<li><a href="#Listing_12">Listing 12</a>. Create the second stop node.</li>
	<li><a href="#Listing_13">Listing 13</a>. Create and populate the other 
	linearGradient node.</li>
	<li><a href="#Listing_14">Listing 14</a>. Create the g node, the ellipse 
	node, and the circle node.</li>
	<li><a href="#Listing_15">Listing 15</a>. The remaining program code.</li>
	<li><a href="#Listing_16">Listing 16</a>. Beginning of the Svg02 class.</li>
	<li><a href="#Listing_17">Listing 17</a>. Create the root node named svg.</li>
	<li><a href="#Listing_18">Listing 18</a>. Create the node named defs.</li>
	<li><a href="#Listing_19">Listing 19</a>. Create the first linearGradient 
	node.</li>
	<li><a href="#Listing_20">Listing 20</a>. Create the second linearGradient 
	node.</li>
	<li><a href="#Listing_21">Listing 21</a>. Create the g node.</li>
	<li><a href="#Listing_22">Listing 22</a>. Create the ellipse node.</li>
	<li><a href="#Listing_23">Listing 23</a>. Create a circle node.</li>
	<li><a href="#Listing_24">Listing 24</a>. Transform the DOM and write the 
	output file.</li>
	<li><a href="#Listing_25">Listing 25</a>. Output XML file produced by both 
	programs.</li>
	<li><a href="#Listing_26">Listing 26</a>. Java code for program Svg01.</li>
	<li><a href="#Listing_27">Listing 27</a>. Java code for program Svg02.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The Java 2D API</b><br />
  According to Sun, &quot;The Java 2D API is a set of classes for advanced 2D graphics and imaging, 
	encompassing line art, text, and images in a single comprehensive model. The 
	API provides extensive support for image compositing and alpha channel 
	images, a set of classes to provide accurate color space definition and 
	conversion, and a rich set of display-oriented imaging operators.&quot;</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Desktop applications</b></font></p>
<p>


When we write desktop applications using Java, we have access to Sun's Java 
2D API <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; We can easily use 
the API to provide rich graphical output for the benefit of the user.</p>
<p>


<font color="#FF0000"><b>Servlets</b></font></p>
<p>


However, if we are writing servlets instead of desktop applications, it isn't obvious that the Java 2D API is directly useful.&nbsp; How 
can we provide the same level of rich graphical output that is possible with 
desktop applications?</p>
<p>


I suppose that one possibility would be to cause the servlet to produce an 
output that causes the web client to download and execute an applet.&nbsp; 
Although I have never done so, it seems that an approach like that would make 
the Java 2D API available to the servlet/applet programmer.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Walter Zorn's JavaScript library</b><br />
  According to Walter Zorn, &quot;This JavaScript VectorGraphics library provides 
	graphics capabilities for JavaScript: functions to draw circles, ellipses 
	(ovals), oblique lines, polylines and polygons (for instance triangles, 
	rectangles) dynamically into a webpage.&quot;
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Zorn's JavaScript library</b></font><p>Another possibility might be to cause the servlet to produce an output 
consisting of JavaScript code that makes use of Walter Zorn's JavaScript 
graphics library <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; That 
might not be a bad idea, except that as of this writing, the capabilities of 
Zorn's graphics library fall far short of the capabilities of the Java 2D API.</p>
<p>On the other hand, since the code produced by the use of the library is 
simply JavaScript code, the output should be compatible with most, if not all 
browsers that are in common use as of the time of this writing.&nbsp; I will 
have more to say about the use of Zorn's library in a future tutorial on 
producing graphic output with the Google Web Toolkit <i>(GWT)</i>.</p>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Scalable Vector Graphics (SVG)</b><br />
  According to the W3C, &quot;SVG is a language for describing two-dimensional 
	graphics in XML. SVG allows for three types of graphic objects: vector 
	graphic shapes (e.g., paths consisting of straight lines and curves), images 
	and text. Graphical objects can be grouped, styled, transformed and 
	composited into previously rendered objects. The feature set includes nested 
	transformations, clipping paths, alpha masks, filter effects and template 
	objects.&quot;
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Scalable Vector Graphics</b></font><p>Another approach is to use Scalable Vector Graphics <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; Scalable Vector Graphics, <i>(or SVG 
as it is more commonly known)</i>, is a W3C recommendation for the use of a 
special dialect of XML for the production of graphical output.</p>
<p>As the title of this tutorial suggests, the use of SVG with Java is the main topic of this tutorial.&nbsp; In this 
and Part 2 of this tutorial, I will teach you how to write servlets to produce SVG code 
that will be rendered in graphic form by an SVG-compatible browser.</p>
<p>The capabilities of SVG are extensive, and don't have to take a backseat to the Java 2D API. </p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>SVG and Internet Explorer</b><br />
  As of the date of this writing, IE 7 has been released for a couple of months, 
	but I haven't installed it yet.&nbsp; I don't know if it has support for SVG 
	built in, or if the Adobe plug-in will cause it to support SVG. From the rumors that I read in the blogs, direct support of SVG is not in 
Microsoft's plans for IE 7.<p>All of the 
	examples in this tutorial were produced using Firefox 1.5.0.8.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>SVG browser compatibility</b></font><p>There are some 
downsides to SVG.&nbsp; Unfortunately, not all browsers currently support SVG, and those that do 
don't necessarily support it fully.&nbsp; </p>
<p>Firefox 1.5 and later 
versions of Firefox support a subset of SVG.</p>
<p>IE 6 doesn't support SVG directly, but 
there is a plug-in available from Adobe <i>(see
<a href="#Resources">Resources</a>)</i> that reportedly makes it possible to 
render SVG in IE 6.&nbsp; <i>(Since I don't make much use of IE, I have never 
installed the SVG plug-in.)</i>&nbsp; </p>
<p><font color="#FF0000"><b>Requires XML code</b></font></p>
<p> Another downside to the use of SVG for many programmers is the requirement 
to produce XML code in a special dialect that describes the graphic image.&nbsp; 
One way to accomplish this is to simply code the raw XML code into output 
statements so that it will be written into the output.&nbsp; This is difficult even for persons with 
considerable expertise in XML, SVG, and Java programming if for no reason other 
than the requirement to use escape sequences for numerous quotation marks that 
are required in the raw XML code.</p>
<p> A somewhat 
easier way, but one that is still not ideal, is to write JAXP DOM code to 
describe the desired graphics image in a DOM tree, and then to use JAXP to transform the 
DOM tree into the required raw XML code.&nbsp; Using JAXP DOM code to produce a 
DOM tree that represents a complex graphic can be a laborious task.</p>
<p> One of the purposes of this tutorial is to show you how you can write your 
own SVG graphics library to eliminate <i>(or at least alleviate)</i> the requirement to 
write raw XML code or raw JAXP DOM code.&nbsp; This 
tutorial will introduce you to the beginnings of an SVG graphics library that 
makes it possible to produce SVG output code simply by making typical Java method calls.</p>
<p> <font color="#FF0000"><b>Breakdown between parts of the tutorial</b></font></p>
<p> I will present and explain two sample programs in this lesson 
followed by two additional sample programs in part 2.</p>
<p> The first sample program that I will explain in this lesson will:</p>
<ul>
	<li>Create a DOM tree describing a specific graphic image in SVG format</li>
	<li>Transform the DOM tree into raw XML code</li>
	<li>Write the raw XML code into an XML 
file <i>(otherwise known as an SVG file)</i> with an extension of svg</li>
</ul>
<p> The graphic image can be rendered 
by manually loading the SVG file into Firefox 1.5.</p>
<p> <font color="#FF0000"><b>Lots of tedious programming is required</b></font></p>
<p> As you will see, even for a simple graphics image, this program requires 
the programmer to write many statements consisting of raw JAXP DOM code, which 
is later transformed into raw XML code.&nbsp; That is definitely not a fun way 
to spend your summer vacation.</p>
<p> <font color="#FF0000"><b>An SVG graphics library</b></font></p>
<p> The second sample program that I will explain in this lesson moves 
most of the difficult and tedious code into a small SVG graphics library 
class.&nbsp; This makes it possible for the application programmer to concentrate on the use of the 
methods in the graphics library rather than having to concentrate on the nitty-gritty details 
of SVG and JAXP DOM code.&nbsp; </p>
<p> The SVG graphics library that I will present and explain is far from complete.&nbsp; 
However, it will 
serve as a proof of concept and will show you a methodology for writing your own SVG 
graphics library.</p>
<p> <font color="#FF0000"><b>A requirement for XHTML files</b></font></p>
<p> While you can use Firefox 1.5 to render SVG code that is contained in an SVG file 
simply by manually loading the SVG file into the browser, as near as I can determine, in order to 
cause Firefox to render SVG code that is downloaded from a web site, the SVG code 
must be presented in the form of an XHTML file.</p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Not a valid XHTML file</b><br />
  Note that the actual file that will be produced is not a valid XHTML file 
	because the SVG elements are not allowed in a valid XHTML file.&nbsp; At 
	least, that is the result indicated by attempting to validate the file at
<a href="http://validator.w3.org/file-upload.html">
http://validator.w3.org/file-upload.html</a>.</td></tr></table>
</td>
</tr>
</table>

One of the programs that I will explain in part 2 of this tutorial will 
create a DOM tree describing the SVG code for a particular graphic image and 
then transform it into SVG code that is wrapped in a file that would otherwise 
be a valid XHTML file.<p> <font color="#FF0000"><b>A useful capability</b></font></p>
<p> The capability demonstrated by the program described above will be useful for the creation of 
static XHTML files containing SVG graphics that you may want to post on your web 
site for downloading by your clients.</p>
<p> The program will also be useful as a precursor to creating inline SVG code in a servlet and to cause that SVG code to be rendered in a 
Firefox browser
that accesses the servlet.&nbsp; That will be the purpose of a servlet program 
that I will also present and explain in part 2 of this tutorial.</p>
<p> <b><font color="#FF0000">What about internal references to SVG files?</font></b></p>
<p> A third option is to create an SVG file stored on a web server and then to 
reference that file for downloading from within an XHTML file.&nbsp; Presumably, 
the SVG file could be a static file, or could be a temporary file that is 
created dynamically by a servlet immediately before the XHTML code is sent from 
the servlet to the client.</p>
<p> So far, I have been unable to get this to work, but my problems seem to have 
more to do with server administration issues than with Java code, SVG code, or 
XML code.&nbsp; Maybe I will get those issues resolved and can show you how to 
do that in part 3 of this tutorial, <i>(which is not currently on my list of 
things to do)</i>.</p>
<p> <font color="#FF0000"><b>The basic image</b></font></p>
<p> Figure 1 shows the basic image that I will be working with in this tutorial.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. The basic image. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2212a01.jpg" width="253" height="353"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This image consists of an ellipse with a blue border.&nbsp; The thickness of 
the border is two pixels.&nbsp; A circle without a border is placed inside the 
ellipse.</p>
<p>The fill color for the ellipse is a color gradient that goes from yellow on 
the left to red on the right.&nbsp; The fill color for the circle is a color 
gradient that goes from green on the left to blue on the right.&nbsp; In both 
cases, the starting and ending points for the gradient are at the left and right 
edges of the graphic object being filled.</p>
<p><font color="#FF0000"><b>Horizontally compressed color gradient</b></font></p>
<p>Figure 2 shows a somewhat different take on the same basic image.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Image with horizontally compressed 
	gradient. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2212a02.jpg" width="254" height="354"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Figure 2 shows the same image as Figure 1, except that in Figure 2, the 
gradient begins twenty-five percent of the way across the ellipse going from 
left to right and ends seventy-five percent of the way across.&nbsp; Thus, the 
left one-fourth of the ellipse is solid yellow and the right one-fourth is solid 
red.&nbsp; The color gradient progresses from yellow to red between these two 
points.</p>
<p><font color="#FF0000"><b>Won't use this image</b></font></p>
<p>Other than to show you that this is possible using SVG color gradients, I 
won't be using the version of the image shown in Figure 2 in this tutorial.&nbsp; 
However, at an appropriate point, I will explain the code changes that were required 
to produce the image shown in Figure 2.</p>
<p>When I get into the use of XHTML files in part 2 of this 
tutorial, I will also add a containing box and some text to the image shown in 
Figure 1.</p>
<p> <font color="#FF0000"><b>Why bother?</b></font></p>
<p> At this point, you may be wondering why anyone would bother with SVG image 
files when they could be using more conventional bitmap image files such as JPEG 
files and GIF files.&nbsp; There are at least two good reasons why it may be 
attractive to use SVG in place of bitmaps:</p>
<ul>
	<li>Scalability</li>
	<li>Bandwidth</li>
</ul>
<p> <font color="#FF0000"><b>Scalability</b></font></p>
<p> Once an image has been committed to a bitmapped image format such as GIF or 
JPEG, the ability to scale the image to make it larger is greatly impaired.&nbsp; 
In particular, if you were to attempt to enlarge the typical bitmapped icons 
that you see on your computer's desktop, you would see that they become very 
grainy when enlarged.&nbsp; While it may be possible to do some sort of 
interpolation to decrease the graininess, bitmapped images were never intended 
to be enlarged and attempts to enlarge bitmapped images always seem to be 
marginal at best.</p>
<p> On the other hand, SVG files are designed to be displayed at any scale with 
little or no loss of quality.&nbsp; Hence the name <i>Scalable Vector Graphics</i>.</p>
<p> <font color="#FF0000"><b>Bandwidth</b></font></p>
<p> As an experiment, I cropped the JPEG image shown in Figure 1 down to the 
smallest rectangle that would contain the ellipse.&nbsp; The result is shown in 
Figure 3.&nbsp; <i>(As you can see, I actually cropped it a little too much and 
clipped off part of the border at the top.)</i>&nbsp; </p>
<p>
 <b><a name="Figure_3">Figure 3</a>. A cropped version of Figure 1. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java2212a03.jpg" width="204" height="81">
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>After cropping and saving the image, <i>(despite the fact that JPEG uses a 
lossy compression algorithm that degrades the quality of the image)</i>, the size of the JPEG file shown in 
Figure 3 was still 3,534 bytes.&nbsp; The SVG file required to produce the 
image, on the other hand, was only 604 bytes.&nbsp; Therefore, for this example, 
the bandwidth required to download or otherwise transmit the JPEG image file was 
more than six times greater than the bandwidth required to download the SVG 
file.&nbsp; Add this to the fact that lossy JPEG compression degrades the 
quality of the image and bandwidth considerations also stand out as a good 
reason to use SVG coding instead of bitmapped images.</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#FF0000"><b>Java 2D API versus SVG</b></font></p>
<p>Programming to produce images using the Java 2D API is completely different 
from programming to produce images using the SVG.&nbsp; There are major 
differences in at least the following categories:</p>
<ul>
	<li>Specifications</li>
	<li>File format</li>
</ul>
<p><font color="#FF0000"><b>Java 2D API specifications</b></font></p>
<p>The &quot;Java 2D API Specification&quot; <i>(see <a href="#Resources">Resources</a>)</i> 
and its associated documentation constitutes a <i>&quot;How To&quot;</i> manual for writing 
programs that will produce certain graphic images on the computer 
screen when a Java program has been compiled and executed.&nbsp; For example, the documentation for the
<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/awt/geom/Ellipse2D.html">
Ellipse2D</a> class tells you everything that you need to know to instantiate 
and configure an object of the <b>Ellipse2D</b>&nbsp;class.&nbsp; The assumption is that you will instantiate and configure such as 
object as part of a larger overall program.&nbsp; Then when you compile and 
execute the program using the Java virtual machine, a visual rendering of the 
ellipse will appear on the screen.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>An SVG specification example</b><br />
  <a href="http://www.w3.org/TR/SVG/shapes.html#EllipseElement">Section 9.4 The 
'ellipse' element</a> tells you what must be contained in the XML data if 
you want that data to be capable of being rendered in such a way as to cause an 
ellipse to appear on the screen.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>The SVG specification</b></font></p>
<p>On the other hand, the &quot;Scalable Vector Graphics (SVG) 1.1 Specification&quot; <i>(see <a href="#Resources">Resources</a>)</i> 
is 
not a <i>&quot;How To&quot;</i> manual.&nbsp; Rather, it is something of a <i>&quot;What 
to Produce&quot;</i> 
manual.&nbsp; In other words, it doesn't tell you how to do anything.&nbsp; 
Instead, it tells you what you must produce in the way of XML data if you want 
to be able to use that data to cause certain graphic images to be displayed by 
an SVG-capable rendering engine.&nbsp; </p>
<p>


<font color="#FF0000"><b>Few if any assumptions</b></font><p>The SVG specifications make no assumptions as to the program that will be used to 
render the XML code into visual graphic images.&nbsp; Also, they make no 
assumptions regarding the display medium on which those images will be rendered. The 
display medium 
could be paper, it could be a computer screen or a PDA screen, or probably 
could even be a hologram.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Creating SVG/XML code</b><br />
  If you are a glutton for punishment, you can create the code manually using 
	a simple text editor.
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>No programming or rendering instructions</b></font></p>
<p>Furthermore, the 
SVG specifications don't tell you how to write the program that will be used to produce the 
required SVG/XML output.&nbsp; In fact, the specifications make 
no assumptions as to what programming environment will be used to write a program 
that can produce the required SVG/XML output.</p>
<p><font color="#FF0000"><b>What about the SVG rendering engine?</b></font></p>
<p>The SVG specifications provide no instructions regarding the use of a 
particular programming environment to write a program that will 
render the SVG/XML code into visual graphic images.&nbsp; Rather, the specifications assume that you can figure out on your own how to 
write the code to produce the required SVG/XML output, and that you have access to a program that can reliably render 
that code on your desired display medium.</p>
<p><font color="#FF0000"><b>The bottom line regarding SVG</b></font></p>
<p>The bottom line is that the SVG specifications simply tell you what must be 
contained in the SVG/XML data in order to cause an SVG-capable 
rendering engine to produce the expected graphic images on the required display 
medium.</p>
<p><font color="#FF0000"><b>File format</b></font></p>
<p>Now let's consider the differences in the file formats required to produce 
images for the two approaches.</p>
<p><font color="#FF0000"><b>Java files</b></font></p>
<p>If you write and compile a Java program that uses the Java 2D API to produce 
graphic output, the instructions for producing that output are integrated into 
the bytecode file(s) that are used by the virtual machine to control the overall 
behavior of the program.&nbsp; That behavior causes your images to be rendered 
on the computer screen <i>(or possibly on a printer, a PDA screen, a cell phone, 
etc.)</i>.&nbsp; Some of those bytecode files are produced by compiling the 
source code for your program.&nbsp; Other bytecode files are contained in the 
Java class libraries, having been placed there by the folks at Sun.</p>
<p><font color="#FF0000"><b>No single data file</b></font></p>
<p>The important point is that there is not a single identifiable data file that 
represents the image.&nbsp; Information representing the image is integrated 
into a lot of other information that determines the overall behavior of the 
program.&nbsp; There are probably very few people in the world that can examine 
the data in those files and make any sense out of it with regard to the graphic 
images that it will produce.</p>
<p><font color="#FF0000"><b>SVG files</b></font></p>
<p>SVG data files on the other hand are totally transparent.&nbsp; They are 
simply XML files, written in plain text according to the SVG specifications.&nbsp; 
They constitute a specific dialect of XML.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A human SVG rendering engine.</b><br />
  While it probably wouldn't be a lot of fun, a technical person with a 
	reasonable amount of drawing talent and a few drawing tools <i>(compass, straightedge, measuring 
scale, black and colored pencils, etc.)</i> could probably function as an SVG 
rendering engine and render the data in an SVG file onto paper.</td></tr></table>
</td>
</tr>
</table>

Anyone who can read the English language can read the contents of an SVG file.&nbsp; 
Persons with reasonable technical skills can then compare what they find there 
with the SVG specifications and pretty well determine what kind of graphic 
output will be produced when the file is rendered.&nbsp; </p>
<p>Thus, the contents of an SVG file consist primarily of the instructions necessary to 
tell a rendering engine how to draw the image.&nbsp; In fact, someone who 
understands the particular SVG dialect of XML could use a text editor to modify 
the SVG/XML data to cause the rendering engine to produce a totally different image from 
the one originally described by the SVG/XML data.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<p> As mentioned earlier, I will present and explain two sample programs in this 
lesson followed by two additional sample programs part 2 of this series.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>XML, DOM trees, JAXP, etc.</b><br />
  In case you are unfamiliar with XML, DOM trees, JAXP and such, I recommend 
	that you take advantage of the many tutorials that I have written on those 
	topics.&nbsp; You will find links to those tutorials in the
	<a href="#Resources">Resources</a> section near the end of this lesson.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Svg01</b></font><p>The first sample program named <b>Svg01</b> will create a DOM tree describing 
the graphic image shown in Figure 1 in SVG format.&nbsp; 
Then it will 
transform the DOM tree into raw XML code and write the raw XML code into an XML 
file <i>(otherwise known as an SVG file)</i> named <b>junk.svg</b><i>.</i>&nbsp; The graphic image can be rendered 
by manually loading the SVG file into Firefox 1.5.</p>
<p> As you will see, this first program requires quite a bit of difficult and 
tedious programming.</p>
<p> <font color="#FF0000"><b>Svg02</b></font></p>
<p> The second sample program named <b>Svg02</b> moves 
most of the difficult and tedious code into a small SVG 
graphics library of my own design.&nbsp; Having the graphics library available makes it possible for the application programmer to concentrate on the use of the 
methods in the library rather than having to concentrate on the nitty-gritty details 
of SVG, XML, or JAXP DOM coding.&nbsp; </p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Completing the graphics library</b><br />
  Perhaps one of the readers of this tutorial will pick up where I left off, 
	extend the graphics library to incorporate the complete SVG specification, 
	and publish it for the entire world to use for free.</td></tr></table>
</td>
</tr>
</table>

The SVG graphics library that I will present and explain is far from complete.&nbsp; 
However, it will serve as a proof of concept and will show you a methodology for 
writing your own SVG graphics library.</p>
<h3><a name="The_Svg01_program">The Svg01 program</a></h3>
<p>Before getting into the programming details, I want to present and briefly 
explain the contents of the SVG/XML file produced by the program.&nbsp; A 
listing of that code begins in Listing 1.</p>
<p>However, even before getting into that, I want to highlight a few good online 
resources on the topic.&nbsp; <i>(You will 
also find links to these resources in the <a href="#Resources">Resources</a> section 
so that you can easily find them later).</i>&nbsp; These resources may be useful in 
helping you to interpret the SVG specifications.</p>
<p>The article titled
<a href="https://www6.software.ibm.com/developerworks/education/x-svggraphics/index.html">
Create vector graphics in the browser with SVG</a> by Uche Ogbuji provides 
numerous examples showing graphic images along with the corresponding raw XML 
code.</p>
<p>The article titled <a href="http://www.w3schools.com/svg/default.asp">SVG 
Tutorial</a> is an excellent resource for understanding how the SVG 
specifications translate into XML code.</p>
<p>The article titled <a href="http://www.svgbasics.com/shapes.html">SVG 
Basics</a> is another good resource for helping you to associate raw XML code 
with the graphic images that are produced by a rendering engine on the basis of 
that code.</p>
<p><font color="#FF0000"><b>Abbreviated SVG/XML code for Figure 1</b></font></p>
<p>Now, getting back on topic, Listing 1 shows an abbreviated version of the raw XML code that was rendered 
in Firefox 1.5 to produce Figure 1.&nbsp; Much of the raw XML code was omitted 
from Listing 1 to make it easier to see the overall structure of the document.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Abbreviated SVG/XML code for Figure 1. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

<b>&lt;svg</b> height="100%" version="1.1" width="100%" 
  xmlns="http://www.w3.org/2000/svg"&gt;

  &lt;defs&gt;
    ...
  &lt;/defs&gt;
  
  &lt;g&gt;
    ...
  &lt;/g&gt;

<b>&lt;/svg></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The XML declaration</b></font></p>
<p>The first line in Listing 1 is an XML declaration.&nbsp; Since this is not 
intended to be an XML tutorial, I won't attempt to explain its purpose.&nbsp; 
Suffice it to say that it probably needs to be there.&nbsp; I'm sure that if you 
want to learn more about it, you can use Google to find more material on the 
topic than you can possibly find the time to read.</p>
<p><font color="#FF0000"><b>The root element</b></font></p>
<p>Every XML document requires a <i>root</i> element, which contains all of the 
other elements.&nbsp; In this case, the root element is the element named <b>svg</b> 
shown in Listing 1.</p>
<p>The purpose of the <i>version</i> attribute shown in Listing 1 is probably fairly obvious.&nbsp; The same 
is true of the height and width attributes, although the meaning of their values 
may not be clear.&nbsp; My recommendation is that you simply experiment with the 
values for the height and width attributes and you will probably be able to 
determine for yourself the behavior that they induce.</p>
<p>The remaining element attribute for the <b>svg</b> element shown in Listing 1 
is known as a <i>namespace</i> attribute.&nbsp; The purpose of a namespace attribute is 
far too complicated for me to try to explain in this lesson.&nbsp; If you are 
really interested in its purpose, I'm confident that you will find a large 
amount of explanatory information on the web.&nbsp; Otherwise, just accept the 
fact that it needs to be there.</p>
<p><font color="#FF0000"><b>The defs element</b></font></p>
<p>The <b>defs</b> element shown in Listing 1 is simply a container for two elements that I will 
explain later.&nbsp; These two elements provide definitions of the two different color gradients that 
you see in Figure 1.&nbsp; One color gradient goes from yellow to red and the 
other color gradient goes from green to blue.&nbsp; Each gradient definition is 
given a name, which can be referred to later to cause other graphic objects to 
be filled using those color gradients.</p>
<p><font color="#FF0000"><b>The g element</b></font></p>
<p>Listing 1 also shows an element named <b>g</b>, which serves as a container 
for the ellipse element and the circle element shown in Figure 1.</p>
<p><font color="#FF0000"><b>Parent-child relationships</b></font></p>
<p>In XML terminology, the <b>defs</b> element and the <b>g</b> element are both 
child elements of the <b>svg</b> element.&nbsp; From a DOM tree perspective, 
they are both child nodes of the node in the tree that represents the <b>svg</b> 
element.&nbsp; This will be important to understand later when we get into the 
Java/JAXP DOM tree code that I used to represent the image. </p>
<p><font color="#FF0000"><b>Abbreviated defs element</b></font></p>
<p>Listing 2 shows an abbreviated version of the <b>defs</b> element with some 
of the content of the element deleted for clarity.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Abbreviated defs element. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre><b>&lt;defs&gt;</b>
  &lt;linearGradient id="gradientA"&gt;
    ...
  &lt;/linearGradient&gt;

  &lt;linearGradient id="gradientB"&gt;
    ...
  &lt;/linearGradient&gt;
<b>&lt;/defs&gt;</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see from Listing 2, the <b>defs</b> element has two child 
elements, both of which are <b>linearGradient</b> elements.&nbsp; At this point we are 
getting a little closer to something that describes what you see in Figure 1.</p>
<p><font color="#FF0000"><b>Identification attributes for linear gradient 
elements</b></font></p>
<p>The first <b>linearGradient</b> element has an attribute named <b>id</b> 
with a value of <b>gradientA</b>.&nbsp; As you will see later, the definition of 
the <b>ellipse</b> element refers to this <b>id</b> value to cause the <b>
ellipse</b> shown in Figure 1 to be filled with the color gradient that is 
defined in the first <b>linearGradient</b> element.</p>
<p>Similarly, the second <b>linearGradient</b> element shown in Listing 2 has an
<b>id</b> attribute value of <b>gradientB</b>.&nbsp; You will see later that the
<b>circle</b> element refers to this <b>id</b> value to cause the <b>circle</b> 
shown in Figure 1 to be filled with the color gradient that is defined in the 
second <b>linearGradient</b> element.</p>
<p><font color="#FF0000">
<b>One complete linearGradient element</b></font></p>
<p>Listing 3 shows the complete <b>linearGradient</b> element for the first <b>
linearGradient</b> element in Listing 2.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. One complete linearGradient element. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;linearGradient id="gradientA"&gt;
  &lt;stop offset="0%" style="stop-color:yellow;"/&gt;
  &lt;stop offset="100%" style="stop-color:red;"/&gt;
&lt;/linearGradient&gt;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A different offset attribute value</b><br />
  For the image shown in Figure 2, the offset value for the first stop element 
	was set to 25% resulting in the left one-fourth of the ellipse being solid 
	yellow.&nbsp; The offset value for the second stop element was set to 75%, 
	causing the right one-fourth of the ellipse to be solid red.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>The stop elements</b></font><p>As you can see, the <b>linearGradient</b> element 
shown in Listing 3 has two child elements, 
each of which is a <b>stop</b> element.</p>
<p><font color="#FF0000"><b>The offset attribute</b></font></p>
<p>The <b>offset</b> attribute of the first <b>
stop</b> element defines the point on the left side of the image at which the color begins to change.&nbsp; 
This point is defined as a percentage of the total width of the component being filled with a 
gradient color.&nbsp; As you can see, I used a value of 0%, specifying that the 
color should begin changing immediately at the left edge of the ellipse.&nbsp;
</p>
<p><font color="#FF0000"><b>The style attribute</b></font></p>
<p>The value of the <b>style</b> attribute in the first <b>stop</b> element 
defines the beginning color at the left.&nbsp; As you can see, I set this to 
yellow causing the left edge of the ellipse in Figure 1 to be yellow.</p>
<p><font color="#FF0000"><b>Attributes of the second stop element</b></font></p>
<p>The value of the <b>offset</b> attribute in the second <b>stop</b> element in 
Listing 3 defines the point at which the color finishes changing.&nbsp; I set 
this to 100% causing the color to change all the way to the right edge of the 
ellipse in Figure 1.</p>
<p>The value of the <b>style</b> attribute in the second <b>stop</b> element 
defines the ending color.&nbsp; I set this to red causing the right 
edge of the ellipse in Figure 1 to be red.</p>
<p>As a result of this definition for a linear gradient, the ellipse, which is 
filled with color according to this definition, makes a smooth transition from 
yellow on the left to red on the right in Figure 1.</p>
<p><font color="#FF0000">
<b>Another complete linearGradient element</b></font></p>
Listing 4 shows the complete version of the second <b>linearGradient</b> element 
from Listing 2.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Another complete linearGradient element. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;linearGradient id="gradientB"&gt;
  &lt;stop offset="0%" style="stop-color:green;"/&gt;
  &lt;stop offset="100%" style="stop-color:blue;"/&gt;
&lt;/linearGradient&gt;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The circle in Figure 1 was filled using the definition of <b>gradientB</b> 
shown in Listing 4.&nbsp; By now, you should be able to interpret the material 
in Listing 4 and understand how that definition causes the color of the circle 
in Figure 1 to transition smoothly from green on the left to blue on the right.</p>
<p><font color="#FF0000">
<b>The ellipse and circle elements</b></font></p>
<p>Listing 5 shows the complete contents of the element named <b>g</b> from 
Listing 1.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. The ellipse and circle elements. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;g&gt;
  &lt;ellipse cx="110" cy="100" rx="100" ry="40" 
    style="fill:url(#gradientA);
           stroke:rgb(0,0,100);
           stroke-width:2"/&gt;

  &lt;circle cx="110" cy="100" r="30" 
    style="fill:url(#gradientB)"/&gt;
&lt;/g&gt;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, the element named <b>g</b> has two child elements.&nbsp; One 
is an <b>ellipse</b> element and the other is a <b>circle</b> element.</p>
<p><font color="#FF0000"><b>The circle element</b></font></p>
<p>I will begin the discussion with the <b>circle</b> element because it is the 
simpler of the two.&nbsp; The appearance of the circle is determined 
by the values of the four attributes shown in Listing 5.&nbsp; For example, the values of the attributes named
<b>cx</b> and <b>cy</b> define the location coordinates of the center of the 
circle, given in pixels relative to the upper-left corner of the white area in 
Figure 1.</p>
<p>The value of the attribute named <b>r</b> defines the radius of the circle.</p>
<p>The value of the <b>style</b> attribute for the circle in Listing 5 specifies 
that the circle is to be filled according to the definition of the <b>
linearGradient</b> with an <b>id</b> of <b>gradientB</b> shown in Listing 4.</p>
<p><font color="#FF0000"><b>The ellipse element</b></font></p>
<p>The <b>ellipse</b> element in Listing 5 is a little more complicated than the
<b>circle</b> element.&nbsp; To begin with, because it is not round, more 
information is required to define its shape.&nbsp; The values of the attributes 
named <b>cx</b> and <b>cy</b> have the same meaning as for the circle.&nbsp; 
However, the <b>ellipse</b> doesn't have a single <i>radius</i> attribute.&nbsp; 
Rather, the value of the attribute named <b>rx</b> defines the distance from the 
center to either the left or right end of the ellipse.&nbsp; 
Similarly, the value of the attribute named <b>ry</b> defines the distance from 
the center to either the top or the bottom of the ellipse.</p>
<p><font color="#FF0000"><b>The style attribute of the ellipse element</b></font></p>
<p>The <b>style</b> attribute is also more complicated.&nbsp; The <b>style</b> 
element is subdivided into three parameters with the following names:</p>
<ul>
	<li>fill</li>
	<li>stroke</li>
	<li>stroke-width</li>
</ul>
<p>Each parameter name is separated from its value by a colon.&nbsp; The three 
parameters are separated from each other by semicolons.</p>
<p><font color="#FF0000"><b>The fill parameter</b></font></p>
<p>The <b>fill</b> parameter has the same meaning as for the circle.&nbsp; In 
other words, the <b>fill</b> parameter specifies that the ellipse is to be 
filled according to the definition of the <b>linearGradient</b> with an <b>id</b> 
value of <b>gradientA</b> in Listing 4.</p>
<p><font color="#FF0000"><b>Style parameters that define the border on the ellipse</b></font></p>
<p>The other two style parameters define the visual characteristics of the border on 
the ellipse as shown in Figure 1.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Alternative ways to specify color.</b><br />
  <i>I 
could also have specified the color in Listing 5 by its common name, but I wanted to 
illustrate that it is possible to mix red, green, and blue to produce custom 
colors for which there is no name.&nbsp; In theory, it is possible to specify 
about sixteen million different colors using this approach.</i></td></tr></table>
</td>
</tr>
</table>

The <b>stroke</b> parameter defines the 
color of the border to be blue, using percentage contributions of red, green, and blue in that 
order from left to right within the parentheses.&nbsp; A value of 0 specifies no 
contribution of a particular color while a value of 100 specifies the maximum 
possible contribution of the color.&nbsp; The result is a mixture of the 
contributions of red, green, and blue.&nbsp; In this case, there was zero 
contribution 
for red, zero contribution for green, and 100 percent contribution for blue.</p>
<p>The <b>stroke-width</b> parameter specifies the thickness of the border.&nbsp; 
In this case, I caused the border to have a thickness of two pixels.</p>
<p><font color="#FF0000"><b>Putting it all together</b></font></p>
<p>Putting all the pieces together, Listing 6 shows the complete contents of the 
SVG file used to render the image in Figure 1.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The complete contents of the SVG/XML file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;svg height="100%" version="1.1" width="100%" 
  xmlns="http://www.w3.org/2000/svg"&gt;

&lt;defs&gt;
&lt;linearGradient id="gradientA"&gt;
&lt;stop offset="0%" style="stop-color:yellow;"/&gt;
&lt;stop offset="100%" style="stop-color:red;"/&gt;
&lt;/linearGradient&gt;

&lt;linearGradient id="gradientB"&gt;
&lt;stop offset="0%" style="stop-color:green;"/&gt;
&lt;stop offset="100%" style="stop-color:blue;"/&gt;
&lt;/linearGradient&gt;
&lt;/defs&gt;

&lt;g&gt;
&lt;ellipse cx="110" cy="100" rx="100" ry="40" 
  style="fill:url(#gradientA);
         stroke:rgb(0,0,100);
         stroke-width:2"/&gt;

&lt;circle cx="110" cy="100" r="30" 
  style="fill:url(#gradientB)"/&gt;
&lt;/g&gt;

&lt;/svg></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A plain text file</b></font></p>
<p>As you can see, an SVG file is a plain text file, which you could produce 
with a text editor if you had a reason to do so.&nbsp; Also, if you knew what 
you were doing, you could use a text editor to modify the file and thus cause 
the modified file to render into a different image.</p>
<p><font color="#FF0000"><b>Just a bunch of characters</b></font></p>
<p>Unlike a JPEG or GIF bitmapped file, the contents of the SVG file shown in 
Listing 6 do not constitute an image.&nbsp; Rather, those contents simply 
provide the instructions by which an SVG-capable rendering engine <i>(such as 
Firefox 1.5)</i> can produce an image.&nbsp; Without the rendering engine, the 
contents of the SVG file are worthless.&nbsp; For example, if you were to load 
the SVG file shown in Listing 6 into IE 6 without first installing the SVG 
plug-in, all you would see would be a very nice indented and color-coded listing 
of the XML text shown in Listing 6.&nbsp; You would not see the image shown in 
Figure 1, which was produced by loading the SVG file into Firefox 1.5.</p>
<p><font color="#FF0000"><b>Loading the SVG file into IE 6</b></font></p>
<p>In fact, Figure 4 shows the result of loading the SVG/XML file into an IE 6 
browser for which the SVG plug-in hasn't been installed.&nbsp; Contrast the 
image in Figure 4 with the image in Figure 1, and you will understand what I 
mean by the importance of an SVG rendering engine.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Viewing the SVG/XML file in IE 6. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2212a04.jpg" width="472" height="584"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Now that you know all about the SVG/XML output produced by the program named
<b>Svg01</b>, it's time to take a look at the program in order to understand how 
it produces that output.</p>
<p><font color="#FF0000"><b>Program description for Svg01</b></font></p>
<p>The purpose of this program is to create a DOM tree describing a specific 
graphic image in SVG format, to transform it into raw XML code, and to write 
that raw XML code out into an XML 
file named <b>junk.svg</b>.</p>
<p>Along the way, the DOM is displayed in XML format on the command-line screen.&nbsp; 
Note, however that the output on the command-line screen is all on a single line 
with no line breaks or indentation.&nbsp; Therefore, it is useful only for test 
and debug purposes.</p>
<p>Portions of this program were based on the earlier program named <b>Xslt01</b>, 
which I explained in lesson number 2202 titled &quot;Getting Started with Java JAXP 
and XSL Transformations (XSLT)&quot; <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p>The output file produced by this program can be rendered by loading it into 
Firefox 1.5.&nbsp; The program was tested using J2SE 5.0, Firefox 1.5.0.8, and 
WinXP.</p>
<p>I will explain this program in fragments.&nbsp; A complete listing of the 
program is provided in Listing 26 near the end of the lesson.</p>
<p><font color="#FF0000">
<b>Beginning of the class for Svg01</b></font></p>
<p>Listing 7 shows the beginning of the class named <b>Svg01</b>.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the class for Svg01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Svg01 {

  public static void main(String[] args){
    try{
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      Document document = builder.newDocument();
      document.setXmlStandalone(false);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Create a DOM tree</b></font></p>
<p>The purpose of the code in Listing 7 is to begin the process of creating a 
DOM tree that represents the XML code that will be used to render the image 
shown in Figure 1.&nbsp; The code in Listing 7 was explained in my earlier 
lesson number 2200 titled &quot;Java API for XML Processing (JAXP), Getting Started&quot;
<i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
Therefore, I won't bore you by repeating that explanation here.&nbsp; You should refer to the explanation in the earlier lesson 
if you don't understand the code in Listing 7.</p>
<p>Note that the code in Listing 7 ends up having created an object of the type
<b>Document</b>, and having saved a reference to that object in a reference 
variable named <b>document</b>.&nbsp; The <b>Document</b> object represents the 
entire XML document. Conceptually, it is the root of the document tree, 
and provides the primary access to the document's data.</p>
<p><font color="#FF0000">
<b>Create root node named svg</b></font></p>
<p>Listing 8 creates the root node named <b>svg</b> and appends it to the <b>
document</b> node.&nbsp; Thus, <b>svg</b> is a child node of <b>document</b>.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Create root node named svg. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element svg = 
                   (Element)document.createElement("svg");
      document.appendChild(svg);

      //Set some attributes on the root node that are
      // required for proper rendering.
      svg.setAttribute("width","100%");
      svg.setAttribute("height","100%");
      svg.setAttribute("version","1.1");
      svg.setAttribute(
                    "xmlns","http://www.w3.org/2000/svg");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The node named <b>svg</b> in Listing 8 corresponds directly to the element named <b>svg</b> 
shown in Listing 1.&nbsp; Later on, when the DOM tree is transformed to raw XML 
code, this node will cause the <b>svg</b> element to be contained in the output 
SVG/XML code.</p>
<p><font color="#FF0000"><b>Set node attribute values on the svg node</b></font></p>
<p>In addition to creating the <b>svg</b> node, the code in Listing 8 also sets 
some attribute values on the node that are required for proper rendering later.&nbsp; 
These attribute values correspond directly to the element attributes shown in 
Listing 1.</p>
<p><font color="#FF0000">
<b>Create the defs node</b></font></p>
<p>Listing 9 creates a node named <b>defs</b> that will eventually contain nodes 
that define two different color gradient schemes. The <b>defs</b> node 
corresponds directly to the element named <b>defs</b> shown in Listing 1, and is 
appended onto the <b>svg</b> node.&nbsp; Therefore, <b>defs</b> is a child node 
of the node named <b>svg</b>.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Create the defs node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
      Element defs = 
                  (Element)document.createElement("defs");
      svg.appendChild(defs);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you saw in Listing 2, a pair of<b> linearGradient</b> nodes will be 
created as child nodes of the<b> defs</b> node.<b> </b>&nbsp;The two <b>
linearGradient</b> nodes will be identified as <b>gradientA</b> and <b>gradientB</b>.&nbsp; They will be referred to later to specify the fill colors 
for an <b>ellipse</b> node and a <b>circle</b> node.</p>
<p><font color="#FF0000">
<b>Create a linearGradient node</b></font></p>
<p>Listing 10 creates the first of two <b>linearGradient</b> nodes <i>(corresponding 
to the <b>linearGradient</b> elements shown in Listing 2)</i>, and appends the node 
to the <b>defs</b> node.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Create a linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element linearGradientA = 
        (Element)document.createElement("linearGradient");
      defs.appendChild(linearGradientA);

      linearGradientA.setAttribute("id","gradientA");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As explained earlier, this node is given an attribute node named <b>id</b> 
with a value of <b>gradientA</b>.</p>
<p><font color="#FF0000">
<b>Create the first stop node</b></font></p>
<p>Listing 11 creates a <b>stop</b> node corresponding to the first <b>stop</b> 
element shown in Listing 3.&nbsp; This <b>stop</b> node is appended to the <b>
linearGradient</b> node, thus becoming a child node of the <b>linearGradient</b> 
node.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Create the first stop node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element stopA = 
                  (Element)document.createElement("stop");
      stopA.setAttribute("offset","0%");
      stopA.setAttribute("style","stop-color:yellow;");

      linearGradientA.appendChild(stopA);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 11 also sets two attribute values that belong to the <b>stop</b> 
node.&nbsp; As you can see, 
the attribute values match the element attribute values for the first <b>stop</b> 
element shown in Listing 3.</p>
<p>This <b>stop</b> node, along with the <b>stop</b> node shown in Listing 12 
causes the <b>linearGradient</b> node to provide a linear color gradient making 
a smooth transition from yellow to red, going from left to right as shown in 
Figure 1.</p>
<p><font color="#FF0000">
<b>Create the second stop node</b></font></p>
<p>Listing 12 creates a <b>stop</b> node corresponding to the second <b>stop</b> 
element shown in Listing 3, and appends the <b>stop</b> node to the <b>
linearGradient</b> node.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Create the second stop node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element stopB = 
                  (Element)document.createElement("stop");
      stopB.setAttribute("offset","100%");
      stopB.setAttribute("style","stop-color:red;");

      linearGradientA.appendChild(stopB);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create and populate the other linearGradient node</b></font></p>
<p>In similar fashion, the code in Listing 13 creates a <b>linearGradient</b> 
node corresponding to the <b>linearGradient</b> element shown in Listing 4.&nbsp; 
The <b>linearGradient</b> node is given two <b>stop</b> nodes as child nodes, 
corresponding to the two <b>stop</b> elements shown in Listing 4.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Create and populate the other 
linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Now define linearGradientB, which provides a
      // linear color gradient from green to blue going
      // from left to right. Append it to the defs node.
      Element linearGradientB = 
        (Element)document.createElement("linearGradient");
      defs.appendChild(linearGradientB);
      linearGradientB.setAttribute("id","gradientB");
      
      Element stopC = 
                  (Element)document.createElement("stop");
      stopC.setAttribute("offset","0%");
      stopC.setAttribute("style","stop-color:green;");
      linearGradientB.appendChild(stopC);
      
      Element stopD = 
                  (Element)document.createElement("stop");
      stopD.setAttribute("offset","100%");
      stopD.setAttribute("style","stop-color:blue;");
      linearGradientB.appendChild(stopD);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the ellipse and circle nodes</b></font></p>
<p>Listing 14 creates a <b>g</b> node and makes it a child of the <b>svg</b> 
node.&nbsp; This <b>g</b> node corresponds to the <b>g</b> element shown in 
Listing 5.</p>
</p>
<p>Also corresponding to Listing 5, the code in Listing 14 creates an <b>ellipse</b> 
node and a <b>circle</b> node and makes them child nodes of the <b>g</b> node.&nbsp; 
These two nodes correspond to the <b>ellipse</b> and <b>circle</b> elements 
shown in Listing 5. </p>
<p>
<b><a name="Listing_14">Listing 14</a>. Create the g node, the ellipse node, and 
the circle node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Create a node named g that contains an ellipse
      // and a circle.  Append it to the svg node.
      Element gNode = 
                     (Element)document.createElement("g");
      svg.appendChild(gNode);

      //Now create an ellipse with a blue border having
      // a thickness of two pixels. Color the ellipse in
      // the yellow-red style defined by linearGradientA.
      // Append the ellipse node to the g node.
      Element ellipseA  = 
               (Element)document.createElement("ellipse");
      gNode.appendChild(ellipseA);
      ellipseA.setAttribute("cx","110");
      ellipseA.setAttribute("cy","100");
      ellipseA.setAttribute("rx","100");
      ellipseA.setAttribute("ry","40");
      ellipseA.setAttribute("style",
                            "fill:url(#gradientA);"
                            + "stroke:rgb(0,0,100);"
                            + "stroke-width:2");
      
      //Now place a circle at a location that will make
      // it appear that the circle is physically inside
      // the ellipse.  Note however that the circle is
      // not a child node of the ellipse.  They simply
      // occupy the same space in the display.  Color the
      // circle with the green-blue style defined by
      // linearGradientB. Append the circle node to the
      // g node.
      Element circleA  = 
                (Element)document.createElement("circle");
      gNode.appendChild(circleA);
      circleA.setAttribute("cx","110");
      circleA.setAttribute("cy","100");
      circleA.setAttribute("r","30");
      circleA.setAttribute("style",
                            "fill:url(#gradientB)");</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>By now, the usage of the Java code to create the DOM tree should be 
sufficiently familiar to you that no explanation beyond the embedded comments in 
Listing 14 should be required.</p>
<p><font color="#FF0000"><b>The DOM tree is complete</b></font></p>
<p>At this point, the construction of the DOM tree representing the XML code 
required to produce the image shown in Figure 1 has been completed.&nbsp; If you 
are new to this process, you may be wondering what the advantage of a DOM tree 
is, since more Java code is required to construct it that is reflected in the 
XML code that it will be used to produce.</p>
<p>Basically, a DOM tree is a generalized way to represent an XML document.&nbsp; 
Once you have the tree, you can write code to perform a variety of modifications 
on the tree, such as moving child nodes among parents, etc.&nbsp; You can also 
transform the DOM tree into a variety of different output formats, including raw XML, 
HTML, PDF, etc.&nbsp; In this case, we will simply transform the DOM tree into a 
raw XML output file to be rendered by the SVG rendering engine in Firefox 1.5.&nbsp;
<i>(For test and debug purposes, we will also transform the DOM tree into a 
screen output showing the raw XML.)</i></p>
<p><font color="#FF0000"><b>The remaining program code</b></font></p>
<p>The remaining program code is shown in Listing 15.&nbsp; Most of the 
remaining code is used to transform the DOM tree into the raw XML screen display 
and raw XML output file described above.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. The remaining program code.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Get a TransformerFactory object.
      TransformerFactory xformFactory = 
                         TransformerFactory.newInstance();
           
      //Get an XSL Transformer object.
      Transformer transformer = 
                            xformFactory.newTransformer();
      
      //This statement is new to this lesson.  It sets
      // the standalone property in the XML declaration,
      // which appears as the first line of the output
      // file.
      transformer.setOutputProperty(
                              OutputKeys.STANDALONE,"no");
      
      //Get a DOMSource object that represents the
      // Document object
      DOMSource source = new DOMSource(document);

      //Get a StreamResult object that points to the
      // screen. Then transform the DOM sending XML to
      // the screen.
      StreamResult scrResult = 
                             new StreamResult(System.out);
      transformer.transform(source, scrResult);

      //Get an output stream for the output file.
      PrintWriter outStream = new PrintWriter("junk.svg");

      //Get a StreamResult object that points to the
      // output file.  Then transform the DOM sending XML
      // to the file
      StreamResult fileResult = 
                              new StreamResult(outStream);
      transformer.transform(source,fileResult);
    }//end try block

    catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch

  }// end main()
  //----------------------------------------------------//
  
}// class Svg01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Explained in an earlier lesson</b></font></p>
<p>Almost all of the code in Listing 15 was explained in my earlier lesson 
titled "Getting Started with Java JAXP and XSL Transformations (XSLT)" <i>
(see <a href="#Resources">Resources</a>)</i> in conjunction with the program named
<b>Xslt01</b>.&nbsp; Therefore, I won't bore you with another explanation of the 
same code.</p>
<p><font color="#FF0000"><b>The end of the program</b></font></p>
<p>Listing 15 also signals the end of the <b>main</b> method and the end 
of the class named <b>Svg01</b>.&nbsp; When the program terminates, it will have 
produced an output file in the current directory named <b>junk.svg</b>.&nbsp; 
You can load that file into your Firefox 1.5 browser, and you should see a 
graphic output that matches the image in Figure 1.</p>
<p>Or, you should be able to load the file into any other SVG rendering engine, 
such as IE 6 with the SVG plug-in installed, and you should see a graphic output 
that matches the image shown in Figure 1.</p>
<h3><a name="The_Svg02_program">The Svg02 program</a></h3>
<p><font color="#FF0000"><b>A lot of programming was required</b></font></p>
<p>By now you have probably realized that a lot of programming was 
required to write the program named <b>Svg01</b>, simply to produce the small 
XML file shown in Listing 6.&nbsp; You may have concluded that there 
must be an easier way.&nbsp; Although it requires more up-front programming 
effort, there is an easier way.</p>
<p><font color="#FF0000"><b>An easier way</b></font></p>
<p>If you will be doing very much of this type of programming, one easier way is 
to create a reusable SVG graphics library that will alleviate most of the 
tedious programming effort required to produce the SVG files that represent your images.&nbsp; I will use the 
program named <b>Svg02</b> to illustrate the beginnings of just such an SVG 
graphics library of my own design.&nbsp; The major elements in the graphics 
library correspond to the major graphic elements in the SVG specification.</p>
<p>I also want to point out that most of the code shown in Listing 7 and Listing 15 is completely 
reusable from one graphic image to the next.&nbsp; Therefore, I also moved most 
of that code to methods in the library.&nbsp; These methods can be used over and over 
again with no requirement to rewrite the code each time the SVG code for a new graphic 
image is required.</p>
<p><font color="#FF0000"><b>Much more work will be required</b></font></p>
<p>Quite a lot of effort will be required to finish the graphic library 
and to bring it into full compliance with the SVG specifications.&nbsp; However, once the 
library is available it can be used to greatly reduce the amount of programming 
effort required to produce a new graphic image.&nbsp; For example, as you will 
see later, exclusive of the code in the new graphics library, the program named
<b>Svg02</b> produces the same SVG/XML output file as the program named <b>Svg01</b> 
with only the following nine method calls:</p>
<ol>
	<li>getDocument <i>part of required setup</i></li>
	<li>getRootNode <i>to create the root node</i></li>
	<li>simpleElement <i>for the node named defs</i></li>
	<li>makeLinearGradient <i>for gradientA</i></li>
	<li>makeLinearGradient <i>for gradientB</i></li>
	<li>simpleElement <i>for the node named g</i></li>
	<li>svgEllipse <i>to create the ellipse</i></li>
	<li>svgCircle <i>to create the circle</i></li>
	<li>transformTheDom <i>to write the output file</i></li>
</ol>
<p>Of the nine methods, only seven are required for the purpose of creating nodes 
that describe the graphic image.&nbsp; The remaining two are required to do 
some required setup and to write the output file.</p>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>This program is an update of the program named <b>Svg01</b>.&nbsp; The 
purpose of this update is to move most of the difficult and tedious code into a 
small SVG graphics library class named <b>SvgGraphics</b> so that the 
application programmer can concentrate on the characteristics of the required 
graphic images rather than having to concentrate on the details of SVG and 
JAXP/DOM programming.</p>
<p>Also, for convenience, the library contains two methods that are used 
to execute code that is the same regardless of the graphic image being produced.</p>
<p><font color="#FF0000"><b>The library is not complete</b></font></p>
<p>As mentioned earlier, the SVG graphics library is far from complete.&nbsp; In 
its current state, the library provides methods to produce the following types 
of DOM tree nodes:</p>
<ul>
	<li>A simple element with no attributes.</li>
	<li>A linear gradient element.</li>
	<li>An ellipse.</li>
	<li>A circle.</li>
</ul>
<p>Although a great deal more programming effort would be required to write a 
complete SVG graphics library, this program demonstrates proof of concept.&nbsp; The program illustrates an approach that 
could be used to create a graphics library that supports most of the features of 
the SVG specification.</p>
<p><font color="#FF0000"><b>Create and transform a DOM tree</b></font></p>
<p>This program creates a DOM tree describing the graphic image shown in Figure 1 
in SVG format.&nbsp; Then it transforms the DOM tree into raw XML code and 
writes that code into an output XML file named <b>junk.svg</b>.&nbsp; Along the way, the DOM is displayed in raw XML format on the command-line screen.</p>
<p>The output file produced by this program can be rendered by loading it into 
Firefox 1.5.</p>
<p>The program was tested using J2SE 5.0, Firefox v1.5.0.8, and WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As is my custom, I will explain this program by discussing it in fragments.&nbsp; 
A complete listing of the program is provided in Listing 27 near the end of the 
lesson.</p>
<p>As before, the program begins by creating a DOM tree that represents the XML code that 
can be rendered to produce the image shown in Figure 1.&nbsp; The program and 
the <b>main</b> method begin in Listing 16.</p><p>
<b><a name="Listing_16">Listing 16</a>. Beginning of the Svg02 class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Svg02{

  public static void main(String[] args){
    //Get the Document object.
    Document document = <b>SvgGraphics.getDocument()</b>;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 16 calls a convenience method in the graphics library to get a reference to an object of 
type <b>Document</b>.&nbsp; <i>(You can view all of the methods in the graphics 
library in Listing 27.)</i>&nbsp; The code in the method is essentially the same as 
that used in the previous program.&nbsp; If you understood the code in Listing 
7, you should have no difficulty understanding the code in this new method.&nbsp; 
Therefore, this code shouldn't require further explanation.</p>
<p><font color="#FF0000">
<b>Create the root node named svg</b></font></p>
<p>Listing 17 calls the graphics library method named <b>getRootNode</b> to</p>
<ul>
	<li>Create 
the root node named <b>svg</b></li>
	<li>Set some attribute values on the new node</li>
	<li>Make it a child node of the <b>Document</b> object</li>
</ul>
<p>
<b><a name="Listing_17">Listing 17</a>. Create the root node named svg. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create the root node named svg and append it
    // to the document.
    Element svg = SvgGraphics.getRootNode(document,
                                          "100%",
                                          "100%",
                                          "absolute",
                                          "0",
                                          "0");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you understood the code in Listing 8, you should have no difficulty 
understanding the code for the method named <b>getRootNode</b>.&nbsp; Therefore, I won't explain it 
further at this point in the lesson.</p>
<p><font color="#FF0000">
<b>Create the node named defs</b></font></p>
<p>Listing 18 calls the graphics library method named <b>simpleElement</b> to create a node named
<b>defs</b>.&nbsp; This node will be the parent for a pair of linear gradient definition 
nodes.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Create the node named defs. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element defs = SvgGraphics.<b>simpleElement</b>(
                                   document,svg,"defs");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>simpleElement</b> is shown in its entirety in Listing 27.&nbsp; 
This method calls the <b>createElement</b> method to create an element node <i>
(having no attributes)</i> of the type given by the third incoming parameter <i>
(&quot;defs&quot; in this case)</i>.&nbsp; Then it appends the new node to the node 
specified by the second parameter <i>(<b>svg</b> in this case)</i> and returns a 
reference to the new node.</p>
<p><font color="#FF0000"><b>Create the first linearGradient node</b></font></p>
<p>Listing 19 calls the graphics library method named <b>makeLinearGradient</b> to 
create a new <b>linearGradient</b> node, which will be identified as <b>
gradientA</b>.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Create the first linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element linearGradientA = 
               SvgGraphics.makeLinearGradient(
                 document,            //this document
                 defs,                 //parent
                 "gradientA",         //id
                 "0%",                //beginning point
                 "stop-color:yellow;",//beginning color
                 "100%",              //ending point
                 "stop-color:red;");  //ending color</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method call defines a <b>linearGradient</b> node that provides a linear 
color gradient that transitions from yellow to red going from left to right. The method 
call also establishes the beginning and ending points of the gradient along with the beginning and ending colors.</p>
<p>The method named <b>makeLinearGradient</b> is shown in its entirety in 
Listing 27.&nbsp; I'm sure that by now you are getting tired of me saying this, 
but I will say it at least one more time.&nbsp; If you understood the code in 
Listing 10, Listing 11, and Listing 12, you should have no difficulty 
understanding the code in the method named <b>makeLinearGradient</b>.&nbsp; 
Therefore, I won't explain it further.</p>
<p><font color="#FF0000">
<b>Create the second linearGradient node</b></font></p>
<p>Listing 20 calls the <b>makeLinearGradient</b> method to create the second <b>
linearGradient</b> node.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Create the second linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element linearGradientB = 
                SvgGraphics.makeLinearGradient(
                  document,           //this document
                  defs,                //parent
                  "gradientB",        //id
                  "0%",               //beginning point
                  "stop-color:green;",//beginning color
                  "100%",             //ending point
                  "stop-color:blue;");//ending color</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method call corresponds to Listing 13 in the previous program, providing a linear gradient 
that transitions from green 
on the left to blue on the right.</p>
<p><font color="#FF0000">
<b>Create the g node</b></font></p>
<p>Listing 21 makes another call to the <b>simpleElement</b> method to create 
the <b>g</b> node.&nbsp; This will be the parent node for an <b>ellipse</b> node 
and a <b>circle</b> node, and corresponds to the first two executable statements 
in Listing 14 from the previous program.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Create the g node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Element g = SvgGraphics.simpleElement(
                                        document,svg,"g");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the ellipse node</b></font></p>
<p>Listing 22 calls the graphics library method named <b>svgEllipse</b> to create an
<b>ellipse</b> node that represents the ellipse shown in Figure 1.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Create the ellipse node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Create an ellipse with a blue border that is two
    // pixels thick. Fill the ellipse with the
    // yellow-red  gradient defined by linearGradientA.

    //Begin by defining the style for the ellipse
    String ellipseStyle = 
          "fill:url(#gradientA);" //Fill using gradientA
          + "stroke:rgb(0,0,100);"//Border and its color
          + "stroke-width:2";     //Border width

    SvgGraphics.svgEllipse(document,//This document
                           g,//Owner
                           110,//Center x-coordinate
                           100,//Center y-coordinate
                           100,//Width
                           40, //Height
                           ellipseStyle);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>To make it somewhat easier to format the code to fit into this narrow 
publication format, the code in Listing 22 begins by defining a <b>String</b> 
that specifies the <b>style</b> for the ellipse.&nbsp; A reference to that 
string is passed as the seventh parameter to the <b>svgEllipse</b> method that 
creates the node and causes it to become a child node of the <b>g</b> node.</p>
<p><font color="#FF0000">
<b>Create a circle node</b></font></p>
<p>Listing 23 calls the graphics library method named <b>svgCircle</b> to create a 
node that represents the circle in Figure 1, and appends the new node to the <b>g</b> 
node.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. Create a circle node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Place a circle in a location that will make it
    // appear to be inside the ellipse. Specify a 
    // style that will fill it with the green-blue
    // gradient defined by linearGradientB.
    SvgGraphics.svgCircle(document,//This document
                          g,//Owner
                          110,//Center x-coordinate
                          100,//Center y-coordinate
                          30, //Radius
                          "fill:url(#gradientB)");</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>In this case, the string specifying the <b>style</b> was rather short, so I 
simply defined it as part of the parameter list in the method call.</p>
<p><font color="#FF0000">
<b>Transform the DOM and write the output file</b></font></p>
<p>The DOM tree that represents the raw XML code required to produce the image 
shown in Figure 1 is now complete.&nbsp; Listing 24 invokes the library method named <b>
transformTheDom</b> to transform the DOM tree into raw XML code, write that code 
onto the command-line screen, and write that code into the output file named <b>
junk.svg</b>.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Transform the DOM and write the output 
file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    SvgGraphics.transformTheDom(document,"junk.svg");
  }// end main()
}// class Svg02</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in the method named <b>transformTheDom</b> is essentially the same 
as the code in Listing 15 from the previous program.&nbsp; If you understood 
that code, you should have no difficulty understanding the code in the method 
named <b>transformTheDom</b>.</p>
<p>Listing 24 also signals the end of the <b>main</b> method and the end of the 
class named <b>Svg02</b>.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 26 and Listing 27 into your text
editor, compile it, and execute it.&nbsp; Then view the resulting SVG files in 
Firefox 1.5, or some other suitable SVG rendering engine.&nbsp; Experiment with 
the code, making
changes, and observing the results of your changes. </p>
<p>Above all, enjoy the process. Programming can be fun if you approach it with 
a positive attitude.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>This lesson is part 1 of a two-part series designed to teach you how to write 
servlets to produce SVG code that will be rendered in graphic form by an 
SVG-compatible browser.</p>
<p>In this lesson, I showed you how to write Java code to produce the raw XML 
code necessary to produce images using an SVG rendering engine.&nbsp; </p>
<p>First I 
showed you how to do it the hard way.&nbsp; Then I introduced the beginnings of 
an SVG graphics library that can be used to eliminate <i>(or at least alleviate)</i> 
the requirement to write raw XML code or to write raw JAXP DOM code.&nbsp; The 
SVG graphics library makes it possible to produce SVG output files simply by 
making typical Java method calls.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>Part 2 of the series will show you how to take what you have learned 
in this lesson and apply it to the generation of XHTML files containing in-line SVG/XML code.&nbsp; 
Then it will teach you how to apply that knowledge to the writing of servlets 
that produce XHTML output containing in-line SVG/XML code.</p>
<p>A future lesson will teach you how to write servlets that produce XHTML 
output containing references to external SVG files in addition to in-line 
SVG/XML code.</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in
Listing 25 through Listing 27 below.
<p>
<b><a name="Listing_25">Listing 25</a>. Output XML file produced by both programs. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;svg height="100%" version="1.1" width="100%" 
  xmlns="http://www.w3.org/2000/svg"&gt;

&lt;defs&gt;
&lt;linearGradient id="gradientA"&gt;
&lt;stop offset="0%" style="stop-color:yellow;"/&gt;
&lt;stop offset="100%" style="stop-color:red;"/&gt;
&lt;/linearGradient&gt;

&lt;linearGradient id="gradientB"&gt;
&lt;stop offset="0%" style="stop-color:green;"/&gt;
&lt;stop offset="100%" style="stop-color:blue;"/&gt;
&lt;/linearGradient&gt;
&lt;/defs&gt;

&lt;g&gt;
&lt;ellipse cx="110" cy="100" rx="100" ry="40" 
  style="fill:url(#gradientA);
         stroke:rgb(0,0,100);
         stroke-width:2"/&gt;

&lt;circle cx="110" cy="100" r="30" 
  style="fill:url(#gradientB)"/&gt;
&lt;/g&gt;

&lt;/svg></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<b><a name="Listing_26">Listing 26</a>. Java code for program Svg01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg01.java
Copyright 2006 R.G.Baldwin

The purpose of this program is to create a DOM tree 
describing a specific graphic image in SVG format and to 
write it out into an XML file named junk.svg. Along the 
way, the DOM is displayed in XML format on the 
command-line screen. Note, however that the output on the 
command-line screen is all on a single line with no line 
breaks or indentation. Therefore, it is useful only for 
test and debug purposes. 

Portions of this program are based on the earlier program 
named Xslt01.java, which was explained in lesson 
number 2202 named "Getting Started with Java JAXP and 
XSL Transformations (XSLT)".

The output file produced by this program can be rendered 
by loading it into Firefox 1.5.

Tested using J2SE 5.0, Firefox 1.5.0.8, and WinXP.
*********************************************************/

import javax.xml.parsers.*;
import org.w3c.dom.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;

public class Svg01 {

  public static void main(String[] args){
    try{
      //Begin by creating a DOM tree that represents
      // the XML code that will render to produce the
      // image of interest.
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      Document document = builder.newDocument();
      document.setXmlStandalone(false);

      //Create the root node named svg and append it to
      // the document.
      Element svg = 
                   (Element)document.createElement("svg");
      document.appendChild(svg);
      
      //Set some attributes on the root node that are
      // required for proper rendering.
      svg.setAttribute("width","100%");
      svg.setAttribute("height","100%");
      svg.setAttribute("version","1.1");
      svg.setAttribute(
                    "xmlns","http://www.w3.org/2000/svg");
      
      //Create a node named defs that contains the
      // definitions of two different gradient coloring
      // schemes. The definitions are identified as
      // linearGradientA and linearGradientB.  They will
      // be referred to later to specify the fill colors
      // for an ellipse and a circle.
      Element defs = 
                  (Element)document.createElement("defs");
      svg.appendChild(defs);
      
      //Now define linearGradientA, which provides a
      // linear gradient from yellow to red going from
      // left to right and append it to the defs node.
      Element linearGradientA = 
        (Element)document.createElement("linearGradient");
      defs.appendChild(linearGradientA);
      linearGradientA.setAttribute("id","gradientA");
      
      Element stopA = 
                  (Element)document.createElement("stop");
      stopA.setAttribute("offset","0%");
      stopA.setAttribute("style","stop-color:yellow;");
      linearGradientA.appendChild(stopA);
      
      Element stopB = 
                  (Element)document.createElement("stop");
      stopB.setAttribute("offset","100%");
      stopB.setAttribute("style","stop-color:red;");
      linearGradientA.appendChild(stopB);
      
      //Now define linearGradientB, which provides a
      // linear color gradient from green to blue going
      // from left to right. Append it to the defs node.
      Element linearGradientB = 
        (Element)document.createElement("linearGradient");
      defs.appendChild(linearGradientB);
      linearGradientB.setAttribute("id","gradientB");
      
      Element stopC = 
                  (Element)document.createElement("stop");
      stopC.setAttribute("offset","0%");
      stopC.setAttribute("style","stop-color:green;");
      linearGradientB.appendChild(stopC);
      
      Element stopD = 
                  (Element)document.createElement("stop");
      stopD.setAttribute("offset","100%");
      stopD.setAttribute("style","stop-color:blue;");
      linearGradientB.appendChild(stopD);
      
      //Create a node named g that contains an ellipse
      // and a circle.  Append it to the svg node.
      Element gNode = 
                     (Element)document.createElement("g");
      svg.appendChild(gNode);

      //Now create an ellipse with a blue border having
      // a thickness of two pixels. Color the ellipse in
      // the yellow-red style defined by linearGradientA.
      // Append the ellipse node to the g node.
      Element ellipseA  = 
               (Element)document.createElement("ellipse");
      gNode.appendChild(ellipseA);
      ellipseA.setAttribute("cx","110");
      ellipseA.setAttribute("cy","100");
      ellipseA.setAttribute("rx","100");
      ellipseA.setAttribute("ry","40");
      ellipseA.setAttribute("style",
                            "fill:url(#gradientA);"
                            + "stroke:rgb(0,0,100);"
                            + "stroke-width:2");
      
      //Now place a circle at a location that will make
      // it appear that the circle is physically inside
      // the ellipse.  Note however that the circle is
      // not a child node of the ellipse.  They simply
      // occupy the same space in the display.  Color the
      // circle with the green-blue style defined by
      // linearGradientB. Append the circle node to the
      // g node.
      Element circleA  = 
                (Element)document.createElement("circle");
      gNode.appendChild(circleA);
      circleA.setAttribute("cx","110");
      circleA.setAttribute("cy","100");
      circleA.setAttribute("r","30");
      circleA.setAttribute("style",
                            "fill:url(#gradientB)");
      
      //Most of the remaining code transforms the DOM
      // tree into a screen display and an output file.
      // This code was explained in the earlier lesson
      // named "Getting Started with Java JAXP and XSL 
      // Transformations (XSLT)" in conjunction with the
      // program named Xslt01.

      //Get a TransformerFactory object.
      TransformerFactory xformFactory = 
                         TransformerFactory.newInstance();
           
      //Get an XSL Transformer object.
      Transformer transformer = 
                            xformFactory.newTransformer();
      
      //This statement is new to this lesson.  It sets
      // the standalone property in the XML declaration,
      // which appears as the first line of the output
      // file.
      transformer.setOutputProperty(
                              OutputKeys.STANDALONE,"no");
      
      //Get a DOMSource object that represents the
      // Document object
      DOMSource source = new DOMSource(document);

      //Get a StreamResult object that points to the
      // screen. Then transform the DOM sending XML to
      // the screen.
      StreamResult scrResult = 
                             new StreamResult(System.out);
      transformer.transform(source, scrResult);

      //Get an output stream for the output file.
      PrintWriter outStream = new PrintWriter("junk.svg");

      //Get a StreamResult object that points to the
      // output file.  Then transform the DOM sending XML
      // to the file
      StreamResult fileResult = 
                              new StreamResult(outStream);
      transformer.transform(source,fileResult);
    }//end try block

    catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch

  }// end main()
  //----------------------------------------------------//
  
}// class Svg01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<b><a name="Listing_27">Listing 27</a>. Java code for program Svg02.
</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg02.java
Copyright 2006 R.G.Baldwin

This program is an update of the program named Svg01.  The
purpose of this update is to move most of the difficult 
and tedious code into a small SVG graphics library class 
named SvgGraphics so that the application programmer can 
concentrate on the use of the graphics library rather than
having to concentrate on the details of SVG.

For convenience, the library also contains a couple of
methods that are used to execute code that is the same 
regardless of the graphic image being produced.

The SVG graphics library is far from complete.  In its
current state, the library provides methods to produce the
following DOM tree nodes.

  A simple element with no attributes.
  A linear gradient element.
  An ellipse
  A circle

Although a great deal more programming effort would be 
required to write a complete SVG graphics library, this
program serves its intended purpose of provides a proof of 
concept. The program illustrates an approach that could be
used to create a graphics library that supports most of 
the features of the SVG specification.

The program creates a DOM tree describing a specific 
graphic image in SVG format and writes it out into an XML 
file named junk.svg. Along the way, the DOM is displayed 
in raw XML format on the command-line screen. Note, 
however that the output on the command-line screen is all 
on a single line with no line breaks or indentation. 
Therefore, it is useful only for test and debug purposes. 

Portions of this program are based on the earlier program 
named Xslt01.java, which was explained in lesson 
number 2202 titled "Getting Started with Java JAXP and 
XSL Transformations (XSLT)".

The output file produced by this program can be rendered 
by loading it into Firefox 1.5.

Tested using J2SE 5.0, Firefox v1.5.0.8, and WinXP.
*********************************************************/

import javax.xml.parsers.*;
import org.w3c.dom.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;

public class Svg02{

  public static void main(String[] args){

    //Begin by creating a DOM tree that represents
    // the XML code that will render to produce the
    // image of interest.

    //Get the Document object.
    Document document = SvgGraphics.getDocument();

    //Create the root node named svg and append it
    // to the document.
    Element svg = SvgGraphics.getRootNode(document,
                                          "100%",
                                          "100%",
                                          "absolute",
                                          "0",
                                          "0");
  
    //Create a node named defs, which will be the parent
    // for a pair of linear gradient definitions.
    Element defs = SvgGraphics.simpleElement(
                                   document,svg,"defs");
  
    //Define linearGradientA, which provides a linear
    // gradient from yellow to red going from left to
    // right. Establish the beginning and ending points
    // along with the beginning and ending colors in
    // the process
    Element linearGradientA = 
               SvgGraphics.makeLinearGradient(
                 document,            //this document
                 defs,                 //parent
                 "gradientA",         //id
                 "0%",                //beginning point
                 "stop-color:yellow;",//beginning color
                 "100%",              //ending point
                 "stop-color:red;");  //ending color


    //Define linearGradientB, which provides a linear
    // gradient from green to blue going from left to
    // right.
    Element linearGradientB = 
                SvgGraphics.makeLinearGradient(
                  document,           //this document
                  defs,                //parent
                  "gradientB",        //id
                  "0%",               //beginning point
                  "stop-color:green;",//beginning color
                  "100%",             //ending point
                  "stop-color:blue;");//ending color
    
    //Create a node named g, which will be the parent
    // for an ellipse and a circle.
    Element g = SvgGraphics.simpleElement(
                                   document,svg,"g");

    //Create an ellipse with a blue border that is two
    // pixels thick. Fill the ellipse with the
    // yellow-red  gradient defined by linearGradientA.
    //Begin by defining the style for the ellipse
    String ellipseStyle = 
          "fill:url(#gradientA);" //Fill using gradientA
          + "stroke:rgb(0,0,100);"//Border and its color
          + "stroke-width:2";     //Border width
    SvgGraphics.svgEllipse(document,//This document
                           g,//Owner
                           110,//Center x-coordinate
                           100,//Center y-coordinate
                           100,//Width
                           40, //Height
                           ellipseStyle);

    //Place a circle in a location that will make it
    // appear to be inside the ellipse. Specify a 
    // style that will fill it with the green-blue
    // gradient defined by linearGradientB.
    SvgGraphics.svgCircle(document,//This document
                          g,//Owner
                          110,//Center x-coordinate
                          100,//Center y-coordinate
                          30, //Radius
                          "fill:url(#gradientB)");
    
    //Transform the DOM and write the output.
    SvgGraphics.transformTheDom(document,"junk.svg");

  }// end main()
  //----------------------------------------------------//
  
}// class Svg02
//======================================================//

//This is a small proof-of-concept graphics class that
// provides method calls for the creation of the following
// DOM tree nodes:
//  A simple element with no attributes.
//  A linear gradient element.
//  An ellipse
//  A circle

//Each method receives a reference to the overall document
// along with a reference to the parent for the new node.
//When the method returns, the new node has been appended
// to the parent node.
class SvgGraphics{

  //This method returns a reference to a simple XML
  // element node that has no attributes.
  static Element simpleElement(Document document,
                               Element parent,
                               String type){
    Element theElement = 
                    (Element)document.createElement(type);
    parent.appendChild(theElement);
    return theElement;
  }//end simpleElement
  //----------------------------------------------------//
  
  //This method returns a reference to a linear gradient
  // node for which the beginning and ending points and
  // the beginning and ending colors have been
  // established. The id value is the value by which the
  // gradient is referenced in order to apply it to 
  // a component.
  static Element makeLinearGradient(Document document,
                                    Element parent,
                                    String id,
                                    String beginningPoint,
                                    String beginningColor,
                                    String endingPoint,
                                    String endingColor){
    Element linearGradient = 
        (Element)document.createElement("linearGradient");
    parent.appendChild(linearGradient);
    linearGradient.setAttribute("id",id);
    
    //Establish the point at which the gradient begins
    // and the color at the beginning point.
    Element beginningElement  = 
                  (Element)document.createElement("stop");
    beginningElement.setAttribute(
                                 "offset",beginningPoint);
    beginningElement.setAttribute("style",beginningColor);
    linearGradient.appendChild(beginningElement);
    
    //Establish the point at which the gradient ends and
    // the color at that point.
    Element endingElement  = 
                  (Element)document.createElement("stop");
    endingElement.setAttribute("offset",endingPoint);
    endingElement.setAttribute("style",endingColor);
    linearGradient.appendChild(endingElement);
    
    return linearGradient;
  }//end makeLinearGradient
  //----------------------------------------------------//

  //This method returns a reference to an ellipse for 
  // which the style has already been established. Pass
  // an empty string for the style parameter if you don't
  // need to set the style. The xCoor and yCoor parameters
  // specify the center of the ellipse.  The xRadius and
  // yRadius parameters specify the width and height of
  // the  ellipse respectively.
  static Element svgEllipse(Document document,
                            Element parent,
                            int xCoor,
                            int yCoor,
                            int xRadius,
                            int yRadius,
                            String style){
    Element ellipseOut  = 
               (Element)document.createElement("ellipse");
    parent.appendChild(ellipseOut);
    ellipseOut.setAttribute("cx",""+xCoor);
    ellipseOut.setAttribute("cy",""+yCoor);
    ellipseOut.setAttribute("rx",""+xRadius);
    ellipseOut.setAttribute("ry",""+yRadius);
    if(!style.equals("")){
      ellipseOut.setAttribute("style",style);
    }//end if
    return ellipseOut;
  }//end svgEllipse
  //----------------------------------------------------//

  //This method returns a reference to a circle for 
  // which the style has already been established. Pass
  // an empty string for the style parameter if you don't
  // need to set the style. The xCoor and yCoor parameters
  // specify the center of the circle.  The radius
  // parameter specifies the radius of the circle.
  static Element svgCircle(Document document,
                           Element parent,
                           int xCoor,
                           int yCoor,
                           int radius,
                           String style){
    Element circleOut  = 
                (Element)document.createElement("circle");
    parent.appendChild(circleOut);
    circleOut.setAttribute("cx",""+xCoor);
    circleOut.setAttribute("cy",""+yCoor);
    circleOut.setAttribute("r",""+radius);
    if(!style.equals("")){
      circleOut.setAttribute("style",style);
    }//end if
    return circleOut;
  }//end svgCircle
  //----------------------------------------------------//
  
  //This method returns a reference to a root node that
  // has already been appended to the document.
  static Element getRootNode(Document document,
                 String width,
                 String height,
                 String position,
                 String top,
                 String left){
    //Create the root node named svg and append it to
    // the document.
    Element svg = 
                 (Element)document.createElement("svg");
    document.appendChild(svg);

    //Set some attributes on the root node that are
    // required for proper rendering. Note that the
    // approach used here is somewhat different from the
    // approach used in the earlier program named Svg01,
    // particularly with regard to the style.
    svg.setAttribute(
                  "xmlns","http://www.w3.org/2000/svg");
    svg.setAttribute("version","1.1");
    svg.setAttribute("style","width:" + width 
                   + ";height:" + height 
                   + ";position:" + position
                   + ";top:" + top
                   + ";left:" + left
                   + ";\"");

    return svg;
  }//end getRootNode
  //----------------------------------------------------//
  
  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced.
  static Document getDocument(){
    Document document = null;
    try{
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      document = builder.newDocument();
      document.setXmlStandalone(false);
    }catch(Exception e){
      e.printStackTrace(System.err);
      System.exit(0);
    }//end catch
    return document;
  }//end getDocument
  //----------------------------------------------------//

  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced.  This method transforms the DOM into
  // raw XML code and writes that code into the output.
  static void transformTheDom(Document document,
                              String filename){
    try{
      //Get a TransformerFactory object.
      TransformerFactory xformFactory =
                         TransformerFactory.newInstance();
           
      //Get an XSL Transformer object.
      Transformer transformer = 
                            xformFactory.newTransformer();
      
      //Sets the standalone property in the first line of
      // the output file.
      transformer.setOutputProperty(
                              OutputKeys.STANDALONE,"no");
      
      //Get a DOMSource object that represents the
      // Document object
      DOMSource source = new DOMSource(document);

      //Get a StreamResult object that points to the
      // screen. Then transform the DOM sending XML to
      // the screen.
      StreamResult scrResult = 
                             new StreamResult(System.out);
      transformer.transform(source, scrResult);

      //Get an output stream for the output file.
      PrintWriter outStream = new PrintWriter(filename);

      //Get a StreamResult object that points to the
      // output file.  Then transform the DOM sending XML
      // code to the file
      StreamResult fileResult = 
                              new StreamResult(outStream);
      transformer.transform(source,fileResult);
    }//end try block

    catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch
  }//end transformTheDom

  //----------------------------------------------------//
  
}//end class SvgGraphics
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<p><b>Java 2D Graphics</b><br>
<a href="http://java.sun.com/products/java-media/2D/">Java 2D API</a><br>
<a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D Graphics, 
Nested Top-Level Classes and Interfaces&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D Graphics, 
The Point2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D Graphics, 
The Graphics2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D Graphics, 
Simple Affine Transforms&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D Graphics, 
The Shape Interface, Part 1&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D Graphics, 
The Shape Interface, Part 2&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D Graphics, 
Solid Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D Graphics, 
Gradient Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D Graphics, 
Texture Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D Graphics, 
The Stroke Interface&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D Graphics, 
The Composite Interface and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D Graphics, 
The Composite Interface, GradientPaint, and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D Graphics, 
The Color Constructors and Transparency<br>
<a href="http://java.sun.com/j2se/1.5.0/docs/guide/2d/spec.html">Java 2D API 
Specification</a></p>
<p><b>Java API for XML Processing (JAXP)</b><br>
<a href="http://www.developer.com/java/other/article.php/3099751">2200</a> Java 
API for XML Processing (JAXP), Getting Started<br>
<a href="http://www.developer.com/xml/article.php/3113351">2202</a> Getting 
Started with Java JAXP and XSL Transformations (XSLT)<br>
<a href="http://www.developer.com/java/other/article.php/3292751">2204</a> Java 
JAXP, Exposing a DOM Tree<br>
<a href="http://www.developer.com/java/other/article.php/3313341">2206</a> Java 
JAXP, Implementing Default XSLT Behavior in Java<br>
<a href="http://www.developer.com/java/other/article.php/3361261">2208</a> Java 
JAXP, Writing Java Code to Emulate an XSLT Transformation<br>
<a href="http://www.developer.com/java/data/article.php/3398741">2210</a> Java 
JAXP, Transforming XML to XHTML<br>
<a href="http://www.dickbaldwin.com/tocxml.htm">Links to numerous XML tutorials 
by Richard G. Baldwin</a><br>
<br>
<b>Scalable Vector Graphics (SVG)</b><br>
<a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a><br>
<a href="http://www.adobe.com/svg/">Adobe SVG Viewer plug-in</a><br>
<a href="https://www6.software.ibm.com/developerworks/education/x-svggraphics/index.html">
Create vector graphics in the browser with SVG</a> by Uche Ogbuji<br>
<a href="http://www.w3schools.com/svg/default.asp">SVG Tutorial</a><br>
<a href="http://www.svgbasics.com/shapes.html">SVG Basics</a><br>
<br>
<b>Miscellaneous</b><br>
<a href="http://www.walterzorn.com/jsgraphics/jsgraphics_e.htm">High Performance 
JavaScript Vector Graphics Library</a> at
<a href="http://www.walterzorn.com/index.htm">www.walterzorn.com</a><br>
</p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java jaxp svg &quot;scalable vector graphics&quot; </p>
<p>-end- </p>
</body>
</html>
