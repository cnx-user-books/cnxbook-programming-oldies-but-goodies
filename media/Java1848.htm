<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <title>... in Java by Richard G Baldwin</title>
</head>
  <body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
 
<p></p>
<h2>Changing Focus traversal Keys in Java V1.4</h2>
 <i>Baldwin shows you two different ways to change the focus traversal keys
on an  individual component at runtime.</i>
<p><b>Published:</b>&nbsp; August 5, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b> 
</p>
<p>Java Programming Notes # 1848</p>
<ul>
 <li> <a href="#Preface">Preface</a></li>
 <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and Sample
Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program Listing</a></li>
 
</ul>
  
<hr size="3" width="100%" align="center"> 
<center> 
<h2> <a name="Preface"></a>Preface</h2>
</center>
 
<p> <b><font color="#ff0000">New features in SDK Version 1.4.0</font></b>
</p>
 
<p>The recently released Java<sup>TM</sup> 2 SDK, Standard Edition Version
1.4  contains a large number of new features, including many changes and
additions to  the focus subsystem.&nbsp; This lesson is part of a series
of lessons designed  to teach you how to use the new  features of the focus
subsystem  in Java Version 1.4 and later.</p>
<p>The first lesson in the series was entitled&nbsp;<a
 href="http://www.developer.com/java/other/article.php/2198221">Focus Traversal
Policies in Java Version 1.4</a>.&nbsp;  The previous lesson was entitled&nbsp;<a
 href="http://www.developer.com/java/other/article.php/2219701">Focusability
in Java Version 1.4</a>.</p>
 
<p> <font color="#ff0000"><b>Focus traversal keys</b></font></p>
<p> This lesson will concentrate on one important new aspect of focus traversal,
<i> focus traversal keys.&nbsp;</i>  Subsequent lessons will deal with other
aspects of focus traversal, as well as a  variety of other features of the
new focus subsystem.</p>
<p><font color="#ff0000"><b>A lot to learn</b></font></p>
 
<p>There is a lot to learn about the new focus subsystem.&nbsp; It is anything
but  trivial.</p>
 
<p>In addition to new capabilities, Sun has also introduced a new set of
focus  terminology.&nbsp; I have briefly discussed the following terms in
the previous  lessons in this series.</p>
 
<ul>
   <li>Focus traversal</li>
   <li>The focus cycle root</li>
   <li>Focus traversal cycle</li>
   <li>Focus owner</li>
   <li>Up cycle and down cycle traversal operations</li>
   <li>Focus traversal policy</li>
 
</ul>
 
<p>In addition, previous lessons have dealt with several aspects of the new
 focus subsystem, including:</p>
 
<ul>
   <li>How to control focusability at runtime.</li>
   <li>The ability to query for the currently focused Component.</li>
   <li>The default Focus Traversal Policy.</li>
   <li>How to establish a focus traversal policy and modify it at runtime.</li>
 
</ul>
 
<p>This lesson will show you how to modify the focus traversal keys on  individual
components at runtime.</p>
 
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate 
browser window.&nbsp; That will make it easier for you to scroll back and 
forth among the different listings and figures while you are reading about 
them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However,
as of the date of this writing, Gamelan doesn't maintain a consolidated index
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp;
You will find a consolidated index at <font color="#000000"> <a
 href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font>   </p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
 
<p>In this lesson, I will teach you two different ways to change the focus
 traversal keys on an individual component at runtime.</p>
<center> 
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion 
and Sample Code</font></h2>
</center>
 
<p><font color="#ff0000"><b>Focus traversal</b></font></p>
<p>Sun defines focus    traversal as <i>"the user's ability to change the
"focus owner" without    moving the cursor."</i></p>
<p>Focus traversal can normally be either <i>forward</i>    to the next component,
or <i>backward</i> to the previous    component.</p>
<p><font color="#ff0000"><b>Traversal typically uses keys</b></font></p>
<p>Typically, focus traversal is accomplished using one or more keys    on
the keyboard.&nbsp; For example, it is very common for the TAB key to be
   used to move the focus along its traversal path in the <i>forward</i>
   direction, and for the Shift-TAB key combination to be used to move the
focus along    its traversal path in the<i> backward </i>direction.</p>
<p>However, keyboard  action isn't always required.&nbsp; It is also possible
for    client code to initiate traversal through the execution of program
   instructions.</p>
<p><font color="#ff0000"><b>No longer tied to the TAB key</b></font></p>
<p>To the best of my knowledge, prior to the release of version    1.4, it
was not possible for the programmer to specify the key or combination   
of keys used for focus traversal <i>(if it was possible, I never figured
out    how to do it).</i>&nbsp;  </p>
<p>With version 1.4, each component can individually  define its own set
of focus traversal keys for a given focus traversal operation.&nbsp; For
example, it is no longer required that the    TAB and Shift-TAB keys be the
keys used for focus traversal.&nbsp;        </p>
<p><font color="#ff0000"><b>Every component can have different traversal
keys</b></font></p>
<p>Furthermore,  with V1.4, every different component within a focus traversal
cycle can use    a different set of traversal keys, and the set of keys being
used for any    component can be modified at runtime.&nbsp; <i>(I will demonstrate
this with    the programs that I will discuss later in this lesson.)</i></p>
<p>Each component supports    a separate set of keys for forward and backward
traversal.&nbsp; Separate sets of keys are also    supported for traversal
up one focus traversal cycle. Containers that are focus cycle roots also support
a set of keys for traversal down one focus traversal cycle.   </p>
<p><font color="#ff0000"><b>Traversal keys may be inherited</b></font></p>
<p>If a set of focus traversal keys is not explicitly defined for a component,
that component recursively inherits a set from its parent.&nbsp; If no set
of focus traversal  keys is explicitly defined somewhere along the way, the
component ultimately  inherits its set of focus traversal keys from a context-wide
default set on the current <b>KeyboardFocusManager</b>.  </p>
<p><font color="#ff0000"><b>AWTKeyStroke</b></font>   </p>
<p>As you will see later, a set of focus traversal keys for a particular
 component consists of a <b>Set</b> of references to objects of type <b>AWTKeyStroke</b>,
 where <b>Set</b> is a common interface used in the <i>Java Collections Framework.</i>&nbsp;
 <i>(If you are unfamiliar with the Java Collections Framework, you can read
 about it on my <a href="http://www.dickbaldwin.com">web site</a>.)</i></p>
<p>Thus, the set of focus traversal keys for a particular component consists
of one  or more references to unique objects of type <b>AWTKeyStroke</b>.</p>
<p><font color="#ff0000"><b>What is an  AWTKeyStroke?</b></font></p>
<p>According to Sun,  </p>
<blockquote> 
  <p><i>"An AWTKeyStroke represents a key action on the keyboard, or equivalent
 input device. AWTKeyStrokes can correspond to only a press or release of
a  particular key, just as KEY_PRESSED and KEY_RELEASED KeyEvents do; alternately,
 they can correspond to typing a specific Java character, just as KEY_TYPED
 KeyEvents do. In all cases, AWTKeyStrokes can specify modifiers (alt, shift,
 control, meta, or a combination thereof) which must be present during the
action  for an exact match."</i></p>
</blockquote>
 
<p><font color="#ff0000"><b>KEY_TYPED is not allowed</b></font></p>
<p>Also according to Sun,  although an <b>AWTKeyStroke</b> can correspond
to typing a specific Java  character,</p>
<blockquote> 
  <p><i>"It is a runtime error to specify a KEY_TYPED event as mapping to
a focus traversal operation, or to map the same event to multiple focus traversal
operations for any particular Component or for a KeyboardFocusManager's defaults."</i></p>
</blockquote>
 
<p>In other words, although an <b>AWTKeyStroke</b><i> </i>can represent  KEY_TYPED
events, such a keystroke cannot be used as a focus traversal key.&nbsp;  Only
KEY_PRESSED and KEY_RELEASED actions on the part of the user can be used
for  focus traversal keys.&nbsp;   </p>
<p><font color="#ff0000"><b>Client code specifies which to use</b></font></p>
<p>The client code can specify  on which of the two specific actions, KEY_PRESSED
or KEY_RELEASED, the focus traversal operation will occur.&nbsp;  This will
also be demonstrated in the programs to be discussed later in this  lesson.</p>
<p><font color="#ff0000"><b>KeyEvent is consumed</b></font></p>
<p>If the key  that is pressed is a focus traversal key, the key events that
would  normally be generated by pressing and releasing the key <i>(including
the associated KEY_TYPED event),</i>  will be consumed.&nbsp; Those key events
will not be dispatched to any component <i>(no registered key listeners will
be notified).</i></p>
<p><font color="#ff0000"><b>Default  focus traversal  keys</b></font></p>
<p> According to Sun, the default focus traversal keys are implementation-dependent.
Sun recommends that all implementations for a particular native platform
use the same keys. For Windows and Unix, Sun's recommendations are:    </p>
<ul>
      <li>traverse forward to the next Component:       <br>
    <i>TextAreas</i>: <code>CTRL-TAB</code> on <code>KEY_PRESSED</code> 
     <br>
    <i>All others</i>: <code>TAB</code> on <code>KEY_PRESSED</code> and 
                      <code>CTRL-TAB</code> on <code>KEY_PRESSED</code> 
    </li>
  <li>traverse backward to the previous Component:       <br>
    <i>TextAreas</i>: <code>CTRL-SHIFT-TAB</code> on                    
   <code>KEY_PRESSED</code>       <br>
    <i>All others</i>: <code>SHIFT-TAB</code> on <code>KEY_PRESSED</code> 
                       and <code>CTRL-SHIFT-TAB</code> on               
        <code>KEY_PRESSED</code>      </li>
  <li>traverse up one focus traversal cycle : &lt;none&gt;      </li>
  <li>traverse down one focus traversal cycle : &lt;none&gt;   </li>
</ul>
 
<p><i>Note that for the recommended default set, <b>TextArea</b> and <b> JTextArea</b>
components are treated differently from other components  (including text
fields) with respect to the TAB key.</i></p>
<p> <font color="#ff0000"><b>Disable a traversal key</b></font></p>
<p>Sun goes on to state,</p>
<blockquote> 
  <p><i>"These recommendations are used in the Sun AWT implementations. ...
To  disable a traversal key, use an empty Set; Collections.EMPTY_SET is  recommended."</i></p>
</blockquote>
 
<p><font color="#ff0000"><b>Changing the focus traversal keys at runtime</b></font></p>
<p>The programs to be discussed later begin with the default focus traversal
 keys, change to a different set of focus traversal keys during runtime,
and  later restore the focus traversal keys to the defaults.</p>
<p><font color="#ff0000"> <b>Enabling and disabling focus traversal</b></font></p>
<p>Components can enable and  disable all of their focus traversal keys by
invoking the  <b>setFocusTraversalKeysEnabled</b> method of the <b>Component</b>
class.</p>
<p>When  focus traversal keys are disabled, the component receives all key
events for those keys. However, as mentioned above, when focus traversal
keys are enabled, the  component never receives key events for traversal
keys.&nbsp; Keystrokes corresponding to  focus traversal keys are mapped
to focus traversal operations instead.</p>
<p> <font color="#ff0000"><b>FocusTraversalPolicy</b></font></p>
<p>The AWT focus implementation determines which component to focus next
based on the <b>FocusTraversalPolicy</b>  of the focus owner's focus cycle
root.&nbsp; <i>(The <b>FocusTraversalPolicy</b>  was the subject of a previous
 lesson.)</i></p>
<p> <font color="#ff0000"><b>Description of the programs</b></font></p>
<p>This tutorial  presents two similar programs to illustrate many of the
concepts mentioned  above.&nbsp; The programs are named <b>FocusKeys01</b>
and <b>FocusKeys02</b>.&nbsp;  Complete listings of both programs are presented
for your examination in Listing  29 and Listing 30 near the end of the lesson.</p>
<p><font color="#ff0000"><b>Adding  objects to a Set</b></font></p>
<p>The two programs differ in how they establish the set of <b>AWTKeyStroke</b>
 objects used to create a custom set of focus traversal keys for a <b>JTextField</b>
 object.&nbsp;  </p>
<p>An important issue has to do with restrictions imposed by the <b>add </b> 
method of a <b>Set</b> object.&nbsp; In order to be eligible for adding to
a  set:</p>
<ul>
   <li>The object being added must implement the <b>Comparable</b> interface,
or    </li>
   <li>An object of a class that implements the<b> Comparator</b> interface,<b> 
  </b><i>(capable of comparing two objects of the type being added),</i>
must be    provided when the<b> Set</b> object is instantiated.</li>
   
</ul>
   
<p><font color="#ff0000"><b>The more complex case</b></font></p>
<p>The more complex  of the two cases is illustrated by the program named
<b>FocusKeys01</b>.&nbsp; In  this program,    the <b>AWTKeyStroke</b> class
is extended into a new class that implements the   <b>Comparable</b> interface.&nbsp;
Objects of the new class are used to define    a custom set of focus traversal
keys.&nbsp;    </p>
<p>This approach illustrates some interesting features of Java, and is  
 discussed in detail in this tutorial lesson.</p>
<p><font color="#ff0000"><b>The  less complex case</b></font></p>
<p>The less complex of the two cases is illustrated by the program named
<b> FocusKeys02</b>.&nbsp;  This program    defines a class that implements
the <b>Comparator</b> interface.&nbsp; An  instance of that class can be
used to compare two <b>AWTKeyStroke </b>objects.</p>
<p>The    differences between the two programs are also    explained in this
 lesson.</p>
<p><font color="#ff0000"><b>The graphical  user interface</b></font></p>
<p>Both  programs place three buttons and a text field in a frame, as shown
in Figure 1.&nbsp;  Also, both programs exhibit the same behavior.&nbsp;
It is only the  implementation of that behavior that differs between the
two programs.</p>
<p align="center"> <img border="0" src="java1848a.gif" width="401"
 height="101">
</p>
<p align="center"> Figure 1.&nbsp; Sample program user interface.</p>
<p><font color="#ff0000"><b> Traversal state</b></font></p>
<p>Initially, the default    focus traversal keys shown in the earlier list
from Sun apply to all four components.&nbsp;        </p>
<p><b><font color="#ff0000">A new set of focus traversal keys</font></b></p>
<p>When  the button labeled <b>Change</b> is pressed, a new set of focus
traversal keys is  created and applied to the text field only <i>(the focus
traversal keys for the    three buttons don't change, illustrating that different
focus traversal keys    can be defined for each component).</i>&nbsp; From
that point forward until  the button labeled <b>Restore </b>is pressed, the
 new set of focus traversal keys must be used to traverse forward or backward
 from the text field.</p>
<p><b><font color="#ff0000">Restore the default focus  traversal keys</font></b></p>
<p>When the button labeled <b>Restore</b> is pressed, the default  focus
traversal keys are restored to the text field, and from that point forward
 until the <b>Change</b> button is pressed again,  the default traversal
keys must be used to traverse forward or backward from the  text field.</p>
<p><b><font color="#ff0000">What about key events?</font></b></p>
<p>A key listener is registered on the text field to demonstrate that  focus
traversal keys don't deliver key events to key-event handlers.</p>
<p><b> <font color="#ff0000">Miscellaneous information</font></b></p>
<p>Various  kinds of  information are displayed on the standard output device
to illustrate the  behavior of the program as it executes.</p>
<p> <font color="#ff0000"><b>Will discuss sample program in fragments</b></font></p>
<p> As is my habit, I will discuss the program in fragments.&nbsp; A complete
 listing of the program is provided in Listing 29 near the end of the lesson.</p>
<p> This program was tested using JDK 1.4.1 under WinXP, and requires Java
 version 1.4 or later to compile and run correctly.</p>
<p> <font color="#ff0000"><b>Get a GUI object</b></font></p>
<p> Listing 1 shows the <b>main</b> method, which simply instantiates a new
object of the  GUI class.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>class FocusKeys01{<br>  public static void <b>main</b>(String[] args){<br>    <b>new GUI();</b>
  }// end main
}//end class FocusKeys01 definition

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p> <font color="#ff0000"><b>The GUI class</b></font></p>
<p> Listing 2 shows the beginning of the <b>GUI</b> class, along with the
 declaration of several instance variables, whose purpose will be become
clear as  the discussion progresses.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>class GUI{<br>  JFrame jFrame = new JFrame();<br>  TreeSet forwardSet;<br>  TreeSet backwardSet;<br>  JTextField textField;<br>  Set oldForwardSet;<br>  Set oldBackwardSet;<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p> <font color="#ff0000"><b>The GUI constructor</b></font></p>
<p> Listing 3 shows the beginning of the constructor for the <b>GUI</b> class.&nbsp;
 Listing 3 also shows a couple of routine housekeeping operations, which
I won't  discuss further.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  GUI(){//constructor<br>    jFrame.setTitle(<br>                  "Copyright 2003, R.G.Baldwin");<br>    jFrame.setDefaultCloseOperation(<br>                           JFrame.EXIT_ON_CLOSE);<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>The GUI components</b></font></p>
<p> As you saw in Figure 1 earlier, the <b>GUI</b> object appears to consist
of  three buttons and a text field in a frame.&nbsp; It actually consists
of three <b>JButton</b> objects and a <b>JTextField</b> object, in a <b>JPanel</b>
 object, which in turn is placed in a <b>JFrame</b> object.</p>
<p> The <b>JFrame</b> object was created in Listing 2 above.&nbsp; Listing
4 shows  the creation of the panel, the three buttons, and the text field.&nbsp;
Code in  a subsequent fragment will assemble these parts into the final <b>GUI</b>
 object.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    JPanel panel = new JPanel();<br>    JButton changeBtn = new JButton("Change");<br>    JButton restoreBtn = new JButton("Restore");<br>    JButton dummyBtn = new JButton("Dummy");<br>    textField = new JTextField("abcde");<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>A key listener</b></font></p>
<p> As I explained earlier, if a key is pressed while a component has the
focus, and  if the key  that is pressed is a focus traversal key, the key
event that would  normally be generated by pressing the key will be consumed.&nbsp;
No key-event  handler methods will be invoked on any key listener objects
registered on that  component.</p>
<p> The code in Listing 5 registers a key listener object on the text field
using an  anonymous inner class.&nbsp; This key listener displays information
about the  key that generated the event.&nbsp; It is used to demonstrate
that  key events resulting from focus traversal keys are consumed and not
delivered to  registered listener objects.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    textField.addKeyListener(<br>      new KeyAdapter(){<br>        public void keyPressed(KeyEvent e){<br>          System.out.println(e.getKeyText(<br>                            e.getKeyCode()));}});<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> I will discuss the results of such a demonstration later in this tutorial
lesson.</p>
<p> <font color="#ff0000"><b>Save default focus traversal key sets</b></font></p>
<p> As I mentioned earlier, pressing the Restore button shown in Figure 1
causes the  default set of focus traversal keys to be restored to the text
field.&nbsp; This  is accomplished by saving the defaults as the program
is starting up, and  later using an action-event handler on the Restore button
to apply the saved sets  to the text field.</p>
<p> The code in Listing 6 saves the default traversal key sets for forward
and  backward traversal in two instance variables of type <b>Set</b>, which
 were declared in Listing 2.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    oldForwardSet = textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                         FORWARD_TRAVERSAL_KEYS);<br>    oldBackwardSet = textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        BACKWARD_TRAVERSAL_KEYS);<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>An indexed property named focusTraversalKeys</b></font></p>
<p> If you are familiar with Java design patterns, you will recognize from
Listing 6  that a <b>JTextField</b> object has an indexed property named
<b> focusTraversalKeys</b>.&nbsp; <i>(This conclusion is based on the existence
of  the method named <b>getFocusTraversalKeys</b>, which takes an integer
parameter.)</i></p>
<p> With a little experimentation, you can determine  the values of four
 constants, two of which are used in Listing 6.</p>
<ul>
   <li>FORWARD_TRAVERSAL_KEYS = 0</li>
   <li>BACKWARD_TRAVERSAL_KEYS = 1</li>
   <li>UP_CYCLE_TRAVERSAL_KEYS = 2</li>
   <li>DOWN_CYCLE_TRAVERSAL_KEYS = 3</li>
   
</ul>
 
<p> <i>(These constants are defined in the <b>KeyboardFocusManager</b> class
and are  inherited into the <b>DefaultKeyboardFocusManager</b> class.)</i></p>
<p> <font color="#ff0000"><b>Four collections of type Set</b></font></p>
<p> By default, the indexed property named <b>focusTraversalKeys </b>contains
 references to four different collections of type <b>Set</b>.&nbsp; Each
 collection contains references to a set of <b>AWTKeyStroke</b> objects.&nbsp;
There is one set for <i>forward</i> traversal, one set for <i>backward</i>
traversal, one set  for <i>up-cycle</i> traversal, and one set for <i>down-cycle</i>
traversal.&nbsp; <i>(I will be discussing up-cycle and down-cycle traversal
in a future lesson.)</i></p>
<p> <font color="#ff0000"><b>Get and save for later restoration</b></font></p>
<p> The code in Listing 6 gets and saves references to the sets corresponding
to  forward and backward traversal.&nbsp; These sets will be used later to
 restore the default focus traversal keys for the text field when the <b>Restore</b>
 button is pressed.</p>
<p> <font color="#ff0000"><b>What is the class type of the Set objects?</b></font></p>
<p> If we are going to create  custom focus traversal keys for a component,
 we must encapsulate references to objects of type <b>AWTKeyStroke</b> in&nbsp;<b>Set 
</b>objects whose references will be stored in the <b>focusTraversalKeys</b>
 property of the text field.&nbsp; Therefore, we need to know the name of
a class from  which we can instantiate those <b>Set </b>objects.&nbsp; So
far, I haven't found an  explicit specification of the name of that class
in the Sun documentation.&nbsp;  Some experimentation is required in order
to identify that class.</p>
<p> <font color="#ff0000"><b>Objects of type Set are required</b></font></p>
<p> The <b>getFocusTraversalKeys</b> method of the <b>JFrame</b> class is
inherited  from the <b>Container</b> class.&nbsp; An examination of the documentation
for  that method tells us that the method returns a reference to an object
of type <b> Set</b>.</p>
<p> Similarly, examination of the documentation for the <b>Container</b>
class  reveals the existence of the following method as well:</p>
<p></p>
<pre>public void setFocusTraversalKeys(<br>                  int&nbsp;id, <b>Set</b>&nbsp;keystrokes)</pre>
<p></p>
 
<p> However, all this really tells us is that the type of the property named
<b> focusTraversalKeys </b>is the interface  type <b>Set</b>.&nbsp; In theory,
we could use a reference to an object of any class that  implements the interface
named <b>Set</b> as a legitimate value for the  property.</p>
<p> <font color="#ff0000"><b>Practical considerations</b></font></p>
<p> However, there may be practical considerations indicating that the use
 of some sets would be better than the use of other sets.&nbsp; I will consider
 Sun to be the authority in making a choice among different types of sets.</p>
<p> <font color="#ff0000"><b>What type does Sun use?</b></font></p>
<p> The code in Listing  7 gets and displays the type of object that Sun
uses to encapsulate the default  focus traversal keys.&nbsp; It should be
safe for us to use the same type.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    System.out.println("Type of set");<br>    System.out.println(oldForwardSet.getClass());<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>UnmodifiableSet</b></font></p>
<p> Listing 7 produces the screen output shown in Figure 2, indicating that
Sun uses <b>UnmodifiableSet</b>, which is available via a method of the <b>Collections</b>
 class.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Type of set<br>class java.util.Collections$UnmodifiableSet<br><br><b>Figure 2</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>What did we learn?</b></font></p>
<p> This is a very interesting result.&nbsp; As it turns out, we still don't
know  for sure the type of object used by Sun to encapsulate the default
 focus traversal keys.&nbsp; However, an examination of the documentation
for the <b>Collections</b> class reveals about six similar methods having
names  beginning with the word <b>unmodifiable</b>.&nbsp; The method named
<b> unmodifiableSet</b> is one of those methods.&nbsp;&nbsp;  </p>
<p> <font color="#ff0000"><b>An unmodifiable view of a Set object</b></font></p>
<p> The documentation for the <b>unmodifiableSet</b> method of the <b>Collections</b>
class provides the  following information:</p>
<blockquote> 
  <p> <i>"Returns an unmodifiable view of the specified set. This method
allows  modules to provide users with "read-only" access to internal sets.
Query  operations on the returned set "read through" to the specified set,
and attempts  to modify the returned set, whether direct or via its iterator,
result in an UnsupportedOperationException."</i></p>
</blockquote>
 
<p> <font color="#ff0000"><b>A conclusion</b></font></p>
<p> From this information, I concluded that it doesn't really matter what
class is  used to instantiate the<b> Set </b>object used to encapsulate the
 focus traversal keys so long as an <i>unmodifiable view</i> of the <b>Set</b>
 object is passed to the <b>setFocusTraversalKeys</b> method.&nbsp;  </p>
<p> <font color="#ff0000"><b>What is an unmodifiable view?</b></font></p>
<p> The use of an unmodifiable view means that the programmer can cause the
property  to refer to a different set, but cannot modify the contents of
the set currently  referred to by the property.</p>
<blockquote> 
  <p> <i>"As it turns out, it is easy to demonstrate that the use of an  unmodifiable
view is not a technical requirement.&nbsp; A reference to any <b>Set</b>
object  can be used.&nbsp; However, it is probably a very good idea to follow
Sun's  example and make the set unmodifiable."</i></p>
</blockquote>
 
<p> Later on in the program, when I create a custom set of focus traversal
keys, I  will use an unmodifiable view of a <b>TreeSet</b> object.</p>
<p> <font color="#ff0000"><b>Register an ActionListener object on the buttons</b></font></p>
<p> The code in Listing 8 creates an action listener object and registers
it on the  two left-most buttons shown in Figure 1.&nbsp; <i>(The right-most
button is a  dummy button used solely to illustrate focus traversal.&nbsp;
It doesn't have any  listeners registered on it.)<br>
 &nbsp;</i>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    MyActionListener listener =<br>                          new MyActionListener();<br>    changeBtn.addActionListener(listener);<br>    restoreBtn.addActionListener(listener);<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> I will discuss the behavior of this action listener object in detail
later in  this lesson.</p>
<p> <font color="#ff0000"><b>The remainder of the constructor</b></font></p>
<p> The remainder of the constructor is shown in Listing 9.&nbsp; The code
in  Listing 9  does some housekeeping chores that are described in the  comments,
so I won't discuss them further.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    //Add a panel to the frame.  Then add the<br>    // buttons and the text field to the panel.<br>    jFrame.getContentPane().add(<br>                      panel,BorderLayout.CENTER);<br><br>    panel.add(changeBtn);<br>    panel.add(restoreBtn);<br>    panel.add(textField);<br>    panel.add(dummyBtn);<br><br>    //Set the size of the frame and make it<br>    // visible.<br>    jFrame.setSize(400,100);<br>    jFrame.setVisible(true);<br><br>  }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>Adding an object to a Set</b></font></p>
<p> Earlier I explained that in order for an object to be added to a set:</p>
<ul>
   <li>The object being added must implement the <b>Comparable</b> interface,
or    </li>
   <li>An object of a class that implements the<b> Comparator</b> interface,<b> 
  </b><i>(capable of comparing two objects of the type being added),</i>
must be    provided when the<b> Set</b> object is instantiated.</li>
   
</ul>
   
<p>This is because a <b>Set</b> object doesn't allow duplicates, and it  
 must be possible for the <b>add</b> method of the <b>Set</b> object to be
able    to compare objects and to reject duplicates.</p>
<p><font color="#ff0000"><b>The  implementing classes of the Set interface</b></font></p>
<p>The only known  implementing classes of the <b>Set</b> interface in version
1.4.1 are:</p>
<ul>
   <li>AbstractSet</li>
   <li>HashSet</li>
   <li>LinkedHashSet</li>
   <li>TreeSet</li>
   
</ul>
   
<p>I have no desire to define a new class that implements the <b>Set </b> 
  interface, and would prefer to use an existing class.&nbsp; Without getting
into a lot of detail as to my reasons, I will state that of these four  
 classes, only the <b>TreeSet</b> class is really suitable for use in this
program.</p>
<p> <font color="#ff0000"><b>TreeSet is a SortedSet</b></font></p>
<p>The <b>TreeSet</b> class implements the <b>SortedSet</b> interface, which
   Sun describes as follows:</p>
<blockquote>   
  <p><i>"A set that further guarantees that its iterator will traverse the
set    in ascending element order, sorted according to the natural ordering
of its    elements (see <b>Comparable</b>), or by a <b>Comparator</b> provided
at sorted set creation    time."</i></p>
</blockquote>
   
<p><font color="#ff0000"><b>Implementing Comparable</b></font></p>
<p>The <b> AWTKeyStroke</b> class does not implement the <b>Comparable</b>
interface.</p>
<p>The program under immediate discussion is named <b> FocusKeys01</b>.&nbsp;
In    this program, I extend the <b>AWTKeyStroke</b> class  into a new class
named <b>MyAWTKeyStroke</b>,    which implements the   <b>Comparable</b>
interface.&nbsp;     </p>
<p>Because objects of this new class are <b>AWTKeyStroke </b>objects, they
are    suitable for use in defining a custom set of focus traversal keys.&nbsp;
   </p>
<p>Because objects of this new class implement the <b>Comparable</b> interface,
   they are    suitable for adding to a <b>Set</b> object.</p>
<p><font color="#ff0000"><b>The  class named MyAWTKeyStroke</b></font></p>
<p>Listing 10 shows the beginning  of the new class named <b>MyAWTKeyStroke</b>,
which extends<b> AWTKeyStroke</b>  and implements <b>Comparable</b>.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>class MyAWTKeyStroke extends AWTKeyStroke<br>                           implements Comparable{<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> Now we come to a very interesting issue involving the <b> AWTKeyStroke</b>
class.</p>
<p> <font color="#ff0000"><b>The getAWTKeyStroke method</b></font></p>
<p> To begin with, the documentation of the <b>AWTKeyStroke</b> class contains
the  following statement:</p>
<blockquote> 
  <p> <i>"AWTKeyStrokes are immutable, and are intended to be unique. Client
code  should never create an AWTKeyStroke on its own, but should instead
use a variant  of getAWTKeyStroke. Client use of these factory methods allows
the AWTKeyStroke  implementation to cache and share instances efficiently."</i></p>
</blockquote>
 
<p> <font color="#ff0000"><b>The appropriate version of getAWTKeyStroke</b></font></p>
<p> The <b> AWTKeyStroke</b> class provides several overloaded public static
methods named <b>getAWTKeyStroke</b>.&nbsp; The version that is  appropriate
for use in creating focus traversal keys is described in Figure 3.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>AWTKeyStroke getAWTKeyStroke(<br>                     int&nbsp;keyCode,<br>                     int&nbsp;modifiers,<br>                     boolean&nbsp;onKeyRelease)<br><br>The "virtual key" constants defined in <br>java.awt.event.KeyEvent can be used to <br>specify the key code. For example: </pre>
 
      <pre>VK_ENTER<br>VK_TAB<br>VK_SPACE </pre>
 
      <pre>The modifiers consist of any combination<br>of the following constants of the <br>java.awt.event.InputEvent class:</pre>
 
      <pre>SHIFT_DOWN_MASK<br>CTRL_DOWN_MASK<br>META_DOWN_MASK<br>ALT_DOWN_MASK<br>ALT_GRAPH_DOWN_MASK<br>BUTTON1_DOWN_MASK<br>BUTTON2_DOWN_MASK<br>BUTTON3_DOWN_MASK </pre>
 
      <pre>The third parameter, onKeyRelease, should<br>be true if the AWTKeyStroke should <br>represent a key release; false otherwise.<br><br><b>Figure 3</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>An important question about factory methods</b></font></p>
 
<p>Since Sun insists that this factory method be used to get <b>AWTKeyStroke
</b> objects, how does one go about creating a similar  factory method for
a subclass of <b>AWTKeyStroke</b>?</p>
 
<p>The answer comes in the form of a protected static method of the <b> AWTKeyStroke</b>
class named <b>registerSubclass</b>.&nbsp; A description of  this method
is given in Figure 4.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>void <b>registerSubclass</b>(Class&nbsp;subclass)<br><br>Registers a new class which the factory <br>methods in AWTKeyStroke will use when <br>generating new instances of AWTKeyStrokes.<br>After invoking this method, the factory <br>methods will return instances of the <br>specified Class. The specified Class must <br>be either AWTKeyStroke or derived from <br>AWTKeyStroke, and it must have a no-arg <br>constructor. The constructor can be of any<br>accessibility, including private. This <br>operation flushes the current AWTKeyStroke <br>cache.<br><br>Parameters:<br>subclass - the new Class of which the <br>factory methods should create instances <br><br><b>Figure 4</b></pre>
      </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Registration is the key</b></font></p>
 
<p>In other words, if you extend the <b>AWTKeyStroke</b> class into a new
class, you should invoke the <b>registerSubclass</b> method of the <b>AWTKeyStroke</b>
class at least once in your program to cause the <b>getAWTKeyStroke</b> method
of the <b>AWTKeyStroke</b> class to return an instance of your new class
instead of returning an instance of the <b>AWTKeyStroke</b> class.</p>
 
<blockquote>
  <p><i>(We will learn later that even in the default case, the <b>getAWTKeyStroke</b>
method doesn't actually return a reference to an object of the <b>AWTKeyStroke</b>
class.  Rather, it returns a reference to an instance of a subclass of the
  <b>AWTKeyStroke</b> class.)</i></p>
 </blockquote>
<p><font color="#ff0000"><b>The registration method</b></font></p>
 
<p>And that brings us to Listing 11, which defines a convenience method of
the <b>MyAWTKeyStroke</b> subclass designed to register the subclass on the
factory methods of the <b>AWTKeyStroke</b> class.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  static void <b>registerIt</b>(){<br>    try{<br>      registerSubclass(Class.forName(<br>                              "MyAWTKeyStroke"));<br>    }catch(Exception ex){System.out.println(ex);}<br>  }//end registerIt<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p> The <b>registerIt</b> method of the <b>MyAWTKeyStroke</b> class registers
the subclass with the factory methods of the <b>AWTKeyStroke</b> class, causing
the factory methods of that class to return a reference to an instance of
the subclass.</p>
<p> The code in Listing 11 invokes the static registration method of the
<b>AWTKeyStroke </b>class, passing a reference to a <b>Class</b> object representing
the <b>MyAWTKeyStroke </b>class as a parameter.</p>
<p> <font color="#ff0000"><b>Not a Comparable interface issue</b></font></p>
<p> Note that this requirement for registration results from extending the
<b>AWTKeyStroke</b> class, and has nothing to do with implementing the <b>Comparable</b>
interface, which is the reason that I extended the class in the first place.</p>
<p> <font color="#ff0000"><b>The Comparable interface</b></font></p>
<p>Here is a little of what Sun has to say about the <b>Comparable</b> interface:</p>
<blockquote>
  <p> <i>"This interface imposes a total ordering on the objects of each
class that implements it. This ordering is referred to as the class's natural
ordering, and the class's <b>compareTo</b> method is referred to as its natural
comparison method."</i></p>
</blockquote>
<p> <font color="#ff0000"><b>The compareTo method</b></font></p>
<p> Any non-abstract class that implements the <b>Comparable</b> interface
must provide a concrete definition of the method named</p>
<pre><b>compareTo(Object o)</b></pre>
<p> Here is a little of what Sun has to say about the <b>compareTo</b> method:</p>
<blockquote>
  <p> <i>"Compares this object with the specified object for order. Returns
a negative integer, zero, or a positive integer as this object is less than,
equal to, or greater than the specified object."</i></p>
</blockquote>
<p> <font color="#ff0000"><b>My compareTo method</b></font></p>
<p> Listing 12 defines the overridden<b> compareTo</b> method for the <b>MyAWTKeyStroke</b>
class.  The comparison is based on the <b>String</b> representation of the
two objects, using the version of the <b>compareTo</b> method defined in
the <b>String</b> class to perform the actual comparison.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public int compareTo(Object o){<br>    String str1 = this.toString();<br>    String str2 = o.toString();<br>    return str1.compareTo(str2);<br>  }//end compareTo<br>}//end MyAWTKeyStroke<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> That completes the discussion of the class named <b>MyAWTKeyStroke</b>,
which extends <b>AWTKeyStroke</b>, and implements <b>Comparable</b>.</p>
<p> <font color="#ff0000"><b>The action listener class</b></font></p>
<p> Listing 13 shows the beginning of the inner class named <b>MyActionListener</b>,
which is used to instantiate and register an action listener object on the
two leftmost buttons shown in Figure 1.  This class is an inner class of
the class named <b>GUI</b>.</p>
<p> Listing 13 also shows the beginning of the <b>actionPerformed</b> method,
which is required of any class that implements the <b>ActionListener</b>
interface.  This is the method that is invoked whenever the user clicks on
the <b>Change</b> button or the <b>Restore</b> button in Figure 1.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  class MyActionListener<br>                       implements ActionListener{<br><br>    public void actionPerformed(ActionEvent e){<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>Registering the subclass on the factory methods</b></font></p>
<p> The <b>actionPerformed</b> method begins by invoking the <b>registerIt</b>
method discussed above to cause an object of the <b>MyAWTKeyStroke</b> class
to be returned when the <b>getAWTKeyStroke</b> method is invoked later. 
This code is shown in Listing 14 <i>(The convenience class named <b>registerIt</b>
is defined in Listing 11.)</i><br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      MyAWTKeyStroke.registerIt();<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>Display the current focus traversal keys for
the text field</b></font></p>
<p> Next,  the code in Listing 15 uses methods and constants discussed earlier
to get and display the current focus traversal keys for the text field.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      System.out.println(<br>                 "Current focus-traversal keys");<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        FORWARD_TRAVERSAL_KEYS));<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       BACKWARD_TRAVERSAL_KEYS));<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>The default focus traversal keys</b></font></p>
<p> The first time either of the left-most buttons in Figure 1 is pressed,
the output shown in Figure 5 is produced by the code in Listing 15.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Current focus-traversal keys<br>[keyCode CtrlTab-P, keyCode Tab-P]<br>[keyCode Ctrl+ShiftTab-P, keyCode ShiftTab-P]<br><br><b>Figure 5</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>What you are seeing in Figure 5 is the default focus traversal keys for
the text field, before any changes have been made to those keys.  If you
compare this with the defaults for a Windows operating system discussed earlier,
you will see that there is a match.</p>
 
<p><font color="#ff0000"><b>When the Change button is pressed ...</b></font></p>
 
<p>At this point, the <b>actionPerformed</b> method needs to determine which
button was pressed, <i>(the <b>Change</b> button or the <b>Restore</b> button),</i>
and to take the action appropriate for that button.</p>
 
<p>Listing 16 shows the beginning of the action taken for the case where
the <b>Change</b> button was pressed.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      if(e.getActionCommand().equals("Change")){<br>        forwardSet = new TreeSet();<br>        backwardSet = new TreeSet();<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p> <font color="#ff0000"><b>Create two new Set objects</b></font></p>
<p> When the <b>Change</b> button is pressed, the code in Listing 16 instantiates
two new <b>TreeSet</b> objects and stores their references in a pair of instance
variables that were declared in Listing 2.</p>
<p> As you can probably guess from the variable names, one of these <b>Set</b>
objects will be used to store keystrokes for forward traversal, and the other
will be used to store keystrokes for backward traversal.</p>
<p> <font color="#ff0000"><b>Populate the Set objects</b></font></p>
<p> The next task is to populate each of the new <b>Set</b> objects with
the keystrokes that will be used for traversal in the forward and backward
directions. It is important to note that any number of different keystrokes
can be encapsulated in the set.  In this program, I elected to encapsulate
two different keystrokes for each direction of traversal.</p>
<p> <font color="#ff0000"><b>Add two AWTKeyStroke objects to one set</b></font></p>
<p> The code in Listing 17 uses the <b>add</b> method of the <b>TreeSet</b>
class along with the <b>getAWTKeyStroke</b> factory method discussed earlier,
to encapsulate two different keystrokes in the set for forward traversal.
 The objects encapsulated in the set are instances of the class <b>MyAWTKeyStroke</b>,
<i>(as a result of the registration discussed earlier).</i><br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        //Create and add two keystrokes for<br>        // forward traversal - lower or upper<br>        // case F on key pressed.  Uses factory<br>        // method to return an instance of the<br>        // registered subclass.<br>        forwardSet.add(AWTKeyStroke.<br>                       getAWTKeyStroke(<br>                         KeyEvent.VK_F,0,false));<br><br>        forwardSet.add(AWTKeyStroke.<br>                  getAWTKeyStroke(<br>                    KeyEvent.VK_F,<br>                      InputEvent.SHIFT_DOWN_MASK,<br>                                         false));<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> There are two statements in Listing 17.  The first statement encapsulates
a lower-case <b>f</b> in the set, while the second statement encapsulates
an upper-case <b>F</b> in the set.  In both cases, the traversal action will
occur when the key is pressed and not when it is released.</p>
<p> <font color="#ff0000"><b>Add two AWTKeyStroke objects to the other set</b></font></p>
<p> In a similar manner, the code in Listing 18 encapsulates two keystrokes
in the set that will be used for backward traversal out of the text field
component.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        //Create and add two keystrokes for<br>        // backward traversal - lower case b on<br>        // key released and upper case B on key<br>        // pressed.<br>        backwardSet.add(AWTKeyStroke.<br>                        getAWTKeyStroke(<br>                          KeyEvent.VK_B,0,true));<br><br>        backwardSet.add(AWTKeyStroke.<br>                  getAWTKeyStroke(<br>                    KeyEvent.VK_B,<br>                      InputEvent.SHIFT_DOWN_MASK,<br>                                         false));<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> In this case, the keystrokes are the lower and upper-case versions of
the character <b>B</b>. However, in this case, the traversal action is designed
to occur on key release instead of key press for the lower-case <b>b</b>.
As before, the traversal action is designed to occur on key press for the
upper-case <b>B</b>.</p>
<p> <font color="#ff0000"><b>Display keystroke type</b></font></p>
<p> Just to confirm that things are going as planned, the code in Listing
19 gets and displays the type of the first keystroke stored in the forward
set.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        System.out.println("Keystroke type");<br>        System.out.println(forwardSet.first().<br>                                     getClass());<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> The output produced by the code in Listing 19 is shown in Figure 6.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Keystroke type<br>class <b>MyAWTKeyStroke</b>

<b>Figure 6</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Happily, the result is what we expected, confirming that the process of
registering the subclass with the factory method worked properly.</p>
 
<p><font color="#ff0000"><b>Get an unmodifiable view</b></font></p>
 
<p> At this point, it would be technically possible to use the populated
objects of the <b>TreeSet</b> class to modify the <b>focusTraversalKeys</b>
property of the text field.  However, it is better programming practice to
get an unmodifiable view object for each <b>TreeSet</b> object and to use
those view objects to set the new property values.</p>
<p> The code in Listing 20 uses the <b>unmodifiableSortedSet</b> method of
the <b>Collections</b> class to accomplish this.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        Set unmodifiableForwardSet = Collections.<br>                           unmodifiableSortedSet(<br>                                     forwardSet);<br><br>        Set unmodifiableBackwardSet =Collections.<br>                           unmodifiableSortedSet(<br>                                    backwardSet);<br><br><b><font
 face="Courier New,Courier">Listing 20</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>Display type of unmodifiable set</b></font></p>
<p> Just to make certain that everything is still going according to plan,
the code in Listing 21 gets and displays the actual type of one of the view
objects.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        //Get and display type of unmodifiable<br>        // set<br>        System.out.println("Type of set");<br>        System.out.println(<br>                          unmodifiableForwardSet.<br>                                     getClass());<br><br><b><font
 face="Courier New,Courier">Listing 21</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> The output produced by Listing 21 is shown in Figure 7.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Type of set<br>class java.util.Collections$<b>UnmodifiableSortedSet</b>

<b>Figure 7</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Happily again, the result matches our expectation, so things must be going
well.</p>
 
<p><font color="#ff0000"><b>Modify the focusTraversalKeys property</b></font></p>
 
<p> Finally, Listing 22 shows the code that actually modifies the <b>focusTraversalKeys</b>
property values for the text field.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       FORWARD_TRAVERSAL_KEYS,<br>                         unmodifiableForwardSet);<br><br>        textField.setFocusTraversalKeys(<br>                    DefaultKeyboardFocusManager.<br>                      BACKWARD_TRAVERSAL_KEYS,<br>                        unmodifiableBackwardSet);<br><br><br><b><font
 face="Courier New,Courier">Listing 22</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> There are two statements in Listing 22.  The first statement sets the
value of the indexed <b>focusTraversalKeys</b> property corresponding to
forward traversal. </p>
<p> The second statement sets the value of the indexed <b>focusTraversalKeys</b>
property corresponding to backwards traversal.</p>
<p> In each case, the property value is set to refer to one of the unmodifiable
set objects created in Listing 20.</p>
<p> <font color="#ff0000"><b>Display new focus traversal keys</b></font></p>
<p> Although we haven't seen it yet, there is some code at the end of this
action event handler method that displays the new focus traversal keys. 
For the case where the event handler was invoked because the <b>Change</b>
button was pressed, the output produced by that code is shown in Figure 8.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>New focus-traversal keys<br>[keyCode ShiftF-P, keyCode F-P]<br>[keyCode ShiftB-P, keyCode B-R]<br><br><b>Figure 8</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>This output shows the new focus traversal keys for the forward direction
to be lower and upper-case <b>F</b> on key pressed.</p>
 
<p>The output shows the new focus traversal keys for the backward direction
to upper-case <b>B</b> on key pressed, and lower-case <b>b</b> on key released.</p>
 
<p>These results are exactly what we expected them to be.</p>
 
<p> That completes the discussion of the result of pressing the Change button.</p>
<p> <font color="#ff0000"><b>Pressing the Restore button</b></font></p>
<p> Listing 23 shows the action that results from pressing the <b>Restore</b>
button.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      }else{<br>        //If the Restore button was clicked,<br>        // restore the original focus properties<br>        // on the text field<br>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                          FORWARD_TRAVERSAL_KEYS,<br>                                  oldForwardSet);<br>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                         BACKWARD_TRAVERSAL_KEYS,<br>                                 oldBackwardSet);<br>      }//end else<br><br><b><font
 face="Courier New,Courier">Listing 23</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> This action is very straightforward.  In this case, the two values of
the indexed <b>focusTraversalKeys</b> property are simply restored to the
default values that were saved earlier.</p>
<p> <font color="#ff0000"><b>Display the focus traversal keys</b></font></p>
<p> For the case where the <b>Restore</b> button is pressed after first pressing
the <b>Change</b> button, the forward and backward focus traversal keys on
entry to the action event handler method are shown in Figure 9.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Current focus-traversal keys<br>[keyCode ShiftF-P, keyCode F-P]<br>[keyCode ShiftB-P, keyCode B-R]<br><br><b>Figure 9</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>For the same case, the forward and backward focus traversal keys on exit
from the action event handler method are shown in Figure 10.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>New focus-traversal keys<br>[keyCode Tab-P, keyCode CtrlTab-P]<br>[keyCode ShiftTab-P, keyCode Ctrl+ShiftTab-P]<br><br><b>Figure 10</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p>Just for the record, Listing 24 shows the code that displays the focus
traversal keys on exit from the action event handler method.  There is nothing
new in this code, so I won't discuss it further.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      System.out.println(<br>                     "New focus-traversal keys");<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        FORWARD_TRAVERSAL_KEYS));<br><br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       BACKWARD_TRAVERSAL_KEYS));<br>    }//end actionPerformed<br>  }//end class MyActionListener<br>  //-------------------------------------------//<br>}//end class GUI<br><br><b><font
 face="Courier New,Courier">Listing 24</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p> <font color="#ff0000"><b>The program named FocusKeys02</b></font></p>
<p> Before leaving the topic of focus traversal keys, I want to provide a
brief discussion of the program named <b>FocusKeys02</b>.  This program uses
the <b>AWTKeyStroke</b> class directly and implements the <b>Comparator</b>
interface instead of extending the <b>AWTKeyStroke</b> class and implementing
the <b>Comparable</b> interface.</p>
<p> A complete listing of <b>FocusKeys02</b> can be viewed in Listing 30
near the end of the lesson.  I will show and discuss a few code fragments
from this program that differ from the similar parts of the program named
<b>FocusKeys01</b>.</p>
<p> <font color="#ff0000"><b>Two TreeSet objects</b></font></p>
<p> The code fragment in Listing 25 comes from the inner class used to create
an action listener object that is registered on the two left-most buttons
in Figure 1.</p>
<p> The code shows the creation of two new <b>TreeSet</b> objects for the
case where the user has pressed the <b>Change</b> button.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  class MyActionListener<br>                      implements ActionListener{<br><br>    public void actionPerformed(ActionEvent e){<br><br>      // ... code deleted for brevity<br><br>      if(e.getActionCommand().equals("Change")){<br>        forwardSet = new TreeSet(<br>         <b>         new AWTKeyStrokeComparator()</b>);<br>        backwardSet = new TreeSet(<br>         <b>         new AWTKeyStrokeComparator()</b>);<br><br><b><font
 face="Courier New,Courier">Listing 25</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>Using a Comparator</b></font></p>
<p> The important thing to note in Listing 25 is the use of the <b>TreeSet</b>
constructor that requires a reference to an object instantiated from a class
that implements the <b>Comparator</b> interface. <i>(I will show you the
definition of that class later.)</i> The <b>Comparator</b> object is used
by the <b>add</b> method of the <b>TreeSet</b> object to reject duplicates
and to sort the contents of the set.</p>
<p> <font color="#ff0000"><b>The getAWTKeyStroke method again</b></font></p>
<p> As is the case for <b>FocusKeys01</b>, this program uses the<b> getAWTKeyStroke</b>
method<b> </b>to create the keystrokes used to populate the two sets for
forward and backward traversal.</p>
<p> Listing 26 shows the code that populates the set for forward traversal.
 As before, the new forward traversal keys are lower-case and upper-case
<b>F</b>.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        forwardSet.add(AWTKeyStroke.<br>              <b>        getAWTKeyStroke</b>(<br>                        KeyEvent.VK_F,0,false));<br><br>        forwardSet.add(AWTKeyStroke.<br>          <b>       getAWTKeyStroke</b>(<br>                   KeyEvent.VK_F,<br>                     InputEvent.SHIFT_DOWN_MASK,<br>                                        false));<br><br><b><font
 face="Courier New,Courier">Listing 26</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> <font color="#ff0000"><b>No registration required</b></font></p>
<p> Unlike the case in the program named <b>FocusKeys01</b>, this program
does not extend the <b>AWTKeyStroke</b> class into a new class that implements
the <b>Comparable</b> interface.  Thus, there is no requirement to register
a subclass with the factory methods of the <b>AWTKeyStroke</b> class.</p>
<p> <font color="#ff0000"><b>Get and display the keystroke object type</b></font></p>
<p> This causes us to wonder about the actual type of object that is returned
when the <b>getAWTKeyStroke</b> method is invoked in Listing 26.  The answer
to that question is provided by the code in Listing 27.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>        System.out.println("Keystroke type");<br>        System.out.println(forwardSet.first().<br>                                    getClass());<br><br><b><font
 face="Courier New,Courier">Listing 27</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> The code in Listing 27 gets and displays the type of the object stored
in the first element of the forward set.  The output produced by Listing
27 is shown in Figure 11.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
 <tbody>
    <tr>
 <td> 
      <pre>Keystroke type<br>class javax.swing.<b>KeyStroke</b>

<b>Figure 11</b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Interestingly, even in this case, the type of the object that represents
the keystroke is not <b>AWTKeyStroke</b>.  Rather, it is type <b>KeyStroke</b>,
which is the only known subclass of <b>AWTKeyStroke</b> in version 1.4. <i>(For
the record, the <b>KeyStroke</b></i> <i>class does not implement <b>Comparable</b>.)</i></p>
 
<p><font color="#ff0000"><b>What does Sun have to say?</b></font></p>
 
<p>The documentation describes the <b>KeyStroke</b> class very similarly
to the description of the <b>AWTKeyStroke</b> class, and there is no obvious
indication as to why it is the better choice between the two.  However, the
constructors for the <b>AWTKeyStroke</b> class are <b>protected</b>.  Therefore,
an object of type <b>AWTKeyStroke</b> can only be created by creating an
instance of a subclass of <b>AWTKeyStroke</b>.</p>
 
<p><font color="#ff0000"><b>Set focusTraversalKeys property values</b></font></p>
 
<p>As in the case of <b>FocusKeys01</b>, the code goes on to get unmodifiable
views of the populated sets, and uses those view objects to modify the values
stored in the indexed property named <b>focusTraversalKeys</b>.</p>
 
<p><font color="#ff0000"><b>A Comparator object</b></font></p>
 
<p>That brings us to the class of my own design named <b>AWTKeyStrokeComparator</b>.
 This class implements the <b>Comparator </b>interface.  Objects of this
class were passed to the constructors for the<b> TreeSet</b> objects in Listing
25.  The <b>Comparator</b> objects are used by the <b>add</b> method of the
<b>TreeSet</b> objects to reject duplicates and to sort the contents of the
set.</p>
 
<p><font color="#ff0000"><b>The compare method</b></font></p>
 
<p>A class that implements the <b>Comparator</b> interface must define a
method named <b>compare</b>.  As the name implies, this is the method belonging
to the object that is actually used to compare two objects.</p>
 
<p>Here is part of what Sun has to say about the <b>Comparator</b> interface:</p>
 
<blockquote>
  <p><i>"A comparison function, which imposes a total ordering on some collection
of objects. Comparators can be passed to a sort method (such as Collections.sort)
to allow precise control over the sort order. Comparators can also be used
to control the order of certain data structures (such as <b>TreeSet</b> or
TreeMap)."</i></p>
 </blockquote>
<p> <font color="#ff0000"><b>The AWTKeyStrokeComparator class</b></font></p>
<p> The entire class named <b>AWTKeyStrokeComparator</b> is shown in Listing
28.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>class AWTKeyStrokeComparator<br>                          implements Comparator{<br><br>  public int <b>compare</b>(Object o1,Object o2){<br>    return o1.toString().<br>                       compareTo(o2.toString());<br>  }//end compare<br><br>}//end AWTKeyStrokeComparator<br><br><b><font
 face="Courier New,Courier">Listing 28</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p> As in the program named <b>FocusKeys01</b>, I made the comparison between
the two objects based on the <b>String</b> representation of the objects.
 Once again, I took advantage of the <b>compareTo</b> method of the <b>String</b>
class to accomplish the comparison.</p>
<p> <font color="#ff0000"><b>The equals method</b></font></p>
<p> Interestingly, the <b>Comparator</b> interface also declares an <b>equals</b>
method with a signature identical to the <b>equals</b> method that every
class inherits from the <b>Object</b> class.  Therefore, the requirement
to provide a definition of the <b>equals</b> method of the <b>Comparator</b>
interface is technically satisfied by the inherited <b>equals</b> method.</p>
<p> The Sun documentation contains the following statement:</p>
<blockquote>
  <p> <i>"Note that it is always safe not to override Object.equals(Object).
However, overriding this method may, in some cases, improve performance by
allowing programs to determine that two distinct Comparators impose the same
order."</i></p>
</blockquote>
<p> In this case, I elected not to override the <b>equals</b> method.</p>
<center> 
<h2> <a name="Run the program"></a>Run the Program</h2>
</center>
 
<p>If you haven't already done so, I encourage you to copy the code from
Listing 29 or Listing 30 into your text editor, compile it, and execute it.&nbsp;
Experiment with it, pressing buttons and keys, and observing the results
of your actions.<br>
</p>
<p>Remember, however, that you must be running Java version 1.4 or later to
compile and execute this program.</p>
<p><font color="#ff0000"><b>Operational behavior</b></font></p>
<p>When the program first starts running, successive presses of the TAB key
should cause the focus to traverse from left to right across all four components,
including the text field.  Similarly, pressing Shift-TAB should cause the
focus to traverse across all four components in reverse order.</p>
<p><font color="#ff0000"><b>The key event handler</b></font></p>
<p>When the program is in this state and the text field has the focus, pressing
just about any key on the keyboard <i>(other than TAB),</i> will deliver
a key event to the key event handler.</p>
<p>The key event handler will display an identification of the key that was
pressed.  As mentioned earlier, the key event associated with the TAB key
is consumed and is not delivered to the event handler because the TAB key
is a focus traversal key.</p>
<p><font color="#ff0000"><b>Changing the focus traversal keys</b></font></p>
<p>Pressing the <b>Change</b> button causes the focus traversal keys for
the text field to change <i>(the focus traversal keys for the buttons remain
the same as before).</i> </p>
<p>As described earlier, the new forward focus traversal keys for the text
field are lower-case and upper-case <b>F</b>.  The new backward focus traversal
keys for the text field are lower-case and upper-case <b>B</b>.</p>
<p>In addition, the traversal action for lower-case <b>b</b> occurs on key
released instead of key pressed.</p>
<p><font color="#ff0000"><b>The key event handler</b></font></p>
<p>When the program is in this state and the text field has the focus, pressing
just about any key on the keyboard <i>(other than f, F, b, or B),</i> will
deliver a key event to the key event handler.  This includes the TAB key,
because it is no longer a focus traversal key. <i>(Note, however, that the
text field shows no indication that the TAB key has been pressed.)</i></p>
<p>As before, the key event handler displays the identification of the key.</p>
<p>Also as before, when any of the focus traversal keys <i>(f, F, b, or B)</i>
are pressed, the key event associated with the key press is consumed and
the event is not delivered to the key event handler.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
 
<p>In this lesson, I have taught you two different ways to change the focus
traversal keys on an individual component at runtime.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
   
<p>Future lessons will discuss new focus features of version 1.4 including
the following:</p>
 
<ul>
  <li>The KeyEventDispatcher interface</li>
  <li>The KeyEventPostProcessor interface</li>
  <li>FocusEvent and WindowEvent</li>
  <li>Event delivery</li>
  <li>Opposite components</li>
  <li>Temporary focus events</li>
  <li>Programmatic focus traversal</li>
  <li>Focus and PropertyChangeListener</li>
  <li>Focus and VetoableChangeListener </li>
</ul>
<center> 
<h2> <a name="Complete Program Listings"></a>Complete Program Listing</h2>
</center>
 Complete listings of the programs discussed in this lesson are shown in
Listings 29 and 30 below.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>/* File FocusKeys01.java<br>Copyright 2003, R.G.Baldwin<br><br>Illustrates the ability to change the focus<br>traversal keys.  Also illustrates that a<br>component does not multicast a key event when it<br>has the focus and a focus traversal key is<br>pressed.<br><br>This version implements the comparable interface<br>to allow new focus traversal keys to be added to<br>a set.<br><br>Tested using JDK 1.4.1 under WinXP<br><br>This program requires v1.4.0 or later to compile<br>and run correctly.<br>************************************************/<br><br>import javax.swing.*;<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.util.*;<br><br>class FocusKeys01{<br>  public static void main(String[] args){<br>    new GUI();<br>  }// end main<br>}//end class FocusKeys01 definition<br>//=============================================//<br><br>class GUI{<br>  JFrame jFrame = new JFrame();<br>  TreeSet forwardSet;<br>  TreeSet backwardSet;<br>  JTextField textField;<br>  Set oldForwardSet;<br>  Set oldBackwardSet;<br><br>  GUI(){//constructor<br>    jFrame.setTitle(<br>                  "Copyright 2003, R.G.Baldwin");<br>    jFrame.setDefaultCloseOperation(<br>                           JFrame.EXIT_ON_CLOSE);<br><br>    JPanel panel = new JPanel();<br>    JButton changeBtn = new JButton("Change");<br>    JButton restoreBtn = new JButton("Restore");<br>    JButton dummyBtn = new JButton("Dummy");<br>    textField = new JTextField("abcde");<br><br>    //Register a key listener on the text field<br>    // to illustrate the relationship between<br>    // focus traversal keys and key events.<br>    textField.addKeyListener(<br>      new KeyAdapter(){<br>        public void keyPressed(KeyEvent e){<br>          System.out.println(e.getKeyText(<br>                            e.getKeyCode()));}});<br><br>    //Save the default text field traversal keys<br>    // for later restoration.<br>    oldForwardSet = textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                         FORWARD_TRAVERSAL_KEYS);<br>    oldBackwardSet = textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        BACKWARD_TRAVERSAL_KEYS);<br><br>    //Get and display the type of the set object<br>    // containing default focus traversal keys.<br>    System.out.println("Type of set");<br>    System.out.println(oldForwardSet.getClass());<br><br>    //Create and register an action listener on<br>    // two of the buttons.  The third button is<br>    // an inactive button used solely to<br>    // illustrate focus traversal.<br>    MyActionListener listener =<br>                          new MyActionListener();<br>    changeBtn.addActionListener(listener);<br>    restoreBtn.addActionListener(listener);<br><br>    //Add a panel to the frame.  Then add the<br>    // buttons and the text field to the panel.<br>    jFrame.getContentPane().add(<br>                      panel,BorderLayout.CENTER);<br><br>    panel.add(changeBtn);<br>    panel.add(restoreBtn);<br>    panel.add(textField);<br>    panel.add(dummyBtn);<br><br>    //Set the size of the frame and make it<br>    // visible.<br>    jFrame.setSize(400,100);<br>    jFrame.setVisible(true);<br><br>  }//end constructor<br>  //-------------------------------------------//<br><br>  //This is an inner class, used to create an<br>  // action listener for two of the buttons.<br>  class MyActionListener<br>                       implements ActionListener{<br><br>    public void actionPerformed(ActionEvent e){<br><br>      //Register the named class with the factory<br>      // methods of the AWTKeyStroke class.<br>      MyAWTKeyStroke.registerIt();<br>      //Display the existing focus traversal<br>      // keystrokes on the text field.<br>      System.out.println(<br>                 "Current focus-traversal keys");<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        FORWARD_TRAVERSAL_KEYS));<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       BACKWARD_TRAVERSAL_KEYS));<br><br>      //Identify source button and take<br>      // appropriate action.<br>      if(e.getActionCommand().equals("Change")){<br>        //If the Change button was clicked,<br>        // create new set objects to contain the<br>        // new focus traversal keys.<br>        forwardSet = new TreeSet();<br>        backwardSet = new TreeSet();<br><br>        //Create and add two keystrokes for<br>        // forward traversal - lower or upper<br>        // case F on key pressed.  Uses factory<br>        // method to return an instance of the<br>        // registered subclass.<br>        forwardSet.add(AWTKeyStroke.<br>                       getAWTKeyStroke(<br>                         KeyEvent.VK_F,0,false));<br>        forwardSet.add(AWTKeyStroke.<br>                  getAWTKeyStroke(<br>                    KeyEvent.VK_F,<br>                      InputEvent.SHIFT_DOWN_MASK,<br>                                         false));<br><br>        //Create and add two keystrokes for<br>        // backward traversal - lower case b on<br>        // key released and upper case B on key<br>        // pressed.<br>        backwardSet.add(AWTKeyStroke.<br>                        getAWTKeyStroke(<br>                          KeyEvent.VK_B,0,true));<br>        backwardSet.add(AWTKeyStroke.<br>                  getAWTKeyStroke(<br>                    KeyEvent.VK_B,<br>                      InputEvent.SHIFT_DOWN_MASK,<br>                                         false));<br><br>        //Get and display actual keystroke type<br>        System.out.println("Keystroke type");<br>        System.out.println(forwardSet.first().<br>                                     getClass());<br><br>        //Get unmodifiable views of the two sets.<br>        // Note that this is not strictly<br>        // required but is highly desirable.<br>        Set unmodifiableForwardSet = Collections.<br>                           unmodifiableSortedSet(<br>                                     forwardSet);<br>        Set unmodifiableBackwardSet =Collections.<br>                           unmodifiableSortedSet(<br>                                    backwardSet);<br><br>        //Get and display type of unmodifiable<br>        // set<br>        System.out.println("Type of set");<br>        System.out.println(<br>                          unmodifiableForwardSet.<br>                                     getClass());<br><br>        //Set the focus properties on the text<br>        // field to the new focus-traversal<br>        // keystrokes.<br>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       FORWARD_TRAVERSAL_KEYS,<br>                         unmodifiableForwardSet);<br>        textField.setFocusTraversalKeys(<br>                    DefaultKeyboardFocusManager.<br>                      BACKWARD_TRAVERSAL_KEYS,<br>                        unmodifiableBackwardSet);<br><br>      }else{<br>        //If the Restore button was clicked,<br>        // restore the original focus properties<br>        // on the text field<br>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                          FORWARD_TRAVERSAL_KEYS,<br>                                  oldForwardSet);<br>        textField.setFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                         BACKWARD_TRAVERSAL_KEYS,<br>                                 oldBackwardSet);<br>      }//end else<br><br>      //Display the new focus traversal<br>      // keys.<br>      System.out.println(<br>                     "New focus-traversal keys");<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                        FORWARD_TRAVERSAL_KEYS));<br>      System.out.println(textField.<br>                   getFocusTraversalKeys(<br>                     DefaultKeyboardFocusManager.<br>                       BACKWARD_TRAVERSAL_KEYS));<br>    }//end actionPerformed<br>  }//end class MyActionListener<br>  //-------------------------------------------//<br>}//end class GUI<br>//=============================================//<br><br>//An object of this class is suitable for adding<br>// to a set because it implements the Comparable<br>// interface.<br>class MyAWTKeyStroke extends AWTKeyStroke<br>                           implements Comparable{<br><br>  //This method registers this subclass with the<br>  // factory methods of the AWTKeyStroke class,<br>  // causing the factory methods to return a<br>  // reference to an instance of this subclass.<br>  static void registerIt(){<br>    //Invoke the static registration method<br>    // passing a Class object representing this<br>    // class as a parameter.<br>    try{<br>      registerSubclass(Class.forName(<br>                              "MyAWTKeyStroke"));<br>    }catch(Exception ex){System.out.println(ex);}<br>  }//end registerIt<br><br>  //Define the compareTo method that is declared<br>  // in the Comparable interface.  Base the<br>  // comparison on the String representation of<br>  // the two objects.<br>  public int compareTo(Object o){<br>    String str1 = this.toString();<br>    String str2 = o.toString();<br>    return str1.compareTo(str2);<br>  }//end compareTo<br>}//end MyAWTKeyStroke<br><br><b><font
 face="Courier New,Courier">Listing 29</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p>    <br>
&nbsp;</p>
<p>    
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>/* File FocusKeys02.java<br>Copyright 2003, R.G.Baldwin<br><br>Illustrates the ability to change the<br>focus traversal keys.  Also illustrates<br>that a component does not multicast a<br>key event when it has the focus and a<br>focus traversal key is pressed.<br><br>This version implements the Comparator<br>interface to allow new focus traversal<br>keys to be added to a set.  See<br>Focus01 for a version that uses the<br>Comparable interface.<br><br>Tested using JDK 1.4.1 under WinXP.<br><br>This program requires v1.4.0 or later<br>to compile and run correctly.<br>**************************************/<br><br>import javax.swing.*;<br>import javax.swing.border.*;<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.util.*;<br><br>class FocusKeys02{<br>  public static void main(<br>                        String[] args){<br>    new GUI();<br>  }// end main<br>}//end class FocusKeys02 definition<br>//===================================//<br><br>class GUI{<br>  JFrame jFrame = new JFrame();<br>  TreeSet forwardSet;<br>  TreeSet backwardSet;<br>  JTextField textField;<br>  Set oldForwardSet;<br>  Set oldBackwardSet;<br><br>  GUI(){//constructor<br>    jFrame.setDefaultCloseOperation(<br>                 JFrame.EXIT_ON_CLOSE);<br><br>    JPanel panel = new JPanel();<br>    JButton changeBtn =<br>                 new JButton("Change");<br>    JButton restoreBtn =<br>                new JButton("Restore");<br>    JButton dummyBtn =<br>                  new JButton("Dummy");<br>    textField =<br>               new JTextField("abcde");<br><br>    //Register a key listener on the<br>    // text field to illustrate the<br>    // relationship between focus<br>    // traversal keys and key events.<br>    textField.addKeyListener(<br>      new KeyAdapter(){<br>        public void keyPressed(<br>                           KeyEvent e){<br>          System.out.println(<br>                e.getKeyText(<br>                  e.getKeyCode()));}});<br><br>    //Save the default text field<br>    // traversal keys for later<br>    // restoration.<br>    oldForwardSet = textField.<br>          getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>               FORWARD_TRAVERSAL_KEYS);<br>    oldBackwardSet = textField.<br>          getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>              BACKWARD_TRAVERSAL_KEYS);<br><br>    //Get and display the type of the<br>    // set object containing default<br>    // focus traversal keys.<br>    System.out.println("Type of set");<br>    System.out.println(<br>             oldForwardSet.getClass());<br><br>    //Create and register an action<br>    // listener on two of the buttons.<br>    // The third button is an inactive<br>    // button used solely to illustrate<br>    // focus traversal.<br>    MyActionListener listener =<br>                new MyActionListener();<br>    changeBtn.addActionListener(<br>                             listener);<br>    restoreBtn.addActionListener(<br>                             listener);<br><br>    //Add a panel to the frame.  Then<br>    // add the buttons and the text<br>    // field to the panel.<br>    jFrame.getContentPane().add(<br>            panel,BorderLayout.CENTER);<br><br>    panel.add(changeBtn);<br>    panel.add(restoreBtn);<br>    panel.add(textField);<br>    panel.add(dummyBtn);<br><br>    //Set the size of the frame and<br>    // make it visible.<br>    jFrame.setSize(400,100);<br>    jFrame.setVisible(true);<br><br>  }//end constructor<br>  //---------------------------------//<br><br>  //This is an inner class, used to<br>  // create an action listener for two<br>  // of the buttons.<br>  class MyActionListener<br>             implements ActionListener{<br><br>    public void actionPerformed(<br>                        ActionEvent e){<br><br>      //Display the existing focus<br>      // traversal keystrokes on the<br>      // text field.<br>      System.out.println(<br>       "Current focus-traversal keys");<br>      System.out.println(textField.<br>          getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>              FORWARD_TRAVERSAL_KEYS));<br>      System.out.println(textField.<br>          getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>             BACKWARD_TRAVERSAL_KEYS));<br><br>      //Identify source button and take<br>      // appropriate action.<br>      if(e.getActionCommand().equals(<br>                            "Change")){<br>        //If the Change button was<br>        // clicked, create new set<br>        // objects to contain the new<br>        // focus traversal keys.  Use<br>        // the constructor that takes<br>        // a reference to a Comparator.<br>        forwardSet = new TreeSet(<br>         new AWTKeyStrokeComparator());<br>        backwardSet = new TreeSet(<br>         new AWTKeyStrokeComparator());<br><br>        //Create and add two keystrokes<br>        // for forward traversal -<br>        // lower or upper case F on key<br>        // pressed.  Uses factory<br>        // method to return an instance<br>        // of the registered subclass.<br>        forwardSet.add(AWTKeyStroke.<br>              getAWTKeyStroke(<br>               KeyEvent.VK_F,0,false));<br>        forwardSet.add(AWTKeyStroke.<br>          getAWTKeyStroke(<br>           KeyEvent.VK_F,<br>            InputEvent.SHIFT_DOWN_MASK,<br>                               false));<br>        //Create and add two keystrokes<br>        // for backward traversal -<br>        // lower case b on key released<br>        // and upper case B on key<br>        // pressed.<br>        backwardSet.add(AWTKeyStroke.<br>              getAWTKeyStroke(<br>                KeyEvent.VK_B,0,true));<br>        backwardSet.add(AWTKeyStroke.<br>          getAWTKeyStroke(<br>           KeyEvent.VK_B,<br>            InputEvent.SHIFT_DOWN_MASK,<br>                               false));<br><br>        //Get and display actual<br>        // keystroke type<br>        System.out.println(<br>                     "Keystroke type");<br>        System.out.println(<br>                    forwardSet.first().<br>                           getClass());<br><br>        //Get unmodifiable views of the<br>        // two sets.  Note that this<br>        // is not strictly required.<br>        Set unmodifiableForwardSet =<br>               Collections.<br>                 unmodifiableSortedSet(<br>                           forwardSet);<br>        Set unmodifiableBackwardSet =<br>               Collections.<br>                 unmodifiableSortedSet(<br>                          backwardSet);<br><br>        //Get and display type of<br>        // unmodifiable set<br>        System.out.println(<br>                        "Type of set");<br>        System.out.println(<br>                unmodifiableForwardSet.<br>                           getClass());<br><br>        //Set the focus properties on<br>        // the text field to the new<br>        // focus-traversal keystrokes.<br>        textField.<br>           setFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>           FORWARD_TRAVERSAL_KEYS,<br>               unmodifiableForwardSet);<br>        textField.<br>           setFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>           BACKWARD_TRAVERSAL_KEYS,<br>              unmodifiableBackwardSet);<br><br>      }else{<br>        //If the Restore button was<br>        // clicked, restore the<br>        // original focus properties on<br>        // the text field<br>        textField.<br>          setFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>           FORWARD_TRAVERSAL_KEYS,<br>                        oldForwardSet);<br>        textField.<br>          setFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>           BACKWARD_TRAVERSAL_KEYS,<br>                       oldBackwardSet);<br>      }//end else<br><br>      //Display the new focus traversal<br>      // keys.<br>      System.out.println(<br>           "New focus-traversal keys");<br>      System.out.println(textField.<br>         getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>              FORWARD_TRAVERSAL_KEYS));<br>      System.out.println(textField.<br>         getFocusTraversalKeys(<br>           DefaultKeyboardFocusManager.<br>             BACKWARD_TRAVERSAL_KEYS));<br>    }//end actionPerformed<br>  }//end class MyActionListener<br>  //---------------------------------//<br>}//end class GUI<br>//===================================//<br><br>//This class makes it possible to add<br>// objects of type AWTKeyStroke to a<br>// set object, by providing a compare()<br>// method that can be used to compare<br>// two objects of type AWTKeyStroke.<br><br>//An object of this class must be<br>// passed to the constructor for the<br>// set object.  The compare method<br>// defined here is based on the String<br>// representation of the objects.<br>class AWTKeyStrokeComparator<br>                 implements Comparator{<br><br>  public int compare(Object o1,<br>                            Object o2){<br>    return o1.toString().<br>              compareTo(o2.toString());<br>  }//end compare<br><br>  //The Sun docs show an equals()<br>  // method in the description of the<br>  // Comparator interface.  However:<br>  //From the Sun docs: "Note that it is<br>  // always safe not to override<br>  // Object.equals(Object). However,<br>  // overriding this method may, in<br>  // some cases, improve performance by<br>  // allowing programs to determine<br>  // that two distinct Comparators<br>  // impose the same order."<br><br>}//end AWTKeyStrokeComparator<br><br><b><font
 face="Courier New,Courier">Listing 30</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
  </p>
<p> </p>
<hr size="3" width="100%" align="center"> 
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in part
in any form or medium without express written permission from Richard Baldwin
is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
 <i><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a> is a college
professor (at Austin Community College in Austin, TX) and private consultant
whose primary focus is a combination of Java, C#, and XML. In addition to
the many platform and/or language independent benefits of Java and C# applications,
he believes that a combination of Java, C#, and XML will become the primary
driving force in the delivery of structured information on the Web.</i><br>
<p><i>Richard has participated in numerous consulting projects, and he frequently
provides onsite training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.DickBaldwin.com">Tutorials</a>, which has gained a worldwide
following among experienced and aspiring programmers. He has also published
articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and 
has many years of experience in the application of computer technology to
real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
<br>
</body>
</html>
