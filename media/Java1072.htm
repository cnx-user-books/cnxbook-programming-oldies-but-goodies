<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#999999" alink="#FF0000" lang="EN-US">
zz incomplete.&nbsp; Needs:
<br>Listing numbers to replace zz
<br>Editing for Parts 7 &amp; 8
<br>Publication date
<br>Confirm correct img references
<br>Title:&nbsp; Instead of Part 1,2, etc, make titles read Concepts, GUI
Setup, Construction, Inheritance, Interfaces, Properties, Events, &amp;
Methods Refer to previous lessons by name
<br>Confirm: This is the <i>seventh</i> lesson in a miniseries
<br>Spell and grammer check
<br>Final edit.
<h2>
Swing from A to Z:&nbsp; Analyzing Swing<br>
Components, Part 7</h2>
<b>Published</b>&nbsp; zz zz
<br><b>By <a href="mailto:baldwin.richard@iname.com">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1072
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Sample Program">Sample Program</a></li>

<li>
<a href="#Interesting Code Fragments">Interesting Code Fragments</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This series of lessons entitled <i>Swing from A to Z</i>, discusses the
capabilities and features of Swing in quite a lot of detail.&nbsp; This
series is intended for those persons who need to understand Swing at a
detailed level.
<p>This is the seventh lesson in a miniseries discussing the use of introspection
for analyzing <b>Swing</b> components.&nbsp; The first lesson in this miniseries
was entitled <i>Swing from A to Z:&nbsp; Analyzing Swing Components, Part 1, Concepts</i>.&nbsp;
You will find&nbsp; links to all of the lessons in the miniseries at the
following <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">site</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Recommended supplementary reading</font></b>
<p>In an earlier lesson entitled <i>Alignment Properties and BoxLayout,
Part 1</i>, I recommended a list of Swing tutorials for you to study prior
to embarking on a study of this series of lessons.
<p>The lessons identified on that list will introduce you to the use of
Swing while avoiding much of the detail included in this series.
<p><b><font color="#FF0000">Where are the lessons located?</font></b>
<p>You will find those lessons published at <a href="http://gamelan.earthweb.com/dlink.index-jhtml.72.1082.-.43.jhtml">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes my lessons are difficult
to locate there.&nbsp; You will find a consolidated index at
<i>Baldwin's
Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a></i><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at Gamelan.com.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Streamlined Documentation</font></b>
<p><font color="#000000">The lessons in this miniseries discuss a very
useful Java program that supplements the Sun documentation.</font>
<p><font color="#000000">The program provides the following information
about Swing and AWT components:</font>
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<b><font color="#FF0000">Program output</font></b>
<p><font color="#000000">Figure 1 is a screen shot showing the program
output after you start the program and click the <b>OK</b> button.</font>
<center>
<p><img SRC="java1072a.gif" height=521 width=400>
<br><b><font color="#000000">Figure 1.&nbsp; Screen shot showing program
output.</font></b></center>

<p><font color="#000000">The various parts of this GUI have been explained
in the earlier lessons in this miniseries.</font>
<p><b><font color="#FF0000">The program code</font></b>
<p><font color="#000000">In the previous lessons, I have walked you through
the code for this program, up to, and including the code that gets and
displays the properties information in the center-left pane.</font>
<p><font color="#000000">In this lesson, I will discuss the code that gets
and displays the sorted information on events shown in the center-right
pane of Figure 1.</font>
<p><font color="#000000">Subsequent lessons will explain other aspects
of the program.</font>
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
<b><font color="#FF0000">The Class class and the Introspector class</font></b>
<p><font color="#000000">Previous lessons explained the use of the <b>Class</b>
class and the <b>Introspector</b> class to achieve the objectives of this
program.</font>
<p><font color="#000000">This included a discussion of the <b>forName()</b>
and&nbsp; <b>getBeanInfo()</b> methods.</font>
<p><b><font color="#FF0000">Properties, events, and methods</font></b>
<p><font color="#000000">It was explained that an object of the interface
type <b>BeanInfo</b> can be used to obtain important information about
the properties, events, and methods of a target class.&nbsp; This lesson
will be primarily concerned with getting, sorting, and displaying the events
of a target class.</font>
<center>
<h2>
<a NAME="Sample Program"></a><font color="#000000">Sample Program</font></h2></center>
A complete listing of this program, named <b>Introspect03</b> is provided
near the end of the lesson.&nbsp; It is provided here so that you can copy,
compile, and begin using it even before you learn all the details of how
it works.
<center>
<h2>
<a NAME="Interesting Code Fragments"></a><font color="#000000">Interesting
Code Fragments</font></h2></center>
I will break this program down and discuss it in fragments.
<p><b><font color="#FF0000">The actionPerformed() method</font></b>
<p>The code in Listing zz is an abbreviated version of the <b>actionPerformed()</b>
method.&nbsp; Most of the code has been deleted because it is not germane
to this lesson.&nbsp; I discussed all of this code in an earlier lesson.&nbsp;
I am listing it here simply to refresh your memory.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006600">Class <b>targetClassObject</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());

</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000099">beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getBeanInfo</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>targetClassObject</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>doEvents();
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...


<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Getting a Class object</font></b>
<p>The code shown in green gets a <b>Class</b> object representing the
target class and refers to that object in the reference variable named
<b>targetClassObject</b>.
<p>The code shown in blue passes that reference, along with a reference
to the name of the ceiling class, to the method named <b>getBeanInfo()</b>.
<p><b><font color="#FF0000">Getting a BeanInfo object</font></b>
<p>The <b>getBeanInfo()</b> method returns a reference to an object instantiated
from a class that implements the <b>BeanInfo</b> interface.&nbsp; The reference
to the <b>BeanInfo</b> object is stored in the instance variable named
<b>beanInfo</b>.
<p>This object can then be used to obtain information about the properties,
events, and methods of the target class and its superclasses up to, but
not including, the ceiling class.
<p><b><font color="#FF0000">The doEvents() method</font></b>
<p>The method named <b>doEvents()</b> invoked by the <b>actionPerformed()</b>
method is the primary topic of this lesson.
<p>The purpose of the <b>doEvents()</b> method is to get, sort, and display
name and callback method information about the events of the target class
and its superclasses, up to, but not including the ceiling class.
<p>This information is displayed in the right-center scroll pane of Figure
1.
<p><b><font color="#FF0000">More difficult than properties</font></b>
<p>If you take a look at the <b>PROPERTIES</b> pane in the left-center
of Figure 1, you will see that only two pieces of information are&nbsp;
displayed for each property:
<ul>
<li>
The name of the property</li>

<li>
The type of the property</li>
</ul>
However, two or more different pieces of information are sorted and displayed
for each event shown in the right-center pane of Figure 1.&nbsp; This is
because every event type can have one or more callback methods for handling
an occurrence of the event.
<p>Therefore, the code required to get, sort, and display information about
events is a little more complicated than the code required to get, sort,
and display information about properties.
<p><b><font color="#FF0000">Sort on the name only</font></b>
<p>The sort on events is performed only on the name of the event.&nbsp;
It is imperative that the sorting operation keeps the name of the event
and the names of the callback methods together for each event.&nbsp; This
required me to encapsulate the event name and names of the callback methods
for each event into an object of a new class named <b>EventClass</b>, and
to sort the objects on the name of the event only.&nbsp; This in turn caused
me to use a <b>Comparator</b> object to assist in the sorting process.
<i>(The
use of a Comparator object for sorting was explained in the previous lesson.)</i>
<p><b><font color="#FF0000">The EventClass class</font></b>
<p>I am going to begin by discussing the <b>EventClass</b> class from which
I will instantiate objects to encapsulate the name and type of each individual
event.&nbsp; The code in this class definition begins in Listing zz.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">class <b>EventClass</b> implements <b>Comparator</b>{

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Implements Comparator</font></b>
<p>A couple of comments are in order regarding the declaration of the class
shown in Listing zz above.&nbsp; The class implements the <b>Comparator</b>
interface.&nbsp; As a result, it must provide a concrete definition of
the <b>compare()</b> and <b>equals()</b> methods declared in that interface.
<p><b><font color="#FF0000">The compare() method</font></b>
<p>The definition of the <b>compare()</b> method must adhere to the specifications
provided in the interface definition so that it will behave properly when
invoked by the <b>sort()</b> method of the <b>Arrays</b> class.&nbsp; <i>(I
discussed this in detail in the previous lesson.)</i>
<p><b><font color="#FF0000">The equals() method</font></b>
<p>The <b>equals()</b> method isn't actually used in this program, so it
doesn't much matter how it is defined so long as it returns the correct
boolean type.
<p><b><font color="#FF0000">Declaring instance variables</font></b>
<p>The code in Listing zz shows the declaration of two instance variables
that are used to encapsulate information about an event.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private String <b>name</b>;
&nbsp; private Vector <b>lstnrMethods</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new <b>Vector</b>();</font></pre>
</td>
</tr>
</table>

<p>The first declaration above declares a <b>String</b> varible used for
storage of the name of the event.
<p>The second declaration declares a reference variable of type <b>Vector</b>.&nbsp;
The <b>Vector</b> object referred to by this variable is used to store
the names of one or more callback methods associated with a particular
event type.
<p><b><font color="#FF0000">A mouse event example</font></b>
<p>For example, you should be familiar with the fact that a simple mouse
event has the following set of five different callback methods, as declared
in the <b>MouseListener</b> interface:
<ul>
<li>
mousePressed</li>

<li>
mouseReleased</li>

<li>
mouseClicked</li>

<li>
mouseExited</li>

<li>
mouseEntered</li>
</ul>
Thus, when encapsulating information about an event named <b>mouse</b>,
it is also necessary to encapsulate the above list of five callback method
names.&nbsp; Those names will be encapsulated in the <b>Vector</b> object
referred to by <b>lstnrMethods</b> in Listing zz above.
<p><b><font color="#FF0000">Set and get methods</font></b>
<p>Listing zz shows the set and get methods for the class.&nbsp; There
is nothing particularly interesting in this code, so I won't discuss it
further.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; public void <b>setName</b>(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String <b>getName</b>(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void <b>setListenerMethod</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String lstnrMethod){
&nbsp;&nbsp;&nbsp; lstnrMethods.<b>add</b>(lstnrMethod);
&nbsp; }//end setType

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Overridden toString() method</font></b>
<p>Listing zz shows the code for an overridden <b>toString()</b> method
for the class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;
&nbsp; public String <b>toString</b>(){
&nbsp;&nbsp;&nbsp; String theString = name;

&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; lstnrMethods.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theString = theString + "\n&nbsp; " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstnrMethods.elementAt(i);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; return theString;
&nbsp; }//end toString

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>This method creates and returns a string containing the name of the
event and the names of the callback methods for the event in the following
format:
<p>mouse
<br>&nbsp; mousePressed
<br>&nbsp; mouseReleased
<br>&nbsp; mouseClicked
<br>&nbsp; mouseExited
<br>&nbsp; mouseEntered
<p><b><font color="#FF0000">The compare() method</font></b>
<p>Listing zz shows the <b>compare()</b> method that is required because
the class implements the <b>Comparator</b> interface.
<p>This method is essentially the same as the one discussed in the previous
lesson.&nbsp; Suffice it to say that the method compares two objects of
the <b>EventClass</b> type based on the values of the names of the events
<i>(independent
of case and ignoring the names of the callback methods)</i>. The method
returns the required integer value indicating which of the two objects
is greater.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; public int <b>compare</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((EventClass)o1).<b>getName</b>().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>toUpperCase</b>().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;

&nbsp; public boolean <b>equals</b>(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)obj).getName());
&nbsp; }//end equals
}//end EventClass inner class</font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The equals() method</font></b>
<p>Listing zz above also defines the <b>equals()</b> method to satisfy
the requirements of the <b>Comparator</b> interface.&nbsp; However, as
mentioned earlier, this method is not used in this program, so the definition
is not important so long as it returns a boolean in order to satisfy the
compiler.
<p>This implementation reports that two objects of the <b>EventClass</b>
type are <i>equal</i> if the values of the event names are the same for
the two objects.
<p><b><font color="#FF0000">The doEvents() method</font></b>
<p>The <b>doEvents()</b> method is the workhorse of the program insofar
as analyzing the events of a target class is concerned.&nbsp; This method
is invoked when the user clicks the <b>OK</b> button in Figure 1.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; void <b>doEvents</b>(){
&nbsp;&nbsp;&nbsp; Vector <b>eventVector</b> = new Vector();

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>The <b>doEvents()</b> method begins by declaring and instantiating a
<b>Vector</b>
object that will be used for temporary local storage of event information.
<p><b><font color="#FF0000">EventSetDescriptor objects</font></b>
<p>An object of type <b>BeanInfo</b> was instantiated and saved in an instance
variable earlier in the program.&nbsp; This object can be used to obtain
information about the properties, events, and methods of the target class,
and its superclasses up to, but not including the ceiling class.
<p>The code in Listing zz invokes the <b>getEventSetDescriptors()</b> method
on a reference to the <b>BeanInfo</b> object to get a reference to an array
object containing references to objects of the <b>EventSetDescriptor</b>
class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; <b>EventSetDescriptor</b>[] evSetDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getEventSetDescriptors</b>();

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What does Sun have to say about this?</font></b>
<p>Here is what Sun has to say about an object of the <b>EventSetDescriptor</b>
class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td BGCOLOR="#66FFFF">
<pre><font face="Courier New,Courier">An <b>EventSetDescriptor</b> describes a group
of events that a given Java bean fires.&nbsp;

The given group of events are all&nbsp;
delivered as method calls on a single
event listener interface, and an event&nbsp;
listener object can be registered
via a call on a registration method&nbsp;
supplied by the event source.</font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What is a group of events?</font></b>
<p>Sometimes the terminology can be confusing regarding events.&nbsp; In
the above material, Sun is saying that an object of the class <b>EventSetDescriptor</b>
contains information about the group of callback methods declared in a
single listener interface, such as the <b>MouseListener</b> interface.
<p><b><font color="#FF0000">Some overall clarification on events</font></b>
<p>You may recall that all of the callback methods in such a group are
associated with the same <i>type</i> of event, because they all receive
an incoming parameter that is a reference to the same type of event object
<i>(such
as the MouseEvent type)</i>.
<p>In Java, an event is the occurence of something of interest that is
associated with the following:
<ul>
<li>
A Listener interface.</li>

<li>
A Listener object that is instantiated from a class that implements the
Listener interface, and is registered on the source of the event.</li>

<li>
A callback method declared in the interface that is invoked on the Listener
object.</li>

<li>
A class from which an object is instantiated and passed as a parameter
to the callback method.</li>
</ul>
<b><font color="#FF0000">Getting information about events</font></b>
<p>There are a number of methods that can be invoked on an <b>EventSetDescriptor</b>
object to obtain information about the event described by that object.&nbsp;
Important among them are the following methods:
<ul>
<li>
<i>Method</i> <b>getAddListenerMethod(</b>) - Gets the method used to add
event listeners.</li>

<li>
<i>MethodDescriptor[]</i> <b><font color="#000000">getListenerMethodDescriptors()</font></b>
- Gets the MethodDescriptors of the target listener interface.</li>

<li>
<i>Method[]</i> <b>getListenerMethods()</b> - Gets the methods of the target
listener interface.</li>

<li>
<i>Class</i> <b>getListenerType()</b> - Gets the Class object for the target
interface.</li>

<li>
<i>Method</i> <b>getRemoveListenerMethod()</b> - Gets the method used to
remove event listeners.</li>
</ul>
Of these five methods, this program uses only the second one in the list,
<font color="#000000"><b>getListenerMethodDescriptors()</b>.&nbsp;
I mention this to remind you that should you desire to expand the program
to provide additional information when you click the <b>OK</b> button,
there is lots of room for such expansion.</font>
<p><b><font color="#FF0000">Using the EventClass class</font></b>
<p>Listing zz shows the beginning of a <b>for</b> loop that is used to
iterate on the array of <b>EventSetDescriptor</b> objects to extract, sort,
and display the desired information about the events of the target class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; <b>for</b> (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; evSetDescrip.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventClass <b>eventObj</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new <b>EventClass()</b>;

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>The body of the <b>for</b> loop begins by declaring a local variable
that refers to a new object of of the <b>EventClass</b> class discussed
earlier.&nbsp; This object is used to encapsulate information about the
event.
<p><b><font color="#FF0000">The name of the event</font></b>
<p>In addition to the methods defined in the <b>EventSetDescriptor</b>
class, that class inherits a number of methods from its superclasses, including
the class named <b>FeatureDescriptor</b>.&nbsp; One of the inherited methods
is the <b>getName()</b> method that can be used to get the <i>programmatic
name of the feature</i>.
<p>The code in Listing zz invokes the <b>getName()</b> method on an <b>EventSetDescriptor</b>
object to get the name of the event described by that object.&nbsp; That
name is saved in the <b>EventClass</b> object being used to encapsulate
information about the event by invoking the <b>setName()</b> method on
a reference to that object and passing the name as a parameter.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.<b>setName</b>(evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getName</b>());

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">MethodDescriptor objects</font></b>
<p>That brings us to something that is completely new for this series of
lessons.&nbsp; Listing zz invokes the <b>getListenerMethodDescriptors()</b>
method on an <b>EventSetDescriptor</b> object to get a reference to an
array containing references to objects of the class <b>MethodDescriptor</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>MethodDescriptor</b>[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getListenerMethodDescriptors</b>();

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What does Sun have to say about this?</font></b>
<p>Here is what Sun has to say about the <b>MethodDescriptor</b> class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td BGCOLOR="#66FFFF">
<pre><font face="Courier New,Courier">A <b>MethodDescriptor</b> describes a&nbsp;
particular method that a Java Bean
supports for external access from&nbsp;
other components.&nbsp;</font></pre>
</td>
</tr>
</table>

<p>The <b>MethodDescriptor</b> class provides the following two methods
for obtaining information about the method that an object of that class
describes:
<ul>
<li>
<i>Method</i> <b>getMethod()</b> - Gets the method that this MethodDescriptor
encapsualtes.</li>

<li>
<i>ParameterDescriptor[]</i> <b>getParameterDescriptors()</b> - Gets the
ParameterDescriptor for each of this MethodDescriptor's method's parameters.</li>
</ul>
This program doesn't use either of these methods, but as you can see they
could be used to obtain additional information about the event.
<p><b><font color="#FF0000">Getting&nbsp; and saving callback method names</font></b>
<p>However, this class also inherits the <b>getName()</b> method from the
<b>FeatureDescriptor</b>
class.&nbsp; The code in Listing zz uses a <b>for</b> loop and the <b>getName()</b>
method to iterate on the array of <b>MethodDescriptor</b> objects to get
and save the name of each of the callback methods.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b> (int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; methDescrip.length; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.<b>setListenerMethod</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[j].<b>getName</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for-loop

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>Each callback method is described by a single <b>MethodDescriptor</b>
object referred to by one of the elements in the array.
<p>The name of each callback method is saved <i>(by invoking the setListenerMethod()
method)</i> on the <b>EventClass</b> object being used to encapsulate information
about one of the event types supported by the target class or one of its
superclasses.
<p><b><font color="#FF0000">Saving the EventClass object</font></b>
<p>The code in Listing zz adds the populated <b>EventClass</b> object to
the <b>Vector</b> object that was instantiated earlier to contain the set
of <b>EventClass</b> objects.&nbsp; This listing also contains the curly
brace that signals the end of the <b>for</b> loop that iterates on the
array of <b>EventSetDescriptor</b> objects.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventVector.<b>add</b>(eventObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>When the <b>for</b> loop of Listing zz above terminates, the <b>Vector</b>
object referred to by <b>eventVector</b> contains references to <b>EventClass</b>
objects that encapsulate information about all of the events multicast
by the target class and all of its superclasses up to, but not including,
the ceiling class.&nbsp; Each of those objects contains the name of one
event along with the name of the callback methods associated with the event.
<p><b><font color="#FF0000">Sorting the event information</font></b>
<p>The code in Listing zz creates an array object containing the information
stored in the <b>Vector</b> object referred to by <b>eventVector</b>.
<p>Then it uses uses a new object of the <b>EventClass</b> class as a <b>Comparator</b>
to sort the <b>EventClass</b> objects referred to by the elements in the
array.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Object[] eventArray = eventVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>toArray</b>();
&nbsp;&nbsp;&nbsp; Arrays.<b>sort</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventArray,new EventClass());

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>Recall that the <b>compare()</b> method of the <b>EventClass</b> class
causes the objects to be sorted in case-insensitive alphabetical order
on the name values of the events encapsulated in the objects.
<p><b><font color="#FF0000">Displaying the event information</font></b>
<p>Then the code in Listing zz uses a <b>for</b> loop to extract <b>String</b>
information from the objects referred to the elements in the sorted array
and append that information to the contents of the right-center pane in
Figure 1.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; <b>for</b>(int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; eventArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.<b>append</b>(eventArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>toString()</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.<b>append</b>("\n");
&nbsp;&nbsp;&nbsp; }//<b>end for</b> loop
&nbsp; }//end doEvents</font></pre>
</td>
</tr>
</table>

<p>This produces text output in that pane similar to the following <i>(color
added for emphasis)</i>, where the names of the events are not indented,
and the names of the callback methods associated with those events are
indented.
<p><font color="#009900">action</font>
<br><font color="#009900">&nbsp; actionPerformed</font>
<br><font color="#3333FF">ancestor</font>
<br><font color="#3333FF">&nbsp; ancestorMoved</font>
<br><font color="#3333FF">&nbsp; ancestorAdded</font>
<br><font color="#3333FF">&nbsp; ancestorRemoved</font>
<br>&nbsp;
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this and the previous lessons, I have introduced you to a program that
displays information about the following aspects of any Java class that
qualifies as a JavaBean component:
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<font color="#000000">I showed how the <b>actionPerformed()</b> method
of an action listener registered on the OK button in Figure 1 invokes the
following methods to obtain and display the sought-after information:</font>
<ul>
<li>
<font color="#000000">doInheritance()</font></li>

<li>
<font color="#000000">doInterfaces()</font></li>

<li>
<font color="#000000">doProperties()</font></li>

<li>
<font color="#000000">doEvents()</font></li>

<li>
<font color="#000000">doMethods()</font></li>
</ul>
<font color="#000000">In this lesson, I discussed the <b>doEvents()</b>
method in detail.&nbsp; That discussion took you much deeper into introspection
involving such items as:</font>
<ul>
<li>
<font color="#000000">The <b>getEventSetDescriptors() </b>method and the
<b>EventSetDescriptor</b>
class</font></li>

<li>
<font color="#000000">The <b>getListenerMethodDescriptors()</b> method
and the <b>MethodDescriptor</b> class</font></li>

<li>
<font color="#000000">The <b>getName()</b> method of the <b>FeatureDescriptor</b>
class</font></li>
</ul>
<font color="#000000">I also introduced you to other introspection methods
that can be used to get and display information about a target class that
I did not include in this program.</font>
<p><font color="#000000">I showed you how to display the information produced
by the <b>doEvents()</b> method in the right-center pane of Figure 1.</font>
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will explain how the method named <font color="#000000"><b>doMethods()</b>
gets and displays information about the exposed methods of the target class,
in alphabetical order, in the bottom-center output pane of Figure 1.</font>
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing&nbsp;
zz</font>.
<br>&nbsp;
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">/*File Introspect03.java&nbsp;
Copyright 2000, R.G.Baldwin

Produces a GUI that displays&nbsp;
inheritance, interfaces, properties,
events, and methods about components,
or about any class that is a bean.

Requires JDK 1.3 or later.&nbsp; Otherwise,
must service the windowClosing event&nbsp;
to terminate the program.
Tested using JDK 1.3 under WinNT.&nbsp;&nbsp;
**************************************/
import java.io.*;
import java.beans.*;
import java.lang.reflect.*;
import java.util.*;
import java.awt.Color;
import java.awt.event.*;
import javax.swing.*;

public class Introspect03&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extends JFrame{
&nbsp; private JLabel errors =&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JLabel("Errors appear here");
&nbsp; private JPanel outputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JPanel inputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JTextField targetClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JTextField ceilingClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JButton okButton =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("OK");
&nbsp;&nbsp;
&nbsp; private JTextArea inher = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INHERITANCE\n",8,17);
&nbsp; private JScrollPane inherPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(inher);
&nbsp; private JTextArea intfcs = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INTERFACES\n",8,17);
&nbsp; private JScrollPane intfcsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(intfcs);
&nbsp; private JTextArea props = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("PROPERTIES\n",8,17);
&nbsp; private JScrollPane propsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(props);
&nbsp; private JTextArea events =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("EVENTS\n",8,17);
&nbsp; private JScrollPane eventsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(events);
&nbsp; private JTextArea methods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("METHODS\n",8,17);
&nbsp; private JScrollPane methodsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(methods);
&nbsp;&nbsp;
&nbsp; private BeanInfo beanInfo;
&nbsp; private Vector intfcsVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Introspect03();
&nbsp; }//end main
&nbsp;&nbsp;
&nbsp; public Introspect03() {//constructor
&nbsp;&nbsp;&nbsp; //This require JDK 1.3 or later.
&nbsp;&nbsp;&nbsp; // Otherwise service windowClosing
&nbsp;&nbsp;&nbsp; // event to terminate the program.
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFrame.EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; outputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.green);
&nbsp;&nbsp;&nbsp; inputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.yellow);

&nbsp;&nbsp;&nbsp; outputPanel.add(inherPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(intfcsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(propsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(eventsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(methodsPane);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Set some default values
&nbsp;&nbsp;&nbsp; targetClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "javax.swing.JButton");
&nbsp;&nbsp;&nbsp; ceilingClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");

&nbsp;&nbsp;&nbsp; inputPanel.add(targetClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(ceilingClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(okButton);

&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors,"North");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputPanel,"Center");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputPanel,"South");
&nbsp;&nbsp;&nbsp; setResizable(false);
&nbsp;&nbsp;&nbsp; setSize(400,520);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2000, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner class to provide
&nbsp;&nbsp;&nbsp; // event handler for okButton
&nbsp;&nbsp;&nbsp; okButton.addActionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ActionListener(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Errors appear here");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INHERITANCE\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INTERFACES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PROPERTIES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "EVENTS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.setText("METHODS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class targetClassObject =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInheritance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInterfaces();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBeanInfo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClassObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doProperties();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doEvents();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doMethods();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(Exception ex){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex.toString());}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end actionPerformed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ActionListener
&nbsp;&nbsp;&nbsp;&nbsp; );//end addActionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInheritance()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ClassNotFoundException{
&nbsp;&nbsp;&nbsp; //Get and display inheritance
&nbsp;&nbsp;&nbsp; // hierarchy
&nbsp;&nbsp;&nbsp; Vector inherVector = new Vector();
&nbsp;&nbsp;&nbsp; String theClass = targetClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText();
&nbsp;&nbsp;&nbsp; Class theClassObj = null;
&nbsp;&nbsp;&nbsp; Class theSuperClass = null;
&nbsp;&nbsp;&nbsp; while(!(theClass.equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object"))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.add(theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassObj = Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theSuperClass = theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSuperclass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and save interfaces to be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // used later
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theClassObj.getInterfaces()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcsVector.add(theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInterfaces());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = theSuperClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName();
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; inherVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display vector contents in
&nbsp;&nbsp;&nbsp; // reverse order
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; inherVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((String)inherVector.elementAt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.size() - (i+1))));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInheritance
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInterfaces(){
&nbsp;&nbsp;&nbsp; Vector interfaceNameVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;&nbsp; //Interface information was stored
&nbsp;&nbsp;&nbsp; // in intfcsVector earlier.
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; intfcsVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class[] interfaceSet =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Class[])intfcsVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elementAt(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; interfaceSet.length;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceSet[j].getName());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop on j
&nbsp;&nbsp;&nbsp; }//end for loop on i

&nbsp;&nbsp;&nbsp; Object[] interfaceNameArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(interfaceNameArray);

&nbsp;&nbsp;&nbsp; if(interfaceNameArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; interfaceNameArray.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup interface names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInterfaces
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doProperties(){
&nbsp;&nbsp;&nbsp; Vector propVector = new Vector();
&nbsp;&nbsp;&nbsp; PropertyDescriptor[] propDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropClass propObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PropClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setName(propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setType("" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propVector.add(propObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] propArray = propVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propArray,new PropClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append(propArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doProperties
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doEvents(){
&nbsp;&nbsp;&nbsp; Vector eventVector = new Vector();
&nbsp;&nbsp;&nbsp; EventSetDescriptor[] evSetDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEventSetDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; evSetDescrip.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventClass eventObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EventClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setName(evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getListenerMethodDescriptors();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; methDescrip.length; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[j].getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventVector.add(eventObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] eventArray = eventVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventArray,new EventClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; eventArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append(eventArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doEvents
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doMethods(){
&nbsp;&nbsp;&nbsp; Vector methVector = new Vector();
&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.getMethodDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[i].getName());
&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Object[] methodArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(methodArray);

&nbsp;&nbsp;&nbsp; if(methodArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[0].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methodArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup method names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(methodArray[i].equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doMethods
//===================================//

//This inner class is used to
// encapsulate name and type
// information about properties.&nbsp; It
// also serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class PropClass implements Comparator{
&nbsp; private String name;
&nbsp; private String type;
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setType(String type){
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return(name + "\n&nbsp; " + type);
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((PropClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)obj).getName());
&nbsp; }//end equals
}//end class PropClass
//===================================//

//This inner class is used to
// encapsulate name and handler
// information about events.&nbsp; It also
// serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class EventClass implements Comparator{
&nbsp; private String name;
&nbsp; private Vector lstnrMethods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String lstnrMethod){
&nbsp;&nbsp;&nbsp; lstnrMethods.add(lstnrMethod);
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; String theString = name;

&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; lstnrMethods.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theString = theString + "\n&nbsp; " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstnrMethods.elementAt(i);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; return theString;
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((EventClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)obj).getName());
&nbsp; }//end equals
}//end EventClass inner class
&nbsp;&nbsp;
}//end controlling class Introspect03

<b>Listing zz</b></font></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
