<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Getting Started in Java by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->OOD -- The Painter's Canvas Problem<!--endTitle--></H2>
<P>Java Programming, Lecture Notes # 031, Revised 10/02/99. </P>


<P>
<!-toc file=Java031a.htm words=Preface-><A HREF="#Preface">Preface</A><BR><!--endtoc-->
<!-toc file=Java031b.htm words=Introduction-><A HREF="#Introduction">Introduction</A><BR><!--endtoc-->
<!-toc file=Java031c.htm words=Sample Program from Dale and Weems-><A HREF="#Sample Program from Dale and Weems">Sample Program from Dale and Weems</A><BR><!--endtoc-->
<!-toc file=Java031d.htm words=Description of the Problem-><A HREF="#Description of the Problem">Description of the Problem</A><BR><!--endtoc-->
<!-toc file=Java031e.htm words=Solution-><A HREF="#OOD Solution:">OOD Solution</A><BR><!--endtoc-->
<!-toc file=Java031f.htm words=Discussion-><A HREF="#Discussion:">Discussion</A><BR><!--endtoc-->
<!-toc file=Java031g.htm words=Required Classes, Objects, and Instance Variables-><A HREF="#Required classes, objects, and instance variables:">Required Classes, Objects, and Instance Variables</A><BR><!--endtoc-->
<!-toc file=Java031h.htm words=Required Methods-><A HREF="#Required methods:">Required Methods</A><BR><!--endtoc-->
<!-toc file=Java031i.htm words=Relationships Among Classes and Objects-><A HREF="#Relationships among classes and objects:">Relationships Among Classes and Objects</A><BR><!--endtoc-->
<!-toc file=Java031j.htm words=Behavior of Objects-><A HREF="#Behavior of Objects:">Behavior of Objects</A><BR><!--endtoc-->
<!-toc file=Java031k.htm words=Interesting Code Fragments-><A HREF="#Interesting Code Fragments">Interesting Code Fragments</A><BR><!--endtoc-->
<!-toc file=Java031l.htm words=Program Listing-><A HREF="#Program Listing">Program Listing</A><!--endtoc-->
</P>




<P><!-next=Java031a.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson. </P>




<P><!-prev=Java031.htm-><!-next=Java031b.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Introduction"></A>Introduction</H2>
</FONT><P>A very brief description of Object-Oriented Design (OOD) was presented in Lesson 4 along with an example of using OOD to develop a simple program that simulated a digital counter. Additional material on the topic was provided in lesson 29 which discussed the topic in considerably more detail. </P>
<P>This lesson, and others that follow will continue exposing you to OOD concepts and sample programs developed using OOD methodology so that you can learn about OOD as you learn to write object-oriented Java programs. </P>
<P>An overall objective in OOD is to create a model of the problem domain consisting of a <I>set of cooperating objects</I>. In order to create such a model, you must discover the classes/objects that make up the model, the attributes of the objects, the relationships among the objects, and the behavior of the objects. </P>
<P>One common technique for accomplishing this is to create a <U>narrative description</U> of the solution to the problem, and then use the <I>nouns, adjectives, </I>and <I>verbs </I>to help identify the <I>classes</I>, <I>data members</I>, and <I>methods </I>needed in the design. This or a similar methodology is found in many books on the subject. </P>




<P><!-prev=Java031a.htm-><!-next=Java031c.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Sample_Program_from_Dale_and_Weems"></A>Sample Program from Dale and Weems</H2>
</FONT><P>This is a Java object-oriented solution to the <I>Problem-Solving Case Study</I> presented on page 152 of <U>Turbo Pascal, Fourth Edition</U> by Nell Dale and Chip Weems. </P>
<P>This sample program is being provided to contrast the structure of two different versions of the same program: one designed according to<I> Top-Down Design</I> methodology and the other designed according to <I>Object-Oriented Design</I> methodology. </P>
<P>Since I am not at liberty to reproduce the Top-Down solution in the textbook, in order for you to compare the two versions, you will need to see the version in the textbook. This series of textbooks has been in use at colleges and universities for many years, and hopefully you can locate one in a library, a friend's house, or a used book store. </P>




<P><!-prev=Java031b.htm-><!-next=Java031d.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="Description_of_the_Problem"></A>Description of the Problem</H3>
</FONT><P>The description of the problem is paraphrased below: </P>
<P>You are learning to make your own painting frames by stretching <B>canvas </B>over a <B>wooden frame </B>and tacking it to the back of the frame. For a given size of <B>painting</B>, you must determine how much wood to buy for the frame, how large a piece of canvas to purchase, and the cost of the materials. Write a program using OOD methodology that will perform that task. </P>
<P>Get the following input from the user: </P>

<UL>
<LI>Length and width of the painting, </LI>
<LI>Cost per inch for the wood, and </LI>
<LI>Cost per square foot for the canvas. </LI></UL>

<P>Calculate and display the following output for the user: </P>

<UL>
<LI>Prompting messages, </LI>
<LI>Echo of input data, </LI>
<LI>Length of wood to buy in inches, </LI>
<LI>Length and width of the canvas in inches, </LI>
<LI>Cost of the wood in dollars, </LI>
<LI>Cost of the canvas in dollars, and </LI>
<LI>Total cost of the materials in dollars. </LI></UL>

<P>Givens: </P>

<UL>
<LI>The required length of the wood to build a frame is twice the sum of the width and the length of the painting (assuming no waste). </LI>
<LI>The size of the canvas must be 5 inches greater than the size of the painting in both dimensions in order to allow for wrapping and tacking of the canvas to the wooden frame. </LI>
<LI>The user will provide proper input data so that no error checking on input is required. </LI></UL>





<P><!-prev=Java031c.htm-><!-next=Java031e.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="OOD_Solution_"></A>OOD Solution</H3>
</FONT><P>The controlling class for the program is named <B>Ood03</B>. It is designed to run as a Java application which means that it requires a <B>main()</B> method. An instance of the controlling class is analogous to a painting.</P>
<STRONG><P>Note: When I run this program under JDK 1.1.6, the prompts do not always appear on the screen at the correct point in time. However, if I ignore that situation and enter data just as though the prompt did correctly appear, all of the prompts eventually appear on the screen. I don't believe that this was a problem with JDK 1.1.3, but I'm not absolutely certain.</STRONG> </P>




<P><!-prev=Java031d.htm-><!-next=Java031f.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="Discussion_"></A>Discussion</H3>
</FONT><P>The required <I>classes</I>, <I>objects</I>, and <I>instance variables</I> were discovered by analyzing the <I>nouns </I>in the description of the problem. </P>
<P>The required <I>methods </I>were discovered by analyzing the <I>verbs </I>and the <I>output requirements</I> in the description of the problem. </P>




<P><!-prev=Java031e.htm-><!-next=Java031g.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="Required_classes__objects__and_instance_"></A>Required Classes, Objects, and Instance variables</H4>
</FONT><P>The nouns that were selected to represent classes (and objects) were: </P>

<UL>
<LI>Painting </LI>
<LI>Canvas </LI>
<LI>Wooden Frame. </LI></UL>

<P>The nouns that were selected to represent instance variables of the <B>Painting </B>class were: </P>

<UL>
<LI>Canvas </LI>
<LI>WoodenFrame. </LI></UL>

<P>Note that these are objects of two of the three classes. </P>
<P>The nouns that were selected to represent instance variables of the <B>Canvas </B>class were: </P>

<UL>
<LI>margin (this is the folding or tacking margin) </LI>
<LI>length (this is the length of the painting) </LI>
<LI>width (this is the width of the painting) </LI>
<LI>costPerSqFt (this is the cost of the canvas material) </LI></UL>

<P>The nouns that were selected to represent instance variables of the <B>WoodenFrame </B>class were: </P>

<UL>
<LI>length (this is the length of the painting) </LI>
<LI>width (this is the width of the painting) </LI>
<LI>costPerInch (this is the cost of the wood) </LI></UL>





<P><!-prev=Java031f.htm-><!-next=Java031h.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="Required_methods_"></A>Required methods</H4>
</FONT><P>The verbs and other aspects of the description of the problem suggested that the <B><I>Painting </B></I>class should have the following methods including the <B>main()</B> method required by all Java applications: </P>

<UL>
<LI>main() </LI>
<LI>getInput() </LI>
<LI>showOutput() </LI>
<LI>getTotalMaterialCost() </LI></UL>

<P>Note that the <B><I>Painting </B></I>class is actually represented by the controlling class which, for disk storage reasons, was named <B>Ood03 </B>instead of <B><I>Painting</B></I>. </P>
<P>The verbs and other aspects of the description of the problem suggested that the <B>Canvas </B>class should have the following <I>mutator </I>methods. A <I>mutator</I> method is a method that modifies the value of an instance variable. </P>

<UL>
<LI>setLength(double length) </LI>
<LI>setWidth(double width) </LI>
<LI>setCostPerSqFt(double costPerSqFt) </LI></UL>

<P>The description of the problem suggested that the <B>Canvas </B>class should have the following <I>accessor </I>methods. An <I>accessor</I> method is a method that uses, but does not modify the values of the instance variables. </P>

<UL>
<LI>getTotalLength() </LI>
<LI>getTotalWidth() </LI>
<LI>getTotalCost() </LI></UL>

<P>The verbs and other aspects of the description of the problem suggested that the <B>WoodenFrame </B>class should have the following mutator methods: </P>

<UL>
<LI>setLength(double length) </LI>
<LI>setWidth(double width) </LI>
<LI>setCostPerInch(double costPerInch) </LI></UL>

<P>The description of the problem suggested that the <B>WoodenFrame </B>class should have the following accessor methods: </P>

<UL>
<LI>getTotalLengthToBuy() </LI>
<LI>getTotalCost() </LI></UL>





<P><!-prev=Java031g.htm-><!-next=Java031i.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="Relationships_among_classes_and_objects_"></A>Relationships Among Classes and Objects</H4>
</FONT><P>The description of the problem suggested the following relationships among objects instantiated from the classes <B>Ood03</B>, <B>Canvas</B>, and <B>WoodenFrame</B>: </P>
<P>Each object of type <B>Ood03 </B><I>(Painting)</I> contains one <B>Canvas </B>object and one <B>WoodenFrame </B>object. This is a <I><U>has-a</I></U> relationship. (A painting <I>has a</I> <B>Canvas </B>and a painting <I>has a</I> <B>WoodenFrame</B>.) </P>




<P><!-prev=Java031h.htm-><!-next=Java031j.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="Behavior_of_Objects_"></A>Behavior of Objects</H4>
</FONT><P>The behavior of each of the objects of the <B>Canvas</B>, and <B>WoodenFrame </B>classes consists primarily of <I>mutation </I>and <I>access</I>. </P>
<I><P>Mutator </I>methods are used to store information in the instance variables of the objects. <I>Accessor </I>methods are used to calculate and return higher-level representations of the instance variables such as total cost. </P>
<P>The behavior of an object of the <B>Ood03 </B>class requires </P>

<UL>
<LI>Getting input data from the user, </LI>
<LI>Sending messages to the <B>Canvas </B>and <B>WoodenFrame </B>objects asking them to change their state and store the information obtained from the user, </LI>
<LI>Sending messages to the <B>Canvas </B>and <B>WoodenFrame </B>objects asking them to calculate and return information in the form of higher-level representations of the data stored in their instance variables (such as total cost), and </LI>
<LI>Displaying data provided by those objects for the benefit of the user.. </LI></UL>





<P><!-prev=Java031i.htm-><!-next=Java031k.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="Interesting_Code_Fragments"></A>Interesting Code Fragments</H3>
</FONT><P>One of the most significant things about objects designed according to the OOD methodology is that objects are generally self-contained entities. For example, in a sorting program, an object can tell you whether it is greater than, equal to, or less than another object of the same class. </P>
<P>That characteristic manifests itself in this program as well. Objects of the <B>Canvas</B> and <B>WoodenFrame</B> class know how to determine the cost of their materials for a painting of a specified size. An object of the <B>Ood03</B> <I>(painting)</I><B> </B>class knows how to determine the total cost of materials to construct an instance of itself. Objects store information, and they are able to answer questions about themselves. </P>
<P>We will begin our examination with the <B>Ood03 </B>class. This class represents a painting. It <I>has a</I> <B>WoodenFrame </B>object and it <I>has a</I> <B>Canvas </B>object, each represented by an instance variable. </P>
<P>It can get user input to establish its own size and can pass that information along to the <B>WoodenFrame </B>object and the <B>Canvas </B>object by sending them appropriate messages. </P>
<P>It can display important attributes about itself, including the total cost of materials required to construct one instance of itself. </P>
<P>This class has two instance variables, which are actually objects of the other two classes. The beginning of the class definition containing the two instance variables is shown in the following fragment. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>public class <B>Ood03{//controlling</B> class
  private Canvas canvas = <B>new Canvas()</B>;
  private WoodenFrame woodenFrame = <B>new WoodenFrame()</B>;</PRE></TD>
</TR>
</TABLE>

<P>All Java <I>applications </I>require a <B>main()</B> method in the controlling class. In this case, code in <B>main()</B> instantiates an object of itself which represents a painting. </P>
<P>Then the code in <B>main()</B> invokes input and output methods on the object, first to obtain size and unit cost information from the user, and second to report total size and total cost information back to the user. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  public static void <B>main</B>(String[] args){
    Ood03 painting = <B>new Ood03()</B>;
    painting.getInput<B>()</B>;
    painting.showOutput<B>()</B>;
  }//end main</PRE></TD>
</TR>
</TABLE>

<P>Now let's examine the <B>getInput</B>() method of the <B>Ood03</B> <I>(painting)</I> class that gets input information from the user. </P>
<P>The first statement in this method instantiates a utility object of type <B>EasyIn</B> to make it easier to handle keyboard input. There is nothing about the <B>EasyIn</B> class that is peculiar to this design. It should be viewed as a local class library. </P>
<P>(However, you may find it interesting as an example program from a noted author illustrating to how to use the reader/writer character stream classes that were introduced in JDK 1.1.) </P>
<P>Then a temporary variable of type <B>double</B> is declared to use for a variety of purposes. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  private void getInput(){
    <B>EasyIn </B>easy = new EasyIn();
    <B>double </B>temp;//temporary double variable</PRE></TD>
</TR>
</TABLE>

<P>This is followed by several groups of statements that are used to communicate with the user and also to communicate with two of the objects in the program. The following code fragment is typical of the code in each of these groups. </P>
<P>First, the method sends a prompt to the user asking her to enter the length of the painting in inches. The length is read from the keyboard as a <B>double</B>. </P>
<P>Then the method <I>sends a message</I> to the <B>Canvas</B> object telling it to <U>change it state</U> by storing the length of the painting in one of its instance variables. </P>
<P>In Java, the act of <I>sending a message to an object</I> is carried out by <U>invoking a method on the object</U>. In this case, we invoke the <I>mutator</I> method named <B>setLength()</B>. </P>
<P>Similarly, a message is sent to the <B>WoodenFrame</B> object telling it to change its state and store the length of the painting in one of its instance variables. </P>
<P>Note that I considered defining a class and instantiating an object to represent the length and width of a painting to prevent having duplicate data in the <B>Canvas</B> and <B>WoodenFrame</B> objects. However, I decided that in this case, the amount of duplicated data wasn't sufficiently large to warrant the additional overhead involved with another object. </P>
<P>I also considered collecting the common attributes of length and width into a superclass and extending that class to create the classes named <B>Canvas</B> and <B>WoodenFrame</B>. However, I decided that wouldn't add benefit to the design at this level and didn't do it. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
    System.out.println(
      "<B>Enter length of painting in inches</B>");
    temp = easy.readDouble();
    canvas.setLength(temp);
    woodenFrame.setLength(temp);</PRE></TD>
</TR>
</TABLE>

<P>The <B>getInput()</B> method continues prompting the user for information and sending that information to the <B>Canvas</B> and <B>WoodenFrame</B> objects until all of the necessary input information has been obtained and stored in objects of those two classes. You can see the code for that activity in the complete listing of the program that follows this section. </P>
<P>That concludes the discussion of the <B>getInput()</B> method. </P>
<P>The <B>showOutput()</B> method of the <B>Ood03</B> class, and the method named <B>getTotalMaterialCost()</B> (also of the <B>Ood03</B> class) which is invoked by the <B>showOutput()</B> method are used to obtain information from the <B>Canvas </B>and <B>WoodenFrame </B>objects regarding their material requirements and the cost of those materials for a painting of the size specified earlier by the user. </P>
<P>The information obtained from the <B>Canvas</B> and <B>WoodenFrame</B> objects is displayed for the benefit of the user by the <B>showOutput()</B> method. </P>
<P>The method begins by sending a message to the <B>WoodenFrame </B>object asking it to report on the amount of wood that needs to be purchased to construct one instance of itself of the specified size. The method displays this information for the benefit of the user. </P>
<P>This communication is accomplished by invoking the <B>getTotalLengthToBuy()</B> accessor method on the <B>WoodenFrame</B> object as shown below. This method uses the information stored in the instance variables of the object to calculate and return the answer. </P>
<P>The method call is physically inside the parameter list of a call to the <B>println()</B> method. The <B>println()</B> method is a method of the <B>System</B> class that causes its argument to be displayed on the standard output device. In this case, the argument is the value returned by the call to <B>getTotalLengthToBuy()</B> and that value is displayed on the standard output device. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  private void <B>showOutput</B>(){
    System.out.println("Length of wood to buy is: " 
         + woodenFrame.getTotalLengthToBuy() + " inches");</PRE></TD>
</TR>
</TABLE>

<P>Several more similar statements are executed where information is obtained from the <B>Canvas</B> and <B>WoodenFrame</B> objects and displayed on the output screen for the benefit of the user. </P>
<P>Then the <B>painting</B> objects <U>sends a message to itself</U> asking itself to report on the total material cost. This is accomplished when the object invokes the <B>getTotalMaterialCost()</B> method on itself. </P>
<B><P>getTotalMaterialCost()</B> sends messages to the <B>WoodenFrame </B>and <B>Canvas </B>objects asking them to report on their individual costs. The method adds those individual costs and returns the sum of the individual costs as the total cost for the project. </P>
<P>The total cost is displayed for the benefit of the user, as shown below, and that terminates the <B>showOutput()</B> method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>    System.out.println("Total cost: " 
               + this.getTotalMaterialCost() + " dollars");</PRE></TD>
</TR>
</TABLE>

<P>The next code fragment shows the <B>getTotalMaterialCost()</B> method of the <B>Ood03</B> class that is used to calculate the total cost of the project. As mentioned above, this method sends messages to the <B>WoodenFrame </B>and <B>Canvas </B>objects asking them to return their individual total costs. The method adds these individual costs and returns the sum as the total material cost for the project. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  private double <B>getTotalMaterialCost</B>(){
    return (<B>canvas.getTotalCost()</B> 
                            + <B>woodenFrame.getTotalCost()</B>);
  }//end getTotalMaterialCost()</PRE></TD>
</TR>
</TABLE>

<P>That ends the discussion of the <B>Ood03</B> class that represents a <B><I>Painting</B> </I>object in this program. The <B><I>Painting</B></I> object knows enough about itself to be able to determine and display critical information about itself for a specified painting size and specified unit costs for the raw materials. </P>
<P>Next we will discuss the <B>Canvas</B> class. </P>
<P>The <B>Canvas </B>class represents the material used to cover the wooden frame for a painting. It has the following instance variables. </P>

<UL>
<LI>length </LI>
<LI>width </LI>
<LI>costPerSqFt </LI></UL>

<P>The length and width values represent the length and width of the painting and are used to calculate the actual length and actual width requirements of the piece of canvas material. </P>
<P>It also has a <U>symbolic constant</U> named <B>margin</B> which specifies the amount of extra material needed to wrap the canvas around the frame and staple it on the back. </P>
<P>The class uses <I>mutator </I>methods to set the values of the instance variables. </P>
<P>It does not provide <I>field accessors</I> by which the values of the instance variables can be obtained. </P>
<P>However, it knows how to calculate the total material cost for one instance of itself, and it provides <I>accessor </I>methods by which the following higher-level representations of the instance variables can be obtained: </P>

<UL>
<LI>total length </LI>
<LI>total width </LI>
<LI>total cost </LI></UL>

<P>The beginning of the class definition along with the symbolic constant and the instance variables is shown in the following fragment. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class <B>Canvas</B>{
  private final double <B>margin </B>= <B>5.0</B>;
  private double <B>length</B>; //length of the painting
  private double <B>width</B>; //width of the painting
  private double <B>costPerSqFt</B>; //cost of the canvas  </PRE></TD>
</TR>
</TABLE>

<P>The next code fragment shows the three <I>mutator</I> methods by which the values of the instance variables can be set. As you can see, they are very simple which is frequently the case. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  public void <B>setLength(double</B> length){
    this.length = length;
  }//end setLength()
  //-----------------------------------------------------//
  
  public void <B>setWidth(double</B> width){
    this.width = width;
  }//end setWidth()
  //-----------------------------------------------------//
  
  public void <B>setCostPerSqFt(double</B> costPerSqFt){
    this.costPerSqFt = costPerSqFt;
  }//end setCostPerSqFt()</PRE></TD>
</TR>
</TABLE>

<P>The following code fragment shows the <I>accessor</I> methods by which an object of the class can calculate and return a higher-level representation of the values of the instance variables (such as total length). </P>
<P>In this case, total length is the length of the painting plus the binding margin required to fold the canvas under the frame and staple it. Similarly, total width is the width of the painting plus the binding margin. </P>
<P>Note that the third <I>accessor</I> method was required to make a conversion between square inches and square feet; hence the use of the constant 144 (there are 144 square inches in a square foot). </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  public double <B>getTotalLength</B>(){
    return (length + margin);
  }//end getTotalLength()
  //-----------------------------------------------------//
 
  public double <B>getTotalWidth</B>(){
    return (width + margin);
  }//end getTotalWidth()
  //-----------------------------------------------------//
  
  public double <B>getTotalCost</B>(){
    return (
     (((length+margin) * (width+margin))*costPerSqFt)/144);
  }//end getTotalCost()</PRE></TD>
</TR>
</TABLE>

<P>That ends the discussion of the <B>Canvas</B> class. </P>
<P>The one remaining class to be discussed is the <B>WoodenFrame</B> class. </P>
<P>This class represents the wooden frame that is covered with canvas for a painting. It has the following instance variables: </P>

<UL>
<LI>length </LI>
<LI>width </LI>
<LI>costPerInch </LI></UL>

<P>Note that length and width are the <I>length </I>and <I>width </I>of the painting which is the same as the length and width required of a finished frame. The <I>costPerInch</I> is the cost of the wood required to construct the frame measured in inches along the length of the board. </P>
<P>The <B>WoodenFrame</B> class uses <I>mutator </I>methods to set the values of the instance variables. </P>
<P>As with the <B>Canvas</B> class, it does not provide <I>field accessors</I> by which the values of the instance variables can be read. </P>
<P>However, it knows how to calculate the total material cost for one instance of itself, and provides <I>accessor </I>methods by which the following higher-level representations of the instance variables can be obtained: </P>

<UL>
<LI>total length of wood required </LI>
<LI>total cost for the wood </LI></UL>

<P>The following code fragment shows the beginning of the class along with the three instance variables. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class <B>WoodenFrame</B>{
  private double <B>length</B>; //of the painting  
  private double <B>width</B>; //of the painting
  private double <B>costPerInch</B>; //for the wood</PRE></TD>
</TR>
</TABLE>

<P>The <I>mutator</I> methods used to set the values of the instance variables are shown in the next code fragment. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  public void <B>setLength(double</B> length){
    this.length = length;
  }//end setLength()
  //-----------------------------------------------------//
  
  public void <B>setWidth(double</B> width){
    this.width = width;
  }//end setWidth()
  //-----------------------------------------------------//
  
  public void <B>setCostPerInch(double</B> costPerInch){
    this.costPerInch = costPerInch;
  }//end setCostPerInch()</PRE></TD>
</TR>
</TABLE>

<P>The accessor methods required to calculate and return the specified information are shown in the next fragment. </P>
<P>Note that the total length of the wood required to build a frame is twice the sum of the length and the width of the frame. </P>
<P>The total cost is the product of the total length in inches and the costPerInch of the wood. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>  public double <B>getTotalLengthToBuy</B>(){
    return (2*(length + width));
  }//end getTotalLengthToBuy()
  //-----------------------------------------------------//
  
  public double <B>getTotalCost</B>(){
    return ((2*(length + width))*costPerInch);
  }//end getTotalCost()</PRE></TD>
</TR>
</TABLE>

<P>That ends the discussion of the <B>WoodenFrame</B> class. </P>
<P>In summary, object-oriented design leads to designs where the solution to the programming problem is to have two or more objects that send messages to each other and react to messages sent by others. </P>
<P>A message from one object typically tells another object to either <I>change its state</I>, <I>perform an action</I>, or both. </P>
<P>In this program, we used <I>mutator</I> methods to tell an object to change its state. When we invoked those <I>mutator</I> methods, we provided the information necessary to define the new state of the object. </P>
<P>We used <I>accessor</I> methods to tell an object to perform an action. In this program, the action to be performed was to calculate a value making use of the values stored in the instance variables of the object. Those values were placed there earlier using the <I>mutator</I> methods. </P>
<P>If possible, you should obtain a copy of the textbook listed above and compare this solution with the <I>Top-Down</I> solution provided in that book. For small programs like this one, neither approach is significantly advantageous relative to the other. However, for a variety of reasons, as the size of the program grows, the advantages of Object-Oriented Design over Top-Down Design begin to manifest themselves. </P>
<P>You should probably learn how to use OOD methodology to design small programs before you tackle larger programs. </P>




<P><!-prev=Java031j.htm-><!-next=Java031l.htm><!-first=Java031.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="Program_Listing"></A>Program Listing</H3>
</FONT><P>A complete listing of the program follows. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
/*File Ood03.java Copyright 1997, R.G.Baldwin
This is a Java object-oriented solution to the Problem- 
Solving Case Study on page 152 of Turbo Pascal, Fourth 
Edition by Nell Dale and Chip Weems. 

This sample program is being provided to contrast the 
structure of two different versions of the program: one 
designed according to Top-Down Design methodology as 
provided in the book, and the other designed according
to Object-Oriented Design methodology.

The description of the problem is paraphrased below:

You are learning to make your own painting frames by 
stretching the canvas over a wooden frame and tacking 
it to the back of the frame. For a given size of 
painting, you must determine how much wood to buy for 
the frame, how large a piece of canvas to purchase, and 
the cost of the materials. Write a program using OOD 
methodology that will perform that task.

Input: 

    Length and width of the painting, 
    Cost per inch for the wood, and 
    Cost per square foot for the canvas.

Output: 

    Prompting messages, 
    Echo of input data, 
    Amount of wood to buy in inches, 
    Dimensions of the canvas in inches, 
    Cost of the wood in dollars,
    Cost of the canvas in dollars, and 
    Total cost of the materials in dollars.

Givens:

    The required length of the wood to build a frame is 
      twice the sum of the width and the length of the 
      painting assuming no waste.
    The size of the canvas must be 5 inches greater 
      than the size of the painting in both dimensions in 
      order to allow for wrapping and tacking of the 
      canvas to the wooden frame.
    The user will provide proper input data so that no 
      error checking on input is required.

Solution:

The controlling class for the program is named Ood03. 
It is designed to run as a Java application which means 
that it requires a main method. An instance of the 
controlling class is analogous to a painting.

Discussion:

The required classes, objects, and instance variables 
were discovered by analyzing the nouns in the 
description of the problem..

The required methods were discovered by analyzing the 
verbs and the output requirements in the description of 
the problem.

Required classes, objects, and instance variables:

The nouns that were selected to represent classes (and 
objects) were: 

    Painting
    Canvas
    WoodenFrame.

The nouns that were selected to represent instance 
variables (instance objects) of the Painting class 
were: 

    Canvas
    WoodenFrame.

The nouns that were selected to represent instance 
variables of the Canvas class were: 

    Margin (the folding margin)
    Length (the length of the painting)
    Width (the width of the painting)
    Cost Per Sq Ft (the cost of the canvas material)

The nouns that were selected to represent instance 
variables of the WoodenFrame class were: 

    Length (the length of the painting)
    Width (the width of the painting)
    Cost Per Inch (the cost of the wood)

Required methods:

The verbs and other aspects of the description of the 
problem suggested that the Painting class should have 
the following methods including the main method 
required by all Java applications:

    main()
    getInput()
    showOutput()
    getTotalMaterialCost()

Note that the Painting class is actually represented by 
the controlling class which, for disk storage reasons, 
is named Ood03 instead of Painting.

The verbs and other aspects of the description of the 
problem suggested that the Canvas class should have the 
following mutator methods:

    setLength(double length)
    setWidth(double width)
    setCostPerSqFt(double costPerSqFt)

The description of the problem suggested that the 
Canvas class should have the following accessor 
methods:

    getTotalLength()
    getTotalWidth()
    getTotalCost()

The verbs and other aspects of the description of the 
problem suggested that the WoodenFrame class should 
have the following mutator methods:

    setLength(double length)
    setWidth(double width)
    setCostPerInch(double costPerInch)

The description of the problem suggested that the 
WoodenFrame class should have the following accessor 
methods:

    getTotalLengthToBuy()
    getTotalCost()

Relationships among classes and objects:

The description of the problem suggested the following 
relationships among objects instantiated from the 
classes Ood03, Canvas, and WoodenFrame:

Each object of type Ood03 (Painting) contains one 
Canvas object and one WoodenFrame object. This is a 
has-a relationship. (A painting has-a Canvas and a
painting has-a WoodenFrame.)

Behavior of Objects:

The behavior of each of the objects of the Canvas, and 
WoodenFrame classes consists primarily of mutation and 
access. Mutator methods are used to store information 
in the instance variables of the objects. Accessor 
methods are used to calculate and return higher-level 
representations of the instance variables such as total 
cost. 

The behavior of an object of the Ood03 class requires 

    Getting input data from the user, 
    Sending messages to the Canvas and WoodenFrame 
      objects asking them to change their state and store 
      the information obtained from the user, 
    Sending messages to the Canvas and WoodenFrame 
      objects asking them to calculate and return 
      information in the form of higher-level 
      representations of the data stored in their 
      instance variables (such as total cost), and
    Displaying data provided by those objects for the 
      benefit of the user.

The program was tested using JDK 1.1.3 running under Win95.
**********************************************************/

import java.io.*;
import java.util.*;
//=======================================================//
public class Ood03{//controlling class
  //This class represents a painting.  It has a WoodenFrame
  // object and it has a Canvas object, each represented
  // by an instance variable. It can get user input to
  // establish its own size in order to pass that 
  // information along to the WoodenFrame object and the 
  // Canvas object.  It can display all the important
  // attributes about itself, including the total cost
  // of materials required for one instance of itself.

  //Instance variables
  private Canvas canvas = new Canvas();
  private WoodenFrame woodenFrame = new WoodenFrame();
  //-----------------------------------------------------//
  
  //Methods
  //-----------------------------------------------------//

  //All Java applications require a main method in the
  // controlling class.
  public static void main(String[] args){
    //Instantiate a new painting object.
    Ood03 painting = new Ood03();
    
    //Get size information about the painting and unit
    // cost information for the materials required to 
    // assemble the frame and canvas for the painting.
    painting.getInput();
    
    //Display information on total material requirements
    // and total cost.
    painting.showOutput();
  }//end main
  //-----------------------------------------------------//

  private void getInput(){
    //This method is used to obtain information about the
    // size of the painting and the unit cost for required
    // materials.
    
    //Prepare to use the class that supports keyboard input
    EasyIn easy = new EasyIn();
    
    double temp;//temporary double variable

    //Display a prompt to the user.    
    System.out.println(
      "Enter length of painting in inches");
    
    //Get the length of the painting from the user.
    temp = easy.readDouble();
    
    //Send a message to the Canvas object telling it to
    // change its state to include the length of the
    // painting.
    canvas.setLength(temp);
    
    //Send a message to the WoodenFrame object telling it
    // to change its state to include the length of the
    // painting.
    woodenFrame.setLength(temp);
    
    //Continue getting input information and sending
    // messages to the Canvas object and the WoodenFrame
    // object telling them to change their state to
    // include the new information.
    System.out.println(
      "Enter width of painting in inches");
    temp = easy.readDouble();
    canvas.setWidth(temp);
    woodenFrame.setWidth(temp);
    
    System.out.println("Enter cost per inch for wood");
    temp = easy.readDouble();
    woodenFrame.setCostPerInch(temp);
    
    System.out.println("Enter cost per sq ft for canvas");
    temp = easy.readDouble();
    canvas.setCostPerSqFt(temp);
  }//end getInput()
  //-----------------------------------------------------//
  
  private void showOutput(){
    //This method, and the method called by this method
    // named getTotalMaterialCost are used to obtain 
    // information from the Canvas object and the 
    // WoodenFrame object regarding their material 
    // requirements and the cost of that material.  The
    // information so obtained is displayed for the benefit
    // of the user.
    
    //Send a message to the WoodenFrame object asking it
    // to report on the amount of wood that needs to be
    // purchased.  Display this information for the 
    // benefit of the user.
    System.out.println("Length of wood to buy is: " 
         + woodenFrame.getTotalLengthToBuy() + " inches");
         
    //Continue sending messages to the WoodenFrame and
    // Canvas objects asking them to report on some aspect
    // of their state.  Display the information so obtained
    // for the benefit of the user.
    System.out.println("Total length of canvas:" 
      + canvas.getTotalLength() + " inches");
    System.out.println(
      "Total width of canvas: " 
                  + canvas.getTotalWidth() + " inches");
    System.out.println("Total cost of wood is: " 
                        + woodenFrame.getTotalCost());
    System.out.println("Total cost of canvas: " 
       + canvas.getTotalCost() + " dollars");
                     
    //Here, the painting object sends a message to itself
    // asking itself to report on the total material cost.
    // This message causes a method  to be invoked which
    // sends messages to the WoodenFrame and Canvas 
    // objects asking them to report on their individual
    // total costs.  The method returns the sum of the 
    // individual costs as the total cost for the project.
    // The total cost is displayed for the benefit of
    // the user.
    System.out.println("Total cost: " 
               + this.getTotalMaterialCost() + " dollars");
  }//end showOutput()
  //-----------------------------------------------------//

  private double getTotalMaterialCost(){
    //Send messages to the WoodenFrame and Canvas objects
    // asking them to return their total costs.  Add these
    // individual costs and return them as the total 
    // material cost for the project.
    return (canvas.getTotalCost() 
                            + woodenFrame.getTotalCost());
  }//end getTotalMaterialCost()
  //-----------------------------------------------------//
}//end class Ood03
//=======================================================//

class Canvas{
  //This class represents the material used to cover the
  // wooden frame for a painting.  It has length, width,
  // cost-per-square-foot, and binding margin attributes.
  // Each of these is represented by an instance
  // variable.
  //It uses mutator methods to set the values of the
  // instance variables.
  //It does not provide field accessors by which the
  // values of the instance variables can be read.  
  // However, it knows how to calculate the total material
  // cost for one instance of itself, and provides 
  // accessors by which higher-level representations of 
  // the instance variables can be obtained: total length,
  // total width, and total cost.
  
  //Instance variables
  private final double margin = 5.0;
  private double length; //length of the painting
  private double width; //width of the painting
  private double costPerSqFt; //cost of the canvas  
  //-----------------------------------------------------//
  
  //Mutator Methods
  //-----------------------------------------------------//
  
  public void setLength(double length){
    this.length = length;
  }//end setLength()
  //-----------------------------------------------------//
  
  public void setWidth(double width){
    this.width = width;
  }//end setWidth()
  //-----------------------------------------------------//
  
  public void setCostPerSqFt(double costPerSqFt){
    this.costPerSqFt = costPerSqFt;
  }//end setCostPerSqFt()
  //-----------------------------------------------------//
  
  //Accessor Methods
  //-----------------------------------------------------//
  
  public double getTotalLength(){
    //Total length is the length of the painting plus
    // the binding margin required to fold the canvas
    // under the frame and staple it.
    return (length + margin);
  }//end getTotalLength()
  //-----------------------------------------------------//

  //Total width is as described above.  
  public double getTotalWidth(){
    return (width + margin);
  }//end getTotalWidth()
  //-----------------------------------------------------//
  
  public double getTotalCost(){
    return (
     (((length+margin) * (width+margin))*costPerSqFt)/144);
  }//end getTotalCost()
  //-----------------------------------------------------//
}//end class Canvas
//=======================================================//

class WoodenFrame{
  //This class represents the wooden frame that is covered
  // with canvas for a painting.  It has length, width,
  // and cost-per-inch attributes which are stored in
  // instance variables.
  //It uses mutator methods to set the values of the
  // instance variables.
  //It does not provide field accessors by which the
  // values of the instance variables can be read.  
  // However, it knows how to calculate the total material
  // cost for one instance of itself, and provides 
  // accessors by which higher-level representations of 
  // the instance variables can be obtained: total length
  // of wood required and total cost.
  
  //Instance variables
  private double length; //of the painting  
  private double width; //of the painting
  private double costPerInch; //for the wood
  //-----------------------------------------------------//
  
  //Mutator Methods
  //-----------------------------------------------------//
  
  public void setLength(double length){
    this.length = length;
  }//end setLength()
  //-----------------------------------------------------//
  
  public void setWidth(double width){
    this.width = width;
  }//end setWidth()
  //-----------------------------------------------------//
  
  public void setCostPerInch(double costPerInch){
    this.costPerInch = costPerInch;
  }//end setCostPerInch()
  //-----------------------------------------------------//

  //Accessor Methods
  //-----------------------------------------------------//
  
  public double getTotalLengthToBuy(){
    //The total length of the wood required to build the
    // frame is twice the sum of the length and the width
    // of the painting.
    return (2*(length + width));
  }//end getTotalLengthToBuy()
  //-----------------------------------------------------//
  
  public double getTotalCost(){
    //The total cost of the wood is the product of the
    // total length of the wood in inches and the cost
    // per inch.
    return ((2*(length + width))*costPerInch);
  }//end getTotalCost()
  //-----------------------------------------------------//
}//end class WoodenFrame
//=======================================================//

//Note this is a general purpose class that is used to 
// service input from the keyboard and was not designed
// for this specific program.  Rather, it was taken, with
// permission by the author, from the book listed below.

// Simple input from the keyboard for all primitive types.
 // Copyright (c) Peter van der Linden,  May 5 1997.
 // Feel free to use this in your programs, as long as this
 // comment stays intact.
 //
 // This is not thread safe, not high performance, and 
 // doesn't service EOF.
 // It's intended for low-volume easy keyboard input.
 // An example of use is:
 //     EasyIn easy = new EasyIn();
 //     int i = easy.readInt();   
 // reads an int from System.in
 // See Just Java and Beyond, Third Edition by Peter
 // van der Linden

class EasyIn {    
  static InputStreamReader is = 
                        new InputStreamReader( System.in );
  static BufferedReader br = new BufferedReader( is );
  StringTokenizer st;

  StringTokenizer getToken() throws IOException {
    String s = br.readLine();
    return new StringTokenizer(s);
  }//end getToken()
     
  boolean readBoolean() {
    try {
      st = getToken();
      return new Boolean(st.nextToken()).booleanValue();
    }catch (IOException ioe) {
      System.err.println(
                    "IO Exception in EasyIn.readBoolean");
      return false;
    }//end catch
  }//end readBoolean()

  byte readByte(){
    try {
      st = getToken();
      return Byte.parseByte(st.nextToken());
    }catch (IOException ioe) {
      System.err.println(
                       "IO Exception in EasyIn.readByte");
      return 0;
    }//end catch
  }//end readByte()

  short readShort(){
    try {
      st = getToken();
      return Short.parseShort(st.nextToken());
    }catch (IOException ioe) {
      System.err.println(
                      "IO Exception in EasyIn.readShort");
      return 0;
    }//end catch
  }//end readShort()
     
  int readInt(){
    try {
      st = getToken();
      return Integer.parseInt(st.nextToken());
    }catch (IOException ioe) {
      System.err.println(
                        "IO Exception in EasyIn.readInt");
      return 0;
    }//end catch
  }//end readInt()

  long readLong(){
    try {
      st = getToken();
      return Long.parseLong(st.nextToken());
    }catch (IOException ioe) {
      System.err.println(
                      "IO Exception in EasyIn.readFloat");
      return 0L;
    }//end catch
  }//end readLong()

  float readFloat() {
    try {
      st = getToken();
      return new Float(st.nextToken()).floatValue();
    }catch (IOException ioe) {
      System.err.println(
                      "IO Exception in EasyIn.readFloat");
      return 0.0F;
    }//end catch
  }//end readFloat()

  double readDouble() {
    try {
      st = getToken();
      return new Double(st.nextToken()).doubleValue();
    }catch (IOException ioe) {
      System.err.println(
                     "IO Exception in EasyIn.readDouble");
      return 0.0;
    }//end catch
  }//end readDouble()

  char readChar() {
    try {
      String s = br.readLine();
      return s.charAt(0);
    }catch (IOException ioe) {
      System.err.println(
                       "IO Exception in EasyIn.readChar");
      return 0;
    }//end catch
  }//end readChar()

  String readString() {
    try {
      return br.readLine();
    }catch (IOException ioe) {
      System.err.println(
                     "IO Exception in EasyIn.readString");
      return "";
    }//end catch
  }//end readString
}//end class definition
//=======================================================//</PRE></TD>
</TR>
</TABLE>





<P><!-prev=Java031k.htm-><!-first=Java031.htm-></P>
<P>-end-</P><P><!--end-->
</P></BODY>
</HTML>
