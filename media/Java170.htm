<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.06 [en] (Win95; I) [Netscape]">
   <META NAME="AUTHOR" CONTENT="Richard G. Baldwin">
   <TITLE>... in Java by Richard G Baldwin</TITLE>
</HEAD>
<BODY>
<!--start-->
<CENTER>
<H3>
<B><I>Richard G Baldwin (512) 223-4758, <A HREF="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</A>,
<A HREF="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</A></I></B></H3></CENTER>

<CENTER>
<H2>
<B><!--title-->The AWT Package, Graphics- Introduction to Images<!--endTitle--></B></H2></CENTER>
Java Programming, Lecture Notes # 170, Revised 09/23/98.
<UL>
<LI>
<A HREF="#Preface">Preface</A></LI>

<LI>
<A HREF="#Introduction">Introduction</A></LI>

<LI>
<A HREF="#The drawImage() Method">The drawImage() Method</A></LI>

<LI>
<A HREF="#The Image Class">The Image Class</A></LI>

<UL>
<LI>
<A HREF="#Constants of the Image Class">Constants of the Image Class</A></LI>

<LI>
<A HREF="#Constructors of the Image Class">Constructors of the Image Class</A></LI>

<LI>
<A HREF="#Methods of the Image Class">Methods of the Image Class</A></LI>
</UL>

<LI>
<A HREF="#Classes and Interfaces that Support the Image Class">Classes
and Interfaces that Support the Image Class</A></LI>

<UL>
<LI>
<A HREF="#ImageProducer">Image Producer</A></LI>

<LI>
<A HREF="#MediaTracker">MediaTracker</A></LI>

<UL>
<LI>
<A HREF="#Constants of the MediaTracker Class">Constants of the MediaTracker
Class</A></LI>

<LI>
<A HREF="#Constructors of the MediaTracker Class">Constructors of the MediaTrackerClass</A></LI>

<LI>
<A HREF="#Methods of the MediaTrackerClass">Methods of the MediaTrackerClass</A></LI>
</UL>
</UL>

<LI>
<A HREF="#First Sample Program">First Sample Program</A></LI>

<UL>
<LI>
<A HREF="#Interesting Code Fragments for First Sample Program">Interesting
Code Fragments for First Sample Program</A></LI>

<LI>
<A HREF="#Program Listing for First Sample Program">Program Listing for
First Sample Program</A></LI>
</UL>

<LI>
<A HREF="#Second Sample Program">Second Sample Program</A></LI>

<UL>
<LI>
<A HREF="#Interesting Code Fragments for Second Sample Program">Interesting
Code Fragments for Second Sample Program</A></LI>

<LI>
<A HREF="#Program Listing for Second Sample Program">Program Listing for
Second Sample Program</A></LI>
</UL>

<LI>
<A HREF="#Third Sample Program">Third Sample Program</A></LI>

<UL>
<LI>
<A HREF="#Interesting Code Fragments for Third Sample Program">Interesting
Code Fragments for Third Sample Program</A></LI>

<LI>
<A HREF="#Program Listing for Third Sample Program">Program Listing for
Third Sample Program</A></LI>
</UL>
</UL>

<HR WIDTH="100%">
<CENTER>
<H2>
<A NAME="Preface"></A><B><FONT COLOR="#FF0000">Preface</FONT></B></H2></CENTER>
Students in Prof. Baldwin's <B>Advanced Java Programming</B> classes at
ACC are responsible for knowing and understanding all of the material in
this lesson.
<CENTER>
<H2>
<A NAME="Introduction"></A><FONT COLOR="#FF0000">Introduction</FONT></H2></CENTER>
This lesson provides an introduction to the handling of images in Java,
including sample programs that illustrates some of the methods used to
display an image in a <B>Frame</B> object. Subsequent lessons will provide
additional information including animation with double buffering and some
of the more complex image processing techniques.
<CENTER>
<H2>
<A NAME="The drawImage() Method"></A><FONT COLOR="#FF0000">The drawImage()
Method</FONT></H2></CENTER>
Methods from several different classes are used in the handling of images
in Java. The first thing we need to do is go back and review the <B>drawImage()</B>
method from the <B>Graphics</B> class, because it is the method used to
display an image.
<P>The JDK 1.1.3 documentation lists six different overloaded versions
of the <B>drawImage() </B>method with the brief descriptions given below.
More detailed information is available in the JDK documentation package.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>drawImage</B>(Image, int, int, Color, ImageObserver) - Draws as
much of the specified image as is currently available.&nbsp;
<P><B>drawImage</B>(Image, int, int, ImageObserver) - Draws as much of
the specified image as is currently available.&nbsp;
<P><B>drawImage</B>(Image, int, int, int, int, Color, ImageObserver) -
Draws as much of the specified image as has already been scaled to fit
inside the specified rectangle.&nbsp;
<P><B>drawImage</B>(Image, int, int, int, int, ImageObserver) - Draws as
much of the specified image as has already been scaled to fit inside the
specified rectangle.&nbsp;
<P><B>drawImage</B>(Image, int, int, int, int, int, int, int, int, Color,
ImageObserver) - Draws as much of the specified area of the specified image
as is currently available, scaling it on the fly to fit inside the specified
area of the destination drawable surface.&nbsp;
<P><B>drawImage</B>(Image, int, int, int, int, int, int, int, int, ImageObserver)
- Draws as much of the specified area of the specified image as is currently
available, scaling it on the fly to fit inside the specified area of the
destination drawable surface.</TD>
</TR>
</TABLE>
As you can see, there is a lot of flexibility available when actually drawing
the image. A more detailed description of one of the methods follows:
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<PRE>&nbsp;public abstract boolean drawImage(Image img,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int width,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageObserver observer)
&nbsp;&nbsp;&nbsp;&nbsp; Parameters:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img - the specified image to be drawn.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x - the x coordinate.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y - the y coordinate.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width - the width of the rectangle.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height - the height of the rectangle.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; observer - object to be notified as more of the image is converted.&nbsp;</PRE>
</TD>
</TR>
</TABLE>
With this version of the method, the image is drawn inside the specified
rectangle and <U>is scaled if necessary</U>. When invoked, this method
draws as much of the specified image as has already been scaled to fit
inside the specified rectangle.
<P>Transparent pixels do not affect whatever pixels are already there.
<P>This method returns immediately, even if the entire image has not yet
been scaled, and converted for the current output device. If the current
output representation is not yet complete, then <B>drawImage </B>returns
false. As more of the image becomes available, the process that draws the
image notifies the image observer by calling its <B>imageUpdate </B>method
and the image continues to be drawn in pieces.
<P>This is how the process is explained by Peter van der Linden in his
book <U>Just Java 1.1 and Beyond</U>:
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>"The <B>Component</B> class contains an <B>imageUpdate()</B> method.
When it is called, it schedules a <B>repaint</B>, allowing a little more
of the image to be drawn without interfering at all with your thread of
control."</TD>
</TR>
</TABLE>
He goes on to explain that a system property with a key value of <B>awt.image.incrementaldraw</B>
determines whether or not the image will be rendered in pieces as described
above. The default value of this property is <B>true</B>. When true, it
causes the system to draw parts of an image as they arrive. When <B>false</B>,
it causes the system to wait until all the image is loaded before drawing.
<P>A second system property with a key value of <B>awt.imager.redrawrate</B>
determines the minimum period in milliseconds between calls to <B>repaint()</B>
for images. The default value is 100 which only applies if the other system
property described above is <B>true</B>.
<P>System properties can be modified. Such modifications persist only for
the current invocation of the program.
<P>Three sample programs in this lesson illustrate the use of the <B>drawImage()</B>
method to draw an image. The first sample program illustrates the effect
of drawing individual portions of the image as the scaled portions become
available. This program produces a visual output that is not very satisfactory
because it tends to flash as successive calls to <B>imageUpdate</B> are
made in the drawing process.
<P>The second sample program eliminates this flashing problem by using
a <B>MediaTracker</B> object to block the thread, and delay the invocation
of <B>drawImage()</B> until the entire scaled image is available for drawing.
<P>According to the JavaSoft documentation, a scaled version of an image
will not necessarily be available immediately just because an unscaled
version of the image has been constructed for the output device. However,
this effect is not apparent in the second sample program.
<P>All of the parameters to the <B>drawImage()</B> method are pretty obvious
except for the last one which is described as follows:
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>observer - object to be notified as more of the image is converted.</TD>
</TR>
</TABLE>
Here is part of what John Zukowski has to say about this topic on page
35 in his book: <U>Java AWT Reference</U>.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>"For the time being, it's enough to say that the call to <B>drawImage()</B>
starts a new thread that loads the requested image. An image observer monitors
the process of loading an image; the thread that is loading the image notifies
the image observer whenever new data has arrived. ... it's safe to use
<B>this</B>
as the image observer in a call to <B>drawImage()</B>. More simply, we
could say that any component can serve as an image observer for images
that are drawn on it."</TD>
</TR>
</TABLE>
Zukowski has a lot more to say on the topic later on in his book.
<P>The <B>drawImage()</B> method has two parameters which are not primitive
int variables as highlighted in <B>boldface</B> below:
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<PRE>(<B>Image img,
</B>&nbsp;int x,
&nbsp;int y,
&nbsp;int width,
&nbsp;int height,
<B>&nbsp;ImageObserver observer</B>)</PRE>
</TD>
</TR>
</TABLE>
This suggests that we need to know more about the <B>Image</B> class and
the <B>ImageObserver</B> interface in order to be able to understand these
parameters.
<CENTER>
<H2>
<A NAME="The Image Class"></A><FONT COLOR="#FF0000">The Image Class</FONT></H2></CENTER>
As usual, the <B>Image</B> class consists of constants or variables, constructors,
and methods.
<CENTER>
<H3>
<A NAME="Constants of the Image Class"></A><FONT COLOR="#FF0000">Constants
of the Image Class</FONT></H3></CENTER>
One of the methods of the <B>Image</B> class is a method named <B>getScaledInstance()</B>
which returns a scaled version of an image. (We will use this method in
the third sample program in this lesson) One of the parameters to this
method is an <B>int</B> value that specifies which of several available
scaling algorithms is to be used in performing the scaling. All but one
of the following constants is used for the purpose of specifying the scaling
algorithm. The names and brief descriptions of the constants are generally
self-explanatory. Additional detail can be obtained from the JDK documentation
package.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<DL>
<DT>
<B>SCALE_AREA_AVERAGING</B> - Use the Area Averaging image scaling algorithm.&nbsp;</DT>

<P><BR><B>SCALE_DEFAULT</B> - Use the default image-scaling algorithm.&nbsp;
<P><B>SCALE_FAST</B> - Choose an image-scaling algorithm that gives higher
priority to scaling speed than smoothness of the scaled image.&nbsp;
<P><B>SCALE_REPLICATE</B> - Use the image scaling algorithm embodied in
the <B>ReplicateScaleFilter </B>class.&nbsp;
<P><B>SCALE_SMOOTH</B> - Choose an image-scaling algorithm that gives higher
priority to image smoothness than scaling speed.&nbsp;
<P><B>UndefinedProperty</B> - The <B>UndefinedProperty</B> object should
be returned whenever a property which was not defined for a particular
image is fetched.&nbsp;</DL>
</TD>
</TR>
</TABLE>
The last constant in this list is not used for scaling. Rather, it is used
as a return value from the method named <B>getProperties()</B> to indicated
that the requested property is not available.
<CENTER>
<H3>
<A NAME="Constructors of the Image Class"></A><FONT COLOR="#FF0000">Constructors
of the Image Class</FONT></H3></CENTER>
Although the <B>Image</B> class has a constructor, it is an <B>abstract</B>
class and an object of the class cannot be instantiated directly by invoking
the constructor.
<P>You can obtain an <B>Image</B> object indirectly by invoking the <B>getImage()</B>
method of either the <B>Applet</B> class or the <B>Toolkit</B> class. <B>getImage()</B>
uses a separate thread to fetch the image. The practical result of invoking
<B>getImage()
</B>is to associate an <B>Image</B> reference with a file located somewhere
that contains the image of interest. In this lesson, we will confine ourselves
to image files on the local hard disk, but they could be on a server somewhere
on the web.
<P>The thread starts execution when you call a method that requires image
information such as <B>drawImage()</B>.
<P>You can also obtain an <B>Image</B> object by invoking the <B>createImage()</B>
method of either the <B>Component</B> class or the <B>Toolkit</B> class.
<P>As we will see in two of the sample programs in this lesson, you can
also use the <B>MediaTracker</B> class to force an image to be loaded before
you invoke a method that requires the image information.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="Methods of the Image Class"></A><FONT COLOR="#FF0000">Methods
of the Image Class</FONT></H3></CENTER>
The seven methods of the <B>Image</B> class, along with brief descriptions
are listed below. You are referred to the JDK documentation for complete
descriptions of these methods.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<DL>
<DT>
<B><A HREF="#flush()">flush</A></B>() - Flushes all resources being used
by this <B>Image </B>object.&nbsp;</DT>

<P><BR><B><A HREF="#getGraphics()">getGraphics</A></B>() - Creates a graphics
context for drawing to an off-screen image.&nbsp;
<P><B><A HREF="#getHeight(java.awt.image.ImageObserver)">getHeight</A></B>(ImageObserver)
- Determines the height of the image.&nbsp;
<P><B><A HREF="#getProperty(java.lang.String, java.awt.image.ImageObserver)">getProperty</A></B>(String,
ImageObserver) - Gets a property of this image by name.&nbsp;
<P><B><A HREF="#getScaledInstance(int, int, int)">getScaledInstance</A></B>(int,
int, int) - Creates a scaled version of this image.&nbsp;
<P><B><A HREF="#getSource()">getSource</A></B>() - Gets the object that
produces the pixels for the image.&nbsp;
<P><B><A HREF="#getWidth(java.awt.image.ImageObserver)">getWidth</A></B>(ImageObserver)
- Determines the width of the image.</DL>
</TD>
</TR>
</TABLE>
We will use two of these methods in the sample programs in this lesson
and some of the others in subsequent lessons.
<P>As usual, we are interested not only in the <B>Image</B> class, but
also in the other classes required to instantiate parameters for the methods,
classes required to instantiate the objects returned from the methods,
and other classes which provide general support for the methods.
<P>A brief review of the above list, the JDK documentation, and several
books suggests that we should take a look at the following classes and
interfaces that support the methods of the <B>Image</B> class.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<UL>
<LI>
String&nbsp;</LI>

<LI>
ImageObserver&nbsp;</LI>

<LI>
ImageProducer&nbsp;</LI>

<LI>
Graphics&nbsp;</LI>

<LI>
Object&nbsp;</LI>

<LI>
MediaTracker&nbsp;</LI>
</UL>
</TD>
</TR>
</TABLE>

<CENTER>
<H2>
<A NAME="Classes and Interfaces that Support the Image Class"></A><FONT COLOR="#FF0000">Classes
and Interfaces that Support the Image Class</FONT></H2></CENTER>
Of the support classes listed in the previous section, you should already
know about <B>String, ImageObserver, Graphics</B>, and <B>Object</B>. We
will take a further look at <B>ImageProducer</B> and <B>MediaTracker</B>.
<CENTER>
<H3>
<A NAME="ImageProducer"></A><FONT COLOR="#FF0000">ImageProducer</FONT></H3></CENTER>
This is the interface for objects which can produce the image data for
Images.
<P>Each image contains an <B>ImageProducer </B>which is used to reconstruct
the image whenever it is needed. Examples of the need for reconstruction
might be when a new size of the <B>Image </B>is scaled, or when the width
or height of the Image is being requested.
<P>This interface declares several methods which generally have to do with
a concept involving <I>image producers</I> and <I>image consumers</I>.
We will have more to say about this in a subsequent lesson.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="MediaTracker"></A><FONT COLOR="#FF0000">MediaTracker</FONT></H3></CENTER>
This is a utility class designed to track the status of media objects.
In theory, media objects could include audio clips and other media as well
as images. However, JDK 1.1.3 is only capable of tracking the status of
images.
<P>You can use a media tracker object by instantiating an instance of <B>MediaTracker
</B>for
the <B>Component</B> that you want have monitored, and invoking its <B>addImage()</B>
method for each image that you want to track. Each image can be assigned
a unique identifier, or groups of images can be assigned the same identifier.
<P>According to the JDK 1.1.3 documentation, this identifier controls the
priority order in which the images are loaded. Images with a lower ID are
loaded in preference to those with a higher ID number.
<P>The identifier can also be used to identify unique subsets of images.
In other words, by assigning the same identifier to several images, you
can track them as a group.
<P>You can determine the status of an image (or group of images) by invoking
one of several methods on the <B>MediaTracker</B> object and passing the
identifier as a parameter to the method.
<P>You can also cause <B>MediaTracker</B> to block and wait until a specified
image (or group of images) completes loading. We will use this approach
in two of the sample programs to make certain that the image has completed
loading before we attempt to draw it.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="Constants of the MediaTracker Class"></A><FONT COLOR="#FF0000">Constants
of the MediaTracker Class</FONT></H3></CENTER>
This class provides four constants as described below. Full descriptions
of these constants can be found in the JDK documentation. As the names
suggest, each of these constants is used as a return value for one or more
of the methods (such as the method named <B>statusID()</B>) that can be
invoked to inquire as to the status of a given image.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<DL>
<DT>
<B>ABORTED</B> - Flag indicating that the downloading of some media was
aborted.&nbsp;</DT>

<P><BR><B>COMPLETE</B> - Flag indicating that the downloading of media
was completed successfully.&nbsp;
<P><B>ERRORED</B> - Flag indicating that the downloading of some media
encountered an error.&nbsp;
<P><B>LOADING</B> - Flag indicating some media is currently being loaded.&nbsp;</DL>
</TD>
</TR>
</TABLE>

<CENTER>
<H3>
<A NAME="Constructors of the MediaTracker Class"></A><FONT COLOR="#FF0000">Constructors
of the MediaTracker Class</FONT></H3></CENTER>
MediaTracker has a single constructor that can be invoked to instantiate
an object to track the status of some of all of the images on a particular
component. A brief description of the constructor follows:
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>MediaTracker</B>(Component) - Creates a media tracker to track images
for a given component.</TD>
</TR>
</TABLE>

<CENTER>
<H3>
<A NAME="Methods of the MediaTrackerClass"></A><FONT COLOR="#FF0000">Methods
of the MediaTrackerClass</FONT></H3></CENTER>
The <B>MediaTracker</B> class has a relatively large number of methods
that can be invoked on an object of the class for various purposes. The
following boxes provide a listing of the JDK 1.1.3 methods along with a
brief description of each. The methods have been grouped into several categories
in an attempt to make them easier to understand.
<P>A more complete description of each of the methods can be obtained from
the JDK documentation.
<H4>
<FONT COLOR="#FF0000">Building and Maintaining the List</FONT></H4>
A <B>MediaTracker</B> object has the ability to track the status of some
or all of the images being loaded for the particular <B>Component</B> that
was specified when the <B>MediaTracker</B> object was instantiated. The
following methods are use to build and maintain that list of images. When
you add an image to the list, you also specify a numeric identifier for
that image that is later used with the other methods to extract status
information about the image.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>addImage</B>(Image, int) - Adds an image to the list of images being
tracked by this media tracker.&nbsp;
<P><B>addImage</B>(Image, int, int, int) - Adds a scaled image to the list
of images being tracked by this media tracker.&nbsp;
<P><B>removeImage</B>(Image) - Remove the specified image from this media
tracker.&nbsp;
<P><B>removeImage</B>(Image, int) - Remove the specified image from the
specified tracking ID of this media tracker.&nbsp;
<P><B>removeImage</B>(Image, int, int, int) - Remove the specified image
with the specified width, height, and ID from this media tracker.</TD>
</TR>
</TABLE>

<H4>
<FONT COLOR="#FF0000">Waiting for Image(s) to finish Loading</FONT></H4>
A <B>MediaTracker</B> object can be used to cause its thread to block until
one or more of the images on its list have completed loading. This is accomplished
using the following methods. The first and third methods return void. The
second and fourth methods return <B>true</B> if all images were successfully
loaded and <B>false</B> otherwise.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD>
<DL>
<DT>
<B>waitForAll</B>() - Starts loading all images tracked by this media tracker.&nbsp;</DT>

<P><BR><B>waitForAll</B>(long) - Starts loading all images tracked by this
media tracker.&nbsp;
<P><B>waitForID</B>(int) - Starts loading all images tracked by this media
tracker with the specified identifier.&nbsp;
<P><B>waitForID</B>(int, long) - Starts loading all images tracked by this
media tracker with the specified identifier.&nbsp;</DL>
</TD>
</TR>
</TABLE>

<H4>
<FONT COLOR="#FF0000">Checking the Load Status of Images</FONT></H4>
It is also possible to use the following methods to check the status of
one or more images on the list without blocking the thread. This makes
it possible to continue doing other work while the image(s) are loading.
These methods return <B>true</B> or <B>false</B> to indicate if loading
is complete.
<P>You will note that there are two overloaded versions of each of these
methods. The version with the <B>boolean</B> parameter will start loading
any images that have not already started loading if the <B>boolean</B>
parameter is <B>true</B>. The other version will not start loading any
images. That is the general interpretation of the <B>boolean</B> parameter
in the other methods of this class that have a <B>boolean</B> parameter.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>checkAll</B>() - Checks to see if all images being tracked by this
media tracker have finished loading.&nbsp;
<P><B>checkAll</B>(boolean) - Checks to see if all images being tracked
by this media tracker have finished loading.&nbsp;
<P><B>checkID</B>(int) - Checks to see if all images tracked by this media
tracker that are tagged with the specified identifier have finished loading.&nbsp;
<P><B>checkID</B>(int, boolean) - Checks to see if all images tracked by
this media tracker that are tagged with the specified identifier have finished
loading.</TD>
</TR>
</TABLE>

<H4>
<FONT COLOR="#FF0000">Testing for Successful Load</FONT></H4>
The fact that one of the above methods indicates that loading is complete
is not a guarantee that the load was successful. The following methods
can be used to determine if there was a problem loading the images. These
methods either return a list or a <B>boolean</B>, depending on which is
required to satisfy the intent of the method.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>getErrorsAny</B>() - Returns a list of all media that have encountered
an error.&nbsp;
<P><B>getErrorsID</B>(int) - Returns a list of media with the specified
ID that have encountered an error.&nbsp;
<P><B>isErrorAny</B>() - Checks the error status of all of the images.&nbsp;
<P><B>isErrorID</B>(int) - Checks the error status of all of the images
tracked by this media tracker with the specified identifier.</TD>
</TR>
</TABLE>

<H4>
<FONT COLOR="#FF0000">Get the Numeric Status Value</FONT></H4>
The following methods return the bitwise inclusive <B>OR</B> of the integer
status values of the images being inquired about.
<TABLE BORDER BGCOLOR="#80FFFF" >
<TR>
<TD><B>statusAll</B>(boolean) - Calculates and returns the bitwise inclusive
<B>OR</B>
of the status of all media that are tracked by this media tracker.&nbsp;
<P><B>statusID</B>(int, boolean) - Calculates and returns the bitwise inclusive
<B>OR</B>
of the status of all media with the specified identifier that are tracked
by this media tracker.</TD>
</TR>
</TABLE>

<CENTER>
<H2>
<A NAME="First Sample Program"></A><FONT COLOR="#FF0000">First Sample Program</FONT></H2></CENTER>
This program illustrates loading and drawing an image without using <B>MediaTracker
</B>to
improve the visual effect. The use of <B>MediaTracker</B> is illustrated
in the second and third sample programs in this lesson.
<P>This program also illustrates:
<UL>
<LI>
Use of the <B>Toolkit </B>class and the <B>getImage()</B> method to associate
an image file on the local hard disk with the name of a reference variable
of type <B>Image</B>.</LI>

<LI>
Use of the <B>drawImage() </B>method to draw a loaded image onto a <B>Frame
</B>object.</LI>

<LI>
Use of the <B>getWidth()</B> and <B>getHeight()</B> methods to determine
the size of the image for drawing purposes.</LI>

<LI>
Use of the <B>translate()</B> method to eliminate the coordinate offset
caused by the insets of a <B>Frame </B>object.</LI>

<LI>
Use of an anonymous inner-class to service the "close" button on a Frame
object. This program was tested using JDK 1.1.3 under Win95.</LI>
</UL>

<CENTER>
<H3>
<A NAME="Interesting Code Fragments for First Sample Program"></A><FONT COLOR="#FF0000">Interesting
Code Fragments for First Sample Program</FONT></H3></CENTER>
The first interesting code fragment is the declaration of an instance variable
which is a reference variable of type <B>Image</B>. This reference is used
later to manipulate the image.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>class Image01 extends Frame{ //controlling class
<B>&nbsp; Image image; //reference to an Image object</B></PRE>
</TD>
</TR>
</TABLE>
<FONT COLOR="#000000">The next interesting code fragment is the statement
inside the constructor for the container that uses the <B>getImage()</B>
method of the <B>Toolkit</B> class to associate the image file named <B>logomain.gif</B>
with the reference variable named <B>image</B>.</FONT>
<P><FONT COLOR="#000000">It is important to note that this statement does
not cause the image to appear on the screen when its container becomes
visible. Rather, the container is visible for a noticeable period of time
before the image is actually drawn on the surface of that container.</FONT>
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; image =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().<B>getImage</B>("logomain.gif");</PRE>
</TD>
</TR>
</TABLE>
The next interesting code fragment is the code inside the overridden <B>paint()</B>
method that invokes one overloaded version of the <B>drawImage()</B> method
on the graphics context for the container. The parameter list for the version
used specifies the image to be drawn by the name of the reference variable
that refers to the image file on the local hard disk as its first parameter.
<P>The parameter list also specifies the coordinates where the upper left-hand
corner of the image is to be placed when the image is drawn (0,0 in this
case).
<P>The parameter list specifies the width and height of the rendered image.
Note that this version of the <B>drawImage()</B> method automatically scales
the image to force it to meet this size requirement.
<P>The <B>getWidth()</B> and <B>getHeight()</B> methods of the <B>Image</B>
class were used to determine the original width and height of the image
before scaling. These dimensions were then divided by 2 and passed as parameters
so that the rendered version of the image would be half its original size.
<P>Note that the <B>getWidth()</B> and <B>getHeight()</B> methods require
the image observer as a parameter. In this case, the container object specified
by <B>this</B> is the image observer.
<P>Finally, the <B>drawImage()</B> method requires the image observer as
its last parameter. Again, <B>this</B> was the image observer object.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; //Now draw it half its normal size.
&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image,0,0,image.<B>getWidth</B>(this)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.<B>getHeight</B>(this)/2,this);</PRE>
</TD>
</TR>
</TABLE>
A complete program listing for the first sample program follows in the
next section.
<CENTER>
<H3>
<A NAME="Program Listing for First Sample Program"></A><FONT COLOR="#FF0000">Program
Listing for First Sample Program</FONT></H3></CENTER>
Some of the interesting code fragments in the following program listing
are highlighted in <B>boldface</B>.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>/*File Image01.java
Copyright 1997, R.G.Baldwin
&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Image01 extends Frame{ //controlling class
<B>&nbsp; Image image; //reference to an Image object
</B>&nbsp;&nbsp;
&nbsp; public Image01(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(350,200);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get an image from the specified file in the current
&nbsp;&nbsp;&nbsp; // directory on the local hard disk.
<B>&nbsp;&nbsp;&nbsp; image =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().getImage("logomain.gif");
</B>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Make the Frame object visible.&nbsp; Note that the image
&nbsp;&nbsp;&nbsp; // is not visible on the Frame object when it first
&nbsp;&nbsp;&nbsp; // appears on the screen.
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor&nbsp;&nbsp;
//=======================================================//
&nbsp;&nbsp;
&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; //Translate origin to avoid insets.
&nbsp;&nbsp;&nbsp; g.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getInsets().left,this.getInsets().top);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now draw it half its normal size.
<B>&nbsp;&nbsp;&nbsp; g.drawImage(image,0,0,image.getWidth(this)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(this)/2,this);
</B>&nbsp; }//end paint()
//=======================================================//
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Image01();//instantiate this object
&nbsp; }//end main
}//end Image01 class
//=======================================================//</PRE>
</TD>
</TR>
</TABLE>

<CENTER>
<H2>
<A NAME="Second Sample Program"></A><FONT COLOR="#FF0000">Second Sample
Program</FONT></H2></CENTER>
The previous program did not provide a pleasing visual effect while the
image was being drawn on the screen as it was loading. For the image being
used in the test, which was not particularly large, there was a lot of
flashing while the image was being drawn on the screen.
<P>This problem was eliminated in the second program by using a <B>MediaTracker
</B>object
to block the thread until the image was fully loaded before attempting
to draw it on the screen.
<P>A maximum allowable load time of one second was specified. If the image
failed to load successfully within one second, the program would display
a message to that effect and terminate. A larger image, or an image loaded
from a slower source (such as a web server) might require more time.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="Interesting Code Fragments for Second Sample Program"></A><FONT COLOR="#FF0000">Interesting
Code Fragments for Second Sample Program</FONT></H3></CENTER>
Note that I am skipping those code fragments in this program which duplicate
the previous program. The first interesting <U>new code fragment</U> in
this program is the statement that instantiates a <B>MediaTracker</B> object.
The parameter to the constructor is the <B>Component</B> whose images are
to be tracked, which in this case is <B>this</B>.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; MediaTracker tracker = new MediaTracker(this);</PRE>
</TD>
</TR>
</TABLE>
The next interesting code fragment is the statement to add the image to
the list of images being tracked by the <B>MediaTracker</B> object. In
this case, the parameters are:
<UL>
<LI>
a reference to the image file and</LI>

<LI>
an <I>identifier</I> which is used later to inquire about the load status
of the image.</LI>
</UL>
Any <B>int</B> value can be used as the identifier. Recall that this value
also represents the priority for tracking with low values having the higher
priority.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image,1);//add image to tracker list</PRE>
</TD>
</TR>
</TABLE>
The next interesting code fragment is the invocation of the <B>waitForId()</B>
method on the tracker object. In this case, the identifier of the image
being tracked is passed as a parameter. Also a value of 1000 milliseconds
is passed as a parameter to cause the program to cease blocking and terminate
if the load of the image isn't completed within that time interval.
<P>This particular method returns <B>true </B>if the image was successfully
loaded and returns <B>false</B> otherwise. Some of the other methods that
can be used for similar purposes return void, in which case other means
should be taken to determine if the image was successfully loaded.
<P>In this program, the return value is used to terminate the program if
the image fails to load successfully. (Note the "!" operator in front of
the word tracker)..
<P>This method also throws an <B>InterruptedException</B> object which
is a <I>checked</I> exception. Therefore, the method call is enclosed in
a <B>try</B> block followed by a <B>catch</B> block.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Block for up to one second while trying to load
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the image. A larger image may require more time.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!tracker.<B>waitForID</B>(1,1000)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Failed to load image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</PRE>
</TD>
</TR>
</TABLE>
Finally, the <B>drawImage()</B> method is used as before to draw the image
on its container once it is loaded. This program provides a much more pleasing
visual experience than the previous program because only one draw operation
is executed to draw the entire image.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp; //Now draw it half its normal size.
&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image,0,0,image.getWidth(this)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(this)/2,this);</PRE>
</TD>
</TR>
</TABLE>
A complete program listing for this program follows in the next section.
<CENTER>
<H3>
<A NAME="Program Listing for Second Sample Program"></A><FONT COLOR="#FF0000">Program
Listing for Second Sample Program</FONT></H3></CENTER>
Some of the interesting code fragments in this complete program listing
are highlighted in <B>boldface.</B>
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>/*File Image02.java
Copyright 1997, R.G.Baldwin

This program illustrates the fetch and display of an
image.

In doing so, it also illustrates:

Use of the Toolkit class and the getImage() method to read
an image file from the local hard disk.

Use of a MediaTracker object to monitor the loading of
an image file from the local hard disk and block the&nbsp;
thread until the image is loaded.

Use of the drawImage() method to display a loaded image
onto a Frame object.

Use of the getWidth() and getHeight() methods to determine
the size of the image for drawing purposes.

Use of the translate() method to eliminate the coordinate
offset caused by the insets of a Frame object.

Use of an anonymous inner-class to service the "close"&nbsp;
button on a Frame object.
&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Image02 extends Frame{ //controlling class
&nbsp; Image image; //reference to an Image object
&nbsp;&nbsp;
&nbsp; public Image02(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(350,200);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get an image from the specified file in the current
&nbsp;&nbsp;&nbsp; // directory on the local hard disk.
&nbsp;&nbsp;&nbsp; image =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().getImage("logomain.gif");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Make the Frame object visible.&nbsp; Note that the image
&nbsp;&nbsp;&nbsp; // is not visible on the Frame object when it first
&nbsp;&nbsp;&nbsp; // appears on the screen.
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor&nbsp;&nbsp;
//=======================================================//
&nbsp;&nbsp;
&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; //Translate origin to avoid insets.
&nbsp;&nbsp;&nbsp; g.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getInsets().left,this.getInsets().top);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use a MediaTracker object to block until the image
&nbsp;&nbsp;&nbsp; // is fully loaded before attempting to draw it on the&nbsp;
&nbsp;&nbsp;&nbsp; // screen. If the image fails to load successfully
&nbsp;&nbsp;&nbsp; // within one second, terminate the program.&nbsp; Without&nbsp;
&nbsp;&nbsp;&nbsp; // the use of the MediaTracker object, the display of&nbsp;
&nbsp;&nbsp;&nbsp; // the image is very choppy while it is being loaded&nbsp;
&nbsp;&nbsp;&nbsp; // for the particular image being used.&nbsp; A smaller
&nbsp;&nbsp;&nbsp; // image may load and display more smoothly without
&nbsp;&nbsp;&nbsp; // use of MediaTracker.
<B>&nbsp;&nbsp;&nbsp; MediaTracker tracker = new MediaTracker(this);
&nbsp;&nbsp;&nbsp; tracker.addImage(image,1);//add image to tracker list
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Block for up to one second while trying to load
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the image. A larger image may require more time.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!tracker.waitForID(1,1000)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Failed to load image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}
</B>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now draw it half its normal size.
<B>&nbsp;&nbsp;&nbsp; g.drawImage(image,0,0,image.getWidth(this)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(this)/2,this);</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end paint()
//=======================================================//
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Image02();//instantiate this object
&nbsp; }//end main
}//end Image02 class
//=======================================================//</PRE>
</TD>
</TR>
</TABLE>

<CENTER>
<H2>
<A NAME="Third Sample Program"></A><FONT COLOR="#FF0000">Third Sample Program</FONT></H2></CENTER>
Although the two previous programs are rather simple, they illustrate a
number of important concepts involved in the handling of images in Java.
This third sample program illustrates some additional concepts.
<P>In this program, five separate scaled instances of an image are created
and drawn. This program illustrates the use of the <B>getScaledInstance()</B>
method of the Image class for producing multiple instances of an image
with different scaling.
<P>The program invokes the <B>getImage()</B> method on an object of the
<B>Toolkit
</B>class to associate an <B>Image </B>reference named <B>rawImage
</B>to
an image file on the local hard disk.
<P>Then the program invokes the <B>getScaledInstance()</B> method on the
<B>rawImage
</B>object five times in succession to produce five new scaled instances
of the image. A <U>different scaling algorithm</U> is used for each of
the new scaled instances of the image.
<P>A <B>MediaTracker </B>object is instantiated in the overridden <B>paint()</B>
method. The <B>rawImage </B>object as well as the five new scaled instances
are added to the list being tracked by the <B>MediaTracker </B>object.
All are added with the same identifier (same priority).
<P>The <B>waitForAll()</B> method of the <B>MediaTracker </B>class is used
to block the thread until all six of the image objects are loaded and properly
scaled. A noticeable pause of about 4 to 5 seconds occurs at this point
using JDK 1.1.3 under Win95 with a 133mhz Pentium processor. (This will
probably vary depending on the complexity and size of the image.)
<P>All five scaled images are then drawn on the screen. There are <U>no
obvious pauses</U> at this point. All five images appear on the screen
<U>almost
simultaneously</U>.
<P>In an earlier program written by this author, but not included in this
lesson, when a version of the <B>drawImage()</B> method that scales while
drawing the images was used, and several scaled versions of the image were
drawn, there were <U>noticeable pauses</U> and a <U>noticeable progression</U>
from the first to the last image as they were being drawn on the screen.
<P>Thus, the tradeoff is to incur the earlier pause while the thread is
blocked and the images are being scaled in order to achieve very fast drawing
of the scaled images. This program was tested using JDK 1.1.3 under Win95.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="Interesting Code Fragments for Third Sample Program"></A><FONT COLOR="#FF0000">Interesting
Code Fragments for Third Sample Program</FONT></H3></CENTER>
For the most part, only those code fragments that were not highlighted
in one of the previous programs will be highlighted here.
<P>The first interesting code fragment uses the <B>getImage()</B> method
to associate an <B>Image</B> reference variable named <B>rawImage </B>to
an image file in the current directory on the local hard disk. This is
essentially the same as the previous program. However, the reference variable
named <B>rawImage</B> is then used to create five additional scaled instances
of the image using the <B>getScaledInstance()</B> method.
<P>Each of the five scaled instances are created using a different scaling
algorithm where the algorithm being used is specified by the symbolic constant
in the third position of the parameter list (such as <B>SCALE_AREA_AVERAGING</B>
for example).
<P>The width and the height of the scaled instance are specified by the
first two parameters. If either of these parameters is -1, the scaled size
in pixels of the scaled instance is based on the other parameter and the
same height-to-width ratio as the original is maintained. If non-negative
values are passed for both parameters, the image will be scaled to fit
the rectangle defined by those parameters.
<P>A parameter value of -1 was used as the second parameter in all five
invocations of <B>getScaledInstance()</B> in this program. Also, all five
scaled instances were scaled to the same size using different scaling algorithms.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; rawImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().<B>getImage</B>("logomain.gif");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; image1 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_AREA_AVERAGING</B>);
&nbsp;&nbsp;&nbsp; image2 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_DEFAULT</B>);
&nbsp;&nbsp;&nbsp; image3 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_FAST</B>);
&nbsp;&nbsp;&nbsp; image4 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_REPLICATE</B>);
&nbsp;&nbsp;&nbsp; image5 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_SMOOTH</B>);</PRE>
</TD>
</TR>
</TABLE>
The next interesting code fragment occurs in the overridden <B>paint()</B>
method where the six <B>Image</B> references are added to the list of images
being tracked by a <B>MediaTracker</B> object. All six references are added
at the same priority level.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; MediaTracker tracker = new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Add images to the tracker list
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(rawImage,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image1,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image2,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image3,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image4,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image5,1);</PRE>
</TD>
</TR>
</TABLE>
The next interesting code fragment is the code to block the thread until
all six of the images have completed loading and scaling.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tracker.<B>waitForAll</B>();
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}</PRE>
</TD>
</TR>
</TABLE>
The final interesting code fragment shows the use of a <I>non-scaling</I>
version of the <B>drawImage()</B> method to draw the five pre-scaled images.
Because the method is not required to scale the images as they are being
drawn, the images appear on the screen almost simultaneously (in the blink
of an eye).
<P>Note that the <B>isErrorAny()</B> method was used (with a <B>not</B>
operator) to confirm that there were no load errors prior to invoking the
<B>drawImage()</B>
method to render the images to the screen.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; if(!tracker.<B>isErrorAny</B>()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image1,0,0,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image2,0,80,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image3,0,160,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image4,0,240,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image5,0,320,this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Load error");&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(1);
&nbsp;&nbsp;&nbsp; }//end else</PRE>
</TD>
</TR>
</TABLE>
A complete listing of the program is presented in the next section.
<CENTER>
<H3>
<A NAME="Program Listing for Third Sample Program"></A><FONT COLOR="#FF0000">Program
Listing for Third Sample Program</FONT></H3></CENTER>
Some of the interesting code fragments are highlighted in <B>boldface</B>
in the program listing that follows.
<TABLE BORDER BGCOLOR="#FFFF80" >
<TR>
<TD>
<PRE>/*File Image03.java
Copyright 1997, R.G.Baldwin

This program illustrates the use of the getScaledInstance()
method of the Image class.

The program invokes the getImage() method on an object of
the Toolkit class to associate an Image reference named
rawImage to an image file on the local hard disk.

Then the program invokes the getScaledInstance() method
on the rawImage object five times in succession to produce
five new scaled instances of the image.&nbsp; A different
scaling algorithm is implemented for each of the new
scaled instances of the image.

A MediaTracker object is instantiated in the overridden
paint() method.&nbsp; The rawImage object as well as the five
new scaled instances are added to the list being tracked
by the MediaTracker object.&nbsp; All are added with the same
identifier (same priority).
&nbsp;&nbsp;&nbsp;&nbsp;
The waitForAll() method of the MediaTracker class is used&nbsp;
to block the thread until all six of the image objects are
loaded and properly scaled.&nbsp; A noticeable pause of about
4 or 5 seconds occurs at this point using JDK 1.1.3 under
Win95 with a 133mhz Pentium processor.

All five scaled images are then drawn on the screen.&nbsp; There
are no obvious pauses at this point.&nbsp; All five images
appear on the screen almost simultaneously.

In an earlier program written by this author, but not
included in the lesson, when a version of the drawImage()
method that scales while drawing the images was used,
and several scaled versions of the image were drawn,
there was a noticeable progression from the first to the
last image as they were being drawn on the screen.

Thus, the tradeoff is to incur the earlier pause in order
to achieve very fast drawing of the scaled images.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Image03 extends Frame{ //controlling class
&nbsp; //references to Image objects
<B>&nbsp; Image rawImage,image1,image2,image3,image4,image5;</B>&nbsp;
&nbsp;&nbsp;
&nbsp; public Image03(){//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1997, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setSize(300,500);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get an image from the specified file in the current
&nbsp;&nbsp;&nbsp; // directory on the local hard disk.
&nbsp;&nbsp;&nbsp; rawImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().<B>getImage</B>("logomain.gif");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create five scaled instances of the image using each
&nbsp;&nbsp;&nbsp; // of the five different scaling algorithms
&nbsp;&nbsp;&nbsp; image1 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_AREA_AVERAGING</B>);
&nbsp;&nbsp;&nbsp; image2 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_DEFAULT</B>);
&nbsp;&nbsp;&nbsp; image3 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_FAST</B>);
&nbsp;&nbsp;&nbsp; image4 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_REPLICATE</B>);
&nbsp;&nbsp;&nbsp; image5 = rawImage.<B>getScaledInstance</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,-1,Image.<B>SCALE_SMOOTH</B>);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Make the Frame object visible.&nbsp; Note that the image
&nbsp;&nbsp;&nbsp; // is not visible on the Frame object when it first
&nbsp;&nbsp;&nbsp; // appears on the screen.
&nbsp;&nbsp;&nbsp; this.setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor&nbsp;&nbsp;
//=======================================================//
&nbsp;&nbsp;
&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; //Translate origin to avoid insets.
&nbsp;&nbsp;&nbsp; g.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getInsets().left,this.getInsets().top);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use a MediaTracker object to block until all images
&nbsp;&nbsp;&nbsp; // are scaled and loaded before attempting to draw&nbsp;
&nbsp;&nbsp;&nbsp; // them. Instantiate the object and add all five
&nbsp;&nbsp;&nbsp; // scaled images to the list.&nbsp;
&nbsp;&nbsp;&nbsp; MediaTracker tracker = new <B>MediaTracker</B>(this);
&nbsp;&nbsp;&nbsp; //Add images to the tracker list
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(rawImage,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image1,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image2,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image3,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image4,1);
&nbsp;&nbsp;&nbsp; tracker.<B>addImage</B>(image5,1);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Block until all images on the list are scaled and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // loaded.&nbsp; There is a noticeable pause of 4 or 5&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // seconds at this point using JDK 1.1.3 under Win95&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with a 133mhz Pentium processor.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tracker.<B>waitForAll</B>();
&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){System.out.println(e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now test for errors and draw all five images if no
&nbsp;&nbsp;&nbsp; // errors were detected.&nbsp; All five images appear
&nbsp;&nbsp;&nbsp; // on the screen almost simultaneously.
&nbsp;&nbsp;&nbsp; if(!tracker.<B>isErrorAny</B>()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image1,0,0,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image2,0,80,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image3,0,160,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image4,0,240,this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<B>drawImage</B>(image5,0,320,this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Load error");&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(1);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end paint()
//=======================================================//
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Image03();//instantiate this object
&nbsp; }//end main
}//end Image03 class
//=======================================================//</PRE>
</TD>
</TR>
</TABLE>
-end-
<!--end-->
</BODY>
</HTML>
