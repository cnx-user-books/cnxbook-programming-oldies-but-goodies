<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Linked-Lists, Stacks, and Queues<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 74, Revised 12/29/97.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#linked-lists">Linked Lists</a></li>

<li><a href="#stacks">Stacks</a></li>

<li><a href="#queues">Queues</a></li>

<li><a href="#ordered list">Ordered List</a></li>

<li><a href="#sample program">Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#test program">Test Program</a></li>

<li><a href="#program listing">Program Listing</a></li></ul>

<li><a href="#is a versus has a">Is A versus Has A</a></li></ul>

<hr align=left width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
This lesson was originally written on December 17, 1997 using the JDK 1.1.3
download and documentation package.

<p>Students in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
classes will be responsible for understanding all of the material in this
lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
Most computer science programs have a class or two dedicated to the study
of classical data structures. While a lot of that is no longer necessary
due to the inclusion of most of the classical data structures in readily
available class libraries, such a study still provides a good vehicle for
testing one's knowledge of important programming concepts.

<p>The watchword these days is<i> reuse, don't reinvent</i>. Therefore,
this lesson is not provided to encourage you to reinvent those data structures
that can be found in class libraries. Rather, this lesson is provided primarily
as a review of much of what you should have learned in the <b><u>Introductory
Java Programming</u></b> course at ACC.

<p>If you are enrolled in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
course and you have difficulty with any of the material in this lesson,
you probably are not well-prepared for the Intermediate course.

<p>While the program in this lesson does review much of what you should
have learned in the Introductory course, there is much more that you should
have learned that it doesn't review (Java arrays for example). Therefore,
a complete understanding of the material in this lesson does not provide
assurance that you learned everything that you should have learned in the
Introductory course. In other words, an understanding of the material in
this lesson is a "necessary but not sufficient" indicator of your readiness
for the Intermediate course.
<center><h2><a name="linked-lists"></a><font color="#ff0000">Linked Lists</font></h2></center>
A data structure is a structure implemented by a computer program that
is intended for the storage and retrieval of data in some structured manner.

<p>Some college professors have made a career of studying data structures
and hundreds of books on data structures have been written. This lesson
will not attempt to compete in that arena. Rather, this lesson will use
three classical types of data structures to illustrate object-oriented
programming concepts in Java.

<p>A <i>node</i>, as used in this lesson, is an object that can be used
to contain data.

<p>A <i>linked-list</i> is commonly thought of as a data structure consisting
of one or more <i>nodes</i>, deposited somewhere in memory, with <i>links
</i>connecting each node to the next node. Sometimes, <i>links </i>are
also provided to connect each node to the previous node. You can think
of the structure as something like a string of beads where each bead contains
some data, and they are linked together by the string.

<p>However, the physical locations of the nodes in memory may be very haphazard
and not nearly as neat as the physical arrangement of a typical string
of beads.

<p>A picture of the locations of the nodes in memory might look something
like what you would get if you put the beads on a very long, very flexible
string (with a lot of extra string between each pair of beads) and dropped
the whole thing on the floor.

<p>The physical arrangement of the beads on the floor would probably be
very haphazard, but it would still be possible to find any particular bead
by following the string.

<p>Linked lists come in the<i> singly-linked</i> and <i>doubly-linked</i>
varieties.

<p>With a <i>singly-linked list</i>, you can only access a node in the
middle of the string by starting at the first node and working your way
from node-to-node until you get to the one that you want. A singly-linked
list is a <i>one-way street</i> and you cannot go backwards in it.

<p>With a <i>doubly-linked list</i>, each node is linked to both the <i>next
</i>and the <i>previous </i>nodes so that it is possible to start at either
end and work your way toward the other end. A doubly-linked list is a two-way
street.

<p><u>In this lesson, we will confine ourselves to singly-linked lists</u>.

<p>In either case, data in the middle can only be accessed by starting
at one of the ends and moving to the desired data on a node-by-node basis.
Therefore, a linked-list is not a very good structure for accessing data
in a <i>random order</i>. However, it is a good structure for implementing
<i>stacks </i>and <i>queues </i>as we will see below.

<p>In this lesson, we will develop a general-purpose singly-linked list
from which we can subclass a stack class and a queue class.
<center><h2><a name="stacks"></a><font color="#ff0000">Stacks</font></h2></center>
A stack is commonly thought of as a last-in/first-out (LIFO) structure
for containing data. This means that when you retrieve data from the stack,
the packet of data most recently put into the stack is the first one that
will be retrieved. The next oldest will be the next to be retrieved, etc.

<p>Putting data into a stack is commonly referred to as <i>pushing </i>data
onto the stack. Retrieving data from a stack is commonly referred to as
<i>popping </i>data from the stack. Popping data from a stack physically
removes it from the stack. A given data item can only be popped once unless
you push it back onto the stack.

<p>The analogy often used for a stack is the stack of trays at a cafeteria.
The dishwasher person <i>pushes </i>clean trays onto the top of the stack
and customers <i>pop </i>them off.

<p>A linked-list is a reasonably good structure for implementing a stack.
To implement a stack with a linked-list, we simply need to attach new nodes
to and remove nodes from the same end of the list, thus achieving the LIFO
behavior that we need.

<p>The use of a linked-list as the underlying implementation of a stack
also provides a good illustration of the benefits of inheritance in object-oriented
programming. We will show that once we have developed a class for the linked
list, we can subclass that list with only a few lines of code to produce
the desired stack class.
<center><h2><a name="queues"></a><font color="#ff0000">Queues</font></h2></center>
A <i>queue </i>is commonly thought of a first-in/first-out (FIFO) structure
for containing data. This means that when you retrieve data from the <i>queue</i>,
the packet of data that has been in the <i>queue </i>the longest will be
the next packet to be retrieved.

<p>Putting data into a queue is commonly referred to as <i>enququeing </i>data
and retrieving data from a queue is often referred to as <i>dequeueing
</i>data.

<p>The common analogy used for a <i>queue </i>is the checkout line at the
supermarket. Assuming that no one "cuts the line", the person who has been
in line the longest will be the next person served by the cashier.

<p>A linked-list is also a reasonably good structure for implementing a
queue. To implement a queue with a linked-list, we simply need to attach
new nodes at one end and remove them from the other end. This provides
the FIFO behavior that we need.

<p>As with the stack, the use of a linked-list as the underlying implementation
of a queue provides a good illustration of the benefits of inheritance
in object-oriented programming. We will show that once we have developed
the class for the linked list (the same class used earlier to implement
the stack), we can subclass that list with only a few lines of code to
produce the desired queue class. Thus, we get two useful data structures
with only slightly more effort than is required for one.
<center><h2><a name="ordered list"></a><font color="#ff0000">Ordered List</font></h2></center>
An ordered list is one in which the data is maintained in some specified
order: numeric, alphabetic, alphanumeric, etc., and can be stored and retrieved
on the basis of some <i>key</i> value.

<p>Because of its poor random-access capabilities, a linked-list is not
a particularly good underlying structure for an ordered list. However,
the development of an ordered list using a linked-list does provide some
good illustrations of important Java programming concepts (such as the
use of interface types). Therefore, we will develop an ordered list in
the next lesson using an upgraded version of our general-purpose linked
list.

<p>Unlike the stack and queue described above, we won't get a lot of advantage
here (such as two for the price of one) because the upgraded linked-list
required to support the ordered list is much more complex than the one
required to support the stack and the queue. Therefore, in this lesson
we will develop the simple version. We will upgrade it to the more-complex
version in the next lesson.
<center><h2><a name="sample program"></a><font color="#ff0000">Sample Program</font></h2></center>
This program develops a general-purpose linked-list that supports the addition
and removal of new nodes at either the front end or the back end.

<p>This general-purpose linked-list is then subclassed to provide two more-specialized
data structures:
<ul><li>
Queue</li>

<li>
Stack</li></ul>
The data structures so produced operate with objects of the generic type
<b>Object </b>and therefore, can be used to accommodate <u>any type of
Java object</u>.

<p>By the way, let me point out at this time that in developing this program,
I didn't give much thought to access control: <b>public</b>, <b>private</b>,
<b>protected</b>, and <i>package</i>. It is not likely that you would want
to use this code for any serious purpose, but if you do, you will need
to review and probably upgrade the access control specifiers that were
used.

<p>Also let me point out that this program did not receive the kind of
exhaustive testing that should be applied to a program of this complexity,
so if you do elect to use it for any serious purpose, you should test it
thoroughly before using it.

<p>The testing that was performed was performed using JDK 1.1.3 under Win95.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
As is often the case, we will break the program up into a set of interesting
code fragments and discuss those fragments individually. A listing of the
complete program is provided at the end of the lesson so that you can see
all of the interesting code fragments in context.

<p>Our first interesting code fragment is the definition of a new exception
class that will be used to instantiate and throw exception objects whenever
exceptional conditions arise within the program.

<p>This class extends <b>Exception</b>. This might not be the best place
to connect a new exception class into the class hierarchy. I simply connected
it there because I didn't want to spend the time and effort required to
find the ideal spot to connect it.

<p>Actually, there might already be an exception class in the standard
API that would be suitable for this purpose. However, for purposes of illustration,
I wanted to include the definition and use of a new exception class because
this is something that you should already be familiar with.

<p>This class contains a single instance variable of type <b>String</b>
that can be used to encapsulate diagnostic information about the nature
of the exceptional condition. While string data is good for human consumption,
it isn't very good if you plan for your program to attempt to recover.
Therefore, you might want to define a set of numeric symbolic constants
to use for diagnostic information instead of using strings for this purpose.

<p>As you can see, the class provides a NoArg constructor as well as a
parameterized constructor. The parameterized constructor allows you to
instantiate a new object and initialize its instance variable with a string
describing the exceptional condition.

<p>It also provides an overridden version of the <b>toString()</b> method
that can be used to display the encapsulated diagnostic information on
the standard output device (or can be used for any other purpose where
a <b>String</b> representation of the exceptional condition might be useful).
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>Excep extends Exception</b>{
&nbsp; private <b>String </b>diagnosticData;//put diagnostic data here
&nbsp;&nbsp;
&nbsp; Excep(){//NoArg <b>constructor
</b>&nbsp;&nbsp;&nbsp; diagnosticData = "No diagnostic data provided";
&nbsp; }//end NoArg constructor

&nbsp; Excep(String diagnosticData){//parameterized <b>constructor
</b>&nbsp;&nbsp;&nbsp; this.diagnosticData = diagnosticData;
&nbsp; }//end parameterized constructor
&nbsp;&nbsp;
&nbsp; public String <b>toString</b>(){//override toString()
&nbsp;&nbsp;&nbsp; return diagnosticData;
&nbsp; }//end overridden toString()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Excep</pre></td></tr></table>
The next interesting code fragment is the class that is used to instantiate
a node in the data structure. It contains an embedded reference to an object
of whatever type is passed in as a parameter.

<p>Note that the incoming parameter to the constructor is a reference to
an object of the generic type <b>Object</b> and it is stored in an instance
variable that is a reference variable of type <b>Object</b>.

<p>You should recall that the generic type <b>Object</b> can be used as
the type for a reference variable that refers to an object of any type
in Java. In this particular program, we tested the data structures using
objects of a class named <b>TestClass</b>. The definition of <b>TestClass</b>
can be found in the program listing near the end of this lesson.

<p>This <b>Node</b> class contains two instance variables, both of which
refer to objects that (may) exist somewhere else in memory (a reference
variable with a value of <b>null</b> doesn't refer to an object). The first
instance variable named <b>dataObj</b> is used to refer to the data object
passed in as a parameter to the constructor for the node.

<p>The second instance variable is a reference to an object of the <b>Node</b>
type (this sometimes leads to a description of classes of this type as
self-referential classes) which will later be used to refer to the next
node in the linked-list. In other words, this reference variable can refer
to an object of the same type as the object that contains the reference
variable.

<p>Even though this reference variable doesn't initially refer to an object
(and therefore should contain <b>null</b>), it is not explicitly initialized
to <b>null</b>. Instance variables in java (which are references to objects)
are automatically initialized to <b>null </b>if you don't explicitly assign
them to an object when you instantiate the object that contains the instance
variable.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>Node</b>{
&nbsp; <b>Object </b>dataObj;//ref to data object is stored here
&nbsp; <b>Node </b>nextNode;//ref to the next node in the RawList
&nbsp;&nbsp;
&nbsp; public Node(<b>Object </b>dataObj){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; <b>this</b>.dataObj = dataObj;
&nbsp;&nbsp; }//end constructor
}//end class Node</pre></td></tr></table>
Later if the new node is attached to the back of the list, this reference
variable will already contain the required value of <b>null (</b>which
is used by the algorithms to indicate the end of the list).

<p>If the new node is attached to the front of the list, this reference
variable will be assigned a reference to the node that was previously the
first node in the list.

<p>Another thing to notice is the use of the <b>this</b> reference in the
constructor to refer to the object being constructed. Hopefully you completely
understand the concept of the <b>this</b> reference. In particular, note
that the <b>this</b> reference is used in this case to differentiate between
an instance variable of the class and a method parameter to the constructor
that has the same name, <b>dataObj</b>.

<p>These are important concepts. Make certain that you understand them
before going on.

<p>The next interesting code fragment is the class used to manage the list,
named <b>RawList</b>. This is a large class containing several methods,
so we will discuss this class in parts.

<p>You might think of an object of the <b>RawList</b> class as being a
<i>manager </i>object. In particular, an object of this class contains
the methods necessary to manage the linking of objects of the <b>Node</b>
class in such a way as to maintain a linked list of those objects.

<p>We will begin our discussion with the instance variables of the <b>RawList</b>
class.

<p>There are two instance variables in an object of this class, both of
which are references to objects of type <b>Node</b>. When an object of
this class is instantiated, these two instance variables are automatically
initialized to <b>null</b>.

<p>In operation, these two variables refer to the <i>fir</i>st node in
the list and the <i>last </i>node in the list. Therefore, at any point
in time, the <i>manager </i>object knows where the list starts, and where
it ends. However, except for the trivial case of a list containing only
one object, the <i>manager </i>object has no knowledge of how the list
snakes through memory (recall the image of the string of beads laying on
the floor in a haphazard fashion with lots of string between the individual
beads).
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>RawList</b>{
&nbsp; private Node <b>firstNode</b>;&nbsp; //reference to first node
&nbsp; private Node <b>lastNode</b>;&nbsp;&nbsp; //reference to last node</pre></td></tr></table>
The fact that these two instance variables are <b>private</b> means that
they are accessible only to the methods of this class. Therefore, even
the code in methods of other classes in the same package don't have access
to the list without going through the accessor methods of this class.

<p>Because the two instance variables are automatically initialized to
<b>null</b>, which is the desired state for a <b>RawList</b> object with
no nodes to manage, this class doesn't need an explicit constructor definition.

<p>The method in the next code fragment is used to instantiate a new object
of type <b>Node</b> and to encapsulate in that object a reference to another
object somewhere in memory that contains the data for the node. This method
returns a reference to the new node.

<p>By now you may be thinking that a linked list in Java consists of a
network of references, and if so, you are probably correct in your thinking.
Somewhere in memory there is some data, and that data is accessible by
traversing the references that link things together. Sometimes the code
required to traverse the links can be rather complicated (as we will see
in the ordered list example in the next lesson).

<p>This method is invoked by other methods in our program that need to
create new nodes and attach them to the front or the back of our linked
list. Since it is a utility method that is not needed outside the class,
it was made private.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; private Node <b>getNode</b>( Object dataObj)&nbsp; {
&nbsp;&nbsp;&nbsp; Node newNode = new Node(dataObj);
&nbsp;&nbsp;&nbsp; return newNode;
&nbsp; }//end getNode()</pre></td></tr></table>
The next code fragment describes a method that is almost trivial in its
simplicity. At various points in the program, it is necessary to determine
if the list is empty. The following method is designed for that purpose.
By definition, the list is empty if the reference variable named <b>firstNode</b>
contains a value of <b>null</b>.

<p>This method tests for that condition and returns <b>true</b> if empty,
and <b>false</b> if not empty. Obviously it wouldn't be difficult to make
this inline code whenever it is needed, but the use of the method with
the descriptive name causes the code to be more self-documenting.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; boolean <b>isEmpty</b>(){
&nbsp;&nbsp;&nbsp; return firstNode == null;//return true if empty
&nbsp; }//end isEmpty()</pre></td></tr></table>
Finally we come to a method that exhibits a modest amount of complexity.
This method, named <b>toFront</b> attaches a new node to the front of the
list.

<p>Note that it receives an incoming data object as the generic type <b>Object</b>
so it can accommodate any type of object.

<p>A call is made to the method discussed above named <b>getNode()</b>
to get a new node and to encapsulate the reference to the actual data object
in that node. The method named <b>getNode()</b> returns a reference to
the new <b>Node</b> object which is saved in a local variable named <b>newNode</b>.

<p>Following this, the method must attach the new node to the front of
the list. For the case of an empty list, this is a trivial operation. The
list is tested for empty, and if it is empty, the reference to the new
node is assigned to the instance variables of the <b>RawList</b> object
named <b>firstNode</b> and <b>lastNode</b>. In this case, the new node
becomes both the first and the last node in the list.

<p>If the list is <u>not empty</u>, some rewiring of the references is
required. (You need to get used to this rewiring because it becomes more
complicated as we go on, particularly in the lesson on the ordered list.)

<p>In this case, we need to cause the instance variable named <b>nextNode</b>
of the new <b>Node</b> object to refer to the object that was previously
the first node in the list. A reference to this object can be obtained
from the instance variable of the <b>RawList</b> object named <b>firstNode</b>.
So we obtain that reference and assign it to <b>newNode.nextNode</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; void <b>toFront</b>(<b>Object </b>dataObj){

&nbsp;&nbsp;&nbsp; Node <b>newNode </b>= this.<b>getNode</b>(dataObj);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>firstNode </b>= <b>lastNode </b>= <b>newNode</b>;
&nbsp;&nbsp;&nbsp; else{ //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>newNode</b>.<b>nextNode </b>= <b>firstNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>firstNode </b>= <b>newNode</b>;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toFront()</pre></td></tr></table>
Note the indirection involved here. We are obtaining a reference to an
object from the reference variable named <b>firstNode</b>, using the reference
variable named <b>newNode</b> to access the reference variable named <b>nextNode,</b>
and assigning the reference to the the first object in the list to the
reference variable named <b>nextNode</b>.

<p>On top of all that, the new object of type <b>Node</b> that we are referring
to contains a reference variable that refers to another object somewhere
in memory that contains our data (possibly involving some more indirection
handled by the virtual machine that we don't need to worry about).

<p><u>It gets much worse</u>. If you are uncomfortable with indirection,
perhaps you might consider a career in Pascal programming (but not ObjectPascal,
because that may be almost as bad).

<p>After we accomplish all of the above, we need to assign a reference
to the new node to the reference variable named <b>firstNode</b> in order
to cause the new node to become the first node in the list.

<p>The next interesting code fragment is the method that attaches a new
node to the back of the list. The operation is very similar to the previous
method. The primary difference is that in this case, we need to cause reference
variables in both the last node in the list and in the <b>RawList</b> object
to refer to the new node object. So, we assign a reference to the new node
to both <b>lastNode.nextNode</b> and <b>lastNode</b>.

<p>The <b>nextNode</b> reference variable in the new node was set to <b>null</b>
when the object was instantiated so we don't need to do anything with it
in this case. It already has the required value for the last node in the
list.

<p>Note that in this method and the previous method, the order in which
we assign references is critical to proper operation of the program. We
don't want to be standing on a limb and saw the limb off between our feet
and the trunk of the tree, which is just about what we will do if we don't
do the rewiring in the correct order.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; void <b>toBack</b>(Object dataObj){

&nbsp;&nbsp;&nbsp; Node <b>newNode </b>= this.<b>getNode</b>(dataObj);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = newNode;
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>lastNode</b>.<b>nextNode </b>= <b>newNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>lastNode </b>= <b>newNode</b>;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toBack()</pre></td></tr></table>
The next code fragment is a method named <b>fetchFromFront</b> that is
used to fetch a reference to the data object that is encapsulated in the
first node in the list and to remove that node from the list. Again, all
objects in this method are treated as the generic type <b>Object</b>, so
the method can accommodate objects of any type.

<p>To begin with, note that this method throws an exception of type <b>Excep</b>,
and this happens if the method is invoked on an empty list. We leave decisions
regarding what to do about the problem to the application program that
is using this class. We simply throw an exception to notify the application
program of the problem.

<p>Once we determine that the list is not empty, we declare a reference
variable of type <b>Node</b> and initialize it with a reference to the
first node in the list. We will use this variable to return the reference
to the data object when the method terminates.

<p>Recall that in Java, the garbage collector does not reclaim objects
until all references to those objects either cease to exist, or are set
to null. In this case, even though we are going to remove the node object
from the list, the data object will continue to exist and be accessible
through the reference that we are going to return to the calling method.
The data object will cease to exist only when the calling method ceases
to refer to it with an active reference variable.

<p>Note however, that the node object will become eligible for garbage
collection as soon as the method terminates because there will no longer
any active references to that object.

<p>Having disposed of the trivial case of an empty list, we need to also
consider another almost-trivial case: a list having only one node.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; Object <b>fetchFromFront</b>() <b>throws Excep</b>{
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw new Excep</b>("Empty list in fetchFromFront");
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>tempRefToNode </b>= <b>firstNode</b>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(<b>firstNode </b>== <b>lastNode</b>)//only one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>firstNode </b>= <b>lastNode </b>= <b>null</b>; //set both to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else//more than one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Wire around the first node and return it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>firstNode </b>= <b>firstNode.nextNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>tempRefToNode.dataObj</b>;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromFront()</pre></td></tr></table>
In this case, <b>firstNode</b> and <b>lastNode</b> both refer to the same
object. All we have to do to remove that object from the list is to set
<b>firstNode</b> and <b>lastNode</b> to <b>null</b>, which, by definition,
causes the list to be empty.

<p>That takes care of the trivial cases. Having determined that there are
at least two nodes in the list, we need to do some rewiring.

<p>In this case, we need to cause <b>firstNode</b> to refer to the second
node in the list (because we need to remove the first node in the list).
We can obtain a reference to the second node as <b>firstNode.nextNode</b>.
(Hopefully all this indirection is making sense to you at this point. If
not, you might need to review some of the material in the introductory
course.)

<p>Once we cause <b>firstNode</b> to refer to the second node in the list,
the second node becomes the first node, the previous first node is no longer
a part of the list, and our job is almost complete.

<p>However, we must return a reference to the data object encapsulated
in the <b>Node</b> object that was removed, and we do so by returning <b>tempRefToNode.dataObj</b>
that we discussed earlier.

<p>What we actually return is a copy of the reference to the data object,
but that is OK. If a burglar has your address or a copy of your address,
he or she can still find your house to burglarize.

<p>So even though we return a copy of the reference to the data object,
the calling method can use the copy to access the object. Also, the existence
of the copy of the reference is sufficient to keep the garbage collector
at bay for a little longer because we still have an active reference to
the data object.

<p>However, once this method terminates, there are no more active references
to the <b>Node</b> object that was removed from the list, so the <b>Node</b>
object becomes eligible for garbage collection.

<p>If this discussion of garbage collection sounds like <u>just so much
garbage to you</u>, consider going back and reviewing the material on garbage
collection in the introductory course.

<p>You might also want to take a look at the on-line book, <u>Thinking
in Java</u>, by Bruce Eckel which, as of this writing on 12/17/97 is available
for free downloading at www.eckelobjects.com. Eckel has a lot to say about
garbage collection and related matters.

<p>Because our linked list is a singly-linked list and is therefore a one-way
street,<u> removal of a node from the back</u> of the list is <u>more complex</u>
than removal from the front. In fact, it is so complex and inefficient
that we are going to avoid using it when we subclass the linked list to
create our <b>stack </b>and <b>queue </b>classes. However, since this program
is here primarily to illustrate important programming concepts, we will
discuss a method for removing an object from the back of the list.

<p>Before getting into that degree of complexity, lets take a look at another
method which is more complex than anything that we have seen so far, but
not quite as complex as removing an object from the back of the list.

<p>The following method named <b>printRawList()</b> is used to traverse
the list from front to back and to display the contents of the data objects
encapsulated in the individual nodes.

<p>Again we have the trivial case of the empty list where we simply display
the string "<b>Empty</b>" and terminate the method.

<p>Once we decide that the list is not empty, we need to execute the code
to traverse the list, one node at a time, and display what we find there.

<p>People who write books on data structures often talk about <i>iterators</i>.
In a nutshell, an <i>iterator </i>provides the capability to traverse all
the nodes in a data structure and take some specific action at each node
(such as squaring the value stored in the node, or displaying that value).

<p>Usually the design of <i>iterators </i>makes it possible for the <i>iterator
</i>method to make a call to another <u>user-specified method</u> when
it arrives at a node so that the user can design the desired behavior into
that <u>user-specified method</u>.

<p>In a crude sense, our method for printing the contents of the nodes
in our list is an extremely simple <i>iterator</i>. However, it does not
provide the ability for the user to define the behavior at each node. Rather,
that behavior is hard-coded into the method. (Some data-structures authors
might object to referring to this as an <i>iterator</i>, even an extremely
simple one.)

<p>In any event, whatever we choose to call it, the method named <b>printRawList</b>
has the ability to traverse the list from front to back and to display
the contents of each data object referred to by the reference variable
named <b>dataObj</b> that is encapsulated in each <b>Node</b> object.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; void <b>printRawList</b>(){
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("<b>Empty</b>");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Not empty.&nbsp; Declare and initialize a local&nbsp;
&nbsp;&nbsp;&nbsp; // reference variable to the first node in the list
&nbsp;&nbsp;&nbsp; Node <b>currentRefToNode </b>= <b>firstNode</b>;

&nbsp;&nbsp;&nbsp; //Use a while loop to traverse the list&nbsp; displaying
&nbsp;&nbsp;&nbsp; // the data object in each node along the way.
&nbsp;&nbsp;&nbsp; <b>while</b>(<b>currentRefToNode </b>!= <b>null</b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.<b>println</b>("" + <b>currentRefToNode.dataObj</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>currentRefToNode = currentRefToNode.nextNode</b>;
&nbsp;&nbsp;&nbsp; }//end while
&nbsp; }//end printRawList()</pre></td></tr></table>
Recall that the reference variable named <b>nextNode</b> contains <b>null</b>
in the last node in the list. We can use that fact to construct a conditional
expression for a <b>while</b> loop, and use the <b>while</b> loop to traverse
the list.

<p>To accomplish this, we declare a local reference variable of type <b>Node</b>
named <b>currentRefToNode </b>and initialize it to refer to the first node
in the list.

<p>We then drop into a <b>while</b> loop which will terminate when the
value of <b>currentRefToNode</b> becomes <b>null</b>.

<p>While we are in the loop, we use the <b>currentRefToNode</b> to extract
a reference to the data object that is stored in the instance variable
named <b>dataObj</b>.

<p>We use the overloaded concatenation form of the "<b>+</b>" operator
to convert our data object to a <b>String</b> object and pass that <b>String</b>
object to the <b>println()</b> method.

<p>We have overridden the <b>toString()</b> method in the definition of
the class from which our data object was instantiated, so this causes the
data object to be converted to a <b>String</b> object according to our
specifications (otherwise the concatenation operator would cause it to
be converted to a <b>String</b> object according to some default specification).
The <b>String</b> object is then passed to the <b>println()</b> method
that displays it on the standard output device.

<p>If it is not absolutely clear to you what is happening here, you will
need to go back and review some of the material in the introductory course.

<p>The <u>last thing that we do inside the loop</u> (before returning to
the top of the loop and testing the conditional expression again) is to
update the conditional variable (<b>currentRefToNode)</b> to cause it to
contain the value of the reference variable named <b>nextNode</b> in the
current node.

<p>The reference variable named <b>nextNode</b> in the last node in the
list contains a value of <b>null</b>. When we finish displaying the data
in the last node and perform this update, we will assign a value of <b>null</b>
to <b>currentRefToNode</b> causing the loop to terminate when the conditional
expression in the <b>while</b> loop is next evaluated.

<p>Well, that brings us to the <u>most complicated method</u> in our program:
a method named <b>fetchFromBack()</b> that <u>removes a node from the back</u>
of the list and returns a reference to the data object encapsulated in
that node.

<p>In a nutshell, what we have to do is <u>start at the front</u> of the
list and <u>walk the nodes</u> until we reach the next-to-last node. While
standing on the next-to-last node, we cut the wires that attach the node
we are standing on to the last node.

<p>This method starts out like previous methods; by testing to see if the
list is empty, and throwing an exception if it is empty.

<p>If the list is not empty, a test is made to see if there is only one
node, and if so, we simply set <b>firstNode</b> and <b>lastNode</b> to
<b>null</b> and return a reference to the data object encapsulated in the
node that occupied the list prior to that action.

<p>Things begin to get interesting when it is determined that the list
is not empty and it contains more than one node.

<p>Here we create another reference variable and point it at the first
node, giving us two local working variables.

<p>One variable refers to the first node. We will use it as a working variable
to traverse the list.

<p>The other variable refers to the last node. We will save it to use at
the end of the method when we return the reference to the data object encapsulated
in the last node.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; Object <b>fetchFromBack</b>() throws Excep{
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep("Empty list in fetchFromBack");
&nbsp;&nbsp;&nbsp; else { //RawList is <b>not empty
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>tempRefToNode </b>= <b>lastNode</b>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(firstNode == lastNode)//<b>only one node</b> in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = null;&nbsp; //<b>set both to null
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {//<b>more than one node</b> in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Declare and initialize another local&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>currentRefToNode </b>= <b>firstNode</b>;

<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(currentRefToNode.nextNode != lastNode)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;

</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>lastNode </b>= <b>currentRefToNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>currentRefToNode.nextNode = null</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return the data object from the saved last node.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>tempRefToNode.dataObj</b>;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromBack()</pre></td></tr></table>
To reiterate, the list is a one-way street. The last node can only be removed
by starting at the front and walking to the next-to-last node, stepping
on each node along the way. As in the printing method discussed earlier,
we will use a <b>while </b>loop to traverse the list, <u>stopping at the
node immediately before the last one</u>. Note the following syntax of
the conditional expression in the <b>while</b> loop that we use to stop
on the node immediately before the last one.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>(currentRefToNode.<b>nextNode </b>!= <b>lastNode</b>)</pre></td></tr></table>
The body of the <b>while </b>loop is essentially the same as in the previous
printing method except that we aren't doing any processing along the way.
Even so, for a large list, this is a very expensive operation.

<p>When the <b>while</b> loop terminates, we need to cut the last node
loose and set the <b>nextNode</b> reference in the current node to <b>null</b>
to indicate that it is now the last node in the list.

<p>We cut the last node loose by setting <b>lastNode</b> to refer to the
next-to-the-last node. This reference is contained in the variable named
<b>currentRefToNode</b>.

<p>We then set the <b>nextNode</b> reference variable in the node referred
to by <b>currentRefToNode</b> to <b>null</b> causing it to be the last
node insofar as some of our algorithms are concerned.

<p>All we have left to do at this point is to return a reference to the
data object encapsulated in the node that we just finished cutting loose.

<p>A reference to this node is stored in the reference variable named <b>tempRefToNode</b>,
so we use that reference variable to access and return a reference to the
data object using the following syntax:
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>tempRefToNode.dataObj</b>;</pre></td></tr></table>
This method is <u>very inefficient</u>, and as mentioned earlier, we won't
use it when we subclass the <b>RawList</b> class. It has been presented
here primarily for illustration and as a mind-expanding exercise. Also
some of the programming concepts embodied here will be required in the
next lesson where we define an <b>OrderedList</b> class.

<p>In this program we have illustrated <u>two different ways</u> to detect
the end of the list. One way is to use the null reference and the other
is to use the reference stored in the reference variable named <b>lastNode</b>.
This latter approach is more self-documenting and slightly less complicated.

<p>That brings us to the end of the class definition for the class named
<b>RawList</b>. We now have a class that defines a general-purpose linked-list
class that we can use for a variety of purposes.

<p>In this lesson, we are going to use the <b>RawList</b> class for two
purposes. In particular, we will extend this class into two new classes.
One of the new classes can be used to instantiate objects that exhibit
the LIFO behavior of a <i>stack</i>. The other can be used to instantiate
objects that exhibit the FIFO behavior of a <i>queue</i>.

<p>It is very important to note that these are completely general data
structures insofar as the type of data that they can accommodate is concerned
(as long as the data is object data).

<p>Objects of any type (including mixed types) can be accommodated by these
structures. If you need to use them to accommodate the primitive types,
such as <b>int</b>, you can use the <i>wrapper</i> classes to turn those
primitive variables into objects. Hopefully you remember what the <i>wrapper</i>
classes are.

<p>The next code fragment is the class that extends the <b>RawList</b>
class to produce a <i>queue </i>class named <b>MyQueue</b>. This class
subclasses the class named <b>RawList </b>in such a way as to provide <i>queue
</i>behavior for objects instantiated from the class.. A <i>queue </i>is
a FIFO structure. FIFO behavior can be accomplished by entering data into
the <i>back </i>of a <b>RawList </b>object and removing it from the <i>front
</i>of the object.

<p>As you can see, this is a very simple class. Except for the class header
line and the required method signatures, there are only four lines of code
in the entire class definition. Those four lines of code invoke the methods
of the <b>RawList </b>class on a <u>selective basis</u> to provide methods
to <b>enqueue</b>, and <b>dequeue </b>objects, to <u>print the contents</u>
of the queue, and to inquire if the <u>queue is empty</u>.

<p>As an exercise for the student, explain why we elected to add to the
back and remove from the front instead of adding to the front and removing
from the back. Either approach would have provided the required FIFO behavior.

<p>Again, note that this class works exclusively with objects of the generic
type <b>Object</b>, and can therefore accommodate objects of any type,
or possibly of mixed types.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>MyQueue extends RawList</b>{
&nbsp; public void <b>enqueue</b>(Object obj){
&nbsp;&nbsp;&nbsp; this.<b>toBack</b>(obj);//enqueue data to the back of the list
&nbsp; }//end enqueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public Object <b>dequeue</b>() throws Excep{
&nbsp;&nbsp;&nbsp; //dequeue data from the front of the list
&nbsp;&nbsp;&nbsp; return this.<b>fetchFromFront</b>();
&nbsp; }//end dequeue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void <b>printQueue</b>(){
&nbsp;&nbsp;&nbsp; this.<b>printRawList</b>();//use the existing print capability
&nbsp; }//end printQueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean <b>isQueueEmpty</b>(){
&nbsp;&nbsp;&nbsp; return this.<b>isEmpty</b>();//use the existing empty test
&nbsp; }//end isQueueEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyQueue</pre></td></tr></table>
The next code fragment defines a class that extends the <b>RawList </b>class
in such a way as to provide <i>stack </i>behavior. A <i>stack </i>is a
LIFO structure. LIFO behavior can be achieved by attaching data to the
<u>front</u> of the list and removing it from the <u>front</u> of the list.

<p>As with the <i>queue </i>class, exclusive of class header and method
signatures, only <u>four lines of code</u> were required to give us the
ability to <b>push</b> and <b>pop</b> objects, to <u>display</u> the objects,
and to inquire if the <u>stack is empty</u>.

<p>Again, the class works exclusively with objects of the generic type
<b>Object</b> meaning that it will accommodate objects of any type.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>MyStack extends RawList</b>{
&nbsp; public void <b>push</b>(Object obj){
&nbsp;&nbsp;&nbsp; this.<b>toFront</b>(obj);//attach new data to front of list
&nbsp; }//end push

&nbsp; public Object <b>pop</b>() throws Excep{
&nbsp;&nbsp;&nbsp; return this.<b>fetchFromFront</b>();
&nbsp; }//end pop()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void <b>printStack</b>(){
&nbsp;&nbsp;&nbsp; this.<b>printRawList</b>();//use existing print capability
&nbsp; }//end printStack()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean <b>isStackEmpty</b>(){
&nbsp;&nbsp;&nbsp; return this.<b>isEmpty</b>();//use the existing empty test
&nbsp; }//end isStackEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyStack</pre></td></tr></table>
Hopefully these last two class have illustrated the power of inheritance
in object-oriented programming. By doing a careful job of designing and
implementing our basic linked-list class, we were able to extend that class
into two other extremely useful classes by writing only eight lines of
code.

<p>In the next lesson, we will add more methods to the <b>RawList</b> class
to make it suitable for extending it into an <b>ordered list</b> class.
This class can be used to instantiate <b>ordered list</b> objects which
will manage a list of other objects in an ordered fashion.

<p>That will be a fairly complex programming task, but will be a good illustration
of additional programming concepts such as the use of interface types and
the oft-used requirement to cast objects of type <b>Object</b> into specific
types in order to access their instance members..
<center><h3><a name="test program"></a><font color="#ff0000">Test Program</font></h3></center>
A method named <b>test()</b> is provided with this program to test the
operation of the <i>linked-list</i>, <i>stack</i>, and <i>queue</i>. You
can view that code, along with the output produced by invoking the test
method, in the program listing in the next section.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
A complete listing of the program follow so that you can view the entire
program in context.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File List02.java
Copyright 1997, R.G.Baldwin

This program develops a general-purpose linked-list that
supports the addition and removal of new nodes at either
the front or the back.

This general-purpose linked-list is then subclassed to
provide two more-specialized data structures:
&nbsp;&nbsp;
Queue
Stack

In all cases, the data structures so produced operate
with objects of the generic type Object.

The output from running this program is shown below:
//------------------------------------------
Test the unordered list
Put some data objects in the unordered list
The unordered list contains:
One
Two
Three
Four

Remove data objects from the unordered list
Removed One
Removed Four
Removed Two
The unordered list now contains:
Three
Removed Three
The unordered list now contains:
Empty
Remove another object from the unordered list
Exception: Empty list in fetchFromFront

Test the queue
Put some data objects in the queue
The queue contains:
One
Two
Three
Four

Try to remove 5 data objects from the queue
Dequeued One
Dequeued Two
Dequeued Three
Dequeued Four
Exception: Empty list in fetchFromFront

Test the stack
Push some data objects on the Stack
The stack contains:
Four
Three
Two
One

Try to pop 5 data objects from the Stack
popped Four
popped Three
popped Two
popped One
Exception: Empty list in fetchFromFront
End of test
//------------------------------------------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;
//=======================================================//
class TestClass{
&nbsp; //This class is used to test the data structures.
&nbsp; //An object of this class contains a single instance
&nbsp; // variable which is an object of type String.
&nbsp; String data;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; TestClass(String data){//constructor
&nbsp;&nbsp;&nbsp; this.data = data;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public String toString(){//overridden toString() method
&nbsp;&nbsp;&nbsp; return (data);
&nbsp; }//end toString()
&nbsp; //-----------------------------------------------------//
}//end TestClass

//=======================================================//


/*This class is the controlling class which is used to test
the data structures developed in this lesson.&nbsp; This
class contains a method named test() which designed to
exercise the capabilities of the unordered linked-list,
stack, queue, and ordered list.
---------------------------------------------------------*/

class List02{//controlling class
&nbsp; public static void main(String[] args){//main
&nbsp;&nbsp;&nbsp; List02 obj = new List02();//instantiate this object&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; obj.test();//invoke the method named test()
&nbsp; }//end main
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; void test(){
&nbsp;&nbsp;&nbsp; System.out.println("Test the unordered list");
&nbsp;&nbsp;&nbsp; RawList theList = new RawList();//instantiate list obj
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Put some data objects in the unordered list");
&nbsp;&nbsp;&nbsp; theList.toFront(new TestClass("Two"));
&nbsp;&nbsp;&nbsp; theList.toBack(new TestClass("Three"));
&nbsp;&nbsp;&nbsp; theList.toFront(new TestClass("One"));
&nbsp;&nbsp;&nbsp; theList.toBack(new TestClass("Four"));
&nbsp;&nbsp;&nbsp; System.out.println("The unordered list contains:");
&nbsp;&nbsp;&nbsp; theList.printRawList();

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nRemove data objects from the unordered list");
&nbsp;&nbsp;&nbsp; try{//because an exception of type Excep can be thrown
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theList.fetchFromFront());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theList.fetchFromBack());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theList.fetchFromFront());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The unordered list now contains:");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theList.printRawList();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theList.fetchFromBack());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The unordered list now contains:");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theList.printRawList();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Remove another object from the unordered list");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theList.fetchFromFront());
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("\nTest the queue");
&nbsp;&nbsp;&nbsp; //instantiate a MyQueue object
&nbsp;&nbsp;&nbsp; MyQueue theQueue = new MyQueue();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Put some data objects in the queue");
&nbsp;&nbsp;&nbsp; theQueue.enqueue(new TestClass("One"));
&nbsp;&nbsp;&nbsp; theQueue.enqueue(new TestClass("Two"));
&nbsp;&nbsp;&nbsp; theQueue.enqueue(new TestClass("Three"));
&nbsp;&nbsp;&nbsp; theQueue.enqueue(new TestClass("Four"));
&nbsp;&nbsp;&nbsp; System.out.println("The queue contains:");
&nbsp;&nbsp;&nbsp; theQueue.printQueue();

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nTry to remove 5 data objects from the queue");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 5; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Dequeued "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + theQueue.dequeue());
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("\nTest the stack");
&nbsp;&nbsp;&nbsp; //instantiate a MyStack object
&nbsp;&nbsp;&nbsp; MyStack theStack = new MyStack();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Push some data objects on the Stack");
&nbsp;&nbsp;&nbsp; theStack.push(new TestClass("One"));
&nbsp;&nbsp;&nbsp; theStack.push(new TestClass("Two"));
&nbsp;&nbsp;&nbsp; theStack.push(new TestClass("Three"));
&nbsp;&nbsp;&nbsp; theStack.push(new TestClass("Four"));
&nbsp;&nbsp;&nbsp; System.out.println("The stack contains:");
&nbsp;&nbsp;&nbsp; theStack.printStack();

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nTry to pop 5 data objects from the Stack");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 5; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("popped " + theStack.pop());
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}
&nbsp;&nbsp;&nbsp; System.out.println("End of test");
&nbsp; }//end test()
}//end controlling class named class02
//=======================================================//
//=======================================================//

//This is the beginning of the classes that are used to
// instantiate several different kinds of data structures.

//=======================================================//
//=======================================================//

//This is a new exception class that is used to instantiate
// exception objects for a variety of different exceptional
// conditions within the data structure methods.

class Excep extends Exception{
&nbsp; private String diagnosticData;//put diagnostic data here
&nbsp;&nbsp;
&nbsp; Excep(){//NoArg constructor
&nbsp;&nbsp;&nbsp; diagnosticData = "No diagnostic data provided";
&nbsp; }//end NoArg constructor

&nbsp; Excep(String diagnosticData){//parameterized constructor
&nbsp;&nbsp;&nbsp; this.diagnosticData = diagnosticData;
&nbsp; }//end NoArg constructor
&nbsp;&nbsp;
&nbsp; public String toString(){//override toString()
&nbsp;&nbsp;&nbsp; return diagnosticData;
&nbsp; }//end overridden toString()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Excep
//=======================================================//

//This class is used to instantiate a node in the data
// structure.&nbsp; It contains an embedded object of whatever
// type is passed in as a parameter.&nbsp; The test class
// provide with this program uses objects of the class
// namedTestClass.

class Node{
&nbsp; Object dataObj;&nbsp; //data object is stored here
&nbsp; Node nextNode;//reference to the next node in the RawList
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public Node(Object dataObj){//constructor
&nbsp;&nbsp;&nbsp; this.dataObj = dataObj;//store incoming dataObj
&nbsp; }//end constructor
}//end class Node
//=======================================================//

//Begin definition of the class used to create
//and maintain a raw list
class RawList{
&nbsp; private Node firstNode;&nbsp; //reference to first node
&nbsp; private Node lastNode;&nbsp;&nbsp; //reference to last node

&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Function to allocate memory and return a reference&nbsp;
&nbsp; // variable for a new node.
&nbsp; private Node getNode( Object dataObj)&nbsp; {
&nbsp;&nbsp;&nbsp; //get reference variable to new memory
&nbsp;&nbsp;&nbsp; Node newNode = new Node(dataObj);
&nbsp;&nbsp;&nbsp; return newNode;
&nbsp; }//end getNode()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Method to determine if The structure is empty
&nbsp; boolean isEmpty(){
&nbsp;&nbsp;&nbsp; return firstNode == null;//return true if empty
&nbsp; }//end isEmpty()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Attach a new node to the front of the RawList
&nbsp; void toFront(Object dataObj){
&nbsp;&nbsp;&nbsp; //Encapsulate the incoming object in an object of type
&nbsp;&nbsp;&nbsp; // node and assign it to a local reference variable.
&nbsp;&nbsp;&nbsp; Node newNode = this.getNode(dataObj);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now attach the new node to the front of the list&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = newNode;
&nbsp;&nbsp;&nbsp; else{ //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newNode.nextNode = firstNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = newNode;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toFront()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Attach a new node to the back of the RawList
&nbsp; void toBack(Object dataObj){
&nbsp;&nbsp;&nbsp; //Encapsulate the incoming object in an object of type
&nbsp;&nbsp;&nbsp; // node and assign it to a local reference variable.
&nbsp;&nbsp;&nbsp; Node newNode = this.getNode(dataObj);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now attach the new node to the back of the list&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = newNode;
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode.nextNode = newNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode = newNode;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toBack()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to fetch and delete a node from&nbsp;
&nbsp; // the front of the RawList.&nbsp; Note that all objects are
&nbsp; // treated as objects of the generic type Object.
&nbsp; Object fetchFromFront() throws Excep{
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Empty list in fetchFromFront");
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node tempRefToNode = firstNode;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(firstNode == lastNode)//only one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = null; //set both to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else//more than one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Wire around the first node and return it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = firstNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempRefToNode.dataObj;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromFront()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to fetch and delete a node from the
&nbsp; // back of the RawList
&nbsp; Object fetchFromBack() throws Excep{
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Empty list in fetchFromBack");
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node tempRefToNode = lastNode;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(firstNode == lastNode)//only one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = null;&nbsp; //set both to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {//more than one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Declare and initialize another local&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The list is a one-way street.&nbsp; The last node can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only be removed by starting at the front and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // walking to the end touching each node along the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // way.&nbsp; Use a while loop to traverse the list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stopping at the node immediately before the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(currentRefToNode.nextNode != lastNode)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Cut the last node loose and set the reference
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the next node in the new last node to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to indicate the new end of the list.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode = currentRefToNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return the data object from the saved last node.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempRefToNode.dataObj;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromBack()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to display the contents of the&nbsp;
&nbsp; // RawList object.
&nbsp; void printRawList(){
&nbsp;&nbsp;&nbsp; if(this.isEmpty()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Empty");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Not empty.&nbsp; Declare and initialize a local&nbsp;
&nbsp;&nbsp;&nbsp; // reference variable to the first node in the list
&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode;

&nbsp;&nbsp;&nbsp; //Use a while loop to traverse the list&nbsp; displaying
&nbsp;&nbsp;&nbsp; // the data object in each node along the way.
&nbsp;&nbsp;&nbsp; while(currentRefToNode != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("" + currentRefToNode.dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp; }//end while
&nbsp; }//end printRawList()
}//end class RawList
//=======================================================//

//The above class was used to provide the raw list which
// serves as a superclass for the following specialized
// subclasses.
//=======================================================//

//This class subclasses the class named RawList in such
// a way as to provide queue behavior.&nbsp; A queue is a&nbsp;
// first-in/first-out structure.&nbsp; This can be accomplished
// by entering data into the back of a RawList object and
// removing it from the front of the object.

//As you can see, this is a very simple class.&nbsp; It simply
// invokes the methods of the RawList class on a selective
// basis.
class MyQueue extends RawList{
&nbsp; public void enqueue(Object obj){
&nbsp;&nbsp;&nbsp; this.toBack(obj);//enqueue data to the back of the list
&nbsp; }//end enqueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public Object dequeue() throws Excep{
&nbsp;&nbsp;&nbsp; //dequeue data from the front of the list
&nbsp;&nbsp;&nbsp; return this.fetchFromFront();
&nbsp; }//end dequeue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void printQueue(){
&nbsp;&nbsp;&nbsp; this.printRawList();//use the existing print capability
&nbsp; }//end printQueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean isQueueEmpty(){
&nbsp;&nbsp;&nbsp; return this.isEmpty();//use the existing empty test
&nbsp; }//end isQueueEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyQueue
//=======================================================//

//This class is used to subclass the RawList class in
// such a way as to provide stack behavior.&nbsp; A stack is a
// last-in/first-out structure.&nbsp; This can be accomplished
// by attaching data to the front of the list and
// removing it from the front of the list.
class MyStack extends RawList{
&nbsp; public void push(Object obj){
&nbsp;&nbsp;&nbsp; this.toFront(obj);//attach new data to front of list
&nbsp; }//end push

&nbsp; public Object pop() throws Excep{
&nbsp;&nbsp;&nbsp; //remove new data from the front of the list
&nbsp;&nbsp;&nbsp; return this.fetchFromFront();
&nbsp; }//end pop()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void printStack(){
&nbsp;&nbsp;&nbsp; this.printRawList();//use existing print capability
&nbsp; }//end printStack()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean isStackEmpty(){
&nbsp;&nbsp;&nbsp; return this.isEmpty();//use the existing empty test
&nbsp; }//end isStackEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyStack
//=======================================================//</pre></td></tr></table>

<center><h2><a name="is a versus has a"></a><font color="#ff0000">Is A versus Has A</font></h2></center>
In case you haven't noticed, this program has a major structural flaw.
In particular, there is nothing to keep user code from instantiating an
object of the <b>MyQueue </b>or <b>MyStack </b>classes, and then using
that object to invoke methods on the <b>RawList</b> class that violate
the <i>LIFO</i> and <i>FIFO</i> rules of access for a <i>stack</i> or a
<i>queue<b>.</b></i> That is because <b>MyStack</b> and <b>MyQueue</b><i>extend</i> <b>RawList</b> which makes all the methods of the superclass
available via an object of the subclass.
<br>&nbsp;
<table border bgcolor="#80ff80" ><tr><td>C++ has a way of dealing with this situation involving a second-level
specification of access control at the inheritance interface. However,
that capability does not exist in Java.</td></tr></table>
There is an easy way and a hard way to fix this problem in Java. The easy
way is based on <i>composition</i> rather than inheritance. This means
to create an object of the <b>RawList</b> class as a <b>private </b>instance
variable of the <b>MyQueue</b> and <b>MyStack</b> classes instead of extending
<b>RawList</b> into those two classes. This changes the relationship between
the classes from an "<b>is a</b>" relationship to a "<b>has a</b>" relationship,
and is a good example of the functional differences between the two different
relationships.

<p>Once you do this, the code in the methods of <b>MyQueue</b> and <b>MyStack</b>
have access to the methods of the <b>RawList</b> object, but those methods
are hidden from code outside the two classes. This requires minimal modifications
to the program code, and will be left as an exercise for the student.

<p>The hard way assumes that for some reason, you need to continue to extend
<b>RawList</b> into <b>MyQueue</b> and <b>MyStack </b>(to maintain the
"<b>is a</b>" relationship). In this case, you can override the methods
of the <b>RawList</b> class in the subclasses and cause an exception to
be thrown whenever the overridden versions of those methods are accessed.
Then in order to make these methods available to the code in the subclasses,
you can invoke those methods using the <b>super</b> keyword ahead of the
method invocation. This will cause the superclass version, as opposed to
the overridden version to be invoked. This involves considerably more modifications
to the program code, and will also be left as an exercise for the student.

<p>-end-<!--end--></body></html>