<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">Creating a lasso for editing digital photos in Java</h2>
<i>Learn how to write the code to use the mouse to create a lasso on an image in 
Java.&nbsp; This capability is critical to the editing of digital photos.</i><p><b>Published:</b>&nbsp; 
March 19, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 359</p>
<ul>
	<li><a href="#Preface">Preface</a>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_from_earlier_lessons">What you have 
		learned from earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul>
		</li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	</li>
	<li><a href="#General Background Information">General background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
		<li><a href="#Software_installation_and_testing">Software installation 
		and testing</a></li>
	</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion and Sample Programs">Discussion and sample code</a><ul>
		<li><a href="#Introductory_remarks">Introductory remarks</a></li>
		<li><a href="#The_program_named_Lasso02">The program named Lasso02</a><ul>
		<li><a href="#The_constructor">The constructor</a></li>
		<li><a href="#Registering_listener_objects">Registering listener objects</a></li>
		<li><a href="#The_method_named_makeRectLasso">The method named 
		makeRectLasso</a></li>
		<li><a href="#The_method_named_processRectPixels">The method named 
		processRectPixels</a></li>
		<li><a href="#The_method_named_makeCircleLasso">The method named 
		makeCircleLasso</a></li>
		<li><a href="#The_method_named_processCirclePixels_">The method named 
		processCirclePixels</a></li>
	</ul>
		</li>
	</ul>
	</li>
	<li><a href="#Run the program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete Program Listings">Complete program listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Edit the color of your digital photos</li>
	<li>Create a lasso to isolate pixels by dragging the mouse in an image.</li>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_from_earlier_lessons">What you have learned 
from earlier lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> in this 
series, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>About the HSB color model and how to use that model to adjust the hue, 
	saturation, and brightness of your digital photos. </li>
	<li>Many aspects of image processing, including color distance, projecting 
	3D coordinates onto a 2D display plane, and edge detection.</li>
	<li>How to write an animated flocking program.</li>
	<li>How to sharpen or soften your digital photos.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p>You will learn how to write the code to create a circular lasso to isolate a group of pixels 
as shown by the black circle around the red pupil in the eyeball in Figure 1.&nbsp; 
Having written the code to create the lasso, you will learn how to write the code 
required to process the pixels isolated by the lasso.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. A circular lasso surrounding the red pupil 
	of an eyeball. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="2" src="java359a1.jpg" width="138" height="109"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A rectangular lasso</b></font></p>
<p>You will also learn how to write the code to create a rectangular lasso with an 
inscribed ellipse as shown in Figure 2.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. A rectangular lasso with an inscribed 
	ellipse. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java359a2.jpg" width="329" height="271"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In this case, you can write code to process the pixels isolated by the 
rectangle, the pixels isolated by the ellipse, or some combination of the two.</p>
<p>Being able to create a lasso to isolate a group of pixels for subsequent 
processing is a critical aspect of editing digital photos.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. A circular lasso surrounding the red 
	pupil of an eyeball. </li>
	<li><a href="#Figure_2">Figure 2</a>. A rectangular lasso with an inscribed 
	ellipse. </li>
	<li><a href="#Figure_3">Figure 3</a>. The eyeball with all of the red 
	removed from the pupil. </li>
	<li><a href="#Figure_4">Figure 4</a>. Processed pixels in the rectangular, 
	elliptical lasso. </li>
	<li><a href="#Figure_5">Figure 5</a>. Program GUI at startup. </li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the class named 
	Lasso02. </li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the constructor. </li>
	<li><a href="#Listing_3">Listing 3</a>. Beginning of an ActionListener 
	registered on the text field. </li>
	<li><a href="#Listing_4">Listing 4</a>. Load the image file. </li>
	<li><a href="#Listing_5">Listing 5</a>. Get the information required to 
	write the output files. </li>
	<li><a href="#Listing_6">Listing 6</a>. Create a separate Picture object 
	that will be used for processing.</li>
	<li><a href="#Listing_7">Listing 7</a>. Get and save several useful 
	references. </li>
	<li><a href="#Listing_8">Listing 8</a>. Adjust the width and location of the 
	GUI. </li>
	<li><a href="#Listing_9">Listing 9</a>. Enable and disable components. </li>
	<li><a href="#Listing_10">Listing 10</a>. Register a MouseListener object on 
	the JFrame containing the image. </li>
	<li><a href="#Listing_11">Listing 11</a>. Register a MouseMotionListener 
	object on the JFrame containing the image. </li>
	<li><a href="#Listing_12">Listing 12</a>. Finish defining the ActionListener 
	on the text field. </li>
	<li><a href="#Listing_13">Listing 13</a>. Register an ActionListener object 
	on the Write button. </li>
	<li><a href="#Listing_14">Listing 14</a>. Register a WindowListener object 
	on the GUI. </li>
	<li><a href="#Listing_15">Listing 15</a>. Register an ActionListener object 
	on the Process Pixels button. </li>
	<li><a href="#Listing_16">Listing 16</a>. Beginning of the method named 
	makeRectLasso. </li>
	<li><a href="#Listing_17">Listing 17</a>. Get the angle of the diagonal 
	line. </li>
	<li><a href="#Listing_18">Listing 18</a>. Create the rectangle and the 
	ellipse in the correct quadrant. </li>
	<li><a href="#Listing_19">Listing 19</a>. Draw the rectangle and the 
	ellipse. </li>
	<li><a href="#Listing_20">Listing 20</a>. Beginning of the method named 
	processRectPixels. </li>
	<li><a href="#Listing_21">Listing 21</a>. Change the colors of the pixels. </li>
	<li><a href="#Listing_22">Listing 22</a>. Beginning of the method named 
	makeCircleLasso. </li>
	<li><a href="#Listing_23">Listing 23</a>. Compute the angle. </li>
	<li><a href="#Listing_24">Listing 24</a>. Construct and draw a circular 
	ellipse. </li>
	<li><a href="#Listing_25">Listing 25</a>. The method named 
	processCirclePixels. </li>
	<li><a href="#Listing_26">Listing 26</a>. Source code for the program named 
	Lasso02.<b> </b></li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample 
programs that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>Several weeks ago, I needed to write the code to create a circular lasso to 
isolate a group of pixels for subsequent processing.&nbsp; My initial reaction was that 
although I had never written such code, it would be a simple matter to find 
a tutorial somewhere on the web that would show me how to do it.</p>
<p>I couldn't have been more wrong.&nbsp; Despite hours of searching the web, I 
couldn't find a website where the requirement was even discussed in the context 
of Java programming, much less a website that showed how to do it.&nbsp; 
Therefore, I concluded that I would have to figure out how to do it on my own.&nbsp; 
This tutorial is based on the fruits of that effort.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="Introductory_remarks">Introductory remarks</a></h3>
<p>In this lesson, I will explain a program named <b>Lasso02</b> that was used to 
produce the images with the lassos in Figure 1 and Figure 2.&nbsp; In addition 
to showing you how to write the code to create the lassos, I will also show you how 
to write code to process the pixels isolated by the lassos.&nbsp; For example, 
Figure 3 shows an image similar to Figure 1 where all of the red color has been 
removed from the pixels that were isolated by the circular lasso.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. The eyeball with all of the red removed 
	from the pupil. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="2" src="java359a3.jpg" width="137" height="112"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Not very attractive</b></font></p>
<p>Figure 3 isn't the most attractive look around, but it does illustrate the 
use of a circular lasso.&nbsp; <i>(I will explain a proper redeye correction program in 
a future lesson.)</i></p>
<p><font color="#FF0000">
 <b>Processed pixels in the rectangular, elliptical lasso</b></font></p>
<p>The image in Figure 4 is similar to the one shown in Figure 2.&nbsp; However, 
in Figure 4, all of the green color was removed from the pixels isolated by the 
ellipse and all of the red color was removed from the pixels that were isolated 
by the rectangle, but were outside the ellipse.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Processed pixels in the rectangular, 
	elliptical lasso. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java359a4.jpg" width="329" height="271"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h3><a name="The_program_named_Lasso02">The program named Lasso02</a></h3>
<p>This is a demonstration program that shows how to create two different lasso 
styles by dragging a mouse across an image in a <b>Picture</b> object.</p>
<p><font color="#FF0000"><b>The graphical user interface (GUI)</b></font></p>
<p>The program begins by displaying a GUI in the upper left corner of the screen 
as shown in Figure 5.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Program GUI at startup. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java359a5.jpg" width="227" height="137"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>At startup, the GUI contains a text field for entry of the name of the 
image file to be processed and some other user-input components, which 
are disabled.&nbsp; <i>(A default image file name is automatically entered into 
the text field to assist in testing and debugging the program.)</i></p>
<p><font color="#FF0000"><b>Required location of image file</b></font></p>
<p>If the image file is in the current directory, only the file name and 
extension must be entered.&nbsp; Otherwise, the full path, name, and extension for the 
file must be entered.&nbsp; Files of types jpg, bmp, and png are supported.</p>
<p><font color="#FF0000"><b>The image is loaded and the GUI is relocated</b></font></p>
<p>When the user 
enters the name of the image file into the text field, the image file is loaded into a 
<b>Picture</b> object.&nbsp; The Picture object is displayed in the upper left corner of the 
screen and the GUI is moved to a location immediately below the Picture object.</p>
<p><font color="#FF0000"><b>Disable and enable components</b></font></p>
<p>At 
this point, the text field and its label are disabled.&nbsp; The two <b>JButton</b> objects and 
the two <b>JRadioButton</b> objects are enabled.&nbsp; One button is labeled <b>Process Pixels</b> and the other button is labeled 
<b>Write</b>.&nbsp; One of the radio buttons is labeled <b>Rect/Ellipse</b> and the other radio button is 
labeled <b>Circle</b>.&nbsp; The <b>Rect/Lasso</b> button is initially selected 
by default.</p>
<p><font color="#FF0000"><b>Creating a rectangular lasso</b></font></p>
<p>When the <b>Rect/Ellipse</b> button selected, the user can drag the mouse in the 
image to create a lasso consisting of a rectangle with an inscribed 
ellipse as shown in Figure 2.</p>
<p>The rectangle containing the ellipse can be created in any quadrant relative 
to the anchor point, which is the location at which the drag operation begins.&nbsp; 
One corner of the rectangle will always touch the anchor point.&nbsp; The 
diagonal length of the rectangle is equal to the distance from the anchor point 
to the mouse pointer.</p>
<p><font color="#FF0000"><b>Creating a circular lasso</b></font></p>
<p>When the 
<b>Circle</b> button is selected, the user can drag the mouse in the image to create a 
circular lasso as shown by the black circle surrounding the red pupil in the 
eyeball in Figure 1.&nbsp; The circle can be created in any direction relative 
to the anchor point.&nbsp; The diameter of the circular lasso is equal to the 
distance from the anchor point to the mouse pointer.</p>
<p><font color="#FF0000"><b>Dragging outside the picture</b></font></p>
<p>Dragging the mouse outside the bounds of the 
picture causes the size of the either lasso to continue to grow until the mouse 
reaches the edge of the desktop.</p>
<p><font color="#FF0000"><b>Setting the shape and size</b></font></p>
<p>Creation of the lasso ends 
and the shape and size of the lasso becomes fixed when the user releases the mouse button.&nbsp; 
At this point, the lasso remains on the screen until 
the user clicks the image with the mouse, clicks the <b>Process Pixels</b> button, or does something else to cause the image to be repainted, 
<i>(such as minimizing and then restoring the <b>JFrame</b> object that contains the 
picture)</i>.</p>
<p><font color="#FF0000"><b>Processing the pixels isolated by the lasso</b></font></p>
<p>After the lasso has 
been drawn, the button labeled <b>Process Pixels</b> can be clicked to call a 
method to process the pixels that are isolated by the lasso.&nbsp; Different methods are called for the two 
different styles of lasso 
in this program.&nbsp; The method is selected on the basis of which radio button is selected 
when the <b>Process Pixels</b> button is clicked.&nbsp; You can modify 
either or both of these methods to satisfy your own pixel-processing needs.</p>
<p>For 
the <b>Rect/Ellipse</b> lasso, the method can be written to process all of the 
pixels that are isolated by the rectangle, the ellipse, or a combination of the 
two.&nbsp; For the <b>Circle</b> lasso, the method can be written to process all of the pixels 
that are isolated by the circle.&nbsp; Another alternative would be to write methods 
to process all of the pixels that are not contained in the lasso.</p>
<p><font color="#FF0000"><b>Refreshing the display</b></font></p>
<p>Clicking 
anywhere in the image will erase an existing lasso and allow the user to start 
over with a clean image to create a new lasso.&nbsp; Clicking the image also erases 
the effects of having previously clicked the <b>Process Pixels</b> button.</p>
<p><font color="#FF0000"><b>Backup files</b></font></p>
<p>Clicking the <b>Write</b> button 
causes a backup file of type bmp to be written into the directory from which the 
image file was read.&nbsp; The five most recent backup files are saved.&nbsp; The names of the 
backup files are the same as the name of the original image file except that the 
characters BAKn are inserted immediately before the extension.&nbsp; The character n is 
replaced by a digit from 0 through 4.</p>
<p><font color="#FF0000"><b>Terminating the program</b></font></p>
<p>Clicking the large X in the upper-right 
corner of the <b>JFrame</b> object that contains the image does nothing.&nbsp; The button is disabled.&nbsp; The program is 
terminated by clicking the large X in the upper-right corner of the GUI.</p>
<p>Before 
terminating, the program writes an output file containing the final state of the 
display in the same format as the input file.&nbsp; The name of the output file is the 
same as the name of the input file except that the word FINAL is 
inserted immediately before the extension.</p>
<p>This program does not modify the 
contents of the original input file.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>As is my practice, I will explain this program by breaking it down into code 
fragments.&nbsp; A complete listing of the program is provided in Listing 26 
near the end of the lesson.</p>
<p><font color="#FF0000">
<b>Beginning of the class named Lasso02</b></font></p>
<p>The program begins in Listing 1.&nbsp; Many different instance variables are 
declared at the beginning of the program.&nbsp; I deleted most of them from Listing 1 
for brevity.&nbsp; You can view them in Listing 26.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the class named Lasso02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Lasso02 extends JFrame{
  //Create the components that are used to construct the
  // GUI.
  private JPanel mainPanel = new JPanel();
  
  //Instance variables deleted for brevity.

  private final double pi = Math.PI;//convenience constant
  //----------------------------------------------------//

  public static void main(String[] args){
    new Lasso02();
  }//end main method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method is shown in Listing 1.&nbsp; This is a totally 
event-driven program.&nbsp; The <b>main</b> method simply instantiates a new object of 
the class named <b>Lasso02</b>.</p>
<h3><a name="The_constructor">The constructor</a></h3>
<p>The constructor creates the GUI, loads the 
image file into the display frame, and registers a variety of event handlers on 
different components.&nbsp; Then the program essentially goes idle waiting for 
the user to cause events to be fired.&nbsp; The event handlers control the behavior of the 
program when events are fired as a result of user activity.</p>
<p><font color="#FF0000">
<b>Beginning of the constructor</b></font></p>
<p>The constructor begins in Listing 2.&nbsp; Much of the code in the early part 
of the constructor is required simply to build up the GUI as a series of panels, 
buttons, etc.&nbsp; I assumed that you are familiar with such code and 
deleted most of it from Listing 2 for brevity.&nbsp; You can view this code in Listing 26.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public Lasso02(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());

    //Code deleted for brevity.

    //Disable the buttons until the user enters the file
    // name.
    writeButton.setEnabled(false);
    processButton.setEnabled(false);
    rectButton.setEnabled(false);
    circleButton.setEnabled(false);

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);

    //Request that the focus move to the text field where
    // the file name is to be entered.
    fileNameField.requestFocus();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Disable buttons and radio buttons</b></font></p>
<p>Once the physical aspects of the GUI are constructed, the code in Listing 2 disables the two <b>
JButton</b> objects and the two <b>JRadioButton</b> objects to prevent them from 
firing events before the image file has been loaded.&nbsp; They are subsequently 
enabled by the event handler that is executed as a result of the user entering 
the name of the image file into the text field shown in Figure 5.</p>
<p><font color="#FF0000"><b>Miscellaneous housekeeping details</b></font></p>
<p>Then Listing 2 adds the GUI to the content pane, calls the <b>pack</b> method 
to cause the overall size to be set consistent with the preferred sizes of the 
components, and calls the <b>setVisible</b> method to cause the GUI to become 
visible on the screen.</p>
<p>Finally Listing 2 requests that the focus be moved to the text field to make 
it easier to enter the image file name in the text field.</p>
<h3><a name="Registering_listener_objects">Registering listener objects</a></h3>
<p>This is where things start to get a little more interesting.&nbsp; The 
remaining code in the constructor registers listener objects on the JFrame 
object that contains the image and various GUI components.</p>
<p><font color="#FF0000">
<b>Beginning of an ActionListener registered on the text field</b></font></p>
<p>Listing 3 shows the 
beginning of an anonymous <b>ActionListener</b> that is registered on the text 
field.&nbsp; When the user enters the file name in the text field, the code in 
the event handler sets everything up properly so that the program will continue 
to function as an event-driven picture-manipulation program until the user 
clicks the large X in the upper-right corner of the GUI to terminate the 
program.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of an ActionListener registered 
on the text field. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){

          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 3 disables the text field and its label to prevent the user from 
entering anything else into it and causing it to fire another event.</p>
<p><font color="#FF0000">
<b>Load the image file</b></font></p>
<p>Listing 4 gets the file name from the text field and uses it to read the file 
and create a new
<b>Picture</b> object using the image contained in the file.&nbsp; Listing 4 also displays my name in the image as a 
quick and easy way to create a watermark.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Load the image file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Get the information required to write the output files</b></font></p>
<p>Listing 5 gets and saves all of the information that will be required later 
to write the output files.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Get the information required to write the 
output files. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);
          
          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>While the code in Listing 5 is a little tedious, it is not complicated and should not require an explanation beyond the embedded comments.</p>
<p>Listing 5 also sets the title in the GUI; an operation that is unrelated to 
the output files but needs to be done somewhere.</p><p><font color="#FF0000">
<b>Create a separate Picture object that will used for processing</b></font></p>
<p>Other than adding the watermark, the <b>Picture</b> object that is created in 
Listing 5 is not modified by the program.&nbsp; Instead, a separate <b>Picture</b> 
object is created in Listing 6 and this is the object that is modified as a 
result of user actions.&nbsp; It also contains the image that is written into 
the output files.</p><p>
<b><a name="Listing_6">Listing 6</a>. Create a separate Picture object that will 
be used for processing.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          display = new Picture(picture);

          //Display the picture.
          display.show();
</pre></td></tr></tbody></table></p><p>The original image is held in reserve in 
memory and is used to refresh the display with a clean image whenever the user 
clicks the mouse in the display.&nbsp; This makes it possible for the user to 
undo the most recent action and start fresh with a clean image.</p>
<p>Listing 6 also calls the <b>show</b> method to cause the image to be 
displayed in the upper-left corner of the screen.</p>
<p><font color="#FF0000">
<b>Get and save several useful references</b></font></p>
<p>Listing 7 gets and saves several references that will be used later in the 
program for a variety of purposes.</p><p>
<b><a name="Listing_7">Listing 7</a>. Get and save several useful references. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          //Save a reference to the image. Also save the
          // width and height of the picture.
          theImage = (BufferedImage)(picture.getImage());
          pictureWidth = picture.getWidth();
          pictureHeight = picture.getHeight();

          //Get and save a reference to the JFrame object
          // that contains the image.
          theFrame = display.getPictureFrame().frame;

          //Get the graphics context on which to draw a
          // lasso.
          g2 = (Graphics2D)(theFrame.getGraphics());
</pre></td></tr></tbody></table></p><p><font color="#FF0000">
<b>Adjust the width and location of the GUI</b></font></p>
<p>Strictly for cosmetic purposes, Listing 8 adjusts the width of the GUI to 
match the width of the display if possible.&nbsp; Then Listing 8 relocates the 
GUI to a position immediately below the display.</p><p>
<b><a name="Listing_8">Listing 8</a>. Adjust the width and location of the GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);
</pre></td></tr></tbody></table></p><p><font color="#FF0000">
<b>Enable and disable components</b></font></p>
<p>Listing 9 enables the user input components to make the program operational.&nbsp; 
Listing 9 also disables the large X in the upper-right corner of the <b>JFrame</b> 
object that contains the image.&nbsp; The program can be terminated by clicking the large X in the 
upper-right corner of the GUI.</p><p>
<b><a name="Listing_9">Listing 9</a>. Enable and disable components. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Enable the user input controls.
          writeButton.setEnabled(true);
          processButton.setEnabled(true);
          rectButton.setEnabled(true);
          circleButton.setEnabled(true);

          //Disable the X-button on the display.
          theFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Register a MouseListener and a MouseMotionListener</b></font></p>
<p>Now that an image has been loaded, a <b>MouseListener</b> object and a <b>
MouseMotionListener</b> object can be registered on the <b>JFrame</b> object 
that contains the image.</p>
<p>Note that the registration code for these two listener objects is actually 
inside the code for the <b>ActionListener</b> object that is registered on the text field.&nbsp; 
This code can't be executed when the GUI is first constructed because a <b>
Picture</b> object does not exist at that point in time.&nbsp; Instead, this 
code is executed after the user enters the image filename, the file has been 
read, and the <b>Picture</b> object referred to by <b>display</b> has been 
constructed.</p>
<p>
<font color="#FF0000">
<b>Register a MouseListener object on the JFrame containing the image</b></font></p>
<p>
Listing 10 registers a <b>MouseListener</b> object on the <b>JFrame</b> object 
that contains the image.&nbsp; This is the <b>JFrame</b> object shown in Figure 
2.</p><p>
<b><a name="Listing_10">Listing 10</a>. Register a MouseListener object on the 
JFrame containing the image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          theFrame.addMouseListener(
            new MouseAdapter(){
              public void mousePressed(MouseEvent e){
                //Draw a new copy of the image on the
                // display each time the user clicks the
                // image with the mouse.
                graphics = display.getGraphics();
                graphics.drawImage(
                             picture.getImage(),0,0,null);
                display.repaint();

                //Prepare the variables...
                anchorX = e.getX();
                anchorY = e.getY();
                deltaX = 0;
                deltaY = 0;
              }//end mousePressed
            }//end new MouseAdapter
          );//end addMouseListener</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Draw a new copy of the image</b></font></p>
<p>Listing 10 begins by drawing a new copy of the image on the display shown in 
Figure 2 each time the user clicks the image with the mouse.&nbsp; This makes it 
possible to erase an existing lasso simply by clicking anywhere in the image.&nbsp; 
This also erases the effect of having previously clicked the <b>Process Pixels</b> button 
to process pixels isolated by the lasso.</p>
<p><font color="#FF0000"><b>Prepare the variables...</b></font></p><p>Then 
Listing 10 prepares several variables so that the <b>mouseDragged</b> event 
handler method can lasso and isolate a group of pixels.</p>
<p><font color="#FF0000"><b>A possible point of confusion</b></font></p>
<p>Note that the reported coordinates for a mouse press on the upper-left corner 
of the image will not be reported as 0,0 due to the top and left insets of the
<b>JFrame</b>.&nbsp; This can lead to some confusion when analyzing the code.</p>
<p>Listing 10 also signals the end of the code that registers a <b>MouseListener</b> 
object on the <b>JFrame</b> object that contains the image.</p>
<p><font color="#FF0000">
<b>Register a MouseMotionListener object on the JFrame containing the image</b></font></p>
<p>Listing 11 registers a <b>MouseMotionListener</b> object on the <b>JFrame</b> 
object containing the image.&nbsp; This listener object calls one of two 
different methods to draw a lasso on the image when the user drags the mouse on 
the image.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Register a MouseMotionListener object on 
the JFrame containing the image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          theFrame.addMouseMotionListener(
            new MouseMotionAdapter(){
              public void mouseDragged(MouseEvent e){
                //Call the method to draw the lasso on the
                // basis of which radio button has been
                // selected.
                if(rectButton.isSelected()){
                  makeRectLasso(e.getX(),e.getY());
                }else if(circleButton.isSelected()){
                  makeCircleLasso(e.getX(),e.getY());
                }//end else
              }//end mouseDragged
            }//end new MouseMotionAdapter
          );//end addMouseMotionListener</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Deciding which method to call</b></font></p>
<p>
The decision as to which of the two methods to call is made on the basis of 
which radio button in Figure 5 has been selected by the user.&nbsp; One of the 
methods, named <b>makeCircleLasso</b> draws a circular lasso as shown by the 
black circle surrounding the red pupil of the eyeball in Figure 1.</p>
<p>The other method named <b>makeRectLasso</b> draws a rectangular lasso with an 
inscribed ellipse as shown in Figure 2.&nbsp; These two methods are the heart of 
this program.&nbsp; I will explain both methods later.</p>
<p><font color="#FF0000">
<b>Finish defining the ActionListener</b> <b>on the text field</b></font></p>
<p>As I mentioned earlier, the code shown in Listing 10 and Listing 11 is 
actually inside the definition of an anonymous class that registers an <b>
ActionListener</b> object on the text field.&nbsp; Listing 7 contains the code 
required to complete the definition of that anonymous class.</p><p>
<b><a name="Listing_12">Listing 12</a>. Finish defining the ActionListener</b>
<b>on the text field. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener</pre></td></tr></tbody></table></p><p>
<font color="#FF0000">
<b>Register an ActionListener object on the Write button</b></font></p>
<p>Listing 13 registers an <b>ActionListener</b> object on the <b>Write</b> 
button shown in Figure 5.</p>
<p>Each time the user clicks the button, a backup image file of type bmp 
containing the current state of the display is written into the directory from 
which the original picture was read.</p><p>
<b><a name="Listing_13">Listing 13</a>. Register an ActionListener object on the 
Write button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end new ActionListener
    );//end addActionListener</pre></td></tr></tbody></table></p>
<p><font color="#FF0000"><b>Five most recent backup files are saved</b></font></p>
<p>The five most recent backup files are saved.&nbsp; The names of the backup 
files are the same as the name of the input file except that BAKn is inserted 
immediately ahead of the extension where n is a digit ranging from 0 to 4.The 
value of n rolls over at 4 and starts back at 0.</p>
<p><font color="#FF0000">
<b>Register a WindowListener object on the GUI</b></font></p>
<p>Listing 14 registers a <b>WindowListener</b> object that responds when the 
user clicks the large X in the upper-right corner of the GUI.&nbsp; This event 
handler writes the final display image into an output file of the same type as 
the original input file.&nbsp; The name of the output file is the same as the 
name of the input file except that the word FINAL is inserted immediately ahead 
of the extension.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Register a WindowListener object on the 
GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener</pre></td></tr></tbody></table></p><p>
<font color="#FF0000">
<b>Register an ActionListener object on the Process Pixels button</b></font></p>
<p>Listing 15 registers an <b>ActionListener</b> object on the <b>Process Pixels</b> 
button.</p>
<p>Listing 15 begins by drawing a clean copy of the image to get rid of the 
black pixels that constitute the lasso.&nbsp; Note that this does not destroy 
the underlying <b>Rectangle2D.Double</b> and <b>Ellipse2D.Double</b> objects 
that define the lasso.&nbsp; <i>(I will have more to say about these objects 
later.)</i></p><p>
<b><a name="Listing_15">Listing 15</a>. Register an ActionListener object on the 
Process Pixels button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    processButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Get rid of the black lasso pixels
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.repaint();
          //Call a method to process the pixels on the
          // basis of which radio button is selected.
          if(rectButton.isSelected()){
            processRectPixels();
          }else if(circleButton.isSelected()){
            processCirclePixels();
          }//end else
        }//end action performed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

  }//end constructor</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Call a method to process the pixels</b></font></p>
<p>Then Listing 15 calls one of two methods to process the pixels that have been 
isolated inside of the lasso.&nbsp; The decision as to which method to call is 
made on the basis of which radio button is selected at the time the button is 
clicked.</p>
<p>If the <b>Rect/Ellipse</b> button is selected, the method named <b>
processRectPixels</b> is called to process a lasso of the type shown in Figure 
2.&nbsp; If the <b>Circle</b> button is selected, the method named <b>
processCirclePixels</b> is called to process a lasso of the type shown in Figure 
1.</p>
<p><font color="#FF0000"><b>Simple demo methods</b></font></p>
<p>I have provided simple demo versions of each of these methods, which I will 
explain later.&nbsp; However, my expectation is that you will modify the methods 
to process the isolated pixels in whatever way meets your specific needs.</p>
<p><font color="#FF0000"><b>The end of the constructor</b></font></p>
<p>Listing 15 also signals the end of the constructor.&nbsp; As mentioned 
earlier, when the constructor terminates, the program goes into an idle state 
waiting for the user to do something that causes an event to be fired, <i>(for which a 
listener object has been registered)</i>.&nbsp; When such an event is 
fired, the program handles the event and then returns to the idle state waiting 
for the next event to be fired.</p>
<h3><a name="The_method_named_makeRectLasso">The method named makeRectLasso</a></h3><p>That 
brings us to the methods that are called when the user drags the mouse in the 
image to create a lasso.&nbsp; The method named <b>makeRectLasso</b> is 
conceptually 
the simpler of the two so I will begin with that method.</p>
<p>This method is called each time the mouse fires a <b>mouseDragged</b> event 
if the radio button labeled <b>Rect/Ellipse</b> is selected.</p>
<p><font color="#FF0000"><b>A rectangular lasso with an inscribed ellipse</b></font></p>
<p>This version of the method draws a lasso consisting of a rectangle with an 
inscribed ellipse as shown in Figure 2.&nbsp; An anchor point is established 
when the user presses a mouse button to drag the mouse across the image.&nbsp; A 
corner of the rectangle touches the anchor point at all times.</p>
<p><font color="#FF0000"><b>Size and shape of the rectangle</b></font></p>
<p>The sides of the rectangle are always parallel with the top and the sides of the
<b>JFrame</b> object containing the image.&nbsp; The dimensions of the rectangle 
are determined by the distance from the anchor point to the mouse pointer.&nbsp; That 
distance defines the length of a line from the anchor point to a 
diagonal corner of the rectangle.</p>
<p><font color="#FF0000"><b>Location of the rectangle</b></font></p>
<p>The location of the rectangle is determined by the angle that an imaginary 
line going through the anchor point and the mouse pointer makes with an 
imaginary horizontal line going through the anchor point.</p>
<p>Assuming the anchor point to be the origin of an imaginary Cartesian 
coordinate system, the rectangle can be drawn in any quadrant of that coordinate 
system with one corner of the rectangle touching the anchor point.&nbsp; The rectangle can be drawn with any size, even if the mouse 
pointer goes outside the bounds of the image.</p>
<p><font color="#FF0000"><b>Processing the isolated pixels</b></font></p>
<p>Pixels isolated by the rectangle and pixels isolated by the inscribed 
ellipse can be process separately or in combination.</p>
<p>When the user releases the mouse button, the rectangle and the inscribed ellipse remain on the screen until the user 
clicks the image with the mouse, clicks the <b>Process Pixels</b> button, or 
does something else to cause the image to be repainted.</p>
<p><font color="#FF0000">
<b>Beginning of the method named makeRectLasso</b></font></p>
<p>The method named
<b>makeRectLasso</b> begins in Listing 16.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Beginning of the method named 
makeRectLasso. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void makeRectLasso(int x,int y){

    //Update the width and height of the rectangular
    // lasso.
    deltaX = x - anchorX;
    deltaY = y - anchorY;

    //Copy the entire image from the backup picture.
    g2.drawImage(theImage,
                 theFrame.getInsets().left,
                 theFrame.getInsets().top,null);
</pre></td></tr></tbody></table></p>
<p>The parameters x and y contain the coordinates of the mouse pointer when the 
event was fired.</p>
<p><b>Update two instance variables</b></p>
<p>Listing 16 begins by updating the variables named <b>
deltaX</b> and <b>deltaY</b>, which will be used to establish the width and the 
height of the rectangular lasso.</p>
<p>These two variables are updated to 
contain the horizontal and vertical components of a vector that extends from the 
anchor point to the current location of the mouse pointer.&nbsp; In effect, they 
contain the horizontal and vertical components of an imaginary line that extends 
from the anchor point to the diagonally opposite corner of the rectangle.</p>
<p><font color="#FF0000"><b>Refresh the 
display</b></font></p>
<p>Then Listing 16 copies the entire image from the backup picture stored in 
memory onto the picture referred to by <b>display</b>.&nbsp; This erases any 
lassos drawn earlier and also erases the effects of earlier clicks on the <b>
Process Pixels</b> button.&nbsp; <i>(The user could have saved this information 
in a disk file by clicking the <b>Write</b> button and copying the backup file 
to a more permanent file.)</i></p>
<p><font color="#FF0000"><b>Caution, trigonometry ahead</b></font></p>
<p>In order to understand the remaining code in this method, you must understand 
trigonometry.&nbsp; If you don't, you will simply have to take my word for it 
that trigonometry was used correctly.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The Math.atan2 method</b><br />
<font size="3" face="arial">
	Note that unlike the <b>Math.atan</b> method, the <b>atan2</b> method returns the 
	angle for the full angular range of -pi to pi.&nbsp; The <b>atan2</b> method 
	also handles the issue of division by zero when the horizontal value goes 
	to zero.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
<b>Get the angle of the diagonal line</b></font></p>
<p>Listing 17 calls the <b>atan2</b> method of the <b>Math</b> class to get and 
save the angle in radians that a line joining the anchor point and the current 
mouse location makes with a horizontal line going through the anchor point. This 
angle that will be used in the computations that are required to draw the rectangle 
in the correct quadrant relative to the anchor point.</p><p>
<b><a name="Listing_17">Listing 17</a>. Get the angle of the diagonal line. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    angle = Math.atan2((double)deltaY,(double)deltaX);
</pre></td></tr></tbody></table></p><p><font color="#FF0000">
<b>Create the rectangle and the ellipse in the correct quadrant</b></font></p>
<p>The objective is to draw a rectangle with an inscribed ellipse with one 
corner touching the anchor point regardless of the direction that the user drags 
the mouse pointer relative to the anchor point.</p>
<p>Listing 18 uses the angle produced by the code in Listing 17 to determine the 
quadrant, <i>(relative to the anchor point as the origin in a Cartesian 
coordinate system)</i>, in which to draw the rectangle.</p>
<p>Then Listing 18 executes one of four alternative blocks of code to construct 
a <b>Rectangle2D.Double</b> object and an inscribed <b>Ellipse2D.Double</b> object 
in the correct quadrant positioned with one corner of the rectangle 
touching the anchor point at all times.</p><p>
<b><a name="Listing_18">Listing 18</a>. Create the rectangle and the ellipse in 
the correct quadrant. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    if((angle >= 0) && (angle < pi/2)){
      //Create the rectangle in the lower-right quadrant.
      rectangle = new Rectangle2D.Double(
          //Compute and specify the coordinates of the
          // upper-left corner of the rectangle.
          anchorX,
          anchorY,
          //Specify the width and the height of the
          // rectangle.
          deltaX,
          deltaY);
      //Now inscribe an ellipse in the rectangle.
      ellipse = new Ellipse2D.Double(anchorX,
                                     anchorY,
                                     deltaX,
                                     deltaY);
    }else if((angle >= pi/2) && (angle < pi)){
      //Create the rectangle in the lower-left quadrant.
      rectangle = new Rectangle2D.Double(anchorX + deltaX,
                                         anchorY,
                                         -deltaX,
                                         deltaY);
      ellipse = new Ellipse2D.Double(anchorX + deltaX,
                                     anchorY,
                                     -deltaX,
                                     deltaY);
    }else if((angle >= -pi/2) && (angle < 0)){
      //Create the rectangle in the upper-right quadrant.
      rectangle = new Rectangle2D.Double(anchorX,
                                         anchorY + deltaY,
                                         deltaX,
                                         -deltaY);
      ellipse = new Ellipse2D.Double(anchorX,
                                     anchorY + deltaY,
                                     deltaX,
                                     -deltaY);
    }else{
      //Create the rectangle in the upper-left quadrant.
      rectangle = new Rectangle2D.Double(anchorX + deltaX,
                                         anchorY + deltaY,
                                         -deltaX,
                                         -deltaY);
      ellipse = new Ellipse2D.Double(anchorX + deltaX,
                                     anchorY + deltaY,
                                     -deltaX,
                                     -deltaY);
    }//end else
</pre></td></tr></tbody></table></p><p><font color="#FF0000"><b>The code is 
straightforward</b></font></p>
<p>You should be able to understand the code in each of the alternative code blocks 
in Listing 18 without a requirement for an explanation beyond the embedded 
comments.&nbsp; When interpreting the comments, however, you need to remember 
that the positive direction for an angle is clockwise.</p>
<p><font color="#FF0000">
<b>Draw the rectangle and the ellipse</b></font></p>
<p>The two objects constructed in Listing 18 exist regardless of whether or not 
they are physically drawn on the screen.&nbsp; Listing 19 draws them on the 
screen.</p><p>
<b><a name="Listing_19">Listing 19</a>. Draw the rectangle and the ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    g2.draw(rectangle);
    g2.draw(ellipse);
  }//end makeRectLasso</pre></td></tr></tbody></table></p><p>Listing 19 also 
signals the end of the method named <b>makeRectLasso</b> that began in Listing 
16.</p>
<h3><a name="The_method_named_processRectPixels">The method named processRectPixels</a></h3>
<p>Before I get into the method that is called to draw a circular lasso, I will 
explain a demonstration method that shows how to process the pixels isolated in 
the rectangular lasso shown in Figure 2.</p>
<p>This method is called by the <b>ActionListener</b> object registered on the
<b>Process Pixels</b> button in Listing 15 whenever the user clicks the <b>
Process Pixels</b> button while the radio button labeled <b>Rect/Ellipse</b> is 
selected.</p>
<p><font color="#FF0000"><b>A very simple pixel-processing algorithm</b></font></p>
<p>This method implements a very simple pixel-processing algorithm and is 
provided for demonstration purposes only.&nbsp; My expectation is that you will 
modify this method to suit your specific pixel-processing needs.</p>
<p><font color="#FF0000"><b>Modify isolated pixels</b></font></p>
<p>This demo method eliminates red from all pixels inside the rectangle but 
outside the ellipse.&nbsp; Then it eliminates green from all pixels inside the 
ellipse.&nbsp; This produces the results shown in Figure 4.</p>
<p><font color="#FF0000">
<b>Beginning of the method named processRectPixels</b></font></p>
<p>The
<b>processRectPixels</b> method begins in Listing 20.</p><p>
<b><a name="Listing_20">Listing 20</a>. Beginning of the method named 
processRectPixels. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void processRectPixels(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(rectangle == null) return;
</pre></td></tr></tbody></table></p><p><font color="#FF0000"><b>Confirm the 
existence of the Rectangle2D.Double object</b></font></p>
<p>The pixel-processing code in the
<b>processRectPixels </b> method 
expects that a <b>Rectangle2D.Double</b> object and an <b>Ellipse2D.Double</b> 
object have been created.&nbsp; However, that would not be the case if the user 
were to click the <b>Process Pixels</b> button while the <b>Rect/Ellipse</b> radio 
button is selected before dragging the mouse to create a rectangular lasso.&nbsp; 
Therefore, Listing 20 tests to confirm that the <b>Rectangle2D.Double</b> object 
has been created, and if not, the method simply returns quietly.</p>
<p><font color="#FF0000">
<b>Change the colors of the pixels</b></font></p>
<p>The key to this entire program hinges on the behavior of the <b>contains</b> 
method belonging to objects of the <b>
Rectangle2D.Double</b> and <b>Ellipse2D.Double</b> classes.</p>
<p>The <b>contains</b> method accepts a pair of incoming coordinate values 
and return true if the coordinates are inside the boundary of the shape, and 
false otherwise.</p>
<p><font color="#FF0000"><b>Cycle and test all pixels</b></font></p>
<p>Listing 21 uses a pair of nested <b>for</b> loops to cycle through all of the 
coordinate pairs contained in the image being processed, calling the <b>
contains</b> methods of the rectangle and ellipse objects for each coordinate 
pair, to identify those pixels that are inside the boundary of the object.</p><p>
<b><a name="Listing_21">Listing 21</a>. Change the colors of the pixels. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    for(int col = 0;col &lt; pictureWidth;col++){
      for(int row = 0;row &lt; pictureHeight;row++){

        //Change the color of the pixels inside the
        // rectangle and outside the ellipse.
        //Note: It is necessary to compensate for the top
        // and left insets of the JFrame.
        if((rectangle.contains(
                       col + theFrame.getInsets().left,
                       row + theFrame.getInsets().top)) &&
           !((ellipse.contains(
                       col + theFrame.getInsets().left,
                       row + theFrame.getInsets().top)))){
          pixel = display.getPixel(col,row);
          pixel.setRed(0);
        }//end if

        //Change the color of the pixels inside the
        // ellipse.
        if(ellipse.contains(
                         col + theFrame.getInsets().left,
                         row + theFrame.getInsets().top)){
          Pixel pixel = display.getPixel(col,row);
          pixel.setGreen(0);
        }//end if

      }//end inner loop
    }//end outer loop
    
    display.repaint();
    
  }//end processRectPixels</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Modify the <i>contained</i> pixels</b></font></p>
<p>Once a pixel is 
determined to be <i>contained</i> in either or both objects, the red or green color 
value is set to zero to produce the result shown in Figure 4.</p>
<p>When all coordinate pairs in the image have been tested, and the color values in selected pixels have been modified, Listing 21 calls 
the <b>repaint</b> method on the <b>display</b> object to cause the display to 
be repainted on the screen.</p>
<p>Listing 21 also signals the end of the method named <b>processRectPixels.</b></p>
<h3><a name="The_method_named_makeCircleLasso">The method named makeCircleLasso</a></h3>
<p>This method is called each time the mouse fires a <b>mouseDragged</b> event 
while the radio button labeled <b>Circle</b> is selected.</p>
<p>This method constructs and draws a lasso consisting of a circular ellipse 
that touches the anchor point at all times.</p>
<p>The diameter of the circle is determined by the distance of the mouse from 
the anchor point.&nbsp; The location of the circle is determined by the angle 
that a line going through the anchor point and the mouse pointer makes 
with a horizontal line going through the anchor point.</p>
<p>The circle can be drawn at any angle, and with any diameter, even if the 
mouse goes outside the bounds of the image.</p>
<p>When the user releases the mouse button, the circle remains on the screen 
until the user clicks the image with the mouse, clicks the <b>Process Pixels</b> 
button, or does something else to cause the image to be repainted.</p>
<p><font color="#FF0000">
<b>Beginning of the method named makeCircleLasso</b></font></p>
<p>The method named
<b>makeCircleLasso</b> begins in Listing 22.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Beginning of the method named 
makeCircleLasso. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void makeCircleLasso(int x,int y){

    //The parameters x and y contain the coordinates of
    // the mouse pointer when the event was fired. Update
    // the diameter of the circular lasso.
    deltaX = x - anchorX;
    deltaY = y - anchorY;
    diameter = (int)Math.hypot(deltaX,deltaY);

    //Copy the entire image from the backup picture stored
    // in memory to erase any lassos drawn earlier. Also
    // erases the effects of prior clicks on the Process
    // Pixels button.
    g2.drawImage(theImage,
                 theFrame.getInsets().left,
                 theFrame.getInsets().top,null);
</pre></td></tr></tbody></table></p>
<p>As before, the parameters x and y contain the coordinates of the mouse 
pointer when the event was fired.&nbsp; Listing 22 begins by updating the variables 
named <b>deltaX</b> and <b>deltaY</b>, which are used to establish the 
diameter of the circular lasso in this method.</p>
<p>Also as before, these two variables are updated to contain the horizontal and vertical 
components of a vector that extends from the anchor point to the current 
location of the mouse pointer.&nbsp; </p>
<p><font color="#FF0000"><b>Get the length of the vector</b></font></p>
<p>Unlike before, the <b>hypot</b> method of the <b>Math</b> 
class is called to get the length of the vector.&nbsp; The <b>hypot</b> method treats the horizontal and vertical components 
of the vector as the 
sides of a right triangle and returns the length of the hypotenuse of that 
triangle.&nbsp; This value defines the diameter of the circular lasso.</p>
<p><font color="#FF0000"><b>Refresh the 
display</b></font></p>
<p>As before, Listing 22 also refreshes the display by copying the backup image 
that is stored in memory into the display.</p>
<p><font color="#FF0000">
<b>Compute the angle</b></font></p>
<p>Listing 23 calls the <b>atan2</b> method to compute the same angle that was 
computed earlier in Listing 17.&nbsp; However, in this case, the angle is used 
for a somewhat different purpose than before.</p><p>
<b><a name="Listing_23">Listing 23</a>. Compute the angle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Get the angle in radians that a line joining the
    // anchor point and the current mouse location makes
    // with a horizontal line going through the anchor
    // point. This is the angle that will be used in the
    // computations required to rotate the circular
    // ellipse around the anchor point while continually
    // touching the anchor point.
    angle = Math.atan2((double)deltaY,(double)deltaX);
</pre></td></tr></tbody></table></p><p><font color="#FF0000">
<b>Construct and draw a circular ellipse</b></font></p>
<p>Listing 24 constructs and then draws a circular version of an <b>
Ellipse2D.Double</b> object that touches the anchor point at all times.</p><p>
<b><a name="Listing_24">Listing 24</a>. Construct and draw a circular ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    ellipse = new Ellipse2D.Double(
          //Compute and specify the coordinates of the
          // upper left corner of a box that will contain
          // the circular ellipse.
          anchorX-(diameter/2-Math.cos(angle)*diameter/2),
          anchorY-(diameter/2-Math.sin(angle)*diameter/2),
          //Specify the width and the height of the box.
          diameter,
          diameter);
          
    //Draw the ellipse.
    g2.draw(ellipse);

  }//end makeCircleLasso</pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>Conceptually complex code</b></font></p>
<p>Although the code 
in Listing 24 is much shorter than the code in Listing 18, the code in Listing 
24 is conceptually more complex than the code in Listing 18.</p>
<p>In Listing 18, all that was required to was to select among, construct,&nbsp; 
and draw one of four alternatives rectangles in which one corner of the 
rectangle touched the anchor point at all times.</p>
<p>In Listing 24, however, the requirement is to construct and then draw any one 
of an infinite number of circles such that the perimeter of the circle touches 
the anchor point at all times.</p>
<p><font color="#FF0000"><b>Use an Ellipse2D.Double object for the circle</b></font></p>
<p>The circle is constructed by constructing an <b>Ellipse2D.Double</b> object 
that is inscribed in a square <i>(not a general rectangle)</i>.&nbsp; 
Beyond that, about all that I can tell you is that if you really understand 
trigonometry <i>(and perhaps vectors as well)</i>, you should be able to 
understand the code in Listing 24 without an explanation beyond the embedded 
comments.&nbsp; If you don't understand trigonometry, the code in Listing 24 
probably won't make any sense to you at all.</p>
<p>Listing 24 also signals the end of the method named <b>makeCircleLasso</b>.</p>
<h3><a name="The_method_named_processCirclePixels_">The method named processCirclePixels</a></h3>
<p>Listing 25 is a demonstration that shows how to process the pixels contained in a circular elliptical lasso, producing results similar to those 
shown in Figure 3.</p><p>
<b><a name="Listing_25">Listing 25</a>. The method named processCirclePixels. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void processCirclePixels(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(ellipse == null) return;

    for(int col = 0;col &lt; pictureWidth;col++){
      for(int row = 0;row &lt; pictureHeight;row++){
        //Change the color of the pixels inside the
        // ellipse.
        //Note: It is necessary to compensate for the top
        // and left insets of the JFrame.
        if(ellipse.contains(
                         col + theFrame.getInsets().left,
                         row + theFrame.getInsets().top)){
          //The pixel is inside the lasso. Change its
          // color.
          Pixel pixel = display.getPixel(col,row);
          pixel.setRed(0);
        }//end if

      }//end inner loop
    }//end outer loop
    display.repaint();
  }//end processCirclePixels</pre></td></tr></tbody></table></p><p>If you 
understood the method named <b>processRectPixels</b> that began in Listing 20, 
you should have no difficulty understanding Listing 25.</p>
<p>As before, this method implements a very simple pixel-processing algorithm to 
eliminate green from all of the pixels isolated by the lasso, and is provided 
for demonstration purposes only.&nbsp; My expectation is that you will modify this 
method to suit your specific pixel-processing needs.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2></center><p>I encourage 
you to copy the code from Listing 26, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do. </p><h2 align="center"><a name="Summary">Summary</a></h2><p>
In this lesson, I showed you how to write the code to create a circular lasso 
that isolates a group of pixels as shown by the black circle around the red pupil in 
the eyeball in Figure 1.</p>
<p>I also showed you how to write the code to create a rectangular lasso with an 
inscribed ellipse as shown in Figure 2.</p>
<p>Finally, I provided demo methods that illustrate a methodology for processing 
the pixels isolated by the lasso.</p><ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2><p>In the next 
lesson, you will learn how to cause two or more pictures to have the same width 
or the same height and otherwise maintain their individual aspect ratios, how to 
create composite pictures containing side-by-side images, how to draw text on a 
picture, and how to apply the same operation to every pixel in a <b>Picture</b> 
object.</p><h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java355.htm">355</a> The HSB Color Model</li>
	<li><a href="http://www.dickbaldwin.com/java/Java356.htm">356</a> The show Method and the PictureFrame Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java357.htm">357</a> An HSB 
	Color-Editing Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java358.htm">358</a> Applying 
	Affine Transforms to Picture Objects</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2></center>
A complete listing of the program that I explained in this lesson is shown in 
Listing 26.
<p>
<b><a name="Listing_26">Listing 26</a>. Source code for the program named Lasso02. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Lasso02 Copyright 2009 R.G.Baldwin

This is a demonstration program that shows how to create
two different lasso styles by dragging a mouse in an image
in a Picture object.

The program begins by displaying a GUI in the upper left
corner of the screen. At that point, the GUI contains a
text field for entry of the name of the image file to be
processed and some other user-input components, which are
disabled.  If the file is in the current directory, only
the file name and extension must be entered. Otherwise,
the full path and name and extension for the file must be
entered. Files of types jpg, bmp, and png are supported.

When the user enters the name of the image file into the
text field, the file is loaded into a Picture object. The
Picture object is displayed in the upper left corner of
the screen and the GUI is moved to a location immediately
below the Picture object.  At this point, the text field
is disabled.  Two buttons and two radio buttons are
enabled.

One button is labeled Process Pixels and the other button
is labeled Write. One radio button is labeled Rect/Ellipse
and the other radio button is labeled Circle. The
Rect/Lasso button is initially selected by the program.

At this point with the Rect/Ellipse button selected, the
user can drag the mouse in the image to create a lasso
consisting of a rectangle with an inscribed ellipse.  The
rectangle and the ellipse can be created in any quadrant
relative to the anchor point. The anchor point is the
location at which the drag operation begins. One corner
of the rectangle will always touch the anchor point.

When the Circle button is selected, the user can drag the
mouse in the image to create a circular lasso. It can be
created in any direction from the anchor point.  The
diameter of the circular lasso is equal to the distance of
the mouse pointer from the anchor point.

Dragging the mouse outside the bounds of the picture
causes the size of the either lasso to continue to grow.
The lasso ends when the user releases the mouse button.

The lasso remains on the screen until the user clicks the
image with the mouse, clicks the Process Pixels button, or
does something else to cause the image to be repainted.

After the lasso has been drawn, the button labeled Process
Pixels can be clicked to cause a method to be called to
process the pixels in the image relative to the position
and size of the lasso. Different methods are called for
the two styles of lasso.

You can modify either or both of these methods to satisfy
your own pixel-processing needs.

For the Rect/Ellipse lasso, the method can be written to
process all of the pixels that are contained in the
rectangle, the ellipse, or a combination of the two. For
the Circle lasso, the method can be written to process
all of the pixels that are contained in the circle.
Another alternative would be to write methods to process
all of the pixels that are not contained in the lasso.

Clicking anywhere in the image will erase an existing
lasso and allow the user to start over with a clean image
to create a new lasso. Clicking the image also erases the
effects of having clicked the Process Pixels button.

Clicking the Write button causes a backup bmp file to be
written into the same directory from which the image file
was read. The five most recent backup files are saved.
The names of the backup file are the same as the name of
the original image file except that the characters BAKn
are inserted immediately before the extension. The
character n is replaced by a digit from 0 through 4.

Clicking the large X in the upper-right corner of the
image display does nothing. The button is disabled.

The program is terminated by clicking the large X in the
upper-right corner of the GUI. Before terminating, the
program writes an output file containing the final state
of the display in the same format as the input file. The
name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately before the extension.

This program does not modify the contents of the original
input file.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.Graphics2D;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseMotionAdapter;

import java.awt.geom.Ellipse2D;
import java.awt.geom.Ellipse2D.Double;
import java.awt.geom.Rectangle2D;

import java.awt.image.BufferedImage;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.JRadioButton;
import javax.swing.ButtonGroup;
import javax.swing.WindowConstants;

import java.io.File;

public class Lasso02 extends JFrame{
  //Create the components that are used to construct the
  // GUI.
  private JPanel mainPanel = new JPanel();
  private JPanel northPanel = new JPanel();
  private JPanel centerPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JButton processButton =
                            new JButton("Process Pixels");
  private JButton writeButton = new JButton("Write");
  private JTextField fileNameField =
                            new JTextField("Lasso02.jpg");
  private JLabel fileNameLabel = new JLabel("File Name:");

  private JRadioButton rectButton =
                    new JRadioButton("Rect/Ellipse",true);
  private JRadioButton circleButton =
                               new JRadioButton("Circle");
  private ButtonGroup buttonGroup = new ButtonGroup();

  //A reference to the original Picture object will be
  // stored here.
  private Picture picture = null;

  //A reference to a modified copy of the original
  // Picture object will be stored here.
  private Picture display = null;

  //Miscellaneous working variables. Many variables were
  // made instance variables instead of local variables
  // to improve responsiveness during a mouse drag
  // operation.
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int writeCounter = 0;

  private String fileName = "NONE";
  private String outputPath = null;
  private String extension = null;

  private int pictureWidth = 0;
  private int pictureHeight = 0;

  private int anchorX = 0;
  private int anchorY = 0;

  private int deltaX = 0;
  private int deltaY = 0;

  private int diameter = 0;
  private double angle = 0;

  private BufferedImage theImage = null;
  private JFrame theFrame = null;

  private Rectangle2D.Double rectangle = null;
  private Ellipse2D.Double ellipse = null;

  private Graphics2D g2 = null;

  private final double pi = Math.PI;//convenience constant
  //----------------------------------------------------//

  public static void main(String[] args){
    new Lasso02();
  }//end main method
  //----------------------------------------------------//

  public Lasso02(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Construct the GUI.
    mainPanel.setLayout(new BorderLayout());
    mainPanel.add(northPanel,BorderLayout.NORTH);
    mainPanel.add(centerPanel,BorderLayout.CENTER);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    northPanel.add(processButton);

    //Add radio buttons to the center panel and make them
    // mutually exclusive.
    centerPanel.add(rectButton);
    buttonGroup.add(rectButton);
    centerPanel.add(circleButton);
    buttonGroup.add(circleButton);

    //Add a button, a label, and a text field to the south
    // panel.
    southPanel.add(writeButton);
    southPanel.add(fileNameLabel);
    southPanel.add(fileNameField);

    //Disable the buttons until the user enters the file
    // name.
    writeButton.setEnabled(false);
    processButton.setEnabled(false);
    rectButton.setEnabled(false);
    circleButton.setEnabled(false);

    //Set the size of the GUI and display it in the upper-
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);

    //Request that the focus move to the text field where
    // the file name is to be entered.
    fileNameField.requestFocus();
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field and its label to
          // prevent the user from entering anything else
          // into it and causing it to fire another event.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object. Display my
          // name in the image.
          fileName = fileNameField.getText();
          picture = new Picture(fileName);
          picture.addMessage("Dick Baldwin",10,20);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);
          //Write the first copy of the output backup
          // file.
          picture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be used for
          // processing.
          //Note that the original image file is not
          // modified by this program.
          display = new Picture(picture);

          //Display the picture.
          display.show();

          //Save a reference to the image. Also save the
          // width and height of the picture.
          theImage = (BufferedImage)(picture.getImage());
          pictureWidth = picture.getWidth();
          pictureHeight = picture.getHeight();

          //Get and save a reference to the JFrame object
          // that contains the image.
          theFrame = display.getPictureFrame().frame;

          //Get the graphics context on which to draw a
          // lasso.
          g2 = (Graphics2D)(theFrame.getGraphics());

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable the user input controls.
          writeButton.setEnabled(true);
          processButton.setEnabled(true);
          rectButton.setEnabled(true);
          circleButton.setEnabled(true);

          //Disable the X-button on the display.
          theFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

          //--------------------------------------------//
          /*
          Note that the following two anonymous listener
          registrations are actually inside the action
          listener that is registered on the text field.
          The code in these two listener registration
          blocks can't be executed when the GUI is first
          constructed because a Picture object does not
          exist at that point in time. This code is
          executed after the user enters the image file
          name, the file has been read, and the Picture
          object referred to by display has been
          constructed.

          Now that an image has been loaded, a mouse
          listener can be registered on the JFrame object
          that contains the image.
          */
          theFrame.addMouseListener(
            new MouseAdapter(){
              public void mousePressed(MouseEvent e){
                //Draw a new copy of the image on the
                // display each time the user clicks the
                // image with the mouse. This makes it
                // possible to erase an existing lasso
                // simply by clicking anywhere in the
                // image regardless of whether or not it
                // is intended to drag a new lasso.
                graphics = display.getGraphics();
                graphics.drawImage(
                             picture.getImage(),0,0,null);
                display.repaint();

                //Prepare the variables so that the
                // mouseDragged event handler can lasso an
                // area.
                //Note that the reported coordinates for
                // a mouse press on the upper-left corner
                // of the image will not be reported
                // as 0,0 due to the top and left insets
                // of the JFrame. This can lead to some
                // confusion when analyzing the code.
                anchorX = e.getX();
                anchorY = e.getY();
                deltaX = 0;
                deltaY = 0;
              }//end mousePressed
            }//end new MouseAdapter
          );//end addMouseListener
          //--------------------------------------------//

          //Register a MouseMotionListener object that
          // will call a method to draw a lasso when the
           // mouse is dragged in the image.
          theFrame.addMouseMotionListener(
            new MouseMotionAdapter(){
              public void mouseDragged(MouseEvent e){
                //Call the method to draw the lasso on the
                // basis of which radio button has been
                // selected.
                if(rectButton.isSelected()){
                  makeRectLasso(e.getX(),e.getY());
                }else if(circleButton.isSelected()){
                  makeCircleLasso(e.getX(),e.getY());
                }//end else
              }//end mouseDragged
            }//end new MouseMotionAdapter
          );//end addMouseMotionListener
          //--------------------------------------------//
        //Now finish the action listener that is
        // registered on the text field.
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of the display is
    // written into the directory from which the original
    // picture was read. The five most recent backup files
    // are saved. The names of the backup files are the
    // same as the name of the input file except that BAKn
    // is inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          display.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of the display into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          display.write(outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//

    //Register an action listener on the processButton
    // that calls a method to process the lasso.
    processButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Get rid of the black lasso pixels
          graphics = display.getGraphics();
          graphics.drawImage(picture.getImage(),0,0,null);
          display.repaint();
          //Call a method to process the pixels on the
          // basis of which radio button is selected.
          if(rectButton.isSelected()){
            processRectPixels();
          }else if(circleButton.isSelected()){
            processCirclePixels();
          }//end else
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

  }//end constructor
  //----------------------------------------------------//

  /*
  This method is called each time the mouse fires a
  mouseDragged event if the radio button labeled Circle
  is selected.

  This version of the method draws a lasso consisting of a
  circular ellipse that touches the anchor point at all
  times. The diameter of the circle is determined by the
  distance of the mouse from the anchor point. The
  location of the circle is determined by the angle that a
  line going through the anchor point and the mouse
  pointer location makes with a horizontal line going
  through the anchor point. The circle can be drawn at any
  angle, and with any diameter, even if the mouse goes
  outside the bounds of the image.

  The circle remains on the screen until the user
  clicks the image with the mouse, clicks the
  Process Pixels button, or does something else to cause
  the image to be repainted.
  */
  private void makeCircleLasso(int x,int y){

    //The parameters x and y contain the coordinates of
    // the mouse pointer when the event was fired. Update
    // the diameter of the circular lasso.
    deltaX = x - anchorX;
    deltaY = y - anchorY;
    diameter = (int)Math.hypot(deltaX,deltaY);

    //Copy the entire image from the backup picture stored
    // in memory to erase any lassos drawn earlier. Also
    // erases the effects of prior clicks on the Process
    // Pixels button.
    g2.drawImage(theImage,
                 theFrame.getInsets().left,
                 theFrame.getInsets().top,null);

    //Get the angle in radians that a line joining the
    // anchor point and the current mouse location makes
    // with a horizontal line going through the anchor
    // point. This is the angle that will be used in the
    // computations required to rotate the circular
    // ellipse around the anchor point while continually
    // touching the anchor point.
    angle = Math.atan2((double)deltaY,(double)deltaX);

    //Create and draw a circular ellipse that touches the
    // anchor point at all times.
    ellipse = new Ellipse2D.Double(
          //Compute and specify the coordinates of the
          // upper left corner of a box that will contain
          // the circular ellipse.
          anchorX-(diameter/2-Math.cos(angle)*diameter/2),
          anchorY-(diameter/2-Math.sin(angle)*diameter/2),
          //Specify the width and the height of the box.
          diameter,
          diameter);
    //Draw the ellipse.
    g2.draw(ellipse);

  }//end makeCircleLasso
  //----------------------------------------------------//

  //This is a demo method that shows how to process pixels
  // contained in a circular elliptical lasso. You can
  // modify this method to meet your own needs.
  //This demo method eliminates green from all pixels
  // inside the circle.
  private void processCirclePixels(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(ellipse == null) return;

    for(int col = 0;col &lt; pictureWidth;col++){
      for(int row = 0;row &lt; pictureHeight;row++){
        //Change the color of the pixels inside the
        // ellipse.
        //Note: It is necessary to compensate for the top
        // and left insets of the JFrame.
        if(ellipse.contains(
                         col + theFrame.getInsets().left,
                         row + theFrame.getInsets().top)){
          //The pixel is inside the lasso. Change its
          // color.
          Pixel pixel = display.getPixel(col,row);
          pixel.setRed(0);
        }//end if

      }//end inner loop
    }//end outer loop
    display.repaint();
  }//end processCirclePixels
  //----------------------------------------------------//

  /*
  This method is called each time the mouse fires a
  mouseDragged event if the radio button labeled
  Rect/Ellipse is selected.

  This version of the method draws a lasso consisting of a
  rectangle with an inscribed ellipse. A corner of the
  rectangle touches the anchor point at all times.

  The dimensions of the rectangle are determined by the
  distance of the mouse from the anchor point. That
  distance is the diagonal length of the rectangle.

  The location of the rectangle is determined by the angle
  that a line going through the anchor point and the mouse
  pointer location makes with a horizontal line going
  through the anchor point.

  The rectangle can be drawn in any quadrant, and with any
  size, even if the mouse goes outside the bounds of the
  image.

  Pixels contained in the rectangle and pixels contained
  in the inscribed ellipse can be process separately or in
  combination.

  The rectangle remains on the screen until the user
  clicks the image with the mouse, clicks the
  Process Pixels button, or does something else to cause
  the image to be repainted.
  */
  private void makeRectLasso(int x,int y){

    //The parameters x and y contain the coordinates of
    // the mouse pointer when the event was fired. Update
    // the width and height of the rectangular lasso.
    deltaX = x - anchorX;
    deltaY = y - anchorY;

    //Copy the entire image from the backup picture stored
    // in memory to erase any lassos drawn earlier. This
    // also erases the effects of earlier clicks on the
    // Process Pixels button.
    g2.drawImage(theImage,
                 theFrame.getInsets().left,
                 theFrame.getInsets().top,null);

    //Get the angle in radians that a line joining the
    // anchor point and the current mouse location makes
    // with a horizontal line going through the anchor
    // point. This is the angle that will be used in the
    // computations required to draw the rectangle in the
    // correct quadrant.
    angle = Math.atan2((double)deltaY,(double)deltaX);

    //Create and draw a rectangle such that one of its
    // corners touches the anchor point at all times.
    if((angle &gt;= 0) && (angle &lt; pi/2)){
      //Create the rectangle in the lower-right quadrant.
      rectangle = new Rectangle2D.Double(
          //Compute and specify the coordinates of the
          // upper-left corner of the rectangle.
          anchorX,
          anchorY,
          //Specify the width and the height of the
          // rectangle.
          deltaX,
          deltaY);
      //Now inscribe an ellipse in the rectangle.
      ellipse = new Ellipse2D.Double(anchorX,
                                     anchorY,
                                     deltaX,
                                     deltaY);
    }else if((angle &gt;= pi/2) && (angle &lt; pi)){
      //Create the rectangle in the lower-left quadrant.
      rectangle = new Rectangle2D.Double(anchorX + deltaX,
                                         anchorY,
                                         -deltaX,
                                         deltaY);
      ellipse = new Ellipse2D.Double(anchorX + deltaX,
                                     anchorY,
                                     -deltaX,
                                     deltaY);
    }else if((angle &gt;= -pi/2) && (angle &lt; 0)){
      //Create the rectangle in the upper-right quadrant.
      rectangle = new Rectangle2D.Double(anchorX,
                                         anchorY + deltaY,
                                         deltaX,
                                         -deltaY);
      ellipse = new Ellipse2D.Double(anchorX,
                                     anchorY + deltaY,
                                     deltaX,
                                     -deltaY);
    }else{
      //Create the rectangle in the upper-left quadrant.
      rectangle = new Rectangle2D.Double(anchorX + deltaX,
                                         anchorY + deltaY,
                                         -deltaX,
                                         -deltaY);
      ellipse = new Ellipse2D.Double(anchorX + deltaX,
                                     anchorY + deltaY,
                                     -deltaX,
                                     -deltaY);
    }//end else

    //Draw the rectangle and the ellipse.
    g2.draw(rectangle);
    g2.draw(ellipse);
  }//end makeRectLasso
  //----------------------------------------------------//

  //This is a demo method that shows how to process pixels
  // contained in a rectangular lasso and an elliptical
  // lasso. You can modify this method to meet your own
  // needs.
  //This demo method eliminates red from all pixels inside
  // the rectangle but outside the ellipse. It eliminates
  // green from all pixels inside the ellipse.
  private void processRectPixels(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(rectangle == null)return;

    for(int col = 0;col &lt; pictureWidth;col++){
      for(int row = 0;row &lt; pictureHeight;row++){

        //Change the color of the pixels inside the
        // rectangle and outside the ellipse.
        //Note: It is necessary to compensate for the top
        // and left insets of the JFrame.
        if((rectangle.contains(
                       col + theFrame.getInsets().left,
                       row + theFrame.getInsets().top)) &&
           !((ellipse.contains(
                       col + theFrame.getInsets().left,
                       row + theFrame.getInsets().top)))){
          pixel = display.getPixel(col,row);
          pixel.setRed(0);
        }//end if

        //Change the color of the pixels inside the
        // ellipse.
        if(ellipse.contains(
                         col + theFrame.getInsets().left,
                         row + theFrame.getInsets().top)){
          Pixel pixel = display.getPixel(col,row);
          pixel.setGreen(0);
        }//end if

      }//end inner loop
    }//end outer loop
    display.repaint();
  }//end processRectPixels
  //----------------------------------------------------//
}//end class Lasso02</pre></td></tr></tbody></table></p>
<p>&nbsp;</p>
<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2><p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2><b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
