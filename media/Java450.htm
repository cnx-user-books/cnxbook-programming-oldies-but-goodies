<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2 align="center">A Framework for Experimenting with 
Java 2D Image-Processing Filters</h2>
    <i>Learn about the image-filtering classes of the Java 2D API.&nbsp; Also learn how to write a framework program that makes it easy to use 
those image-filtering classes to modify the pixels in an image 
and to display the modified image.</i><p><b>Published:</b>&nbsp; November 28, 
2006 <br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 450</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
	<li><a href="#Image-Modification_Examples">Image-Filtering Examples</a></li>
	<ul><li><a href="#LookupOp_examples">LookupOp Examples</a></li>
	<li>A<a href="#AffineTransformOp_Examples">ffineTransformOp Examples</a></li>
	<li><a href="#BandCombineOp_Examples">BandCombineOp Examples</a></li>
	<li><a href="#ConvolveOp_Examples">ConvolveOp Examples</a></li>
	<li><a href="#RescaleOp_Examples">RescaleOp Examples</a></li>
	<li><a href="#ColorConvertOp_Examples">ColorConvertOp Example</a></li></ul>
	<li><a href="#Background_Information">Background Information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion and Sample Programs">Discussion and Sample Programs</a>
<ul>
	<li><a href="#The_program_named_ImgMod05a">The program named ImgMod05a</a></li>
	<li><a href="#The_program_named_ImgMod05">The program named ImgMod05
</a>
</ul>
	<li>
	<a href="#Run the program">Run the Programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#References">References</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
	<li><a href="#Complete Program Listings">Complete Program Listings</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>An image-processing framework</b></font></p>
<p>In the lesson entitled
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>, I provided a framework program 
named <b>ImgMod02</b> that makes it easy to:</p>
<ul>
	<li>Modify the pixels in an image</li>
	<li>Display the modified 
image</li>
	<li>Compare the modified image with the original image</li>
</ul>
<p>I upgraded that framework a couple of times in subsequent lessons.&nbsp;
<i>(See <a href="#References">References</a> below.)</i></p>
<p>That framework and the updated framework named <b>ImgMod02a</b> that I 
provided in a <a href="http://www.developer.com/java/other/article.php/3441391">
subsequent lesson</a> were based on the assumption that 
you would get right down in the mud and learn how to implement 
pixel-modification algorithms 
by working directly 
with the pixels.</p>
<p><font color="#FF0000"><b>Sometimes there is an easier way</b></font></p>
<p>In some cases, writing your own pixel-modification or image-filtering program is the best and 
most effective way to go.&nbsp; However, in some cases, there is an easier way.&nbsp; 
As of the date of this writing, the Java 2D API provides the following classes 
that can be used to filter an image and modify the pixels in that <a name="list_of_classes">image</a>:</p>
<ul>
	<li>LookupOp</li>
	<li>AffineTransformOp</li>
	<li>BandCombineOp</li>
	<li>ConvolveOp</li>
	<li>RescaleOp</li>
	<li>ColorConvertOp</li>
</ul>
<p>For those cases where it is possible to use one of the existing classes to 
satisfy your image-filtering needs, it is usually easier to write a program 
using one or more of the above classes than it is to write your own 
image-filtering program.</p>
<p>In this lesson, I will provide a framework program named <b>ImgMod05</b> that 
makes it easy to use the above classes to modify the pixels in an image and to 
display the modified image.</p>
<p><font color="#FF0000"><b>The Java 2D API doesn't always provide an easier way</b></font></p>
<p>Before going any further, however, I need to point out that despite the fact that the 
image-filtering classes in the above <a href="#list_of_classes">list</a> from 
the Java 2D API provide a great deal of capability, there are many interesting 
image-filtering needs that can't be satisfied by the capabilities of those 
classes.</p>
<blockquote>
	<p><i>(See, for example, the section entitled <b>Highlighting an image</b> 
	in the earlier lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; Although I haven't given it 
	a great deal of thought, I don't believe that any of the classes in the 
	above <a href="#list_of_classes">list</a> could be used to create the 
	spotlight effect shown in that lesson.&nbsp; I will also explain later that 
	the <b>ConvolveOp</b> class is very restrictive, and that you may find that 
	you can do a better image-processing job by
	<a href="http://www.developer.com/java/other/article.php/3522711">writing 
	your own classes</a> for this purpose than by using the <b>ConvolveOp</b> 
	class.)</i></p>
</blockquote>
<p>However, for those cases where the classes from the Java 2D API will satisfy 
your needs, you should probably use those classes rather than to invent your own 
classes.</p>
<p><font color="#FF0000"><b>Not a lesson on JAI</b></font></p>
<p>If you arrived at this lesson while searching for instructions on how to use 
the Java Advanced Imaging <i>(JAI)</i> API, you are certainly welcome to be 
here.&nbsp; However, that is not yet the purpose of the lessons in this series.&nbsp;
<i>(Maybe I will add lessons on the JAI API later.)</i></p>
<p>The JAI API provides image-processing capabilities that this series won't 
address for awhile.&nbsp; The next several lessons in this series will be 
limited to either the capabilities of the Java 2D API, or the capabilities of 
image-filtering programs that you write yourself.</p>
<p><font color="#FF0000"><b><a name="A_new_framework">A new framework</a> for the image-filtering classes of the Java 2D API</b></font></p>
<p>In this lesson, I will provide and explain a new framework program that makes it easy to:</p>
<ul>
	<li>Use the image-filtering classes of the Java 2D API to write and evaluate 
	image-filtering programs.</li>
	<li>Display the modified image along with the original image for easy 
	comparison in a <i>before</i> and <i>after</i> sense.</li>
</ul>
<p><font color="#FF0000"><b>A driver program</b></font></p>
<p>This program is designed to be used as a driver that controls 
the execution of another program that actually processes the pixels.</p>
<p>By 
using this program as a driver, you can concentrate on writing and executing 
image-filtering algorithms without 
having to worry about many of the details involving image files, image 
display, etc.</p>
<p><font color="#FF0000"><b>A simple image-filtering program</b></font></p>
<p>Also in this lesson, I will provide and explain the first of several 
image-filtering programs designed to teach you how to modify an image by using 
the image-filtering classes of the Java 2D API.</p>
<p>The image-filtering 
program provided in this lesson will be relatively simple with the intent being 
to get you started but not necessarily to produce a modified image that is 
especially interesting.</p>
<p><font color="#FF0000"><b>More interesting image-filtering programs</b></font></p>
<p><a href="#Figure_1">Figure 1</a> through <a href="#Figure_19">Figure 19</a> show examples of the use of the 
image-filtering 
classes from the <a href="#list_of_classes">earlier list</a> without showing the 
code used to produce the images.</p>
<p>Future lessons will show you how to write image-filtering programs that use 
the image-filtering classes that were presented in the
<a href="#list_of_classes">earlier list</a>.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>The programs that I will provide and explain in this series of lessons are 
not intended to be used for high-volume production work.&nbsp; Numerous 
integrated image-processing programs are available for that purpose.&nbsp; </p>
<p>However, most of the programs will have the capability to read an input image 
file, modify the image, and write the modified image into an output JPEG file.&nbsp; 
Therefore, feel free to use the programs to process your images if you find them 
useful.</p>
<h2 align="center"><a name="Image-Modification_Examples">Image-Filtering 
Examples</a></h2>
<p>This section provides examples of the input and output for images that 
were modified using the image-filtering classes of the Java 2D API and the <b>
ImgMod05</b> framework program.&nbsp; This lesson will provide and explain the 
code for the framework program.&nbsp; The specific code used to produce these 
images under control of the <b>ImgMod05</b> framework will be provided and 
explained in future lessons.</p>
<h3><b><a name="LookupOp_examples">LookupOp Examples</a></b></h3>
<p><font color="#FF0000"><b>Color inversion</b></font></p>
<p><a href="#Figure_1">Figure 1</a> shows the result of using the <b>LookupOp</b> class to invert the 
color values of all 
the blue pixels in an image without modifying the red and green 
<a name="Figure_1">pixels</a>.</p>






<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450a01.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As is always the case with the framework program named <b>ImgMod05</b>, the 
input image is shown at the top and the output image is shown at the bottom.</p>
<p><font color="#FF0000"><b>An independent look</b></font></p>
<p><a href="#Figure_2">Figure 2</a> shows an independent look at the output JPEG file produced by the 
program named <b>ImgMod05</b> for the case shown in <a name="Figure_2"><a href="#Figure_1">Figure 1</a></a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450a02.jpg" width="162" height="183"><br></pre>
      <pre><b><a href="#Figure_2">Figure 2</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The image shown in <a href="#Figure_2">Figure 2</a> was displayed using the commercial 
image-processing program named <a href="http://www.lview.com/">LView Pro</a>.</p>
<p><font color="#FF0000"><b>Invert all colors</b></font></p>
<p><a href="#Figure_3">Figure 3</a> shows the result of using the <b>LookupOp</b> class to invert the 
color values of all 
the red, green, and blue pixels in the same <a name="Figure_3">image</a>.</p>
<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450a03.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_3">Figure 3</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b><a name="A_few_words_about_image_color_inversion">A few words about image color inversion</a></b></font></p>
<p>I will show you more than one way to use the classes in the 
<a href="#list_of_classes">above list</a> to invert the colors in an image.&nbsp; 
Basically the process involves creating a new pixel color value by subtracting 
the old color value from 255.</p>
<p>Image inversion is an important concept for the following reasons:</p>
<ul>
	<li>Every color value in the inverted image is guaranteed to be different 
	from the original color value <i>(although values in the range of 127 and 
	128 aren't very different)</i>.</li>
	<li>Every color value in the inverted image is guaranteed to be within the 
	limits of 0 to 255 inclusive.</li>
	<li>The original color value can be easily recovered from the modified color 
	value simply by subtracting the modified color value from 255.</li>
</ul>
<p>For those reasons, many programs, <i>(such as the WYSIWYG HTML editor that I am 
using to write this lesson)</i>, use inverted image colors to represent the colors in 
an image that has been <i>selected</i> for editing.&nbsp; When the image is <i>deselected</i>, 
it is easy for the program to restore the original colors in the visual 
representation of the image.</p>
<p><font color="#FF0000"><b>Posterizing an image</b></font></p>
<p><a href="#Figure_4">Figure 4</a> shows the result of using the <b>LookupOp</b> class to <i>posterize</i> 
the same image shown <a name="Figure_4">earlier</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450a04.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_4">Figure 4</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>What does it mean to posterize an image?</b></font></p>
<p>The best explanation that I can give for the process of <i>posterizing</i> an 
image is that it reduces the number of actual colors used to represent the image.&nbsp; 
This tends to make it look like it was painted using a <i>&quot;paint by numbers&quot;</i> 
set containing a limited number of paint colors.</p>
<blockquote>
	<p><i>(If I did my calculations correctly, the bottom image in <a href="#Figure_4">Figure 4</a> has 
	twenty-seven actual colors, made up of three shades each of red, green, and 
	blue.)</i></p>
</blockquote>
<p><b><font color="#FF0000">Custom transforms</font></b></p>
<p><a href="#Figure_5">Figure 5</a> shows the result of using the <b>LookupOp</b> class to modify the 
distribution of the red, green, and blue pixel colors in such a way as to cause 
the distribution to become somewhat narrower and to cause the mean value to be 
moved closer to <a name="Figure_5">255</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450a05.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_5">Figure 5</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You learned quite a lot about the impact of modifying the pixel color 
distributions in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3441391">Processing 
Image Pixels Using Java: Controlling Contrast and Brightness</a>.</p>
<p><font color="#FF0000"><b>Many custom transforms are possible</b></font></p>
<p>You can use the <b>LookupOp</b> class to implement a wide variety of custom 
transforms that convert the incoming image pixel colors to a different, but 
well-defined set of output pixel colors.&nbsp; In a future lesson, I will show 
you how to implement a <i>Log Transform</i> and a <i>Linear Transform</i>.&nbsp; 
<i>(For future reference, the bottom image in <a href="#Figure_5">Figure 5</a> was produced using the 
Linear Transform with a Slope value of 0.85.)</i></p>
<p><font color="#FF0000"><b>Assessment</b></font></p>
<p>It would not be difficult to write your own image-filtering program to 
replicate the behavior of the <b>LookupOp</b> class.&nbsp; However, if the <b>
LookupOp</b> class will satisfy your needs, it will require more work for you to 
write your own class than to simply use the existing class.</p>
<p>Therefore, in the spirit of the <i>&quot;reuse, don't reinvent,&quot;</i> principle of 
OOP, if the <b>LookupOp</b> class will meet your needs, by all means use it and 
don't reinvent your own class to perform the same task.</p>
<h3><a name="AffineTransformOp_Examples">AffineTransformOp Examples</a></h3>
<p>In my opinion, <i>(with the possible exception of the <b>ColorConvertOp</b> 
class)</i>, the <b>AffineTransformOp</b> class is the most significant of 
all the image-filtering classes in the Java 2D API.&nbsp; I will explain my 
reasons for this opinion in the <a href="#Affine_Assessment">Assessment</a> section.&nbsp; 
First, however, I will show you some examples of what you can accomplish using 
this class.</p>
<p><font color="#FF0000"><b>Interpolation choices</b></font></p>
<p>Whenever you change the size, the location, or the orientation of an image, 
you usually need to recreate the color values for all of the new pixels on the 
basis of the color values contained in the original image.&nbsp; This is not a 
trivial computational task.</p>
<p>When you use the <b>AffineTransformOp</b> class to transform one image into 
another image, you have three choices regarding how the color values for the new 
pixels will be created:</p>
<ul>
	<li>Use the <i>nearest neighbor</i></li>
	<li>Perform <i>bilinear</i> interpolation</li>
	<li>Perform <i>bicubic</i> interpolation</li>
</ul>
<p>Generally speaking, the quality of the resulting image will improve and the 
computer time required to generate the new image will increase as you go down the 
list from top to bottom in making your choice.&nbsp; In other words, <i>
bicubic </i> interpolation usually requires more computational effort and 
provides better output image quality than simply using the <i>nearest neighbor</i>.&nbsp;
<i>Bilinear </i> interpolation falls somewhere in between the other two.</p>
<p>I will identify the choices that were used for each of the following 
examples.</p>
<p><font color="#FF0000"><b>Scaling</b></font></p>
<p><a href="#Figure_6">Figure 6</a> and <a href="#Figure_7">Figure 7</a> show the results of a simple scaling transform.&nbsp; 
For this transform, the width of the image was increased by a factor of 1.5 and 
the height was increased by a factor of 2.0.&nbsp; The <i>nearest neighbor</i> 
scheme<i> </i>was used to create the new pixel values for <a href="#Figure_6">Figure 6</a>.&nbsp; <i>
Bicubic </i>interpolation was 
used for <a name="Figure_6"><a href="#Figure_7">Figure 7</a></a>.</p>
</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450b01.jpg" width="241" height="463"><br></pre>
      <pre><b><a href="#Figure_6">Figure 6</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The image quality in Figure 7 is better</b></font></p>
<p>If you compare the bottom image in <a href="#Figure_6">Figure 6</a> above with 
the bottom image in <a href="#Figure_7">Figure 7</a> below, you 
should be able to see that the image quality in <a href="#Figure_7">Figure 7</a> is superior to that in 
<a name="Figure_7"><a href="#Figure_6">Figure 6</a></a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450b02.jpg" width="241" height="463"><br></pre>
      <pre><b><a href="#Figure_7">Figure 7</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Neither image has outstanding quality</b></font></p>
<p>Although neither image shows outstanding quality, <i>(which is a common 
result of enlarging images of this type)</i>, the image produced using the <i>
nearest neighbor </i> scheme in <a href="#Figure_6">Figure 6</a> is more grainy than the image 
produced using <i>bicubic </i> interpolation in <a href="#Figure_7">Figure 7</a>.</p>
<blockquote>
	<p><i>(For example, note the vertical stripes in the light gray stem in the 
	upper-left of the image in <a href="#Figure_6">Figure 6</a>.&nbsp; Although there is some striping 
	in this area of <a href="#Figure_7">Figure 7</a>, it isn't nearly as pronounced.)</i></p>
</blockquote>
<p><b><font color="#FF0000">Will use <i>bicubic </i> interpolation for remaining 
examples</font></b></p>
<p>Now that we have that issue out of the way, the remaining <b>
AffineTransformOp</b> examples will use <i>bicubic </i>interpolation.</p>
<p><font color="#FF0000"><b>Translation</b></font></p>
<p><a href="#Figure_8">Figure 8</a> shows the result of translating the image by 15.25 pixels to the 
right and 20.75 pixels <a name="Figure_8">down</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><b><img border="0" src="java450b03.jpg" width="180" height="348">

<a href="#Figure_8">Figure 8</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Ideally, the output image would be an exact copy of the input image in this 
case.&nbsp; However, there is probably some degradation due to the requirement 
to create the new pixel color values through interpolation of the original pixel 
color values.</p>
<p><font color="#FF0000"><b>Rotation</b></font></p>
<p><a href="#Figure_9">Figure 9</a> shows the result of first translating the image to the right and 
down a distance sufficient to give it room to rotate it about its center, and 
then rotating it by 31.5 degrees in a clockwise direction about its 
<a name="Figure_9">center</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450b04.jpg" width="232" height="392"><br></pre>
      <pre><b><a href="#Figure_9">Figure 9</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Mirror image</b></font></p>
<p><a href="#Figure_10">Figure 10</a> shows the result of using the <b>AffineTransformOp</b> class to 
effectively flip the image about a vertical line in the center of the image, thus creating a 
mirror image of the original <a name="Figure_10">image</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450b05.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_10">Figure 10</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b><a name="Affine_Assessment">Assessment</a></b></font></p>
<p>You can combine these basic transforms to produce a wide variety of 
other results.</p>
<p>As I stated earlier, in my opinion, the <b>AffineTransformOp</b> class is 
probably the 
most significant of all the image-filtering classes in the Java 2D API.&nbsp; 
Because of the interpolation issue, a great deal of programming effort would be 
required for you to write your own class that duplicates the behavior of the <b>
AffineTransformOp</b> class.&nbsp; Therefore, if this class will serve your 
needs, this is clearly a case where you should <i>use</i> the existing class 
instead of <i>inventing</i> a new class.</p>
<h3><a name="BandCombineOp_Examples">BandCombineOp Examples</a></h3>
<p><font color="#FF0000"><b>BufferedImage objects versus Raster 
objects</b></font></p>
<p>Unlike some of the other image-filtering classes in the Java 2D API that can operate 
either on <b>BufferedImage</b> objects or on <b>Raster</b> objects, the <b>
BandCombineOp</b> filter can operate only on <b>Raster</b> objects.</p>
<blockquote>
	<p><i>(I will have more to say about <b>BufferedImage</b> objects and <b>Raster</b> 
	objects in future lessons.&nbsp; For now, suffice it to say that by 
	converting the <b>BufferedImage</b> objects to <b>Raster</b> objects, it is 
	possible to operate on smaller rectangular areas of the image 
	that are extracted from within the body of the entire image.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Image-filtering methodology</b></font></p>
<p>For the <b>BandCombineOp </b>class, the red, green, and blue values of each 
pixel are treated as a column matrix.&nbsp; A 1 is appended onto the end of each 
column matrix producing a set of four-element column matrices that represents 
all of the pixels in the input <b>Raster</b> object.</p>
<p>Each pixel in the output <b>Raster</b> is produced by multiplying a 
user-specified 3x4 processing matrix by the 4x1 column matrix that represents 
the corresponding pixel in the input <b>Raster</b>.&nbsp; The same 3x4 
processing matrix is applied to every input pixel.</p>
<p>This makes it possible to cause the intensity or shade of each of the three 
colors <i>(red, green, and blue)</i> in each pixel of 
the output <b>Raster</b> to be a function of the combined intensities of all three colors 
of the corresponding pixel in the input <b>Raster</b>, <i>(plus a constant that is 
equal to the rightmost value in the corresponding row of the processing matrix)</i>.</p>
<p><font color="#FF0000"><b>Potential arithmetic overflow</b></font></p>
<p>It is unclear in the documentation what happens to the output color value if 
the value resulting from the matrix multiplication and the addition of the 
constant falls outside the range from 
0 to 255.&nbsp; However, observation of the results indicates that rather than 
clipping the value to force it to be within the range from 0 to 255, the value 
is allowed to overflow and become corrupt.&nbsp; Therefore, care must be 
exercised to avoid such overflow when setting the multiplicative values in the 
processing matrix.</p>
<blockquote>
	<p><i>(On the other hand, allowing the overflow to occur can lead to some 
	interesting visual effects.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A variety of interesting effects</b></font></p>
<p>This processing approach can lead to a variety of interesting effects.&nbsp; 
One <a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
author</a> says that this class can be used to create
<a href="http://www.angelfire.com/co/artgeometry/">cubist-style</a> images.&nbsp;
<i>(Given my limited knowledge of art, I will simply have to take the 
author's word on this.)</i></p>
<p><font color="#FF0000"><b>Color inversion</b></font></p>
<p>As with two of the other image-filtering classes, this class can easily 
be used to invert the colors, producing an output just like the output shown in 
<a href="#Figure_3">Figure 3</a>.&nbsp; <i>(Since I have already shown you an 
inverted image, I will simply refer back to 
<a href="#Figure_3">Figure 3</a> in this section rather than repeating it here.)</i></p>
<p><font color="#FF0000"><b>Conversion to gray</b></font></p>
<p><a href="#Figure_11">Figure 11</a> shows the result of causing the red, green, and blue color values 
of each output pixel to be the average of all three color values of the 
corresponding input <a name="Figure_11">pixel</a>. </p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450c01.jpg" width="164" height="311"><br></pre>
      <pre><b><a href="#Figure_11">Figure 11</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Figure_11">Figure 11</a> also shows the result of extracting and processing a <b>Raster</b> 
from the original image that is 130 pixels wide and 120 pixels tall with the 
upper-left corner of the <b>Raster</b> being located at a horizontal position of 
10 pixels and a vertical position of 15 pixels in the original image.</p>
<p><font color="#FF0000"><b>Arithmetic overflow</b></font></p>
<p><a href="#Figure_12">Figure 12</a> shows the same thing as <a href="#Figure_11">Figure 11</a>, except that each output color 
value in <a href="#Figure_12">Figure 12</a> was multiplied by 1.515 relative to the values in 
<a name="Figure_12" href="#Figure_11">Figure 11</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450c02.jpg" width="164" height="311"><br></pre>
      <pre><b><a href="#Figure_12">Figure 12</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see, this caused the overall output image in <a href="#Figure_12">Figure 12</a> to be 
brighter than the output image in <a href="#Figure_11">Figure 11</a>.</p>
<p>As you can also see, this resulted in arithmetic overflow for those 
output color values that exceeded a value of 255.&nbsp; As a result, light gray 
areas in <a href="#Figure_11">Figure 11</a> became black areas outlined with white in <a href="#Figure_12">Figure 12</a>.</p>
<p><font color="#FF0000"><b>A cubist-style image</b></font></p>
<p>For whatever it is worth, if I interpreted the previously-referenced
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
article</a> correctly, the output shown in <a href="#Figure_13">Figure 13</a> is a <i>cubist-style</i> 
image.&nbsp; At least, it was produced using the same processing matrix as the 
one given in 
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html" name="Figure_13">that
</a>
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
article</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450c03.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_13">Figure 13</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>However, as I stated earlier, given my limited knowledge of art, I will 
simply have to take the
<a href="http://javaboutique.internet.com/tutorials/rasters2/listing6.html">
author's</a> word that this is a <i>cubist-style</i> image.&nbsp; Whatever it 
is, it illustrates that it is possible to use the <b>BandCombineOp</b> class to 
produce some weird and interesting effects.</p>
<h3><a name="ConvolveOp_Examples">ConvolveOp Examples</a></h3>
<p>In my opinion, the <b>ConvolveOp</b> class is the weakest of the 
image-filtering classes in the Java 2D API.&nbsp; I will explain my reasons for 
this opinion later in the section entitled <a href="#ConvolveOpAssessment">
Assessment</a>.&nbsp; First, however, I will show you some examples of image 
convolution using the capabilities of the <b>ConvolveOp</b> class.</p>
<p><font color="#FF0000"><b>Edge treatment</b></font></p>
<p>When performing image convolution, you must always decide how you are going 
to treat the edges of the image.&nbsp; The <b>ConvolveOp</b> class provides the 
following choices:</p>
<ul>
	<li>Copy edge pixels in unmodified form</li>
	<li>Zero fill the edge pixels</li>
</ul>
<p><a href="#Figure_14">Figure 14</a> and <a href="#Figure_15">Figure 15</a> show the results of 
electing each of those two choices.</p>
<blockquote>
	<p><i>(The 
processed portion of each image was purposely blacked out or set to white to 
emphasize the treatment of the edges.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Copy edge pixels in unmodified form</b></font></p>
<p>In <a href="#Figure_14">Figure 14</a>, the pixels at the edges of the input image were simply copied 
to the edges of the output image without modification.&nbsp; This is evidenced 
by the fact that the edges of the output image look just like the edges of the 
input <a name="Figure_14">image</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450d01.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_14">Figure 14</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Zero fill the edge pixels</b></font></p>
<p>In <a href="#Figure_15">Figure 15</a>, the pixels at the edge of the output image were set to zero, 
producing the black border around the output <a name="Figure_15">image</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450d02.jpg" width="164" height="327"><br></pre>
      <pre><b><a href="#Figure_15">Figure 15</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The remaining examples in this section will use the first alternative and 
simply copy the pixels from the edges of the input image to the edges of the 
output image in unmodified form.&nbsp; I will explain what controls the width of 
the border produced by that process in a future lesson on the <b>ConvolveOp</b> 
class.</p>
<p><font color="#FF0000"><b>A flat 4x4 smoothing filter</b></font></p>

<p><a href="#Figure_16">Figure 16</a> shows the result of applying a flat 4x4 smoothing filter to the 
same image of a starfish that was used in the earlier lesson entitled
<a name="Figure_16" href="http://www.developer.com/java/ent/article.php/3590351#Figure_18">Processing Image 
Pixels, Applying Image Convolution in Java</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450d03.jpg" width="311" height="477"><br></pre>
      <pre><b><a href="#Figure_16">Figure 16</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you compare the output image in <a href="#Figure_16">Figure 16</a> with the corresponding figure in 
the <a href="http://www.developer.com/java/ent/article.php/3590351#Figure_18">
earlier lesson</a>, you will see good agreement.&nbsp; This is because none of 
the output color values fell outside the range from 0 to 255 inclusive, and it 
was not necessary to deal with the normalization issue that I will discuss later 
in the <a href="#ConvolveOpAssessment">Assessment</a> section.</p>
<p><font color="#FF0000"><b>An embossing filter</b></font></p>
<p>The <a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a> presented the results of a convolution filtering process that 
was intended to produce an output that looks like embossed stationary.&nbsp; 
<a href="#Figure_17">Figure 17</a> shows the same process implemented using the <b>ConvolveOp</b> 
<a name="Figure_17">class</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450d04.jpg" width="311" height="477"><br></pre>
      <pre><b><a href="#Figure_17">Figure 17</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The differences are striking</b></font></p>
<p>The difference between the results shown in <a href="#Figure_17">Figure 17</a> and the results in the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a> are striking.&nbsp; The difference lies solely in the <i>
normalization</i> scheme used to deal with convolution output values that fall 
outside the allowable range from 0 through 255 inclusive.</p>
<p><font color="#FF0000"><b>One approach is to simply clip the values</b></font></p>
<p>Apparently the <b>ConvolveOp</b> class simply clips those values at 0 and 
255.&nbsp; Thus, this is not a <i>safe</i> scheme because it throws away some of 
the output values replacing them by either 0 or 255.</p>
<p><font color="#FF0000"><b><a name="A_statistical_scheme">A statistical scheme</a></b></font></p>
<p>The scheme used in the
<a href="http://www.developer.com/java/ent/article.php/3590351#Figure_34">
earlier lesson</a>, on the other hand doesn't throw away any of the output 
values.&nbsp; Rather, the distribution of the output values is compressed, while 
maintaining its general shape, so as to cause all of the output values to fall 
within the allowable range.&nbsp; Thus, this is a <i>safe</i> scheme in that it 
doesn't throw away any information.</p>
<blockquote>
	<p><i>(When we do DSP in the world of signals, we usually try to avoid 
	clipping the data.&nbsp; Clipping is a nonlinear, non-reversible process, 
	which is usually considered to be a bad idea.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Another statistical scheme</b></font></p>
<p><a href="http://www.developer.com/java/ent/article.php/3590351#Figure_57">
Another image</a> in the earlier lesson shows the results for the same input 
image and the same convolution filter with still another normalization scheme.&nbsp; 
This scheme causes the mean and the standard deviation of the output to match 
the mean and the standard deviation of the input.&nbsp; As a result, some of the 
output values may still fall outside the acceptable limits.&nbsp; In that case, 
those values are simply clipped at 0 and 255, making this scheme less <i>safe</i> 
than the one described <a href="#A_statistical_scheme">above</a>, but probably 
more safe than simply clipping the output values at 0 and 255.</p>
<p><font color="#FF0000"><b><a name="ConvolveOpAssessment">Assessment</a></b></font></p>
<p>Earlier I indicated that in my opinion, the <b>ConvolveOp</b> class is the 
weakest of the image-filtering classes in the Java 2D API.&nbsp; Now I will 
explain my reasons for that opinion.</p>
<p><font color="#FF0000"><b>Output normalization is the real issue</b></font></p>
<p>In the earlier lesson entitled
<a href="http://www.developer.com/java/ent/article.php/3590351">Processing Image 
Pixels, Applying Image Convolution in Java</a>, I explained that image 
convolution results can, and frequently do result in color values that fall 
outside the range from 0 through 255 inclusive.&nbsp; Thus, the real issue in image 
convolution is not how to do the convolution arithmetic.&nbsp; The 
arithmetic algorithm for image convolution is almost trivial.&nbsp; The real 
issue for the serious image processor has to do with how you normalize the 
output values to:</p>
<ul>
	<li>Force them into the range from 0 through 255,</li>
	<li>Discard those that are outside the range from 0 through 255, or</li>
	<li>A combination of the two</li>
</ul>
<p><font color="#FF0000"><b>Apparently the ConvolveOp class simply clips the 
output</b></font></p>
<p>Although the documentation for the <b>ConvolveOp</b> class doesn't indicate 
how the results are normalized, observation of the results suggests that values 
outside the acceptable range are simply clipped to values of 0 and 255.</p>
<p><font color="#FF0000"><b>Not necessarily the best approach</b></font></p>
<p>While that is the easiest approach to implement, it probably isn't the best 
approach from an image processing viewpoint.&nbsp; In fact, there probably isn't 
any one best approach.&nbsp; The normalization scheme that works best for one 
situation is likely to give way to a different normalization scheme for another 
situation.&nbsp; Unfortunately, simply clipping the output at 0 and 255 isn't 
likely to be the best approach for very many situations.</p>
<p><font color="#FF0000"><b>Two normalization schemes were described earlier</b></font></p>
<p>In the earlier lesson entitled
<a href="http://www.developer.com/java/ent/article.php/3590351">Processing Image 
Pixels, Applying Image Convolution in Java</a>, I described two different 
normalization schemes that are based on the statistical distribution of the 
input and output color values.&nbsp; I showed that the choice of normalization scheme can have a 
dramatic effect on the visual results.</p>
<p><font color="#FF0000"><b>Would like optional normalization schemes in the 
ConvolveOp class</b></font></p>
<p>I would like to have seen a choice among several such normalization schemes 
provided by the <b>ConvolveOp</b> class instead of simply clipping the 
results to values of 0 and 255.&nbsp; In my opinion, simply clipping the results 
seriously limits the value of the <b>ConvolveOp</b> class for the serious image 
processor.</p>
<h3><a name="RescaleOp_Examples">RescaleOp Examples</a></h3>
<p>The <b>RescaleOp</b> class can be used to multiply the color value for each 
pixel by a user-specified scale factor, and then to add a user-specified constant 
to the product.&nbsp; Separate scale factors and additive constants are provided 
for each of the red, green, and blue colors.</p>
<p>Color values that fall outside the allowable range from 0 to 255 are simply 
clipped to 0 and 255.</p>
<p><font color="#FF0000"><b>Color inversion</b></font></p>
<p>This is another class that makes it easy to invert the colors.&nbsp; In this 
case, the scale factor for all three bands would be set to -1 and the additive 
constant would be set to 255.&nbsp; This would produce an output image like that 
shown in <a href="#Figure_3">Figure 3</a>.&nbsp; Similarly, each color band can be inverted separately 
producing results like those shown in <a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>Adjusting the contrast and brightness</b></font></p>
<p>The <b>RescaleOp</b> class can also be used to adjust the contrast and 
brightness of an image using the concepts that I explained in the earlier lesson 
entitled <a href="http://www.developer.com/java/other/article.php/3441391">
Processing Image Pixels Using Java: Controlling Contrast and Brightness</a>.</p>
<p><a href="#Figure_18">Figure 18</a> shows the result of using the <b>RescaleOp</b> class to improve the 
contrast and brightness of the input image.&nbsp; In this case, each color value 
was multiplied by 3 and then a value of -160 was added to each 
<a name="Figure_18">product</a>.</p>

<p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450e01.jpg" width="305" height="690"><br></pre>
      <pre><b><a href="#Figure_18">Figure 18</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The statistical changes</b></font></p>
<p>Multiplying the color values by a scale factor widens the distribution as 
shown in the <a href="http://www.developer.com/java/other/article.php/3441391">
earlier lesson</a>.&nbsp; This increases the contrast.&nbsp; Adding the constant 
adjusts the mean value, thus modifying the brightness.</p>
<blockquote>
	<p><i>(See the histogram in the
	<a href="http://www.developer.com/java/other/article.php/3441391">earlier 
	lesson</a>.)</i></p>
</blockquote>
<p>Note that although the methodology isn't exactly the same, the results in 
<a href="#Figure_18">Figure 18</a> compare favorably with the first figure in the
<a href="http://www.developer.com/java/other/article.php/3441391">earlier lesson</a> 
indicating that the standard deviation and the mean for the output image in 
<a href="#Figure_18">Figure 18</a> is probably very similar to the standard deviation and the mean for 
the output image shown in the first figure in the
<a href="http://www.developer.com/java/other/article.php/3441391">earlier lesson</a>.</p>
<p><font color="#FF0000"><b>Assessment</b></font></p>
<p>As demonstrated in the earlier lesson, it is not difficult to write your own 
program to replicate the behavior of the <b>RescaleOp</b> class.&nbsp; However, 
if the <b>RescaleOp</b> class will serve your needs, use it, don't reinvent it.</p>
<p><font color="#FF0000"><b>One major difference</b></font></p>
<p>There is, however, one aspect of my implementation in the
<a href="http://www.developer.com/java/other/article.php/3441391">earlier lesson</a> 
that I consider to be better than the implementation of the <b>RescaleOp</b> 
class, particularly when used for the purpose of adjusting the contrast and 
brightness of an image.</p>
<p>The mean value modification in my implementation is specified by the user as a multiplier, 
such as 1.25.&nbsp; This would, for example, cause the new mean value to be 1.25 
times greater than the old mean value.</p>
<p>With the <b>RescaleOp</b> class, a 
constant must be added or subtracted from the product in order to move the mean 
value.&nbsp; You usually won't know what the actual mean value is, so you 
will have to do a lot of guesswork in order to determine the proper additive 
value.</p>
<p>On the other hand, the <b>RescaleOp</b> class can be used for other purposes
<i>(such as <a href="#Figure_3">color inversion</a>)</i> where an additive constant is more appropriate 
than a multiplicative factor so it is a more general implementation.</p>
<h3><a name="ColorConvertOp_Examples">ColorConvertOp Example</a></h3>
<p>The apparent purpose of this class is to make it possible for you to convert 
an image from one <b>ColorSpace</b> to another <b>ColorSpace</b>.</p>
<blockquote>
	<p><i>(I will leave it up to you to go to the Sun documentation to learn 
	about the <b>ColorSpace</b> class.)</i>&nbsp; </p>
</blockquote>
<p>In any event, when deciding upon a new color space, several are available.&nbsp; 
They are 
defined as constants in the <b>ColorSpace</b> class.</p>
<p><font color="#FF0000"><b>Conversion to grayscale</b></font></p>
<p><a href="#Figure_19">Figure 19</a> coverts the color space of the input image to type <b>
ColorSpace.CS_GRAY</b>.&nbsp; As you can see, this changed the image from a 
color image to what would probably be called a grayscale <a name="Figure_19">image</a>.</p><p>
<table border="1" cols="1"  bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java450f01.jpg" width="311" height="477"><br></pre>
      <pre><b><a href="#Figure_19">Figure 19</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Assessment</b></font></p>
<p>In my opinion, writing your own program to replicate the behavior of the <b>
ColorConvertOp</b> class would be very difficult.&nbsp; If you need this 
capability, by all means, use the class and don't attempt to reinvent it.</p>
<p><font color="#FF0000"><b>A caveat</b></font></p>
<p>This is the one case that I have found where programs that use the 
image-filtering classes of the Java 2D API are incompatible with the 
framework program named <b>ImgMod05</b>.&nbsp; If you modify the color space of 
an image, the code in <b>ImgMod05</b> that attempts to write the output image 
into a JPEG file will throw an error.</p>
 
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p>Before getting into the programming details, it may be useful for you to review the 
concept of how images are constructed, stored, transported, and rendered in Java
<i>(and in most modern computers for that matter).</i></p>
<p>I provided a great deal of information on these topics in the earlier 
lesson entitled
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
Processing Image Pixels using Java, Getting Started</a>.&nbsp; Therefore, I 
won't repeat that information here.&nbsp; Rather, I will simply refer you back 
to the
<a href="http://www.developer.com/java/other/article.php/3403921#Background_Information">
earlier lesson</a>.</p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<p>In addition, I recommend that you study the lessons that I have listed in the
<a href="#References">References</a> section of this document.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain the three programs and one 
interface:</p>
<ul>
	<li>ImgMod05a</li>
	<li>ImgMod05</li>
	<li>ProgramTest</li>
	<li>ImgIntfc05</li>
</ul>
<p><font color="#FF0000"><b>ImgMod05a</b></font></p>
<p>This is just about the simplest program that I know how to write that shows 
how to read, modify, and write an image file using Java2D image-filtering 
classes.&nbsp; This program isn't intended to be particularly useful in its own 
right.&nbsp; Rather, it is intended to teach you how to accomplish the steps 
described above so that you will understand those steps when you attack the 
larger program named <b>ImgMod05</b>.</p>
<p><font color="#FF0000"><b>ImgMod05</b></font></p>
<p>This is the main program for which this lesson was written.&nbsp; This is the 
new image-processing <a href="#A_new_framework">framework</a> program that I 
described in earlier sections of this lesson.</p>
<p><font color="#FF0000"><b>ProgramTest</b></font></p>
<p>This is a test program designed to test the program named <b>ImgMod05</b> and 
also intended to show the essentials of writing an image-processing program that 
can be run under control of the <b>ImgMod05</b> framework.</p>
<p><font color="#FF0000"><b>ImgIntfc05</b></font></p>
<p>This is an interface that must be implemented by any program that is designed 
to run under control of the <b>ImgMod05</b> framework.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Programs</font></h2>
</center>
<h3><a name="The_program_named_ImgMod05a">The program named <i>ImgMod05a</i></a></h3>
<p>I will 
begin by explaining the program named <b>ImgMod05a</b>.&nbsp; I will explain the 
program in fragments.&nbsp; You can view a complete listing of the program in 
<a href="#Listing_29">Listing 29</a> near the end of the lesson.</p>
<p>As mentioned earlier, the purpose of this program is to show you, in the 
simplest program practical, how to read, modify, and write an image file using Java2D image-filtering 
classes.</p>
<p>The program was tested using J2SE 5.0 under WinXP.</p>
<p><font color="#FF0000"><b>The ImgMod05a class</b></font></p>
<p>The beginning of the class is shown in <a name="Listing_1"><a href="#Listing_1">Listing 1</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class <b>ImgMod05a</b>{
  BufferedImage rawBufferedImage;
  BufferedImage processedImage;
  static String theImgFile = "ImgMod05Test.jpg";
  MediaTracker tracker;<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_1">Listing 1</a> declares four instance variables, two of which are type <b>
BufferedImage</b>.&nbsp; The <b>BufferedImage</b> type is relatively new to this lesson, 
and is crucial to the use of the image-filtering classes of the Java 2D API.</p>
<p>The types of the other two instance variables have been used in numerous 
previous lessons.</p>
<p><font color="#FF0000"><b>The BufferedImage class</b></font></p>
<p>The <b>BufferedImage</b> class belongs to the <b>java.awt.image</b> package.&nbsp; 
<a href="#Figure_20">Figure 20</a> contains part of what Sun has to say about this
<a name="Figure_20">class</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      The <b>BufferedImage</b> subclass describes an <b>Image</b> with an 
		accessible buffer of image data.<p>A <b>BufferedImage</b> is comprised 
		of a <b>ColorModel</b> and a <b>Raster</b> of image data.</p>
		<p>The number and types of bands in the <b>SampleModel</b> of the <b>
		Raster</b> must match the number and types required by the <b>ColorModel</b> 
		to represent its color and alpha components.</p>
		<p>All <b>BufferedImage</b> objects have an upper left corner coordinate 
		of (0, 0). </p>
		<p>Any <b>Raster</b> used to construct a <b>BufferedImage</b> must 
		therefore have minX=0 and minY=0.<br>
      </p>
      <pre><b><a href="#Figure_20">Figure 20</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Objects of the BufferedImage class are required</b></font></p>
<p>As you will see later, the framework program named <b>ImgMod05</b>: </p>
<ul>
	<li>Reads and displays image data from an image file.</li>
	<li>Creates a <b>BufferedImage</b> object from the contents of the image 
	file.</li>
	<li>Passes the <b>BufferedImage</b> object to the image-processing program 
	for image processing.</li>
	<li>Receives a modified <b>BufferedImage</b> object back from the 
	image-processing program and displays the modified image.</li>
	<li>Repeats the cycle each time the user clicks a <b>Replot</b> button.</li>
</ul>
<p><font color="#FF0000"><b>One class cannot operate directly on a BufferedImage 
object</b></font></p>
<p>All but one of the image-filtering classes in the Java 2D API can operate 
directly on <b>BufferedImage</b> objects, or on <b>Raster</b> objects.&nbsp; The 
one exception is the <b>BandCombineOp</b> image-filtering class, which can 
operate only on <b>Raster</b> objects.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method for this class is shown in its entirety in 
<a name="Listing_2"><a href="#Listing_2">Listing 2</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void <b>main</b>(String[] args){
    //Instantiate an object of this class.
    ImgMod05a obj = new ImgMod05a();
  }//end main<br><br><b><font face="Courier New,Courier"><a href="#Listing_2">Listing 2</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_2">Listing 2</a> is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>The constructor for ImgMod05a</b></font></p>
<p>The constructor for the class is shown in its entirety in <a name="Listing_3"><a href="#Listing_3">Listing 3</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public ImgMod05a(){//constructor
    //Get an image from the specified image file.
    rawBufferedImage = getTheImage();

    //Process the image.
    processedImage = processImg(rawBufferedImage);
    
    //Write the modified image into a JPEG file named
    // junk.jpg.
    writeJpegFile(processedImage);

  }//end ImgMod05a constructor<br><br><b><font face="Courier New,Courier"><a href="#Listing_3">Listing 3</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_3">Listing 3</a> is also straightforward since all it does is invoke 
three methods in succession.&nbsp; The purposes of the three methods
<a name="threeMethods">are</a>:</p>
<ul>
	<li><b>getTheImage</b> - Get a BufferedImage object that represents the image.</li>
	<li><b>processImg</b> - Process the image.</li>
	<li><b>writeJpegFile</b> - Write the modified image into an output JPEG file named <b>junk.jpg</b>.</li>
</ul>
<p>All the real work is done by the three methods listed <a href="#threeMethods">
above</a>.</p>
<p><font color="#FF0000"><b>The method named getTheImage</b></font></p>
<p>The method named <b>getTheImage</b> begins in <a name="Listing_4"><a href="#Listing_4">Listing 4</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  //This method reads an image from a specified image file,
  // writes it into a BufferedImage object, and returns a
  // reference to the BufferedImage object.
  //The name of the image file is contained in an instance
  // variable of type String named theImgFile.
  BufferedImage getTheImage(){
    Image rawImage = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.  Terminate and
    // display an error message if ten seconds elapse
    // without the image having been loaded.  Note that the
    // constructor for the MediaTracker requires the
    // specification of a Component "on which the images
    // will eventually be drawn" even if there is no
    // intention for the program to actually display the 
    // image.  It is useful to have a media tracker with a
    // timeout even if the image won't be drawn by the
    // program.  Also, the media tracker is needed to delay
    // execution until the image is fully loaded.
    tracker = new MediaTracker(new Frame());
    tracker.addImage(rawImage,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Timeout or Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if<br><br><b><font face="Courier New,Courier"><a href="#Listing_4">Listing 4</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Nothing new here</b></font><p>I have used and explained code similar to that shown in <a href="#Listing_4">Listing 4</a> in numerous 
previous lessons so there is nothing new here.&nbsp; If you are unfamiliar with 
that code, just go to <a href="http://www.google.com/">Google</a> and search for 
the keywords <pre>Baldwin MediaTracker.</pre>
<p><font color="#FF0000"><b>Create a BufferedImage object</b></font></p>
<p>The code in <a href="#Listing_5">Listing 5</a> begins by creating an empty <b>BufferedImage</b> object 
using one of three overloaded constructors that exist for the <b>BufferedImage</b> 
class as of the date of this writing.&nbsp; This code is new to this 
<a name="Listing_5">lesson</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    BufferedImage buffImage = new BufferedImage(
                              rawImage.getWidth(null),
                              rawImage.getHeight(null),
                              BufferedImage.TYPE_INT_RGB);<br><br><b><font face="Courier New,Courier"><a href="#Listing_5">Listing 5</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the specified image type in <a href="#Listing_5">Listing 5</a> is critical to the correct 
operation of the method named <b>processImg</b>, which will be invoked later.&nbsp;
<i>(The <b>processImg </b>method may work correctly for other image types, but 
has been <span lang="en-us"></span>tested only for <b>TYPE_INT_RGB</b>.)</i></p>
<p>The parameters to the <b>getWidth</b> and <b>getHeight</b> methods in Listing 
5 are references to an <b>ImageObserver</b> object, or references to <i>&quot;an object 
waiting for the image to be loaded.&quot;</i></p>
<p><font color="#FF0000"><b>Draw the image data into the BufferedImage object</b></font></p>
<p>The code in <a href="#Listing_6">Listing 6</a> draws the image data from the input file into the <b>
BufferedImage</b> object and returns a reference to that <a name="Listing_6">object</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImage, 0, 0, null);

    return buffImage;
  }//end getTheImage<br><br><b><font face="Courier New,Courier"><a href="#Listing_6">Listing 6</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You should have no problem following the code in <a href="#Listing_6">Listing 6</a> if you simply 
look up the various methods in the Sun documentation.</p>
<p><font color="#FF0000"><b>Process the image</b></font></p>
<p>Going back to <a href="#Listing_3">Listing 3</a>, the constructor next passes the <b>BufferedImage</b> 
object to the method named <b>processImg</b> for processing.</p>
<p>The version 
of the <b>processImg</b> method in this demonstration program uses the 
image-filtering class named <b>LookupOp</b> from the Java 2D API to process the 
image.&nbsp; However, a representative <b>processImg</b> method could have been written using any of the classes 
provided in the <a href="#list_of_classes">earlier list</a> of image-filtering 
classes.</p>
<p><font color="#FF0000"><b>Behavior of the processImg method</b></font></p>
<p>The behavior of the <b>processImg</b> method is to use the <b>LookupOp</b> class to invert all of the color values in the pixels 
as shown by the bottom image in <a href="#Figure_3">Figure 3</a>.&nbsp; </p>
<blockquote>
	<p><i>(Note that this demonstration program does not display the processed 
	image.&nbsp; You will need to use some other program to display the output 
	file named <b>junk.jpg</b> to see the processing results.)</i></p>
</blockquote>
<p>The alpha <i>(transparency)</i> value is not modified.&nbsp; 
As I explained earlier, the process of inverting the color values consists of 
subtracting each color value from 255.</p>
<p><font color="#FF0000"><b>What does Sun have to say?</b></font></p>
<p><a href="#Figure_21">Figure 21</a> contains part of what Sun has to say about the <b>LookupOp</b> 
<a name="Figure_21">class</a>.</p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      This class implements a lookup operation from the source to the destination.<p>The
		<b>LookupTable</b> object may contain a single array or multiple arrays, subject to the restrictions below.</p>
		<p>For <b>Rasters</b>, <b>...</b></p>
		<p>For <b>BufferedImages</b>, the lookup operates on color and alpha components.&nbsp;
		</p>
		<p>The number of lookup arrays may be one, in which case the same array is applied to all color 
		<i>(but not alpha)</i> components.&nbsp; Otherwise, the number of lookup arrays may equal the number of Source color components, in which case no lookup of the alpha component 
		<i>(if present)</i> is performed.<br>
      </p>
      <pre><b><a href="#Figure_21">Figure 21</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>To make a long story short ...</b></font></p>
<p>The <b>filter</b> method that is later invoked on 
an object of the <b>LookupOp</b> class uses a color value from a pixel as an 
ordinal index into a lookup table.&nbsp; It replaces the color value in the 
pixel with the value stored in the lookup table at that index.&nbsp; Thus, you 
can modify the color values in the pixels using just about any substitution 
algorithm that you can devise.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>

<p>The <b>processImg</b> method begins in <a name="Listing_7"><a href="#Listing_7">Listing 7</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public BufferedImage processImg(BufferedImage theImage){

    //Create the data for the lookup table.
    short[] lookupData = new short[256];
    for (int cnt = 0; cnt &lt; 256; cnt++){
      lookupData[cnt] = (short)(255-cnt);
    }//end for loop<br><br><b><font face="Courier New,Courier"><a href="#Listing_7">Listing 7</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_7">Listing 7</a> creates and populates a one-dimensional array of type
<b>short</b> containing 256 values where the value in each element is equal to 
255 minus the element index.&nbsp; This will satisfy the requirement for color 
inversion <a href="#A_few_words_about_image_color_inversion">described earlier</a>.</p>
<p><font color="#FF0000"><b>Create the actual lookup table</b></font></p>
<p><a href="#Listing_8">Listing 8</a> creates the lookup table by instantiating an object of type <b>ShortLookupTable</b> 
and 
passing the array of lookup data as the second parameter to the constructor.&nbsp; 
<i>(The first parameter is an offset value that makes it possible to cause the early 
elements in the lookup data array to be <a name="Listing_8">ignored</a>.)</i></p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    ShortLookupTable lookupTable = 
                        new ShortLookupTable(0,lookupData);<br><br><b><font face="Courier New,Courier"><a href="#Listing_8">Listing 8</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Figure_22">Figure 22</a> contains part of what Sun has to say about 
the <b>ShortLookupTable</b> <a name="Figure_22">class</a>.</p>

<p>
<table border="1" cols="1" width="482" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      This class defines a lookup table object.&nbsp; The output of a lookup operation using an object of this class is interpreted as an unsigned short quantity.<p>The lookup table contains short data arrays for one or more bands 
		<i>(or components)</i> of an image, and it contains an offset which will be subtracted from the input values before indexing the arrays. This allows an array smaller than the native data size to be provided for a constrained input. If there is only one array in the lookup table, it will be applied to all bands. <br>
      </p>
      <pre><b><a href="#Figure_22">Figure 22</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Create the filter object</b></font></p>
<p><a href="#Listing_9">Listing 9</a> creates the filter object by instantiating an object of the <b>
LookupOp</b> class and saving its reference as type <b>BufferedImageOp</b>.</p>
<blockquote>
	<p><i>(<b>BufferedImageOp</b> is an interface that is implemented by the <b>LookupOp</b> 
	<a name="Listing_9">class</a>.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    BufferedImageOp thresholdOp = 
                            new LookupOp(lookupTable,null);<br><br><b><font face="Courier New,Courier"><a href="#Listing_9">Listing 9</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The first parameter to the <b>LookupOp</b> constructor is a reference to the
<b>ShortLookupTable</b> object.&nbsp; The second parameter, <i>(which may 
optionally be passed as null)</i>, is a reference to a <b>RenderingHints</b> 
object.</p>
<blockquote>
	<p><i>(A <b>RenderingHints</b> object can be used to specify some of the 
	fine details as to how the image is actually drawn on the final viewing 
	surface.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Apply the filter to the image</b></font></p>
<p><a href="#Listing_10">Listing 10</a> invokes the <b>filter</b> method belonging to the <b>LookupOp</b> 
object to apply the filter to the incoming image.&nbsp; It returns a reference to the resulting
<b>BufferedImage</b> object that contains the modified <a name="Listing_10">image</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
    return thresholdOp.filter(theImage, null);
  }//end processImg<br><br><b><font face="Courier New,Courier"><a href="#Listing_10">Listing 10</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>filter</b> method performs the table lookup operation and returns a 
reference to the modified image as type <b>BufferedImage</b>.&nbsp; The second 
parameter, <i>(which can optionally be passed as null)</i>, makes it possible to also 
cause the modified image to be written into an existing <b>BufferedImage</b> 
destination object.</p>
<p><a href="#Listing_10">Listing 10</a> also signals the end of the <b>processImg</b> method.</p>
<p><font color="#FF0000"><b>Steps in processing an image</b></font></p>
<p>When using one of the image-filtering classes of the Java 2D API to directly 
modify an image stored in a <b>BufferedImage</b> object, the typical steps are:</p>
<ul>
	<li>Create any necessary data and objects required to support the process, 
	as in <a href="#Listing_7">Listing 7</a> and <a href="#Listing_8">Listing 8</a>.</li>
	<li>Create the filter object as in <a href="#Listing_9">Listing 9</a>.</li>
	<li>Apply the filter object as in <a href="#Listing_10">Listing 10</a>.</li>
</ul>
<blockquote>
	<p><i>(If you elect to decompose the image and process individual <b>Raster</b> 
	objects, additional steps are required. The <b>BandCombineOp</b> filter can 
	operate only on <b>Raster</b> objects, but the other image-filtering classes 
	can operate either on <b>BufferedImage</b> objects or <b>Raster</b> 
	objects.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Write the modified image into a JPEG file</b></font></p>
<p>Returning to the constructor in <a href="#Listing_3">Listing 3</a>, you can see that the constructor 
invokes the method named <b>writeJpegFile</b> to cause the modified image to be 
written into an output file named <b>junk.jpg </b>in the current directory.</p>
<p>The method named <b>writeJpegFile</b> is shown in its entirety in 
<a name="Listing_11"><a href="#Listing_11">Listing 11</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void writeJpegFile(BufferedImage img){
    try{
      //Get a file output stream.
      FileOutputStream outStream = 
                          new FileOutputStream("junk.jpg");
      //Call the write method of the ImageIO class to write
      // the contents of the BufferedImage object to an
      // output file in JPEG format.
      ImageIO.write(img,"jpeg",outStream);
      outStream.close();
    }catch (Exception e) {
      e.printStackTrace();
    }//end catch
  }//end writeJpegFile<br><br><b><font face="Courier New,Courier"><a href="#Listing_11">Listing 11</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>There is very little that is new here</b></font></p>
<p>There is very little, if anything, that is new in <a href="#Listing_11">Listing 11</a>.&nbsp; I have 
been publishing and using methods similar to this one to write JPEG output files since the 
earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3640776">Processing Image Pixels, An Improved 
Image-Processing Framework in Java</a>.&nbsp; The embedded comments in the method, 
along with the Sun documentation of the classes and methods involved, should 
suffice to explain the method and no further explanation should be required.</p>
<p><a href="#Listing_11">Listing 11</a> also signals the end of the explanation of the program named <b>
ImgMod05a</b>.</p>
<h3><a name="The_program_named_ImgMod05">The program named <i>ImgMod05</i></a></h3>
<p>This program is an update of the earlier program named <b>ImgMod04a</b>.</p>
<blockquote>
	<p><i>(The class named <b>ImgMod04a</b> was first published in the earlier 
	lesson entitled 
	<a href="http://www.developer.com/java/other/article.php/3640776">Processing Image Pixels, An Improved Image-Processing 
	Framework in Java</a></i>.<i>)</i></p>
</blockquote>
<p>This program is designed to accommodate the use of the image-filtering 
classes of the Java 2D API.&nbsp; </p>
<p><font color="#FF0000"><b>Sends and receives a BufferedImage object</b></font></p>
<p>This program sends and receives a <b>BufferedImage</b> object to an 
image-processing method of a compatible image-processing object instead of sending and 
receiving an array of pixel data as is the case for the program named <b>
ImgMod04a</b>.</p>
<p><font color="#FF0000"><b>Purpose</b></font></p>
<p>The purpose of this program is to make it easy to experiment with the 
modification of image data using the image-filtering classes of the Java 2D API 
and to display the modified version of the image along with the original image.&nbsp;
</p>
<p>In addition to the graphic display of the modified image, the program also writes the modified image into an output file in JPEG 
format.&nbsp; The name of the output file is <b>junk.jpg</b> and it is written into the 
current directory.</p>
<p><font color="#FF0000"><b>The Replot button</b></font></p>
<p>The program GUI contains a <b>Replot</b> button.&nbsp; At the beginning of 
the run, and each time thereafter that the <b>Replot</b> button is clicked:</p>
<ul>
	<li>The image-processing method belonging to the image-processing object is 
	invoked.</li>
	<li>The original image is passed to the image-processing method, which 
	returns a reference to a modified image.</li>
	<li>The resulting modified image is displayed along with the original image.</li>
	<li>The modified image is written into an output JPEG file named <b>junk.jpg</b>.</li>
</ul>
<p>The <b>Replot</b> button is located at the top of the display to make it 
accessible when the display is too tall to fit on the screen.</p>
<blockquote>
	<p><i>(For purposes of seeing the entire display in that case, it can be 
	moved up and down on the screen using the right mouse button and the up and 
	down arrow keys.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Input and output file format</b></font></p>
<p>The program will read gif and jpg input files and possibly some other input 
file types as well.&nbsp; The output file is always a JPEG file.</p>
<p><font color="#FF0000"><b>A framework program</b></font></p>
<p>This program provides a framework that is designed to invoke another program 
to process an input image.&nbsp; The program reads the image from the input file 
and converts it to type <b>BufferedImage</b>.&nbsp; A second program is invoked 
to actually process the image.</p>
<p>Typically the image-processing program is based on the image-filtering 
classes of the Java 2D API, but that is not a requirement.&nbsp; The only 
requirement is that the image-processing program be capable of receiving the 
image as type <b>BufferedImage</b> and returning the processed image as type <b>
BufferedImage</b>.&nbsp; </p>
<p><font color="#FF0000"><b>Typical usage</b></font></p>
<p>Enter the following at the command-line to run the program:</p>
<p><pre><b>java ImgMod05 ProcessingProgramName ImageFileName</b></pre></p>
<p><font color="#FF0000"><b>A self-contained test program</b></font></p>
<p>For test and illustration purposes, the source code includes a class 
definition for a sample image-processing program named <b>ProgramTest</b>.&nbsp; If the 
command-line parameters are omitted, the program will search for an image file 
named <b>ImgMod05Test.jpg</b> in the current directory and will process it using 
the sample image-processing program named <b>ProgramTest</b>.</p>
<p>The sample program 
named <b>ProgramTest</b> returns a reference to a <b>BufferedImage</b> object in which the colors in the 
modified image are inverted relative to the colors in the original image.</p>
<p><font color="#FF0000"><b>The input image file</b></font></p>
<p>The input image file must be provided by the user in all cases.&nbsp; However, it 
doesn't have to be in the current directory if a path to the file is specified 
along with the file name on the command line.</p>
<p><font color="#FF0000"><b>Display of the images</b></font></p>
<p>When the program is started, the original image and 
the processed version of the image are displayed in a frame with the original 
image above the processed image.&nbsp; The program attempts to set the size of 
the display so as to accommodate both images.&nbsp; If both images are not 
totally visible, the user can manually resize the display frame.</p>
<p><font color="#FF0000"><b>The Replot button</b></font></p>
<p>A <b>Replot</b> 
button appears at the top of the frame.&nbsp; The behavior of the <b>Replot</b> button 
is as described above causing a newly processed version of the original image to 
replace the earlier processed version in the display.</p>
<p><font color="#FF0000"><b>User data input</b></font></p>
<p>The processing 
program may provide a GUI for data input making it possible for the user to 
modify the behavior of the image-processing method each time the <b>Replot</b> button 
is clicked.&nbsp; <i>(The sample image-processing program that is built into 
this program does not provide that capability.)</i></p>
<p><font color="#FF0000"><b>The interface named ImgIntfc05</b></font></p>
<p>The image-processing program must implement the interface named 
<b>ImgIntfc05</b>.&nbsp; That interface declares a single image-processing method with the 
following signature:</p>
<p><pre><b>public BufferedImage processImg(BufferedImage input);</b></pre></p>
<p>The 
processing method receives a reference to a <b>BufferedImage</b> object containing the 
image that is to be processed.&nbsp; The image-processing method must return a reference 
to a <b>BufferedImage</b> object containing the processed image.</p>
<p>A complete listing of the interface named <b>ImgIntfc05</b> is provided in 
<a href="#Listing_31">Listing 31</a>.</p>
<p><font color="#FF0000"><b>Miscellaneous items</b></font></p>
<p>If the image-processing program has a <b>main</b> method, it will be ignored.&nbsp; </p>
<p>If the program 
is unable to load the image file within ten seconds, it will abort with an error 
message.</p>
<p>This program was tested using J2SE5.0 under WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will discuss this program in fragments.&nbsp; A complete listing of the 
program is provided in <a href="#Listing_30">Listing 30</a>.</p>
<p>The program begins in <a href="#Listing_12">Listing 12</a> by declaring a pair of <b>BufferedImage</b> 
variables, just like in the program named <b>ImgMod05a</b>, shown 
<a name="Listing_12">in</a> <a href="#Listing_1">Listing 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod05 extends Frame{
  BufferedImage rawBufferedImage;
  BufferedImage processedImage;<br><br><b><font face="Courier New,Courier"><a href="#Listing_12">Listing 12</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Frame insets</b></font></p>
<p><a href="#Listing_13">Listing 13</a> declares a <b>Frame</b> object that is used to create the display 
shown <a name="Listing_13">in</a> <a href="#Figure_1">Figure 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  Frame displayFrame;//Frame to display the images.
  int inLeft;//left inset
  int inTop;//top inset
  int inBottom;//bottom inset
  int buttonHeight;//Height of Replot button<br><br><b><font face="Courier New,Courier"><a href="#Listing_13">Listing 13</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_13">Listing 13</a> also declares four <b>int</b> variables that will contain the <b>
Frame</b> insets, which are used later to construct the display shown in
<a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>Self-contained test program and default image file</b></font></p>
<p><a href="#Listing_14">Listing 14</a> declares a <b>String</b> variable and initializes it with the name 
of the self-contained image-processing program.&nbsp; <a href="#Listing_14">Listing 14</a> also declares a
<b>String</b> variable and initializes it with the name of the default image 
<a name="Listing_14">file</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  static String theProcessingClass = "ProgramTest";

  static String theImgFile = "ImgMod05Test.jpg";<br><br><b><font face="Courier New,Courier"><a href="#Listing_14">Listing 14</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The class identified by the string in <a href="#Listing_14">Listing 14</a> is executed to process the 
image file identified in <a href="#Listing_14">Listing 14</a> if the user fails to enter a pair of 
command-line parameters.&nbsp; You must provide this file in the current 
directory if it will be needed.</p>
<blockquote>
	<p><i>(You should be able to use any JPEG file for this purpose, provided 
	you assign the correct file name to it.)</i></p>
</blockquote>
<p>The source code for the class identified by the string in <a href="#Listing_14">Listing 14</a> is 
included later in this source code file.</p>
<p><font color="#FF0000"><b>Miscellaneous instance variables</b></font></p>
<p><a href="#Listing_15">Listing 15</a> declares four additional instance variables, the purpose of which 
should become obvious as you study the code that <a name="Listing_15">follows</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  MediaTracker tracker;
  Display display = new Display();//A Canvas object
  Button replotButton = new Button("Replot");

  //Reference to the image-processing object.
  ImgIntfc05 imageProcessingObject;<br><br><b><font face="Courier New,Courier"><a href="#Listing_15">Listing 15</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The <b>main</b> method is shown in its entirety in <a name="Listing_16"><a href="#Listing_16">Listing 16</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    //Get names for the image-processing class and the
    // image file to be processed.  Program reads gif
    // files and jpg files and possibly some other file
    // types as well.
    if(args.length == 0){
      //Use default processing class and default image
      // file.  Class and file names were specified above.
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and image file.
    System.out.println(
              "Processing program: " + theProcessingClass);
    System.out.println("Image file: " + theImgFile);

    //Instantiate an object of this class.
    ImgMod05 obj = new ImgMod05();
  }//end main<br><br><b><font face="Courier New,Courier"><a href="#Listing_16">Listing 16</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Most of the code in <a href="#Listing_16">Listing 16</a> is used to get the name of the 
image-processing class and the name of the image file to be processed.</p>
<p>Finally, the code in the <b>main</b> method in <a href="#Listing_16">Listing 16</a> invokes the 
constructor to construct an object of the <b>ImgMod05</b> class.</p>
<p>All the code in <a href="#Listing_16">Listing 16</a> is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>The constructor for the ImgMod05 class</b></font></p>
<p>The constructor begins in <a href="#Listing_17">Listing 17</a> by invoking the method named <b>
getTheImage</b> to get the image from the input file and to store it in an object 
of type <b><a name="Listing_17">BufferedImage</a></b>.&nbsp; </p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  public ImgMod05(){//constructor
    //Get an image from the specified image file.  Can be
    // in a different directory if the path was entered
    // with the file name on the  command line.
    rawBufferedImage = <b>getTheImage()</b>;<br><br><b><font face="Courier New,Courier"><a href="#Listing_17">Listing 17</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>getTheImage</b> used in this program is essentially the 
same as the method having the same name that was explained in <a href="#Listing_4">Listing 4</a>, Listing 
5, and <a href="#Listing_6">Listing 6</a>.&nbsp; Therefore, it should not be necessary to repeat that 
explanation.</p>
<p>You can view a complete listing of the method named <b>getTheImage</b> in 
<a href="#Listing_30">Listing 30</a> near the end of the lesson.</p>
<p><font color="#FF0000"><b>Construct the display object</b></font></p>
<p><a href="#Listing_18">Listing 18</a> contains code typical of that commonly used to construct an object 
of type <b>Frame</b> and to add a <b>Canvas</b> object and a <b>Button</b> 
object to the <a name="Listing_18">frame</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Construct the display object.
    this.setTitle("Copyright 2006, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.NORTH);
    
    //Make the frame visible to make it possible to
    // get insets and the height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and the height
    // of the button.
    inTop = this.getInsets().top;
    inLeft = this.getInsets().left;
    inBottom = this.getInsets().bottom;
    buttonHeight = replotButton.getSize().height;
    
    //Save a reference to this Frame object for use in
    // setting the size of the Frame later.
    displayFrame = this;<br><br><b><font face="Courier New,Courier"><a href="#Listing_18">Listing 18</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_18">Listing 18</a> along with the embedded comments should be self-explanatory 
and shouldn't require further explanation.</p>
<p><font color="#FF0000"><b>An ActionListener on the Replot button</b></font></p>
<p>Continuing with the constructor, <a href="#Listing_19">Listing 19</a> contains the beginning of an 
anonymous inner class listener for the <b>Replot</b> button.&nbsp; This <b>
actionPerformed</b> method is invoked when the user clicks the <b>Replot</b> 
button.&nbsp; It is also invoked at startup when this program posts an <b>
ActionEvent</b> to the system event queue attributing the event to the <b>Replot</b> 
<a name="Listing_19">button</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    replotButton.addActionListener(
      new ActionListener(){
        public void <b>actionPerformed</b>(ActionEvent e){
          //Process the image.
          System.out.println("\nProcess the image");
          processedImage = 
                          imageProcessingObject.processImg(
                                         rawBufferedImage);
          System.out.println("Image processed");<br><br><b><font face="Courier New,Courier"><a href="#Listing_19">Listing 19</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_19">Listing 19</a> invokes the <b>processImg</b> method of the image-processing 
object, passing the <b>BufferedImage</b> object containing the original image to 
that method.&nbsp; The <b>processImg</b> method returns a reference to a <b>BufferedImage</b> 
object containing the modified image.&nbsp; The reference to the modified image is stored 
by the constructor in the variable 
named <b>processedImage</b>.</p>
<p><font color="#FF0000"><b>Adjust the size of the display</b></font> </p>
<p>The processed image may be larger than the original image.&nbsp; Therefore, 
the code in <a href="#Listing_20">Listing 20</a> attempts to set the display size to accommodate the raw 
and processed images.&nbsp; In the event that the processed image won't fit in 
the display frame after the size adjustment is made by the code in <a href="#Listing_20">Listing 20</a>, 
the user can manually resize the <a name="Listing_20">frame</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          int maxWidth = 0;
          //Get max image width.
          if(processedImage.getWidth() > 
                              rawBufferedImage.getWidth()){
            maxWidth = processedImage.getWidth();
          }else{
            maxWidth = rawBufferedImage.getWidth();
          }//end else
          int totalWidth = 2*inLeft + maxWidth + 2;

          //Get height of two images.
          int height = rawBufferedImage.getHeight() 
                              + processedImage.getHeight();
          int totalHeight = 
              inTop + inBottom + buttonHeight + height + 4;
          displayFrame.setSize(totalWidth,totalHeight);<br><br><b><font face="Courier New,Courier"><a href="#Listing_20">Listing 20</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><a href="#Listing_20">Listing 20</a> sets the size of the display such that for non-rotated images, a 
tiny amount of the background color shows between the two images, to the right 
of the larger image, and below the bottom image as shown in <a href="#Figure_1">
Figure 1</a>.</p>
<p><font color="#FF0000"><b>Validate and repaint the display</b></font></p>
<p>Occasionally, <i>(on an intermittent basis)</i>, without the addition of the first 
statement in <a href="#Listing_21">Listing 21</a>, even though the <b>repaint</b> method is called, the 
operating system doesn't make a call to the overridden <b>paint</b> method.&nbsp; 
As a result, the original and processed images don't appear in the display frame 
and the program appears to be hung up in an indeterminate <a name="Listing_21">state</a>.</p>
<p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          displayFrame.validate();

          System.out.println("Call repaint");
          //Repaint the image display frame with the
          // original image at the top and the modified
          // image at the bottom.
          display.repaint();
          System.out.println("Repaint call complete");<br><br><b><font face="Courier New,Courier"><a href="#Listing_21">Listing 21</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Why validate?</b></font></p>
<p>The Sun documentation for the <b>Container</b> class states</p>
<blockquote>
	<p><i>&quot;If a component has been added to a container that has been displayed, 
	<b>validate</b> must be called on that container to display the new component.&quot;</i>
	</p>
</blockquote>
<p>Apparently the same thing holds true when the size of the container is 
changed.&nbsp; Inclusion of the first statement in <a href="#Listing_21">Listing 21</a> seems to fix the 
intermittent problem.</p>
<p><a href="#Listing_21">Listing 21</a> also invokes the <b>repaint</b> method, asking the operating 
system to call the overridden <b>paint</b> method to repaint the display.</p>
<p><font color="#FF0000"><b>Write the output image file</b></font></p>
<p><a href="#Listing_22">Listing 22</a> invokes the method named <b>writeJpegFile</b> to cause the 
modified image to be written into an output JPEG file named <b>junk.<a name="Listing_22">jpg</a></b>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>          System.out.println("Call writeJpegFile");
          <b>writeJpegFile</b>(processedImage);
          System.out.println(
                            "writeJpegFile call complete");
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class registered on the Replot
    // button.<br><br><b><font face="Courier New,Courier"><a href="#Listing_22">Listing 22</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is essentially the same <b>writeJpegFile</b> method that was explained 
in <a href="#Listing_11">Listing 11</a>.&nbsp; Therefore I won't repeat that explanation.&nbsp; You can 
view the method named <b>writeJpegFile</b> in <a href="#Listing_30">Listing 30</a>.</p>
<p><a href="#Listing_22">Listing 22</a> also signals the end of the definition of the anonymous <b>
ActionListener</b> class and the registration of an object of that class on the
<b>Replot</b> button.</p>
<p><font color="#FF0000"><b>Instantiate an image-processing object</b></font></p>
<p>Continuing with the constructor, <a href="#Listing_23">Listing 23</a> instantiates a new object of the 
image-processing <a name="Listing_23">class</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{
      imageProcessingObject = (ImgIntfc05)Class.forName(
                         theProcessingClass).newInstance();<br><br><b><font face="Courier New,Courier"><a href="#Listing_23">Listing 23</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that this object is instantiated using the <b>newInstance</b> method of 
the class named <b>Class</b>.&nbsp; This approach does not allow for the use of 
a parameterized constructor for the image-processing class.</p>
<p><font color="#FF0000"><b>Post a counterfeit ActionEvent</b></font></p>
<p><a href="#Listing_24">Listing 24</a> posts a counterfeit <b>ActionEvent</b> to the system event queue 
and attributes it to the <b>Replot</b> button.</p>
<blockquote>
	<p><i>(See the anonymous ActionListener class that registers an 
	ActionListener object on the <b>Replot</b> button above.)</i></p>
</blockquote>
<p>Posting this event causes the image-processing method to be invoked and 
causes the modified image to be displayed at <a name="Listing_24">startup</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      Toolkit.getDefaultToolkit().getSystemEventQueue().
        postEvent(
          new ActionEvent(replotButton,
                          ActionEvent.ACTION_PERFORMED,
                          "Replot")
        );//end postEvent method

    }catch(Exception e){
      e.printStackTrace();
      System.exit(1);
    }//end catch<br><br><b><font face="Courier New,Courier"><a href="#Listing_24">Listing 24</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>From this point forward ...</b></font></p>
<p>At this point, the image has been processed and the original image along with 
the modified image has been displayed.</p>
<p>From this point forward, each time the user clicks the <b>Replot</b> button:</p>
<ul>
	<li>A new image-processing object will be instantiated.</li>
	<li>The original image will be processed again.</li>
	<li>The new modified image will be displayed along with the original image.</li>
	<li>The modified image will be written into an output JPEG file.</li>
</ul>
<p><font color="#FF0000"><b>Make everything visible</b></font></p>
<p>Still in the constructor, <a href="#Listing_25">Listing 25</a> causes the composite of the frame, the canvas, and the button 
shown in <a href="#Figure_1">Figure 1</a> to become <a name="Listing_25">visible</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.setVisible(true);<br><br><b><font face="Courier New,Courier"><a href="#Listing_25">Listing 25</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Define and register an anonymous terminator class</b></font></p>
<p>Wrapping up the constructor, <a href="#Listing_26">Listing 26</a> defines and registers a <b>
WindowListener</b> object that causes the program to terminate when the user 
clicks the button with the X in the upper right corner of the 
<a name="Listing_26">frame</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //===================================================//

  }//end ImgMod05 constructor
  //=====================================================//<br><br><b><font face="Courier New,Courier"><a href="#Listing_26">Listing 26</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Define the Display class</b></font></p>
<p><a href="#Listing_27">Listing 27</a> defines the inner <b>Display</b> class.&nbsp; This class is used to 
instantiate a <b>Canvas</b> object on which the original and modified images are 
<a name="Listing_27">displayed</a>.</p><p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  //Inner class for canvas object on which to display the
  // two images.
  class Display extends Canvas{
    //Override the paint method to display the raw image
    // and the modified image on the same Canvas object,
    // separated by a couple of rows of pixels in the
    // background color.
    public void paint(Graphics g){
      //First confirm that the image has been completely
      // loaded and that none of the image references are
      // null.
      if (tracker.statusID(1,false) ==
                                    MediaTracker.COMPLETE){
        if((rawBufferedImage != null) && 
           (processedImage != null)){
          //Draw raw image at the top.  Terminate if the
          // the pixels are changing.
          boolean success = false;
          success = g.drawImage(rawBufferedImage,0,0,this);
          if(!success){
            System.out.println("Unable to draw top image");
            System.exit(1);
          }//end if
          //Draw processed image at the bottom.
          success = g.drawImage(processedImage,0,
                    rawBufferedImage.getHeight() + 2,this);
          if(!success){
            System.out.println(
                            "Unable to draw bottom image");
            System.exit(1);
          }//end if
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas<br><br><b><font face="Courier New,Courier"><a href="#Listing_27">Listing 27</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in <a href="#Listing_27">Listing 27</a> is very similar to the code that I explained for the 
class having the same name in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; Therefore, I won't repeat 
that explanation here.</p>
<p><font color="#FF0000"><b>The ProgramTest class</b></font></p>
<p>The purpose of this class is to provide a simple example of an 
image-processing class that is compatible with the use of the program named <b>
ImgMod05</b>.&nbsp; The beginning of the <b>ProgramTest</b> class is shown in 
<a name="Listing_28"><a href="#Listing_28">Listing 28</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ProgramTest implements ImgIntfc05{

  //The following method must be defined to implement the
  // ImgIntfc05 interface.
  //The following method must be defined to implement the
  // ImgIntfc05 interface.
  public BufferedImage <b>processImg</b>(BufferedImage theImage){

    //Use the LookupOp class from the Java 2D API to
    // invert all of the color values in the pixels.  The
    // alpha value is not modified.

    //Create the data for the lookup table.
    short[] lookupData = new short[256];
    for (int cnt = 0; cnt &lt; 256; cnt++){
      lookupData[cnt] = (short)(255-cnt);
    }//end for loop
    
    //Create the lookup table
    ShortLookupTable lookupTable = 
                        new ShortLookupTable(0,lookupData);

    //Create the filter object.
    BufferedImageOp thresholdOp = 
                            new LookupOp(lookupTable,null);

    //Apply the filter to the incoming image and return
    // a reference to the resulting BufferedImage object.
    return thresholdOp.filter(theImage, null);
  }//end processImg
}//end class ProgramTest<br><br><b><font face="Courier New,Courier"><a href="#Listing_28">Listing 28</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Must implement ImgIntfc05</b></font></p>
<p>A compatible class is required to implement the interface named <b>ImgIntfc05</b>.&nbsp; 
This, in turn, requires the class to define the method named <b>processImg</b>, 
which receives one parameter of type <b>BufferedImage</b> and returns a 
reference of type <b>BufferedImage</b>.</p>
<p><font color="#FF0000"><b>A color-inverter program</b></font></p>
<p>The method named <b>processImg</b> in this sample program is a color inverter 
method.</p>
<p>The method receives an 
incoming reference to an image as a parameter of type <b>BufferedImage</b>.&nbsp; 
The method returns a reference to an image as type <b>BufferedImage</b> where 
all of the color values in the pixels have been inverted by subtracting the 
color values from 255.&nbsp; The alpha values are not modified.</p>
<p><font color="#FF0000"><b>The type of image is important</b></font></p>
<p>The method has been demonstrated to work properly only for the case where the 
incoming <b>BufferedImage</b> object was constructed for image type <b>
BufferedImage.TYPE_INT_RGB</b>.&nbsp; However, it may work properly for other 
image types as well.</p>
<p><font color="#FF0000"><b>No parameterized constructor is allowed</b></font></p>
<p>Note that this class does not define a constructor.&nbsp; However, if it did 
define a constructor, that constructor would not be allowed to receive 
parameters.&nbsp; This is because the class named <b>ImgMod05</b> instantiates 
an object of this class by invoking the <b>newInstance</b> method of the <b>
Class</b> class on the basis of the name of this class<b> as a Strin</b>g.&nbsp; 
That process does not allow for constructor parameters for the class being 
instantiated.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The <b>ProgramTest</b> class in <a href="#Listing_28">Listing 28</a> consists of the single method 
named <b>processImg</b>.&nbsp; The <b>processImg</b> method is essentially the 
same as the method having the same name that I explained in conjunction with 
<a href="#Listing_7">Listing 7</a> through <a href="#Listing_10">Listing 10</a>.&nbsp; Therefore, I won't repeat that explanation 
here.</p>
<p><a href="#Listing_28">Listing 28</a> also signals the end of the explanation of the program named <b>
ImgMod05</b>.<br>
</p>
<center>
<h2><a name="Run the program">Run the Programs</a></h2>
</center>
<p>I encourage you to copy the code from <a href="#Listing_29">Listing 29</a>, <a href="#Listing_30">Listing 30</a>, and <a href="#Listing_31">Listing 31</a> into your text
editor, compile and execute the code.</p>
<p>Make changes to the code and experiment with it.&nbsp; Above all, enjoy 
learning new things about object-oriented image processing using Java.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you a little about the image-filtering classes of 
the Java 2D API.&nbsp; I also showed you how to write a framework program that makes 
it easy to use those image-filtering classes to modify the pixels in an image 
and to display the modified image.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons will teach you more about the <b>LookupOp</b> class of the Java 2D 
API, and will also teach you how to use the following image-filtering classes 
from that API:</p>
<ul>
	<li><b>AffineTransformOp</b> class</li>
	<li><b>BandCombineOp</b> class</li>
	<li><b>ConvolveOp</b> class</li>
	<li><b>RescaleOp</b> class</li>
	<li><b>ColorConvertOp</b> class</li>
</ul>
<h2 align="center"><a name="References">References</a></h2>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3403921">400</a> 
	Processing Image Pixels using Java, Getting Started</li>
	<li><a href="http://www.developer.com/java/other/article.php/3423661">402</a> 
	Processing Image Pixels using Java, Creating a Spotlight</li>
	<li><a href="http://www.developer.com/java/other/article.php/3441391">404</a> 
	Processing Image Pixels Using Java: Controlling Contrast and Brightness</li>
	<li><a href="http://www.developer.com/java/other/article.php/3512456">406</a> 
	Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion</li>
	<li><a href="http://www.developer.com/java/other/article.php/3522711">408</a> 
	Processing Image Pixels, Performing Convolution on Images</li>
	<li><a href="http://www.developer.com/java/other/article.php/3579206">410</a> 
	Processing Image Pixels, Understanding Image Convolution in Java</li>
	<li><a href="http://www.developer.com/java/ent/article.php/3590351">412</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 1</li>
	<li><a href="http://www.developer.com/java/other/article.php/3596351">414</a> 
	Processing Image Pixels, Applying Image Convolution in Java, Part 2</li>
	<li><a href="http://www.developer.com/java/other/article.php/3640776">416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java</li>
</ul>
<center>
<h2> <a name="Complete Program Listings">Complete Program Listings</a></h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
29, <a href="#Listing_30">Listing 30</a>, and <a href="#Listing_31">Listing 31</a> <a name="Listing_29">below</a>. <br>
&nbsp;
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod05a.java
Copyright 2006, R.G.Baldwin

The purpose of this program is to show how to read, modify,
and write an image file using Java2D image-processing
operations.  The program was simplified as much as 
practical.

Tested using J2SE5.0 under WinXP.
**********************************************************/

import java.awt.*;
import java.io.*;
import javax.imageio.*;
import java.awt.image.*;

class ImgMod05a{
  BufferedImage rawBufferedImage;
  BufferedImage processedImage;
  static String theImgFile = "ImgMod05Test.jpg";
  MediaTracker tracker;

  //-----------------------------------------------------//

  public static void main(String[] args){
    //Instantiate an object of this class.
    ImgMod05a obj = new ImgMod05a();
  }//end main
  //-------------------------------------------//

  public ImgMod05a(){//constructor
    //Get an image from the specified image file.
    rawBufferedImage = getTheImage();

    //Process the image.
    processedImage = processImg(rawBufferedImage);
    
    //Write the modified image into a JPEG file named
    // junk.jpg.
    writeJpegFile(processedImage);

  }//end ImgMod05a constructor
  //=====================================================//

  public BufferedImage processImg(BufferedImage theImage){

    //Use the LookupOp class from the Java 2D API to
    // invert all of the color values in the pixels.  The
    // alpha value is not modified.

    //Create the data for the lookup table.
    short[] lookupData = new short[256];
    for (int cnt = 0; cnt &lt; 256; cnt++){
      lookupData[cnt] = (short)(255-cnt);
    }//end for loop
    
    //Create the lookup table
    ShortLookupTable lookupTable = 
                        new ShortLookupTable(0,lookupData);

    //Create the filter object.
    BufferedImageOp thresholdOp = 
                            new LookupOp(lookupTable,null);

    //Apply the filter to the incoming image and return
    // a reference to the resulting BufferedImage object.
    return thresholdOp.filter(theImage, null);
  }//end processImg
  //=====================================================//

  //Write the contents of a BufferedImage object to a JPEG
  // file named junk.jpg.
  void writeJpegFile(BufferedImage img){
    try{
      //Get a file output stream.
      FileOutputStream outStream = 
                          new FileOutputStream("junk.jpg");
      //Call the write method of the ImageIO class to write
      // the contents of the BufferedImage object to an
      // output file in JPEG format.
      ImageIO.write(img,"jpeg",outStream);
      outStream.close();
    }catch (Exception e) {
      e.printStackTrace();
    }//end catch
  }//end writeJpegFile
  //-----------------------------------------------------//
  
  //This method reads an image from a specified image file,
  // writes it into a BufferedImage object, and returns a
  // reference to the BufferedImage object.
  //The name of the image file is contained in an instance
  // variable of type String named theImgFile.
  BufferedImage getTheImage(){
    Image rawImage = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.  Terminate and
    // display an error message if ten seconds elapse
    // without the image having been loaded.  Note that the
    // constructor for the MediaTracker requires the
    // specification of a Component "on which the images
    // will eventually be drawn" even if there is no
    // intention for the program to actually display the 
    // image.  It is useful to have a media tracker with a
    // timeout even if the image won't be drawn by the
    // program.  Also, the media tracker is needed to delay
    // execution until the image is fully loaded.
    tracker = new MediaTracker(new Frame());
    tracker.addImage(rawImage,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Timeout or Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if

    //Create an empty BufferedImage object.  Note that the
    // specified image type is critical to the correct
    // operation of the image-processing method. The method
    // may work correctly for other image types, but has
    // been <span lang="en-us"></span>tested only for TYPE_INT_RGB.  The
    // parameters to the getWidth and getHeight methods are
    // references to ImageObserver objects, or references
    // to "an object waiting for the image to be loaded."

    BufferedImage buffImage = new BufferedImage(
                              rawImage.getWidth(null),
                              rawImage.getHeight(null),
                              BufferedImage.TYPE_INT_RGB);

    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImage, 0, 0, null);

    return buffImage;
  }//end getTheImage
  //-----------------------------------------------------//
}//end ImgMod05a.java class
//=======================================================//<br><br><b><font face="Courier New,Courier"><a href="#Listing_29">Listing 29</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_30"><a href="#Listing_30">Listing 30</a></a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgMod05.java
Copyright 2006, R.G.Baldwin

This is an update of the class named ImgMod04a designed to
accommodate the use of the image-processing operations of 
the Java 2D API.  When this class is run as a program, it 
sends and receives a BufferedImage object to an image 
processing method of a compatible image-processing object 
instead of sending and receiving an array of pixel data as 
is the case in the class named ImgMod04a.

The purpose of this program is to make it easy to 
experiment with the modification of image data using the 
image-processing operations of the Java 2D API and to 
display a modified version of the image along with the 
original image.

This program also writes the modified image into an output 
file in JPEG format.  The name of the output file is 
junk.jpg and it is written into the current directory.

The output GUI contains a Replot button.  At the beginning 
of the run, and each time thereafter that the Replot 
button is clicked:
-The image-processing method belonging to the image 
 processing object is invoked,
-The resulting modified image is displayed along with the 
 original image.

The Replot button is located at the top of the display to
make it accessible when the display is too tall to fit
on the screen.  (For purposes of seeing the entire 
display in that case, it can be moved up and down on the
screen using the right mouse button and the up and down
arrow keys.)

The program will read gif and jpg input files and possibly 
some other input file types as well.  The output file is 
always a JPEG file.

This program provides a framework that is designed to 
invoke another program to process an input image.  This 
program reads the image from the input file and converts it
to type BufferedImage.  A second program is invoked to 
actually process the image.

Typically the image-processing program is based on the 
image-processing operations of the Java 2D API, but that is
not a requirement.  The only requirement is that the image 
processing program be capable of receiving the image as 
type BufferedImage and returning the processed image as 
type BufferedImage.

Typical usage is as follows:

java ImgMod05 ProcessingProgramName ImageFileName

For test and illustration purposes, the source code 
includes a class definition for a sample image-processing 
program named ProgramTest.

If the command-line parameters are omitted, the program 
will search for an image file in the current directory 
named ImgMod05Test.jpg and will process it using the sample
image-processing program named ProgramTest.  The sample 
program returns a reference to a BufferedImage object in 
which the colors in the modified image are inverted 
relative to the colors in the original image.

The image file must be provided by the user in all cases.
However, it doesn't have to be in the current directory if
a path to the file is specified on the command line.

When the program is started, the original image and the
processed version of the image are displayed in a frame
with the original image above the processed image.  The 
program attempts to set the size of the display so as to 
accommodate both images.  If both images are not totally
visible, the user can manually resize the display frame.

A Replot button appears at the top of the frame.  The 
behavior of the Replot button is as described above
causing a newly processed version of the original image to 
replace the earlier processed version in the display.

The processing program may provide a  GUI for data input 
making it possible for the user to modify the behavior of 
the image-processing method each time the Replot button is 
clicked.  (The sample image-processing program does not
provide that capability.)

The image-processing program must implement the 
interface named ImgIntfc05.  That interface declares an
image-processing method with the following signature:

public BufferedImage processImg(BufferedImage input);

The processing method receives a reference to a 
BufferedImage object containing the image that is to be
processed

The image-processing method must return a reference to a
BufferedImage object containing the processed image.

If the image-processing program has a main method, it will
be ignored.

If the program is unable to load the image file within ten
seconds, it will abort with an error message.

Tested using J2SE5.0 under WinXP.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.imageio.*;
import java.awt.image.*;

class ImgMod05 extends Frame{
  BufferedImage rawBufferedImage;
  BufferedImage processedImage;
  
  Frame displayFrame;//Frame to display the images.
  int inLeft;//left inset
  int inTop;//top inset
  int inBottom;//bottom inset
  int buttonHeight;//Height of Replot button

  //This is the name of the default image-processing
  // program.  This class will be executed to process the
  // image if there aren't two command-line parameters. 
  // The source code for this class file is included in
  // this source code file.
  static String theProcessingClass = "ProgramTest";

  //This is the name of the default image file.  This image
  // file will be processed if there aren't two command-
  // line parameters.  You must provide this file in the
  // current directory if it will be needed.
  static String theImgFile = "ImgMod05Test.jpg";

  MediaTracker tracker;
  Display display = new Display();//A Canvas object
  Button replotButton = new Button("Replot");

  //Reference to the image-processing object.
  ImgIntfc05 imageProcessingObject;
  //-----------------------------------------------------//

  public static void main(String[] args){
    //Get names for the image-processing class and the
    // image file to be processed.  Program reads gif
    // files and jpg files and possibly some other file
    // types as well.
    if(args.length == 0){
      //Use default processing class and default image
      // file.  Class and file names were specified above.
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and image file.
    System.out.println(
              "Processing program: " + theProcessingClass);
    System.out.println("Image file: " + theImgFile);

    //Instantiate an object of this class.
    ImgMod05 obj = new ImgMod05();
  }//end main
  //-------------------------------------------//

  public ImgMod05(){//constructor
    //Get an image from the specified image file.  Can be
    // in a different directory if the path was entered
    // with the file name on the  command line.
    rawBufferedImage = getTheImage();
  
    //Construct the display object.
    this.setTitle("Copyright 2006, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.NORTH);
    
    //Make the frame visible to make it possible to
    // get insets and the height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and the height
    // of the button.
    inTop = this.getInsets().top;
    inLeft = this.getInsets().left;
    inBottom = this.getInsets().bottom;
    buttonHeight = replotButton.getSize().height;
    
    //Save a reference to this Frame object for use in
    // setting the size of the Frame later.
    displayFrame = this;

    //===================================================//
    //Anonymous inner class listener for Replot button.
    // This actionPerformed method is invoked when the user
    // clicks the Replot button.  It is also invoked at
    // startup when this program posts an ActionEvent to
    // the system event queue attributing the event to the
    // Replot button.
    replotButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Process the image.
          System.out.println("\nProcess the image");
          processedImage = 
                          imageProcessingObject.processImg(
                                         rawBufferedImage);
          System.out.println("Image processed");
          //Set the display size to accommodate the raw and
          // processed images.  In the event that the 
          // processed image won't fit in the display
          // frame, the user can manually resize the frame.
          // Set the size such that for non-rotated images,
          // a tiny amount of the background color shows
          // between the two images, to the right of the
          // larger image, and below the bottom image.
          int maxWidth = 0;
          //Get max image width.
          if(processedImage.getWidth() > 
                              rawBufferedImage.getWidth()){
            maxWidth = processedImage.getWidth();
          }else{
            maxWidth = rawBufferedImage.getWidth();
          }//end else
          int totalWidth = 2*inLeft + maxWidth + 2;

          //Get height of two images.
          int height = rawBufferedImage.getHeight() 
                              + processedImage.getHeight();
          int totalHeight = 
              inTop + inBottom + buttonHeight + height + 4;
          displayFrame.setSize(totalWidth,totalHeight);
          
          //Occasionally on an intermittent basis, without
          // the addition of the following statement, even
          // though the repaint method is called, the OS
          // doesn't make a call to the overridden paint
          // method.  As a result, the original and
          // processed images don't appear in the display
          // frame and it appears to be hung up in an
          // intermediate state.  The Sun documentation for
          // the Container class states "If a component has
          // been added to a container that has been
          // displayed, validate must be called on that
          // container to display the new component." 
          // Apparently the same thing holds true when the
          // size of the container is changed.  Inclusion
          // of the following statement seems to fix the
          // intermittent problem.
          displayFrame.validate();

          System.out.println("Call repaint");
          //Repaint the image display frame with the
          // original image at the top and the modified
          // image at the bottom.
          display.repaint();
          System.out.println("Repaint call complete");
          //Write the modified image into a JPEG file named
          // junk.jpg.
          System.out.println("Call writeJpegFile");
          writeJpegFile(processedImage);
          System.out.println(
                            "writeJpegFile call complete");
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class registered on the Replot
    // button.
    //===================================================//
    
    //Continuing with the constructor code ...
    
    //Instantiate a new object of the image-processing
    // class.  Note that this object is instantiated using
    // the newInstance method of the class named Class.
    // This approach does not allow for the use of a
    // parameterized constructor.
    try{
      imageProcessingObject = (ImgIntfc05)Class.forName(
                         theProcessingClass).newInstance();

       //Post a counterfeit ActionEvent to the system event
       // queue and attribute it to the Replot button.
       // (See the anonymous ActionListener class that
       // registers an ActionListener object on the Replot
       // button above.)  Posting this event causes the
       // image-processing method to be invoked at startup
       // and causes the modified image to be displayed.
      Toolkit.getDefaultToolkit().getSystemEventQueue().
        postEvent(
          new ActionEvent(replotButton,
                          ActionEvent.ACTION_PERFORMED,
                          "Replot")
        );//end postEvent method

      //At this point, the image has been processed.  The
      // original image and the modified image have been
      // displayed.  From this point forward, each time the
      // user clicks the Replot button, a new image
      // processing will be instantiated, the image will be
      // processed again, and the new modified image will
      // be displayed along with the original image.

    }catch(Exception e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Cause the composite of the frame, the canvas, and the
    // button to become visible.
    this.setVisible(true);

    //===================================================//

    //Anonymous inner class listener to terminate
    // program.
    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //===================================================//

  }//end ImgMod05 constructor
  //=====================================================//

  //Inner class for canvas object on which to display the
  // two images.
  class Display extends Canvas{
    //Override the paint method to display the raw image
    // and the modified image on the same Canvas object,
    // separated by a couple of rows of pixels in the
    // background color.
    public void paint(Graphics g){
      //First confirm that the image has been completely
      // loaded and that none of the image references are
      // null.
      if (tracker.statusID(1,false) ==
                                    MediaTracker.COMPLETE){
        if((rawBufferedImage != null) && 
           (processedImage != null)){
          //Draw raw image at the top.  Terminate if the
          // the pixels are changing.
          boolean success = false;
          success = g.drawImage(rawBufferedImage,0,0,this);
          if(!success){
            System.out.println("Unable to draw top image");
            System.exit(1);
          }//end if
          //Draw processed image at the bottom.
          success = g.drawImage(processedImage,0,
                    rawBufferedImage.getHeight() + 2,this);
          if(!success){
            System.out.println(
                            "Unable to draw bottom image");
            System.exit(1);
          }//end if
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas
//=======================================================//

  //Write the contents of a BufferedImage object to a JPEG
  // file named junk.jpg.
  void writeJpegFile(BufferedImage img){
    try{
      //Get a file output stream.
      FileOutputStream outStream = 
                          new FileOutputStream("junk.jpg");
      //Call the write method of the ImageIO class to write
      // the contents of the BufferedImage object to an
      // output file in JPEG format.
      ImageIO.write(img,"jpeg",outStream);
      outStream.close();
    }catch (Exception e) {
      e.printStackTrace();
    }//end catch
  }//end writeJpegFile
  //-----------------------------------------------------//
  
  //This method reads an image from a specified image file,
  // writes it into a BufferedImage object, and returns a
  // reference to the BufferedImage object.
  //The name of the image file is contained in an instance
  // variable of type String named theImgFile.
  BufferedImage getTheImage(){
    Image rawImage = Toolkit.getDefaultToolkit().
                                      getImage(theImgFile);

    //Use a MediaTracker object to block until the image is
    // loaded or ten seconds has elapsed.  Terminate and
    // display an error message if ten seconds elapse
    // without the image having been loaded.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImage,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully loaded.
    if((tracker.statusAll(false)
                             & MediaTracker.ERRORED
                             & MediaTracker.ABORTED) != 0){
      System.out.println("Load errored or aborted");
      System.exit(1);
    }//end if

    //Create an empty BufferedImage object.  Note that the
    // specified image type is critical to the correct
    // operation of the image-processing method. The method
    // may work correctly for other image types, but has
    // been <span lang="en-us"></span>tested only for TYPE_INT_RGB.
    BufferedImage buffImage = new BufferedImage(
                              rawImage.getWidth(this),
                              rawImage.getHeight(this),
                              BufferedImage.TYPE_INT_RGB);

    // Draw Image into BufferedImage
    Graphics g = buffImage.getGraphics();
    g.drawImage(rawImage, 0, 0, null);

    return buffImage;
  }//end getTheImage
  //-----------------------------------------------------//
}//end ImgMod05.java class
//=======================================================//

//The ProgramTest class

//The purpose of this class is to provide a simple example
// of an image-processing class that is compatible with the
// use of the program named ImgMod05.  A compatible class 
// is required to implement the interface named ImgIntfc05.
// This, in turn, requires the class to define the method
// named processImg, which receives one parameter of 
// type BufferedImage and returns a reference of type
// BufferedImage.

//The method named processImg is a color inverter method.

//The method named processImg as defined in this class
// receives an incoming reference to an image as a
// parameter of type BufferedImage.  The method returns a
// reference to an image as type BufferedImage where all of
// the color values in the pixels have been inverted by
// subtracting the color values from 255.  The alpha values
// are not modified.

//The method has been demonstrated to work properly only
// for the case where the incoming BufferedImage object
// was constructed for image type
// BufferedImage.TYPE_INT_RGB.  However, it may work
// properly for other image types as well.

//Note that this class does not define a constructor.
// However, if it did define a constructor, that
// constructor would not be allowed to receive parameters.
// This is because the class named ImgMod05 instantiates an
// object of this class by invoking the newInstance method
// of the Class class on the basis of the name of this class
// as a String.  That process
// does not allow for constructor parameters for the class
// being instantiated.
class ProgramTest implements ImgIntfc05{

  //The following method must be defined to implement the
  // ImgIntfc05 interface.
  //The following method must be defined to implement the
  // ImgIntfc05 interface.
  public BufferedImage processImg(BufferedImage theImage){

    //Use the LookupOp class from the Java 2D API to
    // invert all of the color values in the pixels.  The
    // alpha value is not modified.

    //Create the data for the lookup table.
    short[] lookupData = new short[256];
    for (int cnt = 0; cnt &lt; 256; cnt++){
      lookupData[cnt] = (short)(255-cnt);
    }//end for loop
    
    //Create the lookup table
    ShortLookupTable lookupTable = 
                        new ShortLookupTable(0,lookupData);

    //Create the filter object.
    BufferedImageOp thresholdOp = 
                            new LookupOp(lookupTable,null);

    //Apply the filter to the incoming image and return
    // a reference to the resulting BufferedImage object.
    return thresholdOp.filter(theImage, null);
  }//end processImg
}//end class ProgramTest
<br><br><b><font face="Courier New,Courier"><a href="#Listing_30">Listing 30</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p> </p>
<p><a name="Listing_31"><a href="#Listing_31">Listing 31</a></a></p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File ImgIntfc05.java
Copyright 2006, R.G.Baldwin

The purpose of this interface is to declare the method 
required by image-processing classes that are 
compatible with the program named ImgMod05.java.

Tested using J2SE 5.0 under WinXP
**********************************************************/

import java.awt.image.BufferedImage;

interface ImgIntfc05{
  public BufferedImage processImg(BufferedImage input);
}//end ImgIntfc05
//=======================================================//<br><br><b><font face="Courier New,Courier"><a href="#Listing_31">Listing 31</a></font></b></pre>
      </td>
    </tr>
  </tbody>
</table><br>
<hr align="center" size="3" width="100%">
<p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java 2D image pixel framework filter&nbsp; </p>
<p>-end- </p>
   </body>
</html>
