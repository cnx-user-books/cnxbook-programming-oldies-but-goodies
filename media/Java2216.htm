<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Using Java to produce SVG code in XHTML data</h2>
<i>Learn how to write Java code to produce XHTML files containing in-line SVG/XML 
code.&nbsp; Also learn how to write servlets that produce XHTML output containing 
in-line SVG/XML code.</i><p><b>Published:</b>&nbsp; May 8, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2216</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_program_named_Svg03">The program named Svg03</a></li>
		<li><a href="#The_program_named_Svg04">The program named Svg04</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This is the third lesson in a series designed to teach you how to write 
servlets to produce SVG code that will be rendered in graphic form by an 
SVG-compatible browser.&nbsp; In this lesson you will learn how to write Java code to produce XHTML files containing in-line SVG/XML 
code.&nbsp; You will also learn how to write servlets that produce XHTML output containing 
in-line SVG/XML code.</p>
<p><font color="#ff0000"><b>An SVG graphics library</b></font></p>
<p>In the previous two lessons titled &quot;Java JAXP, Creating graphics using Java 
and SVG&quot; and &quot;An improved approach for creating SVG/XML code and SVG/XML DOM 
nodes using Java&quot; <i>(see <a href="#Resources">Resources</a>),</i> 
I taught you how write your own SVG graphics library to eliminate, or at least 
alleviate the requirement to write raw XML code or raw JAXP DOM code.&nbsp; The 
use of the SVG graphics library makes it 
possible for you to produce SVG output simply by making typical Java method 
calls.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Graphic output from Svg03 and Svg04 
	programs.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of Svg03 program class.</li>
	<li><a href="#Listing_2">Listing 2</a>. Create the svg node.</li>
	<li><a href="#Listing_3">Listing 3</a>. Show the outline of the canvas.</li>
	<li><a href="#Listing_4">Listing 4</a>. Create the defs node.</li>
	<li><a href="#Listing_5">Listing 5</a>. Create the first linearGradient 
	node.</li>
	<li><a href="#Listing_6">Listing 6</a>. The makeLinearGradient method.</li>
	<li><a href="#Listing_7">Listing 7</a>. Create three stop nodes.</li>
	<li><a href="#Listing_8">Listing 8</a>. Create the other linearGradient 
	node.</li>
	<li><a href="#Listing_9">Listing 9</a>. Create the radialGradient node.</li>
	<li><a href="#Listing_10">Listing 10</a>. Create the node of type g.</li>
	<li><a href="#Listing_11">Listing 11</a>. Create the basic ellipse.</li>
	<li><a href="#Listing_12">Listing 12</a>. Set the appearance of the ellipse.</li>
	<li><a href="#Listing_13">Listing 13</a>. Rotate the ellipse.</li>
	<li><a href="#Listing_14">Listing 14</a>. Create the circle.</li>
	<li><a href="#Listing_15">Listing 15</a>. Set the appearance and rotate the 
	circle.</li>
	<li><a href="#Listing_16">Listing 16</a>. Create and fill the rectangle.</li>
	<li><a href="#Listing_17">Listing 17</a>. Round the corners of the 
	rectangle.</li>
	<li><a href="#Listing_18">Listing 18</a>. Create a polyline and rotate it.</li>
	<li><a href="#Listing_19">Listing 19</a>. Create a polygon and dress it up.</li>
	<li><a href="#Listing_20">Listing 20</a>. Create a wide, green, partially 
	transparent line.</li>
	<li><a href="#Listing_21">Listing 21</a>. Get an output stream to write the 
	XHTML file.</li>
	<li><a href="#Listing_22">Listing 22</a>. Process the DOM tree.</li>
	<li><a href="#Listing_23">Listing 23</a>. The processDocumentNode method.</li>
	<li><a href="#Listing_24">Listing 24</a>. Beginning of the recursive processNode 
	method.</li>
	<li><a href="#Listing_25">Listing 25</a>. Process nodes of type 
	ELEMENT_NODE.</li>
	<li><a href="#Listing_26">Listing 26</a>. The recursive processChildNodes method.</li>
	<li><a href="#Listing_27">Listing 27</a>. The DOCUMENT_NODE case.</li>
	<li><a href="#Listing_28">Listing 28</a>. First section of different code.</li>
	<li><a href="#Listing_29">Listing 29</a>. Last section of different code.</li>
	<li><a href="#Listing_30">Listing 30</a>. Program code for Svg03.</li>
	<li><a href="#Listing_31">Listing 31</a>. Program code for Svg04.</li>
	
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>SVG is a language for describing two-dimensional graphics in XML. SVG allows 
for three types of graphic objects:</p>
<ul>
	<li>vector graphic shapes</li>
	<li>images</li>
	<li>text</li>
</ul>
<p>The <a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a> is extensive, but it is not easy reading, particularly if your 
knowledge of XML is weak.</p>
<p>While I don't claim to be an expert in XML, I do know enough about the 
topic that I can usually make sense of the material provided in the SVG 
specification.&nbsp; One of my objectives for this series is to help Java programmers 
who lack a strong background in XML to take advantage of the capabilities of 
SVG.</p>
<p><font color="#FF0000"><b>G</b></font><font color="#ff0000"><b>reat graphics 
in the browser</b></font></p>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>No experience with IE/SVG plug-in</b><br>
				The SVG rendering engines that are available include Firefox 1.5.&nbsp; 
				I have also read that IE can be made SVG compatible by 
				installing an SVG plug-in.&nbsp;&nbsp; Please note however that 
				I have not installed and tested the SVG plug-in for IE.&nbsp; 
				The sample programs in this series were tested using Firefox 
				1.5.</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
You can write
Java programs that will produce XML output, which, when loaded into an SVG 
rendering engine, will result in the display of rich graphic material.&nbsp; When 
combined with the use of servlets, this makes it possible to display graphic 
material in the client area of a web browser that competes favorably with the 
graphic material that can be displayed using the Java 2D API 

<i>(see
<a href="#Resources">Resources</a>)</i> 

in desktop applications.


<h2 align="center"><font color="#000000"><a name="Preview">
Preview</a></font></h2>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Not valid XHTML data</b><br />
  Note that the output data produced by these two programs will not validate as 
	XHTML at <a href="http://validator.w3.org/file-upload.html">
	http://validator.w3.org/file-upload.html</a> because the SVG elements are 
	not valid XHTML elements.&nbsp; There is probably a way around this, but as 
	of this writing, I don't know what it is.
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Two different programs</b></font><p>In this lesson, I will present and explain two different programs.&nbsp; The 
first program named <b>Svg03</b> produces an output file containing SVG data 
embedded in XHTML data <i>(see the sidebar)</i>.&nbsp; The file can be rendered by loading it directly 
into a Firefox 1.5 browser.</p>
<p>The second program named <b>Svg04</b> is a servlet program.&nbsp; When the servlet is 
deployed and then accessed 
by a Firefox 1.5 browser, the servlet returns SVG data embedded in XHTML data <i>
(see the sidebar)</i>, 
which is rendered in graphic form by a Firefox 1.5 browser.</p>
<p><font color="#FF0000"><b>The graphic output</b></font></p>
<p>Both programs produce the same graphic output, which is shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Graphic output from Svg03 and Svg04 
	programs. </b>
<table cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java2216a01.jpg" width="244" height="618"></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#FF0000"><b>The programs illustrate a large number of important SVG 
capabilities</b></font></p>
<p>The graphic output shown in Figure 1 illustrates a large number of important 
capabilities of SVG including the following:</p>
<ul>
	<li>An <b>svg</b> element that contains other SVG elements and serves as a 
	canvas upon which SVG 
	<a href="http://www.w3.org/TR/SVG/intro.html#TermGraphicsElement">graphics 
	elements</a> are drawn.&nbsp; The available graphics 
	elements are listed below.&nbsp; The subset of graphics elements shown 
	in boldface in the following list are known as the </li>
	<a href="http://www.w3.org/TR/SVG/shapes.html">Basic Shapes</a>.&nbsp; Each 
	of the basic shapes is illustrated in Figure 1.&nbsp; The other graphics 
	elements will be illustrated in future lessons.<ul><li>path</li>
	<li>text</li>
	<li><b>rect</b></li>
	<li><b>circle</b></li>
		<li><b>ellipse</b></li>
	<li><b>line</b></li>
	<li><b>polyline</b></li>
	<li><b>polyline</b></li>
	<li>image</li>
	<li>use</li></ul>
	<li>A <b>rect</b> element that produces a black border <i>(stroke)</i> on the canvas 
	with a thickness of one pixel.</li>
	<li>A <span class="element-name"><b>defs</b></span> element, which is a 
	container for elements that are <i> <a name="referenced">referenced</a></i> by other elements in the 
	SVG code.&nbsp; In this case, the <b>defs</b> element contains two <b>
	linearGradient</b> elements, one <b>radialGradient</b> element, and several
	<b>stop</b> elements associated with the gradient elements.</li>
	<li>A <b>linearGradient</b> element that produces a left-to-right color 
	gradient that begins with yellow, changes to red, and finishes with blue.&nbsp; This gradient is
	<a href="#referenced">referenced</a> to fill the ellipse.</li>
	<li>A second <b>linearGradient</b> element that produces a color gradient 
	that begins with green and finishes with blue.&nbsp; This gradient is
	<a href="#referenced">referenced</a> to fill the circle.</li>
	<li>A <b>radialGradient</b> element, which produces a color gradient where 
	the color changes going outward from a center point.&nbsp; The rounded 
	rectangle in Figure 1 is filled with this radial gradient where the color 
	starts as yellow at the center, changes to red, and finishes with blue at 
	the outer extremity of the gradient.</li>
	<li>Several <b>stop</b> elements, which determine where and how the changes in 
	color gradients occur.</li>
	<li><a name="A_g_element">A <span class="element-name"><b>g</b></span> element</a>, which is a 
	container element for grouping together related graphics elements.&nbsp; 
	This <b>g</b> element is the container for all the graphics elements in Figure 1 
	other than the rectangle that forms the black border on the 
	canvas.</li>
	<li>An <b>ellipse</b>, with a blue border <i>(stroke)</i> two pixels thick 
	rotated by fifteen degrees clockwise around its center and 
	filled with a three-color linear gradient.</li>
	<li>A <b>circle</b> rotated by fifteen degrees clockwise around its center and filled with a two-color linear gradient.</li>
	<li>A <b>rect</b>angle with rounded corners filled with a three-color radial 
	gradient.</li>
	<li>A <b>polyline</b> described by four points and rotated by ten degrees 
	clockwise around the first point on the left.</li>
	<li>A <b>polygon</b> described by four points with a red border <i>(stroke)</i> 
	three pixels thick and filled with green.</li>
	<li>A green <b>line</b> with a width of twelve pixels and an opacity of 0.6.&nbsp; 
	This line is drawn on top of the other graphics elements from the upper left 
	to the bottom right of the canvas.&nbsp; Note that the other graphics 
	elements can be seen showing through the green line because its opacity is less 
	than 1.0.</li>
</ul>
<p>As I discuss the code for the two programs in the next section, remember that 
both of the programs produce the graphic output shown in Figure 1.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Svg03">The program named Svg03</a></h3>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>The main purpose of this program is to illustrate the inclusion of SVG 
graphics elements in an XHTML file that can be rendered in Firefox 1.5.</p>
<p>This program uses an SVG graphic library of my own design that has been significantly 
upgraded relative to the version used in the earlier lessons of this series <i>
(see <a href="#Resources">Resources</a>)</i>.&nbsp; The upgraded version of the library supports the following basic shapes plus linear and radial gradients
and dozens of attributes and transforms on each shape.</p>
<ul>
	<li>rect</li>
	<li>circle</li>
	<li>ellipse</li>
	<li>line</li>
	<li>polyline</li>
	<li>polygon </li>
</ul>
<p>The shapes in the above list are all of the basic shapes provided by SVG.</p>
<p><font color="#FF0000"><b>Convenience methods</b></font></p>
<p>The library also contains some convenience methods for creating elements, 
nodes, and blocks of code.&nbsp; These convenience methods are designed to 
reduce the labor required to write programs such as this one.</p>
<p><font color="#FF0000"><b>Create and transform a DOM tree</b></font></p>
<p>This program creates a DOM tree describing the SVG code for the image shown 
in Figure 1.&nbsp; Then it transforms the DOM tree into SVG code that is 
embedded 
in a file that would otherwise be a valid XHTML file.&nbsp; As mentioned 
earlier, inclusion of the SVG code prevents the code from being valid XHTML 
code because the SVG element names are not recognized by XHTML validator programs</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Converting Svg03 into a servlet.</b><br />
  As you will see later, only a couple of changes will be required to turn the 
	program named Svg03 into the servlet program named Svg04.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>A precursor to writing a servlet program</b></font></p>
<p>The capability demonstrated by this program is a precursor to being able to 
create inline SVG code in a servlet and to cause that SVG code to be rendered in 
a Firefox browser that accesses the servlet.</p>
<p>The output file produced by this program can be rendered by loading it 
directly into Firefox 1.5.</p>
<p>The program was tested using J2SE 5.0, Firefox v1.5.0.9, and WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will discuss and explain this program in fragments.&nbsp; You can view the 
entire program in Listing 30 near the end of the lesson.&nbsp; Listing 1 shows 
the beginning of the program class for the program named <b>Svg03</b>.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of Svg03 program class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>Svg03</b>{

  public static void <b>main</b>(String argv[]){
    
    //The following data values will be used to create
    // SVG graphics.
    int ellipseCenterX = 110;
    int ellipseCenterY = 100;
    int ellipseWidth = 100;
    int ellipseHeight = 40;
    int ellipseRotate = 15;//degrees
    
    int circleCenterX = 110;
    int circleCenterY = 100;
    int circleRadius = 30;
    int circleRotate = 15;

    int rectCenterX = 110;
    int rectCenterY = 200;
    int rectWidth = 110;
    int rectHeight = 80;
    int rectRoundX = 26;
    int rectRoundY = 25;
    
    int rotatePolyline = 10;
    
    try{
      //Create a DOM tree that describes a particular
      // graphic image.
      //Begin by creating a Document object and a root
      // node named svg.  All of the graphic content will
      // be contained in the svg element. This code was
      // explained in the earlier program named
      // Xslt01.java that was explained in lesson 2202
      // named "Getting Started with Java JAXP and XSL
      // Transformations (XSLT)".
      
      //At this point, the program starts using the 
      // SVG graphics library encapsulated in the class
      // named SvgGraphics.
      Document document = SvgGraphics.getDocument();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 1 begins by declaring and initializing some variables that will be 
used later by the program</p>
<p>Then the program calls the <b>getDocument</b> method of the SvgGraphics class 
to get a reference to the <b>Document</b> object that represents the entire XML 
document.&nbsp; I explained this method in an earlier lesson and won't repeat 
that explanation here.</p>
<p><font color="#FF0000">
<b>Create the svg node</b></font></p>
<p>Listing 2 calls the <b>makeNode</b> method to create the root node named <b>svg</b> and append it to the document 
node.&nbsp; 
Listing 2 also sets some attributes on the <b>svg</b> node that are required for proper rendering.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Create the svg node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element svg = SvgGraphics.<b>makeNode</b>(
        document,
        null,//parent
        "<b>svg</b>",//node type
        new String[]{"xmlns","http://www.w3.org/2000/svg",
                     "version","1.1",
                     "width","220px",
                     "height","440px",
                     "position","static",
                     "top","0",
                     "left","0"
                    });//end call to makeNode</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As I mentioned earlier, the <b>svg</b> node is used to create the canvas upon 
which the <i>Basic Shape</i> graphics elements shown in Figure 1 are drawn.</p>
<p><font color="#FF0000"><b>The makeNode method</b></font></p>
<p>I explained the usage of the method named <b>makeNode</b> in the earlier 
lesson titled &quot;An improved approach for creating SVG/XML code and SVG/XML DOM 
nodes using Java&quot; <i>(see <a href="#Resources">Resources</a>)</i> and won't 
repeat that explanation here.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The xmlns and position attributes.</b><br />
  I will leave it as an exercise for the 
reader to go to the SVG specifications <i>(see <a href="#Resources">Resources</a>)</i> 
to investigate the meaning of the attributes named <b>xmlns</b> and <b>position</b>.&nbsp; 
Be forewarned, however, that unless you already understand quite a lot about 
XML, you may have some difficulty understanding the purpose of these attributes, 
particular the one named <b>xmlns</b>.</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Attributes of the svg node</b></font></p>
<p>With the possible exception of the attributes named <b>xmlns</b> and <b>
position</b>, the purpose of the attributes that are set on the <b>svg</b> node 
in Listing 2 should be fairly obvious on the basis of their names.</p>
<p><font color="#FF0000">
<b>Show the outline of the canvas</b></font></p>
<p>Listing 3 calls the <b>makeNode</b> method to create a node of type <b>rect</b> 
to draw the black rectangular outline on the canvas in Figure 1.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Show the outline of the canvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element outline = SvgGraphics.<b>makeNode</b>(
                     document,
                     svg,//parent could be null
                     "<b>rect</b>",//node type
                     new String[]{"x","0",
                                  "y","0",
                                  "width","220",
                                  "height","440",
                                  "fill","none",
                                  "stroke","black",
                                  "stroke-width","1"
                                 });//end call to makeNode</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The stroke and stroke-width attributes</b></font></p>
<p>The <b>stroke</b> attribute value in Listing 3 specifies that the rectangle 
should be drawn <i>(or stroked)</i> with a black line.&nbsp; The <b>stroke-width</b> 
attribute in Listing 3 specifies that the black line should be one pixel in 
thickness.</p>
<p><font color="#FF0000"><b>The x, y, width, and height attributes</b></font></p>
<p>If you compare the <b>x</b>, <b>y</b>, <b>width</b>, and <b>height</b> 
attribute values in Listing 3 with the <b>left</b>, <b>top</b>, <b>width</b>, 
and <b>height</b> attribute values in Listing 2, you will see that the outline 
of the black rectangle matches the outline of the canvas that was created by 
Listing 2.&nbsp; You can't see the canvas in Figure 1.&nbsp; However, you can 
see its outline that is highlighted by the black rectangle.</p>
<p><font color="#FF0000">
<b>Create the defs node</b></font></p>
<p>Listing 4 calls the <b>makeNode</b> method to create a node of type <b>defs</b>.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Create the defs node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element defs = SvgGraphics.<b>makeNode</b>(document,
                                          svg,//parent
                                          "<b>defs</b>",
                                          <b>null</b>);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>defs</b> node will be the parent <i>(container)</i> for three gradient nodes.&nbsp; As 
explained earlier, the <b>defs</b> element will contain two linear gradient 
elements and one radial gradient element.</p>
<p>In this case, a value of null is passed as the fourth parameter <i>(which is 
normally a reference to an array object containing attribute name/value pairs)</i> 
to indicate that the <b>defs</b> node has no attributes.</p>
<p><font color="#FF0000">
<b>Create the first linearGradient node</b></font></p>
<p>Listing 5 is the beginning of a section of code that creates nodes that 
define three different gradient coloring schemes.&nbsp; These nodes will be 
child nodes of the <b>defs</b> node.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Create the first linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element gradientA = SvgGraphics.<b>makeLinearGradient</b>(
                              document,    //this document
                              defs,        //parent
                              "<b>gradientA</b>");//id</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<p>


<font color="#FF0000"><b>A container for referenced elements</b></font></p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Identification of gradientA.</b><br />
  The node that is created in Listing 5 is identified as<i> gradientA</i> by the 
	value of the third parameter.<i> </i>
</td></tr></table>
</td>
</tr>
</table>

Recall that a <span class="element-name"><b>defs</b></span> element in the 
final SVG code is a container for elements that are <a href="#referenced">
referenced</a> by other elements in the SVG code.&nbsp; The three gradient nodes 
will be identified as <i>gradientA</i>, <i>gradientB</i>, and <i>gradientC</i>.&nbsp; 
The other elements in the SVG code will use these identifiers to reference the 
gradient nodes.</p>
<p>The gradient elements will be referenced later to specify the fill colors for 
an ellipse, a circle, and a rounded rectangle.</p>
<p><font color="#FF0000"><b>Call the makeLinearGradient method</b></font></p>
<p>The code in Listing 5 calls the <b>makeLinearGradient</b> method to create 
the node of type <b>linearGradient</b> for <i>gradientA</i>.&nbsp; Although it 
isn't obvious yet, the gradient element that results from transforming this node 
into raw XML code will provide a linear gradient that begins with yellow, changes to red, and ends 
with blue going from left to right.</p>
<p><font color="#FF0000"><b>Did not call the makeNode method</b></font></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Creating the linearGradient node</b><br />
  It would also have been acceptable to call the makeNode method in 
	place of the makeLinearGradient method, but that would have required a 
	little more typing.
</td></tr></table>
</td>
</tr>
</table>

<p>It is important to note that Listing 5 did not call the general <b>makeNode</b> 
method to create this node.&nbsp; Rather, it called the more specialized method 
named <b>makeLinearGradient</b>.</p>
<p><font color="#FF0000"><b>Specialized methods in my SVG graphics library</b></font></p>
<p>My <b>SvgGraphics</b> library contains a 
number of specialized methods that are used to create nodes with most of the 
attributes having default values.&nbsp; Only the attribute values that are most 
likely to change from one call to the next are passed as parameters to these 
methods.&nbsp; They are provided as a convenience 
because they can be called with a little less effort and <span lang="en-us">
</span>a little less 
thought than the <b>makeNode</b> 
method for those cases where they are applicable.</p>
<font color="#FF0000">
<b>The makeLinearGradient method</b></font></p>
<p>It will probably be 
useful to take a look at the code in the <b>makeLinearGradient</b> method as an 
example of the more specialized methods in the library.&nbsp; The method is shown in its entirety in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The makeLinearGradient method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  static Element <b>makeLinearGradient</b>(Document document,
                                    Element parent,
                                    String id){
    Element gradient = 
        (Element)document.createElement("<b>linearGradient</b>");
    parent.appendChild(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method creates and returns a reference to a node of type <b>
linearGradient</b> with an <b>id</b> attribute whose value is set to the value 
of the third parameter.&nbsp; Before returning, the new 
node is appended as a child to the node whose reference is received as the 
second parameter.</p>
<p>This method is straightforward and shouldn't require any further explanation.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>What is a gradient?</b><br />
  According to the <a href="http://www.w3.org/TR/SVG/pservers.html#Introduction">
	W3C</a> &quot;Gradients consist of continuously smooth color transitions 
	along a vector from one color to another, possibly followed by additional 
	transitions along the same vector to other colors. SVG provides for two 
	types of gradients, <strong>linear gradients</strong> and <strong>radial 
	gradients</strong>.&quot;</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000">
<b>Create three stop nodes</b></font></p>
<p>Now, returning to the main thread of the discussion, a <b>linearGradient</b> 
element alone isn't very useful.&nbsp; To be useful, the<b> linearGradient</b> 
element must be supplemented by<b> stop</b> elements that control how and where 
the colors change.&nbsp; One <b>stop</b> element is required for each color 
change.&nbsp; The <b>stop</b> elements must be children of the <b>linearGradient</b> element.</p>
<p>According to the <a href="http://www.w3.org/TR/SVG/pservers.html#GradientStops">
W3C</a>, &quot;The ramp of colors to use on a gradient is defined by the <strong>stop</strong> 
elements that are child elements to either the <b>linearGradient</b> element or 
the <b>radialGradient</b> element.&quot;</p>
<p><font color="#FF0000"><b>Call the makeGradientStop method</b></font></p>
<p>Listing 7 calls the <b>makeGradientStop</b> method three times in succession to 
establish the <i>&quot;ramp of colors&quot;</i> to be used on the <b>linearGradient</b> 
node that was created in Listing 6.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Create three stop nodes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientA,//parent
                                   "2%",     //start here
                                   "yellow");//color
                             
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientA,
                                   "50%",
                                   "red");
                             
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientA,
                                   "98%",
                                   "blue");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You can view the <b>makeLinearGradient</b> method in its entirety in Listing 
30, but you don't need to know much about the code in the method to be able to 
use it.&nbsp; The important thing is to understand the meaning of the four 
parameters to the method.</p>
<p><font color="#FF0000"><b>The four parameters to the makeGradientStop method</b></font></p>
<p>The first parameter is a reference to the document to which the element 
belongs, and the second parameter is a reference to the node that will be the 
parent of the <b>stop</b> node.</p>
<p><font color="#FF0000"><b>The gradient vector</b></font></p>
<p>The third parameter is perhaps the most complicated of the four.&nbsp; This 
parameter specifies the location, <i>(proceeding from the beginning to the end along a 
linearGradient vector or from the center point outward for a radialGradient 
vector)</i> at which the color starts changing.</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The length and direction of the gradient vector</b><br />
  For a linearGradient as used in this lesson, the length of the vector is the 
	width of the component to which the gradient is being applied and the 
	direction is from left to right.&nbsp; However, it is possible to provide 
	much more fine grained control over the length and direction of the vector 
	when the linearGradient element is created.&nbsp; For a radialGradient, the 
	length of the vector is specified as a radius value when the radialGradient 
	element is defined.</td></tr></table>
</td>
</tr>
</table>

This value can be 
specified as a percentage <i>(0% to 100%)</i> or a number <i>(0.0 to 1.0)</i> 
representing a fraction of the total length of the vector to which the gradient 
will be applied, <i>(such as the width of ellipse in Figure 1)</i>.<p>For this 
example, the color starts as pure yellow at the left end of the ellipse and 
starts changing to red two-percent of the way to the right end of the ellipse.</p>
<p><font color="#FF0000"><b>The specified colors</b></font></p>
</p>
<p>The fourth parameter simply specifies the color at the point specified by the 
third parameter.</p>
<p>Thus the combination of the first two <b>stop</b> nodes in Listing 7 specify 
that the color will be yellow at and to the left of the two-percent point and 
will be red at the fifty-percent point.&nbsp; The color will change in a linear 
gradient fashion from yellow to red along the portion of the gradient vector that connects those two 
points.</p>
<p>Similarly, the combination of the last two <b>stop</b> nodes in Listing 7 
specify that the color will be red at the fifty-percent point and will be blue 
at the ninety-eight-percent point and beyond.&nbsp; The color will change in a 
linear gradient fashion from red to blue along the portion of the gradient vector that connects those 
two points.</p>
<p><font color="#FF0000">
<b>Create the other linearGradient node</b></font></p>
<p>Listing 8 creates the<b> linearGradient</b> node and two child nodes of type<b> 
stop</b> that result in the green-to-blue gradient in the circle in Figure 1.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Create the other linearGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element gradientB =SvgGraphics.<b>makeLinearGradient</b>(
                             document,    //this document
                             defs,        //parent
                             "gradientB");//id
                   
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientB,//parent
                                   "0%",     //start here
                                   "green"); //color
                             
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientB,
                                   "100%",
                                   "blue");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create the radialGradient node</b></font></p>
<p>Listing 9 calls the <b>makeRadialGradient</b> method once and then calls the
<b>makeGradientStop</b> method three times in succession to create the radial 
gradient node that results in the color gradient shown in the rounded rectangle 
in Figure 1.&nbsp; This gradient starts with yellow at the center, changes to 
red at a distance of fifty-percent of the distance to the outer edge and ends up 
with blue at the outer edge of the rounded rectangle.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Create the radialGradient node. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element gradientC = 
                 SvgGraphics.<b>makeRadialGradient</b>(
                   document,        //this document
                   defs,            //parent
                   "gradientC",     //ID
                   "userSpaceOnUse",
                   rectCenterX,     //cx
                   rectCenterY,     //cy
                   rectWidth/2);    //r
                   
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientC,
                                   "0%",
                                   "yellow");
                             
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientC,
                                   "50%",
                                   "red");
                             
      SvgGraphics.<b>makeGradientStop</b>(document,
                                   gradientC,
                                   "100%",
                                   "blue");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The parameters to the <b>makeRadialGradient</b> method are similar to, but 
not identical to the parameters to the <b>makeLinearGradient</b> method in 
Listing 5 and Listing 8.&nbsp; For the radial gradient, the first three 
parameters have the same meaning as in Listing 5.</p>
<p><font color="#FF0000"><b>The attribute value of <i>&quot;userSpaceOnUse&quot;</i></b></font></p>
<p>I'm not even going to try to explain the meaning of the fourth parameter with 
the value <i>&quot;userSpaceOnUse.&quot;</i>&nbsp; For this parameter, you can either 
continue to use the same value, or you can go to the SVG specifications <i>(see
<a href="#Resources">Resources</a>)</i> to learn more about this parameter.</p>
<p><font color="#FF0000"><b>The center point and radius of the radialGradient</b></font></p>
<p>The fifth and sixth parameters, <b>cx</b> and <b>cy,</b> specify the point 
from which the gradient will radiate.</p>
<p>The seventh parameter, <b>r</b> 
specifies the distance from that center point that represents 100% insofar as 
the <b>stop</b> element is concerned.&nbsp; Stated differently, this distance 
represents the length of the gradient vector discussed earlier.</p>
<p><font color="#FF0000"><b>The fill color results</b></font></p>
<p>Thus, when this radial gradient is used to fill the rounded rectangle shown 
in Figure 1, the 
color at the center of the rectangle will be yellow.&nbsp; The color half way 
between the center and the outer edge on the horizontal axis will be red.&nbsp; 
The color at the outer edge on the horizontal axis will be blue.&nbsp; The 
colors will change in a linear gradient fashion along any vector that extends 
from the center to a point that is at a distance from the center equal to 
one-half the width of the rectangle.&nbsp; <i>(As you can see in Figure 1, because the height of 
the rectangle is less than the width, the color never quite reaches the blue 
state at the top and the bottom of the rectangle.)</i></p>
<p><font color="#FF0000"><b>The center point can be anywhere</b></font></p>
<p>By the way, there is no requirement for the center point of the radial 
gradient to be at the center of the rectangle.&nbsp; In fact, there is no 
requirement for the center point of the radial gradient to even be inside the 
rectangle.&nbsp; When the radial gradient is used to fill the rectangle, the 
effect is as if an invisible version of the radial gradient is created at a 
specified location with a specified radius on the canvas but only 
that portion that overlaps the rectangle actually becomes visible.</p>
<p><font color="#FF0000">
<b>Create the node of type g</b></font></p>
<p>Listing 10 calls the <b>makeNode</b> method to create a group node named <b>g</b>.&nbsp; 
As described <a href="#A_g_element">earlier</a>, a <b>g</b> element is a 
container element for grouping together related graphics elements.&nbsp; This <b>
g</b> node will result in an element that will be the container for an ellipse, 
a circle, a rectangle, a polyline, a polygon, and a line.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Create the node of type g. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element g = SvgGraphics.makeNode(document,
                                       svg,//parent
                                       "g",
                                       null);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Because this node doesn't have any attributes, a value of null is passed as 
the fourth parameter to the method.</p>
<p><font color="#FF0000">
<b>Create the basic ellipse</b></font></p>
<p>Listing 11 shows the beginning of a section of code that creates the ellipse 
shown at the top of Figure 1.&nbsp;&nbsp; Eventually, this ellipse will be:</p>
<ul>
	<li>Given a blue border that is two pixels thick.</li>
	<li>Filled with <b>gradientA</b>, which is a linear gradient that begins 
	with yellow, changes to red, and finishes with blue.</li>
	<li>Rotated by fifteen degrees clockwise around its center.</li>
</ul>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The width and the height</b><br />
  Note that the width and height dimensions for the ellipse apply to the shape 
	of the ellipse before it is rotated.
</td></tr></table>
</td>
</tr>
</table>

However, the code in Listing 11 simply calls the <b>makeEllipse</b> method to 
create the basic ellipse on the basis of the specified coordinates for the 
center of the ellipse and the specified values for the width and the height.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Create the basic ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element theEllipse = SvgGraphics.<b>makeEllipse</b>(
                             document,
                             g,//Owner
                             ellipseCenterX,
                             ellipseCenterY,
                             ellipseWidth,
                             ellipseHeight);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the ellipse node that is created in Listing 11 is appended as a 
child of the <b>g</b> node.</p>
<p><font color="#FF0000">
<b>Set or update the appearance of the ellipse</b></font></p>
<p>After the basic ellipse node has been created by the code in Listing 11, Listing 12 calls the <b>
setAttribute</b> method on the reference to the ellipse node three times in 
succession to:</p>
<ul>
	<li>Fill the ellipse with the linear gradient element that was created and 
	identified as <b>gradientA</b> earlier.&nbsp; <i>(This is what I meant when 
	I discussed the possibility of SVG elements <a href="#referenced">
	referencing</a> elements that are created within the defs element.)</i></li>
	<li>Set the border color to blue.</li>
	<li>Set the border thickness to two pixels.</li>
</ul>
<p>
<b><a name="Listing_12">Listing 12</a>. Set the appearance of the ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      theEllipse.setAttribute("fill","url(#gradientA)");
      theEllipse.setAttribute("stroke","blue");
      theEllipse.setAttribute("stroke-width","2");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The different kinds of transforms.</b><br />
  You can learn about the different kinds of transforms that are supported by 
	the SVG in the SVG specifications <i>(see <a href="#Resources">Resources</a>)</i>.
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>The transform attribute</b></font></p>
<p>The <b>transform</b> 
attribute can be set repeatedly on a graphics element to perform a series of sequential transforms on the 
element.&nbsp; 
Available transforms include:</p>
<ul>
	<li>translate</li>
	<li>scale</li>
	<li>rotate</li>
	<li>skewX</li>
	<li>skewY</li>
</ul>
<p><font color="#FF0000"><b>Rotate the ellipse <i>(the hard way)</i></b></font></p>
<p>In this case, I was interested only in rotating the ellipse about its center.&nbsp; 
It should be possible to rotate a shape around any location specified 
by x and y coordinate values.&nbsp; However, I was unable to identify the proper 
syntax for doing that, so I used a work around that consisted of three 
sequential steps to accomplish the desired rotation.</p>
<p><font color="#FF0000"><b>The three steps</b></font></p>
<p>The three steps were:</p>
<ol>
	<li>Translate the origin so that the origin was at the 
center of the ellipse.</li>
	<li>Rotate the ellipse by 
fifteen degrees clockwise around the origin.</li>
	<li>Translate the origin so that the center of the now-rotated ellipse was back in 
its original location relative to the origin.</li>
</ol>
<p>The code to accomplish the three steps is shown in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Rotate the ellipse. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      theEllipse.<b>setAttribute</b>("transform",
                  "translate(" + ellipseCenterX + "," 
                  + ellipseCenterY + ") "
                  + "rotate(" + ellipseRotate + ") "
                  + "translate(" + (-ellipseCenterX) + ","
                  + (-ellipseCenterY) + ") ");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If Listing 13 seems confusing, rewrite the statement in Listing 13, 
substituting the numeric values for the variables in place of the variable 
names.&nbsp; It may make more sense if you look at it that way.</p>
<p><font color="#FF0000">
<b>Create the circle</b></font></p>
<p>Listing 14 calls the <b>makeCircle</b> method to position a basic circle so that it appears to be inside the ellipse 
in Figure 1.&nbsp; However, it isn't really inside the ellipse in a containment 
sense.&nbsp; Rather, the circle is simply positioned on top of the ellipse.&nbsp; 
The default opacity value for the circle is 1.0.&nbsp; Therefore, the ellipse 
doesn't show through the circle.</p>
<p>As you can see, the parameter list for the <b>makeCircle</b> method in 
Listing 14 is a 
little simpler than the parameter list for the <b>makeEllipse</b> method in 
Listing 11.&nbsp; 
This is because it is necessary to specify both a width and a height for an 
ellipse, but it is only necessary to specify a radius for a circle.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Create the circle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element theCircle = SvgGraphics.<b>makeCircle</b>(
                            document,
                            g,//Owner
                            circleCenterX,
                            circleCenterY,
                            circleRadius);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once the code in Listing 14 has finished executing, the basic circle has been 
created and positioned, but it hasn't been <i>&quot;dressed up&quot;</i> in the manner shown in 
Figure 1.</p>
<p><font color="#FF0000">
<b>Set the appearance and rotate the circle</b></font></p>
<p>Listing 15 calls the <b>setAttribute</b> method twice in succession to:</p>
<ul>
	<li>Fill the circle with the green-to-blue linear gradient, created and 
	identified earlier as <b>gradientB</b>, as shown in the 
	circle in Figure 1.</li>
	<li>Rotate the circle by fifteen degrees clockwise around its center.</li>
</ul>
<p>
<b><a name="Listing_15">Listing 15</a>. Set the appearance and rotate the 
circle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      theCircle.<b>setAttribute</b>("fill","url(#gradientB)");
      theCircle.<b>setAttribute</b>("transform",
                   "translate(" + circleCenterX + "," 
                   + circleCenterY + ") "
                   + "rotate(" + circleRotate + ") "
                   + "translate(" + (-circleCenterX) + ","
                   + (-circleCenterY) + ") ");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Why rotate the circle?</b></font></p>
<p>You might be wondering what is to be gained by rotating a circle by fifteen 
degrees around its center.&nbsp; If the circle had been filled with a solid 
color, rotation would not change the appearance of the circle.&nbsp; However, 
because the circle was filled with a linear gradient such that it is green on 
the left and blue on the right, rotating the circle about its center does change 
its appearance.</p>
<p><font color="#FF0000">
<b>Create and fill the rectangle</b></font></p>
<p>Listing 16 calls the <b>makeRect</b> method to create a basic rectangle.&nbsp; 
The coordinates of the upper-left corner of the rectangle are specified by the 
values of the third and fourth parameters.&nbsp; The width and height of the 
rectangle are specified by the values of the fifth and sixth parameters.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Create and fill the rectangle.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element theRect = SvgGraphics.<b>makeRect</b>(
                            document,
                            g,//Owner
                            rectCenterX - rectWidth/2,//x
                            rectCenterY - rectHeight/2,//y
                            rectWidth,
                            rectHeight);

      theRect.setAttribute("fill","url(#gradientC)");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 16 calls the <b>setAttribute</b> method to fill the rectangle 
with the radial gradient created and identified earlier as <b>gradientC</b>.</p>
<p>Note that at this point, the rectangle still has square corners.&nbsp; It is 
not yet a <i>&quot;rounded rectangle.&quot;</i></p>
<p><font color="#FF0000">
<b>Round the corners of the rectangle</b></font></p>
<p>Listing 17 calls the <b>setAttribute</b> method twice in succession to set 
the values for the attributes named <b>rx</b> and <b>ry</b>.&nbsp; The purpose 
of these two attributes is to control the amount of rounding that is applied to 
the corners.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Round the corners of the rectangle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Round the corners.
      theRect.setAttribute("rx",""+ rectRoundX);
      theRect.setAttribute("ry",""+ rectRoundY);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although I can't explain exactly how these attribute values are used to round 
the corners from a geometry viewpoint <i>(I would like to see some explanatory 
pictures that describe this process),</i> I can tell you generally how they behave.&nbsp; If you set either 
attribute value to zero, all four corners will be square.</p>
<p>If you set <b>rx</b> to half the width of the rectangle and set <b>ry</b> to 
half the height of the rectangle, the corners will be rounded so much that the 
rectangle will take on the appearance of an ellipse.</p>
<p>Values in between those two extremes result in rounded corners as shown in 
Figure 1.</p>
<p><font color="#FF0000"><b>What is a polyline?</b></font></p>
<p>A <b>polyline</b> is a shape that results from <i>&quot;connecting the dots&quot;</i> 
between each consecutive pair of points in a set of points.&nbsp; Each point is 
connected to only the point that follows it in the specification of the 
locations of the points.&nbsp; </p>
<p>There is no requirement for the shape to be closed, although it can be closed if the coordinates for the last point 
are the same as the coordinates for the 
first point.&nbsp; <i>(The polyline in Figure 1 is not closed.)</i></p>
<p>There is also nothing to prohibit a line drawn between two points from 
crossing a previously drawn line between two other points as shown in Figure 1.</p>
<p>There are no gaps or open spaces along the line.&nbsp; You can always start at the beginning 
specified by the first point and follow the line to the end that is specified by 
the last point.</p>
<p><font color="#FF0000">
<b>Create a polyline and rotate it</b></font></p>
<p>Figure 1 shows a black polyline that was drawn using coordinate values 
for the points as shown in Listing 18.</p>
<p>Listing 18 begins by creating and populating an array object containing eight values of 
type <b>int</b>.&nbsp; Each consecutive pair of <b>int</b> values placed in the 
array object represents the coordinates of a single point.&nbsp; Thus, the array 
object contains the coordinate values for four points.</p>
<p><font color="#FF0000"><b>Call the makePolyline method</b></font></p>
<p>Then Listing 18 calls the <b>makePolyline</b> method to construct and return 
a reference to a node that describes a <b>polyline</b> element representing the 
four points whose coordinate values were used to populate the array object.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Create a polyline and rotate it. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Draw a polyline with four points.
      int[] polylinePoints = 
                         {10,235,210,235,110,275,110,225};
      Element polyline = SvgGraphics.<b>makePolyline</b>(
                                          document,
                                          g,//owner
                                          polylinePoints);
      
      //Rotate the polyline by 10 degrees around the first
      // point.
      polyline.<b>setAttribute</b>("transform",
                    "translate(" + polylinePoints[0] + ","
                    + polylinePoints[1] + ")" 
                    + "rotate(" + rotatePolyline + ")" 
                    + "translate(" + (-polylinePoints[0]) 
                    + "," + (-polylinePoints[1]) + ")");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Rotate the polyline around the first point</b></font></p>
<p>When the <b>makePolyline</b> method returns the reference to the polyline 
node, the code in Listing 18 calls the <b>setAttribute</b> method to rotate the 
entire polyline shape by ten degrees clockwise around the first point.&nbsp; 
Thus, the first line drawn for the polyline in Figure 1 has a general downward 
slope going from left to right.</p>
<p><font color="#FF0000"><b>What is a polygon?</b></font></p>
<p>The big difference between a <b>polyline</b> and a <b>polygon</b> is that a
<b>polygon</b> must always be a closed shape.&nbsp; As a result, once the <b>
polygon</b> points have been connected with straight lines in the same fashion 
as a <b>polyline</b>, the SVG rendering engine draws one additional line for a
<b>polygon</b> that connects the first and last points.&nbsp; This additional 
line always closes the shape.</p>
<p><font color="#FF0000">
<b>Create a polygon and dress it up</b></font></p>
<p>Listing 19 calls the <b>makePolygon</b> method to create a <b>polygon</b> 
node using a set of points similar to those used earlier to create the <b>
polyline</b> node.&nbsp; However, the <b>polygon</b> is not subsequently 
rotated as was the case with the polyline.&nbsp; Rather, the <b>setAttribute</b> method is called on the reference 
to the <b>polygon</b> node three times in succession to give the <b>polygon</b> 
a red border that is three pixels thick, and to fill the <b>polygon</b> with the 
solid color green.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Create a polygon and dress it up. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Draw a polygon with four points. Give it a red
      // border and fill it with green.
      int[] polygonPoints = 
                         {10,335,210,335,110,375,110,325};
      Element polygon = SvgGraphics.<b>makePolygon</b>(
                                           document,
                                           g,//parent
                                           polygonPoints);
      polygon.setAttribute("fill","green");
      polygon.setAttribute("stroke","red");
      polygon.setAttribute("stroke-width","3");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The green and red polygon is shown at the bottom of Figure 1.</p>
<p><font color="#FF0000">
<b>Create a wide, green, partially transparent line</b></font></p>
<p>Listing 20 calls the <b>makeLine</b> method to create a <b>line</b> node that 
extends from the upper-left corner of the canvas to the lower-right corner of 
the canvas.&nbsp; By default, this would be a black line one pixel wide.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Create a wide, green, partially 
transparent line. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      Element line = SvgGraphics.<b>makeLine</b>(document,
                                          g,   //owner
                                          0,   //x1
                                          0,   //y1
                                          220, //x2
                                          440);//y2
      line.setAttribute("stroke","green");
      line.setAttribute("stroke-width","12");
      line.setAttribute("stroke-opacity","0.6");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 20 calls the <b>setAttribute</b> method three times in 
succession to:</p>
<ul>
	<li>Set the color of the line to green.</li>
	<li>Set the width of the line to twelve pixels.</li>
	<li>Set the opacity of the line to 0.6 or 60-percent.&nbsp; <i>(You could 
	also say that the line is 40-percent transparent.)</i></li>
</ul>
<p>Because the line is the last shape to be drawn on the canvas in Figure 1, 
it is drawn on top of the other shapes.&nbsp; However, because the opacity of 
the line is 0.6 <i>(as opposed to 1.0)</i>, it is partially transparent and the 
other shapes that are behind the line show through the line.</p>
<p><font color="#FF0000"><b>Wrap the SVG code in XHTML data</b></font></p>
<p>At this point, a DOM tree that represents the SVG code for the graphic image 
shown in Figure 1 has been constructed.&nbsp; The remaining code in the class is used to transform the DOM tree into SVG code and to wrap 
the SVG code in a document that would otherwise be a valid XHTML document.&nbsp; 
This process begins in Listing 21 and becomes recursive later on.</p>
<p>Listing 21 begins by instantiating an object of the class.&nbsp; Then it gets 
an output stream that will be used to write the XHTML data and the SVG data into 
an output file named <b>junk.xhtml</b>.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Get an output stream to write the XHTML 
file. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Instantiate an object of this class
      Svg03 thisObj = new Svg03();

      //Get an output stream for the output produced by
      // the program code.
      PrintWriter out = new PrintWriter(
                      new FileOutputStream("<b>junk.xhtml</b>"));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Process the DOM tree</b></font></p>
<p>The last executable statement in the <b>main</b> method is shown in Listing 
22.&nbsp; This statement calls the method 
named <b>processDocumentNode</b> passing a reference to the output stream and a 
reference to the <b>Document</b> node of the DOM tree as parameters.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Process the DOM tree. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      thisObj.<b>processDocumentNode</b>(out,document);

    }catch(Exception e){
      //Note that no effort was made to provide meaningful
      // information in the event of an exception or
      // error.
      e.printStackTrace(System.err);
    }//end catch

  }// end main()</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>An XHTML output file is required</b></font></p>
<p>If you have studied the two previous lessons in this series <i>(see
<a href="#Resources">Resources</a>)</i>, you will recall that the sample 
programs in those lessons produced SVG files as the main output from the 
program.&nbsp; Those programs didn't attempt to create XHTML 
files.&nbsp; You will also recall that the programming task was relatively easy 
at this point in the program because JAXP methods already exist to do transform 
the DOM tree into raw XML code.&nbsp; Unfortunately, things 
aren't quite so easy when the program is required to produce an XHTML file as 
its output.&nbsp; 
There is a lot of programming that you are responsible for providing in this 
case.</p>
<p><font color="#FF0000"><b>XHTML text is required</b></font></p>
<p>There is quite a lot of XML text that is required to cause a file to qualify 
as a valid XHTML file.&nbsp; I won't go into the reasons for that text because 
that is beyond the scope of this tutorial series.&nbsp; However, I will show you 
how to write the code to create the text.</p>
<p><font color="#FF0000">
<b>The processDocumentNode method</b></font></p>
<p>The <b>processDocumentNode</b> method is used to produce the XML text that is required in the output at the document level,
<i>(such as the XML declaration)</i>.&nbsp; The method also produces the top level element tags.</p>
<p>The <b>processDocumentNode</b> method is shown in its entirety in Listing 23.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. The processDocumentNode method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre> 
  void <b>processDocumentNode</b>(PrintWriter out,Node node){
    //Create the beginning of the XHTML document.
    out.println("&lt;?xml version=\"1.0\" "
                       + "encoding=\"UTF-8\"?&gt;");
    out.println(
          "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD "
             + "XHTML 1.0 Transitional//EN\" "
             + "\"http://www.w3.org/TR/xhtml1/"
             + "DTD/xhtml1-transitional.dtd\"&gt;");

    out.println(SvgGraphics.makeElement(false,"html",
      new String[]{"xmlns","http://www.w3.org/1999/xhtml",
                   "xml:lang","en",
                   "name","lang"
                  })//end call to makeElement
    );//end println

    out.println("&lt;head&gt;");
    
    out.println(SvgGraphics.makeElement(
               true,
               "meta",
               new String[]{"http-equiv","content-type",
                            "content",
                            "image/svg+xml; charset=UTF-8"
                           })//end call to makeElement
    );//end println
  
    out.println("&lt;title&gt;Generated XHTML file&lt;/title&gt;");

    out.println("&lt;/head&gt;");
    
    out.println(SvgGraphics.makeElement(
                 false,
                 "body",
                 new String[]{"id","body",
                              "style","position:absolute;"
                              + "z-index:0;"
                              + "border:1px solid black;"
                              + "left:0;"
                              + "top:0;"
                              + "width:220px;"
                              + "height:440px;"
                             })//end call to makeElement
    );//end println

    //Go process the root (document) node. This method
    // call triggers a recursive process that will 
    //process the entire DOM tree.
    <b>processNode(out,node);</b>

    //The entire DOM tree has been processed when control
    // returns to this point.
    //Now finish the output document and flush the output
    // buffer.

    out.println("&lt;/body&gt;&lt;/html&gt;");
    out.flush();
  }//end processDocumentNode</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<p><font color="#FF0000"><b>Behavior of the processDocumentNode method</b></font></p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The makeElement method</b><br />
  Recall from the earlier lesson that the purpose of the makeElement method is 
	simply to make it easier to construct strings representing XML elements that 
	contain a lot of attribute values surrounded by quotation marks.
</td></tr></table>
</td>
</tr>
</table>

<p>The behavior of the <b>processDocumentNode</b> method is pretty 
straightforward and shouldn't require a lot of explanation beyond the embedded 
comments.</p>
<p>Down to the point where the method makes a recursive call to the 
method named <b>processNode</b>, the code in the method consists simply of print statements 
and calls to the <b>makeElement</b> method.</p>
<p><font color="#FF0000">
<b>The call to the processNode method</b></font></p>
<p>The call to the <b>processNode</b> method near the end of the <b>processDocumentNode</b> 
method is where the recursive processing of the DOM tree begins in earnest.&nbsp;
<i>(The <b>processNode</b> method is passed a reference to the output stream 
along with a reference to the root node of the DOM tree at this point.)</i></p>
<p>When control returns to the <b>processDocumentNode</b> method from the call 
to the <b>processNode</b> method in Listing 23, the entire DOM tree will have been processed 
recursively.&nbsp; At that point, one more print statement is executed to put 
the final string of XML text into the output file.&nbsp; Then the output buffer 
is flushed, the <b>processDocumentNode</b> method terminates, and the program 
terminates leaving an XHTML file named <b>junk.xhtml</b> in the current 
directory.</p>
<p><font color="#FF0000"><b>The processNode method</b></font></p>
<p>A general DOM tree could contain any of the following seven types of nodes:</p>
<ul>
	<li>root or document </li>
	<li>element </li>
	<li>attribute </li>
	<li>text </li>
	<li>comment </li>
	<li>processing instruction </li>
	<li>namespace</li>
</ul>
<p>A general purpose DOM tree processor would have to be capable of handling any 
combination of the seven types of nodes in the above list.&nbsp; However, because the nodes in 
this DOM tree are produced by the program, it is known in advance which types of 
nodes will be encountered.&nbsp; Therefore, the <b>processNode</b> method only 
handles element nodes, attribute nodes, and document nodes.</p>
<p><font color="#FF0000">
<b>Beginning of the recursive processNode method</b></font></p>
<p>The recursive <b>processNode</b> method begins in Listing 24.&nbsp; The code in Listing 
24 is straightforward.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Beginning of the recursive processNode method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>processNode</b>(PrintWriter out,Node node){
    try{
      if (node == null){
        System.out.println("Nothing to do, node is null");
        return;
      }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Process nodes according to their type</b></font></p>
<p>Each time the <b>processNode</b> method is called, it receives an incoming 
parameter that specifies the node from the DOM tree that is to be processed 
recursively.&nbsp; 
Each node is processed according to its type.&nbsp; A <b>switch</b> statement is 
used to select among the different types.</p>
<p><font color="#FF0000">
<b>Process nodes of type ELEMENT_NODE</b></font></p>
<p>Listing 25 shows the code that is executed to process nodes of type <b>
ELEMENT_NODE</b>.</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Process nodes of type ELEMENT_NODE.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
      int type = node.getNodeType();
      <b>switch</b>(type){
        case Node.<b>ELEMENT_NODE</b>:{
          
          //Start creating the start tag.
          String nodeName = node.getNodeName();
          out.print("&lt;" + nodeName + " ");
          
          //Now add each attribute to the start tag.
          NamedNodeMap theList = node.<b>getAttributes</b>();
          int length = theList.getLength();
          for(int cnt = 0;cnt &lt; length;cnt++){
            Node item = theList.item(cnt);
            out.print(item.getNodeName() + "=\"" 
                           + item.getNodeValue() + "\" ");
          }//end for loop
          out.println("&gt;");//close the start tag.
          
          //Process all XML child nodes recursively.
          <b>processChildNodes(out,node);</b>
          
          //The element and all of its children have been
          // processed when control returns to this point.
          //Create the end tag for the element.
          out.println("&lt;/" + nodeName + "&gt;");
            
          break;
        }//end case ELEMENT_NODE</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Create the beginning of the element start tag</b></font></p>
<p>The code in Listing 25 begins by creating the XML text that constitutes the 
beginning of the start tag for an XML element consisting of &quot;&lt;nodeName &quot;.</p>
<p><font color="#FF0000"><b>Process each attribute</b></font></p>
<p>Then Listing 25 uses a <b>for</b> loop to:</p>
<ul>
	<li>Get each attribute belonging to the node</li>
	<li>Construct an 
XML text string in the proper syntax for the name and value of the attribute</li>
	<li>Concatenate the newly-constructed text string onto the start tag</li>
</ul>
<p><font color="#FF0000"><b>Finish the start tag</b></font></p>
<p>When all attributes belonging to the node have been processed, the <b>for</b> 
loop terminates and an angle 
bracket is appended to the element start tag.&nbsp; At this point, a start tag looking 
something like the following has been sent to the output stream:</p>
<p><pre>&lt;elementName attrName="attrValue" attrName="attrValue"&gt;</pre></p>
<p><font color="#FF0000"><b>Process the child nodes</b></font></p>
<p>Before creating the element's end tag, it is necessary to process any child 
nodes belonging to the node that is being processed.&nbsp; This is accomplished 
by making a call to the recursive method named <b>processChildNodes</b>.</p>
<p><font color="#FF0000"><b>Construct the end tag</b></font></p>
<p>When 
control returns from the recursive <b>processChildNodes</b> method, the entire DOM 
sub-tree below the current node will have been processed.&nbsp; The code in Listing 25:</p>
<ul>
	<li>Constructs the end tag for the element</li>
	<li>Sends it to the output stream</li>
	<li>Breaks out of the <b>switch</b> statement to return control to the method from which 
	the <b>processNode</b> method was called</li>
</ul>
<p><font color="#FF0000"><b>Put switch statement on the back burner</b></font></p>
<p>At this point, I am going to put the <b>switch</b> statement in Listing 25 on 
the back burner, and continue explaining the processing of nodes of 
type <b>ELEMENT_NODE</b>.</p>
<p>As mentioned above, before creating the text for 
the element's end tag and sending it to the output, the code in Listing 25 calls 
the recursive method named <b>processChildNodes</b>, passing a reference to the node 
currently being processed, along with a reference to the output stream as 
parameters.&nbsp; The purpose is to recursively process all of the child nodes 
belonging to the node that is currently being processed.</p>
<p><font color="#FF0000">
<b>The recursive processChildNodes method</b></font></p>
<p>The <b>processChildNodes</b> method is shown in its entirety in Listing 26.</p>
<p>
<b><a name="Listing_26">Listing 26</a>. The recursive processChildNodes method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>processChildNodes</b>(PrintWriter out,Node node){
    NodeList children = node.getChildNodes();
    if (children != null){
      int len = children.getLength();
      //Iterate on NodeList of child nodes.
      for(int i = 0; i &lt; len; i++){
        //This is a recursive call.
        <b>processNode</b>(out,children.item(i));
      }//end for loop
    }//end if children != null

  }//end processChildNodes</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Recursive processing</b><br />
  If you are unfamiliar with recursive processing algorithms, this may seem like 
	black magic to you.&nbsp; In that case, just trust me that it works, and 
	then embark on an effort to gain an understanding of recursive algorithms.
</td></tr></table>
</td>
</tr>
</table>

<font color="#FF0000"><b>Get a list of child nodes</b></font><p>The code in Listing 26 begins by getting a list of all the child nodes 
belonging to the node specified by the second incoming parameter.&nbsp; </p>
<p><font color="#FF0000"><b>Process each child node</b></font></p>
<p>Then it 
executes a <b>for</b> loop, calling the <b>processNode</b> method during each 
iteration of the loop and passing a child node's reference to the <b>
processNode</b> method.&nbsp; <i>(This causes the specified child node and all 
of its children to be processed recursively.)</i></p>
<p>When the <b>for</b> loop in Listing 26 terminates, all of the 
child nodes belonging to the node that was specified by the second incoming 
parameter will have been recursively processed, and the <b>processChildNodes</b> 
method returns control to the method from which it was called.</p>
<p>
<font color="#FF0000">
<b>The DOCUMENT_NODE case</b></font></p>
<p>That completes 
the explanation of the processing of nodes of type <b>ELEMENT_NODE</b> that 
began with the <b>switch</b> statement in Listing 25.&nbsp; There is another 
case in the <b>switch</b> statement, however, that hasn't been explained yet.&nbsp; 
That case is shown in Listing 27.</p>
<p>
<b><a name="Listing_27">Listing 27</a>. The DOCUMENT_NODE case. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        case Node.<b>DOCUMENT_NODE</b>:{
          //No action is required other than to process
          // the child nodes recursively.
          <b>processChildNodes</b>(out,node);
          break;
        }//end case DOCUMENT_NODE

      }//end switch

    }catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch
  }//end processNode(Node)</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
</p>
<p>Listing 27 shows the code that processes the incoming node to the <b>
processNode</b> method for the case where the type of the node is <b>
DOCMENT_NODE</b>.</p>
<p><font color="#FF0000"><b>Will occur only once</b></font></p>
<p>This case will occur only once at the beginning of the processing of the DOM 
tree because the DOM tree has only one document node.&nbsp; As indicated in the comments in Listing 27, no action is required 
for this case other than to assure that all of the child nodes of the document 
node are processed 
recursively.&nbsp; Therefore, the code in Listing 27 simply makes a call to the<b> 
processChildNodes</b> method passing a reference to the document node as a 
parameter.</p>
<p><font color="#FF0000"><b>The entire DOM tree will have been processed</b></font></p>
<p>When control returns from the call to <b>processChildNodes</b> in the <b>
DOCUMENT_NODE</b> case in Listing 27, the entire DOM tree will have been 
processed.&nbsp; At that point:</p>
<ul>
	<li>Control breaks out of the <b>switch</b> statement</li>
	<li>The <b>processNode</b> method returns to the method from which it was 
	called</li>
	<li>Control progresses up the call stack to the bottom of 
Listing 23 causing the final XML text to be written into the output stream and 
	causing the output buffer to be flushed</li>
</ul>
<p><font color="#FF0000"><b>The program terminates</b></font></p>
<p>Control then returns to the
<b>main</b> method in Listing 22.&nbsp; Since there is nothing more for the 
program to do in the <b>main</b> method, the program terminates at that point, 
leaving a new file named <b>junk.xhtml</b> in the current directory.</p>
<p><font color="#FF0000"><b>End of explanation for Svg03</b></font></p>
<p>And that ends the explanation of the program named <b>Svg03</b>.&nbsp; As 
indicated earlier, you will find a complete listing of all of the code discussed 
above, plus the code for my SVG graphics library class named <b>SvgGraphics</b> 
in Listing 30 near the end of the lesson.</p>
<h3><a name="The_program_named_Svg04">The program named Svg04</a></h3>
<p><font color="#FF0000"><b>Description of the program</b></font></p>
<p>This program demonstrates the rendering of SVG graphic content in a Firefox 1.5 
client browser that is produced by a servlet that is accessed by the browser.</p>
<p><font color="#FF0000"><b>Very similar to the previous program</b></font></p>
<p>Except for the fact that this program is a servlet that generates XHTML code 
as its output, and the previous program named <b>Svg03</b> is a desktop 
application that produces an output file containing XHTML code, the two programs 
are identical.</p>
<p>This program defines a servlet that first creates a DOM tree describing the 
graphic image in Figure 1, and then transforms that tree into corresponding SVG XML 
code for transmission to the client.</p>
<p><font color="#FF0000"><b>Not valid XHTML</b></font></p>
<p>The program wraps the SVG graphic 
code in code that would otherwise be valid XHTML code.&nbsp; However the inclusion of the 
SVG code prevents the code produced by the servlet from being valid XHTML because the SVG 
element names are not recognized by XHTML validator programs, such as the 
program at the following URL:</p>
<p>&nbsp;<a href="http://validator.w3.org/file-upload.html">http://validator.w3.org/file-upload.html</a> </p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>For testing, the servlet must be deployed on a 
servlet-compatible server and then accessed using an SVG-compatible browser, 
such as Firefox 1.5.&nbsp; On my system, the servlet can be tested by first copying 
it into the following directory on my Tomcat server:</p>
<p><pre>C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\classes</pre></p>
<p>Having copied the servlet onto the server and having started the server 
running, the servlet can be accessed and the SVG code can be rendered by 
accessing the servlet in Firefox using the following URL:</p>
<p><pre>http://localhost/servlet/Svg04</pre></p>
<p><font color="#FF0000"><b>What about Internet Explorer</b></font></p>
<p>As I mentioned earlier, I have not installed the SVG plug-in for IE6.&nbsp; Accessing the servlet using IE6 <i>(without an SVG plug-in installed)</i> 
simply causes the browser to request permission to save the output produced by 
the server in a local file.&nbsp; The file name that is recommended by IE6 is 
simply Svg04 with no extension.</p>
<p>Therefore, the program was tested using J2SE 5.0, Firefox 1.5.09, and 
jakarta-tomcat-5.0.27 running as a localhost server under WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As usual, I will discuss this program in servlets.&nbsp; However, because the 
code in this program is almost identical to the code in the earlier program 
named <b>Svg03</b>, I will only discuss the code that is different between the 
two.&nbsp; You can view the program named <b>Svg04</b> in its entirety in 
Listing 31 near the end of the lesson.</p>
<p>As you will see, the difference between the two programs is confined to two 
small sections of code.</p>
<p><font color="#FF0000">
<b>First section of different code</b></font></p>
<p>The first section of code that differs between the programs named <b>Svg03</b> 
and <b>Svg04</b> is shown in Listing 28.</p>
<p>
<b><a name="Listing_28">Listing 28</a>. First section of different code.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import javax.servlet.*;
import javax.servlet.http.*;

public class Svg04 <b>extends HttpServlet</b>{
  
  public void <b>doGet</b>(HttpServletRequest req,
                    HttpServletResponse res)
                    throws ServletException,
                                     IOException{
                                      
    //Note:  This statement is critical to causing
    // Firefox to recognize and render the SVG
    // code produced by the servlet.
    <b>res.setContentType("image/svg+xml");</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Additional import directives are required</b></font></p>
<p>First, because <b>Svg04</b> is a servlet program, it must declare the two 
import directives shown in Listing 28 <i>(or fully qualify the classes contained 
in those two packages when they are referenced in the program code.)</i>.</p>
<p><font color="#FF0000"><b>Extend HttpServlet class</b></font></p>
<p>Second, because <b>Svg04</b> is a servlet program, the class must extend the
<b>HttpServlet</b> class.</p>
<p><font color="#FF0000"><b>Define the doGet method</b></font></p>
<p>Third, because <b>Svg04</b> is a servlet program and not a desktop 
application, the <b>main</b> method in 
the desktop application named <b>Svg03</b> must be replaced by the method named <b>doGet</b> 
shown in Listing 28.</p>
<p><font color="#FF0000"><b>Set the content type</b></font></p>
<p>Fourth, the program must set the content 
type as shown in the last statement in Listing 28.</p>
<p><font color="#FF0000">
<b>Last section of different code</b></font></p>
<p>The last section of code that differs between the two programs is the single 
statement shown in 
Listing 29.</p>
<p>
<b><a name="Listing_29">Listing 29</a>. Last section of different code.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Get an output stream for the output produced by
      // the program code.
      PrintWriter out = res.getWriter();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>At this point in the program, the desktop application named <b>Svg03</b> instantiates a
<b>PrintWriter</b> output stream object based on a <b>FileOutputStream</b> object.&nbsp; 
That causes the output produced by the program to be written into a file named
<b>junk.svg</b>.</p>
<p>As you can see in Listing 29, the code required to get an appropriate output 
stream for a servlet is somewhat simpler.&nbsp; Output that is placed in the 
output stream by the servlet ends up at the client browser for rendering and 
display.</p>
<p><font color="#FF0000"><b>Those are the only differences between the two 
programs</b></font></p>
<p>Unless I missed something during my comparison of the two programs, the only 
differences between the two programs are shown in Listing 28 and Listing 29.</p>
<p>It is fortunate that the differences between the two programs are so few in 
number and so insignificant in content.&nbsp; Testing and debugging servlets can 
be a difficult task.&nbsp; However, in this case at least, the program can be 
developed, tested, and debugged as a stand alone Java application, and then 
converted to a servlet by making the small number of changes shown in Listing 28 
and Listing 29.</p>
<p>That ends the discussion and explanation of the program named <b>Svg04</b>.&nbsp; 
Once again, you can view the program in its entirety in Listing 31 near the end 
of the lesson.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 30 and Listing 31 into your text
editor, compile it, and execute it.&nbsp; Experiment with it, making
changes, and observing the results of your changes.&nbsp; Then view the results in 
Firefox 1.5, or some other suitable SVG rendering engine.&nbsp; Experiment with the 
code, making changes, and observing the results of your changes. </p>
<p>Above all, enjoy the process. Programming, particularly graphics programming can be fun.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you how to write Java code to produce XHTML files 
containing in-line SVG/XML code.&nbsp; I also taught you how to write servlets that 
produce XHTML output containing in-line SVG/XML code.</p>
<p>An SVG program was developed, tested, and debugged as a stand-alone desktop 
application that produced an output XHTML file to produce the image shown in 
Figure 1.</p>
<p>Then that desktop application was converted to a servlet program by making 
the following five changes to the code in the desktop application:</p>
<ol>
	<li>Declare the following import directives:
	<pre>
  import javax.servlet.*;
  import javax.servlet.http.*;</pre></li>
	<li>Define the main class to extend the <b>HttpServlet</b> class.</li>
	<li>Replace the signature for the <b>main</b> method in the desktop 
	application with the signature for the <b>doGet</b> 
	method in the servlet program:<pre>
  public void doGet(HttpServletRequest req,
                    HttpServletResponse res)
                           throws ServletException,
	                          IOException{</pre></li>
	<li>Execute the following statement to set the content type:
	<pre>  res.setContentType(&quot;image/svg+&quot;);</pre></li>
	<li>Execute the following statement to get an output stream:
	<pre>  PrintWriter out = res.getWriter();</pre></li>
</ol>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The next lesson in this series will teach you how to write servlets that 
produce XHTML output containing references to external SVG files.&nbsp; Those 
SVG files may be created on-the-fly during the execution of the servlet.</p>
<p>Future lessons will teach you how to write servlets that:</p>
<ul>
	<li>Deal with the following graphics elements:</li>
	<ul><li>path</li>
		<li>text</li>
		<li>image <i>(Deal with bit-mapped images in SVG.)</i></li>
		<li>use <i>(Create and re-use graphics elements.)</i></li>
	</ul>
	<li>Use SVG <i>symbols</i>.</li>
	<li>Deal with stroke caps in SVG in comparison with similar caps in Java 2D.</li>
	<li>Use the <i>switch</i> element in SVG.</li>
	<li>Deal with other features of SVG, such as animation.</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
30 and Listing 31 below.
<p>
<b><a name="Listing_30">Listing 30</a>. Program code for Svg03 </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg03.java
Copyright 2006 R.G.Baldwin

The main purpose of this program is to illustrate the 
inclusion of SVG graphics in an XHTML file that can be 
rendered in Firefox 1.5.

This program uses an SVG graphic library that has been
significantly improved over the one used in the earlier 
program named Svg02.  The library now supports the 
following basic shapes plus linear and radial gradients
and dozens of attributes and transforms on each shape.

rect
circle
ellipse
line
polyline
polygon

These are all of the basic shapes provided by SVG.

The library also contains some convenience methods for 
creating elements, nodes, and blocks of code.  These
convenience methods are designed to reduce the labor 
required to write programs such as this one.

This program creates a DOM tree describing the SVG code 
for a particular graphic image.  Then it transforms the 
DOM tree into SVG code that is wrapped in a file that 
would otherwise be a valid XHTML file.  Inclusion of the 
SVG code, however, prevents the code from being valid 
XHTML because the SVG element names are not recognized 
by XHTML validator programs, such as the program at the 
following URL:

http://validator.w3.org/file-upload.html

The capability demonstrated in this program is a 
precursor to being able to create inline SVG code in a 
servlet and to cause that SVG code to be rendered in a 
Firefox browser that accesses the servlet.

(As you will see, creating an XHTML file is a good bit 
more difficult than creating an SVG file as was done
in the earlier program named Svg02.java.)

The output file produced by this program can be rendered 
by loading it directly into Firefox 1.5.

Tested using J2SE 5.0, Firefox v1.5.0.8, and WinXP.
*********************************************************/

import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;

public class Svg03{

  public static void main(String argv[]){
    
    //The following data values will be used to create
    // SVG graphics.
    int ellipseCenterX = 110;
    int ellipseCenterY = 100;
    int ellipseWidth = 100;
    int ellipseHeight = 40;
    int ellipseRotate = 15;//degrees
    
    int circleCenterX = 110;
    int circleCenterY = 100;
    int circleRadius = 30;
    int circleRotate = 15;

    int rectCenterX = 110;
    int rectCenterY = 200;
    int rectWidth = 110;
    int rectHeight = 80;
    int rectRoundX = 26;
    int rectRoundY = 25;
    
    int rotatePolyline = 10;
    
    
    try{
      //Create a DOM tree that describes a particular
      // graphic image.
      //Begin by creating a Document object and a root
      // node named svg.  All of the graphic content will
      // be contained in the svg element. This code was
      // explained in the earlier program named
      // Xslt01.java that was explained in lesson 2202
      // named "Getting Started with Java JAXP and XSL
      // Transformations (XSLT)".
      
      //At this point, the program starts using the 
      // SVG graphics library encapsulated in the class
      // named SvgGraphics.
      Document document = SvgGraphics.getDocument();      

      //Create the root node named svg and append it to
      // the document.
      //Set some attributes on the root node that are
      // required for proper rendering.
      Element svg = SvgGraphics.makeNode(
        document,
        null,//parent could be null
        "svg",//node type
        new String[]{"xmlns","http://www.w3.org/2000/svg",
                     "version","1.1",
                     "width","220px",
                     "height","440px",
                     "position","static",
                     "top","0",
                     "left","0"
                    });//end call to makeNode

      //Show outline of canvas using 'rect' element
      Element outline = SvgGraphics.makeNode(
                     document,
                     svg,//parent could be null
                     "rect",//node type
                     new String[]{"x","0",
                                  "y","0",
                                  "width","220",
                                  "height","440",
                                  "fill","none",
                                  "stroke","black",
                                  "stroke-width","1"
                                 });//end call to makeNode

      //Create a node named defs, which will be the parent
      // for three gradient definitions.  There will be 
      // two linear gradients and one radial gradient.
      // Pass null for the reference to the object for the
      // special case where the node has no attributes.
      Element defs = SvgGraphics.makeNode(document,
                                          svg,//parent
                                          "defs",
                                          null);

      //Create nodes that define three different gradient
      // coloring schemes.
      //The definitions are identified as gradientA,
      // gradientB, and gradientC.  They will be referred
      // to later to specify the fill colors for an 
      // ellipse, a circle, and a rounded rectangle.

      //Define gradientA, which provides a linear
      // gradient from yellow to red to blue going from
      // left to right.
      Element gradientA = SvgGraphics.makeLinearGradient(
                              document,    //this document
                              defs,        //parent
                              "gradientA");//id
      //Create three stop nodes that identify the colors
      // used to produce the gradient and specify where
      // the colors begin and end, 
      SvgGraphics.makeGradientStop(document,
                                   gradientA,//parent
                                   "2%",     //start here
                                   "yellow");//color
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientA,
                                   "50%",
                                   "red");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientA,
                                   "98%",
                                   "blue");
      
      //Define gradientB, which provides a linear
      // gradient having two stops from green to blue
      // going from left to right.
      Element gradientB =SvgGraphics.makeLinearGradient(
                             document,    //this document
                             defs,        //parent
                             "gradientB");//id
                   
      SvgGraphics.makeGradientStop(document,
                                   gradientB,//parent
                                   "0%",     //start here
                                   "green"); //color
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientB,
                                   "100%",
                                   "blue");
                                     
      //Define gradientC, which provides a radial
      // gradient from yellow to red to blue going from
      // the center to the outer edge.
      Element gradientC = 
                 SvgGraphics.makeRadialGradient(
                   document,        //this document
                   defs,            //parent
                   "gradientC",     //ID
                   "userSpaceOnUse",
                   rectCenterX,     //cx
                   rectCenterY,     //cy
                   rectWidth/2);    //r
                   
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "0%",
                                   "yellow");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "50%",
                                   "red");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "100%",
                                   "blue");
                                   
      //Create a node named g, which will be the parent
      // for an ellipse,a circle, a rectangle, a line,
      // a polyline, and a polygon. Pass null for the
      // reference to the object for the special case
      // where the node has no attributes.
      Element g = SvgGraphics.makeNode(document,
                                       svg,//parent
                                       "g",
                                       null);

      //Create an ellipse with a blue border that is two
      // pixels wide. Fill it with the yellow-red-blue
      // gradient defined by gradientA.
      Element theEllipse = SvgGraphics.makeEllipse(
                             document,
                             g,//Owner
                             ellipseCenterX,
                             ellipseCenterY,
                             ellipseWidth,
                             ellipseHeight);
      //Set the appearance of the ellipse.
      theEllipse.setAttribute("fill","url(#gradientA)");
      theEllipse.setAttribute("stroke","blue");
      theEllipse.setAttribute("stroke-width","2");
      //Rotate the ellipse by 15-degrees clockwise about
      // its center.
      theEllipse.setAttribute("transform",
                  "translate(" + ellipseCenterX + "," 
                  + ellipseCenterY + ") "
                  + "rotate(" + ellipseRotate + ") "
                  + "translate(" + (-ellipseCenterX) + ","
                  + (-ellipseCenterY) + ") ");

      //Position a circle so that it appears to be inside
      // the ellipse.  Fill it with the green-blue
      // gradient defined by gradientB.
      Element theCircle = SvgGraphics.makeCircle(
                            document,
                            g,//Owner
                            circleCenterX,
                            circleCenterY,
                            circleRadius);
      //Set the appearance of the circle and rotate it by
      // 15-degrees clockwise about its center.
      theCircle.setAttribute("fill","url(#gradientB)");
      theCircle.setAttribute("transform",
                   "translate(" + circleCenterX + "," 
                   + circleCenterY + ") "
                   + "rotate(" + circleRotate + ") "
                   + "translate(" + (-circleCenterX) + ","
                   + (-circleCenterY) + ") ");

      //Make a rounded rectangle and fill it with
      // gradientC
      Element theRect = SvgGraphics.makeRect(
                            document,
                            g,//Owner
                            rectCenterX - rectWidth/2,//x
                            rectCenterY - rectHeight/2,//y
                            rectWidth,
                            rectHeight);

      theRect.setAttribute("fill","url(#gradientC)");

      //Round the corners.
      theRect.setAttribute("rx",""+ rectRoundX);
      theRect.setAttribute("ry",""+ rectRoundY);

      //Draw a polyline with four points.
      int[] polylinePoints = 
                         {10,235,210,235,110,275,110,225};
      Element polyline = SvgGraphics.makePolyline(
                                          document,
                                          g,//owner
                                          polylinePoints);
      
      //Rotate the polyline by 10 degrees around the first
      // point.
      polyline.setAttribute("transform",
                    "translate(" + polylinePoints[0] + ","
                    + polylinePoints[1] + ")" 
                    + "rotate(" + rotatePolyline + ")" 
                    + "translate(" + (-polylinePoints[0]) 
                    + "," + (-polylinePoints[1]) + ")");
      
      //Draw a polygon with four points. Give it a red
      // border and fill it with green.
      int[] polygonPoints = 
                         {10,335,210,335,110,375,110,325};
      Element polygon = SvgGraphics.makePolygon(
                                           document,
                                           g,//parent
                                           polygonPoints);
      polygon.setAttribute("fill","green");
      polygon.setAttribute("stroke","red");
      polygon.setAttribute("stroke-width","3");
      
      //Draw a green line 12 pixels wide.  Make the line
      // 60% opaque, or 40% transparent, whichever you
      // prefer.
      Element line = SvgGraphics.makeLine(document,
                                          g,   //owner
                                          0,   //x1
                                          0,   //y1
                                          220, //x2
                                          440);//y2
      line.setAttribute("stroke","green");
      line.setAttribute("stroke-width","12");
      line.setAttribute("stroke-opacity","0.6");
      


      //The remaining code in this class is used to
      // transform the DOM tree into SVG code and to wrap
      // that code in a document that would otherwise be
      // a valid XHTML document.

      //Instantiate an object of this class
      Svg03 thisObj = new Svg03();

      //Get an output stream for the output produced by
      // the program code.
      PrintWriter out = new PrintWriter(
                      new FileOutputStream("junk.xhtml"));

      //Process the DOM tree, beginning with the Document
      // node to produce the output.
      //The invocation of processDocumentNode starts a
      // recursive process that will process the entire
      // DOM tree.
      thisObj.processDocumentNode(out,document);

    }catch(Exception e){
      //Note that no effort was made to provide meaningful
      // information in the event of an exception or
      // error.
      e.printStackTrace(System.err);
    }//end catch

  }// end main()
  //----------------------------------------------------//

  //This method is used to produce the text required in
  // the output at the document level, such as the
  // XML declaration.  It also produces the top level
  // element tags. 
  void processDocumentNode(PrintWriter out,Node node){
    //Create the beginning of the XHTML document.
    out.println("&lt;?xml version=\"1.0\" "
                       + "encoding=\"UTF-8\"?&gt;");
    out.println(
          "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD "
             + "XHTML 1.0 Transitional//EN\" "
             + "\"http://www.w3.org/TR/xhtml1/"
             + "DTD/xhtml1-transitional.dtd\"&gt;");

    out.println(SvgGraphics.makeElement(false,"html",
      new String[]{"xmlns","http://www.w3.org/1999/xhtml",
                   "xml:lang","en",
                   "name","lang"
                  })//end call to makeElement
    );//end println

    out.println("&lt;head&gt;");
    
    out.println(SvgGraphics.makeElement(
               true,
               "meta",
               new String[]{"http-equiv","content-type",
                            "content",
                            "image/svg+xml; charset=UTF-8"
                           })//end call to makeElement
    );//end println
  
    out.println("&lt;title&gt;Generated XHTML file&lt;/title&gt;");

    out.println("&lt;/head&gt;");
    
    out.println(SvgGraphics.makeElement(
                 false,
                 "body",
                 new String[]{"id","body",
                              "style","position:absolute;"
                              + "z-index:0;"
                              + "border:1px solid black;"
                              + "left:0;"
                              + "top:0;"
                              + "width:220px;"
                              + "height:440px;"
                             })//end call to makeElement
    );//end println

    //Go process the root (document) node. This method
    // call triggers a recursive process that will 
    //process the entire DOM tree.
    processNode(out,node);

    //The entire DOM tree has been processed when control
    // returns to this point.
    //Now finish the output document and flush the output
    // buffer.

    out.println("&lt;/body&gt;&lt;/html&gt;");
    out.flush();
  }//end processDocumentNode
  //----------------------------------------------------//

  //There are seven kinds of nodes and most of them were
  // handled in the earlier program from which this
  // program was derived:
  
  // root or document
  // element
  // attribute
  // text
  // comment
  // processing instruction
  // namespace

  //However, because the nodes in this program are
  // produced by the program and it is known in advance
  // the types of nodes that will be encountered, this
  // program is less general than the earlier program.
  // Therefore, this method only handles element nodes
  // and document nodes.
  void processNode(PrintWriter out,Node node){
    try{
      if (node == null){
        System.out.println("Nothing to do, node is null");
        return;
      }//end if

      //Process the incoming node based on its type.
      int type = node.getNodeType();
      switch(type){
        case Node.ELEMENT_NODE:{
          
          //Start creating the start tag.
          String nodeName = node.getNodeName();
          out.print("&lt;" + nodeName + " ");
          
          //Now add each attribute to the start tag.
          NamedNodeMap theList = node.getAttributes();
          int length = theList.getLength();
          for(int cnt = 0;cnt &lt; length;cnt++){
            Node item = theList.item(cnt);
            out.print(item.getNodeName() + "=\"" 
                           + item.getNodeValue() + "\" ");
          }//end for loop
          out.println("&gt;");//close the start tag.
          
          //Process all XML child nodes recursively.
          processChildNodes(out,node);
          
          //The element and all of its children have been
          // processed when control returns to this point.
          //Create the end tag for the element.
          out.println("&lt;/" + nodeName + "&gt;");
            
          break;
        }//end case ELEMENT_NODE

        case Node.DOCUMENT_NODE:{
          //No action is required other than to process
          // the child nodes recursively.
          processChildNodes(out,node);
          break;
        }//end case DOCUMENT_NODE

      }//end switch

    }catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch
  }//end processNode(Node)
  //----------------------------------------------------//

  //This method is called to recursively process
  // the child nodes belonging to a specified
  // node.
  void processChildNodes(PrintWriter out,Node node){
    NodeList children = node.getChildNodes();
    if (children != null){
      int len = children.getLength();
      //Iterate on NodeList of child nodes.
      for(int i = 0; i &lt; len; i++){
        //This is a recursive call.
        processNode(out,children.item(i));
      }//end for loop
    }//end if children != null

  }//end processChildNodes
  //----------------------------------------------------//

}//End class Svg03
//======================================================//


//This is a proof-of-concept graphics class that
// provides method calls for the creation of the following
// DOM tree nodes:
//  A general node of any type
//  A linear gradient element.
//  A radial gradient element.
//  An ellipse.
//  A circle.
//  A rectangle.
//  A line.
//  A polyline.
//  A polygon.

//Each method receives a reference to the overall document
// along with a reference to the parent for the new node.
//When the method returns, the new node has been appended
// to the parent node.
class SvgGraphics{
  //----------------------------------------------------//

  //This method creates a linear gradient node to which
  // stop elements must be appended.
  static Element makeLinearGradient(Document document,
                                    Element parent,
                                    String id){
    Element gradient = 
        (Element)document.createElement("linearGradient");
    parent.appendChild(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient
  //----------------------------------------------------//
  
  //This method creates a radial gradient node to which
  // stop elements must be appended. Note that numeric
  // attributes are set as type String.
  static Element makeRadialGradient(Document document,
                                    Element parent,
                                    String id,
                                    String gradientUnits,
                                    int cx,
                                    int cy,
                                    int r){
    Element gradient = 
        (Element)document.createElement("radialGradient");
    parent.appendChild(gradient);
    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient
  //----------------------------------------------------//

  //This method creates a gradient stop node to be
  // appended to a linear gradient node or a radial
  // gradient node.                                      
  static Element makeGradientStop(Document document,
                                  Element parent,
                                  String location,
                                  String color){
    Element stopElement = 
                  (Element)document.createElement("stop");
    parent.appendChild(stopElement);
    stopElement.setAttribute("offset",location);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop
  //----------------------------------------------------//
  
  //This method returns a reference to an ellipse. The
  // xCoor and yCoor parameters specify the center of the
  // ellipse.  The xRadius and yRadius parameters specify
  // the width and height of the  ellipse respectively
  // while it is in the horizontal plane before being
  // rotated.  Numeric attributes are set at type String.
  static Element makeEllipse(Document document,
                             Element parent,
                             int xCoor,
                             int yCoor,
                             int xRadius,
                             int yRadius){
    Element ellipse  = 
               (Element)document.createElement("ellipse");
    parent.appendChild(ellipse);
    ellipse.setAttribute("cx",""+xCoor);
    ellipse.setAttribute("cy",""+yCoor);
    ellipse.setAttribute("rx",""+xRadius);
    ellipse.setAttribute("ry",""+yRadius);
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This method returns a reference to a circle. The
  // xCoor and yCoor parameters specify the center of the
  // circle.  The radius parameter specifies the radus of
  // the circle.  Numeric attributes are set as type
  // String.
  static Element makeCircle(Document document,
                            Element parent,
                            int xCoor,
                            int yCoor,
                            int radius){
    Element circle  = 
                (Element)document.createElement("circle");
    parent.appendChild(circle);
    circle.setAttribute("cx",""+xCoor);
    circle.setAttribute("cy",""+yCoor);
    circle.setAttribute("r",""+radius);
    return circle;
  }//end makeCircle
  //----------------------------------------------------//
  
  //This method returns a reference to a rectangle. The
  // xCoor and yCoor parameters specify the location of
  // the upper left corner.  The width and height
  // parameters specify the width and the height while
  // the rectangle is in the horizontal plane before
  // being rotated.  Numeric attributes are set as type
  // String.
  static Element makeRect(Document document,
                          Element parent,
                          int xCoor,
                          int yCoor,
                          int width,
                          int height){
    Element rect  = 
                  (Element)document.createElement("rect");
    parent.appendChild(rect);
    rect.setAttribute("x",""+xCoor);
    rect.setAttribute("y",""+yCoor);
    rect.setAttribute("width",""+width);
    rect.setAttribute("height",""+height);
    return rect;
  }//end makeRect
  
  //----------------------------------------------------//
  
  //This method returns a reference to a line. x1 and y1
  // specify the starting point of the line before it is
  // rotated. x2 and y2 specify the end point.  By
  // default, the stroke is set to black one pixel wide.
  // This can be overridden to speciy other colors and
  // other widths if you need to do so.
  static Element makeLine(Document document,
                          Element parent,
                          int x1,
                          int y1,
                          int x2,
                          int y2){
    Element line  = 
                  (Element)document.createElement("line");
    parent.appendChild(line);
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    return line;
  }//end makeLine
  //----------------------------------------------------//

  //This method returns a reference to a polyline. The
  // array of type int[] must contain an even number of
  // values for things to work correctly.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.  This can be overridden to other
  // colors and other widths if you need to do so.
  static Element makePolyline(Document document,
                              Element parent,
                              int[] points){
    Element polyline  = 
              (Element)document.createElement("polyline");
    parent.appendChild(polyline);

    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    
    polyline.setAttribute("points",dataPoints);
    polyline.setAttribute("stroke","black");
    polyline.setAttribute("stroke-width","1");
    polyline.setAttribute("fill","none");
    return polyline;
  }//end makePolyline
  //----------------------------------------------------//
  
  //This method returns a reference to a polygon. The
  // array of type int[] must contain an even number of
  // values for things to work correctly.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black, one pixel
  // wide with no fill.  This can be overridden to other
  // colors and other widths if you need to do so.
  //The major difference between a polygon and a polyline
  // is that a polyline leaves the last point dangling.
  // However, a polygon automatically draws a line from
  // the last point back to the first point to close
  // the polygon.
  static Element makePolygon(Document document,
                           Element parent,
                           int[] points){
    Element polygon  = 
               (Element)document.createElement("polygon");
    parent.appendChild(polygon);

    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    
    polygon.setAttribute("points",dataPoints);
    polygon.setAttribute("stroke","black");
    polygon.setAttribute("stroke-width","1");
    polygon.setAttribute("fill","none");
    return polygon;
  }//end makePolygon
  
  //----------------------------------------------------//
  
  /*
  One of the most frustrating things about using Java
   to create elements in XML, XHTML, or HTML is having
   to deal with the escape characters for the many
   required quotation marks. This method constructs an
   element, which may or may not have attributes. Also,
   the element may or may not be empty.
  The user of this method does not have to deal with the
   required quotation marks surrounding attribute values
   and the corresponding escape characters     
  The first incoming parameter must be true if the
   element is empty and false if the element is not
   empty.
  If the first parameter is true, the element is sealed
   off in the required manner for an empty element. If
   the first parameter is false, the method returns the
   complete start tag for the element but does not
   return a complete element. It is the responsibility
   of the calling method to provide the content and the
   end tag for the element.
  The second parameter to the method must be a String
   that specifies the name of the element.
  The third parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.

  If the reference to the array object is null and the
   first parameter is false, the method returns the start
   tag for an element that has no attributes and is not 
   empty.
  If the reference is null and the first parameter is
   true, the method returns a complete empty element with 
   no attributes (which probably doesn't make any sense).
   
  An example of the recommended usage of the method
   follows:
   
  String newElement = SvgGraphics.makeElement(
                  true/false,
                  name,
                  new String[]{"name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value"
                              });//end call to makeElement
   
  */
  
  static String makeElement(
          boolean empty,String elementName,String[] data){

    //Begin constructing the start tag.
    String element = "&lt;" + elementName + " ";
    
    //Deal with elements that have no attributes.
    if((empty==false)  &amp; &amp; (data == null)){
      //Return a complete start tag.
      return element + "&gt;";
    }else if((empty==true)  &amp; &amp; (data == null)){
      //Return a complete empty element.
      return element + "/&gt;";
    }//end if

    for(int cnt=0;cnt&lt;data.length;cnt+=2){

      String name = data[cnt];
      String value = data[cnt+1];
      element += name + "=" + "\"" + value + "\" ";
    }//end for loop
    
    if(empty){
      //Terminate the element appropriately for an
      // empty element. A complete empty element will
      // be returned.
      element += "/&gt;";
    }else{
      //End the start tag for an element that is not
      // empty. In this case, only the start tag will
      // be returned.  The calling program must provide
      // the content for the element as well as the end
      // tag for the element.
      element += "&gt;";
    }//end else
      
  return element;
  }//end makeElement
  //----------------------------------------------------//
  
  /*
  The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
   
  The first parameter is a reference to the document to
   which the new node belongs.
  
  The second parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node. If this parameter is null, the new
   node is appended to the document.  Otherwise, it is
   appended to the specified parent node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
  
  An example of the recommended usage of the method
   follows:
  Element abc = SvgGraphics.makeNode(
                     document,
                     def,//parent could be null
                     "ghi",//node type
                     new String[]{"name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value"
                                 });//end call to makeNode
  */
  static Element makeNode(Document document,
                                Element parent,
                                String nodeType,
                                String[] data){
  
    Element element = 
                (Element)document.createElement(nodeType);
    
    if(parent == null){
      //For the special case of parent equal to null,
      // append the new node to the document.
      document.appendChild(element);
    }else{
      //Otherwise, append the new node to the specified
      // parent.
      parent.appendChild(element);
    }//end else
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//
  
  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced.
  static Document getDocument(){
    Document document = null;
    try{
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      document = builder.newDocument();
      document.setXmlStandalone(false);
    }catch(Exception e){
      e.printStackTrace(System.err);
      System.exit(0);
    }//end catch
    return document;
  }//end getDocument
  //----------------------------------------------------//
}//end class SvgGraphics</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_31">Listing 31</a>. Program code for Svg04. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Svg04.java,
Copyright 2006, R.G.Baldwin

This program demonstrates the rendering of graphic content
on a Firefox 1.5 client by way of the generation of SVG 
code in a servlet on the server.

Except for the fact that this program is a servlet that
generates XHTML code in its output, and the earlier
program named Svg03 is a desktop application that produces
an output file containing XHTML code, the two programs
are identical.

This program uses an SVG graphic library that has been
significantly improved over the one used in the earlier 
program named Svg02.  The library now supports the 
following basic shapes plus linear and radial gradients
and dozens of attributes on each shape.

rect
circle
ellipse
line
polyline
polygon

These are all of the basic shapes provided by SVG.

The program defines a servlet that first creates a DOM
tree describing a specific graphic image, and then
transforms that tree into corresponding SVG XML code for
transmission to the client. The program wraps the SVG
graphic code in code that would otherwise be valid XHTML
code.  Inclusion of the SVG code, however, prevents the
code from being valid XHTML because the SVG element names
are not recognized by XHTML validator programs, such as
the program at the following URL:

http://validator.w3.org/file-upload.html

This program can only be tested by deploying the servlet
on a servlet-compatible server and then accessing it 
using an SVG-compatible browser, such as Firefox 1.5.

On my system, the servlet can be executed by copying it
into the following directory on the Tomcat server and
accessing it from Firefox using the URL shown below:

C:\jakarta-tomcat-5.0.27\webapps\ROOT\WEB-INF\classes

http://localhost/servlet/Svg04

Accessing the servlet using IE 6 (without an SVG plug-in
installed) simply causes the browser to request permission
to save the output produced by the server in a local file.
The file name that is recommended by the browser is simply
Svg04 with no extension.

Tested using J2SE 5.0, Firefox 1.5.08, and 
jakarta-tomcat-5.0.27 running as a localhost server under
WinXP.
*********************************************************/

import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Svg04 extends HttpServlet{
  
  public void doGet(HttpServletRequest req,
                    HttpServletResponse res)
                    throws ServletException,
                                     IOException{
                                      
    //Note:  This statement is critical to causing
    // Firefox to recognize and render the SVG
    // code produced by the servlet.
    res.setContentType("image/svg+xml");

    //The following data values will be used to create
    // SVG graphics.
    int ellipseCenterX = 110;
    int ellipseCenterY = 100;
    int ellipseWidth = 100;
    int ellipseHeight = 40;
    int ellipseRotate = 15;//degrees
    
    int circleCenterX = 110;
    int circleCenterY = 100;
    int circleRadius = 30;
    int circleRotate = 15;

    int rectCenterX = 110;
    int rectCenterY = 200;
    int rectWidth = 110;
    int rectHeight = 80;
    int rectRoundX = 26;
    int rectRoundY = 25;
    
    int rotatePolyline = 10;
    
    try{
      //Create a DOM tree that describes a particular
      // graphic image.
      //Begin by creating a Document object and a root
      // node named svg.  All of the graphic content will
      // be contained in the svg element. This code was
      // explained in the earlier program named
      // Xslt01.java that was explained inlesson 2202
      // named "Getting Started with Java JAXP and XSL
      // Transformations (XSLT)".
      
      //At this point, the program starts using the 
      // SVG graphics library encapsulated in the class
      // named SvgGraphics.
      Document document = SvgGraphics.getDocument();      

      //Create the root node named svg and append it to
      // the document.
      //Set some attributes on the root node that are
      // required for proper rendering.
      Element svg = SvgGraphics.makeNode(
        document,
        null,//parent could be null
        "svg",//node type
        new String[]{"xmlns","http://www.w3.org/2000/svg",
                     "version","1.1",
                     "width","220px",
                     "height","440px",
                     "position","static",
                     "top","0",
                     "left","0"
                    });//end call to makeNode
      
      //Show outline of canvas using 'rect' element
      Element outline = SvgGraphics.makeNode(
                     document,
                     svg,//parent could be null
                     "rect",//node type
                     new String[]{"x","0",
                                  "y","0",
                                  "width","220",
                                  "height","440",
                                  "fill","none",
                                  "stroke","black",
                                  "stroke-width","1"
                                 });//end call to makeNode

      //Create a node named defs, which will be the parent
      // for three gradient definitions.  There will be 
      // two linear gradients and one radial gradient.
      // Pass null for the reference to the object for the
      // special case where the node has no attribtes.
      Element defs = SvgGraphics.makeNode(document,
                                          svg,//parent
                                          "defs",
                                          null);

      //Create nodes that define three different gradient
      // coloring schemes.
      //The definitions are identified as gradientA,
      // gradientB, and gradientC.  They will be referred
      // to later to specify the fill colors for an 
      // ellipse, a circle, and a rounded rectangle.

      //Define gradientA, which provides a linear
      // gradient from yellow to red to blue going from
      // left to right.
      Element gradientA = SvgGraphics.makeLinearGradient(
                              document,    //this document
                              defs,        //parent
                              "gradientA");//id
      //Create three stop nodes that identify the colors
      // used to produce the gradient and specify where
      // the colors begin and end, 
      SvgGraphics.makeGradientStop(document,
                                   gradientA,//parent
                                   "2%",     //start here
                                   "yellow");//color
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientA,
                                   "50%",
                                   "red");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientA,
                                   "98%",
                                   "blue");
      
      //Define gradientB, which provides a linear
      // gradient having two stops from green to blue
      // going from left to right.
      Element gradientB =SvgGraphics.makeLinearGradient(
                             document,    //this document
                             defs,        //parent
                             "gradientB");//id
                   
      SvgGraphics.makeGradientStop(document,
                                   gradientB,//parent
                                   "0%",     //start here
                                   "green"); //color
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientB,
                                   "100%",
                                   "blue");
                                     
      //Define gradientC, which provides a radial
      // gradient from yellow to red to blue going from
      // the center to the outer edge.
      Element gradientC = 
                 SvgGraphics.makeRadialGradient(
                   document,        //this document
                   defs,            //parent
                   "gradientC",     //ID
                   "userSpaceOnUse",
                   rectCenterX,     //cx
                   rectCenterY,     //cy
                   rectWidth/2);    //r
                   
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "0%",
                                   "yellow");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "50%",
                                   "red");
                             
      SvgGraphics.makeGradientStop(document,
                                   gradientC,
                                   "100%",
                                   "blue");
                                   
      //Create a node named g, which will be the parent
      // for an ellipse,a circle, a rectangle, a line,
      // a polyline, and a polygon. Pass null for the
      // reference to the object for the special case
      // where the node has no attribtes.
      Element g = SvgGraphics.makeNode(document,
                                       svg,//parent
                                       "g",
                                       null);

      //Create an ellipse with a blue border that is two
      // pixels wide. Fill it with the yellow-red-blue
      // gradient defined by gradientA.
      Element theEllipse = SvgGraphics.makeEllipse(
                             document,
                             g,//Owner
                             ellipseCenterX,
                             ellipseCenterY,
                             ellipseWidth,
                             ellipseHeight);
      //Set the appearance of the ellipse.
      theEllipse.setAttribute("fill","url(#gradientA)");
      theEllipse.setAttribute("stroke","blue");
      theEllipse.setAttribute("stroke-width","2");
      //Rotate the ellipse by 15-degrees clockwise about
      // its center.
      theEllipse.setAttribute("transform",
                  "translate(" + ellipseCenterX + "," 
                  + ellipseCenterY + ") "
                  + "rotate(" + ellipseRotate + ") "
                  + "translate(" + (-ellipseCenterX) + ","
                  + (-ellipseCenterY) + ") ");

      //Position a circle so that it appears to be inside
      // the ellipse.  Fill it with the green-blue
      // gradient defined by gradientB.
      Element theCircle = SvgGraphics.makeCircle(
                            document,
                            g,//Owner
                            circleCenterX,
                            circleCenterY,
                            circleRadius);
      //Set the appearance of the circle and rotate it by
      // 15-degrees clockwise about its center.
      theCircle.setAttribute("fill","url(#gradientB)");
      theCircle.setAttribute("transform",
                   "translate(" + circleCenterX + "," 
                   + circleCenterY + ") "
                   + "rotate(" + circleRotate + ") "
                   + "translate(" + (-circleCenterX) + ","
                   + (-circleCenterY) + ") ");

      //Make a rounded rectangle and fill it with
      // gradientC
      Element theRect = SvgGraphics.makeRect(
                            document,
                            g,//Owner
                            rectCenterX - rectWidth/2,//x
                            rectCenterY - rectHeight/2,//y
                            rectWidth,
                            rectHeight);

      theRect.setAttribute("fill","url(#gradientC)");

      //Round the corners.
      theRect.setAttribute("rx",""+ rectRoundX);
      theRect.setAttribute("ry",""+ rectRoundY);

      //Draw a polyline with four points.
      int[] polylinePoints = 
                         {10,235,210,235,110,275,110,225};
      Element polyline = SvgGraphics.makePolyline(
                                          document,
                                          g,//owner
                                          polylinePoints);
      
      //Rotate the polyline by 10 degrees around the first
      // point.
      polyline.setAttribute("transform",
                    "translate(" + polylinePoints[0] + ","
                    + polylinePoints[1] + ")" 
                    + "rotate(" + rotatePolyline + ")" 
                    + "translate(" + (-polylinePoints[0]) 
                    + "," + (-polylinePoints[1]) + ")");
      
      //Draw a polygon with four points. Give it a red
      // border and fill it with green.
      int[] polygonPoints = 
                         {10,335,210,335,110,375,110,325};
      Element polygon = SvgGraphics.makePolygon(
                                           document,
                                           g,//parent
                                           polygonPoints);
      polygon.setAttribute("fill","green");
      polygon.setAttribute("stroke","red");
      polygon.setAttribute("stroke-width","3");
      
      //Draw a green line 12 pixels wide.  Make the line
      // 60% opaque, or 40% transparent, whichever you
      // prefer.
      Element line = SvgGraphics.makeLine(document,
                                          g,   //owner
                                          0,   //x1
                                          0,   //y1
                                          220, //x2
                                          440);//y2
      line.setAttribute("stroke","green");
      line.setAttribute("stroke-width","12");
      line.setAttribute("stroke-opacity","0.6");
      

      //The remaining code in this class is used to
      // transform the DOM tree into SVG code and to wrap
      // that code in a document that would otherwise be
      // a valid XHTML document.

      //Instantiate an object of this class
      Svg04 thisObj = new Svg04();

      //Get an output stream for the output produced by
      // the program code.
      PrintWriter out = res.getWriter();

      //Process the DOM tree, beginning with the Document
      // node to produce the output.
      //The invocation of processDocumentNode starts a
      // recursive process that will process the entire
      // DOM tree.
      thisObj.processDocumentNode(out,document);

    }catch(Exception e){
      //Note that no effort was made to provide meaningful
      // information in the event of an exception or
      // error.
      e.printStackTrace(System.err);
    }//end catch

  }//end doGet()
  //----------------------------------------------------//

  //This method is used to produce the text required in
  // the output at the document level, such as the
  // XML declaration.  It also produces the top level
  // element tags. 
  void processDocumentNode(PrintWriter out,Node node){
    //Create the beginning of the XHTML document.
    out.println("&lt;?xml version=\"1.0\" "
                       + "encoding=\"UTF-8\"?&gt;");
    out.println(
          "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD "
             + "XHTML 1.0 Transitional//EN\" "
             + "\"http://www.w3.org/TR/xhtml1/"
             + "DTD/xhtml1-transitional.dtd\"&gt;");

    out.println(SvgGraphics.makeElement(false,"html",
      new String[]{"xmlns","http://www.w3.org/1999/xhtml",
                   "xml:lang","en",
                   "name","lang"
                  })//end call to makeElement
    );//end println

    out.println("&lt;head&gt;");

    out.println(SvgGraphics.makeElement(
               true,
               "meta",
               new String[]{"http-equiv","content-type",
                            "content",
                            "image/svg+xml; charset=UTF-8"
                           })//end call to makeElement
    );//end println

    out.println("&lt;title&gt;Generated XHTML file&lt;/title&gt;");

    out.println("&lt;/head&gt;");

    out.println(SvgGraphics.makeElement(
                 false,
                 "body",
                 new String[]{"id","body",
                              "style","position:absolute;"
                              + "z-index:0;"
                              + "border:1px solid black;"
                              + "left:0;"
                              + "top:0;"
                              + "width:220px;"
                              + "height:440px;"
                             })//end call to makeElement
    );//end println

    //Go process the root (document) node. This method
    // call triggers a recursive process that will 
    //process the entire DOM tree.
    processNode(out,node);

    //The entire DOM tree has been processed when control
    // returns to this point.
    //Now finish the output document and flush the output
    // buffer.

    out.println("&lt;/body&gt;&lt;/html&gt;");
    out.flush();
  }//end processDocumentNode
  //----------------------------------------------------//

  //There are seven kinds of nodes and most of them were
  // handled in the earlier program from which this
  // program was derived:
  
  // root or document
  // element
  // attribute
  // text
  // comment
  // processing instruction
  // namespace

  //However, because the nodes in this program are
  // produced by the program and it is known in advance
  // the types of nodes that will be encountered, this
  // program is less general than the earlier program.
  // Therefore, this method only handles element nodes
  // and document nodes..
  void processNode(PrintWriter out,Node node){
    try{
      if (node == null){
        System.out.println("Nothing to do, node is null");
        return;
      }//end if

      //Process the incoming node based on its type.
      int type = node.getNodeType();
      switch(type){
        case Node.ELEMENT_NODE:{
          
          //Start creating the start tag.
          String nodeName = node.getNodeName();
          out.print("&lt;" + nodeName + " ");
          
          //Now add each attribute to the start tag.
          NamedNodeMap theList = node.getAttributes();
          int length = theList.getLength();
          for(int cnt = 0;cnt &lt; length;cnt++){
            Node item = theList.item(cnt);
            out.print(item.getNodeName() + "=\"" 
                           + item.getNodeValue() + "\" ");
          }//end for loop
          out.println("&gt;");//close the start tag.
          
          //Process all XML child nodes recursively.
          processChildNodes(out,node);
          
          //The element and all of its children have been
          // processed when control returns to this point.
          //Create the end tag for the element.
          out.println("&lt;/" + nodeName + "&gt;");
            
          break;
        }//end case ELEMENT_NODE

        case Node.DOCUMENT_NODE:{
          //No action is required other than to process
          // the child nodes recursively.
          processChildNodes(out,node);
          break;
        }//end case DOCUMENT_NODE

      }//end switch

    }catch(Exception e){
      e.printStackTrace(System.err);
    }//end catch
  }//end processNode(Node)
  //----------------------------------------------------//

  //This method is called to recursively process
  // the child nodes belonging to a specified
  // node.
  void processChildNodes(PrintWriter out,Node node){
    NodeList children = node.getChildNodes();
    if (children != null){
      int len = children.getLength();
      //Iterate on NodeList of child nodes.
      for(int i = 0; i &lt; len; i++){
        //This is a recursive call.
        processNode(out,children.item(i));
      }//end for loop
    }//end if children != null

  }//end processChildNodes
  //----------------------------------------------------//
}//end class Svg04
//======================================================//

//This is a proof-of-concept graphics class that
// provides method calls for the creation of the following
// DOM tree nodes:
//  A general node of any type
//  A linear gradient element.
//  A radial gradient element.
//  An ellipse.
//  A circle.
//  A rectangle.
//  A line.
//  A polyline.
//  A polygon.

//Each method receives a reference to the overall document
// along with a reference to the parent for the new node.
//When the method returns, the new node has been appended
// to the parent node.
class SvgGraphics{
  //----------------------------------------------------//

  //This method creates a linear gradient node to which
  // stop elements must be appended.
  static Element makeLinearGradient(Document document,
                                    Element parent,
                                    String id){
    Element gradient = 
        (Element)document.createElement("linearGradient");
    parent.appendChild(gradient);
    gradient.setAttribute("id",id);
    return gradient;
  }//End makeLinearGradient
  //----------------------------------------------------//
  
  //This method creates a radial gradient node to which
  // stop elements must be appended. Note that numeric
  // attributes are set as type String.
  static Element makeRadialGradient(Document document,
                                    Element parent,
                                    String id,
                                    String gradientUnits,
                                    int cx,
                                    int cy,
                                    int r){
    Element gradient = 
        (Element)document.createElement("radialGradient");
    parent.appendChild(gradient);
    gradient.setAttribute("id",id);
    gradient.setAttribute("gradientUnits",gradientUnits);
    gradient.setAttribute("cx",""+cx);
    gradient.setAttribute("cy",""+cy);
    gradient.setAttribute("r",""+r);
    return gradient;
  }//End makeRadialGradient
  //----------------------------------------------------//

  //This method creates a gradient stop node to be
  // appended to a linear gradient node or a radial
  // gradient node.                                      
  static Element makeGradientStop(Document document,
                                  Element parent,
                                  String location,
                                  String color){
    Element stopElement = 
                  (Element)document.createElement("stop");
    parent.appendChild(stopElement);
    stopElement.setAttribute("offset",location);
    stopElement.setAttribute("stop-color",color);
    return stopElement;
  }//End makeGradientStop
  //----------------------------------------------------//
  
  //This method returns a reference to an ellipse. The
  // xCoor and yCoor parameters specify the center of the
  // ellipse.  The xRadius and yRadius parameters specify
  // the width and height of the  ellipse respectively
  // while it is in the horizontal plane before being
  // rotated.  Numeric attributes are set at type String.
  static Element makeEllipse(Document document,
                             Element parent,
                             int xCoor,
                             int yCoor,
                             int xRadius,
                             int yRadius){
    Element ellipse  = 
               (Element)document.createElement("ellipse");
    parent.appendChild(ellipse);
    ellipse.setAttribute("cx",""+xCoor);
    ellipse.setAttribute("cy",""+yCoor);
    ellipse.setAttribute("rx",""+xRadius);
    ellipse.setAttribute("ry",""+yRadius);
    return ellipse;
  }//end makeEllipse
  //----------------------------------------------------//

  //This method returns a reference to a circle. The
  // xCoor and yCoor parameters specify the center of the
  // circle.  The radius parameter specifies the radus of
  // the circle.  Numeric attributes are set as type
  // String.
  static Element makeCircle(Document document,
                            Element parent,
                            int xCoor,
                            int yCoor,
                            int radius){
    Element circle  = 
                (Element)document.createElement("circle");
    parent.appendChild(circle);
    circle.setAttribute("cx",""+xCoor);
    circle.setAttribute("cy",""+yCoor);
    circle.setAttribute("r",""+radius);
    return circle;
  }//end makeCircle
  //----------------------------------------------------//
  
  //This method returns a reference to a rectangle. The
  // xCoor and yCoor parameters specify the location of
  // the upper left corner.  The width and height
  // parameters specify the width and the height while
  // the rectangle is in the horizontal plane before
  // being rotated.  Numeric attributes are set as type
  // String.
  static Element makeRect(Document document,
                          Element parent,
                          int xCoor,
                          int yCoor,
                          int width,
                          int height){
    Element rect  = 
                  (Element)document.createElement("rect");
    parent.appendChild(rect);
    rect.setAttribute("x",""+xCoor);
    rect.setAttribute("y",""+yCoor);
    rect.setAttribute("width",""+width);
    rect.setAttribute("height",""+height);
    return rect;
  }//end makeRect
  
  //----------------------------------------------------//
  
  //This method returns a reference to a line. x1 and y1
  // specify the starting point of the line before it is
  // rotated. x2 and y2 specify the end point.  By
  // default, the stroke is set to black one pixel wide.
  // This can be overridden to speciy other colors and
  // other widths if you need to do so.
  static Element makeLine(Document document,
                          Element parent,
                          int x1,
                          int y1,
                          int x2,
                          int y2){
    Element line  = 
                  (Element)document.createElement("line");
    parent.appendChild(line);
    line.setAttribute("x1",""+x1);
    line.setAttribute("y1",""+y1);
    line.setAttribute("x2",""+x2);
    line.setAttribute("y2",""+y2);
    line.setAttribute("stroke","black");
    line.setAttribute("stroke-width","1");
    return line;
  }//end makeLine
  //----------------------------------------------------//

  //This method returns a reference to a polyline. The
  // array of type int[] must contain an even number of
  // values for things to work correctly.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black one pixel
  // wide with no fill.  This can be overridden to other
  // colors and other widths if you need to do so.
  static Element makePolyline(Document document,
                              Element parent,
                              int[] points){
    Element polyline  = 
              (Element)document.createElement("polyline");
    parent.appendChild(polyline);

    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    
    polyline.setAttribute("points",dataPoints);
    polyline.setAttribute("stroke","black");
    polyline.setAttribute("stroke-width","1");
    polyline.setAttribute("fill","none");
    return polyline;
  }//end makePolyline
  //----------------------------------------------------//
  
  //This method returns a reference to a polygon. The
  // array of type int[] must contain an even number of
  // values for things to work correctly.
  //The values are extracted from the array and treated
  // as coordinate values x1,y1, x2,y2, x3,y3 ... etc.
  // By default, the stroke is set to black, one pixel
  // wide with no fill.  This can be overridden to other
  // colors and other widths if you need to do so.
  //The major difference between a polygon and a polyline
  // is that a polyline leaves the last point dangling.
  // However, a polygon automatically draws a line from
  // the last point back to the first point to close
  // the polygon.
  static Element makePolygon(Document document,
                           Element parent,
                           int[] points){
    Element polygon  = 
               (Element)document.createElement("polygon");
    parent.appendChild(polygon);

    String dataPoints = "";
    for(int cnt=0;cnt&lt;points.length;cnt++){
      dataPoints += "" + points[cnt] + ",";
    }//end for loop
    
    polygon.setAttribute("points",dataPoints);
    polygon.setAttribute("stroke","black");
    polygon.setAttribute("stroke-width","1");
    polygon.setAttribute("fill","none");
    return polygon;
  }//end makePolygon
  
  //----------------------------------------------------//
  
  /*
  One of the most frustrating things about using Java
   to create elements in XML, XHTML, or HTML is having
   to deal with the escape characters for the many
   required quotation marks. This method constructs an
   element, which may or may not have attributes. Also,
   the element may or may not be empty.
  The user of this method does not have to deal with the
   required quotation marks surrounding attribute values
   and the corresponding escape characters     
  The first incoming parameter must be true if the
   element is empty and false if the element is not
   empty.
  If the first parameter is true, the element is sealed
   off in the required manner for an empty element. If
   the first parameter is false, the method returns the
   complete start tag for the element but does not
   return a complete element. It is the responsibility
   of the calling method to provide the content and the
   end tag for the element.
  The second parameter to the method must be a String
   that specifies the name of the element.
  The third parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.

  If the reference to the array object is null and the
   first parameter is false, the method returns the start
   tag for an element that has no attributes and is not 
   empty.
  If the reference is null and the first parameter is
   true, the method returns a complete empty element with 
   no attributes (which probably doesn't make any sense).
   
  An example of the recommended usage of the method
   follows:
   
  String newElement = SvgGraphics.makeElement(
                  true/false,
                  name,
                  new String[]{"name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value",
                               "name","value"
                              });//end call to makeElement
   
  */
  
  static String makeElement(
          boolean empty,String elementName,String[] data){

    //Begin constructing the start tag.
    String element = "&lt;" + elementName + " ";
    
    //Deal with elements that have no attributes.
    if((empty==false) &amp;&amp; (data == null)){
      //Return a complete start tag.
      return element + "&gt;";
    }else if((empty==true) &amp;&amp; (data == null)){
      //Return a complete empty element.
      return element + "/&gt;";
    }//end if

    for(int cnt=0;cnt&lt;data.length;cnt+=2){

      String name = data[cnt];
      String value = data[cnt+1];
      element += name + "=" + "\"" + value + "\" ";
    }//end for loop
    
    if(empty){
      //Terminate the element appropriately for an
      // empty element. A complete empty element will
      // be returned.
      element += "/&gt;";
    }else{
      //End the start tag for an element that is not
      // empty. In this case, only the start tag will
      // be returned.  The calling program must provide
      // the content for the element as well as the end
      // tag for the element.
      element += "&gt;";
    }//end else
      
  return element;
  }//end makeElement
  //----------------------------------------------------//
  
  /*
  The purpose of this method is to create a general node
   having any name, and any number of attributes with any 
   attribute names and any String values for the 
   attributes, or no attributes at all.
   
  The first parameter is a reference to the document to
   which the new node belongs.
  
  The second parameter is a reference to the parent node
   to which this node is to be appended so as to become a
   child of that node. If this parameter is null, the new
   node is appended to the document.  Otherwise, it is
   appended to the specified parent node.
   
  The third parameter is a String that specifies the type
   of node.
  
  The fourth parameter to the method must be a reference
   to an array object of type String.  This array must 
   contain an even number of elements.  Each pair of 
   elements constitutes the name and the value of an 
   attribute, in the order name, value, name, value, etc.
  
  An example of the recommended usage of the method
   follows:
  Element abc = SvgGraphics.makeNode(
                     document,
                     def,//parent could be null
                     "ghi",//node type
                     new String[]{"name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value",
                                  "name","value"
                                 });//end call to makeNode
  */
  static Element makeNode(Document document,
                                Element parent,
                                String nodeType,
                                String[] data){
  
    Element element = 
                (Element)document.createElement(nodeType);
    
    if(parent == null){
      //For the special case of parent equal to null,
      // append the new node to the document.
      document.appendChild(element);
    }else{
      //Otherwise, append the new node to the specified
      // parent.
      parent.appendChild(element);
    }//end else
  
    //Deal with elements that have no attributes.
    if(data == null){
      return element;
    }//end if
    
    for(int cnt=0;cnt&lt;data.length;cnt+=2){
      String name = data[cnt];
      String value = data[cnt+1];
      element.setAttribute(name,value);
    }//end for loop
    
    return element;
  }//end makeNode
  //----------------------------------------------------//
  
  //This is a utility method that is used to execute code
  // that is the same regardless of the graphic image
  // being produced.
  static Document getDocument(){
    Document document = null;
    try{
      DocumentBuilderFactory factory = 
                     DocumentBuilderFactory.newInstance();

      DocumentBuilder builder = 
                             factory.newDocumentBuilder();
      document = builder.newDocument();
    }catch(Exception e){
      e.printStackTrace(System.err);
      System.exit(0);
    }//end catch
    return document;
  }//end getDocument
  //----------------------------------------------------//
}//end class SvgGraphics&n/pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<p><b>Java 2D Graphics</b><br>
<a href="http://www.dickbaldwin.com/java/Java300.htm">300</a> Java 2D Graphics, 
Nested Top-Level Classes and Interfaces&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java302.htm">302</a> Java 2D Graphics, 
The Point2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java304.htm">304</a> Java 2D Graphics, 
The Graphics2D Class&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java306.htm">306</a> Java 2D Graphics, 
Simple Affine Transforms&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java308.htm">308</a> Java 2D Graphics, 
The Shape Interface, Part 1&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java310.htm">310</a> Java 2D Graphics, 
The Shape Interface, Part 2&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java312.htm">312</a> Java 2D Graphics, 
Solid Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java314.htm">314</a> Java 2D Graphics, 
Gradient Color Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java316.htm">316</a> Java 2D Graphics, 
Texture Fill&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java318.htm">318</a> Java 2D Graphics, 
The Stroke Interface&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java320.htm">320</a> Java 2D Graphics, 
The Composite Interface and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java322.htm">322</a> Java 2D Graphics, 
The Composite Interface, GradientPaint, and Transparency&nbsp; <br>
<a href="http://www.dickbaldwin.com/java/Java324.htm">324</a> Java 2D Graphics, 
The Color Constructors and Transparency<br>
<a href="http://java.sun.com/j2se/1.5.0/docs/guide/2d/spec.html">Java 2D API 
Specification</a><br>
<a href="http://java.sun.com/products/java-media/2D/">Java 2D API</a></p>
<p><b>Java API for XML Processing (JAXP)</b><br>
<a href="http://www.developer.com/java/other/article.php/3099751">2200</a> Java 
API for XML Processing (JAXP), Getting Started<br>
<a href="http://www.developer.com/xml/article.php/3113351">2202</a> Getting 
Started with Java JAXP and XSL Transformations (XSLT)<br>
<a href="http://www.developer.com/java/other/article.php/3292751">2204</a> Java 
JAXP, Exposing a DOM Tree<br>
<a href="http://www.developer.com/java/other/article.php/3313341">2206</a> Java 
JAXP, Implementing Default XSLT Behavior in Java<br>
<a href="http://www.developer.com/java/other/article.php/3361261">2208</a> Java 
JAXP, Writing Java Code to Emulate an XSLT Transformation<br>
<a href="http://www.developer.com/java/data/article.php/3398741">2210</a> Java 
JAXP, Transforming XML to XHTML<br>
<a href="http://www.dickbaldwin.com/tocxml.htm">Links to numerous XML tutorials 
by Richard G. Baldwin</a><br>
<br>
<b>Scalable Vector Graphics (SVG)</b><br>
<a href="http://www.developer.com/java/other/article.php/3655506">2212</a> Java JAXP, Creating graphics using Java and SVG<br>
<a href="http://www.developer.com/java/other/article.php/3665131">2214</a> An improved approach for creating SVG/XML code and SVG/XML DOM nodes 
using Java<br>
<a href="http://www.w3.org/TR/SVG/">Scalable Vector Graphics (SVG) 1.1 
Specification</a><br>
<a href="http://www.adobe.com/svg/">Adobe SVG Viewer plug-in</a><br>
<a href="https://www6.software.ibm.com/developerworks/education/x-svggraphics/index.html">
Create vector graphics in the browser with SVG</a> by Uche Ogbuji<br>
<a href="http://www.w3schools.com/svg/default.asp">SVG Tutorial</a><br>
<a href="http://www.svgbasics.com/shapes.html">SVG Basics</a></p>
<p><b>Miscellaneous<br>
</b><a href="http://validator.w3.org/file-upload.html">W3C Markup Validation 
Service</a>.</p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java jaxp svg &quot;scalable vector graphics&quot;</p>
<p>-end- </p>
<p><br>
&nbsp;</p>
</body>
</html>
