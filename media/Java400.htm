<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Processing Image Pixels using Java, Getting Started</h2>
    <i>Baldwin shows you how to modify an image by modifying the pixels 
belonging to that image.&nbsp; He also provides a driver program that makes it 
easy to modify the pixels in an image and to display the modified image.</i><p><b>Published:</b>&nbsp; 
September 7, 2004 <br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 400</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
	<li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a><li><a href="#Run_the_Programs">Run the Program</a></li>
  <li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listing</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>First in a series</b></font></p>
<p>This lesson is the first lesson in a new series intended to teach you how to 
use Java to create special effects with images by directly manipulating the 
pixels in the images.</p>
<p><font color="#FF0000"><b>Not a lesson on JAI</b></font></p>
<p>If you arrived at this lesson while searching for instructions on how to use 
the Java Advanced Imaging <i>(JAI)</i> API, you are certainly welcome to be 
here.&nbsp; However, that is not the purpose of the lessons in this series.&nbsp;
<i>(Maybe I will write a series on that topic later.)</i>&nbsp; The purpose of 
this series is to get right down in the mud and to learn how to implement many of 
the algorithms that are commonly used to create special effects with images by 
working directly with the pixels.</p>
<p><font color="#FF0000"><b>Manipulate pixels directly and individually</b></font></p>
<p>In this lesson, I will provide and explain a program that makes it easy to:</p>
<ul>
	<li>Manipulate and modify the pixels that belong to an image</li>
	<li>Display the modified image along with the original image for easy 
	comparison in a <i>before</i> and <i>after</i> sense</li>
</ul>
<p><font color="#FF0000"><b>A framework or driver program</b></font></p>
<p>This program is designed to be used as a framework or driver that controls 
the execution of another program that actually processes the pixels.</p>
<p>By 
using this program as a driver, you can concentrate on writing and executing 
image-processing algorithms without 
having to worry about many of the details involving image files, image 
display, etc.</p>
<p><font color="#FF0000"><b>A simple image-processing program</b></font></p>
<p>Also in this lesson, I will provide and explain the first of several 
image-processing programs designed to teach you how to modify an image by directly 
modifying the pixels that represent the image.</p>
<p>The image-processing 
program provided in this lesson will be relatively simple with the intent being 
to get you started but not necessarily to produce a modified image that is 
especially interesting.</p>
<p><font color="#FF0000"><b>More interesting imaging processing programs</b></font></p>
<p>Future lessons will show you how to write image-processing programs that 
implement many common special effects as well as a few that aren't so common.&nbsp; 
This will include programs to do the following:</p>
<ul>
	<li>Highlight a particular area in an image.</li>
	<li>Blur all or part of an image.</li>
	<li>Sharpen all or part of an image.</li>
	<li>Perform edge detection on an image.</li>
	<li>Apply color filtering to an image.</li>
	<li>Apply color inversion to an image.</li>
	<li>Morphing one image into another image.</li>
	<li>Rotating an image.</li>
	<li>Squeezing part of an image into a smaller size.</li>
	<li>Controlling the brightness of an image using linear and non-linear 
	algorithms.</li>
	<li>Other special effects that I may dream up or discover while doing the 
	background research for the lessons in this series.</li>
</ul>
<p>Figures 1 through 4 show examples of the first four special effects in the 
above list.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
 
<p><font color="#FF0000"><b>Highlighting an image</b></font></p>
<p>The special effect illustrated by Figure 1 begins with a picture of a 
starfish taken in a well-lighted aquarium and converts it to what looks like a 
picture taken by a SCUBA diver deep underwater.</p>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java400a.gif" width="334" height="714">
</pre>
<b>Figure 1&nbsp; Highlighting an area in an image.</b>

</td>
</tr>
</tbody>                                
</table></p>
<p>In Figure 1, as in all of the graphic output produced by this program, the 
original image is shown at the top and the modified image is shown at the 
bottom.</p>
<p>The program that produced the modified image in Figure 1 allows the user to 
interactively control the degree to which the light is concentrated in the 
center of the picture.&nbsp; In other words, the illumination can range from 
being concentrated in a very small area in the center to being spread throughout 
the image.</p>
<p><font color="#FF0000"><b>Blurring an image</b></font></p>
<p>Figure 2 illustrates a well-known algorithm that implements the common 
special effect of blurring an image.</p>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java400b.gif" width="339" height="740">
</pre>
<b>Figure 2&nbsp; A blurred image.</b>&nbsp;

</td>
</tr>
</tbody>                                
</table></p>
<p>The original image is at the top, and the blurred image is at the bottom.</p>
<p>The program used to produce Figure 2 allows the user to interactively control 
the extent of the blurring, ranging from no blurring at all, to extreme 
blurring.</p>
<p><font color="#FF0000"><b>Sharpening an image</b></font></p>
<p>Figure 3 shows the result of applying an algorithm intended to sharpen an 
image.&nbsp; In general, sharpening is intended to cause the small details in 
the image to become more visible.</p>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<div align="center">
<pre>
<img border="0" src="java400c.gif" width="143" height="254">
</pre>
</div>
<b>Figure 3&nbsp; A sharpened image.</b>

</td>
</tr>
</tbody>                                
</table></p>
<p>The program that produced Figure 3 applies a well-known sharpening procedure.&nbsp; 
In the final analysis, the success or failure of the algorithm lies in the eye 
of the beholder, so you will have to make up your own mind as to the results 
shown in Figure 3.</p>
<p>It does appear to me, however, that some of the fine detail, such as the 
veins in the eyeball and the ragged edges on the fingernails are enhanced in the 
processed image at the bottom of Figure 3.</p>
<p><font color="#FF0000"><b>Edge detection</b></font></p>
<p>The purpose of edge detection is to highlight the edges of different objects 
in an image where color changes and shadows produce rapid changes in the color 
and/or intensity of the image.&nbsp; Other circumstances, such as the edges of 
letters on a sign will also trigger edge detection on the basis of strong color 
contrasts between the letters and the background.</p>
<p>Figure 4 shows the result of applying edge detection to a photograph of a 
person inserting a contact lens into their eye.</p>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<div align="center">
<pre>
<img border="0" src="java400d.gif" width="143" height="254">
</pre>
</div>
<b>Figure 4&nbsp; An edge-detected image.</b>

</td>
</tr>
</tbody>                                
</table></p>
<p>You will probably agree that the edge-detection algorithm worked pretty well in this 
case.&nbsp; It is easy to spot the edges of the fingers, the fingernails, the 
eyelid, the iris in the eye, and the shadows on the nose.</p>
<p><font color="#FF0000"><b>Theoretical basis and practical implementation</b></font></p>
<p>In future lessons, I will provide some of the theoretical basis for 
special-effects algorithms including those used in Figures 1 through 3.</p>
<p>In addition, I will show you how to implement those algorithms in Java.</p>
<p>In some cases I will mention situations in which the special effect might be 
useful.</p>
<blockquote>
	<p><i>(For example, blurring can be used to soften a photograph and can make 
	a person look a few years younger than they actually are by hiding some of 
	the wrinkles.&nbsp; Edge detection can be used to highlight the edges of 
	items in surveillance photos.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>The programs that I will provide and explain in this series of lessons are 
not intended to be used for high-volume production work.&nbsp; Numerous 
integrated image-processing programs are available for that purpose.&nbsp; In 
addition, JAI has a number of special effects built in if you prefer to write 
your own production image-processing programs using Java.</p>
<p>The programs that I will provide in this series of lessons are intended to 
make it possible for you to develop and to experiment with such algorithms and 
to gain a better understanding of how they work, and why they do what they do.</p>
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p><font color="#FF0000"><b>Image construction, storage, and rendering</b></font></p>
<p>Before getting into the programming details, it will be useful to review the 
concept of how images are constructed, stored, transported, and rendered in Java
<i>(and in most modern computers for that matter).</i></p>
<p><font color="#FF0000"><b>An array of colored dots - pixels</b></font></p>
<p>A modern computer image, at the point where it is presented <i>(rendered)</i> 
for human consumption, usually consists of a rectangular array of closely spaced 
colored dots.&nbsp; Ideally, the dots are so small and so close together that 
the human eye cannot distinguish them individually.&nbsp; This causes them to 
run together and appear to represent continuous color.</p>
<p>The individual dots are commonly referred to as <i>pixels, </i>which I 
believe is derived from the term <i>picture elements.</i></p>
<p><font color="#FF0000"><b>Image files</b></font></p>
<p>The pixels are typically stored and transported in files, and are then 
extracted from the files and displayed on a computer screen or sheet of paper 
for human consumption.</p>
<p>There are a fairly large number of formats for storing the pixels in a file.&nbsp; 
Different file formats have advantages and disadvantages in terms of 
compression, size, reproduction quality, etc.</p>
<p><font color="#FF0000"><b>Not interested in file formats</b></font></p>
<p>This series of lessons will not be concerned about file 
formats.&nbsp; We will be concerned with what to do with the pixels once they 
have been extracted from the file.&nbsp; The driver program that I will provide 
can read <b>gif</b> files and <b>jpg</b> files, and possibly other file formats 
as well.</p>
<p><font color="#FF0000"><b>Will pick up at the extraction point for raw pixels</b></font></p>
<p>We will initially become interested in the pixels at the point where they 
have been extracted from the file and exist in the form of a 
one-dimensional array of type <b>int</b>.&nbsp; We will convert that array into 
a three-dimensional array that is better suited for processing.&nbsp; Once we 
understand the conversion process, our attention will shift to the 
three-dimensional array containing pixel data.&nbsp; The image-processing programs that we will write 
will receive raw pixel data in the form of a three-dimensional array.</p>
<p><font color="#FF0000"><b>A grid of colored pixels</b></font></p>
<p>Each three-dimensional array object will represent one image consisting of a 
grid of colored pixels.&nbsp; When rendered, the pixels in the grid will be arranged in rows 
and columns.&nbsp; One of the dimensions of the array will represent rows.&nbsp; 
A second dimension will represent columns.&nbsp; The third dimension will 
represent the color <i>(and transparency)</i> of the pixel.</p>
<p><font color="#FF0000"><b>Now back to the fundamentals</b></font></p>
<p>A pixel in a modern computer image is 
represented by four <b><i>unsigned</i></b> 8-bit bytes of data.&nbsp; Three of those four bytes 
represent the colors <i>red, green, </i>and <i>blue.</i>&nbsp; The fourth byte, often referred 
to as the<i> alpha</i> byte,<i> </i>represents <i>transparency.&nbsp; </i>I will have more to say about 
the alpha byte and transparency later.</p>
<p><font color="#FF0000"><b>Mixing the primary colors red, green, and blue</b></font></p>
<p>Specific colors are created by mixing different amount of red, green, and 
blue.&nbsp; That is to say, when the program needs to cause the color orange to 
be displayed on the screen, it mixes together the correct amounts of red, green, 
and blue to produce orange.</p>
<p>The amounts of each of the three primary colors that are added together to 
control the overall color of an individual pixel are specified by the individual 
values stored in the three color bytes for the pixel.</p>
<p><font color="#FF0000"><b>The range of a color</b></font></p>
<p>Each unsigned eight-bit color byte can contain 256 different values ranging from 0 to 255 
inclusive.&nbsp; If the value of the red byte is 0, for 
example, no red color is added into the mix to produce the overall color for that 
pixel.&nbsp; If the value of the red byte is 255, the maximum possible amount of 
red is added into the mix to produce the overall color for that pixel.&nbsp; The 
same is true for blue and green as well.</p>
<p><font color="#FF0000"><b>Black and white pixels</b></font></p>
<p>If all three of the color pixels have a value of 0, the color of that pixel 
is black.&nbsp; If all three of the color pixels have a value of 255, the color 
of that pixel is white.&nbsp; If all three of the pixels have the same value 
somewhere between 0 and 255, the color of the pixel is some shade of gray.</p>
<p><font color="#FF0000"><b>Sixteen million possible colors</b></font></p>
<p>Between black at one extreme and white at the 
other, there are about sixteen million possible combinations of the three color 
values, each having 256 possible values.&nbsp; Thus, in theory, the system can 
produce about sixteen million different colors.</p>
<blockquote>
	<p><i>(In actuality, it is not likely that there are any monitors, printers, or human 
	eyeballs that can reliably distinguish between sixteen million different colors.&nbsp; 
	For practical purposes, many of the colors simply run together when 
	rendered, but they are mathematically possible.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The bottom line on color</b></font></p>
<p>The color of each individual pixel is 
determined by the values stored in the three color bytes for that pixel.&nbsp; 
If you change any of those values, you will change the color of the pixel 
accordingly.</p>
<p><font color="#FF0000"><b>Now back to transparency</b></font> </p>
<p>I'm going to explain transparency with an analogy.&nbsp; 
The alpha byte also has 256 possible values ranging from 0 to 255.&nbsp; If the 
value is zero, the pixel is completely transparent regardless of the values of 
the color bytes.&nbsp; If the value is 255, the pixel is completely opaque with 
the color of the pixel being determined exclusively by the values stored in the 
three color bytes.</p>
<p><font color="#FF0000"><b>What about the values between 0 and 255</b></font></p>
<p>Here is my analogy.&nbsp; Assume that you paint a glass window with purple paint that 
adheres well to glass.&nbsp; After the paint 
dries, what you will see when you look at the window is purple color.&nbsp; It is unlikely that you will see the 
green trees on the other side of the glass showing through the purple.&nbsp; 
This is what I mean by completely opaque.</p>
<p>Now assume that you paint the window with purple paint that doesn't adhere to glass very well.&nbsp; 
You will end up with a very thin coat of purple paint on the glass.&nbsp; When the paint dries, what you will see 
when you look at the window is a 
mixture of purple color and the green trees that show through from the other side.&nbsp; 
This represents an alpha value somewhere between 0 and 255.&nbsp; Whatever pixel 
was placed on the screen before the new pixel was placed there will show through 
the new pixel to some extent.</p>
<p>Now assume that you put cooking oil on the glass before you attempt to paint 
it and none of the purple paint sticks to the glass.&nbsp; Regardless of the 
fact that you attempted to apply purple paint to the window, what you see when 
you look at the window is the green trees 
on the other side of the glass.&nbsp; The purple doesn't show up at all.&nbsp; 
The window is completely transparent.</p>
<p><font color="#FF0000"><b>An alpha byte value of zero</b></font></p>
<p>This 
is what happens when the value of the alpha byte is 0.&nbsp; Whatever was there 
before is what you see even though the combination of red, green, and blue bytes 
is correct to cause the pixel to be purple.&nbsp; The pixel is purple.&nbsp; 
However, it is totally transparent so the purple color doesn't show.</p>
<blockquote>
	<p><i>(If 
you come back later and change the value of the alpha byte to a value between 0 
and 255, the purple attribute of the pixel will become apparent.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Four bytes stored in an int value</b></font></p>
<p>What we are going to find is that once the image file has been read, and the pixel data 
has been extracted from the 
image, each pixel is represented by a four-byte array element of type <b>int</b>.&nbsp; 
However, at this point you shouldn't consider this to truly represent a value of 
type <b>int</b>.&nbsp; Rather, the array element of type<b> int </b>is simply a 
convenient place to pack four independent <i><b>unsigned</b></i> bytes end to 
end.</p>
<p><font color="#FF0000"><b>The order of the bytes</b></font></p>
<p>The most significant byte is the alpha byte.&nbsp; The next most significant is 
the red byte.&nbsp; The next byte is the green byte, and the least significant 
byte is the blue byte.</p>
<p>One of our tasks will be to extract the individual 
bytes from the <b>int</b> value and to get them out where we can easily manipulate 
them.&nbsp; We will use the bitwise operators <b>&amp;</b> and <b>&gt;&gt;</b> to 
accomplish this.</p>
<p>Java doesn't support unsigned arithmetic.&nbsp; As a practical matter, it is very cumbersome to do arithmetic on unsigned byte data in Java.&nbsp; Therefore, we will extract each 
byte into an individual variable of type <b>int</b> to make it easier to do 
arithmetic involving the alpha and color values.&nbsp; In so doing, we will make 
certain that the bits that make up the unsigned color or alpha byte end up in 
the least significant eight bits of the variable, and the twenty-four other bits 
in the variable all have a value of 0.</p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p><font color="#FF0000"><b>Two programs and one interface</b></font></p>
<p>In this lesson, I will present and explain two Java programs and one Java 
interface.&nbsp; The two Java programs are named <b>ImgMod02</b> and <b>
ProgramTest</b>.&nbsp; For convenience, these two programs are contained in the 
same source code file.</p>
<p>The program named <b>ImgMod02</b> is the framework or driver program.&nbsp; 
The program named <b>ProgramTest</b> is a simple image-processing program that 
is provided mainly as a test program for the driver program.</p>
<p>The interface is named <b>ImgIntfc02</b>.&nbsp; It is contained in a separate 
source code file.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The program named <b>ProgramTest</b>, <i>(and for that matter all 
image-processing programs that are capable of being driven by <b>ImgMod02</b>),</i> 
must implement the interface named <b>ImgIntfc02</b>.&nbsp; The interface 
declares a single method named <b>processImg</b>, which must be defined by all 
implementing classes.</p>
<p>When the user runs the program named <b>ImgMod02</b>, that program 
instantiates an object of the image-processing program class and invokes the <b>
processImg</b> method on that object.&nbsp; A three-dimensional array containing the pixel data 
for the image is passed to the method.&nbsp; The <b>processImg</b> method returns a 
three-dimensional array containing the pixel data for a modified version of the 
original image.</p>
<p><font color="#FF0000"><b>A <i>before</i> and <i>after</i> display</b></font></p>
<p>When the <b>processImg</b> method returns, the driver program causes the 
original image and the modified image to be displayed in a frame 
with the original image above the modified image <i>(see Figures 1 through 4 for 
examples of the display format).</i></p>
<p><font color="#FF0000"><b>Default image-processing program and default image 
file</b></font></p>
<p>If the user doesn't specify an image-processing program, the driver program 
will instantiate an object of the class named <b>ProgramTest</b> and will invoke 
the <b>processImg</b> method on that object.</p>
<p>By default, the program will also search for an image file named <b>junk.gif</b> 
in the current directory, and will process that image file if it can be found</p>
<p>As mentioned earlier, the class definition for 
the <b>ProgramTest</b> class is included in the source code file along with the 
driver program. However, the image file named <b>junk.gif </b>must be provided 
by the user in the current directory.</p>
<blockquote>
	<p><i>(Just about any gif file of an appropriate size named <b>junk.gif</b> 
	will do.&nbsp; You should make certain, however, that the image is 
	small enough that two copies will fit on the screen when stacked one 
	above the other.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The behavior of the ProgramTest program</b></font></p>
<p>The default image-processing program named <b>ProgramTest</b> draws a sloping white line 
across the image starting at the top left corner.&nbsp; A sample output 
produced by the image-processing program named <b>ProgramTest</b> with my image 
file named <b>junk.gif</b> is shown in 
Figure 5.</p>
<blockquote>
	<p><i>(You should be able to right-click on the image in Figure 6 and download and save the image locally in a file named <b>junk.gif</b>.)</i></p>
</blockquote>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java400e.gif" width="307" height="609">

<b>Figure 5  Default program output.</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Controlling the slope of the line</b></font></p>
<p>The white line in Figure 5 has a default slope of 1.0.&nbsp; The program named <b>
ProgramTest</b> provides an input dialog box that allows the user to specify the slope 
of the line.</p>
<p>To change the slope, the user types a new slope value into the text 
field in the dialog box <i>(not shown)</i> and clicks the <b>Replot</b> button 
at the bottom of Figure 5.&nbsp; This will cause the image to be reprocessed and 
the newly modified image will be displayed showing the line with the new slope.</p>
<blockquote>
	<p><i>(It isn't necessary to press the <b>Enter</b> key after typing the new slope 
value into the text field, but doing so won't cause any harm.&nbsp; Note that only positive slope values can be used. Entry of a 
negative slope value will cause an exception to be thrown.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Behavior with transparent areas</b></font></p>
<p>Other than to add the white line, the image-processing program named <b>
ProgramTest</b> does not modify the image in any way.&nbsp; Note however 
that it does draw a 
visible white line across transparent areas, making the pixels that constitute the 
line non-transparent.</p>
<blockquote>
	<p><i>(The image in Figure 5 doesn't have any transparent areas.</i></p>
	<p><i>The frame produced by the driver program has a yellow background.&nbsp; 
	You can see some of the background color showing between the two images in 
	Figure 5.&nbsp; Note that it 
may be difficult to see the white line against the default yellow background 
when the line is drawn across a transparent area in an image.)</i></p>
</blockquote>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p>As mentioned earlier, this lesson presents and explains two programs named
<b>ImgMod02</b> and <b>ProgramTest</b>.&nbsp; I will begin with a discussion of
<b>ImgMod02</b>.</p>
<p><font color="#FF0000"><b>The program named ImgMod02</b></font></p>
<p>The purpose of this program is to make it easy to experiment with the 
modification of pixel data in an image and to display the modified version of 
the image along with the original version of the image.</p>
<p><font color="#FF0000"><b>Extracting and saving the pixel data</b></font></p>
<p>The program extracts the pixel data from an image file into a 
three-dimensional array of 
type: </p>
<b><pre>int[row][column][color]</pre></b>
<p>The first two dimensions of the array correspond to the rows and columns of 
pixels in the image.&nbsp; The number of rows and columns will be different from 
one image to the next.</p>
<p>The third dimension always has four elements.&nbsp; The elements along that 
axis contains the following values by index value:</p>
<ul>
	<li>0 alpha </li>
	<li>1 red </li>
	<li>2 green </li>
	<li>3 blue </li>
</ul>
<p><font color="#FF0000"><b>Data type</b></font></p>
<p>Note that the values in the three-dimensional array are stored as type <b>int</b> rather than type
<i>unsigned byte,</i> which is the format of pixel data in the original image.</p>
<blockquote>
	<p><i>(Recall that type <b>byte</b> in Java is inherently signed.&nbsp; 
	There is no such thing as an <b>unsigned byte</b> in Java.&nbsp; Furthermore, all 
	arithmetic operations in Java are signed operations.&nbsp; As I recall, 
	there is only one unsigned operation in Java, and that is an unsigned right 
	shift operation.)</i></p>
</blockquote>
<p>This conversion to type <b>int</b> eliminates many problems involving the requirement to 
perform arithmetic on unsigned byte data.</p>
<p><font color="#FF0000"><b>Image file types supported</b></font> </p>
<p>The program supports <b>gif</b> and <b>jpg</b> files and possibly some other file types as 
well.&nbsp; If you are wondering about compatibility with a particular file 
type, just try using it.&nbsp; The program will abort with an error if the type 
isn't supported.</p>
<p><font color="#FF0000"><b>A framework or driver program</b></font></p>
<p>This program provides a framework that is designed to invoke another program 
to process the pixels extracted from an image.</p>
<p>In other words, this 
program extracts the pixels from an image and puts them in a format that is relatively easy to 
work with.&nbsp; A second program is then invoked to actually process the 
pixels.</p>
<p>The modified pixels are then returned to this program, which displays the 
modified image and the original image in the format shown in Figures 1 through 
5.</p>
<p><font color="#FF0000"><b>Usage information</b> </font> </p>
<p>To use the program in its most versatile form, enter the following at the 
command line: </p>
<b><pre>java ImgMod02 ProcessingProgramName ImageFileName</pre></b> </p>
<p>For test purposes, the source code includes a class definition for an 
image-processing program named <b>ProgramTest</b>. </p>
<p><font color="#FF0000"><b>Default image file is junk.gif</b></font></p>
<p>If the <i>ImageFileName</i> is omitted, the program 
will search for an image file in the current directory named <b>junk.gif </b>and 
will process it using the processing program specified by the second 
command-line argument. </p>
<p><font color="#FF0000"><b>Default processing program is ProgramTest</b></font></p>
<p>If both command-line arguments are omitted, the program will search for an 
image file in the current directory named <b>junk.gif </b>and will process it 
using the built-in processing program named <b>ProgramTest</b>.</p>
<p><font color="#FF0000"><b>Image file must be provided by the user</b></font></p>
<p>The image file must be provided by the user in all cases. However, it doesn't 
have to be in the current directory if a path to the file is specified on the 
command line.&nbsp; If the program is unable to load the image file within ten 
seconds, it will abort with an error message. </p>
<blockquote>
	<p><i>(As mentioned earlier, you should be able to right-click on the image 
	in Figure 6 and download and save the image locally under the file name <b>
	junk.gif</b>.&nbsp; Then you should be able to replicate the output produced in 
	Figure 5 by omitting both the image-processing program name and the image 
	file name.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Image display format</b></font></p>
<p>When the program is started, the original image and the processed image are 
displayed in a frame with the original image above the processed image.</p>
<p>A
<b>Replot</b> button appears at the bottom of the frame. If the user clicks the
<b>Replot</b> button, the image-processing method is rerun, the image is 
reprocessed and the new version of the processed image replaces the old version 
in the display. </p>
<p><font color="#FF0000"><b>Input to the image-processing program</b></font></p>
<p>The image-processing program may provide a GUI for data input making it possible 
for the user to modify the behavior of the image-processing method each time it 
is run. This capability is illustrated in the built-in processing program named
<b>ProgramTest</b>. </p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The image-processing program must implement the interface named <b>
ImgIntfc02</b>.&nbsp; A listing of that interface is provided in Listing 32.&nbsp; That interface declares a single method with the following 
signature:</p><b><pre>
int[][][] processImg(int[][][] threeDPix, 
                     int imgRows, 
                     int imgCols);</pre></b></p>
<p>The first parameter is a reference to a three-dimensional array of pixel data stored as 
type <b>int</b>.&nbsp; The second and third parameters specify the number of rows of 
pixels and the number of columns of pixels in the image. </p>
<p><font color="#FF0000"><b>Parameterized constructor not supported</b></font></p>
<p>The image-processing program cannot have a parameterized constructor.&nbsp; 
</p>
<blockquote>
	<p><i>(More correctly, if the image-processing program has one or more parameterized 
constructors, they will simply be ignored.) </i></p>
</blockquote>
<p>This is because an object of the image-processing class is instantiated by invoking the <b>newInstance</b> method of 
the class named <b>Class</b> on the name of the image-processing class provided 
as a <b>String</b> on the command line. This approach to object instantiation 
does not support parameterized constructors. </p>
<p>Similarly, if the image-processing program has a <b>main</b> method, it will 
also be ignored.&nbsp; Execution of code in the image-processing program is 
started by the invocation of the method named <b>processImg</b>.</p>
<p><font color="#FF0000"><b>More on the processImg method</b></font></p>
<p>The image-processing class must define the method named <b>processImg</b> 
with the signature given earlier.&nbsp; The <b>processImg</b> method receives a 
three-dimensional array containing pixel data.&nbsp; It should make a copy of the incoming 
array and modify the copy rather than modifying the original.&nbsp; Then the 
method should return a reference to the modified copy of the three-dimensional pixel array. </p>
<p>The method also receives the number of columns and the number of rows of 
pixels in the image represented by the three-dimensional array object.</p>
<p><font color="#FF0000"><b>Be careful of the range of values</b></font></p>
<p>The <b>processImg</b> method is free to modify 
the values of the pixels in the array in any manner before returning the 
modified array.&nbsp; Note however that native pixel data consists of four 
<i>unsigned</i> bytes.</p>
<p>If the modification of the pixel data produces negative 
values or positive value greater than 255, this should be dealt with before 
returning the modified pixel data.&nbsp; Otherwise, the returned values will 
simply be truncated to eight bits before display, and the result of displaying 
those truncated bits may not be as expected. </p>
<p><font color="#FF0000"><b>Dealing with out-of-range values</b></font></p>
<p>There are at least two ways to deal with this situation.&nbsp; One way is to 
simply clip all negative values at zero and to clip all values greater than 255 
at 255. </p>
<p>The other way is to perform a further modification and map values in the 
range from -x to +y into the range from 0 to 255.&nbsp; With this approach, all 
the pixel values would be modified in the same way such that the minimum value 
contained in all the pixel color values is 0 and the maximum value is 255.</p>
<p>There is no one approach that is<i> right </i>approach for all situations. </p>
<p><font color="#FF0000"><b>Display both images</b></font></p>
<p>As described earlier, when the <b>processImg</b> method returns, the program 
named <b>ImgMod02




</b> causes the original image and the modified image to be 
displayed in a frame on the screen with the original image being displayed above 
the modified image.&nbsp; Examples of this display format are shown in Figures 1 
through 5.</p>
<p><font color="#FF0000"><b>Some operational details</b></font></p>
<p>This program reads an image file from the disk and saves it in memory under 
the name <b>rawImg</b>.&nbsp; Then it declares a one-dimensional array of type
<b>int</b> of sufficient size to contain one <b>int</b> value for every pixel in 
the image. </p>
<blockquote>
	<p><i>(Each int value will later be populated with one alpha byte and three color 
	bytes.)</i></p>
</blockquote>
<p>The name of the one-dimensional array is <b>oneDPix</b>. </p>
<p>Then the program instantiates an object of type <b>PixelGrabber</b>, which 
associates the <b>rawImg</b> with the one-dimensional array of type <b>int</b>. </p>
<p>Following this, the program invokes the <b>grabPixels</b> method on the 
object of type <b>PixelGrabber</b> to cause the pixels in the <b>rawImg</b> to 
be extracted into <b>int</b> values and stored in the array named <b>oneDPix</b>.</p>
<p><font color="#FF0000"><b>Very similar to programs in earlier lessons</b></font></p>
<p>Down to this point, the program is very similar to programs that I explained 
in earlier lessons entitled
<a href="http://www.dickbaldwin.com/java/Java170.htm">Graphics - Introduction to 
Images</a> and <a href="http://www.dickbaldwin.com/java/Java174.htm">Graphics - 
Overview of Advanced Image Processing Capabilities</a>.&nbsp; I will simply 
refer you to those lessons and won't repeat those explanations in this lesson.</p>
<p><font color="#FF0000"><b>Copy pixel values to three-dimensional int array</b></font></p>
<p>Then the program copies the pixel values from the <b>oneDPix</b> array into 
the <b>threeDPix</b> array, converting them to type <b>int</b> in the process.&nbsp; 
This is done for two reasons:</p>
<ul>
	<li>To put the pixel data in a format that makes it easier to access for 
	processing.</li>
	<li>To change the type from <i>unsigned byte</i> to <b>int</b> to eliminate 
	the requirement to perform arithmetic on unsigned byte data.</li>
</ul>
<p>The type conversion process involves some very special data handling to cause 
the unsigned pixel values to become positive values of type <b>int</b>.&nbsp; I 
will explain that later.</p>
<p><font color="#FF0000"><b>Process the image</b></font></p>
<p>The <b>threeDPix</b> array is passed to an image-processing program that is 
either specified on the command line or specified by a default class name.&nbsp; 
The image-processing program returns a modified version of the three-dimensional array of pixel 
data. </p>
<p><font color="#FF0000"><b>Create new image from modified pixel data</b></font></p>
<p>The<b> ImgMod02 </b>program then creates a new version of the <b>oneDPix</b> 
array containing the modified pixel data.&nbsp; The program uses the <b>createImage</b> 
method of the <b>Component</b> class along with the constructor for the <b>
MemoryImageSource</b> class to create a new image from the modified pixel data.&nbsp; The name of the new image is
<b>modImg</b>. </p>
<p><font color="#FF0000"><b>Display the two images</b></font></p>
<p>Finally, the program overrides the <b>paint</b> method where it uses the <b>drawImage</b> method to display both the raw image and the modified image on the 
	same <b>Frame</b> object.&nbsp; The raw image is displayed above the modified image 
with a very small amount of the background color of the frame showing between 
the two. 
	</p>
<p><font color="#FF0000"><b>An ActionListener object</b></font></p>
<p>Along the way, the program registers an <b>ActionListener</b> object on the <b>
Replot</b> button on the bottom of the <b>Frame</b>.&nbsp; </p>
<p>When the user clicks 
the <b>Replot</b> button, the listener object invokes the <b>processImg</b> 
method again on the image-processing object, passing the <b>threeDPix</b> array 
as a parameter.&nbsp; This causes the <b>processImg</b> method to once again 
process the incoming pixel data and to return a three-dimensional array containing modified 
pixel data.&nbsp; </p>
<p>The listener object then causes the modified 
image to be displayed below the original image.&nbsp; </p>
<p>If the user has provided new and different input 
information to the image-processing object before clicking the <b>Replot</b> 
button, the newly displayed modified image may be different from the 
previously displayed version of the modified image.</p>
<p><font color="#FF0000"><b>Testing</b></font></p>
<p>This program was tested using SDK 1.4.2 under WinXP.</p>

<p><font color="#FF0000"><b>Will discuss the program in fragments</b></font></p>
<p>As is my custom, I will break the program down and discuss it in fragments.&nbsp; 
A complete listing of the program is provided in Listing 31 near the end of the 
lesson.</p>
<p><font color="#FF0000"><b>The ImgMod02 class</b></font></p>
<p>The <b>ImgMod02</b> class definition begins in Listing 1.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class ImgMod02 extends Frame{
  Image rawImg;
  int imgCols;//Number of horizontal pixels
  int imgRows;//Number of rows of pixels
  Image modImg;//Reference to modified image

  //Inset values for the Frame
  int inTop;
  int inLeft;

<b>Listing 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Note that the class extends <b>Frame</b>.&nbsp; In addition to being the 
control program, it is also the display GUI.</p>
<blockquote>
	<p><i>(In case you prefer the use of Swing components, you could easily use 
	a <b>JFrame</b> instead by adding the invocation of <b>getContentPane</b> at 
	the appropriate places.)</i></p>
</blockquote>
<p>Listing 1 declares several instance variables with descriptive names and 
comments.&nbsp; I will explain the use of these variables later.</p>
<p><font color="#FF0000"><b>Default image-processing program and image file</b></font></p>
<p>Listing 2 declares and initializes <b>String</b> instance variables with the 
names of the default image-processing program and the default image file name.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  static String theProcessingClass =
                                   "ProgramTest";

  static String theImgFile = "junk.gif";

<b>Listing 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>As explained earlier, the default image file will be used if the user omits 
the name of the image file from the command line.&nbsp; The user must provide 
this image file in the current directory.</p>
<p>The default image-processing program will be used if the user omits both the 
name of the image file and the name of the image-processing program from the 
command line.</p>
<p><font color="#FF0000"><b>Additional instance variables</b></font></p>
<p>Listing 3 declares additional instance variables and initializes some of 
them.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  MediaTracker tracker;
  Display display = new Display();//A Canvas
  Button replotButton = new Button("Replot");

  //References to arrays that store pixel data.
  int[][][] threeDPix;
  int[][][] threeDPixMod;
  int[] oneDPix;

  //Reference to the image-processing object.
  ImgIntfc02 imageProcessingObject;

<b>Listing 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>I will explain the use of the instance variables in Listing 3 later.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>Listing 4 shows the beginning of the <b>main</b> method.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public static void main(String[] args){

    if(args.length == 0){
      //Use default processing class and default
      // image file.  No code required here.
      // Class and file names were specified
      // above.  This case is provided for
      // information purposes only.
    }else if(args.length == 1){
      theProcessingClass = args[0];
      //Use default image file
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

<b>Listing 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 4 provides the logic to handle the command line arguments and 
implement the previously described behavior involving the default image file 
name and the default image-processing program.</p>
<p>This code in Listing 4 is straightforward and shouldn't require further explanation beyond 
the embedded comments.</p>
<p><font color="#FF0000"><b>Display name of image-processing program and image 
file</b></font></p>
<p>Listing 5 displays the name of the image-processing program and the image 
file to be processed.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    System.out.println("Processing program: "
                           + theProcessingClass);
    System.out.println("Image file: "
                                 + theImgFile);

<b>Listing 5</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The code in Listing 5 is straightforward.</p>
<p><font color="#FF0000"><b>Instantiate an object of the ImgMod02 class</b></font></p>
<p>Listing 6 invokes the constructor for the ImgMod02 class to create an 
instance of the class.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    ImgMod02 obj = new ImgMod02();
  }//end main

<b>Listing 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 6 also signals the end of the <b>main</b> method.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor begins in Listing 7.&nbsp; The code in Listing 7 gets an 
image from the specified image file.&nbsp; The file can be in a different 
directory from the current directory if the path to the file is provided on the 
command line along with the file name.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public ImgMod02(){//constructor

    rawImg = Toolkit.getDefaultToolkit().
                            getImage(theImgFile);

    //Use a MediaTracker object to block until
    // the image is loaded or ten seconds has
    // elapsed.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImg,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully
    // loaded.
    if((tracker.statusAll(false)
                   & MediaTracker.ERRORED
                   & MediaTracker.ABORTED) != 0){
      System.out.println(
                      "Load errored or aborted");
      System.exit(1);
    }//end if

<b>Listing 7</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Code very similar to the code in Listing 7 was explained in previous lessons 
entitled <a href="http://www.dickbaldwin.com/java/Java170.htm">Graphics - 
Introduction to Images</a> and
<a href="http://www.dickbaldwin.com/java/Java174.htm">Graphics - Overview of 
Advanced Image Processing Capabilities</a>.&nbsp; I will simply refer you to those 
lessons and won't repeat that explanation in this lesson. </p>
<p><font color="#FF0000"><b>Image has been loaded</b></font></p>
<p>At this point, the image contained in the image file has been loaded into 
memory.&nbsp; The code in Listing 8 begins by getting the width and the height 
of the image measured in pixels.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    imgCols = rawImg.getWidth(this);
    imgRows = rawImg.getHeight(this);

    this.setTitle("Copyright 2004, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.SOUTH);

<b>Listing 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>In addition, the code in Listing 8:</p>
<ul>
	<li>Sets some GUI properties including a yellow background color.</li>
	<li>Adds the display <i>(a <b>Canvas</b> object)</i> to the frame.</li>
	<li>Adds the <b>Replot</b> button to the bottom of the frame.</li>
</ul>
<p><font color="#FF0000"><b>Set the Frame size</b></font></p>
<p>At this point, I need to set the size of the frame to accommodate the sizes 
of the images that will be displayed later.&nbsp; The code to accomplish this is shown in 
Listing 9.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Make it possible to get insets and the
    // height of the button.
    <b>setVisible(true);</b>
    //Get and store inset data for the Frame and
    // the height of the button.
    <b>inTop = this.getInsets().top;
    inLeft = this.getInsets().left;
    int buttonHeight =
                   replotButton.getSize().height;</b>
    //Size the frame
    <b>this.setSize(2*inLeft+imgCols + 1,inTop
                 + buttonHeight + 2*imgRows + 7);</b>

<b>Listing 9</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>To begin with, I need to invoke the <b>getInsets</b> method on the frame in order to get the 
size of the banner at the top and the size of the borders on the sides and the bottom.&nbsp; 
In addition, I need to get the height of the <b>Replot</b> button at the bottom 
of the frame.&nbsp; I need to make the <b>Frame</b> large enough that a <b>
Canvas</b>, which is twice the size of the image, will fit inside the banner, the 
borders, and the button.</p>
<p><font color="#FF0000"><b>Set visible property to true</b></font></p>
<p>In order to use <b>getInsets</b> to get the size of the banner and the 
borders, the <b>visible</b> property must be true.&nbsp; Therefore, the code in 
Listing 9 begins by invoking the <b>setVisible</b> method with a <b>true</b> 
parameter.</p>
<p>Then the code in Listing 9 invokes the appropriate methods to get and save 
the needed information.</p>
<p><font color="#FF0000"><b>Set the Frame size</b></font></p>
<p>Finally, the code in Listing 9 sets the size of the frame so that a small 
amount of the yellow background will show on the right and on the bottom when 
both images are displayed in the frame.&nbsp; Also, as you will see later, the 
placement of the images on the <b>Canvas</b> allows a small amount of the yellow 
background to show through between the two images.</p>
<blockquote>
	<p><i>(See Figure 5 for an example of the result of this sizing process.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>An ActionListener registered on the Replot button</b></font></p>
<p>Listing 10 shows the beginning of an anonymous inner class that is used to 
register an <b>ActionListener</b> object on the <b>Replot</b> button.</p>
<p>The <b>actionPerformed</b> method defined in the class is invoked whenever 
the user clicks the <b>Replot</b> button.</p>
<blockquote>
	<p><i>(The method is also invoked once at startup when the program posts a 
	counterfeit <b>ActionEvent</b> to the 
system event queue and attributes the event to the <b>Replot</b> button.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    replotButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          threeDPixMod =
                imageProcessingObject.processImg(
                      threeDPix,imgRows,imgCols);

<b>Listing 10</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Behavior of the actionPerformed method</b></font></p>
<p>The <b>actionPerformed</b> method that begins in Listing 10 invokes the <b>
processImg</b> method on the image-processing object, passing a reference to a 
three-dimensional array object containing pixel data.&nbsp; In addition, the number of rows and the number of columns of 
pixels in the image represented by the three-dimensional array object are passed 
as parameters.</p>
<p>The <b>processImg</b> method processes the image and returns a 
three-dimensional array 
object containing pixel data for a modified version of the image.</p>
<p><font color="#FF0000"><b>Convert pixel data back to a one-dimensional array</b></font></p>
<p>Later we will see that the <b>grabPixels</b> method of the <b>PixelGrabber</b> 
class is used to extract the pixel data from the image into a one-dimensional 
array of type <b>int</b>.&nbsp; Then we will see that a method of my own design 
is used to copy that pixel data into a three-dimensional array that is more suitable for 
processing.&nbsp; That is the three-dimensional array that is passed to the <b>processImg</b> 
method in Listing 10.</p>
<p>In order to display the modified image, we need to populate a new object of 
type <b>Image</b> with the modified pixel data.&nbsp; In order to do that, we 
need to convert the pixel data back into a one-dimensional array of type <b>int</b> 
in the same format originally produced by the <b>grabPixels</b> method.</p>
<p>This seems like as good a time as any to explain the formats of the 
one-dimensional and three-dimensional arrays that contain pixel data.</p>
<p><font color="#FF0000"><b>Format of the one-dimensional pixel array</b></font></p>
<p>The <b>grabPixels</b> method of the <b>PixelGrabber</b> class extracts the 
pixel data from an <b>Image</b> object into a one-dimensional array of type <b>
int</b>.</p>
<p>Each element in the array contains the four unsigned data bytes that 
represent a single pixel.&nbsp; The most significant byte contains the alpha or 
transparency data.&nbsp; Moving from most to least significant, the remaining 
bytes contain the unsigned values for red, green, and blue in that order.</p>
<p>If the image has N columns of pixels in each row, the first N elements in the 
array contain the data for the first row; the second N elements contain the data 
for the second row, etc.</p>
<p><font color="#FF0000"><b>Format of the three-dimensional pixel array</b></font></p>
<p>To make it easier to process the pixel data, a method named <b>
convertToThreeDim</b> is used to extract the pixel data from the one-dimensional 
array and to populate a three-dimensional array of type <b>int</b>.&nbsp; Each
<b>byte</b> in the one-dimensional array is used to populate the bottom eight 
bits of an element of type <b>int</b> in the three-dimensional array.</p>
<p>The dimensions of the three-dimensional array are <i>row,</i> <i>col,</i> and <i>color</i> in that order. 
Row and col correspond to the rows and columns of the image measured in 
pixels. Color corresponds to transparency and color information at the following 
index levels in the third dimension:</p>
<ul>
	<li>0 alpha</li>
	<li>1 red</li>
	<li>2 green</li>
	<li>3 blue</li>
</ul>
<p>I will set the discussion of the <b>actionPerformed</b> method aside for the 
time being and explain the two methods that are used to convert the pixel data 
back and forth between the one-dimensional and three-dimensional array formats.</p>
<p><font color="#FF0000"><b>The convertToThreeDim method</b></font></p>
<p>The <b>convertToThreeDim</b> method begins in Listing 11.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  int[][][] convertToThreeDim(
          int[] oneDPix,int imgCols,int imgRows){
    //Create the new 3D array to be populated
    // with color data.
    int[][][] data =
                    new int[imgRows][imgCols][4];

<b>Listing 11</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The purpose of this method is to convert the data in the one-dimensional <b>int</b> array 
<i>(containing pixel data of type unsigned byte)</i> into a three-dimensional array of type <b>int</b>.</p>
<p>The structure of 
the code in this method is determined by the way the pixel data is formatted into the 
one-dimensional 
array of type <b>int</b> produced by the <b>grabPixels</b> method of the <b>PixelGrabber</b> object.</p>
<p><font color="#FF0000"><b>Create an empty three-dimensional array object</b></font></p>
<p>The code in Listing 11 begins by creating a new empty three-dimensional array 
object that will be 
populated with pixel data.&nbsp; The data corresponding to a specific pixel in 
the three-dimensional array will be located at the intersection of a specific 
row and a specific column.&nbsp; That data will consist of four elements of type
<b>int</b> where the least significant eight bits of each <b>int</b> element are 
populated with the eight bits corresponding to an eight-bit unsigned color or 
alpha value.&nbsp; The most significant twenty-four bits of each element will be 
set to 0.</p>
<p>When populating the elements in this array, care will be taken to ensure that 
the unsigned eight-bit values are not allowed to sign-extend into the upper 
twenty-four bits of the <b>int</b> value, even for unsigned byte values of <b>
0x80</b> and higher.</p>
<p><font color="#FF0000"><b>Extract each row of pixel data</b></font></p>
<p>The algorithm for extracting the pixel data from the one-dimensional array 
and populating the three-dimensional array handles one row of pixels at a time.</p>
<p>Listing 12 shows the beginning of a <b>for</b> loop that iterates once for 
each row of pixels in the image.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int row = 0;row < imgRows;row++){
      //Extract a row of pixel data into a
      // temporary array of ints
      int[] aRow = new int[imgCols];
      for(int col = 0; col < imgCols;col++){
        int element = row * imgCols + col;
        aRow[col] = oneDPix[element];
      }//end for loop on col

<b>Listing 12</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 12 begins by extracting one row of pixel data from the original 
one-dimensional array that contains the entire image into a new temporary 
one-dimensional array that contains the pixel data for one row only.</p>
<p>The code in Listing 12 contains an inner <b>for</b> loop that iterates on 
columns.&nbsp; Each time that loop terminates, the one-dimensional array 
referred to by <b>aRow</b> contains one element of type <b>int</b> for each 
pixel in the row.&nbsp; Each element of type <b>int</b> contains one alpha byte 
and there color bytes in the packed format described earlier.</p>
<p><font color="#FF0000"><b>Populate the three-dimensional array for each row</b></font></p>
<p>The code in Listing 13 contains a <b>for</b> loop that iterates once for each 
pixel in the row.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
      //Move the data into the 3D array.  Note
      // the use of bitwise AND and bitwise right
      // shift operations to mask all but the
      // correct set of eight bits.
      for(int col = 0;col < imgCols;col++){
        //Alpha data
        data[row][col][0] = (aRow[col] >> 24)
                                          & 0xFF;
        //Red data
        data[row][col][1] = (aRow[col] >> 16)
                                          & 0xFF;
        //Green data
        data[row][col][2] = (aRow[col] >> 8)
                                          & 0xFF;
        //Blue data
        data[row][col][3] = (aRow[col])
                                          & 0xFF;
      }//end for loop on col
    }//end for loop on row
    return data;
  }//end convertToThreeDim

<b>Listing 13</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>During each iteration, the code in Listing 13 shifts each unsigned byte of 
interest into the least significant eight bits of an <b>int</b>.&nbsp; Then it 
performs a bitwise <b><i>and</i></b> operation with the hexadecimal value <b>
0xFF</b> to force the twenty-four most significant bits to have a value of zero 
and to preserve the values of the eight least-significant bits.&nbsp; This 
operation is performed once for the alpha byte and once for each of the three 
color bytes.</p>
<p><font color="#FF0000"><b>The end result</b></font>&nbsp; </p>
<p>The end result is that each of the four color/alpha elements of type <b>int</b> at the 
intersection of a specific row and a specific column consists of an <b>int</b> 
element 
with zeros in the twenty-four most significant bits and the values of the bits 
from the original unsigned byte in the eight least-significant bits.&nbsp; The 
four elements at the intersection contain the values for the alpha byte and the three color bytes 
for a single pixel.</p>
<p><font color="#FF0000"><b>The convertToOneDim method</b></font></p>
<p>We started down this side trip in our discussion of the inner class used to 
register an <b>ActionListener</b> object on the <b>Replot</b> button.&nbsp; We 
had reached the point in that discussion where we were just about to say that 
the following code converts the modified pixel data in the three-dimensional 
array back into a one-dimensional array so that it can be used to create a new 
object of type <b>Image</b>.</p>
<p>At that point, we decided to explain the format of the one-dimensional array 
and the three-dimensional array and to discuss the methods used to convert the 
data back and forth between the two.</p>
<p>At this point, you understand the format of the one-dimensional array 
produced by the <b>grabPixels</b> method of the <b>PixelGrabber</b> class, and 
you understand the format of the three-dimensional array produced by the method 
named <b>convertToThreeDim</b>.</p>
<p>Listing 14 contains the entire method named <b>convertToOneDim</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  int[] convertToOneDim(
         int[][][] data,int imgCols,int imgRows){
    //Create the 1D array of type int to be
    // populated with pixel data, one int value
    // per pixel, with four color and alpha bytes
    // per int value.
    int[] oneDPix = new int[
                          imgCols * imgRows * 4];

    //Move the data into the 1D array.  Note the
    // use of the bitwise OR operator and the
    // bitwise left-shift operators to put the
    // four 8-bit bytes into each int.
    for(int row = 0,cnt = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        oneDPix[cnt] = ((data[row][col][0] << 24)
                                   & 0xFF000000)
                     | ((data[row][col][1] << 16)
                                   & 0x00FF0000)
                      | ((data[row][col][2] << 8)
                                   & 0x0000FF00)
                           | ((data[row][col][3])
                                   & 0x000000FF);
        cnt++;
      }//end for loop on col

    }//end for loop on row

    return oneDPix;
  }//end convertToOneDim
}//end ImgMod02.java class

<b>Listing 14</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
<p><font color="#FF0000"><b>Reverse the process</b></font></p>
<p>The purpose of the <b>convertToOneDim</b> method is to convert the data in the 
three-dimensional array of type back into a one-dimensional array of type int in the 
same format as that produced by the <b>grabPixels</b> method of the <b>
PixelGrabber</b> class.</p>
<p>This is the reverse of the process implemented by the method named <b>convertToThreeDim</b>.&nbsp; 
If you understand the use of bitwise operators, the code in Listing 14 shouldn't 
require further explanation.&nbsp; If not, you can learn a little about bitwise 
operators in the earlier lesson entitled
<a href="http://www.dickbaldwin.com/java/Java022.htm#bitwiseoperations">
Operators</a>.</p>
<p><font color="#FF0000"><b>Back to the actionPerformed method</b></font></p>
<p>Now it's time to pick back up with the discussion of the <b>actionPerformed</b> 
method where we left off with Listing 10.&nbsp; I had just explained that in 
order to display the modified image based on the pixel data received in Listing 
10, we need to convert that data back into a one-dimensional array in the format 
produced by the <b>grabPixels</b> method.</p>
<p>Listing 15 picks up with the next statement in the <b>actionPerformed</b> 
method.</p>
<p><font color="#FF0000"><b>Convert pixel data to a one-dimensional array format</b></font></p>
<p>The statement in Listing 15 invokes the <b>convertToOneDim</b> method to 
convert the modified pixel data in the three-dimensional array back into a 
one-dimensional array in the correct format.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
//In the actionPerformed method

          oneDPix = convertToOneDim(
                   threeDPixMod,imgCols,imgRows);

<b>Listing 15</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Create a new Image object</b></font></p>
<p>The statement in Listing 16 uses the <b>createImage</b> method and the <b>
MemoryImageSource</b> class to create a new object of type <b>Image</b>, 
referred to by the variable named <b>modImg</b>.</p>
<blockquote>
	<p><i>(Once again, I explained this procedure in the earlier lesson entitled
	<a href="http://www.dickbaldwin.com/java/Java174.htm">Graphics - Overview of 
	Advanced Image Processing Capabilities</a>.&nbsp; You can read an 
	explanation there.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          //Use the createImage() method to
          // create a new image from the 1D array
          // of pixel data.
          modImg = createImage(
             new MemoryImageSource(
             imgCols,imgRows,oneDPix,0,imgCols));

<b>Listing 16</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Repaint the display</b></font></p>
<p>Finally, the code in Listing 17 requests a repaint on the <b>Canvas</b> 
object.&nbsp; This causes the overridden <b>paint</b> method of the <b>Display</b> 
class to be invoked to draw the original image and the modified image in the 
frame on the screen.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          display.repaint();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class.

<b>Listing 17</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>We will see the code for the overridden <b>paint</b> method a little later.</p>
<p>Listing 7 signals the end of the definition of the anonymous inner class.</p>
<p><font color="#FF0000"><b>Now back to the constructor</b></font></p>
<p>Now it's time to pick back up with the discussion of the constructor where we 
left off in Listing 9, before getting involved in the discussion of the inner 
class for the <b>ActionListener</b> object.</p>
<p><font color="#FF0000"><b>Create a one-dimensional array object</b></font></p>
<p>The code in Listing 18 creates an empty one-dimensional array object that will later 
be populated with pixel data produced by the <b>grabPixels</b> method.&nbsp; 
These pixels will represent the original image.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    oneDPix = new int[imgCols * imgRows];

<b>Listing 18</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Get the pixel data from the original image</b></font></p>
<p>The code in Listing 19 extracts the pixel data from the original image and 
stores it in the one-dimensional array created in Listing 18.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Convert the rawImg to numeric pixel
    // representation.  Note that grapPixels()
    // throws InterruptedException
    try{
      //Instantiate a PixelGrabber object
      // specifying oneDPix as the array in which
      // to put the numeric pixel data. See Sun
      // docs for parameters
      PixelGrabber pgObj = new PixelGrabber(
                      rawImg,0,0,imgCols,imgRows,
                              oneDPix,0,imgCols);
      //Invoke the grabPixels() method on the
      // PixelGrabber object to extract the pixel
      // data from the image into an array of
      // numeric pixel data stored in oneDPix.
      // Also test for success in the process.
      if(pgObj.grabPixels() &&
                           ((pgObj.getStatus() &
                           ImageObserver.ALLBITS)
                                          != 0)){

<b>Listing 19</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>You can read an explanation of this code in the earlier lesson entitled
<a href="http://www.dickbaldwin.com/java/Java174.htm">Graphics - Overview of 
Advanced Image Processing Capabilities</a>. </p>
<p><font color="#FF0000"><b>Convert pixel data to three-dimensional format</b></font></p>
<p>At this point, the pixel data has been extracted from the original image and 
has been stored in a one-dimensional array.&nbsp; It is time to convert that pixel data 
to the three-dimensional array format that provides for ease of access while 
processing the pixels.</p>
<p>This is accomplished by the code in Listing 20, which invokes the <b>
convertToThreeDim</b> method to make the conversion.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        threeDPix = convertToThreeDim(
                        oneDPix,imgCols,imgRows);

<b>Listing 20</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Instantiate an image-processing object</b></font></p>
<p>At this point, we have captured the pixel data from the original image in a 
three-dimensional array suitable for processing.&nbsp; All we lack is an object 
to do the processing.</p>
<p>The statement in Listing 21 invokes the <b>newInstance</b> method of the 
class named <b>Class</b> to instantiate an object of the image-processing 
class whose name was provided as a <b>String</b> in a command-line parameter.</p>
<blockquote>
	<p><i>(The name of the image-processing class may also have been obtained by 
	default if the user failed to specify the class name on the command line.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        try{
          imageProcessingObject = (
               ImgIntfc02)Class.forName(
               theProcessingClass).newInstance();

<b>Listing 21</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The use of the class named Class</b></font></p>
<p>If you are unfamiliar with this approach to the instantiation of objects, you 
can learn about it in the earlier lesson entitled
<a href="http://www.dickbaldwin.com/java/Java044.htm">More on Inheritance</a>.&nbsp; 
You will also find examples of the use of this approach in the lesson entitled
<a href="http://www.developer.com/java/article.php/10922_1382101_1">The Essence 
of OOP using Java, Array Objects, Part 3</a>, as well as in numerous other 
lessons on my <a href="http://www.dickbaldwin.com/">website</a>.</p>
<p>Note that this approach does not support the use of parameterized 
constructors.</p>
<p><font color="#FF0000"><b>Fire an ActionEvent</b></font></p>
<p>At this point, we have the pixel data in the correct format and we have an 
image-processing object that will process those pixels and return an array 
containing modified pixel values.&nbsp; All we need to do is to invoke the <b>
processImg</b> method on the image-processing object passing the pixel data and 
other appropriate information as parameters.</p>
<p>This is accomplished in Listing 22.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          Toolkit.getDefaultToolkit().
                getSystemEventQueue().postEvent(
                  new ActionEvent(
                    replotButton,
                    ActionEvent.ACTION_PERFORMED,
                    "Replot"));

<b>Listing 22</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Post a counterfeit ActionEvent to the system event 
queue</b></font></p>
<p>Listing 22 posts a counterfeit <b>ActionEvent</b> to the system event queue 
and attributes the event to the <b>Replot</b> button.&nbsp; The result is 
exactly the same as if the user had clicked the <b>Replot</b> button.&nbsp; In 
either case, the <b>actionPerformed</b> method <i>
(see Listing 10)</i> is executed.</p>
<blockquote>
	<p><i>(If you are unfamiliar with the use of the system event queue, you can 
	learn about it in the earlier lesson entitled <font color="#000000">
	<a href="http://www.dickbaldwin.com/java/Java104.htm">Posting Synthetic 
	Events to the System Event Queue</a>.</font>)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Invoke the processImg method</b></font></p>
<p>Referring back to the <b>actionPerformed</b> method in Listing 10, we see 
that posting this event causes the image-processing method named <b>processImg to</b> 
be invoked, passing the three-dimensional array of pixel data to the method, and 
receiving a three-dimensional array of modified pixel data back from the 
method.</p>
<p><font color="#FF0000"><b>Create and display a modified image</b></font></p>
<p>Referring back to Listings 15, 16, and 17, we also see that the <b>
actionPerformed</b> method causes the modified pixel data to be used to create a 
new <b>Image</b> object, and causes that new image object to be displayed, along 
with the original image in the frame.</p>
<p><font color="#FF0000"><b>The first image-processing pass is complete</b></font></p>
<p>At this point, the image has been processed and both the original image and 
the modified image have been displayed.&nbsp; From this point forward, each 
time the user clicks the <b>Replot</b> button, the image will be processed again 
and the new modified image will be displayed along with the original image.</p>
<p><font color="#FF0000"><b>Remaining constructor code</b></font></p>
<p>The remaining code in the constructor is completely straightforward, so I 
won't discuss it further.&nbsp; You can view that code in Listing 31 near the 
end of the lesson.</p>
<p><font color="#FF0000"><b>The Display class</b></font></p>
<p>An object of the inner class shown in Listing 23 is a <b>Canvas</b> object upon 
which the two images are drawn.</p>
<blockquote>
	<p><i>(Recall that an object of the <b>Display</b> class was added to the client 
	area of the <b>Frame</b> object in Listing 8.&nbsp; The <b>Display</b> class 
	extends the <b>Canvas</b> class.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  class Display extends Canvas{
    public void paint(Graphics g){
      //First confirm that the image has been
      // completely loaded and neither image
      // reference is null.
      if (tracker.statusID(1, false) ==
                          MediaTracker.COMPLETE){
        if((rawImg != null) &&
                               (modImg != null)){
          g.drawImage(rawImg,0,0,this);
          g.drawImage(modImg,0,imgRows + 1,this);
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas

<b>Listing 23</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Overriding the paint method</b></font></p>
<p>Listing 23 overrides the <b>paint</b> method, causing the two images to be 
drawn on the canvas, which is the standard way of drawing on a <b>Canvas</b> 
component in Java.&nbsp; <i>(I have used and discussed overridden <b>paint</b> 
methods in numerous earlier lessons.)</i></p>
<p>The overridden <b>paint</b> method is invoked whenever there is a requirement 
to repaint the canvas.&nbsp; This can occur for a variety of reasons, including 
the invocation of the <b>repaint</b> method in the <b>ActionEvent</b> handler in 
Listing 17.</p>
<p>With the possible exception of the code involving the <b>MediaTracker</b>, 
the code in Listing 23 is straightforward and shouldn't require further 
discussion.</p>
<blockquote>
	<p><i>(Once again, you can learn about <b>MediaTracker</b> in the earlier 
	lessons entitled <a href="http://www.dickbaldwin.com/java/Java170.htm">
	Graphics - Introduction to Images</a> and
	<a href="http://www.dickbaldwin.com/java/Java174.htm">Graphics - Overview of 
	Advanced Image Processing Capabilities</a>.&nbsp; I will simply refer you to 
	those lessons and won't repeat that explanation in this lesson.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>End of ImgMod02 program</b></font></p>
<p>That completes the discussion of the <b>ImgMod02</b> program, and brings us 
to the topic of the built-in image-processing program named <b>ProgramTest</b>.</p>
<p>Fortunately, the <b>ProgramTest</b> program is much simpler than the <b>ImgMod02</b> 
program.&nbsp; This is fortunate because in order to experiment with different 
image-processing algorithms, you only need to replace the program named <b>
ProgramTest</b>.&nbsp; You can use the program named <b>ImgMod02</b>, as 
written, with no changes.</p>
<p><font color="#FF0000"><b>The program named ProgramTest</b></font></p>
<p>The purpose of this program class is to provide a simple example of an 
image-processing class that is compatible with the program named <b>ImgMod02</b>.</p>
<p>The constructor for the class displays a small <b>Frame</b> on the screen 
with a single <b>TextField</b> object. The purpose of the text field is to allow 
the user to enter a value that represents the slope of a line.</p>
<p>In operation, the user types a value into the text field and then clicks the
<b>Replot</b> button on the main image display frame.&nbsp; The user is not 
required to press the <b>Enter</b> key after typing the new value, but it 
doesn't do any harm to do so.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The class defines a method named <b>processImg</b> with the signature shown 
in Listing 32 near the end of the lesson.</p>
<p>The method named <b>processImg</b> receives a three-dimensional array 
containing alpha, red, green, and blue pixel values for an image.&nbsp; The 
values are received as type <b>int</b> <i>(not type byte).</i>&nbsp; </p>
<p><font color="#FF0000"><b>Copy and modify the pixels</b></font></p>
<p>A copy of the <b>threeDPix</b> array is made and saved.&nbsp;&nbsp; 
The copy is then modified to cause a white diagonal line to be drawn down and to 
the right from the upper left corner of the image when the modified pixels are 
used to create and display a new image.&nbsp; The 
three-dimensional array containing the modified pixel data is then returned to 
the calling method named <b>actionPerformed</b> in the program named <b>ImgMod02</b>.</p>
<p><font color="#FF0000"><b>The initial slope is 1.0</b></font></p>
<p>The first time the <b>processImg </b>method<b> </b>is invoked, the slope of 
the line has a value of 1.0.&nbsp; Thereafter, the slope of the line is 
controlled by a value that is typed into the text field prior to clicking the
<b>Replot</b> button.&nbsp; Note that negative slope values will cause the 
program to throw an exception and abort.</p>
<p>The image is not modified in any way other than to draw the sloping white 
line on the image.</p>
<p>To cause a new line to be drawn, type a slope value into the text field and 
click the <b>Replot</b> button at the bottom of the image display frame.</p>
<p><font color="#FF0000"><b>Extends Frame and implements ImgIntfc02</b></font></p>
<p>This class extends <b>Frame</b> because it provides a GUI for user data 
input.&nbsp; However, a class that is compatible with <b>ImgMod02</b> is not 
required to extend the <b>Frame</b> class.</p>
<p>A compatible class is required, however, to implement the interface named <b>
ImgIntfc02</b>.&nbsp; A listing of the interface is shown in Listing 32.</p>
<p><font color="#FF0000"><b>The class definition for ProgramTest</b></font></p>
<p>The beginning of the <b>ProgramTest</b> class, including the declaration of 
some instance variables is shown in Listing 24.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class ProgramTest extends Frame
                           implements ImgIntfc02{

  double slope;//Controls the slope of the line
  String inputData;//Obtained via the TextField
  TextField inputField;//Reference to TextField

<b>Listing 24</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The entire constructor is shown in Listing 25.</p>
<blockquote>
	<p><i>(Recall that the constructor must not require any parameters in order 
	to be compatible with the program named <b>ImgMod02</b>.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  //Constructor must take no parameters
  ProgramTest(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    Label instructions = new Label(
               "Type a slope value and Replot.");
    add(instructions);

    inputField = new TextField("1.0",5);
    add(inputField);

    setTitle("Copyright 2004, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor

<b>Listing 25</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Initial value in the text field</b></font></p>
<p>The code in the constructor is completely straightforward and should not 
require any further discussion.&nbsp; However, I will point out that the new <b>
TextField</b> object is instantiated with an initial value of&nbsp; &quot;1.0&quot; for 
the <b>text</b> property.&nbsp; This is what causes the line to have a slope of 
1.0 the first time the <b>processImg</b> method is invoked <i>(before the user 
has an opportunity to change the value).</i></p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>Because this class implements the <b>ImgIntfc02</b> interface, and because 
that interface declares the <b>processImg</b> method, this class must define the 
method.</p>
<p>The beginning of the <b>processImg</b> method is shown in Listing 26.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public int[][][] processImg(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    System.out.println("Program test");
    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

<b>Listing 26</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Note that in addition to receiving a three-dimensional array containing the 
pixel data for the image, the method also receives the number of rows and the 
number of columns of pixels in the image.</p>
<p>The code in Listing 26 simply displays some interesting information about the 
image being processed.</p>
<p><font color="#FF0000"><b>Make a working copy</b></font></p>
<p>The code in Listing 27 makes a working copy of the three-dimensional array of 
pixel data in order to avoid making permanent changes to the original image 
data.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];

    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

<b>Listing 27</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Get the slope value</b></font></p>
<p>Listing 28 gets the slope value from the text field as type <b>String</b> and 
converts it to type <b>double</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    slope = Double.parseDouble(
                           inputField.getText());

<b>Listing 28</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The equation for a straight line</b></font></p>
<p>You may recall from your analytical geometry class that the equation for a 
straight line in Cartesian coordinates is:</p><b><pre>
y = m * x + b

where:
m is the slope of the line
b is the intersection of the line with the y-axis
</pre></b></p>
<p>In our case, the intersection value is 0 and the slope is the value obtained 
from the text field.</p>
<p>You may also remember that when drawing graphics on a computer screen using 
Java, the positive direction for the y-axis is down the screen.&nbsp; Thus, a 
line with a positive slope will go down and to the right.</p>
<p><font color="#FF0000"><b>Draw a white line on the working copy of the image 
data</b></font></p>
<p>Listing 29 modifies the pixel values such that when the modified pixels are 
rendered as an object of type <b>Image</b>, a white line will originate at the 
upper left corner of the image and proceed down and to the right.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int col = 0;col < imgCols;col++){
      int row = (int)(slope*col);
      if(row > imgRows -1)break;
      //Set values for alpha, red, green, and
      // blue colors.
      temp3D[row][col][0] = (byte)0xff;
      temp3D[row][col][1] = (byte)0xff;
      temp3D[row][col][2] = (byte)0xff;
      temp3D[row][col][3] = (byte)0xff;
    }//end for loop

<b>Listing 29</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Equivalent variables</b></font></p>
<p>In Listing 29, the variable <b>col</b> is equivalent to the variable <b>x</b> 
in the equation of a straight line given earlier.&nbsp; Similarly, the variable <b>row</b> is 
equivalent to the variable <b>y</b> in that equation.&nbsp; The variable <b>slope</b> is 
equivalent to the variable <b>m</b> in that equation.</p>
<p>The value of <b>slope</b> used to 
relate each pixel on the x-axis <i>(col)</i> to a specific pixel on the y-axis
<i>(row)</i>.</p>
<p>Once that relationship has been determined for each value of <b>col</b>, the 
alpha value and each of the three color values for the pixel at the intersection of 
that value of <b>col</b> and that value of <b>row</b> is set to <b>0xff</b> <i>(255).</i>&nbsp; 
The new values replace the previous alpha and color values for that pixel.</p>
<p>Setting the alpha value to <b>0xff</b> causes the pixel to be completely opaque.&nbsp; 
Setting all three color values to <b>0xff</b> causes the combination of those three 
color contributions to result in a pixel that appears white to a human observer, 
as shown in Figure 5.</p>
<p><font color="#FF0000"><b>Return the modified pixel data</b></font></p>
<p>The statement in Listing 30 returns a reference to the modified 
three-dimensional array of pixel data to the calling method in the program named
<b>ImgMod02</b>, where it will used to create and display a new image at the 
bottom of the frame.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    return temp3D;
  }//end processImg
}//end class ProgramTest

<b>Listing 30</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 30 also signals the end of the <b>processImg</b> method and the end 
of the <b>ProgramTest</b> class.</p>
<p><font color="#FF0000"><b>That's all there is to it</b></font></p>
<p>As you can see, once you have the program named <b>ImgMod02</b> to handle all 
of the hard work, all that's required to create and test a new image-processing 
algorithm is to define a new class that:</p>
<ul>
	<li>Makes a copy of an incoming three-dimensional array of pixel data 
	representing an image.</li>
	<li>Modifies the pixel values in the copy according to some algorithm of your 
	own design.</li>
	<li>Returns a reference to the modified three-dimensional array of pixel 
	data for display.</li>
</ul>
<p><font color="#FF0000"><b>Some cautions</b></font></p>
<p>A couple of cautions are probably in order.&nbsp; One caution is to beware of 
transparency.&nbsp; You should make certain 
that you don't end up with a modified array in which all the alpha values are 
zero.</p>
<blockquote>
	<p><i>(Recall that the elements in a new array of type <b>int</b> are 
	automatically initialized to zero, so this is an easy mistake to make.)</i></p>
</blockquote>
<p>If you do, then your modified image will be completely transparent 
regardless of what you did to the color values for the pixels.&nbsp; As a 
result, the display will simply show the yellow background color for the frame.</p>
<p><font color="#FF0000"><b>Value ranges</b></font></p>
<p>Another caution has to do with the range of alpha and color values associated 
with the pixels.&nbsp; None of the values should be negative, and none of the 
values should exceed +255.&nbsp; If your values don't comply with these limits, the 
display will probably not be what you expect to see.</p>
<p>Prior to display, each of the 
four pixel values of type <b>int</b> will be converted to eight bits by simply discarding all but 
the least significant eight bits in each <b>int</b> element in the 
three-dimensional array.&nbsp; This is not the same as clipping the 
values at 0 and 255, and will probably lead to unexpected results.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a></h2>
<p>I encourage you to copy, compile, and run the program provided in this lesson.&nbsp; 
Experiment with it, making changes and observing the results of your changes.&nbsp; 
Above all, have fun and learn as much as you can about modifying image pixels 
using Java.</p>
<p>You should be able to right-click on the image in Figure 6 and download and 
save it locally under the name <b>junk.gif</b>.&nbsp; Then you should be able to 
replicate the output produced in Figure 5.</p>
<p align="center"><img border="0" src="java400f.gif" width="297" height="278"></p>
<p align="center">Figure 6&nbsp; Raw image for junk.gif</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I showed you how to modify an image by modifying the pixels belonging to that 
image.&nbsp; I also provided a program that makes it easy to modify the pixels 
in an image and to display the modified image.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons will show you how to write image-processing programs that 
implement many common special effects as well as a few that aren't so common.&nbsp; 
This will include programs to do the following:</p>
<ul>
	<li>Highlight a particular area in an image.</li>
	<li>Blur all or part of an image.</li>
	<li>Sharpen all or part of an image.</li>
	<li>Perform edge detection on an image.</li>
	<li>Apply color filtering to an image.</li>
	<li>Apply color inversion to an image.</li>
	<li>Morphing one image into another image.</li>
	<li>Rotating an image.</li>
	<li>Squeezing part of an image into a smaller size.</li>
	<li>Controlling the brightness of an image using linear and non-linear 
	algorithms.</li>
	<li>Other special effects that I may dream up or discover while doing the 
	background research for the lessons in this series.</li>
</ul>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program Listing</a></h2><p>
Complete listings of the program and interface discussed in this lesson are provided below.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ImgMod02.java.java
Copyright 2004, R.G.Baldwin

The purpose of this program is to make it easy
to experiment with the modification of pixel
data in an image and to display the modified
version of the image along with the original
version of the image.

The program extracts the pixel data from an
image file into a 3D array of type:

int[row][column][depth].

The first two dimensions of the array correspond
to the rows and columns of pixels in the image.
The third dimension always has a value of 4 and
contains the following values by index value:

0 alpha
1 red
2 green
3 blue

Note that these values are stored as type int
rather than type unsigned byte which is the
format of pixel data in the original image.
This type conversion eliminates many problems
involving the requirement to perform unsigned
arithmetic on unsigned byte data.

The program supports gif and jpg files and
possibly some other file types as well.

Operation:  This program provides a framework
that is designed to invoke another program to
process the pixels extracted from an image.
In other words, this program extracts the pixels
and puts them in a format that is relatively
easy to work with.  A second program is invoked
to actually process the pixels.  Typical usage
is as follows:

java ImgMod02 ProcessingProgramName ImageFileName

For test purposes, the source code includes a
class definition for an image-processing program
named ProgramTest.

If the ImageFileName is not specified on the
command line, the program will search for an
image file in the current directory named
junk.gif and will process it using the
processing program specified by the second
command-line argument.

If both command-line arguments are omitted, the
program will search for an image file in the
current directory named junk.gif and will
process it using the built-in processing program
named ProgramTest.

The image file must be provided by the user in
all cases.  However, it doesn't have to be in
the current directory if a path to the file is
specified on the command line.

When the program is started, the original image
and the processed image are displayed in a frame
with the original image above the processed
image.  A Replot button appears at the bottom of
the frame.  If the user clicks the Replot
button, the image-processing method is rerun,
the image is reprocessed and the new version of
the processed image replaces the old version.

The processing program may provide a  GUI for
data input making it possible for the user to
modify the behavior of the image-processing
method each time it is run.  This capability is
illustrated in the built-in processing program
named ProgramTest.

The image-processing programming must implement
the interface named ImgIntfc02.  That interface
declares a single method with the following
signature:

int[][][] processImg(int[][][] threeDPix,
                     int imgRows,
                     int imgCols);

The first parameter is a reference to the 3D
array of pixel data stored as type int.  The
last two parameters specify the number of rows
of pixels and the number of columns of pixels in
the image.

The image-processing program cannot have a
parameterized constructor.  This is because an
object of the class is instantiated by invoking
the newInstance method of the class named Class
on the name of the image-processing program
provided as a String on the command line.  This
approach to object instantiation does not
support parameterized constructors.

If the image-processing program has a main
method, it will be ignored.

The processImg method receives a 3D array
containing pixel data.  It should make a copy of
the incoming array and modify the copy rather
than modifying the original.  Then the program
should return a reference to the modified copy
of the 3D pixel array.

The program also receives the width and the
height of the image represented by the pixels in
the 3D array.

The processImg method is free to modify the
values of the pixels in the array in any manner
before returning the modified array.  Note
however that native pixel data consists of four
unsigned bytes.  If the modification of the
pixel data produces negative values or positive
value greater than 255, this should be dealt
with before returning the modified pixel data.
Otherwise, the returned values will simply be
masked to eight bits before display, and the
result of displaying those masked bits may not
be as expected.

There are at least two ways to deal with this
situation.  One way is to simply clip all
negative values at zero and to clip all values
greater than 255 at 255.  The other way is to
perform a further modification so as to map the
range from -x to +y into the range from 0 to 255.
There is no one correct way for all situations.

When the processImg method returns, this program
causes the original image and the modified image
to be displayed in a frame on the screen with
the original image above the modified image.

If the user doesn't specify an image-processing
program, this program will instantiate and use
an object of the class named ProgramTest and an
image file named junk.gif.  The class definition
for the ProgramTest class is included in this
source code file.  The image file named junk.gif
must be provided by the user in the current
directory.  Just about any gif file of an
appropriate size will do.  Make certain that it
is small enough so that two copies will fit on
the screen when stacked one above the other.

The processing program named ProgramTest draws a
diagonal white line across the image starting at
the top left corner.  The program provides a
dialog box that allows the user to specify the
slope of the line.  To change the slope, type a
new slope into the text field and press the
Replot button on the main graphic frame.  It
isn't necessary to press the Enter key after
typing the new slope value into the text field,
but doing so won't cause any harm.  (Note that
only positive slope values can be used.  Entry
of a negative slope value will cause an exception
to be thrown.)

Other than to add the white line, the image
processing program named ProgramTest does not
modify the image.  It does draw a visible white
line across transparent areas, making the pixels
underneath the line non-transparent.  However,
it may be difficult to see the white line
against the default yellow background in the
frame.

If the program is unable to load the image file
within ten seconds, it will abort with an error
message.

Some operational details follow.

This program reads an image file from the disk
and saves it in memory under the name rawImg.
Then it declares a one-dimensional array of type
int of sufficient size to contain one int value
for every pixel in the image. Each int value
will be populated with one alpha byte and three
color bytes.  The name of the array is oneDPix.

Then the program instantiates an object of type
PixelGrabber, which associates the rawImg with
the one-dimensional array of type int.
Following this, the program invokes the
grabPixels method on the object of type
PixelGrabber to cause the pixels in the rawImg
to be extracted into int values and stored in
the array named oneDPix.

Then the program copies the pixel values from
the oneDPix array into the threeDPix array,
converting them to type int in the process.  The
threeDPix array is passed to an image-processing
program.

The image-processing program returns a modified
version of the 3D array of pixel data.

This program then creates a new version of the
oneDPix array containing the modified pixel data.
It uses the createImage method of the Component
class along with the constructor for the
MemoryImageSource class to create a new image
from the modified pixel data.  The name of the
new image is modImg.

Finally, the program overrides the paint method
where it uses the drawImage method to display
both the raw image and the modified image on the
same Frame object.  The raw image is displayed
above the modified image.

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;

class ImgMod02 extends Frame{
  Image rawImg;
  int imgCols;//Number of horizontal pixels
  int imgRows;//Number of rows of pixels
  Image modImg;//Reference to modified image

  //Inset values for the Frame
  int inTop;
  int inLeft;

  //Default image-processing program.  This
  // program will be executed to process the
  // image if the name of another program is not
  // entered on the command line.  Note that the
  // class file for this program is included in
  // this source code file.
  static String theProcessingClass =
                                   "ProgramTest";

  //Default image file name.  This image file
  // will be processed if another file name is
  // not entered on the command line.  You must
  // provide this file in the current directory.
  static String theImgFile = "junk.gif";

  MediaTracker tracker;
  Display display = new Display();//A Canvas
  Button replotButton = new Button("Replot");

  //References to arrays that store pixel data.
  int[][][] threeDPix;
  int[][][] threeDPixMod;
  int[] oneDPix;

  //Reference to the image-processing object.
  ImgIntfc02 imageProcessingObject;
  //-------------------------------------------//

  public static void main(String[] args){

    //Get names for the image-processing program
    // and the image file to be processed.
    // Program supports gif files and jpg files
    // and possibly some other file types as
    // well.
    if(args.length == 0){
      //Use default processing class and default
      // image file.  No code required here.
      // Class and file names were specified
      // above.  This case is provided for
      // information purposes only.
    }else if(args.length == 1){
      theProcessingClass = args[0];
      //Use default image file
    }else if(args.length == 2){
      theProcessingClass = args[0];
      theImgFile = args[1];
    }else{
      System.out.println("Invalid args");
      System.exit(1);
    }//end else

    //Display name of processing program and
    // image file.
    System.out.println("Processing program: "
                           + theProcessingClass);
    System.out.println("Image file: "
                                 + theImgFile);

    //Instantiate an object of this class
    ImgMod02 obj = new ImgMod02();
  }//end main
  //-------------------------------------------//

  public ImgMod02(){//constructor
    //Get an image from the specified file.  Can
    // be in a different directory if the path
    // was entered with the file name on the
    // command line.
    rawImg = Toolkit.getDefaultToolkit().
                            getImage(theImgFile);

    //Use a MediaTracker object to block until
    // the image is loaded or ten seconds has
    // elapsed.
    tracker = new MediaTracker(this);
    tracker.addImage(rawImg,1);

    try{
      if(!tracker.waitForID(1,10000)){
        System.out.println("Load error.");
        System.exit(1);
      }//end if
    }catch(InterruptedException e){
      e.printStackTrace();
      System.exit(1);
    }//end catch

    //Make certain that the file was successfully
    // loaded.
    if((tracker.statusAll(false)
                   & MediaTracker.ERRORED
                   & MediaTracker.ABORTED) != 0){
      System.out.println(
                      "Load errored or aborted");
      System.exit(1);
    }//end if

    //Raw image has been loaded.  Get width and
    // height of the raw image.
    imgCols = rawImg.getWidth(this);
    imgRows = rawImg.getHeight(this);

    this.setTitle("Copyright 2004, Baldwin");
    this.setBackground(Color.YELLOW);
    this.add(display);
    this.add(replotButton,BorderLayout.SOUTH);
    //Make it possible to get insets and the
    // height of the button.
    setVisible(true);
    //Get and store inset data for the Frame and
    // the height of the button.
    inTop = this.getInsets().top;
    inLeft = this.getInsets().left;
    int buttonHeight =
                   replotButton.getSize().height;
    //Size the frame so that a small amount of
    // yellow background will show on the right
    // and on the bottom when both images are
    // displayed, one above the other.  Also, the
    // placement of the images on the Canvas
    // causes a small amount of background to
    // show between the images.
    this.setSize(2*inLeft+imgCols + 1,inTop
                 + buttonHeight + 2*imgRows + 7);

    //=========================================//
    //Anonymous inner class listener for replot
    // button.  This actionPerformed method is
    // invoked when the user clicks the Replot
    // button.  It is also invoked at startup
    // when this program posts an ActionEvent to
    // the system event queue attributing the
    // event to the Replot button.
    replotButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(
                                  ActionEvent e){
          //Pass a 3D array of pixel data to the
          // processing object and get a modified
          // 3D array of pixel data back.  The
          // creation of the 3D array of pixel
          // data is explained later.
          threeDPixMod =
                imageProcessingObject.processImg(
                      threeDPix,imgRows,imgCols);
          //Convert the modified pixel data to a
          // 1D array of pixel data.  The 1D
          // array is explained later.
          oneDPix = convertToOneDim(
                   threeDPixMod,imgCols,imgRows);
          //Use the createImage() method to
          // create a new image from the 1D array
          // of pixel data.
          modImg = createImage(
             new MemoryImageSource(
             imgCols,imgRows,oneDPix,0,imgCols));
          //Repaint the image display frame with
          // the original image at the top and
          // the modified pixel data at the
          // bottom.
          display.repaint();
        }//end actionPerformed
      }//end ActionListener
    );//end addActionListener
    //End anonymous inner class.
    //=========================================//

    //Create a 1D array object to receive the
    // pixel representation of the image
    oneDPix = new int[imgCols * imgRows];

    //Convert the rawImg to numeric pixel
    // representation.  Note that grapPixels()
    // throws InterruptedException
    try{
      //Instantiate a PixelGrabber object
      // specifying oneDPix as the array in which
      // to put the numeric pixel data. See Sun
      // docs for parameters
      PixelGrabber pgObj = new PixelGrabber(
                      rawImg,0,0,imgCols,imgRows,
                              oneDPix,0,imgCols);
      //Invoke the grabPixels() method on the
      // PixelGrabber object to extract the pixel
      // data from the image into an array of
      // numeric pixel data stored in oneDPix.
      // Also test for success in the process.
      if(pgObj.grabPixels() &&
                           ((pgObj.getStatus() &
                           ImageObserver.ALLBITS)
                                          != 0)){

        //Convert the pixel byte data in the 1D
        // array to int data in a 3D array to
        // make it easier to work with the pixel
        // data later.  Recall that pixel data is
        // unsigned byte data and Java does not
        // support unsigned arithmetic.
        // Performing unsigned arithmetic on byte
        // data is particularly cumbersome.
        threeDPix = convertToThreeDim(
                        oneDPix,imgCols,imgRows);

        //Instantiate a new object of the image
        // processing class.  Note that this
        // object is instantiated using the
        // newInstance method of the class named
        // Class.  This approach does not support
        // the use of a parameterized
        // constructor.
        try{
          imageProcessingObject = (
               ImgIntfc02)Class.forName(
               theProcessingClass).newInstance();

           //Post counterfeit ActionEvent to the
           // system event queue and attribute it
           // to the Replot button.  (See the
           // anonymous ActionListener class
           // defined above that registers an
           // ActionListener object on the RePlot
           // button.)  Posting this event causes
           // the image-processing method to be
           // invoked, passing the 3D array of
           // pixel data to the method, and
           // receiving a 3D array of modified
           // pixel data back from the method.
          Toolkit.getDefaultToolkit().
                getSystemEventQueue().postEvent(
                  new ActionEvent(
                    replotButton,
                    ActionEvent.ACTION_PERFORMED,
                    "Replot"));

          //At this point, the image has been
          // processed and both the original
          // image and the <span lang="en-us"></span>modified image
          // have been displayed.  From this
          // point forward, each time the user
          // clicks the Replot button, the image
          // will be processed again and the new
          // modified image will be displayed
          // along with the original image.

        }catch(Exception e){
          System.out.println(e);
        }//end catch

      }//end if statement on grabPixels
      else System.out.println(
                    "Pixel grab not successful");
    }catch(InterruptedException e){
      e.printStackTrace();
    }//end catch

    //Cause the composite of the frame, the
    // canvas, and the button to become visible.
    this.setVisible(true);
    //=========================================//

    //Anonymous inner class listener to terminate
    // program.
    this.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);//terminate the program
        }//end windowClosing()
      }//end WindowAdapter
    );//end addWindowListener
    //=========================================//

  }//end constructor
  //===========================================//

  //Inner class for canvas object on which to
  // display the two images.
  class Display extends Canvas{
    //Override the paint method to display both
    // the rawImg and the modImg on the same
    // Canvas object, separated by one row of
    // pixels in the background color.
    public void paint(Graphics g){
      //First confirm that the image has been
      // completely loaded and neither image
      // reference is null.
      if (tracker.statusID(1, false) ==
                          MediaTracker.COMPLETE){
        if((rawImg != null) &&
                               (modImg != null)){
          g.drawImage(rawImg,0,0,this);
          g.drawImage(modImg,0,imgRows + 1,this);
        }//end if
      }//end if
    }//end paint()
  }//end class myCanvas
//=============================================//

  //Save pixel values as type int to make
  // arithmetic easier later.

  //The purpose of this method is to convert the
  // data in the int oneDPix array into a 3D
  // array of ints.
  //The dimensions of the 3D array are row,
  // col, and color in that order.
  //Row and col correspond to the rows and
  // columns of the image.  Color corresponds to
  // transparency and color information at the
  // following index levels in the third
  // dimension:
  // 0 alpha
  // 1 red
  // 2 green
  // 3 blue
  // The structure of this code is determined by
  // the way that the pixel data is formatted
  // into the 1D array of ints produced by the
  // grabPixels method of the PixelGrabber
  // object.
  int[][][] convertToThreeDim(
          int[] oneDPix,int imgCols,int imgRows){
    //Create the new 3D array to be populated
    // with color data.
    int[][][] data =
                    new int[imgRows][imgCols][4];

    for(int row = 0;row < imgRows;row++){
      //Extract a row of pixel data into a
      // temporary array of ints
      int[] aRow = new int[imgCols];
      for(int col = 0; col < imgCols;col++){
        int element = row * imgCols + col;
        aRow[col] = oneDPix[element];
      }//end for loop on col

      //Move the data into the 3D array.  Note
      // the use of bitwise AND and bitwise right
      // shift operations to mask all but the
      // correct set of eight bits.
      for(int col = 0;col < imgCols;col++){
        //Alpha data
        data[row][col][0] = (aRow[col] >> 24)
                                          & 0xFF;
        //Red data
        data[row][col][1] = (aRow[col] >> 16)
                                          & 0xFF;
        //Green data
        data[row][col][2] = (aRow[col] >> 8)
                                          & 0xFF;
        //Blue data
        data[row][col][3] = (aRow[col])
                                          & 0xFF;
      }//end for loop on col
    }//end for loop on row
    return data;
  }//end convertToThreeDim
  //-------------------------------------------//

  //The purpose of this method is to convert the
  // data in the 3D array of ints back into the
  // 1d array of type int.  This is the reverse
  // of the method named convertToThreeDim.
  int[] convertToOneDim(
         int[][][] data,int imgCols,int imgRows){
    //Create the 1D array of type int to be
    // populated with pixel data, one int value
    // per pixel, with four color and alpha bytes
    // per int value.
    int[] oneDPix = new int[
                          imgCols * imgRows * 4];

    //Move the data into the 1D array.  Note the
    // use of the bitwise OR operator and the
    // bitwise left-shift operators to put the
    // four 8-bit bytes into each int.
    for(int row = 0,cnt = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        oneDPix[cnt] = ((data[row][col][0] << 24)
                                   & 0xFF000000)
                     | ((data[row][col][1] << 16)
                                   & 0x00FF0000)
                      | ((data[row][col][2] << 8)
                                   & 0x0000FF00)
                           | ((data[row][col][3])
                                   & 0x000000FF);
        cnt++;
      }//end for loop on col

    }//end for loop on row

    return oneDPix;
  }//end convertToOneDim
}//end ImgMod02.java class
//=============================================//

//The ProgramTest class

//The purpose of this class is to provide a
// simple example of an image-processing class
// that is compatible with the program named
// ImgMod02.

//The constructor for the class displays a small
// frame on the screen with a single textfield.
// The purpose of the text field is to allow the
// user to enter a value that represents the
// slope of a line.  In operation, the user
// types a value into the text field and then
// clicks the Replot button on the main image
// display frame.  The user is not required to
// press the Enter key after typing the new
// value, but it doesn't do any harm to do so.

//The method named processImage receives a 3D
// array containing alpha, red, green, and blue
// values for an image.  The values are received
// as type int (not type byte).

// The threeDPix array that is received is
// modified to cause a white diagonal line to be
// drawn down and to the right from the upper
// left-most corner of the image.  The slope of
// the line is controlled by the value that is
// typed into the text field.  Initially, this
// value is 1.0.  The image is not modified in
// any other way.

//To cause a new line to be drawn, type a slope
// value into the text field and click the Replot
// button at the bottom of the image display
// frame.

//This class extends Frame.  However, a
// compatible class is not required to extend the
// Frame class. This example extends Frame
// because it provides a GUI for user data input.

//A compatible class is required to implement the
// interface named ImgIntfc02.

class ProgramTest extends Frame
                           implements ImgIntfc02{

  double slope;//Controls the slope of the line
  String inputData;//Obtained via the TextField
  TextField inputField;//Reference to TextField

  //Constructor must take no parameters
  ProgramTest(){
    //Create and display the user-input GUI.
    setLayout(new FlowLayout());

    Label instructions = new Label(
               "Type a slope value and Replot.");
    add(instructions);

    inputField = new TextField("1.0",5);
    add(inputField);

    setTitle("Copyright 2004, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor

  //The following method must be defined to
  // implement the ImgIntfc02 interface.
  public int[][][] processImg(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    //Display some interesting information
    System.out.println("Program test");
    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

    //Make a working copy of the 3D array to
    // avoid making permanent changes to the
    // image data.
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

    //Get slope value from the TextField
    slope = Double.parseDouble(
                           inputField.getText());

    //Draw a white diagonal line on the image
    for(int col = 0;col < imgCols;col++){
      int row = (int)(slope*col);
      if(row > imgRows -1)break;
      //Set values for alpha, red, green, and
      // blue colors.
      temp3D[row][col][0] = (byte)0xff;
      temp3D[row][col][1] = (byte)0xff;
      temp3D[row][col][2] = (byte)0xff;
      temp3D[row][col][3] = (byte)0xff;
    }//end for loop
    //Return the modified array of image data.
    return temp3D;
  }//end processImg
}//end class ProgramTest

<b>Listing 31</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>&nbsp;</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ImgIntfc02.java.java
Copyright 2004, R.G.Baldwin

The purpose of this interface is to declare
the one method required by image-processing
classes that are compatible with the program
named ImgMod02.java.

Tested using SDK 1.4.2 under WinXP
===============================================*/

interface ImgIntfc02{
  int[][][] processImg(int[][][] threeDPix,
                       int imgRows,
                       int imgCols);
}//end ImgIntfc02

<b>Listing 32</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
     
<hr size="3" width="100%" align="center">    
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p>
     
<h4> <a name="About_the_author">About the author</a></h4><b>
<a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects, and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.dickbaldwin.com">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p>
     
<p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p>
     
<p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p>
     
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
  </p>
     
<p>-end- </p>
   </body>
</html>
