<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Combining Rotation and Translation in Java 3d</h2>
<i>Understanding rotation and translation individually in Java 3D is not too 
difficult.&nbsp; When you combine the two, things quickly become very 
complicated.&nbsp; If you don't understand what you are doing when you combine 
the two, the chance that you will get it right is probably less than fifty 
percent.&nbsp; In this lesson, you will learn to get it right the first time.</i>
<p><b>Published:</b>&nbsp; November 20, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1548</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a><ul>
	<li><a href="#The_program_named_Java3D008">The program named Java3D008</a></li>
	<li><a href="#The_program_named_Java3D009">The program named Java3D009</a></li>
</ul>
	</li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_program_named_Java3D009a">The program named Java3D008</a></li>
	<li><a href="#The_program_named_Java3D009b">The program named Java3D009</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Download">Download</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#FF0000"><b>Fifth</b></font><font color="#ff0000"><b> in a series of lessons</b></font></p>
<p>This is the fifth lesson in a series of lessons designed to start with Java 
3D basics and work up to some very complicated programs, such as the program that I explained 
in the earlier lesson titled &quot;Understanding Lighting in the Java 3D API&quot; <i>(see
<a href="#Resources">Resources</a>).</i></p>
<p>The first lesson in this series was titled &quot;Back to Basics in the Java 3D 
API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; The 
previous lesson was titled &quot;Understanding the Alpha Time-Base Class in Java 
3D.&quot;&nbsp; This lesson 
is titled &quot;Combining Rotation and Translation in Java 3d.&quot;&nbsp; My current plan 
is for future lessons to deal with user and object interaction as well as 
advanced animation and textures.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p>Understanding rotation in Java 3D is not too difficult.&nbsp; Similarly, it is not 
too difficult to understand translation in Java 3D.&nbsp; However, when you combine 
rotation with translation, things become very complicated very quickly.&nbsp; If 
you don't really understand what you are doing when you combine the two, the 
chance that you will get it right the first time is probably less than fifty 
percent.&nbsp; In this lesson, I will teach you how to get it 
right the first time by helping you to understand the impact of the order of 
rotation and translation on the behavior of the program.</p>
<p><b><font color="#ff0000">Compiling and running Java 3D programs</font></b></p>
<p>In order to compile and run programs using the Java 3D API, you will need to 
download and install the Java 3D API software.&nbsp; As of the date of this writing, 
version 1.5.0 is available for <a href="#Download">download</a>.</p>
<p>In addition, you will need to <a href="#Download">download</a> 
and install either <b>Microsoft DirectX</b> or <b>OpenGL</b>.&nbsp; All of the sample 
programs in this series of tutorials were developed and tested using Microsoft 
DirectX.&nbsp; They were not tested using OpenGL.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. A view of the universe along with the 
	user input GUI.</li>
	<li><a href="#Figure_2">Figure 2</a>. Another screen shot of the program 
	named Java3D008.</li>
	<li><a href="#Figure_3">Figure 3</a>. White sphere rotating about its own 
	tilted vertical axis.</li>
	<li><a href="#Figure_4">Figure 4</a>. White sphere orbiting yellow sphere in 
	a tilted plane.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Constructor for the top-level class.</li>
	<li><a href="#Listing_2">Listing 2</a>. Beginning of the class named 
	TheScene.</li>
	<li><a href="#Listing_3">Listing 3</a>. Beginning of the constructor for the 
	class named TheScene.</li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of code used to animate 
	the universe.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of code to animate the 
	white sphere.</li>
	<li><a href="#Listing_6">Listing 6</a>. The method named rotate.</li>
	<li><a href="#Listing_7">Listing 7</a>. The method named translate.</li>
	<li><a href="#Listing_8">Listing 8</a>. Code that is executed when the user 
	clicks the &quot;b&quot; button.</li>
	<li><a href="#Listing_9">Listing 9</a>. Code that is executed when the user 
	clicks the &quot;c&quot; button.</li>
	<li><a href="#Listing_10">Listing 10</a>. Complete the constructor for the 
	class named TheScene.</li>
	<li><a href="#Listing_11">Listing 11</a>. Code that is executed when the 
	user clicks the &quot;a&quot; button.</li>
	<li><a href="#Listing_12">Listing 12</a>. The method named tiltTheAxes.</li>
	<li><a href="#Listing_13">Listing 13</a>. Code that is executed when the 
	user clicks the &quot;b&quot; button.</li>
	<li><a href="#Listing_14">Listing 14</a>. Code that is executed when the 
	user clicks the &quot;c&quot; button.</li>
	<li><a href="#Listing_15">Listing 15</a>. Program listing for the program 
	named Java3D008.</li>
	<li><a href="#Listing_16">Listing 16</a>. Program listing for the program 
	named Java3D009.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>Rotation and translation are two of several different types of transforms 
that you can apply to objects in Java 3D, including:</p>
<ul>
	<li>scaling</li>
	<li>translation</li>
	<li>shear</li>
	<li>rotation</li>
</ul>
<p>I explained some of these transforms as they apply in the 2D world in the 
earlier lesson titled &quot;Java 2D Graphics, Simple Affine Transforms&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; I will deal with translation and 
rotation in Java 3D in this lesson, and will deal with scaling and shear in future lessons.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<h3><a name="The_program_named_Java3D008">The program named Java3D008</a></h3>
<p>In this lesson, I will present and explain two programs.&nbsp; The first 
program is named <b>Java3D008</b>.&nbsp; The purpose of this program is to 
illustrate the behavior imparted by the order of rotation and translation when 
used together.</p>
<p><font color="#FF0000"><b>The universe</b></font></p>
<p>The universe contains a yellow sphere, a green sphere, and a white sphere as 
shown by the left image in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. A view of the universe along with the user 
	input GUI. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1548a01.jpg" width="469" height="234"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Figure 1 also shows the user input GUI on the right.</p>
<p><font color="#FF0000"><b>Behavior of the yellow sphere</b></font></p>
<p>The yellow sphere slowly rotates around the vertical axis in 3D space for a 
specified period of time.&nbsp; The center of the yellow sphere is at the origin in 3D 
space.&nbsp; Therefore, the yellow sphere appears to rotate around its own vertical 
axis.</p>
<p><font color="#FF0000"><b>Behavior of the green sphere</b></font></p>
<p>The green sphere is translated to a location slightly above, to the right 
of, and behind the yellow sphere.&nbsp; The green sphere maintains its position throughout the time that the program is running in order to provide a 
fixed object in 3D space to help you stay properly oriented.</p>
<p><font color="#FF0000"><b>Behavior of the white sphere</b></font></p>
<p>The behavior of the 
white sphere depends on user input via the input GUI shown in Figure 1.&nbsp; As you can see, the input GUI contains three 
buttons labeled &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;.&nbsp; Depending on 
which button the user clicks, the white sphere is animated in one of three ways:</p>
<ol>
	<li>If the user clicks the &quot;a&quot; button, the white 
sphere is translated to a location just outside the yellow sphere on the positive 
z-axis (0.0f,0.0f,0.7f) where it maintains its location in space and rotates 
about its own vertical axis.&nbsp; <i>(This is the behavior depicted in Figure 
1.)&nbsp; </i>This behavior is the result of rotation followed 
by translation.</li>
	<li>If the user clicks the &quot;b&quot; button, the white sphere is translated 
to the same location in space as for the &quot;a&quot; button but then the white 
sphere orbits the yellow 
sphere with the same face of the white sphere always being oriented toward the yellow sphere.&nbsp;
	<i>(See Figure 2.)</i>&nbsp; The white sphere orbits in a horizontal plane 
	that cuts through the equator of the yellow sphere.&nbsp; This is the result of translation followed by rotation.</li>
	<li>If the user 
clicks the &quot;c&quot; button, the white sphere orbits the yellow sphere as in 
	Figure 2.&nbsp; However, for this case, the white sphere also rotates on its own 
vertical axis while orbiting the yellow sphere.&nbsp; This is the result of rotation 
followed by translation followed by another rotation.</li>
</ol>
<p>
 <b><a name="Figure_2">Figure 2</a>. Another screen shot of the program named 
	Java3D008. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1548a02.jpg" width="236" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A slow computer</b><br />
  On my relatively slow 
laptop, the first animation cycle is perhaps 25-percent complete before the 
first image appears on the screen.&nbsp; I was unable to discover any way to prevent this 
from happening.&nbsp; In addition, there are sporadic undesirable pauses in the 
	animation.</td></tr></table>
</td>
</tr>
</table>
<p>If you perform the rotations and translations in the wrong order, the results 
are not likely to be what you expected or wanted.</p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>Both of the programs that I will present and explain in this lesson were tested using Java SE 6, and Java 3D 1.5.0 running under Windows XP.</p>
<h3><a name="The_program_named_Java3D009">The program named Java3D009</a></h3>
<p>The second program that I will present and explain is named <b>Java3D009</b>.&nbsp; 
This program is an update to the program named <b>Java3D008</b>.&nbsp; The 
purpose of this update is to illustrate one approach to using translation and 
rotation in combination to modify the rotational axis of objects in 3D space.</p>
<p><font color="#FF0000"><b>Three cases are presented</b></font></p>
<p>In one case, a white sphere spins around its own vertical axis that is tilted 
counter-clockwise as shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. White sphere rotating about its own tilted 
	vertical axis. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1548a03.jpg" width="236" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you compare the detailed facet structure on the surface of the white sphere in Figure 3 
with the sphere in Figure 1, you can see that the white sphere's vertical axis 
is tilted counter-clockwise.</p>
<p><font color="#FF0000"><b>The two other cases</b></font></p>
<p>In the other two cases, the white sphere orbits around the yellow sphere on a plane that is 
tilted relative to the X-Y, Y-Z, and Z-X planes.&nbsp; This is shown in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. White sphere orbiting yellow sphere in a 
	tilted plane. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1548a04.jpg" width="236" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The planes on which the white spheres orbit are different in the two cases.&nbsp; 
For the case shown in Figure 4, the plane is tilted such that from its current 
position, the white sphere will move diagonally up to the right across the 
yellow sphere and will then block the view of the green sphere momentarily. Then 
it will disappear by dropping down behind the yellow sphere.</p>
<p><font color="#FF0000"><b>The universe</b></font></p>
<p>As shown in Figures 3 and 4, the universe once again contains a yellow 
sphere, a green sphere, and a white sphere.&nbsp; As before, the yellow sphere 
slowly rotates around the vertical axis in 3D space for a specified period of 
time.</p>
<p>Also as before, the green sphere is translated to the location shown in 
Figures 3 and 4 where it remains stationary throughout the time that the program is running.</p>
<p><font color="#FF0000"><b>The behavior of the white sphere</b></font></p>
<p>The behavior of the 
white sphere depends on user input via the input GUI that provides three buttons 
as shown in Figure 1.&nbsp; Depending on which button is clicked by the user, 
the white sphere is 
animated in one of three ways:</p>
<ol>
	<li>If the user clicks the &quot;a&quot; button, the white 
sphere is translated to a location just outside the yellow sphere on the positive 
z-axis (0.0f,0.0f,0.7f) where it maintains its location in space and rotates 
about its own vertical axis.&nbsp; However, its vertical axis is tilted relative to the 
direction of the vertical axis of 3D space.&nbsp; This is the result of rotation 
followed by axis transformation followed by translation.&nbsp; This behavior is 
	shown in Figure 3.</li>
	<li>If the user clicks the 
&quot;b&quot; button, the white sphere is translated to the same location in space as for 
the &quot;a&quot; button, but then it orbits the yellow sphere with the same face of the white 
sphere always oriented toward the yellow sphere.&nbsp; However, unlike in the previous 
	program where the sphere orbits in a horizontal plane at the equator of the 
	yellow sphere, the orbit in this program is on a plane that is 
tilted relative to the X-Y, Y-Z, and Z-X planes.&nbsp; This is the result of 
translation followed by rotation followed by axis transformation.&nbsp; This 
	behavior is shown in Figure 4.</li>
	<li>If the user 
clicks the &quot;c&quot; button, the white sphere orbits the yellow sphere as in 2 above.&nbsp; However, for this case, the white sphere 
	orbits on a different tilted plane and also rotates on its own vertical 
axis while orbiting the yellow sphere.&nbsp; As before, the orbit is on a plane that is 
tilted relative to the X-Y, Y-Z, and Z-X planes.&nbsp; This is the result of 
rotation followed by translation followed by another rotation followed by axis 
transformation.</li>
</ol>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_program_named_Java3D009a">The program named Java3D008</a></h3>
<p>A complete listing of this program is presented in Listing 15.&nbsp; As is my 
custom, I will present and explain this program in fragments.</p>
<p>Much of the code in this lesson is very similar or identical to code that I 
explained in the earlier lessons on Java 3D <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; I won't repeat those explanations here, but rather 
will assume that you have already studied the earlier lessons and that you 
understand that code.&nbsp; Once again, you can view that code in Listing 15.</p>
<p><font color="#FF0000">
<b>Constructor for the top-level class</b></font></p>
<p>The program begins in Listing 1, which includes the <b>main</b> method and 
the constructor for the user input GUI shown in Figure 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Constructor for the top-level class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Java3D008 extends Frame{
  TheScene theScene;
  
  public static void main(String[] args){
    Java3D008 thisObj = new Java3D008();
  }//end main
  //----------------------------------------------------//
  
  public Java3D008(){//top-level constructor
    setLayout(new GridLayout(1,3));
    Button aButton = new Button("a");
    Button bButton = new Button("b");
    Button cButton = new Button("c");
    
    add(aButton);
    add(bButton);
    add(cButton);
    
    aButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("a");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    bButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("b");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    cButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("c");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener

    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(236,0,235,75);
    setVisible(true);

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Depending on which button is clicked by the user, the action listeners 
registered on the buttons instantiate a new object of the class named <b>
TheScene</b>, passing a string to the constructor for that class.&nbsp; As you 
will see later, the value of the string that is passed to the constructor 
determines the animation behavior of the objects in the universe.&nbsp; 
Otherwise, the code in Listing 1 is straightforward and shouldn't require 
further explanation.</p>
<p><font color="#FF0000">
<b>Beginning of the class named TheScene</b></font></p>
<p>Listing 2 shows the beginning of the class named <b>TheScene</b>.&nbsp; This 
is an inner class from which the universe is instantiated and animated.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Beginning of the class named TheScene. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class TheScene extends Frame{
    
    //Declare instance variables that are used later by
    // the program.
    Canvas3D canvas3D;
    Sphere yellowSph;
    Sphere whiteSph;
    Sphere greenSph;
    PointLight pointLight;
    SimpleUniverse simpleUniverse;
    
    BranchGroup mainBranchGroup = new BranchGroup();
    
    TransformGroup greenTransformGroup = 
                                     new TransformGroup();
    TransformGroup yellowRotXformGroup = 
                                     new TransformGroup();
    
    String buttonLabel;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 2 simply declares instance variables that will be used 
later in the program, initializing some of them in the process.</p>
<p><font color="#FF0000">
<b>Beginning of the constructor for the class named TheScene</b></font></p>
<p>The beginning of the constructor is shown in Listing 3.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of the constructor for the class 
named TheScene. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    TheScene(String input){//constructor
      //Save the incoming parameter to be used later to
      // decide which behavior to execute.
      buttonLabel = input;
      
      //Construct the universe.
      createACanvas();
      createTheUniverse();
            
      //Construct the objects that will occupy the
      // universe.
      createYellowSphere();
      createWhiteSphere();
      createGreenSphere();
      createPointLight();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In addition to saving the incoming parameter to use later in deciding which 
of three animation behaviors to execute, the code in Listing 3 calls a series of 
methods to construct the universe and to construct the objects that occupy the 
universe.&nbsp; The code in each of those methods is similar or identical to 
code that I have explained in earlier lessons on Java 3D <i>(see
<a href="#Resources">Resources</a>)</i>, so I won't repeat those explanations 
here.&nbsp; You can view the code in those methods in Listing 15.</p>
<p><font color="#FF0000"><b>Animate the universe</b></font></p>
<p>Listing 4 shows the beginning of the code that is executed to animate the 
universe.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of code used to animate the 
universe. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      animateYellowSphere();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 4 calls a method named <b>animateYellowSphere</b>, which controls the 
animation of the yellow sphere shown in Figures 1 and 2.&nbsp; The animation of 
the yellow sphere is independent of user input.</p>
<p>As you will see if you examine Listing 15, the <b>animateYellowSphere</b> 
method simply calls another method named <b>rotate</b> to cause the yellow 
sphere to spin around the vertical axis in 3D space.&nbsp; The <b>rotate</b> 
method is used extensively in this program and will be explained in detail 
later.</p>
<p><font color="#FF0000">
<b>Beginning of code to animate the white sphere</b></font></p>
<p>The animation of the white sphere depends on the button selected by the user in the input GUI.&nbsp; 
Listing 5 shows the beginning of an if-else statement that executes one of three 
possible behaviors depending on the button selection.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of code to animate the white 
sphere. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      if(buttonLabel.equals("a")){
        //Begin rotation of white sphere.
        TransformGroup whiteRotXformGroup = 
                       <b>rotate</b>(whiteSph,new Alpha(4,2500));

        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = <b>translate</b>(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));
        
        mainBranchGroup.addChild(whiteTransXformGroup);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 5 will rotate the white sphere around the vertical axis 
in 3D space and then translate the rotating sphere away from the origin in 3D 
space.&nbsp; This causes the white sphere to remain stationary while spinning 
around its own axis.</p>
<p><font color="#FF0000"><b>The rotate and translate methods</b></font></p>
<p>In an attempt to make the order of rotation and translation easier to see in 
the source code, I defined two new methods in this program named <b>rotate</b> 
and <b>translate</b>.&nbsp; As you can see, the code in Listing 5 calls the <b>
rotate</b> method first followed by a call to the <b>translate</b> method.&nbsp; 
The value returned by the <b>rotate</b> method is passed as a parameter to the
<b>translate</b> method.&nbsp; Thus, the behavior of the white sphere in this 
case is caused by rotation followed by translation.</p>
<p><font color="#FF0000"><b>The method named rotate</b></font></p>
<p>At this point, I will put the explanation of the constructor for the class 
named <b>TheScene</b> on the back burner for awhile and explain the methods 
named <b>rotate</b> and <b>translate</b>.&nbsp; The method named <b>rotate</b> 
is shown in its entirety in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The method named rotate.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    TransformGroup rotate(Node node,Alpha alpha){

      TransformGroup xformGroup = new TransformGroup();
      xformGroup.setCapability(
                    TransformGroup.ALLOW_TRANSFORM_WRITE);
      
      //Create an interpolator for rotating the node.
      RotationInterpolator interpolator = 
               new RotationInterpolator(alpha,xformGroup);
                             
      //Establish the animation region for this
      // interpolator.
      interpolator.setSchedulingBounds(new BoundingSphere(
                           new Point3d(0.0,0.0,0.0),1.0));
      
      //Populate the xform group.
      xformGroup.<b>addChild</b>(interpolator);
      xformGroup.<b>addChild</b>(node);

      return xformGroup;
      
    }//end rotate</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Not much that is new here</b></font></p>
<p>Except for packaging this code in a separate method and using an object of 
the class <b>Node</b>, there is nothing in Listing 6 that is new to this lesson.&nbsp; 
I explained all of the code in Listing 6 in the earlier lesson titled &quot;Simple 
Animation with the Java 3D API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Behavior of the method named rotate</b></font></p>
<p>Given an incoming <b>Node</b> object and an <b>Alpha</b> object, this method 
will construct and return a <b>TransformGroup</b> object that is designed to 
rotate the node around the vertical axis in 3D space according to the number of 
cycles and cycle time specified by the <b>Alpha</b> object.</p>
<p><font color="#FF0000"><b>
<a name="A_few_words_about_the_use_of_the_Node_class">A few words about the use 
of the Node class</a></b></font></p>
<p>In some cases, Java 3D code is written to rotate visual objects such as 
objects of the classes <b>Sphere</b>, <b>Box</b>, <b>ColorCube</b>, and <b>Cone</b>.&nbsp; 
In other cases, the code is written to rotate visual objects contained in 
objects of the class <b>TransformGroup</b> which have been populated with visual 
objects, or perhaps with other transform groups that have been populated with 
visual objects.</p>
<p>As it turns out, classes for visual objects such as the classes <b>Sphere</b>,
<b>Box</b>, <b>ColorCube</b>, and <b>Cone</b>, as well as the <b>TransformGroup</b> 
class are all subclasses of the class <b>Node</b>.&nbsp; Therefore, objects of 
these classes can be treated as type <b>Node</b>.</p>
<p>The <b>addChild</b> method that is called in Listing 6 is defined in the <b>
Group</b> class and inherited into the <b>TransformGroup</b> class.&nbsp; The 
method requires an incoming parameter of type <b>Node</b>.&nbsp; Therefore, the 
incoming parameter to the <b>rotate</b> method is eligible for being passed to 
the <b>addChild</b> method regardless of whether that object is actually type <b>
Sphere</b> or type <b>TransformGroup</b>.&nbsp; As a result, this method can be 
used to rotate a visual object or a transform group equally well.</p>
<p><font color="#FF0000">
<b>The method named translate</b></font></p>
<p>The method named <b>translate</b> is shown in its entirety in Listing 7.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. The method named translate. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    TransformGroup translate(Node node,Vector3f vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setTranslation(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end translate</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Given an incoming node object and a vector object, the method named <b>
translate</b> will construct and return a transform group designed to translate 
that node according to that vector.&nbsp; Once again, the code in Listing 7 is 
very similar to code that I explained in the earlier lesson titled &quot;Simple 
Animation with the Java 3D API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
Therefore I won't repeat that explanation here.&nbsp; <i>(<a href="#A_few_words_about_the_use_of_the_Node_class">Earlier 
comments</a> related to the <b>Node</b> class and the <b>addChild</b> method 
apply here also.)</i></p>
<p><font color="#FF0000">
<b>Code that is executed when the user clicks the &quot;b&quot; button</b></font></p>
<p>Returning now to the constructor, Listing 8 shows the code that is executed when the user clicks the button 
labeled &quot;b&quot; in Figure 1.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Code that is executed when the user clicks the &quot;b&quot; button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(buttonLabel.equals("b")){
        //Translate the white sphere.
        TransformGroup whiteTransXformGroup = <b>translate</b>(
                            whiteSph,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of translated white sphere around
        // the vertical axis at the origin in 3D space.
        TransformGroup whiteRotXformGroup = 
           <b>rotate</b>(whiteTransXformGroup,new Alpha(2,5000));
         
        mainBranchGroup.addChild(whiteRotXformGroup);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This code will translate the white sphere and rotate the translated white 
sphere around the vertical axis in 3D space, causing the white sphere to orbit 
the yellow sphere with the same face of the white sphere oriented toward the 
yellow sphere at all times.&nbsp; This behavior was caused by translation 
followed by rotation.</p>
<p><font color="#FF0000"><b>The order of rotation and translation was reversed</b></font></p>
<p>If you compare the code in Listing 8 with the code in Listing 5, you will see 
that the order of rotation and translation was reversed in the two cases.&nbsp; 
In Listing 5, the <b>rotate</b> method was called passing the white sphere 
object as a parameter.&nbsp; Then the <b>TransformGroup</b> object returned by 
the <b>rotate</b> method was passed to the <b>translate</b> method.</p>
<p>In Listing 8, the white sphere was first passed as a parameter to the <b>
translate</b> method.&nbsp; The <b>TransformGroup</b> object returned by the <b>
translate</b> method was then passed as a parameter to the <b>rotate</b> method.</p>
<p><font color="#FF0000"><b>Radically different behavior</b></font></p>
<p>If you run this program selecting the button labeled &quot;a&quot; and then run it 
again selecting the button labeled &quot;b&quot;, you will see that the behavior is 
radically different between the two cases, illustrating the importance of the 
order of rotation and translation.</p>
<p>In the first case, the white sphere was caused to rotate around the vertical 
axis in 3D space, which coincided with the vertical axis of the sphere.&nbsp; 
Then the origin of the coordinate system belonging to the sphere was translated 
to a different location in 3D space, which had the effect of moving the rotating 
sphere to a different location.</p>
<p>In the second case, the origin of the coordinate system belonging to the 
white sphere was translated to a different location in 3D space.&nbsp; Then the 
white sphere was once again caused to rotate around the vertical axis in 3D 
space <i>(not around its own vertical axis)</i> causing the white sphere to 
orbit the yellow sphere whose origin was located at the origin in 3D space.</p>
<p><font color="#FF0000">
<b>Code that is executed when the user clicks the &quot;c&quot; button</b></font></p>
<p>Listing 9 shows the code that is executed when the user clicks the button 
labeled &quot;c&quot; in Figure 1.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Code that is executed when the user clicks the &quot;c&quot; button.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(buttonLabel.equals("c")){
        //Begin rotation of the white sphere
        TransformGroup whiteRotXformGroup = 
                       <b>rotate</b>(whiteSph,new Alpha(8,1250));
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = <b>translate</b>(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));

<i>        //Begin rotation of the translated rotating white
        // sphere.
        TransformGroup whiteRotGroupXformGroup = 
           <b>rotate</b>(whiteTransXformGroup,new Alpha(2,5000));</i>

        mainBranchGroup.addChild(whiteRotGroupXformGroup);
      }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the code</b></font></p>
<p>The code in Listing 9 will rotate the white sphere, translate the rotating 
white sphere away from the origin in 3d space, and then rotate the translated 
rotating white sphere around the origin in 3D space causing the white sphere to 
orbit the yellow sphere and to spin about its own vertical axis at the same 
time.&nbsp; This behavior is rotation followed by translation followed by 
another rotation.</p>
<p>The first two statements in Listing 9 are the same as the two statements in 
Listing 5, which left the white sphere rotating in a stationary position in 3D 
space.&nbsp; However, Listing 9 adds another call to the <b>rotation</b> method
<i>(shown in Italics in Listing 9)</i> causing the white sphere, <i>(which is 
already rotating around its own vertical axis)</i> to also rotate around the 
vertical axis in 3D space.&nbsp; This causes the rotating white sphere to appear 
to orbit the yellow sphere, which is located at the origin in 3D space.</p>
<p><font color="#FF0000">
<b>Complete the constructor for the class named TheScene</b></font></p>
<p>Listing 10 contains the remaining code in the constructor for the class named
<b>TheScene</b>.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Complete the constructor for the class 
named TheScene. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Finish populating the mainBranchGroup.
      mainBranchGroup.addChild(greenTransformGroup);
      mainBranchGroup.addChild(pointLight);
      mainBranchGroup.addChild(yellowRotXformGroup);
      
      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(mainBranchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
    
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 10 is very similar to code that I have explained in 
earlier lessons in this series, so I won't repeat those explanations again here.</p>
<p><font color="#FF0000"><b>The remaining code for the program named Java3D008</b></font></p>
<p>The remaining code in this program consists of the definitions of the 
following methods:</p>
<ul>
	<li>createACanvas</li>
	<li>createYellowSphere</li>
	<li>createWhiteSphere</li>
	<li>createGreenSphere</li>
	<li>createPointLight</li>
	<li>createTheUniverse</li>
	<li>animateYellowSphere</li>
</ul>
<p>The code in all of these methods is very similar to code that I have 
explained in earlier lessons.&nbsp; You can view these methods in Listing 15.&nbsp; 
That brings us to the program named <b>Java3D009</b>.</p>
<h3><a name="The_program_named_Java3D009b">The program named Java3D009</a></h3>
<p>A complete listing of this program is presented in Listing 16.&nbsp; I will also 
present and explain this program in fragments.</p>
<p>Much of the code in this lesson is very similar or identical to code that I 
explained in the earlier lessons on Java 3D <i>(see <a href="#Resources">
Resources</a>)</i> or in the explanation of the program named Java3D008 above.&nbsp; 
I won't repeat those explanations here.</p>
<p><font color="#FF0000"><b>Early code in this program</b></font></p>
<p>The early code in this program is essentially the same as the code in 
Listings 1 through 5 above, so I won't repeat it here.&nbsp; You can view that 
code in Listing 16.</p>
<p><font color="#FF0000">
<b>Code that is executed when the user clicks the &quot;a&quot; button</b></font></p>
<p>As before, the animation of the white sphere depends on the button selected by the user in the input 
GUI <i>(see the GUI in Figure 1)</i>.</p>
<p>The two programs differ in terms of the code in the decision structure in the 
constructor, which uses the identification of the button that was clicked by the 
user to establish the behavior of the white sphere.</p>
<p><font color="#FF0000"><b>When the user clicks the button labeled &quot;a&quot;</b></font></p>
<p>Listing 11 shows the code that is executed when the user clicks the button 
labeled &quot;a&quot;.&nbsp; <i>(Compare this with the code in Listing 5.)</i></p>

<p>
<b><a name="Listing_11">Listing 11</a>. Code that is executed when the user 
clicks the &quot;a&quot; button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      if(buttonLabel.equals("a")){
        //Begin rotation of white sphere.
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(4,2500));
<b>
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotXformGroup,
                      0.0d,//x-axis
                      0.0d,//y-axis
                      Math.PI/8.0d);//z-axis</b>
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            <b>tiltedGroup</b>,
                            new Vector3f(0.0f,0.0f,0.7f));

        mainBranchGroup.addChild(whiteTransXformGroup);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 11 will rotate the white sphere around the vertical axis 
and translate the rotating sphere away from the origin in 3D space causing it to 
remain stationary while spinning in 3D space.&nbsp; Unlike the previous program, 
the vertical axis belonging to the white sphere is tilted relative to the 
vertical axis in 3D space and the sphere rotates about that tilted axis.</p>
<p><font color="#FF0000"><b>How does this code differ from before?</b></font></p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Don't get confused here</b><br />
  The code in the method named <b>rotate</b> causes an object to rotate about 
	the vertical axis belonging to the coordinate system for the universe in a 
	continuous animation.&nbsp; The method named <b>tiltTheAxes</b> 
	causes the axes belonging to an object to be changed one time only relative 
	to their current state.&nbsp;
</td></tr></table>
</td>
</tr>
</table>
<p>The code in Listing 11 differs from the earlier code in Listing 5 by the 
addition of the statement highlighted in boldface in Figure 11.&nbsp; This code 
calls the new method named <b>tiltTheAxes</b> to perform a one-time rotational 
transform on the <b>whiteRotXformGroup</b> <i>(the object returned by the 
original call to the <b>rotate</b> method)</i>.&nbsp; This call rotates the 
group around its z-axis only.&nbsp; <i>(Note that the first two parameters 
passed to the method named <b>tiltTheAxes</b> have values of zero.)</i>&nbsp; As 
you will see, this causes the vertical axis of the white sphere 
to tilt counter-clockwise by 22.5 degrees <i>(Math.PI/8.0d)</i>.&nbsp; The white 
sphere will then spin around that tilted axis after it is translated.</p>
<p><font color="#FF0000"><b>The method named tiltTheAxes</b></font></p>
<p>Once again, I will put the discussion of the constructor code on the 
back burner long enough to explain the behavior of the method named <b>
tiltTheAxes</b>.&nbsp; The code for this method is shown in Listing 12.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. The method named tiltTheAxes.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    TransformGroup tiltTheAxes(Node node,
                               double xAngle,
                               double yAngle,
                               double zAngle){

      Transform3D tiltAxisXform = new Transform3D();
      Transform3D tempTiltAxisXform = new Transform3D();
      
      //Construct and then multiply two rotation transform
      // matrices..
      tiltAxisXform.rotX(xAngle);
      tempTiltAxisXform.rotY(yAngle);
      tiltAxisXform.mul(tempTiltAxisXform);
      
      //Construct the third rotation transform matrix and
      // multiply it by the result of previously 
      // multiplying the two earlier matrices.
      tempTiltAxisXform.rotZ(zAngle);
      tiltAxisXform.mul(tempTiltAxisXform);
      
      TransformGroup tiltedGroup = new TransformGroup(
                                           tiltAxisXform);
      tiltedGroup.addChild(node);
      
      return tiltedGroup;
    }//end tiltTheAxes</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>


<p>The purpose of this method is to create and return a <b>TransformGroup</b> 
object that is designed to perform a counter- clockwise rotation about the x, y, 
and z axes belonging to an incoming node.&nbsp; The three incoming angle values 
must be specified in radians.&nbsp; <i>(Note that the first two angle parameters 
passed to this method in Listing 11 have a value of zero, causing the rotational 
behavior of the method in this case to apply only to the z-axis.)</i></p>
<p><font color="#FF0000"><b>Not so easy to understand</b></font></p>
<p>Unfortunately, a complete understanding of the code in Listing 12 requires an 
understanding of the class named <b>Transform3D</b>.&nbsp;&nbsp; This, in turn, 
requires some knowledge of matrix arithmetic along with an understanding of 
trigonometry and vectors in 3D space.&nbsp; This is a fairly complex topic.&nbsp; I 
plan to publish a future lesson that is dedicated to an understanding of the 
class named <b>Transform3D</b>, so I won't attempt to explain the technical 
details here.</p>
<p><font color="#FF0000"><b>Suffice it to say...</b></font></p>
<p>Suffice it to say at this point that the <b>Transform3D</b> class contains 
the following three methods.</p>
<ul>
	<li><a name="rotX">rotX</a></li>
	<li>rotY</li>
	<li>rotZ</li>
</ul>
<p>Each of these methods constructs and returns a <b>Transform3D</b> object that 
encapsulates a matrix that is designed to accomplish axis rotation around the x, 
y, and z axes respectively.</p>
<p>The matrices returned by the three methods can be multiplied together to 
create a resultant matrix that implements the specified rotation around all 
three axes.</p>
<p>The resultant matrix can be used to rotate the axes of a node by adding the 
node and the resultant matrix as children of a <b>TransformGroup</b> object.&nbsp; </p>
<p>Thus, this method receives a node along with three angles as incoming 
parameters.&nbsp; It uses the three angles along with the methods in the above
<a href="#rotX">list</a> to construct the resultant matrix encapsulated in a <b>
Transform3D</b> object.&nbsp; Then it adds that <b>Transform3D</b> object along 
with the incoming node as children to a new <b>TransformGroup</b> object, and 
returns a reference to the new <b>TransformGroup</b> object.</p>
<p><font color="#FF0000"><b>Now back to the constructor</b></font></p>
<p>Getting back to the constructor code in Listing 11, the <b>TransformGroup</b> 
object returned from the <b>tiltTheAxes</b> method <i>(referred to by the 
variable named <b>tiltedGroup</b>)</i> is then passed as a parameter to the <b>
translate</b> method.&nbsp; Thus, unlike the previous program <i>(see Listing 5)</i>, 
the group that is translated to the new location contains a white sphere that is 
spinning around a vertical axis that has been tilted counter-clockwise by 22.5 
degrees.&nbsp; This produces the image shown in Figure 3 where the facets on the 
white sphere show that its vertical axis has been tilted counter-clockwise <i>
(as compared to the facets on the white sphere shown in Figure 1)</i>.</p>
<p><font color="#FF0000">
<b>Code that is executed when the user clicks the &quot;b&quot; button</b></font></p>
<p>Listing 13 shows the code that is executed when the user clicks the button 
labeled &quot;b&quot;.&nbsp; <i>(Compare this code with the code in Listing 8.)</i></p>
<p>
<b><a name="Listing_13">Listing 13</a>. Code that is executed when the user 
clicks the &quot;b&quot; button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(buttonLabel.equals("b")){
        //Translate the white sphere.
        TransformGroup whiteTransXformGroup = translate(
                            whiteSph,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of translated white sphere around
        // the vertical axis at the origin in 3D space.
        TransformGroup whiteRotXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));
<b>
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotXformGroup,
                      0.0d,//x-axis
                      0.0d,//y-axis
                      Math.PI/4.0d);//z-axis</b>
        
        mainBranchGroup.addChild(<b>tiltedGroup</b>);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This code will translate the white sphere and rotate the translated white 
sphere around the origin in 3D space, causing the white sphere to orbit the 
yellow sphere with the same face of the white sphere oriented toward the yellow 
sphere at all times.&nbsp; Up to this point, the behavior is the same as in the 
previous program shown in Listing 8.</p>
<p><font color="#FF0000"><b>Tilt the axis</b></font></p>
<p>However, the code highlighted in boldface is then added to the code in 
Listing 13 <i>(as compared to Listing 8)</i>.&nbsp; The call to the method named
<b>tiltTheAxes</b> in the boldface code will perform a one-time rotational 
transform on the <b>whiteRotXformGroup</b>, rotating it around its z-axis only.&nbsp;
<i>(The angles that specify rotation around the x and y axes are both zero.)</i>&nbsp; 
This will cause the white sphere to orbit the yellow sphere on a plane that is 
tilted by 45 degrees <i>(Math.PI/4.0d)</i> relative to the x-z, plane as shown 
in Figure 4.</p>
<p><font color="#FF0000">
<b>Code that is executed when the user clicks the &quot;c&quot; button</b></font></p>
<p>Finally, Listing 14 shows the code that is executed when the user clicks the 
button labeled &quot;c&quot;.&nbsp; <i>(Compare this with the code in Listing 9.)</i></p>
<p>
<b><a name="Listing_14">Listing 14</a>. Code that is executed when the user 
clicks the &quot;c&quot; button.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(buttonLabel.equals("c")){
        //The following code will rotate the white sphere,
        // translate the rotating white sphere away from
        // the origin in 3d space, and rotate the
        // translated rotating white sphere around the
        // origin in 3D space causing the white sphere to
        // orbit the yellow sphere and to spin about its
        // own vertical axis at the same time. The white
        // sphere will orbit in a tilted plane.
        
        //Begin rotation of the white sphere
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(8,1250));
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of the translated rotating white
        // sphere.
        TransformGroup whiteRotGroupXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));
           
<b>        //Now perform a one-time rotational transform on
        // the whiteRotGroupXformGroup, rotating it around
        // its x, y, and z axes.  This will cause the
        // white sphere to orbit the yellow sphere on a 
        // plane that is tilted relative to the x-y, y-z,
        // and z-x planes.
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotGroupXformGroup,
                      Math.PI/8.0d,
                      Math.PI/2.0d,
                      Math.PI/4.0d);</b>
        
        mainBranchGroup.addChild(<b>tiltedGroup</b>);

      }//end else-if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>When you compare this code with the code in Listing 9, you will see that as 
was the case in Listing 13, this code contains a call to the method named <b>
tiltTheAxes</b> after the code to rotate, translate, and rotate the white sphere 
has been executed.</p>
<p><font color="#FF0000"><b>A simple screen shot won't illustrate this behavior</b></font></p>
<p>Note that none of the angle values passed to the <b>tiltTheAxes</b> method 
have a value of zero.&nbsp; As a result, the white sphere for this case orbits 
in a plane that is tilted relative to all three planes belonging to the 
universe.&nbsp; In other words, the white sphere orbits in a plane that cuts 
through the yellow sphere at a non-zero angle relative to all three axes.&nbsp;
<i>(A simple screen shot won't illustrate the difference.&nbsp; You will need to 
run the program and observe the behavior of the white sphere to appreciate the 
difference.)</i></p>
<p><font color="#FF0000"><b>The remaining code</b></font></p>
<p>The remaining code for this program is very similar to code that I have 
already explained.&nbsp; Therefore, I won't repeat that explanation.&nbsp; You 
can view that code in Listing 16.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to compile and execute the code from Listing 15 and Listing 
16.&nbsp; Experiment with the code, making changes, and observing 
the results of your changes.</p>
<p>Remember, you will need to download and install the Java 3D API plus either 
Microsoft DirectX or OpenGL to compile and execute these programs.&nbsp; See
<a href="#Download">Download</a> for links to the web sites from which this 
material can be downloaded. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>Understanding rotation in Java 3D is not too difficult.&nbsp; Similarly, it is not 
too difficult to understand translation in Java 3D.&nbsp; However, when you combine 
rotation with translation, things become very complicated very quickly.&nbsp; If you 
don't really understand what you are doing when you combine the two, the chance 
that you will get it right the first time is probably less than fifty percent.&nbsp; In this lesson, I taught you how to get it right the first 
time by helping you to understand the impact of the order of rotation and 
translation on the behavior of the code.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The topics for future lessons include interactive Java 3D programs, advanced 
animation, and surfaces.</p>
<h2 align="center"><a name="Download">Download</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/developer/onlineTraining/java3d/javaa3d.zip">
	Getting Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by 
	Dennis J Bouvier</li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/collateral/examples.zip">
	Source code</a> for example programs from the Bouvier tutorial above</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Version 1.5.0</a> of the Java 3D API</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Implementation documentation</a> for version 1.5.0 of the Java 3D API</li>
	<li>
	<a href="http://www.gamesforwindows.com/en-US/AboutGFW/Pages/DirectX10.aspx">
	Microsoft DirectX10</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/java-media/3D/">Main page</a> for 
	the Java 3D API</li>
	<li>Java 3D <a href="http://wiki.java.net/bin/view/Javadesktop/Java3DFAQ">
	FAQ</a></li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/reference/api/index.html">
	Online documentation</a> for Java 3D version 1.3 <i>(see
	Download above for v1.5.0 
	documentation)</i></li>
	<li><a href="http://java.sun.com/developer/onlineTraining/java3d/">Getting 
	Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by Dennis J 
	Bouvier</li>
	<li>
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/javax/media/j3d/doc-files/intro.html">
	Introduction to the Java 3D API</a> with links to other tutorial information</li>
	<li>Various Java 3D <a href="http://www.java3d.org/">resources</a></li>
	<li>Another Java 3D <a href="http://www.java3d.org/tutorial.html">tutorial</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/626051">306</a> 
	Java 2D Graphics, Simple Affine Transforms&nbsp;</li>
	<li>
	<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
	1468</a> Plotting Engineering and Scientific Data using Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3622246">1540</a> 
	Understanding Lighting in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3701536">1541</a> Back to Basics in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3704116">1542</a> Digging a Little Deeper into the Java 3D API</li>
	<li><a href="http://www.developer.com/java/data/article.php/3706721">1544</a> Simple Animation with the Java 3D API</li>
	<li><a href="http://www.developer.com/java/other/article.php/3709341">1546</a> Understanding the Alpha Time-Base Class in Java 3D</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs presented and explained in this lesson are shown in 
Listing 15 and Listing 16 below.<p>
<b><a name="Listing_15">Listing 15</a>. Program listing for the program named Java3D008. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Java3D008.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to illustrate the 
behavior imparted by the order of rotation and
translation when used together.

The universe contains a yellow sphere, a green sphere, and
a white sphere.

The yellow sphere slowly rotates around the vertical axis
in 3D space for a specified period of time. The center of
the yellow sphere is at the origin in 3D space. Therefore,
the yellow sphere appears to rotate around its own 
vertical axis.

The green sphere is translated to a location slightly 
above, to the right of, and behind the yellow sphere.  The
green sphere maintains its translated location throughout 
the time that the program is running.

The behavior of the white sphere depend on input via a
user input GUI.  The input GUI contains three buttons
labeled "a", "b", and "c"

Depending on the user input the white sphere is animated 
in one of three ways:

1. If the user clicks the "a" button, the white sphere is 
translated to a location just outside the yellow sphere on
the positive z-axis (0.0f,0.0f,0.7f) where it maintains 
its location in space and rotates about its own vertical 
axis.  This is the result of rotation followed by 
translation.

2. If the user clicks the "b" button, the white sphere is 
translated to the same location in space as for the "a"
button and then orbits the yellow sphere with the same 
face of the white sphere always toward the yellow sphere.
This is the result of translation followed by rotation.

3. If the user clicks the "c" button, the white sphere 
orbits the yellow sphere as in 2 above.  However, for this
case, the white sphere also rotates on its own vertical 
axis while orbiting the yellow sphere.  This is the result
of rotation followed by translation followed by another 
rotation.

Note:  On my relatively slow laptop, the first animation 
cycle is perhaps 25-percent complete before the first 
image appears on the screen.  I was unable to discover any
way to prevent this from happening. In addition, there are
sporadic undesirable pauses in the animation.

Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.geometry.Sphere;
import com.sun.j3d.utils.geometry.Primitive;
import javax.media.j3d.Appearance;
import javax.media.j3d.Material;
import javax.media.j3d.PointLight;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.Alpha;
import javax.media.j3d.RotationInterpolator;
import javax.media.j3d.Node;
import javax.vecmath.Vector3f;
import javax.vecmath.Point3f;
import javax.vecmath.Point3d;
import javax.vecmath.Color3f;
import java.awt.Frame;
import java.awt.Button;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

//This is the top-level driver class for this program.
public class Java3D008 extends Frame{
  TheScene theScene;
  
  public static void main(String[] args){
    Java3D008 thisObj = new Java3D008();
  }//end main
  //----------------------------------------------------//
  
  public Java3D008(){//top-level constructor
    setLayout(new GridLayout(1,3));
    Button aButton = new Button("a");
    Button bButton = new Button("b");
    Button cButton = new Button("c");
    
    add(aButton);
    add(bButton);
    add(cButton);
    
    aButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("a");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    bButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("b");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    cButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("c");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener

    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(236,0,235,75);
    setVisible(true);

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class, from which the universe will
  // be  instantiated and animated.
  class TheScene extends Frame{
    
    //Declare instance variables that are used later by
    // the program.
    Canvas3D canvas3D;
    Sphere yellowSph;
    Sphere whiteSph;
    Sphere greenSph;
    PointLight pointLight;
    SimpleUniverse simpleUniverse;
    
    BranchGroup mainBranchGroup = new BranchGroup();
    
    TransformGroup greenTransformGroup = 
                                     new TransformGroup();
    TransformGroup yellowRotXformGroup = 
                                     new TransformGroup();
    
    String buttonLabel;
    //--------------------------------------------------//
        
    TheScene(String input){//constructor
      //Save the incoming parameter to be used later to
      // decide which behavior to execute.
      buttonLabel = input;
      
      //Construct the universe.
      createACanvas();
      createTheUniverse();
            
      //Construct the objects that will occupy the
      // universe.
      createYellowSphere();
      createWhiteSphere();
      createGreenSphere();
      createPointLight();

      //Animate the objects.
      
      //Animation of the yellow sphere is independent of
      // user input.
      animateYellowSphere();
      
      //Animation of the white sphere depends on the
      // button selected by the user in the input GUI.
      if(buttonLabel.equals("a")){
        //This code will rotate the white sphere around
        // the vertical axis and translate the rotating
        // sphere away from the origin in 3D space causing
        // it to remain stationary while spinning in 3D
        // space.  This behavior is rotation followed by
        // translation.
        
        //Begin rotation of white sphere.
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(4,2500));

        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));
        
        mainBranchGroup.addChild(whiteTransXformGroup);
        
      }else if(buttonLabel.equals("b")){
        //This code will translate the white sphere and
        // rotate the translated white sphere around the
        // vertical axis in 3D space, causing the white
        // sphere to orbit the yellow sphere with the same
        // face of the white sphere toward the yellow
        // sphere at all times.  This behavior is
        // translation followed by rotation.

        //Translate the white sphere.
        TransformGroup whiteTransXformGroup = translate(
                            whiteSph,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of translated white sphere around
        // the vertical axis at the origin in 3D space.
        TransformGroup whiteRotXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));
         
        mainBranchGroup.addChild(whiteRotXformGroup);
        
      }else if(buttonLabel.equals("c")){
        //The following code will rotate the white sphere,
        // translate the rotating white sphere away from
        // the origin in 3d space, and rotate the
        // translated rotating white sphere around the
        // origin in 3D space causing the white sphere to
        // orbit the yellow sphere and to spin about its
        // own vertical axis at the same time.  This
        // behavior is rotation followed by translation
        // followed by another rotation.
        
        //Begin rotation of the white sphere
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(8,1250));
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of the translated rotating white
        // sphere.
        TransformGroup whiteRotGroupXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));

        mainBranchGroup.addChild(whiteRotGroupXformGroup);
      }//end if

      //Finish populating the mainBranchGroup.
      mainBranchGroup.addChild(greenTransformGroup);
      mainBranchGroup.addChild(pointLight);
      mainBranchGroup.addChild(yellowRotXformGroup);
      
      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(mainBranchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
    
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//
    
    //Create a Canvas3D object to be used for rendering
    // the Java 3D universe.  Place it in the CENTER of
    // the Frame.
    void createACanvas(){
      canvas3D = new Canvas3D(
              SimpleUniverse.getPreferredConfiguration());
      add(BorderLayout.CENTER,canvas3D);
    }//end createACanvas
    //--------------------------------------------------//
    
    //Create and set properties for the large yellow
    // sphere.
    void createYellowSphere(){
      //Begin by describing the appearance of the surface
      // of the large sphere.  Make the color of the large
      // sphere yellow.
      Material yellowSphMaterial = new Material();
      yellowSphMaterial.setDiffuseColor(1.0f,1.0f,0.0f);
      Appearance yellowSphAppearance = new Appearance();
      yellowSphAppearance.setMaterial(yellowSphMaterial);

      //Now instantiate the large yellow sphere with 9
      // divisions.  Set the radius to 0.5. The reason for
      // setting GENERATE_NORMALS is unclear at this time.
      yellowSph = new Sphere(0.5f,
                             Primitive.GENERATE_NORMALS,
                             9,
                             yellowSphAppearance);
    }//end createYellowSphere
    //--------------------------------------------------//
    
    //Create a white sphere with 8 divisions.  Make the
    // number of divisions small so that the fact that it
    // is spinning will be visually obvious.    
    void createWhiteSphere(){
      Material whiteSphMaterial = new Material();
      whiteSphMaterial.setDiffuseColor(1.0f,1.0f,1.0f);
      Appearance whiteSphAppearance = new Appearance();
      whiteSphAppearance.setMaterial(whiteSphMaterial);
      whiteSph = new Sphere(0.2f,
                            Primitive.GENERATE_NORMALS,
                            8,
                            whiteSphAppearance);
    }//end createWhiteSphere
    //--------------------------------------------------//
    
    //Create a small green sphere located up to the
    // right and behind the yellow sphere.    
    void createGreenSphere(){
      Material greenSphMaterial = new Material();
      greenSphMaterial.setDiffuseColor(0.0f,1.0f,0.0f);
      Appearance greenSphAppearance = new Appearance();
      greenSphAppearance.setMaterial(greenSphMaterial);
      greenSph = new Sphere(0.10f,
                            Primitive.GENERATE_NORMALS,
                            50,
                            greenSphAppearance);
                            
      //Translate the green sphere.
      greenTransformGroup = translate(
                           greenSph,
                           new Vector3f(0.5f,0.5f,-0.5f));
    }//end createGreenSphere
    //--------------------------------------------------//
    //Create a white point light, located over the
    // viewer's right shoulder.    
    void createPointLight(){
      Color3f pointLightColor = 
                              new Color3f(1.0f,1.0f,1.0f);
      Point3f pointLightPosition = 
                              new Point3f(1.0f,1.0f,2.0f);
      Point3f pointLightAttenuation = 
                              new Point3f(1.0f,0.0f,0.0f);
      
      pointLight = new PointLight(pointLightColor,
                                  pointLightPosition,
                                  pointLightAttenuation);
                                  
      //Create a BoundingSphere object and use it to the
      // define the illumination region. Illuminate all of
      // the objects within a radius of one unit from
      // the origin in 3D space.
      pointLight.setInfluencingBounds(new BoundingSphere(
                           new Point3d(0.0,0.0,0.0),1.0));
    }//end createPointLight
    //--------------------------------------------------//
    
    //Create an empty Java 3D universe and associate it 
    // with the Canvas3D object in the CENTER of the
    // frame.  Also specify the apparent location of the
    // viewer's eye.
    void createTheUniverse(){
      simpleUniverse = new SimpleUniverse(canvas3D);
      simpleUniverse.getViewingPlatform().
                             setNominalViewingTransform();
    }//end createTheUniverse
    //--------------------------------------------------//
    
    //This method causes the yellow sphere to rotate
    // around the vertical axis in 3D space.
    void animateYellowSphere(){
      yellowRotXformGroup = 
                      rotate(yellowSph,new Alpha(2,5000));
    }//end animateYellowSphere
    //--------------------------------------------------//
    
    //Given an incoming node object and an Alpha object,
    // this method will return a TransformGroup object
    // that is designed to rotate the node around the
    // vertical axis in 3D space according to the number
    // of cycles and cycle time specified by the Alpha
    // object.
    TransformGroup rotate(Node node,Alpha alpha){

      TransformGroup xformGroup = new TransformGroup();
      xformGroup.setCapability(
                    TransformGroup.ALLOW_TRANSFORM_WRITE);
      
      //Create an interpolator for rotating the node.
      RotationInterpolator interpolator = 
               new RotationInterpolator(alpha,xformGroup);
                             
      //Establish the animation region for this
      // interpolator.
      interpolator.setSchedulingBounds(new BoundingSphere(
                           new Point3d(0.0,0.0,0.0),1.0));
      
      //Populate the xform group.
      xformGroup.addChild(interpolator);
      xformGroup.addChild(node);

      return xformGroup;
      
    }//end rotate
    //--------------------------------------------------//
    
    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to translate that node according to that vector.
    TransformGroup translate(Node node,Vector3f vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setTranslation(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end translate
    //--------------------------------------------------//
    
  }//end inner class TheScene

}//end class Java3D008</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Program listing for the program named Java3D009.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Java3D009.java
Copyright 2007, R.G.Baldwin

This program is an update to the program named Java3D008.

The purpose of this update is to illustrate one approach
to using translation and rotation in combination to cause
different behaviors.  In one case, a white sphere will
spin around an axis that is tilted counter-clockwise. In
two cases, a white sphere orbits around a yellow sphere on
a plane that is tilted relative to the X-Y, Y-Z, and Z-X 
planes.

The universe contains a yellow sphere, a green sphere, and
a white sphere.

The yellow sphere slowly rotates around the vertical axis
in 3D space for a specified period of time. The center of
the yellow sphere is at the origin in 3D space. Therefore,
the yellow sphere appears to rotate around its own 
vertical axis.

The green sphere is translated to a location slightly 
above, to the right of, and behind the yellow sphere.  The
green sphere maintains its translated location throughout 
the time that the program is running.

The behavior of the white sphere depends on input via a
user input GUI.  The input GUI contains three buttons
labeled "a", "b", and "c"

Depending on the user input the white sphere is animated 
in one of three ways:

1. If the user clicks the "a" button, the white sphere is 
translated to a location just outside the yellow sphere on
the positive z-axis (0.0f,0.0f,0.7f) where it maintains 
its location in space and rotates about its own vertical 
axis.  However, its vertical axis is tilted relative to
the direction of the vertical axis of 3D space. This is 
the result of rotation followed by axis transformation
followed by translation.

2. If the user clicks the "b" button, the white sphere is 
translated to the same location in space as for the "a"
button and then orbits the yellow sphere with the same 
face of the white sphere always toward the yellow sphere.
However, the orbit is on a plane that is tilted relative 
to  the X-Y, Y-Z, and Z-X planes. This is the result 
of translation followed by rotation followed by axis
transformation.

3. If the user clicks the "c" button, the white sphere 
orbits the yellow sphere as in 2 above.  However, for this
case, the white sphere also rotates on its own vertical 
axis while orbiting the yellow sphere.  As before, the 
orbit is on a plane that is tilted relative to  the 
X-Y, Y-Z, and Z-X planes. This is the result of rotation 
followed by translation followed by another rotation 
followed by axis transformation.

Note:  On my relatively slow laptop, the first animation 
cycle is perhaps 25-percent complete before the first 
image appears on the screen.  I was unable to discover any
way to prevent this from happening. In addition, there are
sporadic undesirable pauses in the animation.

Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.geometry.Sphere;
import com.sun.j3d.utils.geometry.Primitive;
import javax.media.j3d.Appearance;
import javax.media.j3d.Material;
import javax.media.j3d.PointLight;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.Alpha;
import javax.media.j3d.RotationInterpolator;
import javax.media.j3d.Node;
import javax.vecmath.Vector3f;
import javax.vecmath.Point3f;
import javax.vecmath.Point3d;
import javax.vecmath.Color3f;
import java.awt.Frame;
import java.awt.Button;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

//This is the top-level driver class for this program.
public class Java3D009 extends Frame{
  TheScene theScene;
  
  public static void main(String[] args){
    Java3D009 thisObj = new Java3D009();
  }//end main
  //----------------------------------------------------//
  
  public Java3D009(){//top-level constructor
    setLayout(new GridLayout(1,3));
    Button aButton = new Button("a");
    Button bButton = new Button("b");
    Button cButton = new Button("c");
    
    add(aButton);
    add(bButton);
    add(cButton);
    
    aButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("a");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    bButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("b");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    cButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          theScene = new TheScene("c");
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener

    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(236,0,235,75);
    setVisible(true);

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class, from which the universe will
  // be  instantiated and animated.
  class TheScene extends Frame{
    
    //Declare instance variables that are used later by
    // the program.
    Canvas3D canvas3D;
    Sphere yellowSph;
    Sphere whiteSph;
    Sphere greenSph;
    PointLight pointLight;
    SimpleUniverse simpleUniverse;
    
    BranchGroup mainBranchGroup = new BranchGroup();
    
    TransformGroup greenTransformGroup = 
                                     new TransformGroup();
    TransformGroup yellowRotXformGroup = 
                                     new TransformGroup();
    
    String buttonLabel;
    //--------------------------------------------------//
        
    TheScene(String input){//constructor
      //Save the incoming parameter to be used later to
      // decide which behavior to execute.
      buttonLabel = input;
      
      //Construct the universe.
      createACanvas();
      createTheUniverse();
            
      //Construct the objects that will occupy the
      // universe.
      createYellowSphere();
      createWhiteSphere();
      createGreenSphere();
      createPointLight();

      //Animate the objects.
      
      //Animation of the yellow sphere is independent of
      // user input.
      animateYellowSphere();
      
      //Animation of the white sphere depends on the
      // button selected by the user in the input GUI.
      if(buttonLabel.equals("a")){
        //This code will rotate the white sphere around
        // the vertical axis and translate the rotating
        // sphere away from the origin in 3D space causing
        // it to remain stationary while spinning in 3D
        // space. The vertical axis belonging to the white
        // sphere is tilted relative to the vertical axis
        // in 3D space and the sphere rotates about that
        // tilted axis.
        
        //Begin rotation of white sphere.
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(4,2500));

        //Now perform a one-time rotational transform on
        // the whiteRotXformGroup, rotating it around
        // its z axis only.  This will cause the vertical
        // axis of the white sphere to tilt counter-
        // clockwise by 22.5 degrees.  It will then spin
        // around that tilted axis after it is translated.
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotXformGroup,
                      0.0d,//x-axis
                      0.0d,//y-axis
                      Math.PI/8.0d);//z-axis
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            tiltedGroup,
                            new Vector3f(0.0f,0.0f,0.7f));

        mainBranchGroup.addChild(whiteTransXformGroup);
        
      }else if(buttonLabel.equals("b")){
        //This code will translate the white sphere and
        // rotate the translated white sphere around the
        // vertical axis in 3D space, causing the white
        // sphere to orbit the yellow sphere with the same
        // face of the white sphere toward the yellow
        // sphere at all times.  The white sphere will 
        // orbit in a tilted plane.

        //Translate the white sphere.
        TransformGroup whiteTransXformGroup = translate(
                            whiteSph,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of translated white sphere around
        // the vertical axis at the origin in 3D space.
        TransformGroup whiteRotXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));
           
        //Now perform a one-time rotational transform on
        // the whiteRotXformGroup, rotating it around
        // its z axis only.  This will cause the
        // white sphere to orbit the yellow sphere on a 
        // plane that is tilted relative to the x-z,
        // plane.
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotXformGroup,
                      0.0d,//x-axis
                      0.0d,//y-axis
                      Math.PI/4.0d);//z-axis
        
        mainBranchGroup.addChild(tiltedGroup);
        
      }else if(buttonLabel.equals("c")){
        //The following code will rotate the white sphere,
        // translate the rotating white sphere away from
        // the origin in 3d space, and rotate the
        // translated rotating white sphere around the
        // origin in 3D space causing the white sphere to
        // orbit the yellow sphere and to spin about its
        // own vertical axis at the same time. The white
        // sphere will orbit in a tilted plane.
        
        //Begin rotation of the white sphere
        TransformGroup whiteRotXformGroup = 
                       rotate(whiteSph,new Alpha(8,1250));
        
        //Translate the rotating white sphere
        TransformGroup whiteTransXformGroup = translate(
                            whiteRotXformGroup,
                            new Vector3f(0.0f,0.0f,0.7f));

        //Begin rotation of the translated rotating white
        // sphere.
        TransformGroup whiteRotGroupXformGroup = 
           rotate(whiteTransXformGroup,new Alpha(2,5000));
           
        //Now perform a one-time rotational transform on
        // the whiteRotGroupXformGroup, rotating it around
        // its x, y, and z axes.  This will cause the
        // white sphere to orbit the yellow sphere on a 
        // plane that is tilted relative to the x-y, y-z,
        // and z-x planes.
        TransformGroup tiltedGroup = 
                      tiltTheAxes(whiteRotGroupXformGroup,
                      Math.PI/8.0d,
                      Math.PI/2.0d,
                      Math.PI/4.0d);
        
        mainBranchGroup.addChild(tiltedGroup);

      }//end else-if

      //Finish populating the mainBranchGroup.
      mainBranchGroup.addChild(greenTransformGroup);
      mainBranchGroup.addChild(pointLight);
      mainBranchGroup.addChild(yellowRotXformGroup);
      
      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(mainBranchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
    
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//
    
    //Create a Canvas3D object to be used for rendering
    // the Java 3D universe.  Place it in the CENTER of
    // the Frame.
    void createACanvas(){
      canvas3D = new Canvas3D(
              SimpleUniverse.getPreferredConfiguration());
      add(BorderLayout.CENTER,canvas3D);
    }//end createACanvas
    //--------------------------------------------------//
    
    //Create and set properties for the large yellow
    // sphere.
    void createYellowSphere(){
      //Begin by describing the appearance of the surface
      // of the large sphere.  Make the color of the large
      // sphere yellow.
      Material yellowSphMaterial = new Material();
      yellowSphMaterial.setDiffuseColor(1.0f,1.0f,0.0f);
      Appearance yellowSphAppearance = new Appearance();
      yellowSphAppearance.setMaterial(yellowSphMaterial);

      //Now instantiate the large yellow sphere with 9
      // divisions.  Set the radius to 0.5. The reason for
      // setting GENERATE_NORMALS is unclear at this time.
      yellowSph = new Sphere(0.5f,
                             Primitive.GENERATE_NORMALS,
                             9,
                             yellowSphAppearance);
    }//end createYellowSphere
    //--------------------------------------------------//
    
    //Create a white sphere with 8 divisions.  Make the
    // number of divisions small so that the fact that it
    // is spinning will be visually obvious.    
    void createWhiteSphere(){
      Material whiteSphMaterial = new Material();
      whiteSphMaterial.setDiffuseColor(1.0f,1.0f,1.0f);
      Appearance whiteSphAppearance = new Appearance();
      whiteSphAppearance.setMaterial(whiteSphMaterial);
      whiteSph = new Sphere(0.2f,
                            Primitive.GENERATE_NORMALS,
                            8,
                            whiteSphAppearance);
    }//end createWhiteSphere
    //--------------------------------------------------//
    
    //Create a small green sphere located up to the
    // right and behind the yellow sphere.    
    void createGreenSphere(){
      Material greenSphMaterial = new Material();
      greenSphMaterial.setDiffuseColor(0.0f,1.0f,0.0f);
      Appearance greenSphAppearance = new Appearance();
      greenSphAppearance.setMaterial(greenSphMaterial);
      greenSph = new Sphere(0.10f,
                            Primitive.GENERATE_NORMALS,
                            50,
                            greenSphAppearance);
                            
      //Translate the green sphere.
      greenTransformGroup = translate(
                           greenSph,
                           new Vector3f(0.5f,0.5f,-0.5f));
    }//end createGreenSphere
    //--------------------------------------------------//
    //Create a white point light, located over the
    // viewer's right shoulder.    
    void createPointLight(){
      Color3f pointLightColor = 
                              new Color3f(1.0f,1.0f,1.0f);
      Point3f pointLightPosition = 
                              new Point3f(1.0f,1.0f,2.0f);
      Point3f pointLightAttenuation = 
                              new Point3f(1.0f,0.0f,0.0f);
      
      pointLight = new PointLight(pointLightColor,
                                  pointLightPosition,
                                  pointLightAttenuation);
                                  
      //Create a BoundingSphere object and use it to the
      // define the illumination region. Illuminate all of
      // the objects within a radius of one unit from
      // the origin in 3D space.
      pointLight.setInfluencingBounds(new BoundingSphere(
                           new Point3d(0.0,0.0,0.0),1.0));
    }//end createPointLight
    //--------------------------------------------------//
    
    //Create an empty Java 3D universe and associate it 
    // with the Canvas3D object in the CENTER of the
    // frame.  Also specify the apparent location of the
    // viewer's eye.
    void createTheUniverse(){
      simpleUniverse = new SimpleUniverse(canvas3D);
      simpleUniverse.getViewingPlatform().
                             setNominalViewingTransform();
    }//end createTheUniverse
    //--------------------------------------------------//
    
    //This method causes the yellow sphere to rotate
    // around the vertical axis in 3D space.
    void animateYellowSphere(){
      yellowRotXformGroup = 
                      rotate(yellowSph,new Alpha(2,5000));
    }//end animateYellowSphere
    //--------------------------------------------------//
    
    //Given an incoming node object and an Alpha object,
    // this method will return a TransformGroup object
    // that is designed to rotate the node around the
    // vertical axis in 3D space according to the number
    // of cycles and cycle time specified by the Alpha
    // object.
    TransformGroup rotate(Node node,Alpha alpha){

      TransformGroup xformGroup = new TransformGroup();
      xformGroup.setCapability(
                    TransformGroup.ALLOW_TRANSFORM_WRITE);
      
      //Create an interpolator for rotating the node.
      RotationInterpolator interpolator = 
               new RotationInterpolator(alpha,xformGroup);
                             
      //Establish the animation region for this
      // interpolator.
      interpolator.setSchedulingBounds(new BoundingSphere(
                           new Point3d(0.0,0.0,0.0),1.0));
      
      //Populate the xform group.
      xformGroup.addChild(interpolator);
      xformGroup.addChild(node);

      return xformGroup;
      
    }//end rotate
    //--------------------------------------------------//
    
    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to translate that node according to that vector.
    TransformGroup translate(Node node,Vector3f vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setTranslation(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end translate
    //--------------------------------------------------//
    
    //The purpose of this method is to create and return
    // a transform group designed to perform a counter-
    // clockwise rotation about the x, y, and z axes 
    // belonging to an incoming node.  The three incoming
    // angle values must be specified in radians. Don't
    // confuse this with a RotationInterpolator.  This is
    // not an interpolation operation.  Rather, it is a
    // one-time transform.
    TransformGroup tiltTheAxes(Node node,
                               double xAngle,
                               double yAngle,
                               double zAngle){

      Transform3D tiltAxisXform = new Transform3D();
      Transform3D tempTiltAxisXform = new Transform3D();
      
      //Construct and then multiply two rotation transform
      // matrices..
      tiltAxisXform.rotX(xAngle);
      tempTiltAxisXform.rotY(yAngle);
      tiltAxisXform.mul(tempTiltAxisXform);
      
      //Construct the third rotation transform matrix and
      // multiply it by the result of previously 
      // multiplying the two earlier matrices.
      tempTiltAxisXform.rotZ(zAngle);
      tiltAxisXform.mul(tempTiltAxisXform);
      
      TransformGroup tiltedGroup = new TransformGroup(
                                           tiltAxisXform);
      tiltedGroup.addChild(node);
      
      return tiltedGroup;
    }//end tiltTheAxes
    //==================================================//
    
  }//end inner class TheScene

}//end class Java3D009</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java &quot;java 3D&quot; SimpleUniverse ColorCube BranchGroup canvas 
setNominalViewingTransform getPreferredConfiguration SimpleUniverse Sphere 
Primitive Appearance Material PointLight BranchGroup Canvas3D Transform3D 
TransformGroup BoundingSphere Vector3f Point3f Point3d Color3f 
ALLOW_TRANSFORM_WRITE Alpha Interpolator RotationInterpolator </p>
<p>-end- </p>
</body>
</html>
