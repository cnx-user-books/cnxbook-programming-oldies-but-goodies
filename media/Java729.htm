<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body alink="#ff0000" lang="EN-US" link="#0000ff" vlink="#666666">
<h2>Message Digests 101 using Java</h2>
<i>Learn how to write Java code to implement the SHA-1 algorithm 
and how to produce message digests using that code.&nbsp; Also learn how to use Sun's <b>MessageDigest</b> class to produce message digests for both the 
SHA-1 and MD5 algorithms.</i><p><b>Published:</b>&nbsp; March 8, 2005<br>
<b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
<p>Java Programming, Notes # 729</p>
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a></li>
  <li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#Whats%20Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a>
  </li>
</ul>
<hr align="center" size="3" width="100%">
<center>
<h2> <a name="Preface">Preface</a></h2>
</center>
<p><font color="#FF0000"><b>Third</b></font><font color="#ff0000"><b> in a series</b></font></p>
<p>This is the third lesson in a series designed to teach you
something about the inner workings of cryptography using Java.&nbsp;
The previous lesson was entitled 
<a href="http://www.developer.com/java/web/article.php/3469641">Digital 
Signatures 101 using Java</a>.&nbsp; Hopefully, when you
finish studying the lessons in this series, you will have learned a
little about what goes on
<i>"under the hood"</i> when you apply a cryptographic process to a message.</p>
<p><font color="#ff0000"><b>Not a lesson on JCE</b></font></p>
<p>The lessons in this series do not provide instructions on how to use
the
<a
 href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Java
Cryptography Extension <i>(JCE)</i></a>.&nbsp; The purpose of this
series is to teach you how to implement common cryptography and secure hash 
algorithms for small cases without the use of a cryptography API.</p>
<p><font color="#ff0000"><b>Not intended for production use</b></font></p>
<p>The programs that I will provide and explain in this series of
lessons are not intended to be used for production cryptography.&nbsp;
If you need to do cryptography using Java, you should use
<a
 href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Sun's
Java Cryptography Extension <i>(JCE)</i></a><i>.</i></p>
<p>The programs that I will provide in this series are intended to help
you to experiment with and to learn about various cryptographic and secure hash
algorithms and to gain a better understanding of how they work, and why
they do what they do.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different figures and listings while
you are reading about them.</p>
<p><font color="#ff0000"><b>Theoretical basis and practical
implementation</b></font></p>
<p>I will provide some of the theoretical basis for cryptographic and secure 
hash
algorithms while discussing the lessons in this series.&nbsp; In
addition, I will show you how to implement several common cryptographic
and secure hash algorithms in Java.</p>
<p>I will also discuss and illustrate some of the modern uses of
cryptography, such as the use of digital signatures.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <a href="http://www.dickbaldwin.com">
www.DickBaldwin.com</a><font color="#000000">.</font></p>
<h2 align="center"><a name="Background_Information">Background
Information</a></h2>
<p>Cryptography in one form or another has been around throughout
history.&nbsp; Please see the earlier lesson entitled 
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a> for some
background information on cryptography.</p>
<p><font color="#ff0000"><b>New uses in modern times</b></font></p>
<p>Bringing the field of cryptography up to date,
<a href="http://en.wikipedia.org/wiki/Cryptography">Wikipedia</a> tells
us, <i>
"In recent decades, the field of cryptography has expanded its remit in
two ways. Firstly, it provides mechanisms for more than just
<a title="Confidentiality"
 href="http://en.wikipedia.org/wiki/Confidentiality">keeping secrets</a>:
schemes like
<a title="Digital signature"
 href="http://en.wikipedia.org/wiki/Digital_signature">digital
signatures</a> and
<a title="Digital cash" href="http://en.wikipedia.org/wiki/Digital_cash">digital
cash</a>, for example." </i></p>
<p><font color="#ff0000"><b>Secure communications</b></font></p>
<p>The lessons in this series will present and explain programs that
implement cryptographic and secure hash algorithms intended to achieve secure
communications between two parties.&nbsp; The cryptographic algorithms fall into
two broad categories:</p>
<ul>
  <li>Public <i>(asymmetric)</i> key cryptography</li>
  <li>Symmetric key cryptography</li>
</ul>
<p>The first several lessons deal with
<a
 href="http://en.wikipedia.org/wiki/Cryptography#Public_key_cryptography">public
key cryptography</a>.&nbsp; Subsequent lessons deal with
<a
 href="http://en.wikipedia.org/wiki/Cryptography#Symmetric_key_cryptography">symmetric
key cryptography</a>. </p>
<p>Please see the previous lesson entitled 
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a> for a discussion of
the difference between the two.</p>
<p><font color="#FF0000"><b>Secure hash algorithms</b></font></p>
<p>In addition, cryptographic algorithms are commonly supplemented by secure 
hash algorithms.&nbsp; Several secure hash algorithms are in common use.&nbsp; 
This lesson explains the SHA-1 algorithm as defined in FIPS Pub 180-2, currently 
available at&nbsp; <font color="#ff0000">
<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">
http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a></font>.&nbsp; 
FIPS Pub 180-2 is the primary source for technical information contained in this 
lesson.</p>
<p><font color="#ff0000"><b>Message signing and digital signatures</b></font></p>
<p>As explained in the previous lesson entitled
<a href="http://www.developer.com/java/web/article.php/3469641">Digital 
Signatures 101 using Java</a> a variety of protocols are 
available for the use of public-key cryptography and digital signatures to 
protect the <i>authenticity, integrity,</i> and <i>confidentiality</i> of a message.&nbsp; That 
lesson explained a simple and easily understood protocol.&nbsp; However, it was 
pointed out in that lesson that an improved protocol can be achieved through the 
use of message digests.&nbsp; The purpose of this lesson is to explain how to 
create a message using the SHA-1 Secure Hash Algorithm.</p>
<p>A future lesson will explain how to use a message digest in an improved 
digital signature protocol.</p>
<p><font color="#ff0000"><b>Three important aspects</b></font></p>
<p>There are at least three important aspects of electronic
communication:</p>
<ul>
  <li><b>Authentication:</b> Confirming the identities of the parties involved.
  </li>
  <li><b>Confidentiality:</b> Making certain that only authorized
parties can understand the message, even if it is intercepted by
unauthorized persons. </li>
  <li><b>Integrity:</b> Confirming that content of the message wasn't
modified during transmission.</li>
</ul>
<p>The primary purpose of a digital signature, whether or not it is implemented 
using a message digest, is to achieve authentication and to validate the integrity 
of a message.&nbsp; Message digests, on the other hand, have a 
far greater role than simply being used in digital signatures.&nbsp; 
Therefore, even though the lead-in to this lesson has to do with digital 
signatures, the scope of this lesson is somewhat broader than the use of message 
digests in digital signatures.</p>
<p><font color="#FF0000"><b>What is a message digest?</b></font></p>
<p>According to Brett C. Tjaden, author of
<a href="http://www.fbeedle.com/66-X.html">Fundamentals of Secure Computer 
Systems</a>, </p>
<blockquote>
	<p><i>&quot;Checksums are typically used to produce a fingerprint of a message so 
	that if the message changes the checksum will not match, indicating an 
	error.&nbsp; Most checksum functions ... are not designed to prevent an 
	adversary from intentionally changing a message so that the resulting 
	message has the same checksum as the original message, and thus avoiding 
	detection.&quot;</i></p>
	<p><i>&quot;Cryptographic hash functions (also called message digests) are 
	designed to protect against this possibility.&nbsp; These techniques are 
	often based on collision-resistant, one-way, hash functions.&quot;</i></p>
</blockquote>
<p>Thus, message digests are a special form of hash function that are designed 
to protect a message against attack</p>
<p><font color="#FF0000"><b>What is a hash function?</b></font></p>
<p>There are many kinds of hash functions.&nbsp; One large category of hash 
functions includes the hash functions that are used with the keys in a hashtable 
data structure.</p>
<p>Another large category includes cryptographic hash functions mentioned above.</p>
<p>A cryptographic hash function takes an input of arbitrary <i>(but finite)</i> 
length and produces an output whose size is always the same regardless of the 
length of the input.&nbsp; For example, the MD5 function, which will be 
discussed later, always produces an output consisting of 128 bits.&nbsp; The 
SHA-1 function, which is the main topic of this lesson, always produces an output 
consisting of 160 bits.</p>
<p><font color="#FF0000"><b>A value between 0 and M</b></font></p>
<p>Thus, one way to think about the output of a cryptographic hash function that 
produces an N-bit output is that the function always produces an output 
consisting of a positive binary integer whose value ranges between 0 and M.&nbsp; 
The value of M is one less than 2 raised to the Nth power.</p>
<p>For example, when N is 3, M has a value of 7.&nbsp; While easy to demonstrate 
with pencil and paper, this is not too exciting 
from a cryptography viewpoint.&nbsp; When N is equal to 128, M is a very large 
number.&nbsp; When N is equal to 160, M is an even larger number.&nbsp; Therefore, 
the number of possible outcomes when either the MD5 algorithm or the SHA-1 
algorithm is used to hash a message is very large.</p>
<p><font color="#FF0000"><b>What is a one-way hash function?</b></font></p>
<p>One of the characteristics of a good cryptographic hash function is that it 
is a <i>one-way</i> hash function.&nbsp; One description of a one-way hash 
function is that even if the algorithm and the output produced by hashing a 
given secret message is known, it is impossible, impractical, or at least 
extremely expensive to determine anything about the secret message solely on the 
basis of knowledge of the algorithm and the output.&nbsp; Thus, knowing the 
output produced by the hash function does not divulge any of the secrets 
contained in the message.</p>
<p>Another description says that given an output for a one-way hash function, it 
should be impossible, impractical, or at least extremely expensive to devise any 
specific message that will produce that output.&nbsp; </p>
<p>From a practical standpoint, this implies that a good one-way hash function 
will have a very large number of possible output values <i>(as is the case with 
MD5 and SHA-1).</i>&nbsp; Otherwise, it would be easy to write a program that 
creates and hashes random input messages until at least one input message has 
been identified that produces each of the possible output values.</p>
<p><font color="#FF0000"><b>What is a collision-resistant hash function?</b></font></p>
<p>A collision-resistant hash function is one in which it is extremely unlikely 
that the application of the function to any two or more different messages would 
produce the same output value.&nbsp; A change as small as replacing one of the 
characters in the message with a different character would produce an entirely 
different output in a collision-resistant hash function.</p>
<blockquote>
	<p><i>(Pairs of different messages that produce the same output for a given 
	hash function are said to cause collisions.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A simple hash function</b></font></p>
<p>As I recall, the original ASCII encoding scheme was a 7-bit code that 
represented 128 characters and control codes as the values from 0 through 127.</p>
<blockquote>
	<p><i>(For example, the upper-case A character is represented by the decimal 
	value 65 in seven-bit ASCII.)</i></p>
</blockquote>
<p>One could devise a hash function by adding all of the ASCII values of the 
characters in a message and throwing away the carry whenever the sum exceeds 
255.&nbsp; Thus, this hash function would produce an eight-bit output with values ranging from 0 
to 255, for a total of 256 possible outputs.</p>
<p><font color="#FF0000"><b>Not collision resistant</b></font></p>
<p>This would not be a collision-resistant hash function.&nbsp; We immediately 
know this because the number of possible input messages is significantly greater 
than the number of possible output values <i>(256).</i>&nbsp; Thus, there must be many different messages that would produce the same output value.</p>
<blockquote>
	<p><i>(If a hash function always produced an output value of 1, then every 
	possible input message would collide with every other possible input 
	message.)</i></p>
</blockquote>
<p>For example, applying this hash function to the three-character message 
consisting of the characters &quot;BDF&quot; would produce an output value of 204.&nbsp; 
Similarly, applying this hash function to the message consisting of the 
characters &quot;CDE&quot; would also produce an output value of 204.&nbsp; Thus, there is 
a collision between these two messages because the application of the hash 
function to either message produces the same output value.</p>
<p>While very easy to program, this hash 
function is sorely lacking in terms of being collision resistant.</p>
<blockquote>
	<p><i>(I will leave it as an exercise for the student to decide the degree 
	to which this is a one-way hash function.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Good collision-resistant one-way hash functions</b></font></p>
<p>According to Tjaden, given the functional relationship H(M) = h, good 
collision-resistant one-way hash functions exhibit the following properties:</p>
<ul>
	<li>Given the message M, it is easy to compute the hash value h by applying 
	the hash function H to the message M.</li>
	<li>Given any specific hash value, hx, it is difficult to find any message 
	Mx such that H(Mx) = hx</li>
	<li>Given a specific message M1, it is difficult to find another message M2
	<i>(M2 not identical to M1)</i> such that H(M1) = H(M2).</li>
</ul>
<p>According to Tjaden,</p>
<blockquote>
	<p><i>&quot;Functions that satisfy these criteria are often called <b>message 
	digest</b> functions, because they can be used to produce a fixed-length 
	digest (or fingerprint) of an arbitrary-length message.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Validating integrity, a practical example</b></font></p>
<p>It is probably safe to say that most uses of message digests involve the 
validation of the integrity of a body of digital information even when 
authentication is not a big issue.</p>
<p>For example, I normally use Norton Antivirus software to protect my computer 
from viruses.&nbsp; I have the antivirus program configured so that it updates the 
local virus definition database on a weekly basis.</p>
<p>In the 
event that I feel the need to update more frequently, I can visit
<a href="http://securityresponse.symantec.com/avcenter/download/pages/US-NAVCE.html">
http://securityresponse.symantec.com/avcenter/download/pages/US-NAVCE.html</a> 
and manually download an executable file which, when executed on my computer, will update 
the local virus database to contain the latest virus information.</p>
<p><font color="#FF0000"><b>Should I execute the file on my computer?</b></font></p>
<p>Since I download the file directly from the Symantec website, I'm not too 
concerned about authenticating the actual source of the file.&nbsp; <i>(I'm 
reasonably confident that the website was created by and is maintained by 
Symantec.)</i></p>
<p>However, I 
may be concerned about the possibility that the file has been maliciously 
tampered with after it was made available for downloading on the Symantec server.</p>
<p>While the likelihood of tampering is probably very low, since it is an 
executable file the damage that could be done by a maliciously tampered file 
could be great.</p>
<p>Tampering could happen if someone managed to break into the Symantec server 
and replace the file with a different file having the same name.&nbsp; Tampering 
could also happen through interception and replacement of the file by an 
attacker during the transmission of the file from the Symantec website to my 
computer.</p>
<p><font color="#FF0000"><b>A file name and an associated message digest</b></font></p>
<p>Each day a new downloadable executable file with a different name is provided 
on the Symantec website, 
where the name is based on the 
date.</p>
<blockquote>
	<p><i>(On the date of this writing, the downloadable file is named 20050120-008-x86.exe.)</i></p>
</blockquote>
<p>In addition to the downloadable executable file, the Symantec web site 
also provides a 128-bit message digest <i>(in hexadecimal format)</i> based on the 
MD5 hash function.&nbsp; This message digest serves as a fingerprint for 
the executable file.</p>
<p><font color="#FF0000"><b>I can validate the integrity of the file</b></font></p>
<p>If I have any concerns about the integrity of the 
executable file <i>(such as whether or not it may have been tampered with),</i> 
I can compute the message digest for the file after downloading and before execution.&nbsp; I can 
compare the message digest of the downloaded file with the message digest given on the 
Symantec website and validate <i>(or fail to validate)</i> the integrity of the executable file.</p>
<blockquote>
	<p><i>(In this case, the message digest is based on the use of a hash function 
	named MD5, which is a different hash function from SHA-1.&nbsp; As an 
	example, on the date 
	of this writing, the MD5 message digest for the executable file listed above 
	was 
	8F595216E577AAB670D1550EE96402EB.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does Symantec have to say?</b></font></p>
<p>Figure 1 contains some of what Symantec has to say about the use of the MD5 
message digest.&nbsp; This information is useful because it expresses much of 
what this lesson is all about.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      A hash function such as MD5 is a one-way operation that transforms a data string of any length into a shorter, fixed-length value. No two strings of data will produce the same hash value.

		<p>An MD5 checksum verifies the data integrity by running a hash operation on the data after it is received. The resultant hash value is compared to the hash value that was sent with the data.&nbsp; If the two values match, this indicates that the data has not been altered or tampered with, and its integrity may be trusted.</p>
		<p>Click </a><a target="_blank" href="http://www.fourmilab.ch/md5/">here</a> to learn more about MD5 and to download an MD5 checksum utility.</p>
		<p><b>Figure 1</b></p>
</pre></td></tr></tbody></table><p><font color="#FF0000"><b>An MD5 checksum utility</b></font></p><p>As you can see, in addition to providing the MD5 message digest for the executable file, Symantec also provides a free utility program that can be used to validate the file against the message digest after the file has been downloaded and before it is executed.</p><blockquote><p><i>(Although I haven't used the program to generate a message digest, the documentation indicates that the program can be used to generate MD5 message digests as well as to check them.&nbsp; In addition, the program can be used with either files or strings as input.&nbsp; Therefore, this might be an interesting utility program for you to download and experiment with.)</i></p></blockquote><p><font color="#FF0000"><b>Hashtable hash functions versus cryptographic hash functions</b></font></p><p>Programmers have been using hash functions for many years to deal with the key values in hashtables.&nbsp; Cryptographic hash functions are a close first cousin to the hash functions used with hashtables.&nbsp; However, there are some important differences having to do primarily with the application.</p><p><font color="#FF0000"><b>Number of possible values</b></font></p><p>As mentioned earlier, the number of possible values produced by a cryptographic hash function should normally be very large for the reasons given.&nbsp; On the other hand, the values produced by a hashtable hash function normally refer to storage locations in some sort of storage space.&nbsp; Therefore, while in extreme cases, it might be useful for these hash functions to produce millions of possible values, the useful range is probably much smaller than is the case for cryptographic hash functions.</p><p><font color="#FF0000"><b>Collision resistance</b></font></p><p>As mentioned earlier, collision resistance is extremely important for cryptographic hash functions.&nbsp; While collision resistance is probably also important for hash functions used with hashtables, people who design hashtables have developed a variety of ways to deal with collisions.&nbsp; Therefore, collisions are probably less of a problem with hash functions used with hashtables than with cryptographic hash functions.</p><p><font color="#FF0000"><b>One-way hash functions</b></font></p><p>Also as mentioned earlier, it is extremely important that cryptographic hash functions be one-way functions.&nbsp; This is probably much less important for the hash functions that are used with hash tables.&nbsp; Except for the fact that the ability to deduce the input from the output of a hash function implies poor resistance to collisions, it probably doesn't matter if it is possible to work backwards from a hashtable hash value and deduce the value of the key that was used to produce that hash value.&nbsp; I doubt that would be a security issue with hash tables.&nbsp; On the other hand, it would be an extreme security problem for cryptographic hash functions.</p><h2 align="center"><a name="Preview">Preview</a></h2><p><font color="#ff0000"><b>Two different programs</b></font></p><p>I will present and explain two different programs in this
lesson.&nbsp; The first program named <b>Sha03</b> will show you how to create a 
message digest from the ground up through the implementation and use of the 
SHA-1 algorithm.&nbsp; The purpose of this lesson is to teach you the inner 
workings of the SHA-1 algorithm.</p><p>The second lesson named <b>Sha01</b> will show you how to create a 
message digest using an instance of Sun's <b>MessageDigest</b> class.</p><p>Each of the programs will be used to produce message digests for the same three messages, and the results will be shown to be identical.</p><h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and
Sample Code</a></h2><p><font color="#ff0000"><b>The program named Sha03</b></font></p><p>Before getting into the details of this program, I will provide a verbal description of the implementation of the SHA-1 algorithm.</p><p>The maximum length of a message <i>(in bits)</i> that can be hashed using the SHA-1 algorithm is one less than 2 to the 64th power.</p><p>Implementation of the SHA-1 algorithm consists of <a name="six_major_steps">six major steps</a> and a variety of minor steps.</p><p>This implementation is based on the description of the SHA-1 algorithm beginning in Section 5.0 of the Federal Information Processing Standards (FIPS) Publication 180-2 available at:&nbsp; <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.</p><p><font color="#ff0000"><b><a name="Step_1">Step 1</a> Preprocessing</b></font></p><p>The first major step is to prepare the message for hashing.&nbsp; There are three minor steps included in this preprocessing step.</p><p>The first minor preprocessing step is to pad the length of the message so as to guarantee that the final length is a multiple of 512 bits or 64 bytes.</p><p>The second minor preprocessing step is to set the initial hash value to a standard 160-bit value.&nbsp; <i>(You will see the standard value later in the discussion of the program.)</i></p><p>The third minor preprocessing step is to parse the padded message into blocks of 512 bits or 64 bytes each.</p><p><font color="#FF0000"><b>Each block is processed separately</b></font></p><p>Each block is processed separately and the hash value is updated during the processing of each block.&nbsp; The initialized hash value from above is the input hash value for processing the first block.&nbsp; The updated hash value produced by processing each block serves as the initial hash value for the processing of the next block.</p><p><font color="#ff0000"><b>Padding the message</b></font></p><p>All messages are padded regardless of the original length of the message.&nbsp; The number of bits in the pad must be such as to cause the final length to be a multiple of 512 bits.&nbsp; The first bit in the pad must have a value of 1.&nbsp; The last 64 bits in the pad must contain a binary representation of the length of the original message.&nbsp; All other bits in the pad must have a value of 0.</p><p><font color="#ff0000"><b>Resources used by the algorithm</b></font></p><p>The algorithm uses the following resources:</p><ul><li>A message <i>schedule</i> consisting of eighty 32-bit words, known in this program as <b>W[0]</b> through <b>W[79]</b>.</li><li>An array of eighty 32-bit constants, known in this program as <b>K[0]</b> through <b>K[79]</b>.</li><li>Five working variables of 32 bits each, known in this program as <b>A</b> through <b>E</b>.</li><li>A 160-bit hash value consisting of five 32-bit words known in this program as <b>H[0]</b> through <b>H[4]</b>.&nbsp; The final hash result consists of five 32-bit words, which constitute a 160-bit message digest.&nbsp; The digest is a unique fingerprint of the message used to compute the hash value.</li><li>A temporary word known in this program as <b>temp</b>.</li></ul><p><font color="#ff0000"><b>Processing the message blocks</b></font></p><p>Each message block, consisting of 64 bytes, is processed in sequence.&nbsp; The hash value output from processing one message block forms the initial hash value for processing the next message block.&nbsp; The hash value output from processing the final message block is the message digest for the message.</p><p><font color="#FF0000"><b>The five remaining steps</b></font></p><p>The five remaining major steps take place and are repeated during the processing of each message block.</p><p><font color="#FF0000"><b><a name="Step_2">Step 2</a>:&nbsp; Initialize the message schedule</b></font></p><p>Initialize the message schedule <b>W</b> by using the incoming 64 bytes that constitute a message block to populate the first sixteen 32-bit elements of the 80-element message schedule.</p><p><font color="#FF0000"><b><a name="Step_3">Step 3</a>:&nbsp; Populate the remainder of the message schedule</b></font></p><p>Populate the remaining 64 elements of the message schedule <b>W</b> by propagating the values in the first sixteen elements upward into the remaining 64 elements.</p><p><font color="#FF0000"><b><a name="Step_4">Step 4</a>:&nbsp; Initialize the working variables</b></font></p><p>Set the initial values of the variables <b>A</b> through <b>E</b> to the five 32-bit segments of the incoming 160-bit hash value.</p><p><font color="#FF0000"><b><a name="Step_5">Step 5</a>:&nbsp; Process the message schedule</b></font></p><p>Individually process each of the elements in the 80-element message schedule.&nbsp; A different process is applied to the elements in each group of 20 elements.&nbsp; The processing of each element results in an updated set of values for the working variables <b>A</b> through <b>E</b>.</p><blockquote><p><i>(These processes require the use of 32-bit unsigned addition, which is not directly supported by a Java primitive operator.&nbsp; Thus, a special method is required to accomplish this addition.)</i> </p></blockquote><p><font color="#FF0000"><b><a name="Step_6">Step 6</a>:&nbsp; Update the hash value</b></font></p><p>When all 80 elements in the message schedule have been processed, use the values in the working variables <b>A</b> through <b>E</b> to update the five 32-bit segments of the hash value.&nbsp; This updated hash value is used as the input hash value for processing the next message block.&nbsp; If all message blocks have been processed, the updated hash value is the message digest for the message that has been processed.</p><p>I will refer back to these steps during the discussion of the code in the program.</p><p><font color="#FF0000"><b>Description of the program</b></font></p><p>This program implements the SHA-1 secure hash algorithm as defined at:&nbsp; <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.&nbsp; This resource will be referred to hereafter simply as <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.</p><p>Also see page 67 of the book entitled <a href="http://www.fbeedle.com/66-X.html">Fundamentals of Secure Computer Systems</a> by Brett C. Tjaden.</p><p><font color="#FF0000"><b>Testing the implementation</b></font></p><p>The program tests the implementation, producing an output that should exactly match the output produced by the program named <b>Sha01</b> <i>(to be discussed later).</i></p><p>The program creates and displays the message digests for three different strings of 8-bit character data.&nbsp; One of the strings is very short, consisting of only three characters or 24 bits.</p><blockquote><p><i>(This matches one of the test cases given in Appendix A of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.&nbsp; The program was also tested successfully against the other two test cases given in Appendix A of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>, but the results of those tests are not shown in this lesson.)</i></p></blockquote><p>A second string that was used for testing the program consists of 50 characters or 400 bits.&nbsp;&nbsp; The third string consists of 65 characters or 520 bits.</p><p>The two longer strings were selected to confirm correct behavior of the code across the 512-bit processing boundary of the SHA-1 algorithm.</p><p>The program was tested using JDK 1.5.0 and WinXP.</p><p><font color="#FF0000"><b>The program output</b></font></p><p>The output produced by the program is shown in Figure 2.</p><table bgcolor="#ccffff" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>Digests are displayed in hex format.
Data Length: 24 bit message.
Message Digest:
A9993E364706816ABA3E25717850C26C9CD0D89D
Data Length: 400 bit message.
Message Digest:
804AA5C1DE1C74C10C37F36327A12924B87DD3A7
Data Length: 520 bit message.
Message Digest:
E2220BDED2A3E23A44E883401042123A790AE21D<br></pre>
      <pre><b>Figure 2</b></pre></td></tr></tbody></table><p>The message digests in Figure 2 are displayed in hexadecimal format.</p><p>As you can see from Figure 2, the message digest is always 160 bits in length regardless of the length of the message being digested.</p><p>I will refer back to Figure 2 during the discussion and explanation of the program.</p><p><font color="#FF0000"><b>The class named Sha03</b></font></p><p>Listing 1 shows the beginning of the class named <b>Sha03</b> and the beginning of the <b>main</b> method.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>class Sha03 {

&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; Sha04 digester = new <b>Sha04</b>();
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Digests are displayed in hex format.");<br><br><b>Listing 1</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>As you will see later, the class named <b>Sha03</b> serves simply as a driver program to exercise the capabilities of an object of a top-level class named <b>Sha04</b>.</p><blockquote><p><i>(I didn't declare <b>Sha04</b> public simply because I didn't want to be forced to put it in a different source code file.)</i></p></blockquote><p>Listing 1 instantiates a new object of the class named <b>Sha04</b>, and saves its reference in a local reference variable named <b>digester</b>.</p><p>Then Listing 1 displays the first line of text shown in Figure 2.</p><p><font color="#FF0000"><b>Create a very short message</b></font></p><p>Listing 2 creates a very short message consisting of only three characters and then displays the length of the message in bits, producing the output shown in line 2 of Figure 2. </p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; byte[] dataBuffer = ("abc").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
<b>Listing 2</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Digest the very short message</b></font></p><p>The code in Listing 3 digests the message by passing its reference to the method named <b>digestIt</b> belonging to the object instantiated earlier from the class named <b>Sha04</b>.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; String theDigest = digester.<b>digestIt</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataBuffer);<br><br><b>Listing 3</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>As you can see in Listing 3, the <b>digestIt</b> method of the <b>Sha04</b> class returns the message digest as a reference to a <b>String</b> object.&nbsp; Later you will see that this <b>String</b> object encapsulates the 160 bits that comprise the message digest expressed in hexadecimal format.</p><p><font color="#FF0000"><b>The digestIt method of the Sha04 class</b></font></p><p>At this point, I am going to set the <b>main</b> method aside for awhile and explain the implementation of the SHA-1 algorithm, as embodied in the method named <b>digestIt</b>.</p><p>Listing 4 shows the beginning of the <b>Sha04</b> class and the beginning of the <b>digestIt</b> method.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>class Sha04{
&nbsp; String digestIt(byte[] dataIn){
&nbsp;&nbsp;&nbsp; //Step 1:
&nbsp;&nbsp;&nbsp; byte[] paddedData = <b>padTheMessage</b>(dataIn);<br><br><b>Listing 4</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>The<b> Sha04 </b>class generates and returns a message digest for an incoming array of bytes of arbitrary length.&nbsp; You should invoke the instance method named <b>digestIt</b> on an object of the <b>Sha04</b> class to digest a message.&nbsp; Pass the message to the <b>digestIt</b> method as an array of bytes.</p><p>The message digest is returned as a reference to a <b>String</b> object, which encapsulates a 160-bit message digest expressed in hexadecimal format.</p><p><font color="#FF0000"><b>Six major steps</b></font></p><p>As explained earlier, the algorithm consists of <a href="#six_major_steps">six</a> major steps and a variety of minor steps.&nbsp; The <a href="#Step_1">first</a> of the six major steps is shown in Listing 4.&nbsp; Listing 4 invokes the method named <b>padTheMessage</b> in order to pad the incoming data and guarantee that the message length is a multiple of 512 bits.</p><p><font color="#FF0000"><b>Padding the message</b></font></p><p>Recall that all messages must be padded regardless of the original length of the message.&nbsp; The number of bits in the pad must be such as to cause the final length to be a multiple of 512 bits.&nbsp; The first bit in the pad must have a value of 1.&nbsp; The last 64 bits in the pad must contain a binary representation of the length of the original message.&nbsp; All other bits in the pad must have a value of 0. </p><p>You can view the method named <b>padTheMessage</b> in Listing 23 near the end of the lesson.&nbsp; The method is straightforward and is not deserving of a detailed discussion in this lesson.</p><p><font color="#FF0000"><b>Set the initial hash value</b></font></p><p>Listing 5 sets the initial hash value, expressed in hexadecimal format as five 32-bit words, to the values specified in Section 5.3.1 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; int[] H = {0x67452301,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xEFCDAB89,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x98BADCFE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10325476,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xC3D2E1F0};<br><br><b>Listing 5</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Set constant values</b></font></p><p>Listing 6 sets the values of eighty 32-bit constants as specified in Section 4.2.1 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; int[] K = new int[80];
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < 20;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x5A827999;
&nbsp;&nbsp;&nbsp; for(int cnt = 20;cnt < 40;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6ED9EBA1;
&nbsp;&nbsp;&nbsp; for(int cnt = 40;cnt < 60;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8F1BBCDC;
&nbsp;&nbsp;&nbsp; for(int cnt = 60;cnt < 80;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xCA62C1D6;<br><br><b>Listing 6</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Determine the number of blocks</b></font></p><p>Listing 7 begins by making certain that the length of the padded message is a multiple of 512 bits or 64 bytes.&nbsp; If not, the program terminates.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; if(paddedData.length % 64 != 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Invalid padded data length.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; int passesReq = paddedData.length/64;<br><br><b>Listing 7</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>Then Listing 7 determines and saves the number of 512-bit blocks that must be processed.&nbsp; This value is used as a loop counter in the <b>for</b> loop shown in Listing 8.</p><p><font color="#FF0000"><b>Process the blocks</b></font></p><p>Listing 8 shows the control structure used to process each of the blocks by invoking the method named <b>processTheBlock</b> once for each block.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; byte[] work = new byte[64];
&nbsp;&nbsp;&nbsp; for(int passCntr = 0;passCntr < passesReq;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passCntr++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Copy the next block of paddedData into
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the working array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(paddedData,64*passCntr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work, 0, 64);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Process the current block of 64 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processTheBlock(work,H,K);
&nbsp;&nbsp;&nbsp; }//end for loop on passCntr

&nbsp;&nbsp;&nbsp; //Digestion is complete.
&nbsp;&nbsp;&nbsp; //Return the digest value to the calling
&nbsp;&nbsp;&nbsp; // method as a String.
&nbsp;&nbsp;&nbsp; return intArrayToHexStr(H);
&nbsp; }//end digestIt()<br><br><b>Listing 8</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>Each time the <b>processTheBlock</b> method is invoked, it receives:</p><ul><li>The padded message data for the next block</li><li>The 80 constants in the array named <b>K</b></li><li>The updated hash value produced by the previous invocation of <b>processTheBlock</b> and saved in the array named <b>H</b></li></ul><p>When the <b>processTheBlock</b> method returns, the array named <b>H</b> contains an updated version of the hash value.&nbsp; When the final invocation of <b>processTheBlock</b> returns, the final hash value is stored in the array named <b>H</b>.</p><p><font color="#FF0000"><b>Convert the hash value to a hexadecimal string</b></font></p><p>At this point, the <b>digestIt</b> method invokes a method named <b>intArrayToHexStr</b> to convert the hash value from an array containing five values of type <b>int</b> to a <b>String</b> object encapsulating forty hexadecimal characters. <i>(Each hexadecimal character represents four bits for a total of 160 bits.)</i>&nbsp;&nbsp; The <b>digestIt</b> method returns a reference to the <b>String</b> object as the message digest.</p><p><font color="#FF0000"><b>The intArrayToHexStr method</b></font></p><p>The <b>intArrayToHexStr</b> method converts an incoming array of <b>int</b> values into a <b>String</b> that represents each of the <b>int</b> values as eight hexadecimal characters including leading zeros if necessary.</p><p>The method can be viewed in its entirety in Listing 23 near the end of the lesson.&nbsp; The method is straightforward and doesn't warrant further discussion in this lesson.</p><p><font color="#FF0000"><b>The processTheBlock method</b></font></p><p>Listing 9 shows the beginning of the method named <b>processTheBlock</b>.&nbsp; This method, which is invoked once for each 512-bit block of the padded message, is the workhorse of the program.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp; private void processTheBlock(byte[] work,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] H,int[] K){

&nbsp;&nbsp;&nbsp; //Step 2:
&nbsp;&nbsp;&nbsp; int[] W = new int[80];
&nbsp;&nbsp;&nbsp; for(int outer = 0;outer < 16;outer++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int inner = 0;inner < 4; inner++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = (work[outer * 4 + inner]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; & 0x000000FF) << (24 - inner * 8);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W[outer] = W[outer] | temp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop<br><br><b>Listing 9</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>The <b>processTheBlock</b> method processes a message block consisting of 512 bits <i>(64 bytes)</i> of padded message data updating the ongoing calculation of the message digest, which is stored in the incoming array named <b>H</b>.</p><p>Steps 2 through 6 of the <a href="#six_major_steps">six</a> major steps described earlier are implemented within this method.</p><p><font color="#FF0000"><b>Do Step 2</b></font></p><p><a href="#Step_2">Step 2</a> is implemented in Listing 9.&nbsp; This step combines the incoming 64 bytes of padded message data into sixteen 32-bit values of type <b>int</b>, and deposits those 16 <b>int</b> values into the first 16 elements of an eighty-element array of type <b>int</b> named <b>W</b>.</p><p>The code required to accomplish this is straightforward and won't be discussed further.</p><p><font color="#FF0000"><b>Do Step 3</b></font></p><p><a href="#Step_3">Step 3</a> is implemented in Listing 10.&nbsp; At this point, the first 16 elements of <b>W</b> contain the data from 64 combined bytes of padded message data.&nbsp; The code in Listing 10 uses this data to populate the remaining 64 elements in <b>W</b>.</p><blockquote><p><i>(Note the use of the XOR operator (^) in Listing 10.&nbsp; Also note the use of the <b>rotateLeft</b> method of the <b>Integer</b> class to perform a circular left shift on the data.)</i></p></blockquote><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Step 3:
&nbsp;&nbsp;&nbsp; for(int j = 16; j < 80; j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp = W[j-3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-8];//XOR operator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-14];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-16];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = Integer.rotateLeft(temp,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W[j] = temp;
&nbsp;&nbsp;&nbsp; }//end for loop on j<br><br><b>Listing 10</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>The methodology for populating the upper 64 elements in<b> W</b> is specified in Section 6.1.2 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.</p><p><font color="#FF0000"><b>Do Step 4</b></font></p><p><a href="#Step_4">Step 4</a> is implemented by the code in Listing 11.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Step 4:
&nbsp;&nbsp;&nbsp; int A = H[0];
&nbsp;&nbsp;&nbsp; int B = H[1];
&nbsp;&nbsp;&nbsp; int C = H[2];
&nbsp;&nbsp;&nbsp; int D = H[3];
&nbsp;&nbsp;&nbsp; int E = H[4];<br><br><b>Listing 11</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>Listing 11 creates values for the variables <b>A</b> through <b>E</b> based on the current value of the message digest stored in <b>H</b>.</p><p><font color="#FF0000"><b>Do Step 5</b></font></p><p><a href="#Step_5">Step 5</a> is implemented in Listing 12.&nbsp; This step applies four different processes to the data in the eighty-element <b>W</b> array.</p><p>The same process is applied to each individual element in each group of 20 elements of <b>W</b>.&nbsp; However, the process changes from one group of 20 elements to the next group of 20 elements.</p><p>The specification for the process implemented in Listing 12 is provided on page 16 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Step 5:
&nbsp;&nbsp;&nbsp; int temp;
&nbsp;&nbsp;&nbsp; //Process first 20 elements
&nbsp;&nbsp;&nbsp; for(int j = 0;j < 20;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),<b>f0_19(B,C,D)</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Process next 20 elements
&nbsp;&nbsp;&nbsp; for(int j = 20;j < 40;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),<b>f20_39(B,C,D)</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Process next 20 elements
&nbsp;&nbsp;&nbsp; for(int j = 40;j < 60;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),<b>f40_59(B,C,D)</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Process last 20 elements
&nbsp;&nbsp;&nbsp; for(int j = 60;j < 80;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),<b>f60_79(B,C,D)</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop<br><br><b>Listing 12</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Four different functions</b></font></p><p>The difference in the processing from one group to the next in Listing 12 is embodied in the behavior of the four functions named <b>f0_19</b>, <b>f20_39</b>, <b>f40_59</b>, and <b>f60_79</b>.</p><blockquote><p><i>(The code in these four functions is straightforward.&nbsp; Each of the functions can be viewed in its entirety in Listing 23 near the end of the lesson.&nbsp; The specifications for the four functions are provided in Section 4.1.1 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.&nbsp; Note that there is a disagreement between <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a> and the Tjaden book with respect to two of these functions.&nbsp; This program implements the version specified in <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>.)</i></p></blockquote><p>Other than the use of the different functions in the first statement inside each of the <b>for</b> loops in Listing 12, the process is the same for each group of 20 elements.</p><p><font color="#FF0000"><b>The uAdd method</b></font></p><p>The method named <b>uAdd</b> is invoked several times within each <b>for</b> loop in Listing 12.&nbsp; The method named <b>uAdd</b> performs <i><b>unsigned</b></i> addition of two 32-bit integer parameters that are passed to the method.&nbsp; The use of such a method was necessary because Java does not have an unsigned addition operator for 32-bit data.</p><p>The code in the <b>uAdd</b> method is relatively straightforward.&nbsp; Each of the two 32-bit integer parameters is treated as a 32-bit unsigned value in the lower 32 bits of an integer of type <b>long</b>.&nbsp; The two <b>long</b> integers are added.&nbsp; Any overflow into the 33rd bit is discarded upon return when the <b>long</b> result is converted back to type <b>int</b>.&nbsp; </p><p>The <b>uAdd</b> method can be viewed in its entirety in Listing 23.</p><p><font color="#FF0000"><b>Do Step 6</b></font></p><p><a href="#Step_6">Step 6</a> is implemented in Listing 13.&nbsp; This step updates the hash value stored in <b>H</b> by adding the current hash value to the values of the variables <b>A</b> through <b>E</b> produced by the code in Listing 12.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Step 6:
&nbsp;&nbsp;&nbsp; H[0] += A;
&nbsp;&nbsp;&nbsp; H[1] += B;
&nbsp;&nbsp;&nbsp; H[2] += C;
&nbsp;&nbsp;&nbsp; H[3] += D;
&nbsp;&nbsp;&nbsp; H[4] += E;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return from processing this block with
&nbsp;&nbsp;&nbsp; // the updated values of the digest in H.
&nbsp; }//end processTheBlock<br><br><b>Listing 13</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Return with new hash value in H</b></font></p><p>This completes the processing of a 512-bit block of padded message.&nbsp; At this point, the updated hash value has been stored in the array named <b>H</b>, and the <b>processTheBlock</b> method returns.</p><p>If this is the final block in the padded message, the hash-value contents of <b>H</b> will be the message digest.&nbsp; If not, the hash value stored in <b>H</b> will be used as input to the processing of the next block of padded message.</p><p><font color="#FF0000"><b>Return to the main method</b></font></p><p>Now let's turn our attention back to the <b>main</b> method, picking up where we left off in Listing 3.</p><p>At this point the message digest for the very short message has been produced and stored in hexadecimal format in a <b>String</b> object referred to by the reference variable named <b>theDigest</b>.</p><p><font color="#FF0000"><b>Display the message digest</b></font></p><p>The code in Listing 14 displays the digest producing lines 3 and 4 in Figure 2.&nbsp; Note once again that even though the message contained only three characters, the message digest contained 160 bits represented by 40 hexadecimal digits in Figure 2.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);<br><br><b>Listing 14</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Digest a longer message</b></font></p><p>Continuing in the <b>main</b> method, Listing 15 digests and displays the digest for a longer <i>(400-bit)</i> message, displaying the results in lines 5 through 7 in Figure 2.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 400 bits, which is still less
&nbsp;&nbsp;&nbsp; // than&nbsp; the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digester.digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);<br><br><b>Listing 15</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>Note that even though this message was longer than the first one, it was still sufficiently short that the padded version would only be 512 bits in length.&nbsp; Therefore, this message did not exercise the capability of the <b>digestIt</b> method to process multiple blocks of 512 bits each.</p><p><font color="#FF0000"><b>A multi-block message</b></font></p><p>The code in listing 16 creates, digests, and displays the message digest for a message with an original length of 520 bits.&nbsp; This produced the output shown in Lines 8 through 10 in Figure 2.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567f\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "012g\n").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digester.digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);

&nbsp; }//end main
}//end class Sha03<br><br><b>Listing 16</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>The length of this message would result in a padded length of 1024 bits.&nbsp; Thus, this message exercised the ability of the <b>digestIt</b> method to correctly digest a message requiring the processing of more than one padded message block.</p><p><font color="#FF0000"><b>End of the main method</b></font></p><p>Listing 16 also signals the end of the <b>main</b> method and the end of the program.</p><p><font color="#FF0000"><b>Are these the correct results?</b></font></p><p>How do I know that I didn't make a mistake in my implementation of the SHA-1 algorithm as defined in <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a>?&nbsp; The algorithm is sufficiently complex that it would be easy to make a mistake.</p><p>I can't say for certain that I didn't make a mistake.&nbsp; I can say that I probably didn't make a mistake because the results produced by these three test cases agree with message digests that I produced using an independent program named <b>Sha01</b>.&nbsp; The program named <b>Sha01</b> uses Sun's implementation of the SHA-1 algorithm and I trust that implementation to be correct.&nbsp; Also, I tested my implementation against three test cases given in Appendix A of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a> and produced a matching message digest in all three cases.</p><p><font color="#FF0000"><b>What have you learned so far?</b></font></p><p>Hopefully at this point, you will have learned something about message digests in general, the SHA-1 hash function in particular, and how to implement an SHA-1 message digest capability from the ground up using Java.</p><p>Now let's move along to the second program that I will explain in this lesson.</p><p><font color="#FF0000"><b>The program names Sha01</b></font></p><p>This program uses Sun's SHA algorithm and serves as the baseline for confirming the correctness of my own version of the SHA-1algorithm as implemented in the program named <b>Sha03</b>.</p><p>This program creates and displays the digests for three different strings of 8-bit character data.&nbsp; The strings are identical to the strings used in the program named <b>Sha03</b>.</p><p>As before, one of the strings is very short, consisting of only three characters or 24 bits.&nbsp; The second string consists of 400 bits.&nbsp; The third string consists of 520 bits.&nbsp; The two longer strings confirm correct operation across the 512-bit processing boundary of the SHA-1 algorithm.</p><p>The results are displayed in hexadecimal format.&nbsp; The digest is always 160 bits long, regardless of the length of the message being digested.</p><p>The program was tested using JDK 1.5.0 and WinXP.</p><p><font color="#FF0000"><b>The program output</b></font></p><p>The output produced by this program is identical to the output produced by the program named <b>Sha03</b> that was shown in Figure 2. Therefore, I won't duplicate that output in another figure.&nbsp; The fact that the outputs produced by the two programs are identical confirms that each program produces the same message digest when applied to the same message.</p><p>You can view the entire program in Listing 24 near the end of the lesson.&nbsp; Except for the code in the method named <b>digestIt</b>, the two programs are very similar.&nbsp; Therefore, I will discuss only a small portion of this program.</p><p><font color="#FF0000"><b>The class named Sha01</b></font></p><p>Listing 17 shows the beginning of the class named <b>Sha01</b> and the beginning of the <b>main</b> method.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>import java.security.*;

class Sha01 {
&nbsp; public static void main(String[] args) {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Digests are displayed in hex format.");
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a very
&nbsp;&nbsp;&nbsp; // short message.
&nbsp;&nbsp;&nbsp; byte[] dataBuffer = ("abc").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");

&nbsp;&nbsp;&nbsp; <b>byte[] theDigest = digestIt(dataBuffer);</b><br><br><b>Listing 17</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>If you compare Listing 17 with the code in Listings 1, 2, and 3, you will see that they are very similar.&nbsp; Both programs create a very short message consisting of the string &quot;abc&quot; and pass the message to a method named <b>digestIt</b> for computation of the message digest.</p><p><font color="#FF0000"><b>So, what is the difference?</b></font></p><p>The big difference between the two programs lies in the implementation of the method named <b>digestIt</b>.&nbsp; That method has the same purpose in both programs.&nbsp; The purpose is to produce an SHA-1 message digest for a message that is passed to the method.</p><p>You will recall that the <b>digestIt</b> method, plus several methods that it called represented most of the code in the program named <b>Sha03</b>.&nbsp; On the other hand, the method named <b>digestIt </b>is fairly short in this program.</p><p><font color="#FF0000"><b>The digestIt method</b></font></p><p>The method named <b>digestIt</b> in the program named <b>Sha01</b> begins in Listing 18.&nbsp; This method computes and returns a message digest for an incoming array of bytes using Sun's SHA message digest algorithm.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>
&nbsp; static byte[] digestIt(byte[] dataIn){
&nbsp;&nbsp;&nbsp; byte[] theDigest = null;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDigest messageDigest =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDigest.getInstance("SHA","SUN");<br><br><b>Listing 18</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>The method named <b>digestIt</b> begins by invoking a factory method of the<b> MessageDigest</b> class named <b>getInstance</b> to create<b> </b>a <b>MessageDigest</b> object that implements Sun's SHA algorithm.</p><blockquote><p><i>(As an aside, if you were to substitute MD5 for SHA in Listing 18, this program would produce message digests using Sun's version of the MD5 hash function.)</i></p></blockquote><p><font color="#FF0000"><b>What does Sun have to say?</b></font></p><p>Here is some of what Sun has to say about the <b>MessageDigest</b> class.</p><blockquote><p><i>&quot;This <b>MessageDigest</b> class provides applications the functionality of a message digest algorithm, such as MD5 or SHA. Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value. </i></p><p><i>A <b>MessageDigest</b> object starts out initialized. The data is processed through it using the <b>update</b> methods. At any point <b>reset</b> can be called to reset the digest. Once all the data to be updated has been updated, one of the <b>digest</b> methods should be called to complete the hash computation.&quot;</i></p></blockquote><p><font color="#FF0000"><b>Feed the digester</b></font></p><p>Listing 19 feeds the digester by invoking the <b>update</b> method on the digester object passing the array of message bytes as a parameter.&nbsp; Multiple <b>update</b> calls could be made if necessary to feed an entire message to the digester.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; messageDigest.update(dataIn);
<br><b>Listing 19</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>Complete the digestion</b></font></p><p>Listing 20 causes the digestion to be completed by invoking the <b>digest</b> method on the digester object.&nbsp; The <b>digest</b> method returns the message digest to the calling program as an array of bytes.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theDigest = messageDigest.digest();
&nbsp;&nbsp;&nbsp; }catch(Exception e){System.out.println(e);}

&nbsp;&nbsp;&nbsp; //Return the digest value to the calling
&nbsp;&nbsp;&nbsp; // method as an array of bytes.
&nbsp;&nbsp;&nbsp; return theDigest;
&nbsp; }//end digestIt()<br><br><b>Listing 20</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>Then the code in Listing 20 returns the message digest to the program from which the <b>digestIt</b> method was called, signaling the end of the <b>digestIt</b> method.</p><p><font color="#FF0000"><b>Return to the main method</b></font></p><p>Returning now to the discussion of the <b>main</b> method, the code in Listing 21 invokes the method named <b>byteArrayToHexStr</b> to display the message digest shown in line 4 of Figure 2. </p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>//Back in the main method
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));<br><br><b>Listing 21</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p><font color="#FF0000"><b>The byteArrayToHexStr method</b></font></p><p>This method converts an incoming array of bytes into a string that represents each of the bytes as two hexadecimal characters.&nbsp; The code in this method is straightforward and doesn't warrant a detailed discussion.&nbsp; You can view the method in its entirety in Listing 24 near the end of the lesson.</p><p><font color="#FF0000"><b>Continuing with the main method</b></font></p><p>The remainder of the <b>main</b> method is shown in Listing 22.&nbsp; This code produces and displays message digests for two more messages, identical to the last two messages processed earlier in the program named <b>Sha03</b>.</p><p>The code in Listing 22 produces output that exactly matches the output produced by the program named <b>Sha03</b> shown in line 5 through line 10 in Figure 2.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 400 bits, which is still less
&nbsp;&nbsp;&nbsp; // than&nbsp; the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 520 bits, which is greater than
&nbsp;&nbsp;&nbsp; // the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567f\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "012g\n").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));
&nbsp;&nbsp;&nbsp;
&nbsp; }//end main<br><br><b>Listing 22</b></pre></td></tr></tbody></table><p></p>
<p></p>
<p>That concludes the discussion of the program named <b>Sha01</b>.</p><h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2><p>I encourage you to copy, compile and run the following programs that
are provided in this lesson:</p><ul>
  <li>Sha03</li><li>Sha01</li></ul><p>Experiment with the programs, making changes and observing the
results of your changes.</p><p>Above all, have fun and use these programs to learn as much as you
can about the theory behind and the mechanics of message digests as implemented using Java.</p><h2 align="center"><a name="Summary">Summary</a></h2><p>In this lesson, I showed you how to write Java code to implement the SHA-1 algorithm as defined in <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">FIPS Pub 180-2</a> and how to produce message digests using that code.&nbsp; I also showed you how to use Sun's <b>MessageDigest</b> class to produce message digests for both the SHA-1 and MD5 algorithms.</p><h2 align="center"><a name="Whats Next">What's Next?</a></h2><p>The previous lesson entitled <a href="http://www.developer.com/java/web/article.php/3469641">Digital Signatures 101 using Java</a> showed you how to use public-key cryptography to sign messages using digital signatures.&nbsp; This lesson showed you how to create message digests.&nbsp; The next lesson in this series will show you how to combine method digests with public-key cryptography to implement an improved way to sign messages using digital signatures.</p><h2 align="center"><a name="Complete_Program_Listings">Complete Program
Listings</a></h2><p>Complete listings of the programs discussed in this lesson are provided in Listing 23 and Listing 24 below.&nbsp; </p><p><font color="#ff0000"><b>A disclaimer</b></font></p><p>The programs that I am providing and explaining in this series of
lessons are not intended to be used for production cryptography.&nbsp;
If you need to do cryptography using Java, you should use <a
 href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Sun's
Java Cryptography Extension <i>(JCE)</i></a><i>.</i></p><p>The programs that I am providing were developed solely for
instructional purposes.&nbsp; They are intended to help you to
experiment with and to learn about various cryptographic and secure hash algorithms and
to gain a better understanding of how they work, and why they do what
they do.</p><table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sha03.java Copyright 2005, R.G.Baldwin
Rev 1/11/05

This program implements the SHA-1 secure hash
algorithm as defined at:
http://csrc.nist.gov/publications/fips/fips180-2/
fips180-2withchangenotice.pdf

Also see page 67 of the book entitled
Fundamentals of Secure Computer Systems
by Brett C. Tjaden.

The program tests the implementation, producing
an output that should exactly match the output
produced by the program named Sha01.

The program creates and displays the digests for
three different strings of 8-bit character data.
One of the strings is very short, consisting of
only three characters or 24 bits.

A second string consists of 400 bits.&nbsp;

The&nbsp; third string consists of 520 bits.&nbsp; The two
longer strings are used to confirm correct
operation across the magic 512-bit processing
boundary of the SHA-1 algorithm.

The results are displayed in hex format. The
digest is always 160 bits long.

Tested using JDK 1.5.0 and WinXP

This program produces the following output:
&nbsp;
Digests are displayed in hex format.
Data Length: 24 bit message.
Message Digest:
A9993E364706816ABA3E25717850C26C9CD0D89D
Data Length: 400 bit message.
Message Digest:
804AA5C1DE1C74C10C37F36327A12924B87DD3A7
Data Length: 520 bit message.
Message Digest:
E2220BDED2A3E23A44E883401042123A790AE21D
************************************************/

class Sha03 {

&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; Sha04 digester = new Sha04();
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Digests are displayed in hex format.");
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a very
&nbsp;&nbsp;&nbsp; // short message.
&nbsp;&nbsp;&nbsp; byte[] dataBuffer = ("abc").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; String theDigest = digester.digestIt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataBuffer);
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 400 bits, which is still less
&nbsp;&nbsp;&nbsp; // than&nbsp; the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digester.digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 520 bits, which is greater than
&nbsp;&nbsp;&nbsp; // the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567f\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "012g\n").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digester.digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; System.out.println(theDigest);

&nbsp; }//end main
}//end class Sha03
//=============================================//

//This class generates and returns a digest
// for an incoming array of bytes of arbitrary
// length.&nbsp; Invoke the instance method named
// digestIt on an object of the class to digest
// a message.
class Sha04{
&nbsp; String digestIt(byte[] dataIn){

&nbsp;&nbsp;&nbsp; //The algorithm consists of six major steps
&nbsp;&nbsp;&nbsp; // and a variety of minor steps.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Step 1:&nbsp; Pad the incoming data to guarantee
&nbsp;&nbsp;&nbsp; // that the message length is always an even
&nbsp;&nbsp;&nbsp; // multiple of 512 bits.
&nbsp;&nbsp;&nbsp; byte[] paddedData = padTheMessage(dataIn);

&nbsp;&nbsp;&nbsp; //Establish the initial values for the
&nbsp;&nbsp;&nbsp; // message digest.&nbsp; Use the variable names
&nbsp;&nbsp;&nbsp; // given in the book by Tjaden
&nbsp;&nbsp;&nbsp; int[] H = {0x67452301,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xEFCDAB89,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x98BADCFE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10325476,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xC3D2E1F0};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int[] K = new int[80];
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < 20;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x5A827999;
&nbsp;&nbsp;&nbsp; for(int cnt = 20;cnt < 40;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6ED9EBA1;
&nbsp;&nbsp;&nbsp; for(int cnt = 40;cnt < 60;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8F1BBCDC;
&nbsp;&nbsp;&nbsp; for(int cnt = 60;cnt < 80;cnt++) K[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xCA62C1D6;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Determine the number of passes required to
&nbsp;&nbsp;&nbsp; // process the padded data in blocks of 512
&nbsp;&nbsp;&nbsp; // bits (64 bytes) per pass..
&nbsp;&nbsp;&nbsp; if(paddedData.length % 64 != 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Invalid padded data length.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; int passesReq = paddedData.length/64;

&nbsp;&nbsp;&nbsp; //Outer loop to process each block of 64
&nbsp;&nbsp;&nbsp; // bytes or 512 bits
&nbsp;&nbsp;&nbsp; byte[] work = new byte[64];
&nbsp;&nbsp;&nbsp; for(int passCntr = 0;passCntr < passesReq;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passCntr++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Copy the next block of paddedData into
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the working array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(paddedData,64*passCntr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work, 0, 64);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Process the current block of 64 bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processTheBlock(work,H,K);
&nbsp;&nbsp;&nbsp; }//end for loop on passCntr

&nbsp;&nbsp;&nbsp; //Digestion is complete.
&nbsp;&nbsp;&nbsp; //Return the digest value to the calling
&nbsp;&nbsp;&nbsp; // method as a String.
&nbsp;&nbsp;&nbsp; return intArrayToHexStr(H);
&nbsp; }//end digestIt()
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //This method performs the required padding
&nbsp; // and returns the result as an array of bytes.
&nbsp; // The first bit in the pad must have a value
&nbsp; // of 1.&nbsp; The last 64 bits in the pad must be a
&nbsp; // binary representation of the length in bits
&nbsp; // of the original message.&nbsp; All other bits in
&nbsp; // the pad must have a value of 0.&nbsp; Note that
&nbsp; // this implementation of the padding procedure
&nbsp; // works correctly only for messages whose
&nbsp; // length is an even multiple of 8-bit bytes.
&nbsp; private byte[] padTheMessage(byte[] data){
&nbsp;&nbsp;&nbsp; int origLength = data.length;
&nbsp;&nbsp;&nbsp; int tailLength = origLength%64;
&nbsp;&nbsp;&nbsp; int padLength = 0;
&nbsp;&nbsp;&nbsp; if((64 - tailLength &gt;= 9))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padLength = 64 - tailLength;
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padLength = 128 - tailLength;

&nbsp;&nbsp;&nbsp; //Construct an array containing the bytes
&nbsp;&nbsp;&nbsp; // required to make the padded message length
&nbsp;&nbsp;&nbsp; // equal to an even multiple of 512 bits or
&nbsp;&nbsp;&nbsp; // 64 bytes.
&nbsp;&nbsp;&nbsp; byte[] thePad = new byte[padLength];
&nbsp;&nbsp;&nbsp; //Insert a single 1 bit in the pad
&nbsp;&nbsp;&nbsp; thePad[0] = (byte)0x80;
&nbsp;&nbsp;&nbsp; //Represent original bit length in 64 bits.
&nbsp;&nbsp;&nbsp; long lengthInBits = origLength * 8;
&nbsp;&nbsp;&nbsp; //Now break the long bit length into 8 bytes
&nbsp;&nbsp;&nbsp; // and deposit them at the end of thePad.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < 8;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thePad[thePad.length - 1 - cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)((lengthInBits >> (8 * cnt))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; & 0x00000000000000FF);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Create an output array.
&nbsp;&nbsp;&nbsp; byte[] output =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new byte[origLength + padLength];

&nbsp;&nbsp;&nbsp; //Populate the output array with the original
&nbsp;&nbsp;&nbsp; // data concatenated with the pad.
&nbsp;&nbsp;&nbsp; System.arraycopy(data,0,output,0,origLength);
&nbsp;&nbsp;&nbsp; System.arraycopy(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thePad,0,output,origLength,thePad.length);
&nbsp;&nbsp;&nbsp; return output;

&nbsp; }//end padTheMessage
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //This method processes a message block
&nbsp; // consisting of 512 bits (64 bytes) updating
&nbsp; // the ongoing calculation of the digest, which
&nbsp; // is stored in the array named H.
&nbsp; private void processTheBlock(byte[] work,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] H,int[] K){

&nbsp;&nbsp;&nbsp; //Step 2:&nbsp; Combine the incoming 64 bytes into
&nbsp;&nbsp;&nbsp; // the first 16 elements of an 80-element
&nbsp;&nbsp;&nbsp; // array of 32-bit data.
&nbsp;&nbsp;&nbsp; int[] W = new int[80];
&nbsp;&nbsp;&nbsp; for(int outer = 0;outer < 16;outer++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int inner = 0;inner < 4; inner++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = (work[outer * 4 + inner]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; & 0x000000FF) << (24 - inner * 8);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W[outer] = W[outer] | temp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp; }//end outer loop

&nbsp;&nbsp;&nbsp; //Step 3:&nbsp; First 16 elements of W contain 64
&nbsp;&nbsp;&nbsp; // bytes of message data.&nbsp; Use this data to
&nbsp;&nbsp;&nbsp; // populate the remaining 64 elements in W.
&nbsp;&nbsp;&nbsp; // Note the use of the XOR operator ^.
&nbsp;&nbsp;&nbsp; for(int j = 16; j < 80; j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp = W[j-3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-8];//XOR operator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-14];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp ^ W[j-16];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = Integer.rotateLeft(temp,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W[j] = temp;
&nbsp;&nbsp;&nbsp; }//end for loop on j

&nbsp;&nbsp;&nbsp; //Step 4:&nbsp; Create values for A through E
&nbsp;&nbsp;&nbsp; // based on the current intermediate value of
&nbsp;&nbsp;&nbsp; // the digest.
&nbsp;&nbsp;&nbsp; int A = H[0];
&nbsp;&nbsp;&nbsp; int B = H[1];
&nbsp;&nbsp;&nbsp; int C = H[2];
&nbsp;&nbsp;&nbsp; int D = H[3];
&nbsp;&nbsp;&nbsp; int E = H[4];

&nbsp;&nbsp;&nbsp; //Step 5:&nbsp; Apply four different processes to
&nbsp;&nbsp;&nbsp; // the data in the W array.&nbsp; A different
&nbsp;&nbsp;&nbsp; // process is applied to each successive
&nbsp;&nbsp;&nbsp; // group of 20 values of W.&nbsp; The difference
&nbsp;&nbsp;&nbsp; // lies in the behavior of the functions
&nbsp;&nbsp;&nbsp; // named f0_19, f20_39, etc. Otherwise, the
&nbsp;&nbsp;&nbsp; // processes are the same for each group of
&nbsp;&nbsp;&nbsp; // 20 values.&nbsp; Note that the method named
&nbsp;&nbsp;&nbsp; // uAdd performs unsigned addition of two
&nbsp;&nbsp;&nbsp; // 32-bit integer parameters that are passed
&nbsp;&nbsp;&nbsp; // to the method.&nbsp; The use of such a method
&nbsp;&nbsp;&nbsp; // is necessary because Java does not have an
&nbsp;&nbsp;&nbsp; // unsigned addition operator.
&nbsp;&nbsp;&nbsp; int temp;
&nbsp;&nbsp;&nbsp; for(int j = 0;j < 20;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),f0_19(B,C,D));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for(int j = 20;j < 40;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),f20_39(B,C,D));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for(int j = 40;j < 60;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),f40_59(B,C,D));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for(int j = 60;j < 80;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer.rotateLeft(A,5),f60_79(B,C,D));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,E);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,W[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = uAdd(temp,K[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E = D;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = Integer.rotateLeft(B,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = temp;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Step 6:&nbsp; Update the current value of the
&nbsp;&nbsp;&nbsp; // digest stored in the H array.
&nbsp;&nbsp;&nbsp; H[0] += A;
&nbsp;&nbsp;&nbsp; H[1] += B;
&nbsp;&nbsp;&nbsp; H[2] += C;
&nbsp;&nbsp;&nbsp; H[3] += D;
&nbsp;&nbsp;&nbsp; H[4] += E;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return from processing this block with
&nbsp;&nbsp;&nbsp; // the updated values of the digest in H.
&nbsp; }//end processTheBlock
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //This method performs an unsigned addition of
&nbsp; // two 32-bit int values by treating them as
&nbsp; // 32-bit unsigned values in the lower 32 bits
&nbsp; // of a long.&nbsp; Any overflow into the 33rd bit
&nbsp; // is discarded upon return when the long
&nbsp; // result is converted back to an int.&nbsp; The use
&nbsp; // of this method is required because Java does
&nbsp; // not have an unsigned addition operator.
&nbsp; private int uAdd(int a,int b){
&nbsp;&nbsp;&nbsp; long x = a;
&nbsp;&nbsp;&nbsp; //Eliminate sign extension, if any using a
&nbsp;&nbsp;&nbsp; // left shift followed by an unsigned right
&nbsp;&nbsp;&nbsp; // shift.
&nbsp;&nbsp;&nbsp; x = (x << 32) >>> 32;
&nbsp;&nbsp;&nbsp; long y = b;
&nbsp;&nbsp;&nbsp; y = (y << 32) >>> 32;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return (int)(x + y);
&nbsp; }//end unsignedAdd
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //The following four functions are defined in
&nbsp; // FIPS 180-2, Section 4.1.1, and also by
&nbsp; // Tjaden on pages 69 and 70.&nbsp; Note that these
&nbsp; // are all bitwise logical operations.&nbsp; Note
&nbsp; // also that there is a disagreement between
&nbsp; // the use of an inclusive bitwise or (|)
&nbsp; // and an exclusive bitwise or (^) between
&nbsp; // Tjaden and FIPS 180-2 in the first and
&nbsp; // third functions.&nbsp; However, both
&nbsp; // formulations produce the same digest for the
&nbsp; // test cases used in the program named Sha03.
&nbsp; // These functions use the FIPS 180-2 version.
&nbsp; // The Tjaden version is shown in comments.
&nbsp;
&nbsp; private int f0_19(int B,int C,int D){
&nbsp;&nbsp;&nbsp; //return (B & C) | ((~B)& D);//Tjaden version
&nbsp;&nbsp;&nbsp; return (B & C) ^ ((~B)& D);
&nbsp; }
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; private int f20_39(int B,int C,int D){
&nbsp;&nbsp;&nbsp; return ((B ^ C) ^ D);
&nbsp; }
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; private int f40_59(int B,int C,int D){
&nbsp;&nbsp;&nbsp; //return ((B & C) | (B & D) | (C & D));
&nbsp;&nbsp;&nbsp; return ((B & C) ^ (B & D) ^ (C & D));
&nbsp; }
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; private int f60_79(int B,int C,int D){
&nbsp;&nbsp;&nbsp; return ((B ^ C) ^ D);
&nbsp; }
&nbsp; //-------------------------------------------//

&nbsp; //This utility method converts an incoming
&nbsp; // array of ints into a string that represents
&nbsp; // each of the ints as eight hex characters,
&nbsp; // including leading zeros if necessary.
&nbsp; private String intArrayToHexStr(int[] data){
&nbsp;&nbsp;&nbsp; String output = "";
&nbsp;&nbsp;&nbsp; String tempStr = "";
&nbsp;&nbsp;&nbsp; int tempInt = 0;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < data.length;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempInt = data[cnt];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get hex representation of the int as a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // string.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = Integer.toHexString(tempInt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Append leading zeros if necessary so that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // each hex string will contain eight
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // characters.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tempStr.length() == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "0000000" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "000000" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 3)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "00000" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 4)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "0000" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 5)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "000" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 6)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "00" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(tempStr.length() == 7)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "0" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = output + tempStr;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return output.toUpperCase();
&nbsp; }//end intArrayToHexStr
&nbsp; //-------------------------------------------//
&nbsp;
}//end class Sha04

<br><b>Listing 23</b></pre></td></tr></tbody></table><p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>/*File Sha01.java Copyright 2005, R.G.Baldwin
Rev 1/17/05

This program implements Sun's SHA algorithm and
serves as the baseline for confirming the
correctness of my own version of the SHA-1
algorithm in the program named Sha03.

The program creates and displays the digests for
three different strings of 8-bit character data.
One of the strings is very short, consisting of
only three characters or 24 bits.

A second string consists of 400 bits.&nbsp;

The&nbsp; third string consists of 520 bits.&nbsp; The two
longer strings are used to confirm correct
operation across the magic 512-bit processing
boundary of the SHA-1 algorithm.

The results are displayed in hex format. The
digest is always 160 bits long.

Tested using JDK 1.5.0 and WinXP

This program produces the following output:
&nbsp;
Digests are displayed in hex format.
Data Length: 24 bit message.
Message Digest:
A9993E364706816ABA3E25717850C26C9CD0D89D
Data Length: 400 bit message.
Message Digest:
804AA5C1DE1C74C10C37F36327A12924B87DD3A7
Data Length: 520 bit message.
Message Digest:
E2220BDED2A3E23A44E883401042123A790AE21D
************************************************/

import java.security.*;

class Sha01 {
&nbsp; public static void main(String[] args) {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Digests are displayed in hex format.");
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a very
&nbsp;&nbsp;&nbsp; // short message.
&nbsp;&nbsp;&nbsp; byte[] dataBuffer = ("abc").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; byte[] theDigest = digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 400 bits, which is still less
&nbsp;&nbsp;&nbsp; // than&nbsp; the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Digest and display the digest for a longer
&nbsp;&nbsp;&nbsp; // message of 520 bits, which is greater than
&nbsp;&nbsp;&nbsp; // the crossover point of 512 bits.
&nbsp;&nbsp;&nbsp; dataBuffer = ("01234567a\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567b\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567c\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567d\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567e\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "01234567f\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "012g\n").getBytes();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Data Length: " + dataBuffer.length * 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " bit message.");
&nbsp;&nbsp;&nbsp; System.out.println("Message Digest:");
&nbsp;&nbsp;&nbsp; theDigest = digestIt(dataBuffer);
&nbsp;&nbsp;&nbsp; //Display the digest in hex format
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byteArrayToHexStr(theDigest));
&nbsp;&nbsp;&nbsp;
&nbsp; }//end main
&nbsp; //-------------------------------------------//

&nbsp; //This method generates and returns a digest
&nbsp; // for an incoming array of bytes using Sun's
&nbsp; // SHA message digest algorithm..
&nbsp; static byte[] digestIt(byte[] dataIn){
&nbsp;&nbsp;&nbsp; byte[] theDigest = null;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create a MessageDigest object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // implementing the SHA algorithm, as
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // supplied by SUN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDigest messageDigest =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDigest.getInstance("SHA", "SUN");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Feed the byte array to the digester.&nbsp; Can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accommodate multiple calls if needed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; messageDigest.update(dataIn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Complete the digestion and save the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theDigest = messageDigest.digest();
&nbsp;&nbsp;&nbsp; }catch(Exception e){System.out.println(e);}

&nbsp;&nbsp;&nbsp; //Return the digest value to the calling
&nbsp;&nbsp;&nbsp; // method as an array of bytes.
&nbsp;&nbsp;&nbsp; return theDigest;
&nbsp; }//end digestIt()
&nbsp; //-------------------------------------------//

&nbsp; //This method converts an incoming array of
&nbsp; // bytes into a string that represents each of
&nbsp; // the bytes as two hex characters.
&nbsp; static String byteArrayToHexStr(byte[] data){
&nbsp;&nbsp;&nbsp; String output = "";
&nbsp;&nbsp;&nbsp; String tempStr = "";
&nbsp;&nbsp;&nbsp; int tempInt = 0;
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < data.length;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Deposit a byte into the 8 lsb of an int.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempInt = data[cnt]&0xFF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get hex representation of the int as a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // string.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = Integer.toHexString(tempInt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Append a leading 0 if necessary so that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // each hex string will contain two
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // characters.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tempStr.length() == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempStr = "0" + tempStr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Concatenate the two characters to the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // output string.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = output + tempStr;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return output.toUpperCase();
&nbsp; }//end byteArrayToHexStr
&nbsp; //-------------------------------------------//
}//end class Sha01
<br><br><b>Listing 24</b></pre></td></tr></tbody></table></p><p></p>
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About_the_author">About the author</a></h4><b><a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and
XML. In addition to the many platform and/or language independent
benefits
of Java and C# applications, he believes that a combination of Java,
C#,
and XML will become the primary driving force in the delivery of
structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years
of practical experience in Digital Signal Processing (DSP).&nbsp; His
first job after he earned his Bachelor's degree was doing DSP in the
Seismic Research Department of Texas Instruments.&nbsp; (TI is still a
world leader in DSP.)&nbsp; In the following years, he applied his
programming and DSP expertise to other interesting areas including
sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology
to real-world problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</body>
</html>
