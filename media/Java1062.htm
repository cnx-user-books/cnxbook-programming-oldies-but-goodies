<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#999999" alink="#FF0000" lang="EN-US">

<h2>
Swing from A to Z:&nbsp; Analyzing Swing Components, Part 2, GUI Setup</h2>
<i>In the previous lesson, Baldwin introduced you to a very useful program
that displays information about any Java component, including inheritance,
interfaces, properties, events, and methods.&nbsp; In this lesson, Baldwin
explains how the GUI for this program is set up using JFrame, JPanel, JTextArea,
JScrollPane, JTextField, JButton, and JLabel components.</i>
<p><b>Published</b>&nbsp; February 19, 2001
<br><b>By <a href="mailto:baldwin.richard@iname.com">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1062
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Sample Program">Sample Program</a></li>

<li>
<a href="#Interesting Code Fragments">Interesting Code Fragments</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This series of lessons entitled <i>Swing from A to Z</i>, discusses the
capabilities and features of Swing in quite a lot of detail.&nbsp; This
series is intended for those persons who need to understand Swing at a
detailed level.
<p>This is the second lesson in a miniseries discussing the use of introspection
for analyzing Swing components.&nbsp; The first lesson in this miniseries
was entitled <i>Swing from A to Z:&nbsp; Analyzing Swing Components, Part
1, Concepts</i>.&nbsp; You will find&nbsp; links to all of the lessons
in the miniseries at the following <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">site</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Recommended supplementary reading</font></b>
<p>In an earlier lesson entitled <i>Alignment Properties and BoxLayout,
Part 1</i>, I recommended a list of Swing tutorials for you to study prior
to embarking on a study of this series of lessons.
<p>The lessons identified on that list will introduce you to the use of
Swing while avoiding much of the detail included in this series.
<p><b><font color="#FF0000">Where are the lessons located?</font></b>
<p>You will find those lessons published at <a href="http://gamelan.earthweb.com/dlink.index-jhtml.72.1082.-.43.jhtml">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes my lessons are difficult
to locate there.&nbsp; You will find a consolidated index at
<i>Baldwin's
Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a></i><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at Gamelan.com.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Documentation is required</font></b>
<p><font color="#000000">You will need access to lots of documentation
when programming in Java.&nbsp; The standard Sun documentation contains
a voluminous amount of information and is very useful.&nbsp; This lesson
discusses a Java program that is also very useful from a documentation
viewpoint.&nbsp; The program described in this lesson is intended to be
used as a supplement to the Sun documentation.</font>
<p><b><font color="#FF0000">A streamlined approach</font></b>
<p><font color="#000000">Sometimes you need something a little more streamlined
than the large Sun documentation package.&nbsp; In this miniseries, I will
show you how to write a Java program that provides almost instantaneous
information about Swing and AWT components at the click of a button.&nbsp;
The program displays:</font>
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<b><font color="#FF0000">Customization is possible</font></b>
<p><font color="#000000">After studying the lessons in this miniseries,
you should be able to customize the program to provide more or less information,
in the same or different formats.</font>
<p><b><font color="#FF0000">Introspection</font></b>
<p><font color="#000000">Java provides a capability, known as introspection,
which can be used to extract information about a class that qualifies as
a <i>JavaBean Component</i>.&nbsp; Fortunately, this includes all of the
<b>Swing</b>
components and all of the <b>AWT</b> components.&nbsp; It also includes
many of the other classes in the standard library as well.</font>
<p><b><font color="#FF0000">Program output</font></b>
<p><font color="#000000">Figure 1 is a screen shot showing the program
output after you start the program and click the <b>OK</b> button.</font>
<center>
<p><img SRC="java1062a.gif" height=521 width=400>
<br><b><font color="#000000">Figure 1.&nbsp; Screen shot showing program
output.</font></b></center>

<p><font color="#000000">You specify the target component to be analyzed
by entering its package and class name in the text field at the lower left.&nbsp;
The program displays five kinds of information for the class specified
in that text field in scrollable panels.</font>
<p><font color="#000000">Error messages are displayed in the gray panel
at the top of the GUI.</font>
<p><b><font color="#FF0000">The ceiling class</font></b>
<p><font color="#000000">A ceiling class is entered in the text field at
the bottom right.&nbsp; The program uses the ceiling class to determine
how much of the inheritance hierarchy to consider when determining properties,
events, and methods for the target class.</font>
<p><b><font color="#FF0000">Analysis of a JButton component</font></b>
<p><font color="#000000">The screen shot of Figure 1 displays information
about a <b>JButton</b> component, using all of the superclasses up to,
but not including the <b>Object</b> class.</font>
<p><font color="#000000">In this lesson, I will provide quite a lot of
background information on introspection, and will walk you through initial
code up to, but not including the constructor for the program.</font>
<p><font color="#000000">Along the way, I will discuss how to combine and
use objects of the <b>JTextArea</b> and <b>JScrollPane</b> classes.&nbsp;
These are the rectangular white panes showing in the green area of the
GUI in Figure 1.</font>
<p><font color="#000000">I will discuss the constructor in the next lesson.&nbsp;
Subsequent lessons will explain other material in the program.</font>
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
<b><font color="#FF0000">The Class class</font></b>
<p><font color="#000000">JDK 1.3 includes the following class:</font>
<p><b><font color="#000000">java.lang.Class</font></b>
<p><font color="#000000">An object of the class whose name is <b>Class</b>
represents another class or interface.&nbsp; The object can be used to
learn many things about the class that the object represents.</font>
<p><b><font color="#FF0000">Getting superclass and interfaces</font></b>
<p><font color="#000000">Among other things, the object can be used to
determine the superclass of the class that the object represents, as well
as the interfaces implemented by the class that the object represents.&nbsp;
Those two capabilities will be used in developing the program discussed
in this lesson.</font>
<p><b><font color="#FF0000">The Introspector class</font></b>
<p>JDK 1.3 also includes the following class:
<p><b>java.beans.Introspector</b>
<p>The <b>Introspector</b> class, intended primarily for use with JavaBean
Components, provides a way for tools to learn about the <i>properties</i>,
<i>events</i>, and
<i>methods</i> of a target bean's class.&nbsp; Of course,
this includes those properties, events, and methods that the target class
inherits from its superclasses.
<p>As mentioned earlier, all Swing and AWT components are beans, making
them suitable for analysis by introspection.
<p><b><font color="#FF0000">getBeanInfo</font></b>
<p>The <b>Introspector </b>class provides three overloaded versions of
a method named <b>getBeanInfo</b>.&nbsp; Each of these methods accepts
a <b>Class</b> object representing the target bean as an input parameter.
<i>(Two
of the versions accept other incoming parameters as well.)</i>
<p>This method can be used to analyze the target bean's class and superclasses
looking for information about properties, events, and methods.&nbsp; <i>(This
process is discussed in detail in my tutorial lessons on JavaBean Components.&nbsp;
You will find a consolidated index to those lessons at my <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">web
site</a>.)</i>
<p><b><font color="#FF0000">The BeanInfo object</font></b>
<p>The information discovered through introspection is used to build and
return an object of the type <b>BeanInfo</b>.&nbsp; The <b>BeanInfo</b>
object contains even more information about the target bean than is provided
by the <b>Class</b> object that forms its seed.
<p>The <b>BeanInfo</b> interface declares a variety of methods that can
be used to extract specific information about the bean from that object.
<p><b><font color="#FF0000">Performing the analysis</font></b>
<p>The <b>getBeanInfo()</b> method is the primary method of the <b>Introspector
</b>class
used to analyze a bean.&nbsp; The program developed in this lesson will
use one of the three overloaded versions of this method.&nbsp; Simply put,
this method takes a <b>Class </b>object (representing a target class) as
a parameter and returns a <b>BeanInfo </b>object containing information
about the target class.
<p><b><font color="#FF0000">The ceiling class</font></b>
<p>The overloaded version of <b>getBeanInfo</b> used in this lesson accepts
a second <b>Class </b>object as a parameter.&nbsp; It uses the class represented
by that object as a ceiling for introspection up the inheritance hierarchy.
Information is returned taking into account all the superclasses up to,
but not including the ceiling class.
<p>For example, if this second class is the direct superclass of the primary
target class, only information about the primary target class is returned.
<center>
<h2>
<a NAME="Sample Program"></a><font color="#000000">Sample Program</font></h2></center>
A complete listing of this program, named <b>Introspect03</b> is provided
near the end of the lesson.&nbsp; It is provided here so that you can copy,
compile, and begin using it even before you have an opportunity to learn
how it all works.
<center>
<h2>
<a NAME="Interesting Code Fragments"></a><font color="#000000">Interesting
Code Fragments</font></h2></center>
I will break this program down and discuss it in fragments.
<p><b><font color="#FF0000">The controlling class</font></b>
<p><font color="#000000">Listing 1 shows the declaration for the controlling
class.&nbsp; As you can see, the class extends <b>JFrame</b>.&nbsp; Therefore,
an object of the controlling class is a <b>JFrame</b> object, and is the
GUI for the program.</font>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">public class <b>Introspect03</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extends <b>JFrame</b>{

<b>Listing 1</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Major GUI panels</font></b>
<p>Listing 2 begins the declaration of a long series of instance variables
of the controlling class.&nbsp; This listing shows the major panels that
will be contained in the North, Center, and South positions of the <b>JFrame</b>
GUI object.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private JLabel <b>errors</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JLabel("Errors appear here");

&nbsp; private JPanel <b>outputPanel</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JPanel <b>inputPanel</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();

<b>Listing 2</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">errors</font></b>
<p>The <b>JLabel</b> object referred to by <b>errors</b> in listing 2 will
be used to display any error messages produced by the program.&nbsp; This
output appears near the top of the GUI in Figure 1.
<p><b><font color="#FF0000">outputPanel</font></b>
<p>The <b>JPanel</b> object referred to by <b>outputPanel</b> will be used
as a container for five <b>JScrollPane</b> objects used to display the
desired information about the target component.&nbsp; This panel appears
in the center of the GUI in Figure 1.
<p><b><font color="#FF0000">inputPanel</font></b>
<p>The <b>JPanel</b> object referred to by <b>inputPanel</b> will be used
as a container for two <b>JTextField</b> objects and one <b>JButton</b>
object, appearing at the bottom of the GUI.&nbsp; These three components
are used for user input to the program.
<p><b><font color="#FF0000">The input components</font></b>
<p>Listing 3 shows the three input components that will be contained by
the <b>JPanel</b> object at the bottom of the GUI.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private JTextField <b>targetClass</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JTextField <b>ceilingClass</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JButton <b>okButton</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("OK");
&nbsp;&nbsp;
<b>Listing 3</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">targetClass</font></b>
<p>The <b>JTextField</b> object referred to by <b>targetClass</b> is used
to collect user input.&nbsp; This is where the user enters the package
and class name for the component of interest.&nbsp; <i>Note that the user
must enter a fully-qualified package and class name unless the class file
is located in the directory from which the program is being executed.</i>
<p><b><font color="#FF0000">ceilingClass</font></b>
<p>The <b>JTextField</b> object referred to by <b>ceilingClass</b> is also
used to collect user input.&nbsp; This is where the user enters the package
and class name for an analysis ceiling.&nbsp; The program will take into
account all superclasses up to, but not including the ceiling class when
reporting properties, events, and methods.&nbsp; In other words, properties,
events, and methods inherited from and above the ceiling class will not
be reflected in the program output.
<p><b><font color="#FF0000">okButton</font></b>
<p>As you have probably already guessed, after entering the requisite package
and class names in the two text fields, the user clicks the <b>JButton</b>
referred to by <b>okButton</b> to cause the program to compute and display
a new set of results.
<p><b><font color="#FF0000">The output components</font></b>
<p>Listing 4 shows the code that instantiates the first of the five output
components that appear in the green area of the GUI in Figure 1.&nbsp;
This object appears in the upper-left corner of the green area.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private JTextArea <b>inher</b> = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INHERITANCE\n",8,17);
&nbsp; private JScrollPane <b>inherPane</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(<b>inher</b>);

<b>Listing 4</b></font></pre>
</td>
</tr>
</table>

<p>This component consists of a combination of a <b>JTextArea</b> object
and a <b>JScrollPane</b> object.
<p><b><font color="#FF0000">JTextArea</font></b>
<p>A <b>JTextArea</b> object is a multi-line area that displays plain text.&nbsp;
Unlike <b>java.awt.TextArea</b>, a <b>JTextArea</b> component doesn't manage
scrolling.&nbsp; <i>(Thus, an object of this class is not a direct functional
replacement for an AWT TextArea object.)</i>
<p>If you need scrolling capability for a <b>JTextArea</b> object, <i>which
we do in this program</i>, you need to place it inside of a <b>JScrollPane</b>
object.
<p>The <b>JTextArea</b> class has several constructors.&nbsp; The constructor
used in Listing 4 causes the object to display an initial text value of
<b>INHERITANCE</b>
followed by a newline.
<p><b><font color="#FF0000">Size of JTextArea objects</font></b>
<p>The same version of the constructor was used for all five of the <b>JTextArea</b>
objects in the green area of Figure 1.&nbsp; The parameters passed to the
constructors caused the preferred size of each object to accommodate 8
rows of text and 17 columns of text.
<p>If you examine the GUI in Figure 1, you will see that each <b>JTextArea</b>
object does accommodate 8 rows.&nbsp; However, since the widths of the
characters differ in the display font used, the specification for the number
of columns did not match the number of characters displayed horizontally.
<p><i>(You may also notice that when a horizontal scroll bar appears, it
consumes one of the available rows.)</i>
<p><b><font color="#FF0000">JScrollPane</font></b>
<p>A <b>JScrollPane</b> object provides a scrollable view of a component.
<i>(In
this case, it provides a scrollable view of a JTextArea component, but
JScrollPane can be used with many different kinds of objects.)</i>
<p>A <b>JScrollPane</b> object manages a viewport, optional vertical and
horizontal scroll bars, and optional row and column heading viewports.
<i>(In
this case, I didn't make use of the latter option.)</i>
<p><b><font color="#FF0000">JScrollPane Constructors</font></b>
<p><b>JScrollPane</b> has several constructors.&nbsp; I elected to use
a&nbsp; constructor that is defined as shown in Listing 5:
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td BGCOLOR="#66FFFF">
<pre><b><font face="Courier New,Courier">JScrollPane(Component view)</font></b><font face="Courier New,Courier">&nbsp;
&nbsp;Creates a JScrollPane that displays
&nbsp;the contents of the specified
&nbsp;component, where both horizontal and
&nbsp;vertical scrollbars appear whenever
&nbsp;the component's contents are larger
&nbsp;than the view.

<b>Listing 5</b></font></pre>
</td>
</tr>
</table>

<p>In other words, I used a version of the constructor that accepts a reference
to my <b>JTextArea</b> object, and manages a viewport on that object with
scroll bars appearing when needed.
<p>As you can see in Listing 4 above, I passed a reference to the <b>JTextField</b>
object (<b>inher</b>) to the constructor for the new <b>JScrollPane</b>
object.
<p><b><font color="#FF0000">Additional output panes</font></b>
<p>Listing 6 shows the code that instantiates the remaining four output
panes.&nbsp; This code is essentially the same as that discussed above,
and won't be discussed further here.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private JTextArea <b>intfcs</b> = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INTERFACES\n",8,17);
&nbsp; private JScrollPane <b>intfcsPane</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(<b>intfcs</b>);
&nbsp; private JTextArea <b>props</b> = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("PROPERTIES\n",8,17);
&nbsp; private JScrollPane <b>propsPane</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(<b>props</b>);
&nbsp; private JTextArea <b>events</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("EVENTS\n",8,17);
&nbsp; private JScrollPane <b>eventsPane</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(<b>events</b>);
&nbsp; private JTextArea <b>methods</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("METHODS\n",8,17);
&nbsp; private JScrollPane <b>methodsPane</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(<b>methods</b>);
&nbsp;&nbsp;
<b>Listing 6</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Remaining instance variables</font></b>
<p>Listing 7 shows the two remaining instance variables declared in the
definition of the controlling class.&nbsp; I will defer a discussion of
the purpose of these two instance variables until later when I discuss
the code that uses them.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; private BeanInfo <b>beanInfo</b>;
&nbsp; private Vector <b>intfcsVector</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();

<b>Listing 7</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The main() method</font></b>
<p>Listing 8 shows the definition of the <b>main</b> method.&nbsp; As you
can see, the sole purpose of the <b>main</b> method is to instantiate an
object of the controlling class to serve as the GUI for the program.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; public static void <b>main</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){&nbsp;
&nbsp;&nbsp;&nbsp; <b>new Introspect03();
</b>&nbsp; }//end main

<b>Listing 8</b></font></pre>
</td>
</tr>
</table>

<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this and the previous lesson, I have introduced you to a very useful
program that can be used to quickly obtain information about the following
aspects of any Java class that qualifies as a JavaBean component:
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
I provided screen shots to show you how the program works in practice,
and I provided a complete listing of the program so that you can begin
using it.
<p>I have provided quite a lot of background information on Java introspection,
and have explained how introspection is used to achieve the objectives
of this program.
<p>I have walked you through the early portions of the code, explaining
the purpose of a large number of instance variables and the behavior of
the <b>main()</b> method.
<p><font color="#000000">Along the way, I discussed how to combine and
use objects of the <b>JTextArea</b> and <b>JScrollPane</b> classes.</font>
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
Several lessons will be required to provide a complete discussion of this
program.&nbsp; In the next lesson, I will explain the constructor for the
GUI used in this program.&nbsp; This will include examples of the use of
the <b>forName()</b> method of the <b>Class</b> class, and the <b>getBeanInfo()</b>
method of the <b>Introspector</b> class.
<p>Subsequent lessons will contain detailed discussions on how the objects
produced by these methods are used to achieve the objectives of the program.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing&nbsp;
9</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">/*File Introspect03.java&nbsp;
Copyright 2000, R.G.Baldwin

Produces a GUI that displays&nbsp;
inheritance, interfaces, properties,
events, and methods about components,
or about any class that is a bean.

Requires JDK 1.3 or later.&nbsp; Otherwise,
must service the windowClosing event&nbsp;
to terminate the program.
Tested using JDK 1.3 under WinNT.&nbsp;&nbsp;
**************************************/
import java.io.*;
import java.beans.*;
import java.lang.reflect.*;
import java.util.*;
import java.awt.Color;
import java.awt.event.*;
import javax.swing.*;

public class Introspect03&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extends JFrame{
&nbsp; private JLabel errors =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JLabel("Errors appear here");
&nbsp; private JPanel outputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JPanel inputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JTextField targetClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JTextField ceilingClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JButton okButton =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("OK");
&nbsp;&nbsp;
&nbsp; private JTextArea inher = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INHERITANCE\n",8,17);
&nbsp; private JScrollPane inherPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(inher);
&nbsp; private JTextArea intfcs = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INTERFACES\n",8,17);
&nbsp; private JScrollPane intfcsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(intfcs);
&nbsp; private JTextArea props = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("PROPERTIES\n",8,17);
&nbsp; private JScrollPane propsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(props);
&nbsp; private JTextArea events =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("EVENTS\n",8,17);
&nbsp; private JScrollPane eventsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(events);
&nbsp; private JTextArea methods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("METHODS\n",8,17);
&nbsp; private JScrollPane methodsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(methods);
&nbsp;&nbsp;
&nbsp; private BeanInfo beanInfo;
&nbsp; private Vector intfcsVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Introspect03();
&nbsp; }//end main
&nbsp;&nbsp;
&nbsp; public Introspect03() {//constructor
&nbsp;&nbsp;&nbsp; //This require JDK 1.3 or later.
&nbsp;&nbsp;&nbsp; // Otherwise service windowClosing
&nbsp;&nbsp;&nbsp; // event to terminate the program.
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFrame.EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; outputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.green);
&nbsp;&nbsp;&nbsp; inputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.yellow);

&nbsp;&nbsp;&nbsp; outputPanel.add(inherPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(intfcsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(propsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(eventsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(methodsPane);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Set some default values
&nbsp;&nbsp;&nbsp; targetClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "javax.swing.JButton");
&nbsp;&nbsp;&nbsp; ceilingClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");

&nbsp;&nbsp;&nbsp; inputPanel.add(targetClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(ceilingClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(okButton);

&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors,"North");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputPanel,"Center");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputPanel,"South");
&nbsp;&nbsp;&nbsp; setResizable(false);
&nbsp;&nbsp;&nbsp; setSize(400,520);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2000, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner class to provide
&nbsp;&nbsp;&nbsp; // event handler for okButton
&nbsp;&nbsp;&nbsp; okButton.addActionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ActionListener(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Errors appear here");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INHERITANCE\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INTERFACES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PROPERTIES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "EVENTS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.setText("METHODS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class targetClassObject =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInheritance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInterfaces();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBeanInfo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClassObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doProperties();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doEvents();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doMethods();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(Exception ex){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex.toString());}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end actionPerformed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ActionListener
&nbsp;&nbsp;&nbsp;&nbsp; );//end addActionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInheritance()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ClassNotFoundException{
&nbsp;&nbsp;&nbsp; //Get and display inheritance
&nbsp;&nbsp;&nbsp; // hierarchy
&nbsp;&nbsp;&nbsp; Vector inherVector = new Vector();
&nbsp;&nbsp;&nbsp; String theClass = targetClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText();
&nbsp;&nbsp;&nbsp; Class theClassObj = null;
&nbsp;&nbsp;&nbsp; Class theSuperClass = null;
&nbsp;&nbsp;&nbsp; while(!(theClass.equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object"))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.add(theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassObj = Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theSuperClass = theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSuperclass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and save interfaces to be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // used later
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theClassObj.getInterfaces()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcsVector.add(theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInterfaces());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = theSuperClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName();
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; inherVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display vector contents in
&nbsp;&nbsp;&nbsp; // reverse order
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; inherVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((String)inherVector.elementAt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.size() - (i+1))));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInheritance
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInterfaces(){
&nbsp;&nbsp;&nbsp; Vector interfaceNameVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;&nbsp; //Interface information was stored
&nbsp;&nbsp;&nbsp; // in intfcsVector earlier.
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; intfcsVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class[] interfaceSet =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Class[])intfcsVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elementAt(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; interfaceSet.length;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceSet[j].getName());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop on j
&nbsp;&nbsp;&nbsp; }//end for loop on i

&nbsp;&nbsp;&nbsp; Object[] interfaceNameArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(interfaceNameArray);

&nbsp;&nbsp;&nbsp; if(interfaceNameArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; interfaceNameArray.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup interface names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInterfaces
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doProperties(){
&nbsp;&nbsp;&nbsp; Vector propVector = new Vector();
&nbsp;&nbsp;&nbsp; PropertyDescriptor[] propDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropClass propObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PropClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setName(propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setType("" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propVector.add(propObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] propArray = propVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propArray,new PropClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append(propArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doProperties
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doEvents(){
&nbsp;&nbsp;&nbsp; Vector eventVector = new Vector();
&nbsp;&nbsp;&nbsp; EventSetDescriptor[] evSetDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEventSetDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; evSetDescrip.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventClass eventObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EventClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setName(evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getListenerMethodDescriptors();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; methDescrip.length; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[j].getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventVector.add(eventObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] eventArray = eventVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventArray,new EventClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; eventArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append(eventArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doEvents
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doMethods(){
&nbsp;&nbsp;&nbsp; Vector methVector = new Vector();
&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.getMethodDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[i].getName());
&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Object[] methodArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(methodArray);

&nbsp;&nbsp;&nbsp; if(methodArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[0].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methodArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup method names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(methodArray[i].equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doMethods
//===================================//

//This inner class is used to
// encapsulate name and type
// information about properties.&nbsp; It
// also serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class PropClass implements Comparator{
&nbsp; private String name;
&nbsp; private String type;
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setType(String type){
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return(name + "\n&nbsp; " + type);
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((PropClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)obj).getName());
&nbsp; }//end equals
}//end class PropClass
//===================================//

//This inner class is used to
// encapsulate name and handler
// information about events.&nbsp; It also
// serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class EventClass implements Comparator{
&nbsp; private String name;
&nbsp; private Vector lstnrMethods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String lstnrMethod){
&nbsp;&nbsp;&nbsp; lstnrMethods.add(lstnrMethod);
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; String theString = name;

&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; lstnrMethods.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theString = theString + "\n&nbsp; " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstnrMethods.elementAt(i);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; return theString;
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((EventClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)obj).getName());
&nbsp; }//end equals
}//end EventClass inner class
&nbsp;&nbsp;
}//end controlling class Introspect03

<b>Listing 9</b></font></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
