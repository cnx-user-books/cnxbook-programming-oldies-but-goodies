<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#999999" alink="#FF0000" lang="EN-US">

<h2>
Swing from A to Z:&nbsp; Analyzing Swing Components, Part 4, Inheritance</h2>
<i>Baldwin has previously introduced you to a very useful program that
displays information about any Java component, including inheritance, interfaces,
properties, events, and methods.&nbsp; In this lesson, Baldwin explains
the code that gets and displays inheritance information about a component.</i>
<p><b>Published:</b>&nbsp; April 16, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1066
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Sample Program">Sample Program</a></li>

<li>
<a href="#Interesting Code Fragments">Interesting Code Fragments</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This series of lessons entitled <i>Swing from A to Z</i>, discusses the
capabilities and features of Swing in quite a lot of detail.&nbsp; This
series is intended for those persons who need to understand Swing at a
detailed level.
<p>This is the fourth lesson in a miniseries discussing the use of introspection
for analyzing <b>Swing</b> components.&nbsp; The first lesson in this miniseries
was entitled <a href="Java1060.htm">Swing from A to Z:&nbsp; Analyzing
Swing Components, Part 1, Concepts</a>.&nbsp; You will find links to all
of the lessons in the miniseries at the following <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">web
site</a>.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Recommended supplementary reading</font></b>
<p>In an earlier lesson entitled <i>Alignment Properties and BoxLayout,
Part 1</i>, I recommended a list of Swing tutorials for you to study prior
to embarking on a study of this series of lessons.
<p>The lessons identified on that list will introduce you to the use of
Swing while avoiding much of the detail included in this series.
<p><b><font color="#FF0000">Where are the lessons located?</font></b>
<p>You will find those lessons published at <a href="http://gamelan.earthweb.com/dlink.index-jhtml.72.1082.-.43.jhtml">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes my lessons are difficult
to locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at Gamelan.com.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Streamlined Documentation</font></b>
<p><font color="#000000">The lessons in this miniseries discuss a very
useful Java program that serves as a supplement to the Sun documentation.</font>
<p><font color="#000000">I will show you how to write a Java program that
provides information about Swing and AWT components at the click of a button.&nbsp;
The program displays:</font>
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
<b><font color="#FF0000">Introspection</font></b>
<p><font color="#000000">Introspection can be used to extract information
about any class that qualifies as a <i>JavaBeans Component</i>.&nbsp; This
includes all of the
<b>Swing</b> and <b>AWT</b> components.&nbsp; It also
includes many of the other classes in the standard library as well.</font>
<p><b><font color="#FF0000">Program output</font></b>
<p><font color="#000000">Figure 1 is a screen shot showing the program
output after you start the program and click the <b>OK</b> button.</font>
<center>
<p><img SRC="java1066a.gif" height=521 width=400>
<br><b><font color="#000000">Figure 1.&nbsp; Screen shot showing program
output.</font></b></center>

<p><font color="#000000">The various parts of this GUI have been explained
in the earlier lessons in this miniseries.</font>
<p><b><font color="#FF0000">Analysis of a JButton component</font></b>
<p><font color="#000000">The screen shot of Figure 1 displays information
about a <b>JButton</b> component, using all of the superclasses except
the <b>Object</b> class.</font>
<p><font color="#000000">In the previous lessons, I have walked you through
the code for this program, up to, and including the constructor.&nbsp;
This included the instantiation of <b>Class</b> and <b>BeanInfo</b> objects
from which information about the target class can be obtained.</font>
<p><font color="#000000">In this lesson, I will discuss the code that gets
and displays the inheritance information shown in the top left-hand scroll
pane of Figure 1.</font>
<p><font color="#000000">Subsequent lessons will explain other aspects
of the program.</font>
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
<b><font color="#FF0000">The Class class and the Introspector class</font></b>
<p><font color="#000000">Previous lessons explained the use of the <b>Class</b>
class and the <b>Introspector</b> class to achieve the objectives of this
program.</font>
<p><font color="#000000">This included a discussion of the <b>forName()</b>
and <b>getBeanInfo()</b> methods.</font>
<p><b><font color="#FF0000">Superclasses and interfaces</font></b>
<p><font color="#000000">It was explained that information about the superclass
of a target class and the interfaces that it implements can be obtained
through use of a <b>Class</b> object that represents the target class.</font>
<p><font color="#000000">This lesson will use that fact to develop the
inheritance family tree for the target class.</font>
<p><b><font color="#FF0000">Properties, events, and methods</font></b>
<p><font color="#000000">Previous lessons also explained that an object
of the interface type <b>BeanInfo</b> can be used to obtain other important
information about the properties, events, and methods of a target class.</font>
<center>
<h2>
<a NAME="Sample Program"></a><font color="#000000">Sample Program</font></h2></center>
A complete listing of this program, named <b>Introspect03</b> is provided
near the end of the lesson.&nbsp; It is provided here so that you can copy,
compile, and begin using it even before you have an opportunity to learn
exactly how it works.
<center>
<h2>
<a NAME="Interesting Code Fragments"></a><font color="#000000">Interesting
Code Fragments</font></h2></center>
I will break this program down and discuss it in fragments.
<p>The previous lesson, entitled <a href="Java1064.htm">Swing from A to
Z:&nbsp; Analyzing Swing Components, Part 3, Construction</a> discussed
the constructor for this program.&nbsp; It explained the purpose of most
of the code in the constructor, including an anonymous inner class that
provides action event handling capability for the OK button in the lower
right-hand corner of Figure 1.
<p><b><font color="#FF0000">The actionPerformed() method</font></b>
<p>The code in Listing 1 is an abbreviated version of the <b>actionPerformed()</b>
method that was discussed in the previous lesson.&nbsp; Most of the code
has been deleted because it is not germane to this lesson.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void <b>actionPerformed</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>doInheritance</b>();

<b>Listing 1</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The doInheritance() method</font></b>
<p>The method named <b>doInheritance()</b> invoked by the <b>actionPerformed()</b>
method is the primary topic of this lesson.
<p>The purpose of the <b>doInheritance()</b> method is to obtain and display
the inheritance family tree beginning with the target class, and progressing
up the inheritance hierarchy to the class named <b>Object</b>.
<p><b><font color="#FF0000">Methodology</font></b>
<p>The approach used is to get and save the superclass of the target class.&nbsp;
Then use that superclass as a new target class and repeat the process until
the class named <b>Object</b> is encountered.
<p>The objective is to display the family tree beginning with the class
named <b>Object</b>, and ending with the original target class.&nbsp; All
of this information is saved in the process described above.&nbsp; The
information that has been saved is then displayed in the output scroll
pane in the reverse order from which it was saved.
<p><b><font color="#FF0000">The method signature</font></b>
<p>Listing 2 shows the beginning of the method named <b>doInheritance()</b>.&nbsp;
As you can see, the method throws a <b>ClassNotFoundException</b>.&nbsp;
Therefore, the method call in the <b>actionPerformed()</b> method shown
earlier is enclosed in a <i>try</i> block.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp; void <b>doInheritance</b>()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws <b>ClassNotFoundException</b>{

<b>Listing 2</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Temporary storage</font></b>
<p>Listing 3 shows the declaration of a new object of the class <b>Vector</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Vector <b>inherVector</b> = new Vector();

<b>Listing 3</b></font></pre>
</td>
</tr>
</table>

<p>In case you are unfamiliar with the use of the <b>Vector</b> class,
an object of this class is an extremely useful container for an unknown
amount of data that needs to be accessed later using an ordinal index.

<i>(You can find a detailed discussion of the Vector class among the many
tutorial lessons on my <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">web
site</a>.)</i>
<p>In this case, we need a container for an unknown amount of data that
needs to be accessed later using an ordinal index, so a <b>Vector</b> object
is my container of choice.&nbsp; To begin with, there is no advance knowledge
of how many different classes comprise the family tree.&nbsp; Further,
it will later be necessary to access the class names in the reverse of
the order in which they are saved in order to display them.
<p><b><font color="#FF0000">The target class</font></b>
<p>During operation, the user enters the name of the target class in the
text field shown in the lower left of the GUI in Figure 1.&nbsp; The code
in Listing 4 invokes the <b>getText()</b> method on the reference to that
<b>JTextField</b>
object to obtain the name of the target class as a <b>String</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; String <b>theClass</b> = targetClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getText</b>();

<b>Listing 4</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Working variables</font></b>
<p>The code in Listing 5 shows the declaration of a pair of working variables
that will be used later.&nbsp; The first variable named <b>theClassObj</b>
is used to refer to an object of the <b>Class</b> class that represents
the target class.
<p>The second variable named <b>theSuperClass</b> is used to refer to an
object of the <b>Class</b> class that represents the superclass of the
target class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; Class <b>theClassObj</b> = null;
&nbsp;&nbsp;&nbsp; Class <b>theSuperClass</b> = null;

<b>Listing 5</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">A while loop</font></b>
<p>Listing 6 shows the beginning of a <b>while</b> loop that is used to
get and save the names of all the classes in the inheritance family tree.&nbsp;
Note that this loop continues to iterate as long as the name of the class
is <u>not</u> <b>java.lang.Object</b>.&nbsp; Once the <b>Object</b> class
is encountered, execution of the loop is terminated.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; while(!(theClass.equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<b>java.lang.Object</b>"))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.<b>add</b>(theClass);

<b>Listing 6</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Saving the class name</font></b>
<p>At the beginning of the loop, the <b>add()</b> method is used to store
the name of the class in the <b>Vector</b> object referred by <b>inherVector</b>.&nbsp;
This is shown in Listing 6 above.
<p><b><font color="#FF0000">Getting the superclass</font></b>
<p>As explained in an earlier lesson, if you have a <b>Class</b> object
that represents a target class, you can use that object to obtain another
<b>Class</b>
object that represents the superclass of the target object.
<p>The first statement in Listing 7 uses the <b>forName()</b> method of
the <b>Class</b> class to get and save a reference to a <b>Class</b> object
that represents the target class whose name is stored in the <b>String</b>
object referred to by <b>theClass</b>.
<p>The second statement in that fragment uses the <b>getSuperclass()</b>
method to get and save a reference to a <b>Class</b> object that represents
the superclass of the target class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassObj = Class.<b>forName</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theSuperClass = theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getSuperclass</b>();

<b>Listing 7</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Interfaces</font></b>
<p>Once you have a <b>Class</b> object that represents the target class,
you can use the method named <b>getInterfaces()</b> to get a reference
to an array of <b>Class</b> objects, each of which represents an interface
implemented by the target class.
<p>Although identification of the interfaces implemented by the target
class is not the primary purpose of this lesson, this information will
be needed later in the program.&nbsp; Therefore, the code in Listing 8
gets and saves that interface information in a <b>Vector</b> object referred
to by an instance variable named <b>intfcsVector</b>.
<p>The use of this information to produce the display shown in the top-left
scroll pane of Figure 1 will be discussed in the next lesson.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theClassObj.<b>getInterfaces</b>()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcsVector.add(theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getInterfaces</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if

<b>Listing 8</b></font></pre>
</td>
</tr>
</table>

<p>Note that a class doesn't necessarily implement any interfaces.&nbsp;
Therefore, the code in Listing 8 first tests to see if the target class
does implement any interfaces before trying to get the information and
save it in the vector.
<p><b><font color="#FF0000">The superclass name</font></b>
<p>At this point, the reference variable named <b>theSuperClass</b> contains
a reference to a <b>Class</b> object that represents the superclass of
the target class.&nbsp; We need to extract the name of the superclass from
that object.&nbsp; The code in Listing 9 shows how to do this using the
<b>getName()</b>
method of the <b>Class</b> class.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = theSuperClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getName</b>();
&nbsp;&nbsp;&nbsp; }//end while loop

<b>Listing 9</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Make the superclass into a target class</font></b>
<p>The resulting <b>String</b> is a fully qualified class name for the
superclass.&nbsp; This string is assigned to the variable named <b>theClass</b>
causing it to become the target class for the next iteration.
<p>Control then returns to the top of the <b>while</b> loop where the process
is repeated unless the name of the target class is <b>Object</b>.&nbsp;
In that event, the loop is terminated and the code in Listing 10 is executed.
<p><b><font color="#FF0000">Saving name of Object class</font></b>
<p>The code in Listing 10 simply adds the name of the <b>Object</b> class
to the storage vector so that the contents of that vector will include
the names of all of the classes in the family tree, beginning with the
target class and ending with the class named <b>Object</b>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; inherVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<b>java.lang.Object</b>");

<b>Listing 10</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Display the family tree</font></b>
<p>The <b>Vector</b> object referred to by <b>inherVector</b> now contains
the names of all the classes in the family tree.&nbsp; However, they are
in the reverse of the order in which they need to be displayed.
<p>The inheritance family tree, consisting of the class names in the vector,
needs to be displayed in the <b>JTextArea</b> object referred to by <b>inher</b>.&nbsp;
That object is displayed in the upper-left of Figure 1.
<p><b><font color="#FF0000">Contents of a JTextArea object</font></b>
<p>A <b>JTextArea</b> object contains a single <b>String</b> object.&nbsp;
Therefore, it is necessary to convert the contents of the storage vector
to a <b>String</b> in the correct format, and to store that <b>String</b>
in the <b>JTextArea</b> object.&nbsp; This involves extracting the class
names from the storage vector and appending them to the <b>String</b> contents
of the <b>JTextArea</b> object.
<p><b><font color="#FF0000">Storing the family tree in the JTextArea object</font></b>
<p>The <b>for</b> loop in Listing 11 extracts the names of the classes
from the storage vector referred to by <b>inherVector</b> in reverse order.&nbsp;
It appends those names to the contents of the <b>JTextArea</b> object referred
to by <b>inher</b>.
<p>Because each class in the family tree needs to be displayed on a separate
line, the code in Listing 11 also appends newline code between each of
the class names.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; inherVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>inher.append</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((<b>String</b>)inherVector.elementAt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.size() - (i+1))));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>inher.append</b>("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInheritance

<b>Listing 11</b></font></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Downcasting is required</font></b>
<p>Note that the contents of a <b>Vector</b> object are references to objects
stored in the vector as type <b>Object</b>.&nbsp; Therefore, it is necessary
to downcast those references to type <b>String</b> before the strings to
which they refer can be appended to the contents of the <b>JTextArea</b>
object.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
I have introduced you to a program that displays information about the
following aspects of any Java class that qualifies as a JavaBeans Component:
<ul>
<li>
<font color="#000000">Inheritance family tree of the component</font></li>

<li>
<font color="#000000">Interfaces implemented by the component</font></li>

<li>
<font color="#000000">Properties of the component</font></li>

<li>
<font color="#000000">Events multicast by the component</font></li>

<li>
<font color="#000000">Public methods exposed by the component</font></li>
</ul>
I have provided background information on Java introspection.
<p><font color="#000000">I have explained the use of an anonymous inner
class that is used to instantiate an action listener object and register
it on the OK button shown in Figure 1.</font>
<p><font color="#000000">I showed how the <b>actionPerformed()</b> method
of the action listener object invokes the following methods to obtain and
display the sought-after information about the target component:</font>
<ul>
<li>
<font color="#000000">doInheritance()</font></li>

<li>
<font color="#000000">doInterfaces()</font></li>

<li>
<font color="#000000">doProperties()</font></li>

<li>
<font color="#000000">doEvents()</font></li>

<li>
<font color="#000000">doMethods()</font></li>
</ul>
<font color="#000000">In this lesson, I explained the <b>doInheritance()</b>
method in detail.&nbsp; In the discussion, I showed you how to use a <b>Class</b>
object representing a target class to obtain a <b>Class</b> object representing
the superclass of the target class.</font>
<p><font color="#000000">I showed you how to use iteration to obtain the
complete family tree of the target class, all the way up to the class named
<b>Object</b>.</font>
<p><font color="#000000">I showed you how to display that information in
a <b>JTextArea</b> object.</font>
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will explain how the method named <font color="#000000"><b>doInterfaces()</b>
obtains and displays interface information about the target class, in alphabetical
order, in the upper-right output pane in Figure 1.</font>
<p><font color="#000000">In subsequent lessons, I will provide similar
explanations for the other three methods in the above list.</font>
<br>&nbsp;
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
12</font>.
<br>&nbsp;
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre><font face="Courier New,Courier">/*File Introspect03.java&nbsp;
Copyright 2000, R.G.Baldwin

Produces a GUI that displays&nbsp;
inheritance, interfaces, properties,
events, and methods about components,
or about any class that is a bean.

Requires JDK 1.3 or later.&nbsp; Otherwise,
must service the windowClosing event&nbsp;
to terminate the program.
Tested using JDK 1.3 under WinNT.&nbsp;&nbsp;
**************************************/
import java.io.*;
import java.beans.*;
import java.lang.reflect.*;
import java.util.*;
import java.awt.Color;
import java.awt.event.*;
import javax.swing.*;

public class Introspect03&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extends JFrame{
&nbsp; private JLabel errors =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JLabel("Errors appear here");
&nbsp; private JPanel outputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JPanel inputPanel =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JPanel();
&nbsp; private JTextField targetClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JTextField ceilingClass =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField(14);
&nbsp; private JButton okButton =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("OK");
&nbsp;&nbsp;
&nbsp; private JTextArea inher = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INHERITANCE\n",8,17);
&nbsp; private JScrollPane inherPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(inher);
&nbsp; private JTextArea intfcs = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("INTERFACES\n",8,17);
&nbsp; private JScrollPane intfcsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(intfcs);
&nbsp; private JTextArea props = new&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JTextArea("PROPERTIES\n",8,17);
&nbsp; private JScrollPane propsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(props);
&nbsp; private JTextArea events =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("EVENTS\n",8,17);
&nbsp; private JScrollPane eventsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(events);
&nbsp; private JTextArea methods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextArea("METHODS\n",8,17);
&nbsp; private JScrollPane methodsPane =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JScrollPane(methods);
&nbsp;&nbsp;
&nbsp; private BeanInfo beanInfo;
&nbsp; private Vector intfcsVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Introspect03();
&nbsp; }//end main
&nbsp;&nbsp;
&nbsp; public Introspect03() {//constructor
&nbsp;&nbsp;&nbsp; //This require JDK 1.3 or later.
&nbsp;&nbsp;&nbsp; // Otherwise service windowClosing
&nbsp;&nbsp;&nbsp; // event to terminate the program.
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFrame.EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; outputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.green);
&nbsp;&nbsp;&nbsp; inputPanel.setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.yellow);

&nbsp;&nbsp;&nbsp; outputPanel.add(inherPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(intfcsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(propsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(eventsPane);
&nbsp;&nbsp;&nbsp; outputPanel.add(methodsPane);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Set some default values
&nbsp;&nbsp;&nbsp; targetClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "javax.swing.JButton");
&nbsp;&nbsp;&nbsp; ceilingClass.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");

&nbsp;&nbsp;&nbsp; inputPanel.add(targetClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(ceilingClass);
&nbsp;&nbsp;&nbsp; inputPanel.add(okButton);

&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors,"North");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputPanel,"Center");
&nbsp;&nbsp;&nbsp; getContentPane().add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputPanel,"South");
&nbsp;&nbsp;&nbsp; setResizable(false);
&nbsp;&nbsp;&nbsp; setSize(400,520);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2000, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Anonymous inner class to provide
&nbsp;&nbsp;&nbsp; // event handler for okButton
&nbsp;&nbsp;&nbsp; okButton.addActionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ActionListener(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Errors appear here");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INHERITANCE\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INTERFACES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PROPERTIES\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "EVENTS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.setText("METHODS\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class targetClassObject =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClass.getText());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInheritance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doInterfaces();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo = Introspector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBeanInfo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetClassObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceilingClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doProperties();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doEvents();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doMethods();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(Exception ex){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors.setText(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex.toString());}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end actionPerformed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ActionListener
&nbsp;&nbsp;&nbsp;&nbsp; );//end addActionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInheritance()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ClassNotFoundException{
&nbsp;&nbsp;&nbsp; //Get and display inheritance
&nbsp;&nbsp;&nbsp; // hierarchy
&nbsp;&nbsp;&nbsp; Vector inherVector = new Vector();
&nbsp;&nbsp;&nbsp; String theClass = targetClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getText();
&nbsp;&nbsp;&nbsp; Class theClassObj = null;
&nbsp;&nbsp;&nbsp; Class theSuperClass = null;
&nbsp;&nbsp;&nbsp; while(!(theClass.equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object"))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.add(theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassObj = Class.forName(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theSuperClass = theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSuperclass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get and save interfaces to be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // used later
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(theClassObj.getInterfaces()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcsVector.add(theClassObj.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInterfaces());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClass = theSuperClass.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName();
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; inherVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "java.lang.Object");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display vector contents in
&nbsp;&nbsp;&nbsp; // reverse order
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; inherVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((String)inherVector.elementAt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherVector.size() - (i+1))));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inher.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInheritance
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doInterfaces(){
&nbsp;&nbsp;&nbsp; Vector interfaceNameVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;&nbsp; //Interface information was stored
&nbsp;&nbsp;&nbsp; // in intfcsVector earlier.
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; intfcsVector.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class[] interfaceSet =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Class[])intfcsVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elementAt(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; interfaceSet.length;j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceSet[j].getName());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop on j
&nbsp;&nbsp;&nbsp; }//end for loop on i

&nbsp;&nbsp;&nbsp; Object[] interfaceNameArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(interfaceNameArray);

&nbsp;&nbsp;&nbsp; if(interfaceNameArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; interfaceNameArray.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup interface names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceNameArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfcs.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doInterfaces
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doProperties(){
&nbsp;&nbsp;&nbsp; Vector propVector = new Vector();
&nbsp;&nbsp;&nbsp; PropertyDescriptor[] propDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropClass propObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PropClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setName(propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propObj.setType("" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPropertyType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propVector.add(propObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] propArray = propVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propArray,new PropClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; propArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append(propArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; props.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doProperties
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doEvents(){
&nbsp;&nbsp;&nbsp; Vector eventVector = new Vector();
&nbsp;&nbsp;&nbsp; EventSetDescriptor[] evSetDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEventSetDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; evSetDescrip.length; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventClass eventObj =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EventClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setName(evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evSetDescrip[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getListenerMethodDescriptors();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j &lt; methDescrip.length; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventObj.setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[j].getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventVector.add(eventObj);
&nbsp;&nbsp;&nbsp; }//end for-loop

&nbsp;&nbsp;&nbsp; Object[] eventArray = eventVector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventArray,new EventClass());
&nbsp;&nbsp;&nbsp; for(int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; eventArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append(eventArray[i].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; events.append("\n");
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doEvents
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; void doMethods(){
&nbsp;&nbsp;&nbsp; Vector methVector = new Vector();
&nbsp;&nbsp;&nbsp; MethodDescriptor[] methDescrip =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beanInfo.getMethodDescriptors();
&nbsp;&nbsp;&nbsp; for (int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methDescrip.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methDescrip[i].getName());
&nbsp;&nbsp;&nbsp; }//end for-loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Object[] methodArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methVector.toArray();
&nbsp;&nbsp;&nbsp; Arrays.sort(methodArray);

&nbsp;&nbsp;&nbsp; if(methodArray.length > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[0].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; for(int i = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; methodArray.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Eliminate dup method names
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!(methodArray[i].equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i-1]))){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methodArray[i].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; methods.append("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end doMethods
//===================================//

//This inner class is used to
// encapsulate name and type
// information about properties.&nbsp; It
// also serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class PropClass implements Comparator{
&nbsp; private String name;
&nbsp; private String type;
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setType(String type){
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return(name + "\n&nbsp; " + type);
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((PropClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PropClass)obj).getName());
&nbsp; }//end equals
}//end class PropClass
//===================================//

//This inner class is used to
// encapsulate name and handler
// information about events.&nbsp; It also
// serves as a class from which a
// Comparator object can be
// instantiated to assist in sorting
// by name.
class EventClass implements Comparator{
&nbsp; private String name;
&nbsp; private Vector lstnrMethods =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Vector();
&nbsp;&nbsp;
&nbsp; public void setName(String name){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp; }//end setName
&nbsp;&nbsp;
&nbsp; public String getName(){
&nbsp;&nbsp;&nbsp; return name;
&nbsp; }//end getName
&nbsp;&nbsp;
&nbsp; public void setListenerMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String lstnrMethod){
&nbsp;&nbsp;&nbsp; lstnrMethods.add(lstnrMethod);
&nbsp; }//end setType
&nbsp;&nbsp;
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; String theString = name;

&nbsp;&nbsp;&nbsp; for(int i = 0;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; lstnrMethods.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theString = theString + "\n&nbsp; " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstnrMethods.elementAt(i);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; return theString;
&nbsp; }//end toString
&nbsp;&nbsp;
&nbsp; public int compare(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o1, Object o2){
&nbsp;&nbsp;&nbsp; return ((EventClass)o1).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase().compareTo(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)o2).getName().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toUpperCase());
&nbsp; }//end compare
&nbsp;&nbsp;
&nbsp; public boolean equals(Object obj){
&nbsp;&nbsp;&nbsp; return this.getName().equals(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((EventClass)obj).getName());
&nbsp; }//end equals
}//end EventClass inner class
&nbsp;&nbsp;
}//end controlling class Introspect03

<b>Listing 12</b></font></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
