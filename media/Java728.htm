<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body alink="#ff0000" lang="EN-US" link="#0000ff" vlink="#666666">
<h2>Digital Signatures 101 using Java</h2>
<i>Learn a simple protocol for using public-key cryptography and 
digital signatures to protect the authenticity, integrity, and confidentiality 
of a message.</i><p><b>Published:</b>&nbsp; February 8, 2005<br>
<b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
<p>Java Programming, Notes # 728</p>
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a></li>
  <li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#Whats%20Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a>
  </li>
</ul>
<hr align="center" size="3" width="100%">
<center>
<h2> <a name="Preface">Preface</a></h2>
</center>
<p>&nbsp;</p>
<p><font color="#FF0000"><b>A simple protocol</b></font></p>
<p>A variety of protocols are available for the use of public-key cryptography 
and digital signatures to protect the authenticity, integrity, and 
confidentiality of a message.&nbsp; This lesson explains a simple and easily 
understood protocol.&nbsp; Future lessons will explain more sophisticated 
protocols.</p>
<p><font color="#ff0000"><b>Second in a series</b></font></p>
<p>This is the second lesson in a series designed to teach you
something about the inner workings of cryptography using Java.&nbsp;
The previous lesson was entitled 
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.&nbsp; Hopefully, when you
finish studying the lessons in this series, you will have learned a
little about what goes on
<i>"under the hood"</i> when you apply a cryptographic process.</p>
<p><font color="#ff0000"><b>Not a lesson on JCE</b></font></p>
<p>The lessons in this series do not provide instructions on how to use
the
<a
 href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Java
Cryptography Extension <i>(JCE)</i></a>.&nbsp; The purpose of this series is to 
teach you how to implement common cryptography algorithms for small cases 
without the use of a cryptography API.</p>
<p><font color="#ff0000"><b>Not intended for production use</b></font></p>
<p>The programs that I will provide and explain in this series of
lessons are not intended to be used for production cryptography.&nbsp;
If you need to do production cryptography using Java, you should use Sun's
<a href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Java Cryptography Extension <i>(JCE)</i></a><i>.</i></p>
<p>The programs that I will provide in this series are intended to help
you to experiment with and to learn about various cryptographic
and secure hash algorithms and to gain a better understanding of how they work, and why
they do what they do.&nbsp; In addition, the lessons in this series are intended 
to help you understand some of the common uses of cryptography such as the use 
of digital signatures.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different figures and listings while
you are reading about them.</p>
<p><font color="#ff0000"><b>Theoretical basis and practical
implementation</b></font></p>
<p>I will provide some of the theoretical basis for cryptographic
algorithms while discussing the lessons in this series.&nbsp; In
addition, I will show you how to implement several common cryptographic
and secure hash algorithms in Java.</p>
<p>I will also discuss and illustrate some of the modern uses of
cryptography, such as the use of digital signatures, which is the
primary topic of this and the next several lessons.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <a href="http://www.dickbaldwin.com">
www.DickBaldwin.com</a><font color="#000000">.</font></p>
<h2 align="center"><a name="Background_Information">Background
Information</a></h2>
<p>Cryptography in one form or another has been around throughout
history.&nbsp; Please see the previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a> for some
background information on cryptography.</p>
<p><font color="#ff0000"><b>New uses in modern times</b></font></p>
<p>Bringing the field of cryptography up to date,
<a href="http://en.wikipedia.org/wiki/Cryptography">Wikipedia</a> tells
us, <i>
"In recent decades, the field of cryptography has expanded its remit in
two ways. Firstly, it provides mechanisms for more than just
<a title="Confidentiality"
 href="http://en.wikipedia.org/wiki/Confidentiality">keeping secrets</a>:
schemes like
<a title="Digital signature"
 href="http://en.wikipedia.org/wiki/Digital_signature">digital
signatures</a> and
<a title="Digital cash" href="http://en.wikipedia.org/wiki/Digital_cash">digital
cash</a>, for example." </i></p>
<p><font color="#ff0000"><b>Secure communications</b></font></p>
<p>The lessons in this series will present and explain programs that
implement cryptographic and secure hash algorithms intended to achieve secure
communications between two parties.&nbsp; These algorithms fall into
two broad categories:</p>
<ul>
  <li>Public <i>(asymmetric)</i> key cryptography</li>
  <li>Symmetric key cryptography</li>
</ul>
<p>The first several lessons will deal with
<a
 href="http://en.wikipedia.org/wiki/Cryptography#Public_key_cryptography">public
key cryptography</a>.&nbsp; Subsequent lessons will deal with
<a
 href="http://en.wikipedia.org/wiki/Cryptography#Symmetric_key_cryptography">symmetric
key cryptography</a>. </p>
<p>Please see the previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a> for a discussion of
the difference between the two.</p>
<p><font color="#FF0000"><b>Asymmetric or public key cryptography</b></font></p>
<p>This lesson deals with <i>asymmetric</i> or <i>public key </i>cryptography.&nbsp;
With asymmetric key cryptography, there are two keys.&nbsp; One key is
used to encrypt the data and the other is used to decrypt the
data.&nbsp; Thus, one of the keys <i>(the encryption key)</i> can be
publicly disclosed without compromising secrecy so long as the other key <i>(the
decryption key)</i> is held secret.&nbsp; This leads to the common name
of <i>public key </i>cryptography<i>.</i></p>
<p><font color="#FF0000"><b>Sometimes the roles are switched</b></font></p>
<p>Actually the concept that the <i>encryption key</i> is public and the
<i>decryption key</i> is secret isn't always correct.&nbsp; As you will
see in this lesson, either key can be used to encrypt the data provided
that the other key is used to decrypt the data.&nbsp; It is very important, 
however, that one of the keys be kept secret.&nbsp; For purposes of <i>digital
signing</i> of messages, the secret key is used to encrypt the message
or a portion thereof and the public key is used to decrypt it.</p>
<p><font color="#ff0000"><b>The RSA algorithm</b></font></p>
<p>This lesson deals with a particular asymmetric key algorithm known
as the <a href="http://theory.lcs.mit.edu/%7Erivest/rsapaper.pdf">
RSA</a> algorithm.&nbsp; This algorithm is named after the original
authors, R.L. Rivest, A. Shamir, and L. Adleman.&nbsp; Please see the
previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a> to gain a basic understanding of the RSA
algorithm.</p>
<p><font color="#ff0000"><b>Key management</b></font></p>
<p>In their paper, the authors point out that <i>"... publicly
revealing an encryption key does not thereby reveal the corresponding
decryption key.</i></p>
<p>One consequence of this is a significant easing of key management
problems relative to symmetric key cryptography.&nbsp; For example,
couriers or other secure means are not needed to exchange keys.&nbsp;
The sender of the message can encrypt the message using the intended
recipient's public encryption key.&nbsp; However, only the intended
recipient can decrypt the message using her private and secret
decryption key.</p>
<p><font color="#ff0000"><b>Message signing and digital signatures</b></font></p>
<p>A second important consequence is that a message can be <i>"signed"</i>
using a privately held key.&nbsp; The signature can be verified using
the corresponding publicly revealed key.</p>
<p>In other words, a message that is encrypted using the sender's secret key can 
be decrypted by anyone having access to the sender's public key.&nbsp; The 
significance of such an operation is that only the holder of the secret key 
could have encrypted the message.&nbsp; While the contents of the message are 
not held secret in this case, the identity of the sender is clearly established 
as someone having access to the secret key.</p>
<p>The primary topic of this lesson is the <i>digital signing</i> of
both plain text and encrypted messages.</p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p><font color="#ff0000"><b>Two different programs</b></font></p>
<p>I will present and discuss two different programs in this
lesson.&nbsp; The first program named <b>Rsa04</b> will illustrate the
digital signing of an unencrypted message using an encrypted digital
signature.</p>
<p>The second program named <b>Rsa05</b> will illustrate the digital
signing of an encrypted message.</p>
<p><font color="#ff0000"><b>Three important aspects</b></font></p>
<p>There are at least three important aspects of electronic
communication:</p>
<ul>
  <li><b>Authentication:</b> Confirming the identities of the parties involved.
  </li>
  <li><b>Confidentiality:</b> Making certain that only authorized
parties can understand the message, even if it is intercepted by
unauthorized persons. </li>
  <li><b>Integrity:</b> Confirming that the content of the message wasn't
modified during transmission.</li>
</ul>
<p>The first program named <b>Rsa04</b> will illustrate a scenario
where only <i>
authentication</i> and <i>integrity</i> are of concern.&nbsp; In this
scenario, there is no need to be concerned about the public disclosure
of the content of a message.</p>
<p>The second program named <b>Rsa05</b> involves a scenario where all
three aspects are important.&nbsp; In this case, it is also necessary
to keep the content of each message confidential.</p>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and
Sample Code</a></h2>
<p><font color="#ff0000"><b>The program named Rsa04</b></font></p>
<p>IMPORTANT:&nbsp; THIS PROGRAM USES PREDETERMINED KEYS THAT WERE
DESIGNED FOR A BLOCK SIZE OF 4.&nbsp; THEREFORE, IT WILL WORK CORRECTLY
ONLY FOR A BLOCK SIZE OF 4.</p>
<p>The purpose of this program is to illustrate the <i>digital signing</i>
of an unencrypted message along with the later verification of the
signature and the validation of the message by the recipient of the message.&nbsp; 
This program illustrates how to validate <i>(or fail to validate)</i> both the
<i>authenticity</i> and the <i>integrity</i> of the message.</p>
<p><font color="#ff0000"><b>Alice and Bob</b></font></p>
<p>The comments in this program reflect a scenario based on two
fictitious people named Alice and Bob.&nbsp; This scenario is commonly
used in discussions of digital signatures.</p>
<p><font color="#ff0000"><b>The scenario</b></font></p>
<p>Alice needs to send a <i>digitally signed</i> unencrypted message
to Bob. The message needs to be digitally signed so that Bob can be
confident that the message that he received was sent by Alice and was
not sent by someone pretending to be Alice<i>.</i>&nbsp; In other words, Bob
needs to be able to <i>authenticate</i> the message.&nbsp; In addition, Bob
needs to be able to confirm the <i>integrity</i> of the message.</p>
<blockquote>
  <p><i>(For example, the message could be an order from Alice to Bob
for the purchase of ten file cabinets.&nbsp; Bob needs to be certain
that Alice really did sign and send the purchase order before he ships
the file cabinets.&nbsp; Otherwise, the order may have been sent by
someone pretending to be Alice, in which case, Bob probably won't get
paid for the shipment.&nbsp; Bob also needs to confirm that Alice
really did order ten file cabinets and that the quantity in her
purchase order was not modified during transit.&nbsp; Otherwise, he may ship 
	more or fewer than she wants.)</i></p>
</blockquote>
<p><font color="#ff0000"><b>Key management</b></font></p>
<p>In order to accomplish the desired result, Alice needs to create a
pair of asymmetric keys.&nbsp; She will hold one of the keys secret and
will provide the other key to Bob.&nbsp; We will refer to the secret
key as Alice's <i>private</i> key, and will refer to the key that she gives to
Bob as her <i>public</i> key.</p>
<blockquote>
  <p><i>(Alice needs to provide the public key to Bob in a way that
causes him to be confident that the public key was actually provided by
Alice and was not provided by someone pretending to be Alice.&nbsp;
Otherwise, his later use of the public key to decrypt the digital
signature won't authenticate that the message was actually sent by
Alice.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Block size, encoding, and decoding</b></font></p>
<p>In addition, for this simple implementation, Alice needs to notify Bob as to the block size for
which the keys were designed.&nbsp; The two of them need to agree on an
encoding/decoding methodology for transforming messages back and forth
between a text format and a numeric format.</p>
<blockquote>
  <p><i>(Recall that the RSA algorithm can only be used with messages
expressed in a numeric format.)</i></p>
</blockquote>
<p>You can read about most of these topics in the previous lesson
entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.</p>
<p><font color="#ff0000"><b>Create a digital signature</b></font></p>
<p>Alice begins by creating a digital signature.&nbsp; The digital
signature is created by encoding and encrypting the entire text message
using Alice's private key and the RSA algorithm.</p>
<blockquote>
  <p><i>(Bob can later decrypt the digital signature using Alice's
public key.)</i></p>
</blockquote>
<p><font color="#ff0000"><b>Message digests as an alternative</b></font></p>
<p>As described above, the approach used by this program is to create a
digital signature that is an encrypted version of the entire text
message.&nbsp; This can be wasteful of communication resources, particularly for long
messages.&nbsp; In this implementation, the length of the digital signature is twice the
length of the text version of the message.&nbsp; A more efficient
approach for long messages would be to apply another mathematical algorithm to the message, 
which will produce something called a <i>message digest</i>.&nbsp; </p>
<p><font color="#FF0000"><b>A fingerprint</b></font></p>
<p>The message-digest algorithm takes an arbitrary amount of input message data
and produces a fixed-length output that represents the message data.&nbsp;
The fixed-length version is commonly referred to as a <i>digest</i> or
a <i>
fingerprint</i>.&nbsp; While it is not guaranteed that digests for two
different messages will be different, the probability that two
different messages will produce the same digest is extremely small.</p>
<p>Using this approach, Alice would encode and encrypt the digest and use the 
resulting string of numeric characters as the digital signature instead of 
encrypting the entire message for use as a digital signature.&nbsp; If her 
message is a long message, this will save communications resources <i>(but will also require an extra computational step at
each end of the communication between Alice and Bob).</i></p>
<p>This lesson won't deal with message digests.&nbsp; That is a topic
for a future lesson.</p>
<p><font color="#ff0000"><b>Sign and send the message</b></font></p>
<p>Now let's return to the original scenario were Alice creates the digital 
signature by encrypting the entire message using her private key.&nbsp; Alice signs the message by appending the digital signature
onto the end of the unencrypted message.&nbsp; According to a previous agreement 
between Alice and Bob, she uses an underscore
character as the delimiter to separate the text portion of the message from the digital signature.</p>
<blockquote>
  <p><i>(Bob will use the delimiter later to separate the text portion
of the message from the digital signature.&nbsp; There is nothing magic
about an underscore character.&nbsp; Any mutually agreed upon character
could be used as a delimiter provided that it is a character that won't
appear elsewhere in the message.)</i></p>
</blockquote>
<p>Then Alice sends the signed message to Bob.</p>
<blockquote>
	<p><i>(Note that there are ways to avoid having to use a delimiter that 
	involve encoding the length of the original message in the overall message.)</i></p>
</blockquote>
<p><font color="#ff0000"><b>Separate and decrypt the digital signature</b></font></p>
<p>When Bob receives the signed message, he separates the encrypted digital signature from the text portion
of the message using the underscore character as the delimiter between
the two.&nbsp; Then he decrypts the digital signature using Alice's
public key and decodes the result.&nbsp; This should produce a plain text
version of the digital signature.</p>
<p><font color="#ff0000"><b>Test the signature for validity</b></font></p>
<p>According to a previous agreement between Alice and Bob, the plain text
version of the digital signature should exactly match the text portion
of the message.&nbsp; Bob compares the text version of the digital
signature with the text portion of the message. If they match exactly,
he concludes that the message was actually sent by Alice, <i>(or by
someone having access to her private key).</i>&nbsp; Also because they
match, he concludes that the message was not modified in transit.</p>
<p>If they fail to match, the actual source or the content of the
message is questionable.</p>
<p><font color="#ff0000"><b>Message digests</b></font></p>
<p>In the event that Alice and Bob had agreed to authenticate and
confirm the integrity of the message based on the use of an encrypted
message digest as the digital signature, Bob's validation procedure
would be a little more complicated.</p>
<p>Bob would extract, decrypt and decode the digital signature as
before.&nbsp; He would also need to use the same algorithm used by
Alice and create a digest of the text portion of the message.&nbsp; He
would then compare his version of the digest with the decrypted and
decoded version of the digital signature.&nbsp; If they matched
exactly, he would conclude with a high degree of confidence that the
message was sent by Alice and that it had not been modified in
transit.&nbsp;
</p>
<p><font color="#ff0000"><b>Key reversal</b></font></p>
<p>Note that you can reverse the values of the two keys and get the
same results. In other words, it doesn't matter which key you use to
sign the message as long as you use the other key to decrypt the
digital signature.&nbsp; However, for the protocol to achieve the desired 
result, it is imperative that Alice maintain the secrecy of the key that she 
uses to encrypt the digital signature.</p>
<p><font color="#ff0000"><b>Support for 95 text characters</b></font></p>
<p>This program supports the ninety-five ASCII characters from space
(32) through ~ (126) inclusive for use in the message.&nbsp; <i>(However, 
because the underscore character is used as a delimiter, it is not available for 
use elsewhere in the message.)</i></p>
<p><font color="#ff0000"><b>Predetermined keys</b></font></p>
<p>The program uses predetermined values shown in Figure 1 for the
following:</p>
<ul>
  <li>Alice's public key, e</li>
  <li>Alice's private key, d</li>
  <li>Alice's common divisor, n</li>
</ul>
<p><font color="#ff0000"><b>A disclaimer</b></font></p>
<p>This program should not be used for production purposes.&nbsp; If
you need a Java program for production use, you should develop it using
Sun's 
<a href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">
Java Cryptography Extension <i>(JCE)</i></a> .</p>
<p><font color="#ff0000"><b>Theoretical background</b></font></p>
<p>See the theoretical basis for the RSA algorithm at:
<a href="http://theory.lcs.mit.edu/%7Erivest/rsapaper.pdf">http://theory.lcs.mit.edu/~rivest/rsapaper.pdf</a></p>
<p>Another good reference is at:
<a href="http://www.math.mtu.edu/mathlab/COURSES/holt/dnt/phi4.html">http://www.math.mtu.edu/mathlab/COURSES/holt/dnt/phi4.html</a></p>
<p><font color="#ff0000"><b>The program output</b></font></p>
<p>The program was tested using SDK 1.5 and WinXP, producing the
output shown in Figure 1.&nbsp; </p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre><b>Alice's keys:<br>e: 17<br>d: 3869<br>n: 9617<br>Alice's extended message:<br>Hello Bob, how are you?-<br>Alice's digital signature<br>645654360346008475874713831303624383162618484532<br>Alice's signed message:<br>Hello Bob, how are you?-_645654360346008475874713<br>831303624383162618484532<br>Bob's extracted message text:<br>Hello Bob, how are you?-<br>Bob's extracted digital signature:<br>645654360346008475874713831303624383162618484532<br>Bob's decoded digital signature:<br>Hello Bob, how are you?-<br>Bob's conclusion: Valid signature</b><br></pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that line breaks were manually entered into the above text to
force it fit into this narrow publication format.</p>
<p>I will refer back to Figure 1 frequently during the discussion of
this program.</p>
<p><font color="#ff0000"><b>The class named Rsa04</b></font></p>
<p>The beginning of the class and the beginning of the main method is
shown in Listing 1.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>class <b>Rsa04</b>{<br>  static class Keys{<br>    BigInteger n = new BigInteger("9617");<br>    BigInteger d = new BigInteger("3869");<br>    BigInteger e = new BigInteger("17");<br>  }//end inner class Keys<br><br>  public static void <b>main</b>(String[] args){<br>    //Instantiate an object containing<br>    // keys.<br>    Keys keys = new Keys();<br><br><b>Listing 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>The definition of the class named <b>Rsa04</b> begins with the
definition of a <b>static</b> internal class named <b>Keys</b>.&nbsp; The
sole purpose of the <b>Keys</b> class is to create an object that
serves as a container for the keys.&nbsp; The class was made <b>static</b> so
that it can be instantiated from within <b>main</b>.&nbsp; The <b>Keys</b>
class contains predetermined values for the two keys, e and d, and the
common divisor n used by the RSA algorithm.</p>
<p>The key named e will be used as a public key and the key named d
will be used as a private key</p>
<p>The <b>main</b> method begins by instantiating an object of the <b>Keys</b>
class containing the predetermined keys as shown in Listing 1.</p>
<p><font color="#ff0000"><b>The test message</b></font></p>
<p>Listing 2 instantiates a <b>String</b> object that will be signed
and sent by Alice to Bob.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String message = "Hello Bob, how are you?";<br><br><b>Listing 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p><font color="#ff0000"><b>Set the block size</b></font></p>
<p>Listing 3 sets the <b>blockSize</b> to 4.&nbsp; As mentioned
earlier, because this program uses predetermined keys that were
designed for a block size of 4, changing <b>blockSize</b> to any other
value will cause this program to fail.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    int blockSize = 4;<br><br>    //Instantiate an object of this class<br>    Rsa04 obj = new Rsa04();<br><br>    //Display the key values<br>    System.out.println("Alice's keys:");<br>    System.out.println("e: " + keys.e);<br>    System.out.println("d: " + keys.d);<br>    System.out.println("n: " + keys.n);<br><br><b>Listing 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 3 also instantiates an object of the controlling class and
displays the contents of the <b>Keys</b> object.&nbsp; This produces
the first four lines of output in Figure 1.</p>
<p><font color="#ff0000"><b>Extend text message if necessary</b></font></p>
<p>As you learned in the previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>, the length of
the encoded text must be evenly divisible by <b>blockSize</b>.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    while(message.length()%(blockSize/2) != 0){<br>      message += "-";<br>    }//end while<br>    System.out.println(<br>                    "Alice's extended message:\n"<br>                                      + message);<br><br><b>Listing 4</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 4 forces the message length to be a multiple of half the
block size to avoid end-effect problems later.&nbsp; <i>(The encoding process 
used later produces two encoded numeric characters for each character in the 
original message.)</i>&nbsp; The text message
is extended by appending dash characters if it is necessary to extend
the message.</p>
<blockquote>
	<p><i>(Note that a more sophisticated approach to extending the message is 
	often used wherein the values of the characters used to extend the message 
	indicate the number of required extension characters.&nbsp; This makes it 
	possible to remove the extension later in an unambiguous manner.&nbsp; I 
	extended the message using dash characters for simplicity.)</i></p>
</blockquote>
<p>Listing 4 also displays the extended message producing the fifth and sixth
lines of output in Figure 1.</p>
<p><font color="#ff0000"><b>Encode the message</b></font></p>
<p>The first part of the program is presented from Alice's
viewpoint.&nbsp; She begins by invoking the <b>encode</b> method in
Listing 5 to encode the text message into numeric format in order to
get it ready for RSA encryption.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String encodedMsg = obj.encode(message);<br><br><b>Listing 5</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#ff0000"><b>The encode method</b></font></p>
<p>The <b>encode</b> method used by this program is essentially the
same as the method having the same name in one of the programs that I
explained in the previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.</p>
<p>As mentioned earlier, this method supports the encoding of the
ninety-five ASCII characters extending from the space character to the
tilde (~) character inclusive.</p>
<p>Because I explained this method in the previous lesson, I won't
discuss it further here.&nbsp; You can view the <b>encode</b> method along with 
all of the other methods in this program in Listing 27 near the end of this 
lesson.</p>
<p><font color="#ff0000"><b>Create the digital signature</b></font></p>
<p>Alice invokes the <b>doRSA</b> method in Listing 6 to create a
digital signature by encrypting the encoded message using her private
key.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String signature = obj.doRSA(<br>            encodedMsg,<b>keys.d</b>, keys.n,blockSize);<br><br>    System.out.println(<br>                    "Alice's digital signature\n"<br>                                    + signature);<br><br><b>Listing 6</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 6 also displays the digital signature as the seventh and eighth lines in
Figure 1.</p>
<blockquote>
	<p><i>(As you can see, the length of the digital signature is twice
the length of the text version of the message.&nbsp; This illustrates
that for long messages there may be bandwidth benefits in encrypting a
shorter digest of the message for use as the digital signature instead
of encrypting the entire message.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The doRSA method</b></font></p>
<p>The <b>doRSA</b> method used in this program is essentially the same as the 
method having the same name that I explained in the previous lesson entitled 
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.&nbsp; Therefore, I won't discuss it further here.</p>
<p><font color="#ff0000"><b>Sign the message</b></font></p>
<p>Alice signs the message in Listing 7 by appending the digital
signature onto the message.&nbsp; She identifies the beginning of the
digital signature by the presence of an underscore character.</p>
<blockquote>
	<p><i>(The underscore character is used to separate the message from the 
	digital signature.)</i></p>
</blockquote>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String signedMsg = message + "_" + signature;<br><br>    System.out.println(<br>                      "Alice's signed message:\n"<br>                                    + signedMsg);<br><br><b>Listing 7</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 7 also displays the digitally signed message producing the
output shown in lines 9, 10, and 11 in Figure 1.</p>
<blockquote>
  <p><i>(Note that a line break was manually inserted into line 10 in
Figure 1 to force the material to fit in this narrow publication
format.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Send the message to Bob</b></font></p>
<p>At this point, the digitally signed message is ready for Alice to
send to Bob, which she does.&nbsp; From this point forward, the program
viewpoint switches from Alice's viewpoint to Bob's viewpoint.</p>
<p><font color="#ff0000"><b>Extract the message text from the signed
message</b></font></p>
<p>In Listing 8, Bob extracts the message text from the signed message
based on the location of the underscore character.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String extractedMsgText =<br>                     signedMsg.substring(<br>                       0,signedMsg.indexOf('_'));<br><br>    System.out.println(<br>                "Bob's extracted message text:\n"<br>                             + extractedMsgText);<br><br><b>Listing 8</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 8 also displays the message text as lines 12 and 13 in Figure
1.&nbsp; As you would expect, it matches the beginning of Alice's
signed message shown in line 10 of Figure 1.</p>
<p><font color="#ff0000"><b>Extract the digital signature from the
signed message</b></font></p>
<p>Bob uses the location of the underscore character to extract and
display the encrypted digital signature in Listing 9.&nbsp; This produces the
output shown in lines 14 and 15 in Figure 1.<br>
</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String extractedSignature =<br>                   signedMsg.substring(<br>                     signedMsg.indexOf('_') + 1);<br>    System.out.println(<br>           "Bob's extracted digital signature:\n"<br>                           + extractedSignature);<br><br><b>Listing 9</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<font color="#FF0000"><b>Decrypt, decode, and display the digital signature</b></font><p>
In Listing 10, Bob uses Alice's public key and the <b>doRSA</b> method to 
decrypt the encrypted digital signature.&nbsp; Then he decodes the decrypted 
signature by 
invoking the <b>decode</b> method.&nbsp; Finally, he displays the result, producing the output 
shown in lines 16 and 17 in Figure 1.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String decipheredSignature =<br>              obj.doRSA(extractedSignature,<b>keys.e</b><br>                              ,keys.n,blockSize);<br><br>    String decodedSignature = obj.decode(<br>                            decipheredSignature);<br>    System.out.println(<br>             "Bob's decoded digital signature:\n"<br>                             + decodedSignature);<br><br><b>Listing 10</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>As you can see from a visual comparison, the result matches the original 
extended message shown in line 6 in Figure 1.&nbsp; It also matches the plain 
text portion of the message shown in line 10 of Figure 1.</p>
<p><font color="#FF0000"><b>The decode method</b></font></p>
<p>The decode method used here is essentially the same as the method having the 
same name that I explained in the previous lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.&nbsp; 
Therefore, I won't discuss that method further her.</p>
<p><font color="#FF0000"><b>Make an automated comparison</b></font></p>
<p>A visual comparison is OK for a short message such as this one.&nbsp; 
However, if the message were longer, Bob would need a better way to make the 
comparison in order to confirm that the decoded digital signature matches the 
plain text portion of the message.&nbsp; He accomplishes this using the <b>
equals</b> method of the <b>String</b> class in Listing 11.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    if(extractedMsgText.equals(decodedSignature))<br>    {<br>      System.out.println(<br>            "Bob's conclusion: Valid signature");<br>    }else{<br>      System.out.println(<br>          "Bob's conclusion: Invalid signature");<br>    }//end else<br><br>  }//end main<br><br><b>Listing 11</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p><font color="#FF0000"><b>A validation message</b></font></p>
<p>After making the comparison, the code in Listing 11 displays a message 
indicating whether or not the digital signature is valid.&nbsp; If the decoded 
digital signature exactly matches the plain text portion of the message, the 
signature is valid.&nbsp; Otherwise, it is invalid.&nbsp; The result is shown in 
the last line in Figure 1.</p>
<p><font color="#FF0000"><b>Conclusions regarding the program named Rsa04</b></font></p>
<p>If the digital signature is valid, Bob can conclude that the message was sent 
by Alice <i>(or someone having access to her private key).</i>&nbsp; Thus, the 
message has been <i>authenticated,</i> confirming the identities of the parties 
involved.</p>
<p>Bob can also conclude that the message was not modified by someone else 
during transmission <i>(unless that person had access to Alice's private key),</i> 
thus validating the integrity of the message.</p>
<p>On the other hand, if the digital signature is deemed to be invalid, Bob must 
conclude that either the <i>authenticity</i> or the <i>integrity</i> of the 
message is questionable.</p>
<p><font color="#FF0000"><b>The program named Rsa05</b></font></p>
<p>The program named <b>Rsa05</b> is somewhat more complicated than the previous 
program named <b>Rsa04</b>.</p>
<p><font color="#FF0000"><b>The program output</b></font></p>
<p>Before getting into the program details, let's take a look at the program 
output, as shown in Figure 2.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre><b>Alice's key values:
e: 17
d: 3869
n: 9617
Bob's key values:
e: 17
d: 7973
n: 9557
Extended message:
Hello Bob, how are you?-
Alice's digital signature
645654360346008475874713831303624383162618484532
Extended signed message:
Hello Bob, how are you?-_645654360346008475874713
831303624383162618484532-
Alice's encrypted signed message
3775134981462442655548020315575049268515315878533
1311740103502891756418117565793881488682309495851
7257280481681561515172572873118819371637165132096
2
Bob's deciphered and decoded message:
Hello Bob, how are you?-_645654360346008475874713
831303624383162618484532-
Extracted message text:
Hello Bob, how are you?-
Extracted digital signature:
645654360346008475874713831303624383162618484532
Deciphered and decoded digital signature:
Hello Bob, how are you?-
Valid signature</b><br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that line breaks were manually entered into the above text to force it 
to fit into this narrow publication format.</p>
<p>I will refer back to Figure 2 frequently during the discussion of this 
program.</p>
<p>IMPORTANT: BECAUSE THIS PROGRAM USES PREDETERMINED KEYS THAT WERE DESIGNED 
FOR A BLOCK SIZE OF 4, IT WILL WORK CORRECTLY ONLY FOR A BLOCK SIZE OF 4.</p>
<p><font color="#FF0000"><b>A different scenario</b></font></p>
<p>The program named <b>Rsa05</b> simulates a somewhat different scenario from 
the scenario simulated by <b>Rsa04</b>.</p>
<p>The purpose of this program is to illustrate the signing of an <i>encrypted</i> 
message along with the later decrypting of the message and the verification of 
the signature by the recipient.</p>
<p>The comments in this program make use of the scenario of Alice and Bob, which 
is common in discussions of the RSA encryption algorithm.</p>
<p><font color="#FF0000"><b>The supported character set</b></font></p>
<p>This program supports all of the ASCII characters from space (32) through ~ 
(126) inclusive.&nbsp; Thus, all of these characters may be used in the message.&nbsp;
<i>(Once again, however, the underscore character is used as a delimiter, so it 
cannot be used elsewhere in the message.)</i></p>
<p><font color="#FF0000"><b>Precomputed keys</b></font></p>
<p>This program uses two sets of precomputed key values for:</p>
<ul>
	<li>The public key e.</li>
	<li>The private key d.</li>
	<li>The modulus operand n.</li>
</ul>
<p>One set of keys belongs to Alice. The other set belongs to Bob.</p>
<p>Note that you can reverse the values of the public and private keys and the 
result will be the same so long as the keys are properly managed.&nbsp; You can 
encrypt with either key value so long as you decrypt using the other key value.</p>
<p><font color="#FF0000"><b>Finally, the scenario</b></font></p>
<p>Alice needs to send a signed encrypted message to Bob.</p>
<blockquote>
	<p><i>(Maybe Alice and Bob have a romantic interest in one another and she doesn't want Bob's wife 
	to be able to read her message.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A digital signature</b></font></p>
<p>Alice uses the RSA algorithm to create a digital signature for an unencrypted 
message.&nbsp; The digital signature is an encrypted version of the original 
message.&nbsp; She uses her private key to encrypt the original message in order 
to create the digital signature.&nbsp; Bob can later decrypt the digital 
signature using her public key.</p>
<p>Alice signs the message by appending the digital signature onto the end of 
the unencrypted message, with the signature being delimited from the unencrypted 
message by an underscore character.</p>
<blockquote>
	<p><i>(Bob will use the underscore character later to separate the message 
	from the digital signature.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Encrypting the signed message</b></font></p>
<p>Then Alice uses Bob's public key to encrypt the entire signed message 
including the digital signature.</p>
<blockquote>
	<p><i>(The digital signature has now been encrypted twice, once using 
	Alice's private key and once again using Bob's public key.)</i></p>
</blockquote>
<p>Bob's wife cannot read the message in this condition <i>(unless she has 
access to his private key).</i>&nbsp; However, 
encryption using Bob's public key by Alice makes it possible for Bob to decrypt the 
signed encrypted message using his private key.</p>
<p><font color="#FF0000"><b>Bob reads the message</b></font></p>
<p>Bob receives the encrypted message and decrypts <i>(and decodes)</i> it using his private key. At 
this point, he can view the unencrypted version of the message text along with 
the still encrypted digital signature.</p>
<blockquote>
	<p><i>(The digital signature has been encrypted twice, once using Alice's 
	private key and once using Bob's public key.&nbsp; However at this point, 
	the digital signature has been decrypted only once using Bob's private key, 
	so it is still not readable.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Decrypt the digital signature</b></font></p>
<p>Bob uses the position of the underscore character to separate the message 
text from the still encrypted digital signature.&nbsp; Then he uses Alice's 
public key to decrypt <i>(and decode)</i> the digital signature.&nbsp; He compares the result with 
the unencrypted message text.&nbsp; If they match, this verifies that the 
message was actually sent by Alice <i>(or someone who had access to Alice's 
private key).</i></p>
<p><font color="#FF0000"><b>Objectives achieved</b></font></p>
<p>Thus Alice was able to send a confidential message to Bob, which could be read 
only by Bob <i>(or by someone having access to Bob's private key).</i>&nbsp; 
Further, bob was able to confirm that the message was actually sent by Alice <i>
(or someone having access to Alice's private key) </i>and that the message was 
not modified in transient.&nbsp; Therefore, all three of the following 
objectives were met:</p>
<ul>
	<li><b>Authentication:</b> Confirming the identities of the parties 
	involved. </li>
	<li><b>Confidentiality:</b> Making certain that only authorized parties can 
	understand the message, even if it is intercepted by unauthorized persons. 
	</li>
	<li><b>Integrity:</b> Confirming that the content of the message wasn't 
	modified during transmission.</li>
</ul>
<p>If the unencrypted digital signature doesn't match the text of the message, 
the source or the integrity of the message is in question.</p>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>This program should not be used for production purposes. If you need a Java 
program for production use, you should develop it using Sun's
<a href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">
Java Cryptography Extension <i>(JCE)</i></a>.</p>
<p><font color="#FF0000"><b>Theoretical background</b></font></p>
<p>See the theoretical basis for the RSA algorithm at:
<a href="http://theory.lcs.mit.edu/~rivest/rsapaper.pdf">
http://theory.lcs.mit.edu/~rivest/rsapaper.pdf</a></p>
<p>Another good reference is at:&nbsp;&nbsp;
<a href="http://www.math.mtu.edu/mathlab/COURSES/holt/dnt/phi4.html">
http://www.math.mtu.edu/mathlab/COURSES/holt/dnt/phi4.html</a></p>
<p>This program was tested using SDK 1.5 and WinXP.</p>
<p><font color="#FF0000"><b>The class named Rsa05</b></font></p>
<p>Listing 12 shows the beginning of the class named <b>Rsa05.</b></p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>class Rsa05{
  static class Keys{
    BigInteger n;
    BigInteger d;
    BigInteger e;
  }//end inner class Keys<br><br><b>Listing 12</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 12 also defines a <b>static</b> inner class named<b> Keys</b>, whose sole purpose is to create an object that serves as a container for 
the keys.&nbsp; 
The class was made <b>static</b> so that it could be instantiated from within <b>main</b>.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>The beginning of the <b>main</b> method is shown in Listing 13.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    //Instantiate and populate an object
    // containing precomputed keys for Alice.
    Keys aliceKeys = new Keys();
    aliceKeys.n = new BigInteger("9617");
    aliceKeys.d = new BigInteger("3869");
    aliceKeys.e = new BigInteger("17");

    //Instantiate and populate an object
    // containing precomputed keys for Bob.
    Keys bobPar = new Keys();
    bobPar.n = new BigInteger("9557");
    bobPar.d = new BigInteger("7973");
    bobPar.e = new BigInteger("17");<br><br><b>Listing 13</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>The code in Listing 13 instantiates and populates two objects of the <b>Keys</b> 
class to contain the precomputed keys for Alice and Bob.&nbsp; The precomputed 
keys for Alice are stored in the object referred to by <b>aliceKeys</b>.&nbsp; 
Similarly, the precomputed keys for Bob are stored in the object referred to by
<b>bobPar</b>.</p>
<p><font color="#FF0000"><b>Create test message, set block size, etc.</b></font></p>
<p>The code in Listing 14 creates the test message that Alice will sign, 
encrypt, and send to Bob.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    //Original test message.
    String message = "Hello Bob, how are you?";

    //Set blockSize and make certain that it is
    // divisible by 2.
    int blockSize = 4;
    if(blockSize % 2 != 0){
      System.out.println(
                       "blockSize must be even");
      System.exit(1);
    }//end if

    //Instantiate an object of this class.
    Rsa05 obj = new Rsa05();<br><br><b>Listing 14</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 14 also sets the block size to 4 and instantiates an object of the <b>
Rsa05</b> class.</p>
<p><font color="#FF0000"><b>Display the precomputed key values</b></font></p>
<p>Listing 15 displays the precomputed key values for Alice and Bob.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    //Display Alice's keys.
    System.out.println("Alice's key values:");
    System.out.println("e: " + aliceKeys.e);
    System.out.println("d: " + aliceKeys.d);
    System.out.println("n: " + aliceKeys.n);

    //Display Bob's keys.
    System.out.println("Bob's key values:");
    System.out.println("e: " + bobPar.e);
    System.out.println("d: " + bobPar.d);
    System.out.println("n: " + bobPar.n);<br><br><b>Listing 15</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>The code in Listing 15 produces the first eight lines of output text in 
Figure 2.&nbsp; </p>
<p><font color="#FF0000"><b>Adjust the message length</b></font></p>
<p>The code in Listing 16 forces the message length to be a multiple of half the 
block length.&nbsp; Because the encoding technique, which converts the message 
to numeric form, creates two encoded characters for every character in the 
message, this forces the length of the encoded message to be a multiple of the 
block length.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    while(message.length()%(blockSize/2) != 0){
      //Append a visible character on the end.
      message += "-";
    }//end while
    System.out.println(
              "Extended message:\n" + message);<br><br><b>Listing 16</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>If the length of the original message is not a multiple of half the block 
length, the code in Listing 16 appends visible dash (-) characters to the end of 
the message to achieve the required length.</p>
<p>The code in Listing 16 also displays the extended message, producing the text 
shown in lines 9 and 10 in Figure 1.&nbsp; So far, this program is tracking 
right along with the previously-discussed program named <b>Rsa04</b>.</p>
<p><font color="#FF0000"><b>Create and display the digital signature</b></font></p>
<p>Following this, Alice creates the digital signature 
by:</p>
<ul>
	<li>Encoding the extended message into numeric format by invoking the <b>
	encode</b> method.&nbsp; <i>(This is the same <b>encode</b> method discussed 
	earlier.&nbsp; You can view the method in Listing 28 near the end of the 
	lesson.)</i></li>
	<li>Encrypting the encoded extended message by invoking the <b>doRSA</b> 
	method and passing her private key as one of the parameters to the method.&nbsp;
	<i>(Once again, this the same <b>doRSA</b> method discussed earlier.&nbsp; 
	You can also view this method in Listing 28 near the end of the lesson.)</i></li>
</ul>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String aliceEncodedText =
                             obj.encode(message);

    String aliceDigitalSignature =
          obj.doRSA(aliceEncodedText,aliceKeys.d,
                          aliceKeys.n,blockSize);
    System.out.println(
                    "Alice's digital signature\n"
                        + aliceDigitalSignature);<br><br><b>Listing 17</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>The above operations are shown in Listing 17.</p>
<p>Finally, the code in Listing 17 displays Alice's digital signature, producing 
lines 11 and 12 in Figure 2.</p>
<p><font color="#FF0000"><b>Sign the message</b></font></p>
<p>In Listing 18, Alice signs the message by appending the digital signature 
onto the end of the message.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String aliceSignedMsg =
           message + "_" + aliceDigitalSignature;<br><br><b>Listing 18</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Alice uses an underscore character to physically separate the digital 
signature from the message.&nbsp; Bob will use this underscore character later 
to identify the end of the message and the beginning of the digital signature.</p>
<p><font color="#FF0000"><b>Prepare for encryption</b></font></p>
<p>Up to this point, this program has been very similar to the previous program 
named <b>Rsa04</b>.&nbsp; However, the two programs diverge significantly at 
this point.&nbsp; Recall that Alice needs to send the message to Bob in such a 
way that it can only be read by Bob, or by someone having access to Bob's 
private key.&nbsp; To accomplish this, Alice will encrypt the signed message 
using Bob's public key.</p>
<p>In preparation for encrypting the signed message, Alice forces the length of 
the signed message to be a multiple of one-half the block length in Listing 19.&nbsp; 
Once again, Listing 19 appends visible dash (-) characters onto the end of the 
signed message, if necessary, to achieve the required length.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    while(aliceSignedMsg.length()%(blockSize/2)
                                           != 0){
      //Append a visible character on the end.
      aliceSignedMsg += "-";
    }//end while

    System.out.println(
                     "Extended signed message:\n"
                               + aliceSignedMsg);<br><br><b>Listing 19</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 19 also displays the extended signed message, producing lines 13, 14, 
and 15 in Figure 2.</p>
<blockquote>
	<p><i>(Note that a line break was manually inserted into line 14 in Figure 2 
	to force the material to fit in this narrow publication format.&nbsp; In 
	addition, line breaks were manually inserted into several subsequent lines 
	in Figure 2 for the same purpose.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Encode the signed message</b></font></p>
<p>Following this, Alice invokes the <b>encode</b> method to encode the signed 
message into numeric format in preparation for encryption.&nbsp; This is shown 
in Listing 20.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String aliceEncodedMsg = obj.encode(
                                 aliceSignedMsg);<br><br><b>Listing 20</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p><font color="#FF0000"><b>Encrypt the signed encoded message</b></font></p>
<p>Then Alice invokes the<b> doRSA</b> method to encrypt the signed encoded 
message using Bob's public key, as shown in Listing 21.&nbsp; <b>&nbsp;</b></p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String aliceCipherText = obj.doRSA(
                        aliceEncodedMsg,<b>bobPar.e</b>,
                             bobPar.n,blockSize);
                             
    System.out.println(
             "Alice's encrypted signed message\n"
                              + aliceCipherText);<br><br><b>Listing 21</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Only Bob or someone having access to Bob's secret key will be able to 
decrypt and read the signed message.</p>
<p>Listing 21 also displays the encrypted signed message, producing lines 16 
through 20 in Figure 2.</p>
<blockquote>
	<p><i>(Once again, line breaks were manually inserted in the encrypted 
	version to force it to fit in this narrow publication format.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Increased bandwidth required</b></font></p>
<p>It might be worth noting that the extending, signing, encoding, and 
encryption of the original message containing 23 characters resulted in an 
encrypted signed message containing 147 characters.&nbsp; Thus in this case, the 
length of the message that was transmitted was approximately six times the 
length of the original message.</p>
<p><font color="#FF0000"><b>A factor of three increase in length</b></font></p>
<p>The signing of the message extended its length by almost a factor of 3.&nbsp; 
For very long messages, the use of a message digest for the creation of the digital 
signature could reduce this factor significantly.&nbsp; However, for short 
messages such as this one, the use a message digest would provide very little 
improvement in the extension factor.</p>
<p><font color="#FF0000"><b>An additional factor of two increase in length</b></font></p>
<p>The encryption of the signed message increased the length again by 
approximately a factor of 2, resulting in an overall increase in the length by 
approximately a factor of 6.</p>
<p>Thus, there is a price to pay in terms of required transmission bandwidth for 
signing and encrypting a message.</p>
<p><font color="#FF0000"><b>Send the message</b></font></p>
<p>Up to this point, the program has been written from Alice's viewpoint.&nbsp; 
At this point, Alice sends the signed encrypted message to Bob, and the program 
viewpoint switches to Bob's viewpoint.&nbsp; </p>
<p><font color="#FF0000"><b>Decrypt and decode the signed encrypted message</b></font></p>
<p>Bob begins by invoking the <b>doRSA</b> method, using his private key to 
decrypt the signed encrypted message, as shown in Listing 22.&nbsp; Then he 
invokes the <b>decode</b> method to decode the message from numeric format back 
into text format.&nbsp; This is also shown in Listing 22.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String bobDecipheredMsg = obj.doRSA(
                        aliceCipherText,<b>bobPar.d</b>,
                             bobPar.n,blockSize);

    String bobDecodedMsg = obj.decode(
                               bobDecipheredMsg);
    System.out.println(
        "Bob's deciphered and decoded message:\n"
                                + bobDecodedMsg);<br><br><b>Listing 22</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Listing 22 also displays the decoded signed message producing the output text 
shown in lines 21 through 23 in Figure 2.&nbsp; As you might expect, the result 
is identical to Alice's extended signed message shown earlier in lines 13, 14, 
and 15 of Figure 2.</p>
<p><font color="#FF0000"><b>Separate the message from the digital signature</b></font></p>
<p>In Listing 23, Bob uses the position of the underscore character to extract 
the message text from the signed message.&nbsp; This produces the output shown 
in lines 24 and 25 in Figure 2.&nbsp; As might be expected, this matches Alice's 
extended message text shown in line 10 in Figure 2.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String bobMsgText = bobDecodedMsg.substring(
                   0,bobDecodedMsg.indexOf('_'));
    System.out.println(
                      "Extracted message text:\n"
                                   + bobMsgText);<br><br><b>Listing 23</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>At this point, however, Bob can't be certain that the message was actually 
sent by Alice, or if it was sent by Alice, that it wasn't modified somewhere 
along the way.&nbsp; In order to confirm the authenticity and integrity of the 
message, he needs to decrypt the digital signature and compare the result with 
the message produced by Listing 23.</p>
<p><font color="#FF0000"><b>Extract and display the digital signature</b></font></p>
<p>In Listing 24, Bob uses the position of the underscore character to extract 
the digital signature from the signed message.&nbsp; He knows that because of 
the use of the <b>RSA</b> algorithm to produce the digital signature, it can 
consist only of the numeric characters from 0 through 9.&nbsp; He removes any 
dash (-) characters at the end that were placed there by Alice to cause the signed 
message length to be a multiple of half the block length before she encrypted 
the message using Bob's public key.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String receivedSignature =
                bobDecodedMsg.substring(
                 bobDecodedMsg.indexOf('_') + 1);

    while(receivedSignature.endsWith("-")){
      receivedSignature =
               receivedSignature.substring(
                 0,receivedSignature.length()-1);
    }//end while
    System.out.println(
                 "Extracted digital signature:\n"
                            + receivedSignature);<br><br><b>Listing 24</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Then Listing 24 displays the extracted digital signature, producing the 
output shown in lines 26 and 27 in Figure 2.&nbsp; As might be expected, the 
digital signature received by Bob matches the digital signature created by Alice 
and displayed earlier in lines 11 and 12 of Figure 2.</p>
<p><font color="#FF0000"><b>Decrypt and decode the digital signature</b></font></p>
<p>Finally, Bob decrypts the digital signature using Alice's public key.&nbsp; 
He decodes and displays the result producing the output shown in lines 28 and 29 
of Figure 2.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    String decipheredSignature =
         obj.doRSA(receivedSignature,<b>aliceKeys.e</b>
                         ,aliceKeys.n,blockSize);
    String decodedSignature = obj.decode(
                            decipheredSignature);
    System.out.println(
    "Deciphered and decoded digital signature:\n"
                             + decodedSignature);<br><br><b>Listing 25</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p><font color="#FF0000"><b>Make a visual comparison</b></font></p>
<p>For this short message, Bob can visually compare the result with the 
extracted message text shown earlier in line 25 of Figure 2.&nbsp; Since the two 
are exactly the same, Bob can conclude not only that the encrypted signed 
message was sent by Alice <i>(or someone having access to her private key)</i> 
but also that the message was not modified in transit.&nbsp; However, had the 
two failed to compare favorably, either the authenticity or the integrity 
of the message would have been in question.</p>
<p><font color="#FF0000"><b>Make an automated comparison</b></font></p>
<p>For a long message, Bob might need some help in making the comparison.&nbsp; </p>
<p>Listing 26 uses the <b>equals</b> method of the <b>String</b> class to 
automatically compare the extracted message text <i>(line 25 in Figure 2)</i> 
with the decoded signature <i>(line 29 in Figure 2).</i></p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>    if(bobMsgText.equals(decodedSignature)){
      System.out.println("Valid signature");
    }else{
      System.out.println("Invalid signature");
    }//end else

  }//end main<br><br><b>Listing 26</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<p>Depending on the result of the comparison, the code in Listing 26 either 
validates or refuses to validate the authenticity and integrity of the message, 
producing the output shown in the last line in Figure 2.</p>
<p><font color="#FF0000"><b>End of program discussion</b></font></p>
<p>Listing 26 also signals the end of the <b>main</b> method and the end of the 
discussion of the program named <b>Rsa05</b>.&nbsp; All of the methods referred 
to but not discussed in detail above were previously discussed in the lesson entitled  
<a href="http://www.developer.com/java/ent/article.php/3447491">Public Key 
Cryptography 101 Using Java</a>.&nbsp; These methods can be viewed in Listing 27 
and Listing 28 near the end of the lesson.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2>
<p>I encourage you to copy, compile and run the following programs that
are provided in this lesson:</p>
<ul>
  <li>Rsa04</li>
	<li>Rsa05</li>
</ul>
<p>Experiment with the programs, making changes and observing the
results of your changes.</p>
<p>Above all, have fun and use these programs to learn as much as you
can about the theory behind and the mechanics of digital signatures
using public key cryptography as implemented using Java.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>There are numerous protocols that can be used along with public key 
cryptography and digital signatures to validate the authenticity and integrity 
of a message.</p>
<p>In this lesson, I explained one of those protocols for the use of digital 
signatures.&nbsp; Two scenarios were explained.&nbsp; In the first scenario, it 
was necessary to validate the authenticity and integrity of a message, but there 
was no requirement to keep the contents of the message secret.&nbsp; In the 
second scenario, it was necessary to keep the contents of the message secret in 
addition to validating the authenticity and integrity of the message.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>The next lesson in this series will teach you how to create message digests 
using the secure hash algorithm known as SHA-1.&nbsp; A subsequent lesson will 
show how to use a message digest for the creation of a digital signature.</p>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program
Listings</a></h2>
<p>Complete listings of the programs discussed in this lesson are
provided in Listing 27 and Listing 28 below.&nbsp; </p>
<p><font color="#ff0000"><b>A disclaimer</b></font></p>
<p>The programs that I am providing and explaining in this series of
lessons are not intended to be used for production cryptography.&nbsp;
If you need to do production cryptography using Java, you should use
<a
 href="http://java.sun.com/j2se/1.4/docs/guide/security/jce/JCERefGuide.html">Sun's
Java Cryptography Extension <i>(JCE)</i></a><i>.</i></p>
<p>The programs that I am providing were developed solely for
instructional purposes.&nbsp; They are intended to help you to
experiment with and to learn about various cryptosystems and
to gain a better understanding of how they work, and why they do what
they do.</p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>/*File Rsa04.java<br>Copyright 2004, R.G.Baldwin<br><br>IMPORTANT:  BECAUSE THIS PROGRAM USES<br>PREDETERMINED KEYS THAT WERE DESIGNED FOR A BLOCK<br>SIZE OF 4, IT WILL WORK CORRECTLY ONLY FOR A<br>BLOCK SIZE OF 4.<br><br>The purpose of this program is to illustrate the<br>signing of an unencrypted message along with the<br>later verification of the signature by the<br>receiver of the message.<br><br>The comments in this program reflect the<br>scenario of Alice and Bob, which is common in<br>discussions of RSA.<br><br>Alice needs to send a signed unencrypted message<br>to Bob.  The message needs to be signed so that<br>Bob can be confident that the message that he<br>received was sent by Alice and not by someone<br>pretending to be Alice.<br><br>First Alice creates a digital signature by<br>encrypting the message using her private key and<br>the RSA algorithm.  Bob can later decipher the<br>digital signature using Alice's public key.<br><br>Then Alice signs the message by appending the<br>digital signature onto the end of the unencrypted<br>message using an underscore character as the<br>delimiter between the text portion of the message<br>and the digital signature.  Bob will need the<br>delimiter later to separate the text portion of<br>the message from the digital signature.<br><br>Then Alice sends the signed message to Bob.<br><br>Bob separates the text portion of the message<br>from the digital signature.  Then he deciphers<br>the digital signature using Alice's public key.<br>The result should match the text portion of the<br>message.<br><br>Bob then compares the deciphered version of the<br>digital signature with the text portion of the<br>message.  If they match, he concludes that the<br>message was actually sent by Alice, or by someone<br>having access to her private key.  If they fail<br>to match, the actual source of the message is in<br>question.<br><br>This program supports all of the ASCII characters<br>from space (32) through ~ (126) inclusive to be<br>used in the message.<br><br>This program uses predetermined values for the<br>following:<br>Alice's public key, e<br>Alice's private key, d<br>Alice's modulus operand, n<br><br>This program should not be used for production<br>purposes.  If you need a Java program for<br>production use, you should develop it using Sun's<br>JCE API.<br><br>See the theoretical basis for the RSA algorithm<br>at:<br>http://theory.lcs.mit.edu/~rivest/rsapaper.pdf<br><br>Another good reference is at:<br>http://www.math.mtu.edu/mathlab/COURSES/holt/dnt<br>/phi4.html<br><br>Tested using SDK 1.5 and WinXP.  This program<br>produces the following output:<br><br>Alice's keys:<br>e: 17<br>d: 3869<br>n: 9617<br>Alice's extended message:<br>Hello Bob, how are you?-<br>Alice's digital signature<br>645654360346008475874713831303624383162618484532<br>Alice's signed message:<br>Hello Bob, how are you?-_645654360346008475874713<br>831303624383162618484532<br>Bob's extracted message text:<br>Hello Bob, how are you?-<br>Bob's extracted digital signature:<br>645654360346008475874713831303624383162618484532<br>Bob's decoded digital signature:<br>Hello Bob, how are you?-<br>Bob's conclusion: Valid signature<br><br>Note that line breaks were manually entered into<br>the above text to force it fit into this narrow<br>publication format.<br><br>Also note that you can reverse the values of the<br>two keys and get the same result.  In other<br>words, it doesn't matter which key you use to<br>sign the message as long as you use the other<br>key to decipher the digital signature.<br>************************************************/<br>import java.math.BigInteger;<br><br>class Rsa04{<br>  //This is a static inner class whose sole<br>  // purpose is to create an object that serves<br>  // as a container for keys.  It was made static<br>  // so that it can be instantiated from within<br>  // main.  It contains precomputed values for<br>  // the two keys, e and d, and the modulus<br>  // operand n.<br>  //<br>  // e is the public key<br>  // d is the private key<br>  static class Keys{<br>    BigInteger n = new BigInteger("9617");<br>    BigInteger d = new BigInteger("3869");<br>    BigInteger e = new BigInteger("17");<br>  }//end inner class Keys<br><br>  public static void main(String[] args){<br>    //Instantiate an object containing<br>    // keys.<br>    Keys keys = new Keys();<br><br>    //Raw test message.<br>    String message = "Hello Bob, how are you?";<br><br>    //Set blockSize<br>    int blockSize = 4;<br><br>    //Instantiate an object of this class<br>    Rsa04 obj = new Rsa04();<br><br>    //Display the key values along with the<br>    // modulus operand.<br>    System.out.println("Alice's keys:");<br>    System.out.println("e: " + keys.e);<br>    System.out.println("d: " + keys.d);<br>    System.out.println("n: " + keys.n);<br><br>    //Force the message length to be a multiple<br>    // of half the block length to avoid<br>    // end-effect problems later.<br>    while(message.length()%(blockSize/2) != 0){<br>      //Append a visible character on the end.<br>      message += "-";<br>    }//end while<br>    System.out.println(<br>                    "Alice's extended message:\n"<br>                                      + message);<br><br>    //Alice encodes the message into numeric<br>    // format.<br>    String encodedMsg = obj.encode(message);<br><br>    //Alice creates a digital signature by<br>    // encrypting the encoded message using her<br>    // private key.<br>    String signature = obj.doRSA(<br>            encodedMsg,keys.d, keys.n,blockSize);<br>    System.out.println(<br>                    "Alice's digital signature\n"<br>                                    + signature);<br><br>    //Alice signs the message by appending the<br>    // digital signature onto the message.  She<br>    // identifies the beginning of the digital<br>    // signature by the presence of an<br>    // underscore character.<br>    String signedMsg = message + "_" + signature;<br>    System.out.println(<br>                      "Alice's signed message:\n"<br>                                    + signedMsg);<br><br>    //Alice sends the message go Bob.  At the<br>    // receiving end, Bob extracts the message<br>    // text and the digital signature from the<br>    // signed message based on the location of<br>    // the underscore character.<br>    String extractedMsgText =<br>                     signedMsg.substring(<br>                       0,signedMsg.indexOf('_'));<br>    System.out.println(<br>                "Bob's extracted message text:\n"<br>                             + extractedMsgText);<br>    String extractedSignature =<br>                   signedMsg.substring(<br>                     signedMsg.indexOf('_') + 1);<br>    System.out.println(<br>           "Bob's extracted digital signature:\n"<br>                           + extractedSignature);<br><br>    //Bob deciphers and decodes the digital<br>    // signature using Alice's public key.  The<br>    // result should match the plain text portion<br>    // of the signed message.<br>    String decipheredSignature =<br>              obj.doRSA(extractedSignature,keys.e<br>                              ,keys.n,blockSize);<br><br>    String decodedSignature = obj.decode(<br>                            decipheredSignature);<br>    System.out.println(<br>             "Bob's decoded digital signature:\n"<br>                             + decodedSignature);<br><br>    //Bob compares the decoded digital signature<br>    // with the message text in the signed<br>    // message and displays a message indicating<br>    // whether or not the signature is valid.<br>    if(extractedMsgText.equals(decodedSignature))<br>    {<br>      System.out.println(<br>            "Bob's conclusion: Valid signature");<br>    }else{<br>      System.out.println(<br>          "Bob's conclusion: Invalid signature");<br>    }//end else<br><br>  }//end main<br>  //-------------------------------------------//<br><br>  //The purpose of this method is to encode a<br>  // plain text message into numeric format<br>  // where:<br>  // space = 32 - 32 = 0<br>  // A = 65 - 32 = 33<br>  // ...<br>  // Z = 90 - 32 = 58<br>  // ...<br>  // a = 97 - 32 = 65<br>  // ...<br>  // ~ = 126 - 32 = 94<br><br>  //Note that this encoding method supports all<br>  //of the ASCII characters from space through<br>  // tilde (~) inclusive.<br>  String encode(String message){<br>    byte[] textChars = message.getBytes();<br>    String temp = "";<br>    String encodedMsg = "";<br><br>    //Build the encoded text string two numeric<br>    // characters at a time.  Each message<br>    // character is converted into two numeric<br>    // characters according to the relationships<br>    // given above.<br>    for(int cnt = 0; cnt &lt; message.length();<br>                                          cnt++){<br>      temp = String.valueOf(<br>                       textChars[cnt] - ' ');<br>      //Convert all single-character numeric<br>      // values to two characters with a leading<br>      // zero, as in 09.<br>      if(temp.length() &lt; 2) temp = "0" + temp;<br>      encodedMsg += temp;<br>    }//end for loop<br>    return encodedMsg;<br>  }//end encode<br>  //-------------------------------------------//<br><br>  //The purpose of this method is to reverse the<br>  // encoding process implemented by the encode<br>  // method, converting a string of numeric<br>  // characters back to a text string containing<br>  // the ASCII characters from space through<br>  // tilde.<br>  String decode(String encodedMsg){<br>    String temp = "";<br>    String decodedText = "";<br>    for(int cnt = 0; cnt &lt; encodedMsg.length();<br>                                       cnt += 2){<br>      temp = encodedMsg.substring(cnt,cnt + 2);<br>      //Convert two numeric text characters to a<br>      // value of type int.<br>      int val = Integer.parseInt(temp) + 32;<br>      //Convert the ASCII character values to<br>      // numeric String values and build the<br>      // output String one character at a time.<br>      decodedText += String.valueOf((char)val);<br>    }//end for loop<br>    return decodedText;<br>  }//end decode<br>  //-------------------------------------------//<br><br>  //Apply the RSA algorithm to an input string<br>  // using the exponent exp and the modulus<br>  // operator n, which are provided as input<br>  // parameters.  This method can be used to<br>  // encrypt or to decipher the input string<br>  // depending on whether the exponent is an<br>  // encryption key or a decryption key.  Apply<br>  // the algorithm for the block size given by<br>  // the incoming parameter named blockSize.<br>  String doRSA(String inputString,<br>               BigInteger exp,<br>               BigInteger n,<br>               int blockSize){<br><br>    BigInteger block;<br>    BigInteger output;<br>    String temp = "";<br>    String outputString = "";<br><br>    //Iterate and process one block at a time.<br>    for(int cnt = 0; cnt &lt; inputString.length();<br>                               cnt += blockSize){<br>      //Get the next block of characters<br>      // and encapsulate them in a BigInteger<br>      // object.<br>      temp = inputString.substring(<br>                            cnt,cnt + blockSize);<br><br>      block = new BigInteger(temp);<br>      //Raise the block to the power exp, apply<br>      // the modulus operand n, and save the<br>      // remainder.  This is the essence of the<br>      // RSA algorithm.<br>      output = block.modPow(exp,n);<br><br>      //Convert the numeric result to a<br>      // four-character string, appending leading<br>      // zeros as necessary.<br>      temp = output.toString();<br>      while(temp.length() &lt; blockSize){<br>        temp = "0" + temp;<br>      }//end while<br><br>      //Build the outputString blockSize<br>      // characters at a time.  Each character<br>      // in the inputString results in one<br>      // character in the outputString.<br>      outputString += temp;<br>    }//end for loop<br><br>    return outputString;<br>  }//end doRSA<br>  //-------------------------------------------//<br>}//end class Rsa04<br><br><b>Listing 27</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>
<table bgcolor="#ffff00" border="1" cols="1" width="400">
  <tbody>
    <tr>
      <td>
      <pre>/*File Rsa05.java
Copyright 2004, R.G.Baldwin

IMPORTANT:  BECAUSE THIS PROGRAM USES
PREDETERMINED KEYS THAT WERE DESIGNED FOR A BLOCK
SIZE OF 4, IT WILL WORK CORRECTLY ONLY FOR A
BLOCK SIZE OF 4.

The purpose of this program is to illustrate the
signing of an encrypted message along with the
later deciphering of the message and the
verification of the signature by the recipient.

The comments in this program make use of the
scenario of Alice and Bob, which is common in
discussions of the RSA encryption algorithm.

This program supports all of the ASCII characters
from space (32) through ~ (126) inclusive to be
used in the message.

This program uses two sets of precomputed key
values for:
The public key e.
The private key d.
The modulus operand n.

One set of keys belongs to Alice.  The other set
belongs to Bob.

Note that you can reverse the values of the
public and private keys and the result will be
the same so long as the keys are properly
managed.  You can encrypt with either key value
so long as you decrypt using the other key
value.

Here is the scenario illustrated by this program:
Alice needs to send a signed encrypted message to
Bob.  She uses the RSA algorithm to create a
digital signature for an unencrypted message.
The digital signature is an encrypted version of
the same message that she encrypts using her
private key.  Bob can later decipher the
digital signature using her public key.

Alice signs the message by appending the digital
signature onto the end of the unencrypted
message, with the signature being delimited from
the message by an underscore character.  Bob
needs to know how the two are delimited so that
he can extract the digital signature from the
deciphered signed message later.

Then Alice uses Bob's public key to encrypt the
entire signed message including the digital
signature.  This makes it possible for Bob to
decipher the signed message using his private
key.

Bob receives the encrypted message and deciphers
it using his private key.  At this point, he can
view the unencrypted version of the message text
along with the still encrypted digital signature.
(The digital signature had actully been encrypted
twice, once using Alice's private key and once
using Bob's public key.)

Bob separates the message text from the still
encrypted digital signature.

Then Bob uses Alice's public key to decipher the
digital signature and compares the result with
the unencrypted message text.  If they match,
this verifies that the message was actually sent
by Alice (or someone who has access to her
private key).  If they don't match, the actual
source of the message is in question.

This program should not be used for production
purposes.  If you need a Java program for
production use, you should develop it using Sun's
JCE API.

See the theoretical basis for the RSA algorithm
at:
http://theory.lcs.mit.edu/~rivest/rsapaper.pdf

Another good reference is at:
http://www.math.mtu.edu/mathlab/COURSES/holt/dnt
/phi4.html

Tested using SDK 1.5 and WinXP.  This program
produces the following output:

Alice's key values:
e: 17
d: 3869
n: 9617
Bob's key values:
e: 17
d: 7973
n: 9557
Extended message:
Hello Bob, how are you?-
Alice's digital signature
645654360346008475874713831303624383162618484532
Extended signed message:
Hello Bob, how are you?-_645654360346008475874713
831303624383162618484532-
Alice's encrypted signed message
3775134981462442655548020315575049268515315878533
1311740103502891756418117565793881488682309495851
7257280481681561515172572873118819371637165132096
2
Bob's deciphered and decoded message:
Hello Bob, how are you?-_645654360346008475874713
831303624383162618484532-
Extracted message text:
Hello Bob, how are you?-
Extracted digital signature:
645654360346008475874713831303624383162618484532
Deciphered and decoded digital signature:
Hello Bob, how are you?-
Valid signature

Note that line breaks were manually entered into
the above text to force it fit into this narrow
publication format.
************************************************/
import java.math.BigInteger;

class Rsa05{
  //This is a static inner class whose sole
  // purpose is to create an object that serves
  // as a container for keys.  It was made static
  // so that it can be instantiated from within
  // main.

  static class Keys{
    BigInteger n;
    BigInteger d;
    BigInteger e;
  }//end inner class Keys

  public static void main(String[] args){
    //Instantiate and populate an object
    // containing precomputed keys for Alice.
    Keys aliceKeys = new Keys();
    aliceKeys.n = new BigInteger("9617");
    aliceKeys.d = new BigInteger("3869");
    aliceKeys.e = new BigInteger("17");

    //Instantiate and populate an object
    // containing precomputed keys for Bob.
    Keys bobPar = new Keys();
    bobPar.n = new BigInteger("9557");
    bobPar.d = new BigInteger("7973");
    bobPar.e = new BigInteger("17");

    //Original test message.
    String message = "Hello Bob, how are you?";

    //Set blockSize and make certain that it is
    // divisible by 2.
    int blockSize = 4;
    if(blockSize % 2 != 0){
      System.out.println(
                       "blockSize must be even");
      System.exit(1);
    }//end if

    //Instantiate an object of this class.
    Rsa05 obj = new Rsa05();

    //Display Alice's keys.
    System.out.println("Alice's key values:");
    System.out.println("e: " + aliceKeys.e);
    System.out.println("d: " + aliceKeys.d);
    System.out.println("n: " + aliceKeys.n);

    //Display Bob's keys.
    System.out.println("Bob's key values:");
    System.out.println("e: " + bobPar.e);
    System.out.println("d: " + bobPar.d);
    System.out.println("n: " + bobPar.n);

    //Force the message length to be a multiple
    // of half the block length to avoid
    // end-effect problems later.
    while(message.length()%(blockSize/2) != 0){
      //Append a visible character on the end.
      message += "-";
    }//end while
    System.out.println(
              "Extended message:\n" + message);

    //Alice encodes the extended message into
    // numeric format.
    String aliceEncodedText =
                             obj.encode(message);

    //Alice creates a digital signature by
    // encrypting the encoded message using her
    // private key.
    String aliceDigitalSignature =
          obj.doRSA(aliceEncodedText,aliceKeys.d,
                          aliceKeys.n,blockSize);
    System.out.println(
                    "Alice's digital signature\n"
                        + aliceDigitalSignature);

    //Alice signs the message by appending the
    // digital signature onto the message.  She
    // identifies the beginning of the digital
    // signature by the presence of an
    // underscore character.
    String aliceSignedMsg =
           message + "_" + aliceDigitalSignature;

    //Alice forces the signed message length to
    // be a multiple of half the block length to
    // avoid end-effect problems later.
    while(aliceSignedMsg.length()%(blockSize/2)
                                           != 0){
      //Append a visible character on the end.
      aliceSignedMsg += "-";
    }//end while

    System.out.println(
                     "Extended signed message:\n"
                               + aliceSignedMsg);

    //Alice encodes the signed message to get it
    // ready for encryption.
    String aliceEncodedMsg = obj.encode(
                                 aliceSignedMsg);

    //Alice encrypts the signed message using
    // Bob's public key.
    String aliceCipherText = obj.doRSA(
                        aliceEncodedMsg,bobPar.e,
                             bobPar.n,blockSize);
                             
    System.out.println(
             "Alice's encrypted signed message\n"
                              + aliceCipherText);

    //Alice sends the cipherText to Bob.  Bob
    // deciphers the message using his private
    // key.
    String bobDecipheredMsg = obj.doRSA(
                        aliceCipherText,bobPar.d,
                             bobPar.n,blockSize);

    //Bob decodes the deciphered message.
    String bobDecodedMsg = obj.decode(
                               bobDecipheredMsg);
    System.out.println(
        "Bob's deciphered and decoded message:\n"
                                + bobDecodedMsg);

    //Bob extracts the message text and the
    // digital signature from the decoded
    // signed message based on the location of
    // the underscore character.
    String bobMsgText = bobDecodedMsg.substring(
                   0,bobDecodedMsg.indexOf('_'));
    System.out.println(
                      "Extracted message text:\n"
                                   + bobMsgText);
    String receivedSignature =
                bobDecodedMsg.substring(
                 bobDecodedMsg.indexOf('_') + 1);

    //Bob removes any dashes at the end of the
    // digital signature that were put there by
    // Alice to force the signed message length
    // to be a multiple of half the block size.
    while(receivedSignature.endsWith("-")){
      receivedSignature =
               receivedSignature.substring(
                 0,receivedSignature.length()-1);
    }//end while
    System.out.println(
                 "Extracted digital signature:\n"
                            + receivedSignature);

    //Bob deciphers and decodes the digital
    // signature using the Alice's public key.
    // The result should match the text portion
    // of the signed message.
    String decipheredSignature =
         obj.doRSA(receivedSignature,aliceKeys.e
                         ,aliceKeys.n,blockSize);
    String decodedSignature = obj.decode(
                            decipheredSignature);
    System.out.println(
    "Deciphered and decoded digital signature:\n"
                             + decodedSignature);

    //Bob compares the decoded digital signature
    // with the message text in the signed
    // message and displays a message indicating
    // whether or not the signature is valid.
    if(bobMsgText.equals(decodedSignature)){
      System.out.println("Valid signature");
    }else{
      System.out.println("Invalid signature");
    }//end else

  }//end main
  //-------------------------------------------//

  //The purpose of this method is to encode a
  // plain text message into numeric format
  // where:
  // space = 32 - 32 = 0
  // A = 65 - 32 = 33
  // ...
  // Z = 90 - 32 = 58
  // ...
  // a = 97 - 32 = 65
  // ...
  // ~ = 126 - 32 = 94

  //Note that this encoding method supports all
  //of the ASCII characters from space through
  // tilde (~) inclusive.
  String encode(String message){
    byte[] textChars = message.getBytes();
    String temp = "";
    String encodedText = "";

    //Build the encoded text string two numeric
    // characters at a time.  Each message
    // character is converted into two numeric
    // characters according to the relationships
    // given above.
    for(int cnt = 0; cnt < message.length();
                                          cnt++){
      temp = String.valueOf(
                       textChars[cnt] - ' ');
      //Convert all single-character numeric
      // values to two characters with a leading
      // zero, as in 09.
      if(temp.length() < 2) temp = "0" + temp;
      encodedText += temp;
    }//end for loop
    return encodedText;
  }//end encode
  //-------------------------------------------//

  //The purpose of this method is to reverse the
  // encoding process implemented by the encode
  // method, converting a string of numeric
  // characters back to a text string containing
  // the ASCII characters from space through
  // tilde.
  String decode(String encodedText){
    String temp = "";
    String decodedText = "";
    for(int cnt = 0; cnt < encodedText.length();
                                       cnt += 2){
      temp = encodedText.substring(cnt,cnt + 2);
      //Convert two numeric text characters to a
      // value of type int.
      int val = Integer.parseInt(temp) + 32;
      //Convert the ASCII character values to
      // numeric String values and build the
      // output String one character at a time.
      decodedText += String.valueOf((char)val);
    }//end for loop
    return decodedText;
  }//end decode
  //-------------------------------------------//

  //Apply the RSA algorithm to an input string
  // using the exponent exp and the modulus
  // operator n, which are provided as input
  // parameters.  This method can be used to
  // encrypt or to decipher the input string
  // depending on whether the exponent is an
  // encryption key or a decryption key.  Apply
  // the algorithm for the block size given by
  // the incoming parameter named blockSize.
  String doRSA(String inputString,
               BigInteger exp,
               BigInteger n,
               int blockSize){

    BigInteger block;
    BigInteger output;
    String temp = "";
    String outputString = "";

    //Iterate and process one block at a time.
    for(int cnt = 0; cnt < inputString.length();
                               cnt += blockSize){
      //Get the next block of characters
      // and encapsulate them in a BigInteger
      // object.
      temp = inputString.substring(
                            cnt,cnt + blockSize);

      block = new BigInteger(temp);
      //Raise the block to the power exp, apply
      // the modulus operand n, and save the
      // remainder.  This is the essence of the
      // RSA algorithm.
      output = block.modPow(exp,n);

      //Convert the numeric result to a
      // four-character string, appending leading
      // zeros as necessary.
      temp = output.toString();
      while(temp.length() < blockSize){
        temp = "0" + temp;
      }//end while

      //Build the outputString blockSize
      // characters at a time.  Each character
      // in the inputString results in one
      // character in the outputString.
      outputString += temp;
    }//end for loop

    return outputString;
  }//end doRSA
  //-------------------------------------------//
}//end class Rsa05

<br><b>Listing 28</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p></p>
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About_the_author">About the author</a></h4>
<b><a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and
XML. In addition to the many platform and/or language independent
benefits
of Java and C# applications, he believes that a combination of Java,
C#,
and XML will become the primary driving force in the delivery of
structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years
of practical experience in Digital Signal Processing (DSP).&nbsp; His
first job after he earned his Bachelor's degree was doing DSP in the
Seismic Research Department of Texas Instruments.&nbsp; (TI is still a
world leader in DSP.)&nbsp; In the following years, he applied his
programming and DSP expertise to other interesting areas including
sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology
to real-world problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</body>
</html>
