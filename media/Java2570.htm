<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Getting Started with MIDlets and the Sun Java Wireless Toolkit for CLDC</h2>
Learn how to 
write a Java programming framework that makes it easy to experiment with MIDLets 
(Java programs for embedded devices) and the Sun Java Wireless Toolkit for CLDC 
(Connected Limited Device Configuration)<p>experimenting with MIDlet 
programming easy.</p>
<p><b>Published:</b>&nbsp; January 1, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2570</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_MIDlet_program_named_WTK001">The MIDlet program named WTK001</a></li>
		<li><a href="#The_batch_file_approach">The batch file approach</a></li>
		<li><a href="#The_framework_program_named_WTKFramework01">The framework 
		program named WTKFramework01</a></li>
	</ul>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> This is the first lesson in a series of tutorial lessons designed to teach<br>
you how to write programs using the Sun Java Wireless Toolkit for CLDC<br>
<i>(Connected Limited Device Configuration.)</i>.&nbsp; 
According to Sun <i>(see <a href="#Resources">Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;The Sun Java Wireless Toolkit (formerly known as J2ME Wireless Toolkit) 
	is a set of tools for creating Java applications that run on devices 
	compliant with the <a href="http://java.sun.com/products/jtwi/">Java 
	Technology for the Wireless Industry (JTWI, JSR 185)</a> specification and 
	the Mobile Service Architecture (MSA, JSR 248) specification.&quot;</i></p>
</blockquote>
<p> Stated more simply, the toolkit is used to create Java programs capable of 
running on small devices having limited resources such as cell phones.</p>
<p> <font color="#FF0000"><b>What is a MIDlet?</b></font></p>
<p> In this series of lessons, I will start from scratch and help you work your way up to the point where you can write simple 
games and produce simple multimedia on cell phones.&nbsp; Such a program is 
often called a MIDlet.&nbsp; According to Wikipedia <i>(see <a href="#Resources">
Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;A MIDlet is a Java program for embedded devices, more specifically the 
	Java ME virtual machine. Generally, these are games and applications that 
	run on a cell phone.&quot;</i></p>
</blockquote>
<p> According to the SCMAD Certification Center <i>(see <a href="#Resources">
Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;A MIDlet is an application written for MIDP. MIDlet applications are 
	subclasses of the javax.microedition.midlet.MIDlet class that is defined by 
	MIDP.&quot;</i></p>
</blockquote>
<p>In this first lesson, I will present some general background information 
about MIDlets and provide you with a Java programming framework that makes it 
easy to experiment with the programming of MIDlets.</p>
<h3> <a name="General">General</a></h3>
<p> The <a name="following_steps">following steps</a> are required to produce a MIDlet and to get it running in a cell 
phone:</p>
<ol>
	<li>Design the MIDlet <i>(similar to designing any Java program).</i></li>
	<li>Write the program code <i>(similar to coding any Java program).</i></li>
	<li>Compile the code <i>(targeted to a Java v1.4 virtual machine, a specific 
	version of the CLDC, and a specific version of the MIDP).</i></li>
	<li>Pre-verify the compiled code.</li>
	<li>Create a manifest file.</li>
	<li>Create a <b>J</b>ava <b>AR</b>chive <i>(JAR)</i> file.</li>
	<li>Create a Java Application Descriptor <i>(JAD)</i> file.</li>
	<li>Test the MIDlet in a cell phone emulator.</li>
	<li><a name="Deploy_the_MIDlet_into_a_cell_phone">Deploy the MIDlet into a cell phone</a>.</li>
</ol>
<p> The Java framework program that I will present in this lesson handles items 3 
through 8 in the above list with the single click of a button.&nbsp; I will 
discuss items 1 and 2 in some detail in subsequent lessons.</p>
<p> <font color="#FF0000"><b>The final product - a MIDlet suite</b></font></p>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>Other file types</b><br>
				Future lessons will update the MIDlet-programming framework to 
				accommodate image files and other specialized file types as 
				well.
				</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<p>In the final analysis, only the JAR file and the JAD file are required to 
deploy the MIDlet into a cell phone.&nbsp; Together these two are called a 
MIDlet suite <i>(see MIDlet Life Cycle in <a href="#Resources">Resources</a>)</i>. Therefore, the 
MIDlet-programming framework program that I will 
present cleans up after itself, automatically deleting all of the extraneous 
files that are created during the MIDlet development process, leaving only the 
source code files, the JAR file, and the JAD file.</p>
<p> I will leave it up to you to research the web and learn how to deploy a 
MIDlet into your particular brand and model number cell phone <i>(see
<a href="#Deploy_the_MIDlet_into_a_cell_phone">item 9</a>)</i>.&nbsp; 
There is a wealth of information available on that topic on various web sites.</p>
<p> <font color="#FF0000"><b>Acknowledgement</b></font></p>
<p> I would be remiss if I failed to mention the articles published by Vikram Goyal 
and others on this topic <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; It was those articles that got me started down the 
path to learning about MIDlet programming.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. User interface for the framework 
	program.</li>
	<li><a href="#Figure_2">Figure 2</a>. Sun's cell phone emulator program.</li>
	<li><a href="#Figure_3">Figure 3</a>. Usage instructions for the preverify 
	method.</li>
	<li><a href="#Figure_4">Figure 4</a>. Required contents for the manifest 
	file.</li>
	<li><a href="#Figure_5">Figure 5</a>. Minimum requirements for a JAD file.</li>
	<li><a href="#Figure_6">Figure 6</a>. Typical screen output from 
	deleteOldStuff method.</li>
	<li><a href="#Figure_7">Figure 7</a>. Typical output from the compile 
	process.</li>
	<li><a href="#Figure_8">Figure 8</a>. Typical screen output for 
	preverification process.</li>
	<li><a href="#Figure_9">Figure 9</a>. Screen output from deleting class 
	files.</li>
	<li><a href="#Figure_10">Figure 10</a>. Screen output from moving files.</li>
	<li><a href="#Figure_11">Figure 11</a>. The screen output from making the 
	JAR file.</li>
	<li><a href="#Figure_12">Figure 12</a>. The screen output for the cleanup 
	phase.</li>
	<li><a href="#Figure_13">Figure 13</a>. The cell phone emulator with the 
	MIDlet loaded.</li>
	<li><a href="#Figure_14">Figure 14</a>. The cell phone emulator with the 
	MIDlet running.</li>
	<li><a href="#Figure_15">Figure 15</a>. Screen output produced by the 
	runEmulator method.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the top-level class for 
	WTK001.</li>
	<li><a href="#Listing_2">Listing 2</a>. Instantiate an object of LocalClass.</li>
	<li><a href="#Listing_3">Listing 3</a>. Inherited abstract methods.</li>
	<li><a href="#Listing_4">Listing 4</a>. The member class named MemberClass.</li>
	<li><a href="#Listing_5">Listing 5</a>. The compilation batch file named 
	1-Compile.bat.</li>
	<li><a href="#Listing_6">Listing 6</a>. A sample text file named 
	2-Classes.txt.</li>
	<li><a href="#Listing_7">Listing 7</a>. The batch file named&nbsp; 
	3-Preverify.bat.</li>
	<li><a href="#Listing_8">Listing 8</a>. Batch file named 
	4-MakeManifestFile.bat.</li>
	<li><a href="#Listing_9">Listing 9</a>. The batch file named 
	5-MakeJarFile.bat.</li>
	<li><a href="#Listing_10">Listing 10</a>. The batch file named 
	6-MakeJadFile.bat.</li>
	<li><a href="#Listing_11">Listing 11</a>. The batch file named 7-Run.bat.</li>
	<li><a href="#Listing_12">Listing 12</a>. Beginning of class named 
	WTKFramework01.</li>
	<li><a href="#Listing_13">Listing 13</a>. The main method.</li>
	<li><a href="#Listing_14">Listing 14</a>. Beginning of the inner class named 
	GUI.</li>
	<li><a href="#Listing_15">Listing 15</a>. Specifying default radio buttons.</li>
	<li><a href="#Listing_16">Listing 16</a>. An anonymous ActionListener class.</li>
	<li><a href="#Listing_17">Listing 17</a>. Make the GUI visible.</li>
	<li><a href="#Listing_18">Listing 18</a>. Beginning of method named 
	runTheProgram.</li>
	<li><a href="#Listing_19">Listing 19</a>. Delete leftover files from a 
	previous run.</li>
	<li><a href="#Listing_20">Listing 20</a>. Beginning of the method named 
	deleteOldStuff.</li>
	<li><a href="#Listing_21">Listing 21</a>. The beginning of the method named 
	deleteOutputSubDir.</li>
	<li><a href="#Listing_22">Listing 22</a>. Delete the subdirectory proper.</li>
	<li><a href="#Listing_23">Listing 23</a>. Delete old manifest, JAR, and JAD 
	files.</li>
	<li><a href="#Listing_24">Listing 24</a>. Delete old class files from the 
	program directory.</li>
	<li><a href="#Listing_25">Listing 25</a>. The method named 
	deleteProgClassFiles.</li>
	<li><a href="#Listing_26">Listing 26</a>. Compile the MIDlet.</li>
	<li><a href="#Listing_27">Listing 27</a>. Beginning of the method named 
	compile.</li>
	<li><a href="#Listing_28">Listing 28</a>. Delay until compilation is 
	complete.</li>
	<li><a href="#Listing_29">Listing 29</a>. Preverify the class files.</li>
	<li><a href="#Listing_30">Listing 30</a>. Beginning of the preverify method.</li>
	<li><a href="#Listing_31">Listing 31</a>. Continuation of the preverify for 
	loop.</li>
	
	<li><a href="#Listing_32">Listing 32</a>. Delay until preverification is 
	complete.</li>
	<li><a href="#Listing_33">Listing 33</a>. Delete the class files from the 
	program directory.</li>
	<li><a href="#Listing_34">Listing 34</a>. Move the preverified files to the 
	original program directory.</li>
	<li><a href="#Listing_35">Listing 35</a>. Make the manifest file.</li>
	<li><a href="#Listing_36">Listing 36</a>. Make the JAR file.</li>
	<li><a href="#Listing_37">Listing 37</a>. The method named makeJarFile.</li>
	<li><a href="#Listing_38">Listing 38</a>. Make the JAD file.</li>
	<li><a href="#Listing_39">Listing 39</a>. Clean up the disk.</li>
	<li><a href="#Listing_40">Listing 40</a>. Running the emulator.</li>
	<li><a href="#Listing_41">Listing 41</a>. The runEmulator method.</li>
	<li><a href="#Listing_42">Listing 42</a>. The MIDlet program named WTK001.</li>
	<li><a href="#Listing_43">Listing 43</a>. The framework program named 
	WTKFramework01.java.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#FF0000"><b>Design and coding</b></font></p>
<p>In an earlier section, I provided a <a href="#following_steps">list</a> of nine steps that are required to 
get a MIDlet up and running in a cell phone.&nbsp; The first two steps are 
similar to the design and coding steps required for the writing of any Java 
program.&nbsp; Of course, when designing and coding a MIDlet, you must be 
cognizant of the fact that a cell phone has very limited resources as compared 
to a modern desktop or laptop computer.&nbsp; According to Goyal <i>(see
<a href="#Resources">Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;The most popular profile and configuration that Sun provides are the 
	Mobile Information Device Profile (MIDP) and Connected Limited Device 
	Configuration (CLDC), respectively. As the name suggests, CLDC is for 
	devices with limited configurations; for example, devices that have only 128 
	to 512KB of memory available for Java applications. Consequently, the JVM 
	that it provides is very limited and supports only a small number of 
	traditional Java classes. (This limited JVM is actually called the KVM.)&quot;</i></p>
</blockquote>
<p>Also, as anyone who has ever used a cell phone is aware, the size of the 
screen in pixels is generally much smaller than the size of the screen on a 
typical desktop or laptop computer.</p>
<p><font color="#FF0000"><b>Compiling the code</b></font></p>
<p>As you will see later, you can use Sun's standard <b>javac.exe</b> program to 
compile your MIDlet.&nbsp; However, you must make 
adjustments so that the compiler will use the classes in the wireless toolkit 
library in place of the classes in the standard J2SE library.</p>
<p>When using version 2.5.2 of the wireless toolkit, you have your choice of two 
different CLDC libraries and three different MIDP libraries.&nbsp; The choice of 
which you should use depends on the brands and model numbers of the targeted 
cell phones.&nbsp; Different cell phones accommodate different programming 
features.&nbsp; The different libraries in the toolkit provide those different 
features.&nbsp; Sun provides <span class="style2">The Java ME Device Table
<i>(see <a href="#Resources">Resources</a>)</i> to help you decide which 
libraries you should target when compiling&nbsp;your MIDlet.</span></p>
<p><font color="#FF0000">
 <b>User interface for the framework program</b></font></p>
<p>Figure 1 shows a screen shot of the user interface for the Java WTK framework 
program that I will provide in this lesson.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. User interface for the framework program. </b>
<table border="0" cols="0" bgcolor="#ffffff" id="table1">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2570a1.jpg" width="401" height="251"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you can see from Figure 1, this framework program <span class="style2">makes 
it easy for you to select a specific CLDC and a specific MIDP during the 
compilation process simply by selecting two radio buttons before clicking the <b>
Run</b> button.&nbsp; <i>(Even these selections have the default values shown 
in Figure 1, so if you are satisfied with those selections, you can simply enter 
the name of your program and click the <b>Run</b> button.)</i></span></p>
<p><font color="#FF0000"><b>Which Java version should you use?</b></font></p>
<p>Here is a quotation from Goyal's article <i>(see <a href="#Resources">
Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;Warning: I had problems getting the Wireless Toolkit to work properly 
	with JDK 5.0. If you don't need the latest features in version 5.0, it is 
	best to stick to any 1.4.2 version.&quot;</i></p>
</blockquote>
<p><a name="I_have_independently">I have independently</a> and experimentally confirmed that Sun's WTK2.5.2 also won't work properly 
with Sun's Java standard edition v1.6.&nbsp; Rather, it is necessary to compile 
the MIDlet code in such a way as to make it compatible with Sun's Java virtual 
machine v1.4.&nbsp; I will show you how to do that later when I discuss the code 
in my framework program.</p>
<p><font color="#FF0000"><b>The pre-verification step</b></font></p>
<p>Referring back to the earlier <a href="#following_steps">list</a>, we see 
that when grouped together, the remaining steps following compilation consist 
of:</p>
<ul>
	<li>Pre-verifying the compiled MIDlet code</li>
	<li>Packaging the pre-verified MIDlet code in a JAR file with an 
	accompanying JAD file</li>
	<li>Testing the MIDlet</li>
	<li>Deploying the MIDlet</li>
</ul>
<p>Goyal explains the purpose of the pre-verification step quite well <i>(see
<a href="#Resources">Resources</a>)</i>, so I won't repeat that information in 
this lesson.&nbsp; Suffice it to say that this step involves executing a 
WTK2.5.2 program named <b>preverify.exe</b> <i>(with the proper command-line 
parameters)</i> to transform the collection of class files produced by the 
compiler into a collection of class files that will execute more efficiently in 
the cell phone.</p>
<p><font color="#FF0000"><b>Packaging the MIDlet for testing and deployment</b></font></p>
<p>Following the pre-verification step, packaging the MIDlet for testing and 
deployment consists of the following three individual steps:</p>
<ul>
	<li>Create a manifest file.</li>
	<li>Encapsulate the manifest file and the pre-verified class files in a 
	JAR file.</li>
	<li>Create a JAD file that describes the JAR file.</li>
</ul>
<p>These three steps are rather mechanical.&nbsp; I will explain how to 
accomplish them later when we examine the code in my framework program.</p>
<p><font color="#FF0000"><b>Testing the MIDlet</b></font></p>
<p>Fortunately, the WTK2.5.2 contains a cell phone emulator program that can be 
used to test your MIDlet before committing it to actual cell phone hardware.&nbsp; 
Figure 2 shows a screen shot of the emulator running a simple MIDlet that 
displays my name on the screen.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Sun's cell phone emulator program. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table2">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2570a2.jpg" width="323" height="721"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I will show you how to use the emulator to test your MIDlet later in the 
detailed discussion of my framework program.</p>
<p><font color="#FF0000"><b>Deploying the MIDlet</b></font></p>
<p>Once again, Goyal provides a good discussion of the various options that are 
available for deploying your MIDlet onto actual cell phone hardware, so I won't 
duplicate that discussion in this series of lessons.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>I plan to accomplish the following tasks in this lesson:</p>
<ol>
	<li>Teach you how to develop and test a MIDlet by executing a series of 
	batch command files.</li>
	<li>Demonstrate that WTK2.5.2 supports both local classes and member classes 
	in a MIDlet.</li>
	<li>Teach you about my framework program for the development 
	and testing of MIDlets.</li>
	<li>Teach you how to use my framework program for the development 
	and testing of MIDlets.</li>
</ol>
<p><font color="#FF0000"><b>Four ways to develop and test a MIDlet</b></font></p>
<p>I know of at least four ways that you can develop and test a MIDlet program:</p>
<ol>
	<li>By entering a series of tedious and complex commands at the command 
	line.</li>
	<li>By executing a series of batch files that essentially encapsulate those 
	commands.</li>
	<li>By running the Wireless Toolkit program.</li>
	<li>By running the framework program that I will provide in this lesson.</li>
</ol>
<p><font color="#FF0000"><b>Executing commands at the command line</b></font></p>
<p>Goyal shows you how to do this in his first article <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; While the process isn't complex, 
it is extremely tedious and prone to problems resulting from typing errors.&nbsp; 
Therefore, I don't recommend this approach.</p>
<p><font color="#FF0000"><b>Executing batch files</b></font></p>
<p>In effect, the batch files contain the same commands that you would execute 
at the command line if you were to take that approach.&nbsp; While the use of 
batch files is not ideal, it is&nbsp;much less tedious than executing commands 
at the command line.&nbsp; At least when you use batch files, you can gracefully 
correct your typing errors, and the process is entirely repeatable.</p>
<p>There are some good aspects to using batch files, particularly with respect 
to understanding what is going on.&nbsp; I will present and explain six batch 
files and an associated text file that you can customize for your own use.</p>
<p><font color="#FF0000"><b>Running the Wireless Toolkit program</b></font></p>
<p>Once you have become proficient in programming MIDlets and start doing such 
programming in a serious way, this may be your best approach.&nbsp; However, it 
has some problems, which in my opinion, diminish its value during the learning 
phase.</p>
<p><font color="#FF0000"><b>Java version compatibility</b></font></p>
<p>Perhaps the most important problem with the Wireless Toolkit program has to do with a compatibility issue 
between the toolkit program and versions of J2SE beyond v1.4. Cell 
phones capable of executing MIDlets contain a small Java Virtual Machine.&nbsp; 
Apparently the virtual machine in the WTK2.5.2 emulator is not compatible with 
the bytecode produced by J2SE v1.5 and J2SE v1.6.&nbsp; I will show you how to 
get around that problem for batch files and also for my framework program.&nbsp; 
However, short of actually having v1.4 installed on my computer, I haven't 
figured out how to get around the problem using the Wireless Toolkit program.&nbsp; 
Since I am currently running v1.6, and I teach courses that require the features 
introduced in v1.5 and v1.6, I don't want to install v1.4 
on my computer.</p>
<p><font color="#FF0000"><b>Lots of leftover garbage</b></font></p>
<p>Another problem that I have with the Wireless Toolkit program for 
experimental work is the large number of folders and files that it creates and 
leaves hanging around on the disk whenever you use it.&nbsp; I am very frugal when it 
comes to the use of disk space, not because of a shortage of disk space, but 
because of the backup problems that are caused by having a lot of garbage on the 
disk.</p>
<p>As I have mentioned earlier, in most cases my framework program will clean 
up after itself, leaving only the source code, a JAR file, and a JAD file on the 
disk.&nbsp; Only the JAR file and the JAD 
file are required for testing and deployment of the MIDlet in a cell phone.</p>
<p><font color="#FF0000"><b>Running my framework program</b></font></p>
<p>Obviously, this is my preference.&nbsp; Otherwise, I wouldn't have invested 
the time and effort required to develop and test the framework.&nbsp; I will be 
teaching you all about the framework in this and subsequent lessons.</p>
<p><font color="#FF0000"><b>Local classes and member classes</b></font></p>
<p>I am a heavy user of member classes, local classes, and anonymous classes.&nbsp; 
Therefore, one of my objectives was to demonstrate that 
WTK2.5.2 supports both local classes and member classes in a MIDlet.&nbsp; For 
that reason, I will present and briefly explain a very simple MIDlet program 
named <b>WTK001</b> that consists of one top-level class, one local class, and 
one member class.</p>
<p>The behavior of the MIDlet is very simple.&nbsp; It displays my name <i>(or 
your name if you prefer)</i> on the cell phone screen.&nbsp; The point isn't the behavior of the MIDlet.&nbsp; Rather 
the point is the class structure that is used to organize the MIDlet.&nbsp; A 
method in an object of the top-level class calls a method in an object of the local class, 
which in turn gets and returns the value of an instance variable in an object of 
the member class.&nbsp; Thus, the three objects are inextricably linked to one 
another.</p>
<p><font color="#FF0000"><b>Let's see some code</b></font></p>
<p>That's enough talk.&nbsp; Let's see some code.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h4>
<font size="4"><a name="The_MIDlet_program_named_WTK001">The MIDlet program named WTK001</a></font></h4>
<p>
I will begin by providing a brief introduction to the MIDlet program named <b>
WTK001</b>.&nbsp; A complete listing of this program is presented in Listing 42 
near the end of the lesson.&nbsp; I don't want you to worry too much about the 
actual Java code in the program just yet.&nbsp; I will explain that code in a future lesson.&nbsp; 
In this lesson, I want you to concentrate on the class 
structure used to create the program.</p>
<p><font color="#FF0000"><b>Linked objects from three classes</b></font></p>
<p>The purpose of this program is to illustrate a MIDlet that is composed of 
linked objects from three classes.&nbsp; One of the classes is a top-level 
class, one is a local class, and one is a member class.&nbsp; A method in an 
object of the top-level class calls a method in an object of the local class, 
which in turn gets and returns the value of an instance variable in an object of 
the member class.&nbsp; That value, which is my name, is ultimately displayed on the cell phone 
screen.</p>
<p><font color="#FF0000"><b>The output class files</b></font></p>
<p>The compilation of this program produces the following three class files:</p>
<ul>
	<li>WTK001$1LocalClass.class</li>
	<li>WTK001$MemberClass.class</li>
	<li>WTK001.class</li>
</ul>
<p>If you are familiar with member classes and local classes, you should 
recognize two of these class file names as being in those categories.</p>
<p>The MIDlet was tested using a Java SE 6 compiler, targeted at a V1.4 virtual 
machine, and WTK 2.5.2 running under Windows XP.</p>
<p><font color="#FF0000"><b>Discuss the program in fragments</b></font></p>
<p>As is my custom, I will present and discuss the programs in this lesson in 
fragments.&nbsp; The top-level class begins in Listing 1, which also shows the 
beginning of the constructor for that class.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the top-level class for 
WTK001. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table3">
  <tbody>
    <tr>
      <td>
      <pre>package WTK001;

import javax.microedition.lcdui.Alert;
import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;

public class WTK001 extends MIDlet{

  Alert alertDisplay;

  public WTK001(){//constructor
    alertDisplay = new Alert("Name Display, WTK001");
    alertDisplay.setTimeout(10000);
    
    //==================================================//
    //This is a local class. The method named getName
    // instantiates a member class, gets the value of a
    // public instance variable from that object, and
    // returns that value.
    class <b>LocalClass</b>{
      public String <b>getName</b>(){
        return new MemberClass().name;
      }//end getName
    }//end class LocalClass
    //==================================================//</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The definition of a local class</b></font></p>
<p>For purposes of the intent of this lesson, one of the most important aspects 
of the code in Listing 1 is the definition of the small local class named <b>
LocalClass</b> early in the constructor.&nbsp; Note that the instance method 
named <b>getName</b> belonging to an object of the local class instantiates an 
object of a member class named <b>MemberClass</b>, gets the value of an instance 
variable named <b>name</b> belonging to that object, and returns that value.</p>
<p>The code in Listing 2 instantiates an object of <b>LocalClass</b> discussed 
above, calling the method named <b>getName</b> on that object.&nbsp; The value 
returned by the <b>getName</b> method is stored in a location from which it can 
later be displayed on the cell phone screen.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Instantiate an object of LocalClass. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table4">
  <tbody>
    <tr>
      <td>
      <pre>    <b>alertDisplay</b>.setString(<b>new LocalClass().getName()</b>);
  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 2 also signals the end of the constructor for <b>WTK001</b>.</p>
<p><font color="#FF0000"><b>Inherited abstract methods</b></font></p>
<p>Listing 3 begins with three methods that we aren't going to worry much about 
in this lesson because I will be discussing them in detail in future lessons.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Inherited abstract methods. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table5">
  <tbody>
    <tr>
      <td>
      <pre>  public void <b>startApp</b>(){
    Display.getDisplay(this).setCurrent(<b>alertDisplay</b>);
  }//end startApp

  public void <b>pauseApp</b>(){
  }//end pauseApp

  public void <b>destroyApp</b>(boolean unconditional){
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Suffice it to say at this point that these three methods are inherited from 
the <b>MIDlet</b> class where they are declared as <b>abstract</b> methods.&nbsp; 
Therefore, the <b>WTK001</b> class must provide concrete definitions for the 
three methods or the class must be declared abstract.</p>
<p>As you can see, two of the three methods in Listing 3 are defined simply as empty methods in this 
class.&nbsp; The method named <b>startApp</b> causes my name to be displayed on 
the cell phone screen as shown in Figure 2.</p>
<p><font color="#FF0000">
<b>The member class named MemberClass</b></font></p>
<p>Listing 4 shows the definition of the member class named <b>MemberClass</b>.&nbsp;
<i>(Note that this entire class is defined inside of the class named <b>WTK001</b>.)</i></p>
<p>
<b><a name="Listing_4">Listing 4</a>. The member class named MemberClass. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table6">
  <tbody>
    <tr>
      <td>
      <pre>  class <b>MemberClass</b>{
    public String <b>name = "Dick Baldwin"</b>;
  }//end class MemberClass
  //====================================================//
  
}//end class WTK001</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is a very simple class containing a single instance variable populated 
with my name.&nbsp; This is the value that is displayed on the cell phone screen 
in Figure 2.</p>
<h4><font size="4"><a name="The_batch_file_approach">The batch file approach</a></font></h4>
<p>Earlier in this lesson, I provided a <a href="#following_steps">list</a> of 
nine steps that are required to produce a MIDlet and to get it running in a cell 
phone. In this section of the lesson, I will present and explain six batch files 
and one text file that can be used to accomplish steps 3 through 8 in that
<a href="#following_steps">list</a>.</p>
<p><font color="#FF0000">
<b>The compilation batch file</b></font></p>
<p>A batch file that can be used to compile the MIDlet program named <b>WTK001</b> 
is shown in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. The compilation batch file named 
1-Compile.bat. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table7">
  <tbody>
    <tr>
      <td>
      <pre>rem Note:  It is necessary to target Java v1.4 for 
compatibility with the J2ME library classes.

rem Set path to root of wireless toolkit directory tree.
set WTK2.5.2=M:\WTK2.5.2

javac 
-target 1.4 
-source 1.4 
-bootclasspath 
%WTK2.5.2%\lib\cldcapi11.jar;
%WTK2.5.2%\lib\midpapi20.jar 
WTK001\WTK001.java

dir WTK001\*.class

pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Disk directory structure</b></font></p>
<p>Before getting into a detailed discussion of the batch file shown in Listing 5, we 
need to take care of some housekeeping chores.&nbsp; The first housekeeping 
chore that I will explain is the disk directory structure.</p>
<p>The batch file named <b>
1-Compile.bat</b> shown in Listing 5 was executed from a directory named <b>
Examples</b> on my computer.&nbsp; <i>(You can name that directory anything you 
like.)</i>&nbsp; One of the subdirectories of the<b> Examples
</b>directory is a directory named <b>WTK001</b>.&nbsp; <i>(You need to stick 
with this name unless you plan to modify the batch files.)</i>&nbsp; The source code file 
named <b>WTK001.java</b>, <i>(shown in Listing 42)</i> is in the directory 
named <b>WTK001</b>.</p>
<p>As you can see from the code in Listing 42, the MIDlet program contains the 
following package directive:</p>
<pre>package WTK001;</pre>
<p>I will leave it up to you to discern the meaning of the package directive in 
this case.&nbsp; Just make certain that you duplicate the directory structure 
and the package directive.&nbsp; If you change either, you must change both.</p>
<p><font color="#FF0000"><b>Batch file format</b></font></p>
<p>The second housekeeping chore that I will explain is the format of the batch file.&nbsp; Since a 
batch file is little more than a text file containing commands that you might 
normally execute at the command-line prompt, each such command must be on a line 
of its own in the batch file.&nbsp; <i>(If there is such a thing as a line 
continuation indicator in a batch file, I don't know what it is.)</i></p>
<p>However, the commands in this case are much too long to fit into this narrow 
publication format.&nbsp; Therefore, I manually inserted line breaks in Listing 
5 <i>(and all of the remaining batch files as well)</i> to force the material to 
fit in the required publication format.&nbsp; You will have to remove those line 
breaks when you copy the code into your own batch files.</p>
<p><font color="#FF0000"><b>Pointing to WTK2.5.2 software</b></font></p>
<p>The default installation location for the wireless toolkit software is 
C:\WTK2.5.2 on a Windows machine.&nbsp; However, you can install it wherever you 
like.&nbsp; For example, I have it installed on the M-drive on my machine rather 
than the C-drive.&nbsp; 
Therefore, the batch file begins by setting an environment variable named <b>
WTK2.5.2</b> to indicate the location of the toolkit.&nbsp; This environment 
variable can be used later, as in <pre>%WTK2.5.2%</pre>to represent the path to the 
toolkit in the batch commands.<p><font color="#FF0000"><b>The javac command</b></font></p>
<p>Listing 5 assumes that you have J2SE v1.4 or later installed on your machine, 
and that the program file named <b>javac.exe</b> is <i>&quot;on the path&quot;</i>.</p>
<p>According to the Sun documentation, the first two options following the <b>javac</b> command in Listing 5 instruct the 
compiler to do the following <i>(where &lt;release&gt; specifies a particular Java 
release version)</i>:</p>
<ul>
	<li>-target &lt;release&gt; Generate class files for specific VM version</li>
	<li>-source &lt;release&gt; Provide source compatibility with specified release</li>
</ul>
<p>As you can see, Listing 5 targets the output from the compiler for 
compatibility with version 1.4 of the Java Virtual Machine.&nbsp; <i>(I 
explained the reasons for this <a href="#I_have_independently">earlier</a>.) </i></p>
<p><font color="#FF0000"><b>The bootclasspath option</b></font></p>
<p>The next option to <b>javac</b> <i>(-bootclasspath in Listing 5)</i> instructs the 
compiler to <i>&quot;Override the location of bootstrap class files.&quot;</i>&nbsp; The two 
elements in the classpath that follow specify the paths to the<b> WTK2.5.2 </b>
JAR files for CLDC 1.1 and MIDP 2.0 respectively.&nbsp; Thus, the classes in 
those two JAR files will be used to compile the program instead of the classes 
in the standard J2SE class library.</p>
<p>If you want to compile to a different version of CLDC and/or MIDP, look in the 
<b>lib</b> directory of <b>WTK2.5.2</b> 
and get the names of the JAR files for the configuration and profile that you 
want to use.&nbsp; Substitute those names for the names given in Listing 5.</p>
<p><font color="#FF0000"><b>The MIDlet program to be compiled</b></font></p>
<p>Finally, the last command-line parameter to the <b>javac</b> program in 
Listing 5 instructs the compiler to compile the program named <b>WTK001.java</b> 
in the directory named <b>WTK001</b>.</p>
<p>If there are compiler errors, they will appear on the command-line screen at 
this point when you run the batch file.</p>
<p><font color="#FF0000"><b>A directory listing of class files</b></font></p>
<p>Before pausing, the batch file in Listing 5 produces a directory listing of 
all the class files in the <b>WTK001</b> folder for later use.</p>
<p><font color="#FF0000"><b>The pause command</b></font></p>
<p>The <b>pause</b> command at the end of Listing 5 causes the command-line 
screen to remain visible until you press any key on the keyboard.&nbsp; This is 
useful because it allows you to execute the batch file simply by double-clicking 
it with the mouse in the Windows GUI.&nbsp; Because of the pause command, the 
command-line screen won't go away until you dismiss it.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table13">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table14">
  <tr><td bgcolor="#eeeeee">
  <b>An exercise for the student</b><br />
  A useful upgrade would be for you to figure out how to cause my framework to 
	capture and display the error messages produced by the compiler.&nbsp; I 
	will show you how to <span lang="en-us"></span>do this in a future lesson, but it would be a good 
	exercise for you at this point.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Keep a copy of this batch file</b></font></p>
<p>Once you begin using my framework program to develop and test your MIDlet 
programs, this batch file will be very handy to 
keep around for diagnostic purposes.&nbsp; If there is a compiler error when you run my framework program, you will simply get a single-line error message 
indicating a compiler error.&nbsp; At that point, you can use the batch file in 
Listing 5 to recompile the program and see the error messages produced by the 
<b>javac</b> program.</p>
<p><font color="#FF0000">
<b>A sample text file</b></font></p>
<p>The next operational step will be for you to run the batch file named <b>
3-Preverify.bat</b> in order to preverify each of the class files produced during 
the compilation of the MIDlet program.&nbsp; Assuming that there are multiple 
class files, you have two options as to how you go about doing this:</p>
<ol>
	<li>Run the <b>preverify.exe</b> program multiple times, or </li>
	<li>Take advantage of one of 
the options to the <b>preverify.exe</b> program and run the program once against a list of class 
files to be preverified.</li>
</ol>
<p><font color="#FF0000"><b>A text file containing a list of class files</b></font></p>
<p>Listing 6 shows a sample text file for the MIDlet program named <b>WTK001</b> 
that can be used with the second option.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. A sample text file named 2-Classes.txt. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table8">
  <tbody>
    <tr>
      <td>
      <pre>WTK001.WTK001$1LocalClass 
WTK001.WTK001$MemberClass 
WTK001.WTK001</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, it was necessary for me to manually insert line breaks into 
Listing 6 to force the material to fit in the required narrow format.&nbsp; However, it 
is very important that all of the items in the list be on a single line in the 
text file and that 
the items be separated by a space character.&nbsp; Each item in the list is the 
path from the execution directory of the batch file to the class file itself.&nbsp; 
Note also that there is no extension on the name of the class files.</p>
<p>As you may recall, the batch file in Listing 5 produces a directory listing of all the class 
files.&nbsp; I did this to help you to construct the list of files shown in 
Listing 6 with minimal effort.</p>
<p><font color="#FF0000"><b>The preverify method</b></font></p>
<p>Figure 3 shows usage instructions for the <b>preverify</b> method.&nbsp; Listing 7 shows the contents of the batch file used to execute the method and 
preverify each of the class files produced by the compilation process in Listing 
5.&nbsp; The options that were used in this batch file are highlighted in 
boldface in Figure 
3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Usage instructions for the preverify 
	method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table15">
  <tbody>
    <tr>
      <td>
      <pre>Usage: preverify [options] classnames|dirnames ...

where options include:
   <b>-classpath     &lt;directories separated by ';'&gt;
                  Directories in which to look for 
                  classes</b>
   -d &lt;directory&gt; Directory in which output is written 
                  (default is ./output/)
   [ -cldc1.0 | -cldc ]
                  Checks for existence of language 
                  features prohibited by CLDC 1.0 
                  (native methods, floating point and 
                  finalizers)
   -target &lt;CLDC1.1 | CLDC1.0&gt;
                  Which preverifier to run
   -nofinalize    No finalizers allowed
   -nonative      No native methods allowed
   -nofp          No floating point operations allowed
   <b>@&lt;filename&gt;    Read command line arguments from a text
                  file
                  Command line arguments must all be on a 
                  single line
                  Directory names must be enclosed in 
                  double quotes (")</b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The batch file named&nbsp; 3-Preverify.bat</b></font></p>
<p>As you may already have figured out, the numbers that I included in the batch-file names 
indicate the order in which they should be executed.&nbsp; The batch file used 
to preverify the class files in the list shown in Listing 6 is shown in Listing 
7.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. The batch file named&nbsp; 
3-Preverify.bat.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table9">
  <tbody>
    <tr>
      <td>
      <pre>rem Set path to root of wireless toolkit directory tree.
set WTK2.5.2=M:\WTK2.5.2

%WTK2.5.2%\bin\preverify.exe 
-classpath %WTK2.5.2%\lib\cldcapi11.jar;
%WTK2.5.2%\lib\midpapi20.jar 
@2-Classes.txt

pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As was the case earlier, Listing 7 uses a -classpath option to specify CLDC 
version 1.1 and MIDP version 2.0.</p>
<p>Listing 7 also specifies that the text file named <b>2-Classes.txt</b> 
contains the list of class files that are to be <span lang="en-us"></span>preverified.</p>
<p><font color="#FF0000"><b>Location of the preverified class files</b></font></p>
<p>Figure 3 indicates that unless overridden by use of the <b>-d</b> parameter, 
the output class files from the <b>preverify</b> program will be written into 
a directory named <b>./output/</b>.&nbsp; This directory will be a subdirectory 
of the execution directory of the batch file, making it a sibling of the 
directory named <b>WTK001</b>.&nbsp; Also, the <b>preverify</b> program honors 
the package directive in the MIDlet program.&nbsp; This causes the preverified class 
files to be written into the following directory:</p>
<p><pre><b>output/WTK001</b></pre></p>
<p><font color="#FF0000"><b>Creating a manifest file</b></font></p>
<p>One of the things that we will be doing shortly is making a JAR file 
containing the preverified class files plus a manifest file.</p>
<p>There is nothing difficult about creating the manifest file.&nbsp; The only tricky 
part is knowing what the manifest file must contain.&nbsp; By examining several resources on the web, 
I concluded that as a minimum the manifest file must 
contain the three lines of text shown in Figure 4.&nbsp; <i>(See the article by
<span class="style2">Richard Marejka in <a href="#Resources">Resources</a> for 
example.</span>)</i></p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Required contents for the manifest file. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table16">
  <tbody>
    <tr>
      <td>
      <pre>MIDlet-Name: WTK001
MIDlet-Version: 1.0.0
MIDlet-Vendor: Dick Baldwin</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>However, I was completely unable to determine the significance of the MIDlet 
version number shown in Figure 4.&nbsp; The Sun cell phone emulator doesn't seem to care what 
value is provided for this item in the manifest file <i>(and later in the JAD 
file)</i>.</p>
<p><font color="#FF0000">
<b>Batch file named 4-MakeManifestFile.bat</b></font></p>
<p>Listing 8 
shows a batch file that can be used to create the necessary manifest file.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Batch file named 4-MakeManifestFile.bat. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table10">
  <tbody>
    <tr>
      <td>
      <pre>cd output
del Manifest.mf

echo MIDlet-Name: WTK001>&gt; Manifest.mf
echo MIDlet-Version: 1.0.0>&gt; Manifest.mf
echo MIDlet-Vendor: Dick Baldwin>&gt; Manifest.mf

type Manifest.mf
pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If you are familiar with command-line control of your system, you shouldn't 
find anything in Listing 8 that you don't understand.&nbsp; If you do, just look 
it up on the web and improve your knowledge in the process.</p>
<p><font color="#FF0000">
<b>The batch file named 5-MakeJarFile.bat</b></font></p>
<p>The program used to create a JAR file is part of J2SE.&nbsp; The name of the 
program is <b>jar.exe</b>, and it is normally found in the <b>bin</b> directory.&nbsp; 
Listing 9 shows a batch file that can be used to create the JAR file.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. The batch file named 5-MakeJarFile.bat. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table11">
  <tbody>
    <tr>
      <td>
      <pre>echo off
cd output
jar cvfm WTK001.jar Manifest.mf .\WTK001
echo ===
echo Note size of jar file.
dir *.jar
pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once again, there is nothing unusual about the code in Listing 9.&nbsp; If 
you don't know what it means, go to a command line and enter the <b>jar</b> 
command.&nbsp; You should get usage information on your screen that will explain 
the use of the <b>jar</b> command in Listing 9.</p>
<p>In order to create a JAD file later, it is necessary to know the exact size 
of the JAR file in bytes.&nbsp; The code in Listing 9 causes the file size to be 
displayed on the screen to make it easily available for later use.</p>
<p><font color="#FF0000"><b>Make a JAD file</b></font></p>
<p>Ultimately, all that is needed to deploy a MIDlet into the Sun cell phone 
emulator, or into an actual cell phone is the JAR file and a JAD file.&nbsp; As 
with the manifest file, the most difficult part of creating the JAD file is determining what the JAD file 
must contain.&nbsp; Once again, by consulting several resources on the web, I 
concluded that the minimum requirements for the JAD file are shown in Figure 
5.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Minimum requirements for a JAD file. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table17">
  <tbody>
    <tr>
      <td>
      <pre>MIDlet-1: WTK001, , WTK001.WTK001
<b>MIDlet-Name: WTK001</b>
<b>MIDlet-Version: 1.0.0</b>
<b>MIDlet-Vendor: Dick Baldwin</b>
MIDlet-Jar-URL: WTK001.jar
MIDlet-Jar-Size: 2123
MicroEdition-Profile: MIDP-2.0
MicroEdition-Configuration: CLDC-1.1</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Partial duplicate of the manifest file</b></font></p>
<p>As I understand it, the three boldface lines in Figure 5 must be exact duplicates of the same 
three lines in the manifest file <i>(see Figure 4)</i>.&nbsp; The value shown 
for the size of the JAR file must be the exact size of the file in bytes.&nbsp; 
I don't know what would happen if you failed to make the MIDP version and the 
CLDC version match the versions that you specified when you compiled the MIDlet 
code, but I would think that they should normally match.</p>
<p>That leaves only the first line in Figure 5 as not being self-explanatory.&nbsp; 
This line has three parameters separated by commas.&nbsp; 
According to one source on the web, the three parameters for that line describe the following:</p>
<pre>&lt;Application name&gt;, &lt;icon path&gt;, &lt;MIDlet class></pre></p>
<p>The icon parameter was left blank in Figure 5.&nbsp; The last parameter 
instructs the virtual machine to execute the class at <b>WTK001</b>.<b>WTK001</b>.</p>
<p><font color="#FF0000">
<b>The batch file named 6-MakeJadFile.bat</b></font></p>
<p>Listing 10 contains a batch file capable of producing the JAD file shown in 
Figure 5.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. The batch file named 6-MakeJadFile.bat. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table12">
  <tbody>
    <tr>
      <td>
      <pre>echo off
echo USAGE: 6-MakeJadFile jarFileSizeInBytes

cd output
del WTK001.jad

echo MIDlet-1: WTK001, , WTK001.WTK001&gt;&gt; WTK001.jad
echo MIDlet-Name: WTK001&gt;&gt; WTK001.jad
echo MIDlet-Version: 1.0.0&gt;&gt; WTK001.jad
echo MIDlet-Vendor: Dick Baldwin&gt;&gt; WTK001.jad
echo MIDlet-Jar-URL: WTK001.jar&gt;&gt; WTK001.jad
echo MIDlet-Jar-Size: %1&gt;&gt; WTK001.jad
echo MicroEdition-Profile: MIDP-2.0&gt;&gt; WTK001.jad
echo MicroEdition-Configuration: CLDC-1.1&gt;&gt; WTK001.jad

type WTK001.jad

pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in this batch file is completely straightforward with one exception.&nbsp; 
Note the use of the <b>%1</b> in the line that specifies the size of the JAR 
file.&nbsp; This makes it possible to run this batch file from the command line 
by entering the JAR file size as a command-line parameter.</p>
<p><font color="#FF0000"><b>Run the cell phone emulator</b></font></p>
<p>That leaves us with one more batch file to examine.&nbsp; If you have made it 
this far, execution of the batch file shown in Listing 11 should run the cell 
phone emulator producing an output similar to that shown in Figure 2.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. The batch file named 7-Run.bat. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table18">
  <tbody>
    <tr>
      <td>
      <pre>rem Set path to root of wireless toolkit directory tree.
set WTK2.5.2=M:\WTK2.5.2

cd output

%WTK2.5.2%\bin\emulator.exe -Xdescriptor WTK001.jad

pause</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Once the MIDlet is loaded into the emulator, the word <b>launch</b> should 
appear in the bottom-right corner of the cell phone screen.&nbsp; Use the mouse to click the button 
immediately below that word.&nbsp; That should cause the MIDlet to be executed 
once, 
causing my name to appear on the cell-phone screen for about ten seconds.&nbsp; 
Then it will go away.</p>
<p>The -Xdescriptor parameter value of <b>WTK001.jad</b> in Listing 11 causes the virtual 
machine to open the JAD file to get instructions on how to proceed further.&nbsp; </p>
<p><font color="#FF0000"><b>Problems with the batch file approach</b></font></p>
<p>Entering the commands manually at the command-line prompt is very tedious and 
prone to typing errors.&nbsp; Encapsulating those commands in batch files and 
executing the batch files in the proper sequence improves things considerably.&nbsp; However, as near as I have been able to determine, it isn't possible to totally 
automate the process using batch files.</p>
<p>There are two places where manual 
intervention is required when using the batch file approach.&nbsp; At one point, it is necessary to manually create 
the text file containing the list of class files to be preverified.&nbsp; At 
another point, it is necessary to manually enter the size of the JAR file as a 
command-line parameter.&nbsp; Ideally, we would like to eliminate the 
requirement to manually intervene in the process.&nbsp; That provides a good transition into the discussion of 
my fully automated framework program written in Java v1.6. </p>
<h4><font size="4"><a name="The_framework_program_named_WTKFramework01">The 
framework program named WTKFramework01</a></font></h4>
<p>The purpose of this program is to provide a framework that makes it easy to 
experiment with Java MIDlets written to run on small mobile devices using the 
Sun Java Wireless Toolkit (WTK2.5.2).&nbsp; </p>
<p>The framework not only makes such experimentation easy, it also cleans up 
after itself by automatically deleting all of the extraneous files created 
during the development of the JAR and JAD files.&nbsp; These are the only files that 
are required for the deployment of the MIDlet program.</p>
<p><font color="#FF0000"><b>Overall behavior of the program</b></font></p>
<p>Given a file containing the source code for the MIDlet, a single click of the 
mouse causes this framework to automatically cycle through the following steps:</p>
<ul>
	<li>Compile (targeted to Java v1.4 virtual machine)</li>
	<li>Preverify</li>
	<li>Create manifest file</li>
	<li>Create JAR file</li>
	<li>Create JAD file</li>
	<li>Delete&nbsp;extraneous files, saving the source, JAR and JAD files</li>
	<li>Deploy and execute in Sun's cell phone emulator</li>
</ul>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table32">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table33">
  <tr><td bgcolor="#eeeeee">
  <b>Testing</b><br />
  The framework program was tested using Java SE 6 and WTK2.5.2 running under Windows XP.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Disk organization</b></font></p>
<p>The MIDlet being processed must be stored in a folder having the same name as 
the main MIDlet class.&nbsp; The folder containing the MIDlet must be a child of 
the folder in which the framework is being executed.&nbsp; </p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>A complete listing of the framework program named <b>WTKFramework01</b> is 
presented in Listing 43.&nbsp; As usual, I will discuss the program in 
fragments.</p>
<p>The beginning of the class, including import directives and the declaration 
of a large number of instance variables is shown in Listing 12.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Beginning of class named WTKFramework01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table19">
  <tbody>
    <tr>
      <td>
      <pre>import java.io.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class WTKFramework01{
  String <b>toolkit</b> = "M:/WTK2.5.2";//Path to toolkit root
  String <b>prog</b> = "WTK001";//Default program name
  String <b>vendor</b> = "Dick Baldwin";//Default vendor name
  String <b>midletVersion</b> = "1.0.0";
  //Path to the bin folder of the Java installation
  String <b>javaPath</b> = "C:/Program Files/Java/jdk1.6.0/bin";
  
//Many variable declarations deleted from this listing for
// brevity.  See them all in Listing 43

  JRadioButton cButton10;
  JRadioButton cButton11;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The main method</b></font></p>
<p>The <b>main</b> method simply instantiates a new object of the member class 
named <b>GUI</b>, which I will explain next.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. The main method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table20">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    new WTKFramework01().new GUI();
  }//end main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The user interface</b></font></p>
<p>The class named <b>GUI</b> creates and displays the user interface shown in 
Figure 1.&nbsp; This interface allows the user to enter the name of the MIDlet 
program to be processed along with some other pertinent text information that will be used 
while the program is running.</p>
<p>For convenience, a default value is provided for each of the 
text fields.&nbsp; Default values were chosen that are appropriate for my 
system.&nbsp; You may want to modify the default values to make them more 
appropriate for your system.&nbsp; You can do this by modifying the initial 
values of the five instance variables shown in boldface in Listing 12.</p>
<p>The user interface also provides radio buttons that allow you to select a 
profile <i>(MIDP)</i> and a configuration <i>(CLDC)</i> for use by the program.&nbsp; You can also change 
the default selection should you choose to do so.&nbsp; 
<a name="I_will_explain_how_to_change_the_default_selection">I will explain how to 
change the default selection</a> in conjunction with the code that produces the 
radio buttons.</p>
<p>When the user clicks the <b>Run</b> button shown in Figure 1, the framework 
program executes, hopefully causing the MIDlet to run in the cell phone emulator 
shown in Figure 2.&nbsp; Once the window containing the emulator is dismissed, 
the framework program is ready to accept a new set of input parameters <i>(such 
as a new program name or a different profile)</i> and run again.</p>
<p>At the end of each run, the JAR file and the JAD file for that MIDlet program 
and those parameters are available in the <b>output</b> folder to be used for 
deployment in an actual cell phone.</p>
<p><font color="#FF0000">
<b>Beginning of the inner class named GUI</b></font></p>
<p>The <b>GUI</b> class begins in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Beginning of the inner class named GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table21">
  <tbody>
    <tr>
      <td>
      <pre>  class GUI extends JFrame{

    GUI(){//constructor
      setSize(400,250);
      setTitle("Copyright 2007, R.G.Baldwin");

//Code deleted for brevity in this listing.
//See Listing 43 for complete code listing.

      getContentPane().add(proCon,"Center");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that essentially all of the code in the <b>GUI</b> class is contained in 
the constructor.</p>
<p>The code in Listing 14 is completely straightforward.&nbsp; In fact, it is so 
straightforward that I deleted much of the code from Listing 14 for brevity.&nbsp; 
You can view that code in its entirety in Listing 43.</p>
<p><font color="#FF0000">
<b>Specifying default radio buttons</b></font></p>
<p>I promised you <a href="#I_will_explain_how_to_change_the_default_selection">
earlier</a> that I would explain how to establish the default selection for the 
radio buttons in conjunction with the explanation of the code.&nbsp; That 
process is illustrated in Listing 15.&nbsp; The five radio buttons are 
instantiated using two different overloaded versions of the <b>JRadioButton</b> 
constructor in Listing 15.&nbsp; When a radio button is constructed using the 
constructor that takes two parameters, and <b>true</b> is specified for the 
second parameter, that button is selected by default when it is constructed.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Specifying default radio buttons. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table22">
  <tbody>
    <tr>
      <td>
      <pre>      //Construct JPanel with radio buttons for selection
      // of profile.
      JPanel proButtons = new JPanel();
      proButtons.setLayout(new GridLayout(0,1));
      pButton10 = new JRadioButton("MIDP-1.0");
      pButton20 = new JRadioButton("MIDP-2.0",<b>true</b>);
      pButton21 = new JRadioButton("MIDP-2.1");

//Code deleted for brevity in this listing.
//See Listing 43 for complete code listing.

      //Construct JPanel with radio buttons for selection
      // of configuration.
      JPanel configButtons = new JPanel();
      configButtons.setLayout(new GridLayout(0,1));
      cButton10 = new JRadioButton("CLDC-1.0");
      cButton11 = new JRadioButton("CLDC-1.1",<b>true</b>);

//Code deleted for brevity in this listing.
//See Listing 43 for complete code listing.

      proCon.add(configButtons);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As before, most of the code in Listing 15 is completely straightforward.&nbsp; 
Therefore, much of the code was deleted from Listing 15 for brevity.&nbsp; You 
can view that code in its entirety in Listing 43.</p>
<p><font color="#FF0000"><b>Register an ActionListener on the Run button</b></font></p>
<p>As mentioned earlier, when the user clicks the <b>Run</b> button in Figure 1, 
the framework program is executed using the parameter values provided by the 
user in the user interface.</p>
<p>Listing 16 shows an anonymous inner class that registers an <b>ActionListener</b> 
on the <b>Run</b> button.&nbsp; </p>
<p>
<b><a name="Listing_16">Listing 16</a>. An anonymous ActionListener class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table23">
  <tbody>
    <tr>
      <td>
      <pre>      //Register an action listener on the Run button
      runButton.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            //Get user inputs from text fields

//Code deleted for brevity in this listing.
//See Listing 43 for complete code listing.

            //Now run the program.
            <b>runTheProgram()</b>;

          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is nothing unusual about the code in the definition of the anonymous <b>
ActionListener</b> class, so I deleted most of the code from Listing 16 for 
brevity.&nbsp; As before, you can view that code in its entirety in Listing 43.</p>
<p><font color="#FF0000"><b>Purposes of the ActionListener object</b></font></p>
<p>The <b>ActionListener</b> object has two primary purposes:</p>
<ol>
	<li>Extract information from the user input GUI in Figure 1 to set parameter 
	values that will be used by the framework to process the specified MIDlet.</li>
	<li>Cause the framework program to execute and process the MIDlet program 
	one time.</li>
</ol>
<p>Once the first purpose has been accomplished, the code in Listing 16 calls 
the method named <b>runTheProgram</b> to cause the framework program to execute 
one time.&nbsp; Thus, each time the <b>Run</b> button is clicked, the framework 
program executes and processes the specified MIDlet program one time.</p>
<p><font color="#FF0000"><b>Make the GUI visible</b></font></p>
<p>Listing 17 shows the end of the definition of the class named <b>GUI</b>.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Make the GUI visible. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table24">
  <tbody>
    <tr>
      <td>
      <pre>
      setVisible(true);
    }//end constructor
  }//end class GUI</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing causes the GUI shown in Figure 1 to become visible on the 
screen.&nbsp; Listing 17 also signals the end of the constructor and the end of 
the GUI class.</p>
<p><font color="#FF0000"><b>The method named runTheProgram</b></font></p>
<p>As indicated above, when the user clicks the <b>Run</b> button in Figure 1, 
the framework program is caused to execute one time using the input parameters 
specified by the user in the GUI.&nbsp; This is a relatively long method.&nbsp; The beginning of 
the method is shown in Listing 18.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Beginning of method named runTheProgram. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table25">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>runTheProgram</b>(){
    System.out.println("PROGRESS REPORT");
    System.out.println("Running program named: " + prog);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This method calls several other methods in sequence to accomplish the needed actions.&nbsp; If there is a failure at any step along the way, the framework will terminate at that point with a suitable error message.</p>
<p><font color="#FF0000"><b>Sample screen output</b></font></p>
<p>A considerable amount of information is displayed on the command-line screen 
while the framework program is executing to keep you informed as to what is 
happening.&nbsp; For 
example, the code in Listing 18 produced the screen output shown in 
Figure 6 for one particular run.</p>
<p>
 <b><a name="Figure_32">Figure 6</a>. Screen output at the beginning of a run. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table34">
  <tbody>
    <tr>
      <td>
      <pre>PROGRESS REPORT
Running program named: WTK001</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although this isn't the case in Figure 6, much of the screen output produced 
by the framework program is too wide to fit in this narrow publication format.&nbsp; 
Therefore, it will frequently be necessary for me to manually enter line breaks 
in order to show you samples of the screen output in this lesson.</p>
<p><font color="#FF0000"><b>Delete leftover files from a previous run</b></font></p>
<p>The first method called by the method named <b>runTheProgram</b> is a method 
named <b>deleteOldStuff</b> as shown in Listing 19.&nbsp; The purpose of this 
method call is to delete leftover files from a previous run, if any exist.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Delete leftover files from a previous 
run. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table26">
  <tbody>
    <tr>
      <td>
      <pre>    <b>deleteOldStuff</b>();
    if(initialCleanupOK != 0){//Test for success
      System.out.println("Initial cleanup error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The instance variables include a number of&nbsp; <i>&quot;success flags&quot;</i> of 
which the variable named <b>initialCleanupOK</b> is one.&nbsp; These variables 
are initialized to a value of 1.&nbsp; A successful execution of the method will 
change that value to a 0.&nbsp; The code in Listing 19 is typical, causing the 
value of the <i>success flag</i> to be tested, and causing the program to 
terminate with an appropriate error message if that value is not 0.</p>
<p><font color="#FF0000"><b>The method named deleteOldStuff</b></font></p>
<p>Now getting back to the code in Listing 19, I am going to put the discussion 
of the method named <b>runTheProgram</b> on hold for a while and explain the 
method named <b>deleteOldStuff</b>.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Beginning of the method named 
deleteOldStuff. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table27">
  <tbody>
    <tr>
      <td>
      <pre>
  void <b>deleteOldStuff</b>(){
    System.out.println(
           "Deleting leftover files from a previous run");

    //Delete subdirectory from output folder if it exists.
    int successFlag = <b>deleteOutputSubDir</b>();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As the name implies, the purpose of this method is to clean up the disk area 
utilized by the framework program deleting old files, if any, that may have been 
left there from a previous run of the program.</p>
<p><font color="#FF0000"><b>The directory named output</b></font></p>
<p>As you will learn later, the <b>preverify</b> method in WTK2.5.2 causes its 
output to be written in a directory named <b>output</b>, which is a subdirectory 
of the directory in which the program is being run.&nbsp; The <b>preverify</b> 
method honors the package directive in the MIDlet program.&nbsp; Therefore, for 
my case, using the package directive shown in Listing 1, the preverified files 
will be written in a subdirectory of the <b>output</b> directory where the name 
of that subdirectory matches the name of the MIDlet program.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table45">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table46">
  <tr><td bgcolor="#eeeeee">
  <b><a name="Upgrading_deleteOutputSubDir">Upgrading deleteOutputSubDir</a></b> <br />
  If you elect to cause your package directives to have more depth than mine, 
	you may need to upgrade the method named <b>deleteOutputSubDir</b> to a <i>
	(possibly recursive)</i> method that will delete all of the children of the 
	subdirectory.&nbsp; I could do that myself, but I have decided to <i>&quot;leave 
	that as an exercise for the student&quot;</i>.</td></tr></table>
</td>
</tr>
</table>
<p>The code in Listing 20 calls the method named <b>deleteOutputSubDir</b> to 
delete that subdirectory and the files that it contains.</p>
<p><font color="#FF0000"><b>Put deleteOldStuff on hold</b></font></p>
<p>At this point, I will put the discussion of the method named <b>deleteOldStuff</b> 
on hold and explain the method named <b>deleteOutputSubDir</b>.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table47">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table48">
  <tr><td bgcolor="#eeeeee">
  <b>Subdirectory should not exist</b><br />
  Actually this subdirectory should not exist.&nbsp; It should have been 
	deleted during the final cleanup process in the previous run.&nbsp; However, 
	if it does exist, it will be deleted.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000">
<b>The beginning of the method named deleteOutputSubDir</b></font></p>
<p>This method begins in Listing 21.&nbsp; As explained earlier, the purpose of 
this method is to delete the subdirectory contained in the <b>output</b> directory and all of its files
<i>(see <a href="#Upgrading_deleteOutputSubDir">sidebar</a>)</i>.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. The beginning of the method named deleteOutputSubDir.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table35">
  <tbody>
    <tr>
      <td>
      <pre>  int <b>deleteOutputSubDir</b>(){
    int returnVal = 0;

    System.out.println(
                  "\nDeleting files from output folder.");
    //First delete the files in the subdirectory
    File subDir = new File("output/" + prog);
    //Get a list of the files in the folder.
    String[] children = subDir.list();
    if(children != null){
      for(int cnt = 0;cnt &lt; children.length;cnt++){
        boolean success = (new File("output/" + prog + "/"
                               + children[cnt])).delete();
        if(!success){
          // Deletion failed
          returnVal = 1;
        }else{
          System.out.println(
                      "   " + children[cnt] + " deleted");
        }//end else
      }//end for loop
    }//end if !null</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Assumes no additional depth</b></font></p>
<p>Listing 21 begins by using a straightforward approach to delete the files 
contained in the subdirectory under the assumption that there are no 
subdirectories in that subdirectory.&nbsp; If the subdirectory does contain 
other subdirectories <i>(resulting from additional depth in the package 
directive)</i>, the <b>deleteOutputSubDir</b> method will likely throw an 
exception <i>(see <a href="#Upgrading_deleteOutputSubDir">sidebar</a>)</i>.&nbsp; 
Note in particular the handling of the success flag in this code.</p>
<p><font color="#FF0000">
<b>Delete the subdirectory proper</b></font></p>
<p>Having deleted all of the files, the code in Listing 22 deletes the 
subdirectory proper.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. Delete the subdirectory proper. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table36">
  <tbody>
    <tr>
      <td>
      <pre>    if(subDir.exists()){
      boolean success = subDir.delete();
      if(!success){
        // Deletion failed
        returnVal = 1;
      }else{
        System.out.println("   Empty directory named " 
                         + "output/" + prog + " deleted");
      }//end else
    }//end if

    return returnVal;
  }//end deleteOutputSubDir</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the value of <b>returnVal</b>, which is based on the success of the 
deletion process, is returned and stored in the variable named <b>successFlag</b> 
in Listing 20.</p>
<p><font color="#FF0000">
<b>Delete old manifest, JAR, and JAD files</b></font></p>
<p>Returning now to the discussion of the method named <b>deleteOldStuff</b>, 
Listing 23 shows the code that will delete the old manifest, JAR, and JAD files 
if they exist.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. Delete old manifest, JAR, and JAD files. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table37">
  <tbody>
    <tr>
      <td>
      <pre>    //Delete manifest file if it exists.
    File manifestFile = new File("output/Manifest.mf");
    if(manifestFile.exists()){
      boolean success = manifestFile.delete();
      if(success){
        System.out.println("   Manifest file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if
    
    //Delete old JAR file if it exists.
    File jarFile = new File("output/" + prog + ".jar");
    if(jarFile.exists()){
      boolean success = jarFile.delete();
      if(success){
        System.out.println("   Old jar file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if

    //Delete old JAD file if it exists.
    File jadFile = new File("output/" + prog + ".jad");
    if(jadFile.exists()){
      boolean success = jadFile.delete();
      if(success){
        System.out.println("   Old jad file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The JAR file and the JAD file should exist, because they are not deleted 
during the final disk cleanup at the end of the run.&nbsp; However, the manifest 
file will normally have been deleted during that cleanup process.</p>
<p>The code in Listing 23 is completely straightforward and shouldn't require 
further explanation.</p>
<p><font color="#FF0000">
<b>Delete old class files from the program directory</b></font></p>
<p>Listing 24 calls a method named <b>deleteProgClassFiles</b>, <i>(which I will 
discuss shortly)</i> to delete any leftover class files in the program directory 
if they exist.&nbsp; <i>(There shouldn't be any.&nbsp; They should have been 
deleted in the final cleanup process in the previous run.)</i></p>
<p>
<b><a name="Listing_24">Listing 24</a>. Delete old class files from the program 
directory. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table38">
  <tbody>
    <tr>
      <td>
      <pre>    int temp = <b>deleteProgClassFiles</b>();
    if(temp != 0){
      successFlag = temp;
    }//end if

    if(successFlag == 0){
      System.out.println("\nLeftover files deleted");
      initialCleanupOK = 0;//success
    }else{
    }//end else

  }//end deleteOldStuff</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 24 also deals with the success flag named <b>
initialCleanupOK</b>, setting it to 0 if no errors occurred during the process 
of deleting the old files and folders.</p>
<p>Listing 24 also signals the end of the method named <b>deleteOldStuff</b>.</p>
<p><font color="#FF0000">
<b>The method named deleteProgClassFiles</b></font></p>
<p>The method named
<b>deleteProgClassFiles</b> is shown in its entirety in Listing 25.</p>
<p>
<b><a name="Listing_25">Listing 25</a>. The method named deleteProgClassFiles. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table39">
  <tbody>
    <tr>
      <td>
      <pre>  int deleteProgClassFiles(){
    int returnVal = 0;

    System.out.println(
        "\nDeleting class files from program folder.");
    File dir = new File(prog);
    //Get a list of the files in the folder.
    String[] children = dir.list();
    for(int cnt = 0;cnt &lt; children.length;cnt++){

      //Don't delete files with extension of .java
      String aFile = children[cnt];
      if(aFile.indexOf(".java") &lt; 0){
        //Not a .java file.
        boolean success = (
                   new File(prog + "/" + aFile).delete());
        if(!success){
          // Deletion failed
          returnVal = 1;
        }else{
          System.out.println("   " + aFile + " deleted");
        }//end else
      }else{
        //This is a .java file.
        System.out.println("   " + aFile + " saved");
      }//end else

    }//end for loop

    return returnVal;
  }//end deleteProgClassFiles</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although the code in Listing 25 is straightforward, one interesting aspect of 
that code is that it does not delete the source code files having an extension 
of <i>.java in the program directory.&nbsp; (After all, we don't want to delete 
the program files before we attempt to compile them.)</i></p>
<p><font color="#FF0000">
 <b>Typical screen output from deleteOldStuff method</b></font></p>
<p>Figure 6 shows typical screen output produced by the call to the method named
<b>deleteOldStuff</b> in Listing 19.</p>
<p>
 <b><a name="Figure_6">Figure 6</a>. Typical screen output from deleteOldStuff 
	method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table51">
  <tbody>
    <tr>
      <td>
      <pre>Deleting leftover files from a previous run

Deleting files from output folder.
   Old jar file deleted
   Old jad file deleted

Deleting class files from program folder.
   WTK001.java saved

Leftover files deleted</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In this case, the only leftover files from the previous run were the JAR and 
JAD files, which are always preserved at the end of a run.</p>
<p><font color="#FF0000">
<b>Compile the MIDlet</b></font></p>
<p>After twenty-listings and six figures, we are finally going 
to compile the MIDlet.&nbsp; <i>(I didn't promise you that this program would be 
short and simple, just effective.)</i></p>
<p>Listing 26 shows a fragment from the method named <b>runTheProgram</b>, which 
calls the method named <b>compile</b> to compile the MIDlet.</p>
<p>
<b><a name="Listing_26">Listing 26</a>. Compile the MIDlet. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table40">
  <tbody>
    <tr>
      <td>
      <pre>    <b>compile()</b>;//compile the MIDlet
    if(compileOK != 0){//Test for successful compilation.
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the method named compile</b></font></p>
<p>The beginning of the method named <b>compile</b> is shown in Listing 27.</p>
<p>
<b><a name="Listing_27">Listing 27</a>. Beginning of the method named compile. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table41">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>compile()</b>{
    try{
      String cmdString =
           javaPath + "/<b>javac</b> -target 1.4 -source 1.4 "
           + "-bootclasspath " + toolkit + configJar + ";"
           + toolkit + profileJar
           + " " + prog + "/" + prog + ".java";
      
      System.out.println("\nCompile command:");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().<b>exec(cmdString)</b>;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of this method is to compile the MIDlet.&nbsp; As was the case 
for the batch file shown in Listing 5, the compilation generates class files for a Java v1.4 virtual machine.&nbsp; 
In fact, the code in Listing 27 does essentially the same thing as the batch 
file in Listing 5, but does so in a different way.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table52">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table53">
  <tr><td bgcolor="#eeeeee">
  <b><a name="New_processes">New processes</a></b><br />
  When you transfer control to a new process window by calling the <b>
exec</b> method, as this program does, the <i>path</i> environment variable doesn't go along for the ride.&nbsp; 
Therefore, you must provide the full path for programs that you call in that new 
process.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Calling the exec method</b></font></p>
<p>The code in Listing 27 is not straightforward, and there is a good 
possibility that you have never used code like this before.&nbsp; In particular, 
the code in Listing 27 constructs a command string and then calls the method 
named <b>exec</b> to cause that command to be executed on the command line in a 
<i>new process</i>.</p>
<p><font color="#FF0000"><b>The javac command string</b></font></p>
<p>Although it may not be immediately obvious from looking at the code, the <b>javac</b> 
command string that is constructed Listing 28 is in exactly the same format as 
the <b>javac</b> command in the batch file in Listing 5.&nbsp; The main 
difference is in the use of variables that contain user input values to 
construct the string.&nbsp; Since I explained that command in the discussion of 
that batch file, I won't repeat that discussion here.</p>
<p>
 <font color="#FF0000">
 <b>Typical output from the compile process</b></font></p>
<p>Before leaving the 
topic of the command string, I want to show you some typical output from this 
part of the program.&nbsp; That output is shown in Figure 7.&nbsp; <i>(Once 
again, I manually inserted line breaks to force the material to fit into this 
narrow publication format.)</i></p>
<p>
 <b><a name="Figure_7">Figure 7</a>. Typical output from the compile process. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table54">
  <tbody>
    <tr>
      <td>
      <pre>Compile command:
<b>C:/Program Files/Java/jdk1.6.0/bin/javac 
-target 1.4 
-source 1.4 
-bootclasspath 
M:/WTK2.5.2/lib/cldcapi11.jar;
M:/WTK2.5.2/lib/midpapi20.jar 
WTK001/WTK001.java</b>
Compile OK</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display of the command string</b></font></p>
<p>The boldface portion of the text in Figure 7 shows the command string that is 
passed to the new process created by the execution of the <b>exec</b> method.&nbsp; 
You should be able to reconcile the differences between this command string and 
the command that is shown in the batch file in Listing 5, but just in case you 
can't, I will give you some help.</p>
<p>The first difference is the use of a full path to the <b>javac</b> program in 
Figure 7 <i>(See the <a href="#New_processes">sidebar</a> discussing the path 
environment variable and new processes.)</i>.</p>
<p>The second difference is that the command in Figure 7 is exact whereas the 
command in the batch file in Listing 5 uses <b>%WTK2.5.2%</b> to represent the 
root of the WTK2.5.2 directory tree.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table59">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table60">
  <tr><td bgcolor="#eeeeee">
  <b>Compiler error messages are not displayed</b><br />
  This version of the framework does not display detailed compiler error messages.&nbsp; It 
	simply indicates that the compilation has failed and terminates.&nbsp; If a 
	compilation fails, the next step is to use a batch file similar to that 
	shown in Listing 5 to perform the compilation on a stand-alone basis.&nbsp; 
	<i>(I will improve on that process in a future lesson.)</i>&nbsp; That will cause compilation error messages to be displayed and allow for 
	identifying and fixing the problem in the MIDlet code.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Delay until compilation is complete</b></font></p>
<p>When you call the <b>exec</b> method to execute a command at the command line 
in a new process, you must be cognizant of the fact that the <b>exec</b> method 
may return before the new process is finished.&nbsp; </p>
<p>Continuing with the method named <b>compile</b>, the code in Listing 28 
delays until the compilation is complete.&nbsp; In other words, the method named
<b>waitFor</b> blocks and does not return until the compiler terminates.&nbsp; 
The <i>exit value</i> from the compiler is returned and stored in the variable 
named <b>val</b>.</p>
<p>
<b><a name="Listing_28">Listing 28</a>. Delay until compilation is complete. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table42">
  <tbody>
    <tr>
      <td>
      <pre>      int val = proc.<b>waitFor</b>();
      compileOK = val;
      if(val == 0){
        System.out.println("Compile OK");
      }else{
        System.out.println("Compile error");
      }//end else

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end compile</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Test the exit value for a successful compilation</b></font></p>
<p>Then the code in Listing 28 tests the exit value for success.&nbsp; By 
convention, an exit value of 0 indicates that the compilation was completed 
successfully.&nbsp; Any other value indicates that the compilation was not 
successful.&nbsp; If the exit value is 0, it is stored in the success flag 
variable named <b>compileOK</b> and the method terminates.&nbsp; Otherwise, the 
method displays a <b>Compile error</b> message and terminates without changing the 
value stored in the success flag named <b>compileOK</b>.</p>
<p>As mentioned earlier, the value of the <b>compileOK </b>flag was initialized 
to 1.&nbsp; Referring back to Listing 26, we see that if the method named <b>
compile</b> fails to set the value of that flag to 0, the framework program will 
terminate.&nbsp; This general procedure is used to prevent the framework from 
continuing to run after a failure in one of the steps implemented in the method 
named <b>runTheProgram</b>.</p>
<p><font color="#FF0000">
<b>Preverify the class files</b></font></p>
<p>Returning once again to the method named <b>runTheProgram</b>, the code in 
Listing 29 calls the <b>preverify</b> method to preverify the class files 
produced by the compiler.&nbsp; This framework terminates with an appropriate error message if 
the preverify method fails.</p>
<p>
<b><a name="Listing_29">Listing 29</a>. Preverify the class files. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table43">
  <tbody>
    <tr>
      <td>
      <pre>    <b>preverify()</b>;//Pre-verify the MIDlet class files
    if(preverifyOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the preverify method</b></font></p>
<p>The preverify method begins in Listing 30.</p>
<p>
<b><a name="Listing_30">Listing 30</a>. Beginning of the preverify method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table44">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>preverify()</b>{
    System.out.println(
        "\nPreverifying class files.");
    File dir = new File(prog);
    //Get a list of the files in the folder.
    String[] children = dir.list();
    <b>for</b>(int cnt = 0;cnt &lt; children.length;cnt++){
      //Only preverify files with an extension of .class
      String aFile = children[cnt];
      if(aFile.endsWith(".class")){
        //This is a class file
        try{
          //Remove the .class extension from the file name
          aFile = aFile.substring(0,aFile.lastIndexOf(
                                               ".class"));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The compiler may have created any number of class files.&nbsp; The <b>preverify</b> 
method assumes that they are all contained in the same folder, and assumes that 
the folder may contain other types of files such as source code files.</p>
<p>The code in Listing 30 shows the beginning of a <b>for</b> loop that gets the 
name of each class file contained in the folder and removes the .class 
extension from that file name.</p>
<p><font color="#FF0000">
<b>Continuation of the preverify for loop</b></font></p>
<p>The <b>for</b> loop that began in Listing 30 continues in Listing 31.</p>
<p>
<b><a name="Listing_31">Listing 31</a>. Continuation of the preverify for loop. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table61">
  <tbody>
    <tr>
      <td>
      <pre>          String cmdString = 
                toolkit + "/bin/preverify.exe -classpath "
                + toolkit + configJar + ";"
                + toolkit + profileJar + " "
                + prog + "/" + aFile;
            
          System.out.println("\nPreverify command");
          System.out.println(cmdString);
          Process proc = Runtime.getRuntime().<b>exec</b>(
                                               cmdString);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 31 constructs a command string and passes that command 
string as a parameter to the <b>exec</b> method for execution.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right" id="table74">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1" id="table75">
  <tr><td bgcolor="#eeeeee">
  <b>Name duplication</b><br />
  In hindsight, it would probably have been better for me to have given the method a different 
	name so as to avoid duplicating the name of the WTK program named <b>
	preverify</b>.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>A different approach than with the batch file</b></font></p>
<p>This Java program takes a different approach to preverification than was the 
case for the batch file shown in Listing 7.&nbsp; As you will recall, using the 
batch file approach, it was necessary for the user to manually create a text 
file containing the names of all the class files to be preverified.&nbsp; The 
name of the text file was then provided as a command-line parameter to the <b>
preverify</b> program provided by WTK2.5.2.&nbsp; </p>
<p>In that case, the <b>preverify</b> program was executed only once by the 
batch file and it processed all of the files listed in the text file.</p>
<p><font color="#FF0000"><b>Programmatic determination of class file names</b></font></p>
<p>In this program, Java code is used to determine the names of all the class 
files with no manual intervention required on the part of the user.&nbsp; Each 
class file is then processed during one iteration of a <b>for</b> loop.</p>
<p>The command string for one class file is displayed during each iteration of 
the <b>for</b> loop.&nbsp; One such command string is shown in the screen output 
in Figure 8.&nbsp; This command string instructs the WTK <b>preverify</b> 
program to process the class file named <b>WTK001/WTK001$1LocalClass</b>.&nbsp; 
This is the class file that represents the local class in the MIDlet program 
shown in Listing 1.</p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Typical screen output for preverification 
	process. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table71">
  <tbody>
    <tr>
      <td>
      <pre>Preverify command
M:/WTK2.5.2/bin/preverify.exe 
-classpath M:/WTK2.5.2/lib/cldcapi11.jar;
M:/WTK2.5.2/lib/midpapi20.jar 
<b>WTK001/WTK001$1LocalClass</b>

...

Pre-verify OK</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Delay until preverification is complete</b></font></p>
<p>As before, after calling the <b>exec</b> method, it is necessary to delay until preverification is complete 
before executing the next iteration of the <b>for</b> loop.&nbsp; This is 
accomplished by the code in Listing 32.</p>
<p>
<b><a name="Listing_32">Listing 32</a>. Delay until preverification is complete.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table62">
  <tbody>
    <tr>
      <td>
      <pre>          int val = proc.<b>waitFor</b>();
          preverifyOK = val;
          if(val == 0){
            System.out.println("Pre-verify OK");
          }else{
            System.out.println("Pre-verify error");
            return;//return prematurely
          }//end else
    
        }catch( Exception e ){
          e.printStackTrace();
        }//end catch        
      }//end if
    }//end for loop
  }//end preverify</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 32 also signals the end of my method named <b>preverify</b>, and 
deals with the success flag named <b>preverifyOK</b> that is used by the <b>runTheProgram </b>
code in Listing 29 to decide whether to continue or to terminate the framework 
program with an error message.</p>
<p><font color="#FF0000">
<b>Delete the class files from the program directory</b></font></p>
<p>Getting back to the method named <b>runTheProgram</b>, Listing 33 shows another 
call to the method named <b>deleteProgClassFiles</b> in the method named <b>runTheProgram</b> 
for the purpose of deleting the class files 
from the program folder.&nbsp; This is a call to the same method shown earlier 
in Listing 25.</p>
<p>
<b><a name="Listing_33">Listing 33</a>. Delete the class files from the program 
directory.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table63">
  <tbody>
    <tr>
      <td>
      <pre>    deleteClassFilesOK = <b>deleteProgClassFiles</b>();    
    if(deleteClassFilesOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I explained the method named <b>deleteProgClassFiles</b> earlier, so I won't 
repeat that explanation here.&nbsp; However, I will explain why I needed to 
delete those class files at this point in the program.</p>
<p><font color="#FF0000"><b>Why delete the class files?</b></font></p>
<p>Listing 9 shows the batch-file code that was used to create the JAR file 
using the batch file approach.&nbsp; 
Note that the second line of text in Listing 9 is a command that causes the current directory to 
be changed to the directory named <b>
output</b>.&nbsp; From that point forward, the execution directory for the batch 
file is the directory named <b>output</b>.&nbsp; 
Under that circumstance, the <b>jar</b> command shown in Listing 9 produces a JAR file 
where each preverified class file in the JAR file has the correct path for 
matching the package directive in the source code in Listing 1.</p>
<p><font color="#FF0000"><b>How do you change the execution directory in program 
code?</b></font></p>
<p>However, if there is a way to cause the execution directory of the Java 
framework program to switch to the directory named <b>output</b>, I don't know what it is.&nbsp; Therefore, before creating the JAR file using program code, 
I need to move the preverified class files to the directory named <b>WTK001</b> 
as a child of the program execution directory rather than leaving those files in the directory having 
the name <b>WTK001</b> 
that is a child of the <b>output</b> directory.</p>
<p>Before moving the files, I need to delete the class files in 
the destination directory having the name <b>WTK001</b>.&nbsp; <i>(Fortunately, 
I have no further use for those class files and it is okay to delete them at 
this point in the program execution.)</i></p>
<p>That is the 
explanation for why it was necessary to call the method named <b>deleteProgClassFiles</b> 
in Listing 33.</p>
<p><font color="#FF0000"><b>The screen output</b></font></p>
<p>Figure 9 shows the screen output produced by calling the method named <b>deleteProgClassFiles</b> 
in Listing 33.</p>
<p>
 <b><a name="Figure_9">Figure 9</a>. Screen output from deleting class files. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table76">
  <tbody>
    <tr>
      <td>
      <pre>Deleting class files from program folder.
   WTK001$1LocalClass.class deleted
   WTK001$MemberClass.class deleted
   WTK001.class deleted
   WTK001.java saved</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Move the preverified files to the original program 
directory</b></font></p>
<p>The next statement in the method named <b>runTheProgram</b> is a call to the 
method named <b>movePreverifiedFiles</b> as shown in Listing 34.</p>
<p>
<b><a name="Listing_34">Listing 34</a>. Move the preverified files to the 
original program directory.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table64">
  <tbody>
    <tr>
      <td>
      <pre>    <b>movePreverifiedFiles</b>();
    if(moveFilesOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>By now you should have caught onto the methodology for manipulating files and 
it shouldn't be necessary for me to explain the method named <b>movePreverifiedFiles</b>.&nbsp; 
You can view the method in its entirety in Listing 43.</p>
<p>Figure 10 shows the screen output produced by the call to the method named    <b>movePreverifiedFiles</b> 
in Listing 34.</p>
<p>
 <b><a name="Figure_10">Figure 10</a>. Screen output from moving files. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table77">
  <tbody>
    <tr>
      <td>
      <pre>Moving preverified files to program folder.
   output/WTK001/WTK001$1LocalClass.class moved
   output/WTK001/WTK001$MemberClass.class moved
   output/WTK001/WTK001.class moved</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Make the manifest file</b></font></p>
<p>Just as was the case when using the batch file approach, it is necessary for 
the framework program to create a manifest file named <b>Manifest.mf</b> in the 
directory named <b>output</b>.&nbsp; This is accomplished by calling the method 
named <b>makeManifestFile</b> as the next operation in the method named <b>
runTheProgram</b> as shown in Listing 35.</p>
<p>
<b><a name="Listing_35">Listing 35</a>. Make the manifest file.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table65">
  <tbody>
    <tr>
      <td>
      <pre>    <b>makeManifestFile()</b>;
    if(manifestFileOK != 0){
      System.out.println("Manifest file error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>makeManifestFile</b> is completely straightforward and 
shouldn't require any explanation.&nbsp; You can view that method in its 
entirety in Listing 43.</p>
<p><font color="#FF0000">
<b>Make the JAR file</b></font></p>
<p>The method named <b>runTheProgram</b> calls the method named <b>
makeJarFile</b> <i>(as shown in Listing 36)</i> to create the JAR file 
containing the manifest file and the preverified class files.</p>
<p>
<b><a name="Listing_36">Listing 36</a>. Make the JAR file.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table66">
  <tbody>
    <tr>
      <td>
      <pre>    <b>makeJarFile()</b>;    
    if(jarFileOK != 0){
      System.out.println("JAR file error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The method named makeJarFile</b></font></p>
<p>The method named <b>makeJarFile</b> is shown in its entirety in Listing 37.</p>
<p>
<b><a name="Listing_37">Listing 37</a>. The method named makeJarFile.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table67">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>makeJarFile()</b>{
    try{
      String cmdString = 
                    javaPath + "/jar cvfm output/" + prog 
                    + ".jar output/Manifest.mf ./" + prog;

      System.out.println("\nJAR command");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().exec(cmdString);

      //Delay until complete
      int val = proc.waitFor();
      jarFileOK = val;
      if(val == 0){
        System.out.println("Jar file written");
      }else{
        System.out.println("Jar file error");
        return;//Return prematurely on error.
      }//end else

      //Get and save file size in bytes
<b>      File file = new File("output/" + prog + ".jar");
      jarFileSize = file.length();
      System.out.println(
                     "   Jar file size = " + jarFileSize);</b>

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end makeJarFile</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Assuming that you understood the batch file code in Listing 9, and that you 
understand the process of creating command strings and causing them to be 
executed in a new process by calling the <b>exec</b> method, you should have no 
trouble understanding the code in Listing 37.</p>
<p><font color="#FF0000"><b>Get and save the JAR file size</b></font></p>
<p>The only thing that is new in Listing 37 is the code that gets and saves the 
size of the JAR file <i>(highlighted in boldface)</i>.&nbsp; There is nothing 
complicated about this code.&nbsp; I mention it only because you haven't seen 
code like this before in this lesson.</p>
<p><font color="#FF0000"><b>The screen output from making the JAR file</b></font></p>
<p>Figure 11 shows the screen output produced by calling the method named <b>
makeJarFile</b> in Listing 36.&nbsp; Compare this with the contents of the batch 
file shown in Listing 9.</p>
<p>
 <b><a name="Figure_11">Figure 11</a>. The screen output from making the JAR 
	file.</b><table border="1" cols="1" width="477" bgcolor="#ffffff" id="table78">
  <tbody>
    <tr>
      <td>
      <pre>JAR command
C:/Program Files/Java/jdk1.6.0/bin/jar
cvfm 
output/WTK001.jar 
output/Manifest.mf 
./WTK001
Jar file written
   Jar file size = 3066</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Make the JAD file</b></font></p>
<p>The size of the JAR file shown in Figure 11 will be used to create the JAD file.&nbsp; 
This leads into the next action taken by the method named <b>runTheProgram</b>.&nbsp;
<i>(Recall that you had to deal with the file size issue manually when using the 
batch file approach.&nbsp; That issue is handled automatically in the framework 
program.)</i></p>
<p>Listing 38 calls the <b>makeJadFile</b> method to replicate the 
behavior of the batch file shown in Listing 10 to create a JAD file and to write 
it in the directory named <b>output</b>.</p>
<p>
<b><a name="Listing_38">Listing 38</a>. Make the JAD file.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table68">
  <tbody>
    <tr>
      <td>
      <pre>    <b>makeJadFile()</b>;
    if(jadFileOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method named <b>makeJadFile</b> shouldn't require further explanation.&nbsp; 
You can view that method in its entirety in Listing 43.</p>
<p><font color="#FF0000">
<b>Clean up the disk</b></font></p>
<p>As mentioned earlier, I wanted my framework to avoid leaving any garbage files or directories 
that were created during the development 
process on the disk when the program terminates.&nbsp; The only two files that 
are required to deploy the MIDlet into the Sun cell phone emulator or into an 
actual cell phone are the JAR file and the JAD file.&nbsp; Therefore, the method 
named <b>runTheProgram</b> calls the method named <b>cleanup</b> in 
Listing 39 to clean up the disk.</p>
<p>
<b><a name="Listing_39">Listing 39</a>. Clean up the disk.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table69">
  <tbody>
    <tr>
      <td>
      <pre>    <b>cleanup()</b>;
    if(cleanupOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>cleanup</b> method is very similar to the method named <b>
deleteOldStuff</b> that I explained earlier, so you should have no trouble 
understanding the <b>cleanup</b> method without an explanation on my part.</p>
<p><font color="#FF0000"><b>The screen output for the cleanup phase</b></font></p>
<p>Figure 12 shows the screen output produced by the call to the <b>cleanup</b> 
method in Listing 39.</p>
<p>
 <b><a name="Figure_12">Figure 12</a>. The screen output for the cleanup phase.</b><table border="1" cols="1" width="477" bgcolor="#ffffff" id="table79">
  <tbody>
    <tr>
      <td>
      <pre>Deleting files from output folder.
   Empty directory named output/WTK001 deleted
   Manifest file deleted

Deleting class files from program folder.
   WTK001$1LocalClass.class deleted
   WTK001$MemberClass.class deleted
   WTK001.class deleted
   WTK001.java saved

Extraneous files deleted</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the JAD file and the JAR file are not deleted from the directory 
named <b>output</b>.&nbsp; They remain there to be deployed into Sun's cell 
phone emulator for testing or into an actual cell phone when testing is 
complete.</p>
<p><font color="#FF0000">
<b>Running Sun's cell phone emulator to test the MIDlet</b></font></p>
<p>That brings us to the end of the method named <b>runTheProgram</b> as 
shown in Listing 40.</p>
<p>
<b><a name="Listing_40">Listing 40</a>. Running the emulator.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee" id="table70">
  <tbody>
    <tr>
      <td>
      <pre><b>    runEmulator();</b>

    //Reset success flags
    initialCleanupOK = 1;//Success = 0
    compileOK = 1;//Compiler success = 0
    preverifyOK = 1;//Preverify success = 0
    deleteClassFilesOK = 1;//Delete success = 0
    moveFilesOK = 1;//Move success = 0
    manifestFileOK = 1;//Manifest success = 0
    jarFileOK = 1;//Jar file success = 0
    jadFileOK = 1;//Jad file success = 0
    cleanupOK = 1;//Cleanup success = 0

    //Control returns to here when the user terminates
    // the cell phone emulator.
    System.out.println(
      "\nClick the Run button to run another MIDlet.");
    System.out.println();//blank line

  }//end runTheProgram</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The only thing that is really significant in Listing 40 is the call to the 
method named <b>runEmulator</b>.</p>
<p><font color="#FF0000">
<b>The runEmulator method</b></font></p>
<p>The <b>runEmulator</b> method is shown in its entirety in Listing 41.</p>
<p>
<b><a name="Listing_41">Listing 41</a>. The runEmulator method.</b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  void <b>runEmulator()</b>{
    try{
      String cmdString = toolkit + "/bin/emulator.exe "
                + "-Xdescriptor output/" + prog + ".jad";
                
      System.out.println("\nEmulator command");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().exec(cmdString);

      //Delay until complete
      int val = proc.waitFor();
      if(val == 0){
        System.out.println("Emulator finished");
      }else{
        System.out.println("Emulator error");
      }//end else

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end runEmulator</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>If everything goes well, <a name="two_different_screen_outputs">two different screen outputs</a> will be produced by the 
method named <b>runEmulator</b>.&nbsp; The most important output is the 
appearance of a cell phone emulator as shown in Figure 13, with the MIDlet loaded 
into the emulator.</p>
<p><font color="#FF0000"><b>The cell phone emulator output</b></font></p>
<p>For the MIDlet being discussed here, when the emulator first appears on the screen, 
there may be a short period during which the MIDlet is being loaded 
into the emulator and the cell phone screen will be blank except for the icons 
at the very top of the screen.&nbsp; Then the screen should change to look like Figure 
13.</p>
<p>
 <b><a name="Figure_13">Figure 13</a>. The cell phone emulator with the MIDlet 
	loaded. </b>
<table border="0" cols="1" bgcolor="#ffffff" id="table80">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2570a3.jpg" width="323" height="721"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><i>(There may be other text on the screen if you have loaded multiple MIDlets 
into the emulator.)</i></p>
<p>At this point, you should use the arrow keys on the cell phone keyboard to 
select <b>WTK001</b> <i>(if you have a choice)</i>.&nbsp; This should cause the 
word <b>launch</b> to appear in the gray area at the bottom right of the cell 
phone screen.&nbsp; <i>(If you loaded only one MIDlet, it will already be 
selected and the word launch will already be visible once the load process is 
complete.)</i></p>
<p><font color="#FF0000">
 <b>The cell phone emulator with the MIDlet running</b></font></p>
<p>If you click the cell phone button below the word <b>launch</b>, the cell 
phone screen should change to that shown in Figure 14 with my name being displayed 
near the middle of the cell phone screen.&nbsp; The text at the top should also 
change to that shown in Figure 14.</p>
<p>
 <b><a name="Figure_14">Figure 14</a>. The cell phone emulator with the MIDlet 
	running.</b><table border="0" cols="1" bgcolor="#ffffff" id="table81">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2570a4.jpg" width="323" height="721"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>After about ten seconds, the cell phone screen should go blank except for the 
icons at the top.&nbsp; When you dismiss the cell phone emulator window by 
clicking the X in the upper right corner, the text on the command-line screen should 
instruct you to <i>&quot;Click the Run button to run another MIDlet.&quot;&nbsp;</i></p>
<p><font color="#FF0000">
 <b>Screen output produced by the runEmulator method</b></font></p>
<p>The <a href="#two_different_screen_outputs">other</a> screen output produced 
by the method named <b>runEmulator</b> is the information displayed on the 
command-line screen by print statements in the code.&nbsp; This output is shown 
in Figure 15.</p>
<p>
 <b><a name="Figure_15">Figure 15</a>. Screen output produced by the runEmulator 
	method. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff" id="table82">
  <tbody>
    <tr>
      <td>
      <pre>Emulator command
M:/WTK2.5.2/bin/emulator.exe 
-Xdescriptor output/WTK001.jad
Emulator finished</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Compare the command string shown in Figure 15 with the contents of the batch 
file shown in Listing 11, which I explained earlier.</p>
<p><font color="#FF0000"><b>That's a wrap!</b></font></p>
<p>That is the end of the discussion in the main body of this lesson.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 42 and Listing 43 into your text
editor, compile it, and execute it.&nbsp; Experiment with the MIDlet code in 
Listing 42 and the framework program in Listing 43, making
changes, and observing the results of your changes.&nbsp; See if you can 
understand the results produced by your changes.</p>
<p>Don't forget that you 
will need to download and install the latest version of the Sun Java Wireless 
Toolkit for CLDC <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; As of 
the date this lesson is being written <i>(December 2007)</i>, the latest version 
of the toolkit is WTK2.5.2.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this first lesson of the series, I presented some <span lang="en-us">
</span>general background 
information about MIDlets.&nbsp; I also provided you with a Java programming framework 
that makes it easy to experiment with the programming of MIDlets.&nbsp; I 
also explained the Java code in the framework program.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, I will teach you how to upgrade the framework program so 
that it will capture and display the standard output and error output produced 
by programs executing in a child process resulting from a call to the <b>Runtime.getRuntime().exec(cmdString)</b> 
method.&nbsp; For example, this will make it possible to display compile time 
errors when the framework is used to compile a MIDlet and will also make it 
possible to display information written to standard output or error output by 
MIDlets being tested in the Sun cell phone emulator.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/products/sjwtoolkit/download-2_5.html">Download</a> Sun Java Wireless Toolkit 2.5 for CLDC Release</li>
	<li><a href="http://en.wikipedia.org/wiki/MIDlet">MIDlet</a>: From 
	Wikipedia, the free encyclopedia</li>
	<li><a href="http://www.scmad.com/j2me-glossary1.php">MIDlet</a>: According 
	to SCMAD Certification Center</li>
	<li><a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html">J2ME 
	Tutorial, Part 1: Creating MIDlets</a> by Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step4">
	Pre-verifying</a> MIDlet code according to Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step7">
	Deploying</a> a MIDlet according to Vikram Goyal</li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/device/device;jsessionid=3F91C410E754F34B1A44DEBCE011ED18">
	The Java ME Device Table</a></span></li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/midp/ttips/getAppProperty/index.html">
	Retrieving MIDlet Attributes</a> by Richard Marejka</span></li>
	<li><a href="http://developers.sun.com/mobility/learn/midp/lifecycle/">
	Learning Path: MIDlet Life Cycle</a></li>
	<li><span class="style2">
	<a href="http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html?page=1">
	When Runtime.exec() won't</a> By </span>Michael C. Daconta</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
42 and Listing 43 below.
<p>
<b><a name="Listing_42">Listing 42</a>. The MIDlet program named WTK001</b>.<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*WTK001.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to illustrate a MIDlet
that is composed of linked objects from three classes,
one of which is a local class and one of which is a
member class.

Compilation produces the following three class files:
  WTK001$1LocalClass.class
  WTK001$MemberClass.class
  WTK001.class

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package WTK001;

import javax.microedition.lcdui.Alert;
import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;

public class WTK001 extends MIDlet{

  Alert alertDisplay;

  public WTK001(){
    alertDisplay = new Alert("Name Display, WTK001");
    alertDisplay.setTimeout(10000);
    
    //==================================================//
    //This is a local class. The method named getName
    // instantiates a member class, gets the value of a
    // public instance variable from that object, and
    // returns that value.
    class LocalClass{
      public String getName(){
        return new MemberClass().name;
      }//end getName
    }//end class LocalClass
    //==================================================//
    
    //Get a name string from an object of a local class,
    // which in turn gets the actual name string from an
    // object of a member class.
    alertDisplay.setString(new LocalClass().getName());
  }//end constructor

  public void startApp(){
    Display.getDisplay(this).setCurrent(alertDisplay);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
  }//end destroyApp
  
  //====================================================//

  //This is a member class.
  class MemberClass{
    public String name = "Dick Baldwin";
  }//end class MemberClass
  //====================================================//
  
}//end class WTK001</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_43">Listing 43</a>. The framework program named WTKFramework01.java. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*WTKFramework01.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to provide a framework that
makes it easy to experiment with Java MIDlets written to 
run on small mobile devices using the Sun Java Wireless 
Toolkit (WTK2.5.2).  The framework not only makes such 
experimentation easy, it also cleans up after itself by 
automatically deleting all of the extraneous files created
during the development of the JAR and JAD files, which
are required for the deployment of the MIDlet program.

Given a file containing the source code for the MIDlet, 
a single click of the mouse causes this framework to 
automatically cycle through the following steps:

Compilation (targeted to Java v1.4 virtual machine)
Pre-verification
Creation of the manifest file
Creation of the JAR file
Creation of the JAD file
Deletion of extraneous files, saving the JAR and JAD files
Deployment and execution in Sun's cell phone emulator

The MIDlet being processed must be stored in a folder 
having the same name as the main MIDlet class.  The 
folder containing the MIDlet must be a child of the 
folder in which the framework is being executed.

Note: When you transfer control to a new process window by
calling the exec method, the path environment variable
doesn't go along for the ride.  Therefore, you must 
provide the full path for programs that you call in that
new process.

Tested using Java SE 6 and WTK2.5.2 running under 
Windows XP.
*********************************************************/

import java.io.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class WTKFramework01{
  String toolkit = "M:/WTK2.5.2";//Path to toolkit root
  String prog = "WTK001";//Default program name
  String vendor = "Dick Baldwin";//Default vendor name
  String midletVersion = "1.0.0";
  String profile = "MIDP-2.0";
  String profileJar = "/lib/midpapi20.jar";
  String config = "CLDC-1.1";
  String configJar = "/lib/cldcapi11.jar";
  //Path to the bin folder of the Java installation
  String javaPath = "C:/Program Files/Java/jdk1.6.0/bin";

  int initialCleanupOK = 1;//Success = 0
  int compileOK = 1;//Compiler success = 0
  int preverifyOK = 1;//Preverify success = 0
  int deleteClassFilesOK = 1;//Delete success = 0
  int moveFilesOK = 1;//Move success = 0
  int manifestFileOK = 1;//Manifest success = 0
  int jarFileOK = 1;//Jar file success = 0
  int jadFileOK = 1;//Jad file success = 0
  int cleanupOK = 1;//Cleanup success = 0

  long jarFileSize = 0;

  JTextField progName;
  JTextField WTKroot;
  JTextField vendorText;
  JTextField midletVersionText;
  JTextField javaPathText;

  JRadioButton pButton10;
  JRadioButton pButton20;
  JRadioButton pButton21;

  JRadioButton cButton10;
  JRadioButton cButton11;
  //----------------------------------------------------//

  public static void main(String[] args){
    new WTKFramework01().new GUI();
  }//end main
  //----------------------------------------------------//

  void runTheProgram(){
    //This method is called when the user clicks the Run
    // button on the GUI.
    System.out.println("PROGRESS REPORT");
    System.out.println("Running program named: " + prog);

    //This code calls several methods in sequence to
    // accomplish the needed actions. If there is a
    // failure at any step along the way, the
    // framework will terminate at that point with a 
    // suitable error message.
    
    //Delete leftover files from a previous run, if any
    // exist
    deleteOldStuff();
    if(initialCleanupOK != 0){//Test for success
      System.out.println("Initial cleanup error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    compile();//compile the MIDlet
    if(compileOK != 0){//Test for successful compilation.
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    preverify();//Pre-verify the MIDlet class files
    if(preverifyOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    //Delete the class files from the original program
    // folder
    deleteClassFilesOK = deleteProgClassFiles();    
    if(deleteClassFilesOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if

    //Move the preverified files back to the original
    // program folder
    movePreverifiedFiles();
    if(moveFilesOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if

    //Make manifest file
    makeManifestFile();
    if(manifestFileOK != 0){
      System.out.println("Manifest file error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    //Make Jar file    
    makeJarFile();    
    if(jarFileOK != 0){
      System.out.println("JAR file error");
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    //Make Jad file
    makeJadFile();
    if(jadFileOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    //Delete extraneous files    
    cleanup();    
    if(cleanupOK != 0){
      System.out.println("Terminating");
      System.exit(1);
    }//end if
    
    //Run emulator    
    runEmulator();  
    
    //Reset success flags
    initialCleanupOK = 1;//Success = 0
    compileOK = 1;//Compiler success = 0
    preverifyOK = 1;//Preverify success = 0
    deleteClassFilesOK = 1;//Delete success = 0
    moveFilesOK = 1;//Move success = 0
    manifestFileOK = 1;//Manifest success = 0
    jarFileOK = 1;//Jar file success = 0
    jadFileOK = 1;//Jad file success = 0
    cleanupOK = 1;//Cleanup success = 0  
    
    //Control returns to here when the user terminates
    // the cell phone emulator.
    System.out.println(
      "\nClick the Run button to run another MIDlet.");
    System.out.println();//blank line

  }//end runTheProgram
  //----------------------------------------------------//

  //Purpose: Delete leftover files at startup
  void deleteOldStuff(){
    System.out.println(
           "Deleting leftover files from a previous run");

    //Delete subdirectory from output folder if it exists.
    int successFlag = deleteOutputSubDir();
    
    //Delete manifest file if it exists.
    File manifestFile = new File("output/Manifest.mf");
    if(manifestFile.exists()){
      boolean success = manifestFile.delete();
      if(success){
        System.out.println("   Manifest file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if
    
    //Delete old JAR file if it exists.
    File jarFile = new File("output/" + prog + ".jar");
    if(jarFile.exists()){
      boolean success = jarFile.delete();
      if(success){
        System.out.println("   Old jar file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if

    //Delete old JAD file if it exists.
    File jadFile = new File("output/" + prog + ".jad");
    if(jadFile.exists()){
      boolean success = jadFile.delete();
      if(success){
        System.out.println("   Old jad file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if
    
    //Delete class files from program folder, if any exist
    int temp = deleteProgClassFiles();
    if(temp != 0){
      successFlag = temp;
    }//end if

    if(successFlag == 0){
      System.out.println("\nLeftover files deleted");
      initialCleanupOK = 0;//success
    }else{
    }//end else

  }//end deleteOldStuff
  //----------------------------------------------------//
  
  //This method compiles the MIDlet.  Note that the
  // compilation generates class files for a Java v1.4
  // virtual machine.  Apparently WTK2.5.2 is not
  // compatible with Java 1.6.  Also note that the
  // compiler uses the classes in the WTK2.5.2 library
  // JAR files instead of using the classes in the
  // J2SE v1.6 libraries.
  void compile(){
    try{
      String cmdString =
           javaPath + "/javac -target 1.4 -source 1.4 "
           + "-bootclasspath " + toolkit + configJar + ";"
           + toolkit + profileJar
           + " " + prog + "/" + prog + ".java";
      
      System.out.println("\nCompile command:");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().exec(cmdString);
        
      //Delay until compilation is complete. Then test the
      // exit value of the compiler for success.  A value
      // of 0 indicates success.  Any other value
      // indicates that the compilation was not
      // successful.  Also note that this framework does
      // not display the compiler error messages.  If a
      // compilation fails, the next step is to use the
      // same approach from a batch file or from the
      // command line to perform the compilation on a
      // stand-alone basis.  That will expose the error
      // messages and allow for identifying and fixing the
      // problem in the MIDlet code.
      int val = proc.waitFor();
      compileOK = val;
      if(val == 0){
        System.out.println("Compile OK");
      }else{
        System.out.println("Compile error");
      }//end else

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end compile
  //----------------------------------------------------//

  //Purpose:  To preverify the class files.
  void preverify(){

    System.out.println(
        "\nPreverifying class files.");
    File dir = new File(prog);
    //Get a list of the files in the folder.
    String[] children = dir.list();
    for(int cnt = 0;cnt &lt; children.length;cnt++){
      //Only preverify files with an extension of .class
      String aFile = children[cnt];
      if(aFile.endsWith(".class")){
        //This is a class file
        try{
          //Remove the .class extension from the file name
          aFile = aFile.substring(0,aFile.lastIndexOf(
                                               ".class"));
          
          String cmdString = 
                toolkit + "/bin/preverify.exe -classpath "
                + toolkit + configJar + ";"
                + toolkit + profileJar + " "
                + prog + "/" + aFile;
            
          System.out.println("\nPreverify command");
          System.out.println(cmdString);
          Process proc = Runtime.getRuntime().exec(
                                               cmdString);
    
          //Delay until preverification is complete
          int val = proc.waitFor();
          preverifyOK = val;
          if(val == 0){
            System.out.println("Pre-verify OK");
          }else{
            System.out.println("Pre-verify error");
            return;//return prematurely
          }//end else
    
        }catch( Exception e ){
          e.printStackTrace();
        }//end catch        
      }//end if
    }//end for loop
  }//end preverify
  //----------------------------------------------------//
  
  //Purpose: Move preverified files back to original
  // program folder to make it easier to put them into
  // a JAR file with the correct path.
  void movePreverifiedFiles(){

  System.out.println(
         "\nMoving preverified files to program folder.");
  File dir = new File("output/" + prog);
  //Get a list of the files in the folder.
  String[] children = dir.list();
    
  //Destination directory
  File dest = new File(prog);
    
  for(int cnt = 0;cnt &lt; children.length;cnt++){
    String filename = children[cnt];

    try{
      // File to be moved
      String temp = "output/" + prog + "/" + filename;
      File file = new File(temp);

      // Move file to destination directory
      boolean success = file.renameTo(
                           new File(dest,file.getName()));
      if (!success){
        System.out.println("File move error");
        return;//return prematurely
      }else{
        System.out.println("   " + temp + " moved");
      }//end else

    }catch( Exception e ){
      e.printStackTrace();
     }//end catch        
   }//end for loop
    
   moveFilesOK = 0;//Successful move
  }//end movePreverifiedFiles
  //----------------------------------------------------//

  void makeManifestFile(){
    try{
      BufferedWriter out = new BufferedWriter(
                    new FileWriter("output/Manifest.mf"));
      out.write("MIDlet-Name: " + prog + "\n");
      out.write(
               "MIDlet-Version: " + midletVersion + "\n");
      out.write("MIDlet-Vendor: " + vendor + "\n");
      out.close();
      System.out.println("\nManifest file written");
      manifestFileOK = 0;
    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end makeManifestFile
  //----------------------------------------------------//

  void makeJarFile(){
    try{
      String cmdString = 
                    javaPath + "/jar cvfm output/" + prog 
                    + ".jar output/Manifest.mf ./" + prog;

      System.out.println("\nJAR command");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().exec(cmdString);

      //Delay until complete
      int val = proc.waitFor();
      jarFileOK = val;
      if(val == 0){
        System.out.println("Jar file written");
      }else{
        System.out.println("Jar file error");
        return;//Return prematurely on error.
      }//end else

      //Get and save file size in bytes
      File file = new File("output/" + prog + ".jar");
      jarFileSize = file.length();
      System.out.println(
                     "   Jar file size = " + jarFileSize);

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end makeJarFile
  //----------------------------------------------------//

  void makeJadFile(){
    try{
      BufferedWriter out = new BufferedWriter(
               new FileWriter("output/" + prog + ".jad"));

      out.write("MIDlet-1: " + prog + ", , " + prog 
                                + "." + prog + "" + "\n");

      out.write("MIDlet-Name: " + prog + "\n");
      out.write("MIDlet-Version: " 
                                  + midletVersion + "\n");
      out.write("MIDlet-Vendor: " + vendor + "\n");
      out.write("MIDlet-Jar-URL: " + prog + ".jar\n");
      out.write("MIDlet-Jar-Size: " + jarFileSize + "\n");
      out.write("MicroEdition-Profile: " 
                                        + profile + "\n");
      out.write("MicroEdition-Configuration: " 
                                         + config + "\n");
      out.close();
      
      System.out.println("\nJad file written");
      jadFileOK = 0;
    }catch( Exception e ){
      e.printStackTrace();
    }//end catch
  }//end makeJadFile
  //----------------------------------------------------//

  //Purpose: To run Sun's cell phone emulator with this
  // MIDlet.
  void runEmulator(){
    try{
      String cmdString = toolkit + "/bin/emulator.exe "
                + "-Xdescriptor output/" + prog + ".jad";
                
      System.out.println("\nEmulator command");
      System.out.println(cmdString);
      Process proc = Runtime.getRuntime().exec(cmdString);

      //Delay until complete
      int val = proc.waitFor();
      if(val == 0){
        System.out.println("Emulator finished");
      }else{
        System.out.println("Emulator error");
      }//end else

    }catch( Exception e ){
      e.printStackTrace();
    }//end catch

  }//end runEmulator
  //----------------------------------------------------//

  //Purpose:  Delete all files and folders in the output
  // folder other than the jar and jad files. Also delete
  // all class files in the program folder.
  void cleanup(){
    //Delete subdirectory from output folder.
    int successFlag = deleteOutputSubDir();
    
    //Delete manifest file from output folder.
    File manifestFile = new File("output/Manifest.mf");
    if(manifestFile.exists()){
      boolean success = manifestFile.delete();
      if(success){
        System.out.println("   Manifest file deleted");
      }else{
        successFlag = 1;
      }//end else
    }//end if
    
    //Delete class files from program folder
    int temp = deleteProgClassFiles();
    if(temp != 0){
      successFlag = temp;
    }//end if

    if(successFlag == 0){
      System.out.println("\nExtraneous files deleted");
      cleanupOK = 0;//success
    }else{
    }//end else

  }//end cleanup
  //----------------------------------------------------//

  //Purpose: To delete the folder contained in the output
  // directory and all of its files.
  int deleteOutputSubDir(){
    int returnVal = 0;

    System.out.println(
                  "\nDeleting files from output folder.");
    //First delete the files in the subdirectory
    File subDir = new File("output/" + prog);
    //Get a list of the files in the folder.
    String[] children = subDir.list();
    if(children != null){
      for(int cnt = 0;cnt &lt; children.length;cnt++){
  
        boolean success = (new File("output/" + prog + "/"
                               + children[cnt])).delete();
        if(!success){
          // Deletion failed
          returnVal = 1;
        }else{
          System.out.println(
                      "   " + children[cnt] + " deleted");
        }//end else
      }//end for loop
    }//end if !null
    
    //Now delete the subdirectory
    if(subDir.exists()){
      boolean success = subDir.delete();
      if(!success){
        // Deletion failed
        returnVal = 1;
      }else{
        System.out.println("   Empty directory named " 
                         + "output/" + prog + " deleted");
      }//end else
    }//end if

    return returnVal;
  }//end deleteOutputSubDir
  //----------------------------------------------------//

  //The purpose of this method is to delete the compiled
  // class files from the program folder.
  int deleteProgClassFiles(){
    int returnVal = 0;

    System.out.println(
        "\nDeleting class files from program folder.");
    File dir = new File(prog);
    //Get a list of the files in the folder.
    String[] children = dir.list();
    for(int cnt = 0;cnt &lt; children.length;cnt++){

      //Don't delete files with extension of .java
      String aFile = children[cnt];
      if(aFile.indexOf(".java") &lt; 0){
        //Not a .java file.
        boolean success = (
                   new File(prog + "/" + aFile).delete());
        if(!success){
          // Deletion failed
          returnVal = 1;
        }else{
          System.out.println("   " + aFile + " deleted");
        }//end else
      }else{
        //This is a .java file.
        System.out.println("   " + aFile + " saved");
      }//end else

    }//end for loop

    return returnVal;
  }//end deleteProgClassFiles
  //====================================================//

  //This is an inner class that controls the interactive
  // behavior of the framework.
  class GUI extends JFrame{

    GUI(){//constructor
      setSize(400,250);
      setTitle("Copyright 2007, R.G.Baldwin");
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      JButton runButton = new JButton("Run");
      JPanel runPanel = new JPanel();
      runPanel.add(runButton);
      getContentPane().add(runPanel,"South");

      //Construct and populate fields for entry of text
      // data.
      JPanel textData = new JPanel();
      textData.setLayout(new GridLayout(0,2));
      getContentPane().add(textData,"North");

      //Populate first row of grid with default values.
      textData.add(new JLabel("  Program Name"));
      progName = new JTextField(prog);
      textData.add(progName);

      //Populate second row, etc.
      textData.add(new JLabel("  WTK Root"));
      WTKroot = new JTextField(toolkit);
      textData.add(WTKroot);

      //Populate third row ...
      textData.add(new JLabel("  Vendor"));
      vendorText = new JTextField(vendor);
      textData.add(vendorText);

      //Populate fourth row ...
      textData.add(new JLabel("  Midlet Version"));
      midletVersionText = new JTextField(midletVersion);
      textData.add(midletVersionText);
      
      //Populate fifth row
      textData.add(new JLabel(
                            "  Path to Java bin folder"));
      javaPathText = new JTextField(javaPath);
      textData.add(javaPathText);

      //Create column titles for profile and configuration
      // buttons
      textData.add(new JLabel(" "));//spacer
      textData.add(new JLabel(" "));//spacer
      textData.add(new JLabel("  Profile"));
      textData.add(new JLabel("  Configuration"));

      //Construct and populate radio buttons for
      // selection of profile and configuration.
      JPanel proCon = new JPanel();
      proCon.setLayout(new GridLayout(0,2));
      getContentPane().add(proCon,"Center");

      //Construct JPanel with radio buttons for selection
      // of profile.
      JPanel proButtons = new JPanel();
      proButtons.setLayout(new GridLayout(0,1));
      pButton10 = new JRadioButton("MIDP-1.0");
      pButton20 = new JRadioButton("MIDP-2.0",true);
      pButton21 = new JRadioButton("MIDP-2.1");

      //Make the buttons mutually exclusive.
      ButtonGroup profileGroup = new ButtonGroup();
      profileGroup.add(pButton10);
      profileGroup.add(pButton20);
      profileGroup.add(pButton21);
 
      //Add the radio buttons to the GUI
      proButtons.add(pButton10);
      proButtons.add(pButton20);
      proButtons.add(pButton21);
      proCon.add(proButtons);

      //Construct JPanel with radio buttons for selection
      // of configuration.
      JPanel configButtons = new JPanel();
      configButtons.setLayout(new GridLayout(0,1));
      cButton10 = new JRadioButton("CLDC-1.0");
      cButton11 = new JRadioButton("CLDC-1.1",true);

      //Make the buttons mutually exclusive.
      ButtonGroup configGroup = new ButtonGroup();
      configGroup.add(cButton10);
      configGroup.add(cButton11);

      //Add the radio buttons to the GUI
      configButtons.add(cButton10);
      configButtons.add(cButton11);
      proCon.add(configButtons);

      //Register an action listener on the Run button
      runButton.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            //Get user inputs from text fields
            prog = progName.getText();
            toolkit = WTKroot.getText();
            vendor = vendorText.getText();
            midletVersion = midletVersionText.getText();
            javaPath = javaPathText.getText();

            //Set the profile based on which radio button
            // was selected by the user
            if(pButton10.isSelected()){
              profile = "MIDP-1.0";
              profileJar = "/lib/midpapi10.jar";
            }else if (pButton20.isSelected()){
              profile = "MIDP-2.0";
              profileJar = "/lib/midpapi20.jar";
            }else{//no other choice available
              profile = "MIDP-2.1";
              profileJar = "/lib/midpapi21.jar";
            }//end else

            //Set the configuration based on which radio
            // button was selected by the user
            if(cButton10.isSelected()){
              config = "CLDC-1.0";
              configJar = "/lib/cldcapi10.jar";
            }else{//no other choice available
              config = "CLDC-1.1";
              configJar = "/lib/cldcapi11.jar";
            }//end else

            //Now run the program.
            runTheProgram();

          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener

      setVisible(true);
    }//end constructor
  }//end class GUI
  //====================================================//
}//end class WTKFramework01</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java J2ME MIDlet &quot;cell phone emulator&quot; &quot;wireless toolkit&quot; WTK MIDP CLDC</p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
