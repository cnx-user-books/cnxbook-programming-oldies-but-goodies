<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="author" content="richard g. baldwin">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>... in Java by Richard G Baldwin</title>
</head>

<body bgcolor="#FFFFFF">
<!--start-->
<h3 align="center"><b><i>Richard G Baldwin (512) 223-4758, </i></b><a
href="mailto:baldwin@austin.cc.tx.us"><b><i>baldwin@austin.cc.tx.us</i></b></a><b><i>,
</i></b><a href="http://www2.austin.cc.tx.us/baldwin/"><b><i>http://www2.austin.cc.tx.us/baldwin/</i></b></a></h3>

<h2 align="center"><b><!--title-->JDK 1.1, Introduction to the Toolkit Class,
Peers, and Lightweight Components<!--endtitle--></b></h2>

<p>Java Programming, Lecture Notes # 103, Revised 01/27/99. </p>

<ul>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#sample program">Sample Program</a></li>
    <li><a href="#peers">Peers</a></li>
    <li><a href="#lightweight components">Lightweight Components</a></li>
</ul>

<hr>

<h2 align="center"><a name="preface"></a><font color="#FF0000"><b>Preface</b></font></h2>

<p>Students in Prof. Baldwin's <b><u>Intermediate Java
Programming</u></b> classes at ACC are responsible for knowing
and understanding all of the material in this lesson. </p>

<p>The material in this lesson is very important. However, there
is simply too much material to be covered in detail during
lecture periods. Therefore, students in Prof. Baldwin's <b>Intermediate
Java Programming</b> classes at ACC will be responsible for
studying this material on their own, and bringing any questions
regarding the material to class for discussion. </p>

<p align="left">This lesson was originally written on December 1,
1997 using the software and documentation in the JDK 1.1.3
download package. </p>

<p align="left">Sample program confirmed operational with JDK 1.2
on 1/27/99.</p>

<h2 align="center"><a name="introduction"></a><font
color="#FF0000">Introduction</font></h2>

<p>The primary purpose of this lesson is to introduce you to the
concept of the <b>Toolkit</b> class so that you will recognize it
when you see it used in subsequent lessons. We will also provide
a brief introduction to peers, and make mention of lightweight
components. </p>

<p>The <b>Toolkit</b> class provides an interface to
platform-specific services such as printing, fonts, images, and
display parameters. </p>

<p>The <b>Toolkit</b> constructor is abstract and therefore, we
never directly instantiate an object of type <b>Toolkit</b>.
Rather, we obtain a <b>Toolkit</b> object by invoking the <b>getDefaultToolkit()</b>
method. This gives us an object that is appropriate for our
system. </p>

<p>For example, to emit an audible signal in a program, we would
execute the following statement: &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><b><tt>Toolkit.getDefaultToolkit().beep();</tt></b></td>
    </tr>
</table>

<p>Note however, that depending on your system setup, this may,
or may not result in an audible signal (some systems provide the
ability to silence audible signals). </p>

<p>There are many methods in the <b>Toolkit</b> class, and some
of those methods are not of direct use. However, there are a
fairly large number of methods of the <b>Toolkit</b> class that
are quite useful, and often necessary. We will use many of these
methods in subsequent lessons. A partial list of the useful
methods with brief descriptions follows. You are referred to the
JDK documentation for a complete list of all the methods with
descriptions. &nbsp; </p>

<table border="1" bgcolor="#80FFFF">
    <tr>
        <td><ul>
            <li><b>beep</b>() - Sounds an audible signal&nbsp;</li>
            <li><b>getImage</b>() - Used to load an image file
                from a disk or URL.&nbsp;</li>
            <li><b>checkImage</b>() - Used to check the
                construction status of an image&nbsp;</li>
            <li><b>createImage</b>() - Three versions available
                to create an <b>Image </b>object from specified
                data&nbsp;</li>
            <li><b>prepareImage</b>() - Prepares an image for
                rendering.&nbsp;</li>
            <li><b>getFontList</b>() - Returns the names of the
                available fonts for this system.&nbsp;</li>
            <li><b>getFontMetrics</b>() - Used to obtain
                information such as the height and width of a
                font.&nbsp;</li>
            <li><b>getPrintJob</b>() - Gets a <b>PrintJob </b>object
                to use for printing&nbsp;</li>
            <li><b>getScreenResolution</b>() - Returns the screen
                resolution in dots-per-inch.&nbsp;</li>
            <li><b>getScreenSize</b>() - Gets the size of the
                screen.&nbsp;</li>
            <li><b>getSystemClipboard</b>() - Gets an instance of
                the system clipboard that can be used to transfer
                data to other applications.&nbsp;</li>
            <li><b>getSystemEventQueue</b>() - Allow you to post
                events to the system event queue.&nbsp;</li>
        </ul>
        </td>
    </tr>
</table>

<p>To elaborate, according to <u>Java AWT Reference</u> by John
Zukowski: &nbsp; </p>

<table border="1" bgcolor="#80FFFF">
    <tr>
        <td>The <b>Toolkit</b> ... is an abstract class that
        provides an interface to platform-specific details like
        window size, available fonts, and printing. ... Although
        the <b>Toolkit</b> is used frequently, both directly and
        behind the scenes, you would never create any of these
        objects directly. When you need a <b>Toolkit</b>, you ask
        for it with the static method <b>getDefaultToolkit()</b>
        or the <b>Component.getToolkit()</b> method.</td>
    </tr>
</table>

<p>What are some of the situations where you might need to use a <b>Toolkit</b>?
A partial list follows: &nbsp; </p>

<table border="1" bgcolor="#80FFFF">
    <tr>
        <td><ul>
            <li>To fetch an image in an application you might
                invoke <b>getImage()</b>.&nbsp;</li>
            <li>To obtain information about available fonts, you
                might use <b>getFontList()</b>.&nbsp;</li>
            <li>To obtain certain information about the color
                model, you might use <b>getColorModel()</b>.&nbsp;</li>
            <li>To obtain information about the screen, you might
                use <b>getScreenSize()</b> or <b>getScreenResolution()</b>.&nbsp;</li>
            <li>To work with the system clipboard, you might use <b>getSystemClipboard()</b>.&nbsp;</li>
            <li>To print, you might use <b>getPrintJob()</b>.&nbsp;</li>
            <li>To force an image to be loaded, you might use <b>prepareImage()</b>.&nbsp;</li>
            <li>To post events to the system event queue, you
                might use <b>getSystemEventQueue() </b>and the
                list goes on.&nbsp;</li>
        </ul>
        </td>
    </tr>
</table>

<p>Although the <b>Toolkit</b> class has a simple constructor,
the class is <i>abstract</i> and therefore cannot be
instantiated. As mentioned above, to get a usable <b>Toolkit</b>
object, you must invoke the static <b>getDefaultToolkit()</b>
method of the <b>Toolkit</b> class, or the <b>getToolkit() </b>method
of the <b>Component</b> class. </p>

<p align="left">As you work through the remaining lessons, be on
the lookout for the use of these methods. A sample program is
provided in the following section that illustrates how to use the
<b>Toolkit</b> class. </p>

<h2 align="center"><a name="sample program"></a><font
color="#FF0000">Sample Program</font></h2>

<p>This program illustrates the use of the <b>Toolkit </b>class
to obtain <u>system-specific information at runtime</u>. </p>

<p>The program determines the <b>width </b>and <b>height </b>of
the screen in pixels at runtime by invoking the <b>getScreenSize()</b>
method on an object of the <b>Toolkit </b>class. </p>

<p>This method returns an object of type <b>Dimension </b>which
contains two public data members named <b>width </b>and <b>height</b>.
The values of these two public data members in the returned
object define the <b>width </b>and <b>height </b>of the screen in
pixels for the current system settings. </p>

<p>This information is used to set the size of a <b>Frame </b>object
so that its width is <u>half the screen width</u> and its height
is <u>half the screen height</u>. </p>

<p>The <b>width </b>and <b>height </b>values are also displayed
in <b>Label </b>objects that are added to the <b>Frame</b>. </p>

<p>The program also uses a method named <b>beep()</b> of the <b>Toolkit
</b>class to emit an audible signal when the image becomes
visible (but may not work on all systems, depending on system
setup). </p>

<p>If you change your system parameters to select a different
resolution, and hence a different screen size (as measured in
pixels) and rerun the program, the <b>Frame </b>object will still
be half as wide as the screen and half as tall as the screen,
illustrating the fact that the <b>Toolkit </b>class provides
system-specific information (based on the most current system
setup) to programs that use its methods. </p>

<p>Note the use of the <b>getDefaultToolkit()</b> method to
obtain a <u>system-specific object</u> of type <b>Toolkit</b>. </p>

<p>Also note the use of an anonymous inner-class to terminate the
program. </p>

<p>This program was tested using JDK 1.1.3 and JDK 1.2 under
Win95. &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>/*File <b>Toolkit01</b>.java
Copyright 1997, R.G.Baldwin

This program illustrates the use of the Toolkit class to&nbsp;
obtain system-specific information at runtime.

This program was tested using JDK 1.1.3 under Win95.

**********************************************************/
import java.awt.*;
import java.awt.event.*;

class Toolkit01 extends Frame{ //controlling class

&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new Toolkit01();//instantiate this object
&nbsp;&nbsp; }//end main
&nbsp; //=====================================================//
&nbsp;&nbsp;
&nbsp; public Toolkit01(){//constructor
&nbsp;&nbsp;&nbsp; int width = //get width and height of screen in pixels
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Toolkit.getDefaultToolkit().getScreenSize().width;
</b>&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Toolkit.getDefaultToolkit().getScreenSize().height;

</b>&nbsp;&nbsp;&nbsp; //Set size of frame and decorate it
&nbsp;&nbsp;&nbsp; this.setSize(width/2,height/2);
&nbsp;&nbsp;&nbsp; this.setTitle(&quot;Copyright 1997, Baldwin&quot;);
&nbsp;&nbsp;&nbsp; this.setBackground(Color.yellow);
&nbsp;&nbsp;&nbsp; this.setLayout(new FlowLayout());

&nbsp;&nbsp;&nbsp; //Display width and height of screen in Label objects
&nbsp;&nbsp;&nbsp; this.add(new Label(&quot;&quot; + width));
&nbsp;&nbsp;&nbsp; this.add(new Label(&quot;&quot; + height));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; this.setVisible(true);//make the Frame visible
&nbsp;&nbsp;&nbsp; //Try to emit an audible signal
<b>&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().beep();&nbsp;&nbsp;
</b>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner-class listener to terminate program
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){//anonymous class definition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);//terminate the program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end windowClosing()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end WindowAdapter
&nbsp;&nbsp;&nbsp; );//end addWindowListener
&nbsp; }//end constructor&nbsp;
}//end class Toolkit01&nbsp;&nbsp;&nbsp;
//=======================================================//</pre>
        </td>
    </tr>
</table>

<h2 align="center"><a name="peers"></a><font color="#FF0000">Peers</font></h2>

<p>As of JDK 1.1.3, every component provided by the AWT (not
Swing) is supported by a <b>peer</b>. The peer is the native
implementation of that component. </p>

<p>For example, if you instantiate a <b>Button</b> object in your
application, it corresponds to the native button implemented by
the operating system. </p>

<p>For the most part, you as a Java programmer need be concerned
only with your implementation of the Java class named <b>Button</b>.
The relationship between your <b>Button</b> object and the native
peer button is handled behind the scenes by the Java Virtual
Machine. </p>

<p>There is at least one situation, however, where you do need to
be concerned. This situation has to do with the order in which
you do things. For example, if you compile and execute the
following code: &nbsp; </p>

<table border="1" bgcolor="#FFFF80">
    <tr>
        <td><pre>&nbsp;&nbsp;&nbsp; Label newLabel = new Label(&quot;New Label&quot;);&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(newLabel.<b>getPreferredSize</b>().width);
&nbsp;
&nbsp;&nbsp;&nbsp; this.<b>add</b>(newLabel);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(newLabel.<b>getPreferredSize</b>().width);</pre>
        </td>
    </tr>
</table>

<p>you will find that you <u>do not get valid data</u> for the
first invocation of the <b>getPreferredSize()</b> method but <u>you
do get valid data</u> for the second invocation of the <b>getPreferredSize()</b>
method<b>, </b><u>after the Label object has been added to its
container</u> which was already on the screen. </p>

<p>According to the book entitled <u>Java AWT Reference</u><b> </b>by
John Zukowski: &nbsp; </p>

<table border="1" bgcolor="#80FFFF">
    <tr>
        <td>Creating a Java component ... does not create the
        peer. An object's peer is created when the object's <b>addNotify()</b>
        method is called. This is usually when the component's
        container is added to the screen.</td>
    </tr>
</table>

<p>This explains the behavior of the code fragment listed above.
Valid information about the preferred size of the Label object is
not available until the peer is actually created (because the
preferred size depends on system-dependent factors such as the
size and style of the font in this case). However, the peer is
not created until the <b>Label </b>object is added to its
container by the invocation of the <b>add()</b> method. After the
<b>Label </b>is added to its container, the inquiry returns valid
information. </p>

<p>You need to be careful to avoid making inquiries about
components before they have a peer. In this particular case,
there was no compile-time error or runtime error. The value
returned from the first invocation of <b>getPreferredSize()</b>
was simply zero. Using this value later could lead to problems
that might be difficult to find and fix. </p>

<p>I will finish this section with one final quotation from John
Zukowski: &nbsp; </p>

<table border="1" bgcolor="#80FFFF">
    <tr>
        <td>The most important advice I can give you about the
        peer interfaces is not to worry about them. Unless you
        are porting Java to another platform, creating your own <b>Toolkit</b>,
        or adding any native component, you can ignore the peer
        interfaces.</td>
    </tr>
</table>

<p align="left">Zukowski then goes on to provide several pages of
good hard-core technical information about peer interfaces. If
you have further interest in the topic, see his book. </p>

<h2 align="center"><a name="lightweight components"></a><font
color="#FF0000">Lightweight Components</font></h2>

<p>Finally, be aware that JavaSoft is moving away from the
exclusive use of peer components in an area known as
&quot;lightweight components.&quot; Lightweight components are
components implemented completely in Java without a requirement
to depend on the components provided by the operating system. You
will learn how to create your own lightweight components in a
subsequent lesson after we have covered the appropriate
background material. </p>

<p>It can probably be expected that lightweight components will
have both advantages and disadvantages , but they have a couple
of significant characteristics: </p>

<ul>
    <li>They look the same regardless of the platform being used.</li>
    <li>In some cases they are much more responsive than peer, or
        heavyweight components.</li>
</ul>

<p>Possibly in some cases, they may also be less responsive than
heavyweight components, but I haven't seen that demonstrated as
of December 1997. </p>

<p>The capability to implement lightweight components was
introduced in JDK 1.1 with the advent of the lightweight
framework. </p>

<p>In the future, the programmer will have a choice to use either
lightweight or heavyweight components, or a mixture of the two.
As of JDK 1.1.3, you already have that choice if you want to
expend the effort to develop your own lightweight components.
However, because of the necessity to develop appropriate artwork,
and other factors as well (generally outside the realm of
programming), the development of a lightweight component is not a
trivial task, and the development of an entire library of
lightweight components could be a significant task. </p>

<p>As of 12/1/97, Javasoft has published a large set of
lightweight components in the pre-beta evaluation stage under the
name <b>Swing</b>. This set includes components that are not
available in JDK 1.1.3, such as progress indicators, sliders,
tabbed notebooks, help bubbles, etc. They are currently available
for downloading and evaluation at
&lt;http://java.sun.com/products/jfc/swingdoc-current/doc/index.html&gt;
but that URL is likely to change over time. </p>

<p>You may find it instructive to access the site and take a look
at the <b>Swing</b> demos that you will find there. </p>

<p>-end-<!--end--></p>
</body>
</html>
