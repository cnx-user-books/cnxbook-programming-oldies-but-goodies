<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Understanding the Alpha Time-Base Class in Java 3D</h2>
<i>Understanding the Alpha class is critical to understanding Java 3D animation.&nbsp; The constructors for the Alpha 
class can require up to ten parameters.&nbsp; Learn about the detailed behavior of objects instantiated from the Alpha 
class, with particular emphasis on understanding the behavior imparted by each 
of the ten parameters.</i>
<p><b>Published:</b>&nbsp; November 6, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1546</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Download">Download</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#FF0000"><b>Fourth</b></font><font color="#ff0000"><b> in a series of lessons</b></font></p>
<p>This is the fourth lesson in a series of lessons designed to start with Java 3D 
basics and work up to the general complexity of the program that I explained in 
the earlier lesson titled &quot;Understanding Lighting in the Java 3D API&quot; <i>(see
<a href="#Resources">Resources</a>).</i></p>
<p>The first lesson in this series was titled &quot;Back to Basics in the Java 3D 
API&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; The 
previous lesson was titled &quot;Simple Animation with the Java 3D API&quot;&nbsp; This 
lesson is titled &quot;Understanding the Alpha Time-Base Class in Java 3D&quot;&nbsp; 
My current plan is for future lessons to deal with user and object interaction as well as advanced animation and 
textures.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p>Understanding the <b>Alpha</b> class is critical to understanding Java 3D 
animation.&nbsp; The constructors for the <b>Alpha</b> class can require up to ten 
parameters.&nbsp; Understanding the purpose of those parameters and the behavior 
imparted by those parameters is far from trivial.&nbsp; In this lesson, I will 
teach you about the detailed behavior of objects instantiated from the <b>Alpha</b> 
class, with particular emphasis on understanding the behavior imparted by each 
of the ten parameters.&nbsp; In many cases, I will provide practical suggestions 
as to an animation scenario in which a particular parameter value might be 
appropriate.</p>
<p><b><font color="#ff0000">Compiling and running Java 3D programs</font></b></p>
<p>In order to compile and run programs using the Java 3D API, you will need to 
download and install the Java 3D API software.&nbsp; As of the date of this writing, 
version 1.5.0 is available for <a href="#Download">download</a>.</p>
<p>In addition, you will need to <a href="#Download">download</a> 
and install either <b>Microsoft DirectX</b> or <b>OpenGL</b>.&nbsp; All of the sample 
programs in this series of tutorials were developed and tested using Microsoft 
DirectX.&nbsp; They were not tested using OpenGL.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Bouvier's recipe for animation in Java 
	3D.</li>
	<li><a href="#Figure_2">Figure 2</a>. Parameter names and default values for 
	Alpha constructor.</li>
	<li><a href="#Figure_3">Figure 3</a>. Time functions produced by six 
	different Alpha objects.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the program named 
	Java3D007.</li>
	<li><a href="#Listing_2">Listing 2</a>. Three additional instance variables.</li>
	<li><a href="#Listing_3">Listing 3</a>. The main method.</li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the constructor.</li>
	<li><a href="#Listing_5">Listing 5</a>. Time to quit sampling.</li>
	<li><a href="#Listing_6">Listing 6</a>. The else clause.</li>
	<li><a href="#Listing_7">Listing 7</a>. End of anonymous inner class 
	definition.</li>
	<li><a href="#Listing_8">Listing 8</a>. Instantiate the first Alpha object.</li>
	<li><a href="#Listing_9">Listing 9</a>. A delayed saw tooth time function.</li>
	<li><a href="#Listing_10">Listing 10</a>. Even more delay.</li>
	<li><a href="#Listing_11">Listing 11</a>. Going from 1.0 to 0.0</li>
	<li><a href="#Listing_12">Listing 12</a>. A mode for moving objects with 
	significant mass.</li>
	<li><a href="#Listing_13">Listing 13</a>. Combining the mode values with a 
	bitwise OR.</li>
	<li><a href="#Listing_14">Listing 14</a>. The end of the constructor.</li>
	<li><a href="#Listing_15">Listing 15</a>. Source code for the program named 
	Java3D007.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>Dennis Bouvier <i>(see <a href="#Resources">Resources</a>)</i> gives us the 
recipe shown in Figure 1 for creating animation in Java 3D through the use an
<b>Interpolator</b> object.&nbsp; This lesson will concentrate on developing an 
understanding of step 2 in Figure1 dealing with objects of the <b>Alpha</b> 
class.</p>
<p><b><a name="Figure_1">Figure 1</a>. Bouvier's recipe for animation in Java 
3D.</b>
<table bgcolor="#ffffff" border="1" cols="1" width="477">
	<tr>
		<td>
		<ol>
			<li>Create a target TransformGroup<ul>
				<li>Set the ALLOW_TRANSFORM_WRITE capability</li>
			</ul>
			</li>
			<li><b>Create an Alpha object</b><ul>
				<li><b>Specify the time parameters for the alpha</b></li>
			</ul>
			</li>
			<li>Create the interpolator object<ul>
				<li>Have it reference the Alpha and TransformGroup objects</li>
				<li>Customize the behavior parameters</li>
			</ul>
			</li>
			<li>Specify a scheduling region<ul>
				<li>Set the scheduling region for the behavior</li>
			</ul>
			</li>
			<li>Make the behavior a child of the TransformGroup </li>
		</ol>
		</td>
	</tr>
</table>
<p>As you can see from Figure 1, being able to create the <b>Alpha</b> object is 
critical to the creation of the overall animation.</p>
<p><font color="#FF0000"><b>Constructors</b></font></p>
<p>The <b>Alpha</b> class has four overloaded constructors.&nbsp; The most 
complex of those four constructors requires ten parameters.&nbsp; The only 
differences among the constructors are that some of the constructors use default 
values for some of the ten required parameters.&nbsp; This results in three of 
the four constructors having fewer parameters.&nbsp; Regardless of which 
constructor you elect to use, you need to understand the behavior imparted by 
the values provided by all ten parameters even if some of those parameters take 
on default values.</p>
<p><font color="#FF0000"><b>The parameter names and default values</b></font></p>
<p>Although this is not likely to mean much to you at this point, Figure 2 shows 
the names of all ten parameters along with their default values.&nbsp; These 
names are based on the Sun documentation for the <b>Alpha</b> class.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Parameter names and default values for 
	Alpha constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>
loopCount :                     -1
mode :                           INCREASING_ENABLE
triggerTime :                    0
phaseDelayDuration :             0
increasingAlphaDuration :     1000
increasingAlphaRampDuration :    0
alphaAtOneDuration :             0
decreasingAlphaDuration :        0
decreasingAlphaRampDuration :    0
alphaAtZeroDuration :            0</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>By the end of this lesson, you should understand the purpose of each of the 
parameters listed in Figure 2.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain a program named <b>Java3D007</b>, 
which instantiates six different <b>Alpha</b> objects using different 
combinations of parameter values, and then illustrates the behavior of each 
<b>Alpha</b> object using the plots shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Time functions produced by six different 
	Alpha objects. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1546a01.jpg" width="409" height="701"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#ff0000"><b><a name="What_is_an_Alpha_object">What is an Alpha 
object</a>?</b></font></p>
<p>Before getting ahead of ourselves, we should probably back up and 
start at the beginning.&nbsp; According to Sun, </p>
<blockquote>
	<p><i>&quot;The alpha NodeComponent object provides common methods for converting 
	a time value into an alpha value (a value in the range 0 to 1). The Alpha 
	object is effectively a function of time that generates alpha values in the 
	range [0,1] when sampled: f(t) = [0,1]. A primary use of the Alpha object is 
	to provide alpha values for Interpolator behaviors. The function f(t) and 
	the characteristics of the Alpha object are determined by user-definable 
	parameters&quot;</i></p>
</blockquote>
<p>Stated more simply, an <b>Alpha</b> object provides a time base that can be 
used by an <b>Interpolator</b> object in the process of producing the 
intermediate views of the universe that are needed during an animation of that 
universe.</p>
<p><font color="#ff0000"><b><a name="Four_overloaded_constructors">Four overloaded constructors</a></b></font></p>
<p>There are four different overloaded constructors for the <b>Alpha</b> class, 
with the most complex constructor requiring the following ten parameters:</p>
<ol>
	<li><b><a name="loopCount_">loopCount</a></b> - number of times to run this alpha; a value of -1 
	specifies that the alpha loops indefinitely.</li>
	<li><b><a name="mode_">mode</a></b> - indicates whether the increasing alpha parameters or the 
	decreasing alpha parameters or both are active.</li>
	<li><b><a name="triggerTime_">triggerTime</a></b> - time in milliseconds since the start time that this 
	object first triggers</li>
	<li><b><a name="phaseDelayDuration_">phaseDelayDuration</a></b> - number of milliseconds to wait after 
	triggerTime before actually starting this alpha</li>
	<li><b><a name="increasingAlphaDuration_">increasingAlphaDuration</a></b> - period of time during which alpha goes 
	from zero to one</li>
	<li><b><a name="increasingAlphaRampDuration_">increasingAlphaRampDuration</a></b> - period of time during which the 
	alpha step size increases at the beginning of the increasingAlphaDuration 
	and, correspondingly, decreases at the end of the increasingAlphaDuration. 
	This value is clamped to half of increasingAlphaDuration. NOTE: a value of 
	zero means that the alpha step size remains constant during the entire 
	increasingAlphaDuration.</li>
	<li><b><a name="alphaAtOneDuration_">alphaAtOneDuration</a></b> - period of time that alpha stays at one</li>
	<li><b><a name="decreasingAlphaDuration_">decreasingAlphaDuration</a></b> - period of time during which alpha goes 
	from one to zero</li>
	<li><b><a name="decreasingAlphaRampDuration_">decreasingAlphaRampDuration</a></b> - period of time during which the 
	alpha step size increases at the beginning of the decreasingAlphaDuration 
	and, correspondingly, decreases at the end of the decreasingAlphaDuration. 
	This value is clamped to half of decreasingAlphaDuration. NOTE: a value of 
	zero means that the alpha step size remains constant during the entire 
	decreasingAlphaDuration. </li>
	<li><b><a name="alphaAtZeroDuration_">alphaAtZeroDuration</a></b> - period of time that alpha stays at zero</li>
</ol>
<p><font color="#FF0000"><b>Some names and descriptions don't quite do the job</b></font></p>
<p>Some of you may not need any more information than that given above to 
fully understand the behavior imparted by each of these ten parameters.&nbsp; For me, 
however, some of the names and descriptions given above didn't quite do the job.&nbsp; 
I found it necessary to do some experimentation with the parameter values to 
understand their behavior.&nbsp; The purpose of this lesson is to share the 
results of that experimentation with you, and also to provide a program that you 
can easily modify to do your own experimentation.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
A complete listing of the program named <b>Java3D007</b> is provided in Listing 
15.&nbsp; The purpose of this program is to investigate and illustrate the 
behavior of the Java 3D class named <b>Alpha</b> as a function of the values 
passed as parameters when an <b>Alpha</b> object is instantiated.&nbsp; The 
class named <b>Alpha</b> is a programmable time-base program that is used mainly 
to control animations, but could be used for any purpose that requires a 
programmable time base.&nbsp; 
<p><font color="#FF0000"><b>The alpha value ranges from 0.0 to 1.0</b></font></p>
<p>An <b>Alpha</b> object generates and provides an alpha value ranging from 0.0 
to 1.0 over a specified elapsed cycle time.&nbsp; The shape of the time function 
described by the alpha value is controlled by parameters that are passed to the 
constructor when the object is instantiated.</p>
<p><font color="#FF0000"><b>Number of cycles is an input parameter</b></font></p>
<p>The number of repetitive cycles of the alpha value that will be produced is 
an input parameter <i>(loopCount in Figure 2)</i>.&nbsp; A value of -1 will 
cause the object to continue producing repetitive alpha values until it is 
purposely terminated.</p>
<p><font color="#FF0000"><b>A set of sample values</b></font></p>
<p>An <b>Alpha</b> object has many methods, one if which is named <b>value</b>.&nbsp; 
This method can be called to sample the alpha value at any point in time.&nbsp; 
By using a clock and sampling the alpha value at a set of equally spaced points 
in time, a set of sample values can be obtained from the <b>Alpha</b> object 
that describe the alpha time function.</p>
<p><font color="#FF0000"><b>Constructors</b></font></p>
<p>The <b>Alpha</b> class contains four overloaded constructors.&nbsp; The most 
complex constructor requires ten parameters.&nbsp; The only differences among 
the constructors are that some of the constructors use default values for some of 
the parameters.&nbsp; This results in three of the four 
constructors having fewer than ten required parameters.</p>
<p><font color="#FF0000"><b>Samples from six Alpha objects</b></font></p>
<p>This program constructs six different <b>Alpha</b> objects, each having different 
parameter values.&nbsp; All six constructors run for two cycles with a duration 
of five seconds per cycle.&nbsp; Thus, each <b>Alpha</b> object generates alpha values 
during a time span of ten seconds (10000 milliseconds).</p>
<p>A timer is used to collect 100 samples from each <b>Alpha</b> object spaced at 
uniform intervals of 100 milliseconds during the total elapsed time of ten 
seconds.</p>
<p>As a quality check, the system clock is also used to get and print the total 
elapsed time during which the <b>Alpha</b> objects are generating data.</p>
<p><font color="#FF0000"><b>Plots of the time functions</b></font></p>
<p>Each set of 100 samples is plotted as shown in Figure 3.&nbsp; The plot data 
is scaled so that a value of 1.0 produced by an <b>Alpha</b> object is plotted 
as a value of 100 in Figure 3.</p>
<p><font color="#FF0000"><b>The plotting software</b></font></p>
<p>The plotting software used in the program is a simplified version of the program 
named <b>Graph01</b> that I published and explained earlier in the tutorial titled &quot;Plotting Engineering and Scientific Data using Java&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; Because I explained that plotting 
software in the earlier lesson, I won't repeat that explanation here, but will 
simply refer you to the earlier lesson.</p>
<p><font color="#FF0000"><b>Program testing</b></font></p>
<p>This program was tested using Java SE 6, and Java 3D 1.5.0 running under 
Windows XP.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>
<p>As mentioned earlier, a complete listing of the program is presented in 
Listing 15 near the end of the lesson.&nbsp; As is my custom for long programs, 
I will break the program down and explain it in fragments.</p>
<p>The program begins in the fragment shown in Listing 7.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the program named Java3D007. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>class Java3D007{
  
  Alpha alpha1Obj;
  Alpha alpha2Obj;
  Alpha alpha3Obj;
  Alpha alpha4Obj;
  Alpha alpha5Obj;
  Alpha alpha6Obj;
  
  float[] alpha1Data = new float[100];
  float[] alpha2Data = new float[100];
  float[] alpha3Data = new float[100];
  float[] alpha4Data = new float[100];
  float[] alpha5Data = new float[100];
  float[] alpha6Data = new float[100];</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Reference variables for the Alpha objects and data</b></font></p>
<p>As mentioned earlier, this program is designed to instantiate and run six <b>
Alpha</b> objects with different combinations of parameters being passed to the 
constructors, and to plot the time series produced by those <b>Alpha</b> 
objects.</p>
<p>Listing 1 declares reference variables that will point to each of the <b>
Alpha</b> objects.&nbsp; Listing 1 also creates six array objects, each having a
<b>length</b> of 100 elements.&nbsp; The sampled alpha values will be stored in 
these array objects as they are being produced.&nbsp; After all six arrays have 
been populated, the data in those arrays will be plotted as shown in Figure 3.</p>
<p><font color="#FF0000">
<b>Three additional instance variables</b></font></p>
<p>Listing 2 declares and initializes three additional instance variables that 
are used later in the program.&nbsp; The purpose of these variables will be 
explained later.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Three additional instance variables. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  //Initialize the sampleTime counter to the time that the
  // first sample will be taken.
  int sampleTime = 100;
  //Used to compute the actual elapsed time from the
  // system clock.
  long baseTime;
  //Timer used to trigger the collection of samples of the
  // alpha values.
  Timer samplingTimer;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The main method</b></font></p>
<p>The <b>main</b> method is shown in Listing 3.&nbsp; The sole purpose of this 
method is to instantiate an object of the class.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. The main method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public static void main(String[] args){
    new Java3D007();
  }//end main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Beginning of the constructor</b></font></p>
<p>The code for the constructor begins in Listing 4.&nbsp; Note that the first 
thing that happens in the constructor is the instantiation of a <b>Timer</b> 
object, which creates and passes an anonymous inner class as the second 
parameter to the constructor the <b>Timer</b> class.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  Java3D007(){//constructor 
    samplingTimer = new Timer(100,
      new ActionListener(){
        public void actionPerformed(ActionEvent e){          
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Not trivial code</b></font></p>
<p>This in not trivial code, particularly if you are unfamiliar with the use of 
anonymous inner classes in Java.&nbsp; The documentation for J2SE 5 shows three
<b>Timer</b> classes.&nbsp; This timer is constructed from the <b>
Timer</b> class in the <b>javax.swing</b> package <i>(see the import directives 
in Listing 15)</i>.</p>
<p>I'm not going to explain the underlying technology behind the use 
of anonymous inner classes in Java.&nbsp; I have previously published many 
tutorial lessons that explain those concepts.&nbsp; Furthermore, I used and 
discussed a timer very similar to this one in an earlier lesson titled &quot;Using 
the Full-Screen Exclusive Mode API in Java&quot; <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; I will simply refer you back to those earlier lessons 
for a detailed understanding of this code.</p>
<p>Briefly, however, this code will create a <b>javax.swing.Timer</b> object 
which, once started, will fire an <b>Action</b> event once each 100 milliseconds.&nbsp; 
The code in the overridden <b>actionPerformed</b> method that begins in Listing 
4 will get and save the current alpha value from each of the six <b>Alpha</b> objects each time the timer 
fires an event.</p>
<p><font color="#FF0000">
<b>Time to quit sampling</b></font></p>
<p>The overridden <b>actionPerformed</b> method begins with the if-clause of an <b>
if-else</b> construct in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Time to quit sampling. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          if(sampleTime &gt;= 10000){
            System.out.println("Elapsed time = " + 
                       (new Date().getTime() - baseTime));

            samplingTimer.stop();
            
            new Plotter();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the if-else construct</b></font></p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>An alternative approach</b><br />
  In retrospect, it may have been better to use the<b> </b>finished method 
	belonging to one or more of the Alpha objects to determine when to quit 
	taking samples.<b> </b>
</td></tr></table>
</td>
</tr>
</table>
<p>The first clause in the <b>if-else</b> construct tests to determine if 10000 
milliseconds have passed since the six <b>Alpha</b> objects were started, based 
on the value of the <b>sampleTime</b> variable that was declared and initialized 
in Listing 2, and is updated by 100 milliseconds each time a sample is taken.&nbsp; 
If true, three things happen:</p>
<ol>
	<li>Get and display the total elapsed time from the system clock</li>
	<li>Cause the timer to stop firing events</li>
	<li>Instantiate a new <b>Plotter</b> object to plot the alpha data values 
	that have been saved in the six arrays that were declared in Listing 1.</li>
</ol>
<p><font color="#FF0000"><b>This code is straightforward</b></font></p>
<p>None of the code required to accomplish these three things is complicated, so 
no further explanation should be required.</p>
<p>The <b>Plotter</b> object is instantiated from an inner class named <b>
Plotter</b>.&nbsp; As I explained earlier in this lesson, the code in that class 
is a simplified version of code that I explained in an earlier lesson <i>(see
<a href="#Resources">Resources</a>)</i>, so I won't repeat that explanation 
here.</p>
<p><font color="#FF0000"><b>The else clause</b></font></p>
<p>The <b>else</b> clause in the <b>if-else</b> structure in the overridden <b>
actionPerformed</b> method is shown in its entirety in Listing 6.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The else clause.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          }else{
            alpha1Data[sampleTime/100] = 
                                        alpha1Obj.value();
            alpha2Data[sampleTime/100] = 
                                        alpha2Obj.value();
            alpha3Data[sampleTime/100] = 
                                        alpha3Obj.value();
            alpha4Data[sampleTime/100] = 
                                        alpha4Obj.value();
            alpha5Data[sampleTime/100] = 
                                        alpha5Obj.value();
            alpha6Data[sampleTime/100] = 
                                        alpha6Obj.value();
          }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Getting six sample values</b></font></p>
<p>This code calls the method named <b>value</b> on each of the six <b>Alpha</b> 
objects to get and save a sample from each <b>Alpha</b> object.&nbsp; Here is part of 
what Sun has to say about the <b>value</b> method:</p>
<blockquote>
	<p><i>&quot;This method returns a value between 0.0 and 1.0 inclusive, based on 
	the current time and the time-to-alpha parameters established for this 
	alpha. If this alpha object is paused, the value will be based on the pause 
	time rather than the current time. This method will return the starting 
	alpha value if the alpha has not yet started (that is, if the current time 
	is less than startTime + triggerTime + phaseDelayDuration). This method will 
	return the ending alpha value if the alpha has finished (that is, if the 
	loop count has expired).&quot;</i></p>
</blockquote>
<p>I don't know how to elaborate on that other than to say that calling the <b>
value</b> method on an <b>Alpha</b> object once at the end of each 100 millisecond interval will produce a 
set of sampled values that describe the shape of the time function produced by 
the <b>Alpha</b> object.&nbsp; That is probably what an <b>Interpolator</b> 
object does when it uses an <b>Alpha</b> object to provide the necessary time-base information for generating the intermediate states of a universe that are 
required to produce an animated universe.</p>
<p>
<font color="#FF0000">
<b>End of anonymous inner class definition</b></font></p>
<p>Listing 7 shows the end of the overridden <b>actionPerformed</b> method as 
well as the end of the definition of the anonymous inner class.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. End of anonymous inner class definition. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          sampleTime += 100;
        
        }//end actionPerformed
      }//end new ActionListener
    );//end new javax.swing.Timer</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The overridden <b>actionPerformed</b> method contains one additional 
statement in Listing 7, which updates the <b>sampleTime</b> variable used in the conditional clause 
in Listing 5.&nbsp; This prepares the program for collecting samples the next 
time the timer fires an action event.</p>
<p><font color="#FF0000"><b>Instantiate the first Alpha object</b></font></p>
<p>This is where things get interesting.&nbsp; The code in Listing 8 begins the 
process of instantiating six new <b>Alpha</b> objects using different constructors and parameter lists. 
The Alpha objects are used to populate the arrays of alpha data under control of 
the timer discussed above.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Instantiate the first Alpha object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha1Obj = new Alpha(2,    //cycles
                          5000);//cycle duration up</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Only two parameters required</b></font></p>
<p>The code in Listing 8 instantiates a new <b>Alpha</b> object using a 
constructor that requires only two parameters and uses default values for the 
other eight required parameters.&nbsp; The time function produced by this <b>
Alpha</b> object is shown as the very top plot in Figure 3.</p>
<p><font color="#FF0000"><b>Two cycles at 5000 milliseconds each</b></font></p>
<p>Listing 8 specifies that when this <b>Alpha</b> object is started, it should 
produce two cycles of its time function with each cycle requiring a duration of 
5000 milliseconds.</p>
<p>The two parameters for which values are passed to this 
constructor are named <a href="#loopCount_">loopCount</a> and
<a href="#increasingAlphaDuration_">increasingAlphaDuration</a> in Figure 2.&nbsp;
<i>(I used somewhat shorter names in the comments in 
Listing 8.)</i>&nbsp; The default values for the remaining eight parameters 
shown in Figure 2 were used in constructing this object.&nbsp; <i>(I recommend 
that you click on the two links above and read the descriptions.&nbsp; This 
should help you to connect behavior with parameter names.)</i></p>
<p><font color="#FF0000"><b>When would this Alpha object be appropriate?</b></font></p>
<p>Many different types of animations can be produced by using <b>Interpolator</b> 
subclasses in conjunction with<b> Alpha</b> objects in Java 3D.&nbsp; For 
purposes of this discussion, let's consider the top time function in Figure 3 to 
represent the movement of a visual object in a Java 3D universe.&nbsp; For 
example, that visual object might be the big hand on a clock, a dragster on a drag 
strip, or a moon orbiting a planet.</p>
<p><font color="#FF0000"><b>The big hand on a clock</b></font></p>
<p>The time function at the top of Figure 3 might be ideal for animating the big 
hand on a clock.&nbsp; To begin with, the hands on clocks have very little mass 
and from a practical viewpoint appear to start and stop abruptly.&nbsp; 
Furthermore, when they are moving, they move at a constant angular velocity.</p>
<p>This <b>Alpha</b> object could be used to control the angular position of the 
big hand on the clock, with each cycle of the saw tooth in Figure 3 representing one 
complete rotation of the clock's big hand.&nbsp; By passing a value of -1 to the 
constructor in Listing 8, the <b>Alpha</b> object would continue producing the 
same saw tooth waveform indefinitely.</p>
<p><font color="#FF0000"><b>The position of a moon</b></font></p>
<p>While not quite as ideal, this <b>Alpha</b> object could also be used to 
control the position of a moon in a circular orbit around a planet.&nbsp; In 
fact this is the form of <b>Alpha</b> object that was used to control the 
rotation of the white sphere around the yellow sphere in the previous lesson 
titled &quot;Simple Animation with the Java 3D API&quot; <i>(see <a href="#Resources">
Resources</a>)</i>.&nbsp; 
For the case of moons and planets, it is often assumed that the moon is already orbiting 
the planet when the animation begins and will continue to do so indefinitely.&nbsp; 
Thus, none of the startup transients involved in getting the moon into orbit 
initially would typically come into play.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Do dragsters start and stop abruptly?</b><br />
  They don't start abruptly.&nbsp; Unfortunately, they may stop rather abruptly 
	when they run into an immovable obstacle.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>What about a dragster?</b></font></p>
<p>This would not be an appropriate <b>Alpha</b> object for controlling the 
animation of a dragster.&nbsp; Cars don't start moving abruptly and move with 
constant velocity until they suddenly stop abruptly.&nbsp; Rather, when the 
driver presses the accelerator pedal, the dragster starts moving, slowly at first and 
gaining velocity as time elapses.&nbsp; That is not the sort of time function 
represented by the top plot in Figure 3.&nbsp; When used to animate motion, the 
top plot in Figure 3 would represent something that starts and stops abruptly 
and moves at a constant velocity while it is moving.</p>
<p><font color="#FF0000">
<b>A delayed saw tooth time function</b></font></p>
<p>The <b>Alpha</b> object constructed in Listing 9 produces the delayed saw 
tooth time function shown in the second plot down from the top in Figure 3.&nbsp;
<i>(This constructor requires more parameters, but I passed the default values of 
zero to all but three of them.)</i></p>
<p>
<b><a name="Listing_9">Listing 9</a>. A delayed saw tooth time function. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha2Obj = new Alpha(2,   //cycles
                          1000,//trigger time
                          0,   //phase delay
                          5000,//cycle duration up
                          0,   //ramp duration for up
                          0);  //duration at one</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The triggerTime parameter</b></font></p>
<p>Note that for this object, the time function in Figure 3 remains at a value of zero for 
the first 1000 milliseconds after startup, at which time it starts to behave just like the 
object that produced the top plot in Figure 3.&nbsp; This resulted from 
specifying a value of 1000 for the second parameter in Listing 9.</p>
<p>This parameter is named <a href="#triggerTime_">triggerTime</a> in the 
earlier description of the parameters.&nbsp; If you go back and read that 
description, the reason for this behavior will probably make sense to you.</p>
<p>Frankly, I have scratched my head and haven't come up with any practical 
examples for the use of a time-delayed time function of this sort.&nbsp; However, I'm sure 
that there are some or Sun wouldn't have included this capability in Java 3D.</p>
<p><font color="#FF0000">
<b>Even more delay</b></font></p>
<p>The <b>Alpha</b> object instantiated in Listing 10 produced the third plot 
down from the top in Figure 3.&nbsp; This was accomplished by passing a value of 
500 as the third parameter in the constructor.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Even more delay. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha3Obj = new Alpha(2,   //cycles
                          1000,//trigger time
                          500, //phase delay
                          5000,//cycle duration up
                          0,   //ramp duration for up
                          0);  //duration at one</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The phaseDelayDuration parameter</b></font></p>
<p>This parameter is named <a href="#phaseDelayDuration_">phaseDelayDuration</a>, 
and it provides a mechanism for inserting an additional delay into the start of 
the time function following the <a href="#phaseDelayDuration_">triggerTime</a> 
delay.</p>
<p>This behavior is evident in the third plot in Figure 3, which shows that the 
function remained at a value of zero for 500 milliseconds in addition to the 
1000 millisecond delay produced by the <a href="#triggerTime_">triggerTime</a> 
delay.</p>
<p>Once again, since I was unable to come up with a practical example for the 
use of a single delay, I was also unable to come up with a practical example for 
two sequential delays.</p>
<p><font color="#FF0000">
<b>Going from 1.0 to 0.0</b></font></p>
<p>An <b>Alpha</b> object not only has the ability to produce a time function 
that increases from 0.0 to 1.0 in a specified manner, it also has the ability to 
produce a time function that decreases from 1.0 to 0.0 in a specified manner.&nbsp; 
As you will see later, it also has the ability to produce a time function that 
is the combination of the two.</p>
<p>The <b>Alpha</b> object that resulted from calling the constructor shown 
in Listing 11 produced the time function shown in the fourth plot from the top 
in Figure 3.</p>

<p>
<b><a name="Listing_11">Listing 11</a>. Going from 1.0 to 0.0 </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha4Obj = new Alpha(2,   //cycles
                          Alpha.DECREASING_ENABLE,//mode
                          0,   //trigger time
                          0,   //phase delay
                          0,   //cycle duration up
                          0,   //ramp duration for up
                          0,   //duration at one
                          5000,//cycle duration down
                          0,   //ramp duration for down
                          0);  //duration at zero</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Using a value of Alpha.DECREASING_ENABLE for mode</b></font></p>
<p>In this case, it was necessary to use the most complex constructor requiring 
the specification of all ten parameters.&nbsp; Note however, that with one 
exception, I provided parameter values that matched the default values used by 
the constructor in Listing 8.&nbsp; Thus, as a practical matter, the only 
difference between Listing 11 and Listing 8 was the specification of the value
<b>Alpha.DECREASING_ENABLE</b> for the parameter named <a href="#mode_">mode</a> 
in Listing 11.</p>
<p><font color="#FF0000"><b>Two allowable values</b></font></p>
<p>There are only two allowable values for this parameter:</p>
<ul>
	<li>Alpha.INCREASING_ENABLE</li>
	<li>Alpha.DECREASING_ENABLE</li>
</ul>
<p>The first of the two values in the above list is the default value as 
shown in Figure 2.</p>
<p><font color="#FF0000"><b>Behavior imparted by the two values for the mode 
parameter</b></font></p>
<p>The <b>Alpha.INCREASING_ENABLE </b>value results in an <b>Alpha</b> object 
whose time function increases from 0.0 to 1.0.</p>
<p>The <b>Alpha.DECREASING_ENABLE</b> 
value results on an <b>Alpha</b> object whose time function decreases from 1.0 
to 0.0.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Many variations are possible</b><br />
  Note that it is possible to use either or a combination of these two values 
	for mode with many different combinations of the other nine required 
	parameters.
</td></tr></table>
</td>
</tr>
</table>
<p>As you will see later, it is also possible to perform a bitwise OR on 
the two values producing an <b>Alpha</b> object whose time function first 
increases from 0.0 to 1.0 and then decreases from 1.0 back down to 0.0.</p>
<p><font color="#FF0000"><b>Compare the two plots</b></font></p>
<p>If you compare the top plot in Figure 3, which was produced using the default
<b>Alpha.INCREASING_ENABLE</b> value for the <a href="#mode_">mode</a> parameter 
with the fourth plot, which was produced using an explicit <b>Alpha.DECREASING_ENABLE</b> 
value for the <a href="#mode_">mode</a> parameter, you will see the results of 
an increasing or a decreasing time function.</p>
<p><font color="#FF0000"><b>A possible usage scenario</b></font></p>
<p>It might be useful to combine one cycle of the time function in the fourth 
plot with one cycle of the time function in the top plot to cause a visual 
object to move from point A to point B at a constant velocity and then return 
from point B to point A at the same, or perhaps a different constant velocity.&nbsp; 
However, as you will see later, there is an easier way to accomplish that 
behavior by performing a bitwise OR on the two allowable values.</p>
<p><font color="#FF0000"><b>Another aspect of the mode parameter</b></font></p>
<p>Another aspect of the <a href="#mode_">mode</a> parameter is that by passing 
a value of <b>Alpha.INCREASING_ENABLE</b>, you will enable the parameters in the 
following list and disable the 
parameters in the list titled <i>Decreasing Alpha parameters</i>.</p>
<ul>
	<li><b><a name="Increasing_Alpha_parameters">Increasing Alpha parameters</a>:
	</b>
	<ul>
		<li>increasingAlphaDuration </li>
		<li>increasingAlphaRampDuration</li>
		<li>alphaAtOneDuration</li>
	</ul>
	</li>
</ul>
<p>Passing a parameter value of <b>Alpha.DECREASING_ENABLE</b> will enable the 
parameters in the following list and disable the parameters in the above list 
titled <i>Increasing Alpha parameters</i>.</p>
<ul>
	<li><b><a name="Decreasing_Alpha_parameters">Decreasing Alpha parameters</a>:
	</b>
	<ul>
		<li>decreasingAlphaDuration </li>
		<li>decreasingAlphaRampDuration </li>
		<li>alphaAtZeroDuration</li>
	</ul>
	</li>
</ul>
<p><font color="#FF0000">
<b>A mode for moving objects with significant mass</b></font></p>
<p>Now let's go back to the dragster scenario.&nbsp; The code in Listing 12 
produced the fifth plot down from the top in Figure 3.&nbsp; A single cycle of 
this time function might be appropriate for animating the motion of a dragster.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. A mode for moving objects with 
significant mass. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha5Obj = new Alpha(2,   //cycles
                          0,   //trigger time
                          0,   //phase delay
                          5000,//cycle duration up
                          2000,//ramp duration for up
                          0);  //duration at one</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The parameter named increasingAlphaRampDuration</b></font></p>
<p>The significant thing in Listing 12 is the specification of 2000 milliseconds 
for the parameter named <a href="#increasingAlphaRampDuration_">
increasingAlphaRampDuration</a>.&nbsp; If we apply this time function to our idealized 
dragster, the driver presses the accelerator pedal to the floor at the extreme 
left end of the fifth plot in Figure 3.&nbsp; The dragster starts moving, slowly at first with 
the velocity increasing over time.&nbsp; This curve describes constant positive 
acceleration and increasing velocity for the first 2000 milliseconds <i>(out to 
the second tick mark on the horizontal axis)</i>.</p>
<p><font color="#FF0000"><b>The dragster won't go any faster</b></font></p>
<p>At that point, the dragster has achieved its maximum velocity and moves at a 
constant velocity for the next 1000 milliseconds <i>(out to the third tick mark)</i>.&nbsp;
<i>(For those readers with an engineering or scientific bent, the velocity is 
indicated by the slope of the time function.&nbsp; The slope of the 
function continues to increase out to the second tick mark and is constant 
between the second and third tick marks.)</i></p>
<p><font color="#FF0000"><b>Time to slow down and stop</b></font></p>
<p>At the third tick mark, the dragster crosses the finish line and the driver 
applies the brakes, deploys the parachute, or both.&nbsp; From that point to the 
fifth tick mark, the dragster is slowing down with a constant negative acceleration.&nbsp;
<i>(The slope of the function is decreasing with time.)</i>&nbsp; Finally, the 
velocity of the dragster goes to zero at the fifth tick mark <i>(5000 milliseconds or 
the time for one cycle) </i>where the slope of the function is flat with a slope 
of zero.</p>
<p><font color="#FF0000"><b>The dragster has covered quite a lot of ground</b></font></p>
<p>At this point, the dragster has moved a considerable distance down the drag strip 
so the value of the function, which began at 0, is now at 100.&nbsp; <i>(The 
sample values from the Alpha object were all multiplied by 100 for plotting in 
Figure 3.&nbsp; Therefore, a plotted value of 100 equates to an alpha value of 
1.0.)</i></p>
<p><font color="#FF0000"><b>What if you change the value of the mode parameter?</b></font></p>
<p>The constructor that was used in Listing 12 used a default value of <b>
Alpha.INCREASING_ENABLE</b> for the <a href="#mode_">mode</a> parameter.&nbsp; 
If we were to rewrite this code using the constructor that allows us to specify 
the <a href="#mode_">mode</a> value, and were to specify a value of <b>Alpha.DECREASING_ENABLE</b>, 
the shape of the curve would be flipped upside down going from its maximum value 
at zero time to a value of zero at 5000 milliseconds.</p>
<p><font color="#FF0000">
<b>Combining the mode values with a bitwise OR</b></font></p>
<p>That brings us to the last, and most complicated of the six <b>Alpha</b> 
objects as shown in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Combining the mode values with a bitwise 
OR. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    alpha6Obj = new Alpha(2,   //cycles
                          Alpha.INCREASING_ENABLE //mode
                                | Alpha.DECREASING_ENABLE,
                          0,   //trigger time
                          0,   //phase delay
                          2500,//cycle duration up
                          1000,//ramp duration for up
                          0,   //duration at one
                          2500,//cycle duration down
                          1000,//ramp duration for down
                          0);  //duration at zero</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>First an increase and then a decrease</b></font></p>
<p>In this case, the value passed to the <a href="#mode_">mode</a> parameter was 
the bitwise OR of the two allowable mode values.&nbsp; 
Basically this causes the function to increase from 0.0 to 1.0 according to the 
values provided for the three <a href="#Increasing_Alpha_parameters">Increasing 
Alpha parameters</a> listed above and then to decrease from 1.0 to 0.0 according 
to the three <a href="#Decreasing_Alpha_parameters">Decreasing Alpha parameters</a> 
listed above.</p>
<p>Thus, a complete cycle includes an increasing component followed by a 
decreasing component.&nbsp; In this case, I wanted the total cycle time to 
remain at 5000 milliseconds, so I set the duration for each of the increasing and 
decreasing portions to 2500 milliseconds.&nbsp; I also provided the ramp 
duration values shown in Listing 13 for both the increasing and decreasing 
portions.</p>
<p>The code in Listing 13 resulted in an <b>Alpha</b> object that produced the 
time function shown in the bottom plot in Figure 3.&nbsp; <i>(Note that Figure 3 
shows two complete cycles for every plot including the bottom one.)</i></p>
<p><font color="#FF0000"><b>A pendulum</b></font></p>
<p>The function shown in the bottom plot in Figure 3 might be appropriate for 
animating a pendulum.&nbsp; Assume that you manually pull the pendulum to an 
extreme position on the left side and hold it there.&nbsp; That position would 
be represented by the zero value of the function at the extreme left of the 
plot.</p>
<p>Now assume that you turn the pendulum loose and allow it to swing.&nbsp; One 
complete cycle of the pendulum from an extreme position on the left side to the 
extreme position on the right side and back to the extreme position on the left 
side could be represented by one cycle of the function in the bottom plot of 
Figure 3.&nbsp; The extreme position on the right side would be represented by 
the maximum value of the function.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A more accurate physical model</b><br />
  If I remember my physics correctly, to more closely model the physics of a 
	pendulum, I probably should have set the two ramp values to 1250 
	milliseconds instead of 1000 milliseconds.
</td></tr></table>
</td>
</tr>
</table>
<p>The maximum positive and negative velocities would occur on the two sides of the cycle where the 
magnitude of the slope of the function is at its maximum.&nbsp; Physically, this 
would represent the velocity of the pendulum as it goes through the bottom of 
its swing in each direction.</p>
<p><font color="#FF0000">
<b>The end of the constructor</b></font></p>
<p>That is the end of the discussion of the instantiation of the six <b>Alpha</b> 
objects.</p>
<p>The first statement in Listing 14 gets and saves the current time from the 
system clock to be used later to compute the total elapsed time for the <b>Alpha</b> 
objects to generate two complete cycles of data.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. The end of the constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    baseTime = new Date().getTime();
    samplingTimer.start();

  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The last statement in Listing 14 starts the timer running and gets the 
acquisition of the alpha values from the six <b>Alpha</b> objects underway.</p>
<p>Listing 14 signals the end of the constructor and almost signals the end of the 
discussion.&nbsp; However, there are a few more things that I need to mention 
before the discussion ends.</p>
<p><font color="#FF0000"><b>Two more parameters</b></font></p>
<p>There are two parameters in the <a href="#Four_overloaded_constructors">list 
of ten</a> parameters that are not illustrated by this program:</p>
<ul>
	<li><b>alphaAtOneDuration</b></li>
	<li><b>alphaAtZeroDuration</b></li>
</ul>
<p>The behavior of these two parameters is straightforward.&nbsp; A non-zero 
value for either parameter causes the alpha value to remain at either the value 
of 1.0 or the value of 0.0 for the specified amount of time at the end of a cycle before 
it begins the next cycle.</p>
<p><font color="#FF0000"><b>Numerous methods</b></font></p>
<p>An <b>Alpha</b> object provides numerous methods.&nbsp; The list of methods 
includes setter and getter methods for all ten of the parameters in the
<a href="#Four_overloaded_constructors">list of ten</a> parameters.&nbsp; This 
makes it possible to set and get the values for those parameters for an existing
<b>Alpha</b> object.</p>
<p>There are also methods for causing an <b>Alpha</b> object to start running at 
a specified time according to the system clock and for causing an <b>Alpha</b> 
object to pause.</p>
<p><font color="#FF0000"><b>A wide variety of time functions is available</b></font></p>
<p>Hopefully by now you have recognized that by combining 
different values for the ten constructor parameters for the <b>Alpha</b> class, you can generate 
quite a variety of time functions to control your animations in Java 3D.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 15 into your text editor, 
compile it, and execute it.&nbsp; Experiment with it, making changes, and observing 
the results of your changes.</p>
<p>Remember, you will need to download and install the Java 3D API plus either 
Microsoft DirectX or OpenGL to compile and execute these programs.&nbsp; See
<a href="#Download">Downloads</a> for links to the web sites from 
which this material can be downloaded. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>Understanding the <b>Alpha</b> class is critical to understanding Java 3D 
animation.&nbsp; The constructors for the <b>Alpha</b> class can require up to ten 
parameters.&nbsp; Understanding the purpose of those parameters and the behavior 
imparted by those parameters is far from trivial.&nbsp; In this lesson, I taught you about the detailed behavior of objects instantiated from the <b>Alpha</b> 
class, with particular emphasis on understanding the behavior imparted by each 
of the ten parameters.&nbsp; In many cases, I provided practical suggestions as 
to an animation scenario in which a particular parameter value might be 
appropriate.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The topics for future lessons include interactive Java 3D programs, advanced 
animation, and surfaces.&nbsp; I plan to deal with interaction in the next 
lesson.</p>
<h2 align="center"><a name="Download">Download</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/developer/onlineTraining/java3d/javaa3d.zip">
	Getting Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by 
	Dennis J Bouvier</li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/collateral/examples.zip">
	Source code</a> for example programs from the Bouvier tutorial above</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Version 1.5.0</a> of the Java 3D API</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Implementation documentation</a> for version 1.5.0 of the Java 3D API</li>
	<li>
	<a href="http://www.gamesforwindows.com/en-US/AboutGFW/Pages/DirectX10.aspx">
	Microsoft DirectX10</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/java-media/3D/">Main page</a> for 
	the Java 3D API</li>
	<li>Java 3D <a href="http://wiki.java.net/bin/view/Javadesktop/Java3DFAQ">
	FAQ</a></li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/reference/api/index.html">
	Online documentation</a> for Java 3D version 1.3 <i>(see
	<a href="#Download">Download</a> for v1.5.0 
	documentation)</i></li>
	<li><a href="http://java.sun.com/developer/onlineTraining/java3d/">Getting 
	Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by Dennis J 
	Bouvier</li>
	<li>
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/javax/media/j3d/doc-files/intro.html">
	Introduction to the Java 3D API</a> with links to other tutorial information</li>
	<li>Various Java 3D <a href="http://www.java3d.org/">resources</a></li>
	<li>Another Java 3D <a href="http://www.java3d.org/tutorial.html">tutorial</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/626051">306</a> 
	Java 2D Graphics, Simple Affine Transforms&nbsp;</li>
	<li>
	<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
	1468</a> Plotting Engineering and Scientific Data using Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3609776">1496</a> Using the Full-Screen Exclusive Mode API 
	in Java</li>
	<li><a href="http://www.developer.com/java/other/article.php/3622246">1540</a> 
	Understanding Lighting in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3701536">1541</a> Back to Basics in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3704116">1542</a> Digging a Little Deeper into the Java 3D API</li>
	<li><a href="http://www.developer.com/java/data/article.php/3706721">1544</a> Simple Animation with the Java 3D API</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program discussed in this lesson is presented in
Listing 15 below.
<p>
<b><a name="Listing_15">Listing 15</a>. Source code for the program named Java3D007. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/* File Java3D007.java
Copyright 2007, R.G.Baldwin

The purpose of this program is to investigate and 
illustrate the behavior of the Java 3D class named Alpha
as a function of the values passed as parameters when
an Alpha object is instantiated.

The class named Alpha is a programmable time-base program
that is used mainly to control animations, but could be
used for any purpose that requires a programmable time
base.

The object generates and provides an alpha value ranging 
from 0.0 to 1.0 over a specified elapsed cycle time.  The 
shape of the time function described by the alpha
value is controlled by parameters that are passed to the
constructor when the object is instantiated.  The number
of repetitive cycles of the alpha value that will be
produced is an input parameter.  A value of -1 will cause
the object to continue producing repetitive alpha values
until it is purposely terminated.

The object has a method named value(), which can be used
to sample the alpha value at any point in time.
By using a clock and sampling the alpha value at a set of
equally spaced points in time, a set of sample values can
be obtained that describe the alpha time function.

The Alpha class contains four overloaded constructors. The
most complex constructor requires ten parameters.  The
only differences among the constructors is that some of
the constructors default some of the ten required
parameters, resulting in constructors having different
numbers of parameters.

This program constructs six different Alpha objects, each
having different parameter values.  All six constructors
run for two cycles with a duration of five seconds per 
cycle.  Thus, each Alpha object generates alpha values 
during a time span of ten seconds (10,000 milliseconds).

A timer is used to collect 100 samples from each Alpha
object spaced at uniform intervals of 100 milliseconds
during the total elapsed time of ten seconds.

As a quality check, the system clock is used to get and
print the total elapsed time during which the Alpha
objects are generating data.

Each set of 100 samples is plotted in a format that 
displays the six plots in a vertical stack, one plot above
the other.  The plot data is scaled so that a value of 1.0
produced by an Alpha object is plotted as a value of 100 
on the plot.

The plotting software is a simplified version of the 
program named Graph01 that was published earlier in a
tutorial lesson number 1468 titled  "Plotting Engineering 
and Scientific Data using Java."


Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import javax.media.j3d.Alpha;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.Frame;
import java.util.Date;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Java3D007{
  
  Alpha alpha1Obj;
  Alpha alpha2Obj;
  Alpha alpha3Obj;
  Alpha alpha4Obj;
  Alpha alpha5Obj;
  Alpha alpha6Obj;
  
  float[] alpha1Data = new float[100];
  float[] alpha2Data = new float[100];
  float[] alpha3Data = new float[100];
  float[] alpha4Data = new float[100];
  float[] alpha5Data = new float[100];
  float[] alpha6Data = new float[100];
  
  //Initialize the sampleTime counter to the time that the
  // first sample will be taken.
  int sampleTime = 100;
  //Used to compute the actual elapsed time from the
  // system clock.
  long baseTime;
  //Timer used to trigger the collection of samples of the
  // alpha values.
  Timer samplingTimer;
  
  public static void main(String[] args){
    new Java3D007();
  }//end main
  //----------------------------------------------------//
  
  Java3D007(){//constructor
    
    //Create a timer that will fire once each 100
    // milliseconds.  Get and save the current alpha value
    // from each Alpha object each time the timer fires, 
    samplingTimer = new Timer(100,
      new ActionListener(){
        public void actionPerformed(ActionEvent e){

          
          
          if(sampleTime &gt;= 10000){
            //Time to quit taking samples.  Get and
            // display the actual elapsed time from the
            // system clock.
            System.out.println("Elapsed time = " + 
                       (new Date().getTime() - baseTime));
            //Cause the timer to quit firing events.
            samplingTimer.stop();
            
            //Instantiate a Plotter object, which will
            // cause the data in the arrays to be plotted.
            new Plotter();
          }else{
            //Get and save a sample from each Alpha
            // object.
            alpha1Data[sampleTime/100] = 
                                        alpha1Obj.value();
            alpha2Data[sampleTime/100] = 
                                        alpha2Obj.value();
            alpha3Data[sampleTime/100] = 
                                        alpha3Obj.value();
            alpha4Data[sampleTime/100] = 
                                        alpha4Obj.value();
            alpha5Data[sampleTime/100] = 
                                        alpha5Obj.value();
            alpha6Data[sampleTime/100] = 
                                        alpha6Obj.value();
          }//end else
          
          //Update the sample time to prepare for 
          // collecting the next sample when the timer
          // fires again.
          sampleTime += 100;
        
        }//end actionPerformed
      }//end new ActionListener
    );//end new javax.swing.Timer

    
    //Instantiate new Alpha objects using different
    // constructors and parameter lists. Use them to
    // populate arrays of alpha data.
    alpha1Obj = new Alpha(2,    //cycles
                          5000);//cycle duration up

    alpha2Obj = new Alpha(2,   //cycles
                          1000,//trigger time
                          0,   //phase delay
                          5000,//cycle duration up
                          0,   //ramp duration for up
                          0);  //duration at one

    alpha3Obj = new Alpha(2,   //cycles
                          1000,//trigger time
                          500, //phase delay
                          5000,//cycle duration up
                          0,   //ramp duration for up
                          0);  //duration at one

    alpha4Obj = new Alpha(2,   //cycles
                          Alpha.DECREASING_ENABLE,//mode
                          0,   //trigger time
                          0,   //phase delay
                          0,   //cycle duration up
                          0,   //ramp duration for up
                          0,   //duration at one
                          5000,//cycle duration down
                          0,   //ramp duration for down
                          0);  //duration at zero
 
    alpha5Obj = new Alpha(2,   //cycles
                          0,   //trigger time
                          0,   //phase delay
                          5000,//cycle duration up
                          2000,//ramp duration for up
                          0);  //duration at one

    alpha6Obj = new Alpha(2,   //cycles
                          Alpha.INCREASING_ENABLE //mode
                                | Alpha.DECREASING_ENABLE,
                          0,   //trigger time
                          0,   //phase delay
                          2500,//cycle duration up
                          1000,//ramp duration for up
                          0,   //duration at one
                          2500,//cycle duration down
                          1000,//ramp duration for down
                          0);  //duration at zero
                          
                          
    //Get the start time from the system clock to be used
    // later to compute the actual elapsed time as a
    // quality check.    
    baseTime = new Date().getTime();
    samplingTimer.start();

  }//end constructor
  //===================================================//

  
  //This is an inner plotting class
  class Plotter extends JFrame{

    //Define plotting parameters.
    double xMin = 0.0;
    double xMax = 100.0;
    double yMin = -10.0;
    double yMax = 100.0;
 
    //Tic mark intervals
    double xTicInt = 10.0;
    double yTicInt = 10.0;
  
    //Tic mark lengths.
    double xTicLen = (yMax-yMin)/20;
    double yTicLen = (xMax-xMin)/20;
  
    //Calculation interval along x-axis
    double xCalcInc = 1.0;

    //Misc instance variables
    int frmWidth = 408;
    int frmHeight = 700;
    int width;
    int height;
    int numberPlots = 6;
  
    //Plots are drawn on the canvases
    // in this array.
    Canvas[] canvases;
  
    //Constructor
    Plotter(){
      //Create array to hold correct
      // number of Canvas objects.
      canvases = new Canvas[numberPlots];

      //Create a panel to contain the
      // Canvas objects.  They will be
      // displayed in a one-column grid.
      JPanel canvasPanel = new JPanel();
      canvasPanel.setLayout(//?rows,1 col
                    new GridLayout(0,1));
  
      //Create a custom Canvas object for
      // each function to be plotted and
      // add them to the one-column grid.
      // Make background colors alternate
      // between white and gray.
      for(int cnt = 0;cnt &lt; numberPlots;cnt++){
        switch(cnt){
          case 0 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.WHITE);
            break;
          case 1 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.LIGHT_GRAY);
            break;
          case 2 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.WHITE);
            break;
          case 3 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.LIGHT_GRAY);
            break;
          case 4 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.WHITE);
            break;
          case 5 :
            canvases[cnt] = new MyCanvas(cnt);
            canvases[cnt].setBackground(Color.LIGHT_GRAY);
            break;
        }//end switch
        //Add the object to the grid.
        canvasPanel.add(canvases[cnt]);
      }//end for loop
  
      //Add the sub-assemblies to the
      // frame.  Set its location, size,
      // and title, and make it visible.
      getContentPane().
               add(canvasPanel,"Center");
  
      setBounds(0,0,frmWidth,frmHeight);
      setTitle("Copyright 2007, " +
                   "Richard G. Baldwin");
      setVisible(true);
  
      //Set to exit on X-button click
      setDefaultCloseOperation(
                          EXIT_ON_CLOSE);
  
      //Get and save the size of the
      // plotting surface
      width = canvases[0].getWidth();
      height = canvases[0].getHeight();

      //Guarantee a repaint on startup.
      for(int cnt = 0;
               cnt &lt; numberPlots; cnt++){
        canvases[cnt].repaint();
      }//end for loop
  
    }//end constructor
    //---------------------------------//
  
  
    //This is an inner class, which is used
    // to override the paint method on the
    // plotting surface.
    class MyCanvas extends Canvas{
      int cnt;//object number
      //Factors to convert from double
      // values to integer pixel locations.
      double xScale;
      double yScale;
    
      MyCanvas(int cnt){//save obj number
        this.cnt = cnt;
      }//end constructor
    
      //Override the paint method
      public void paint(Graphics g){
        //Calculate the scale factors
        xScale = width/(xMax-xMin);
        yScale = height/(yMax-yMin);
    
        //Set the origin based on the
        // minimum values in x and y
        g.translate((int)((0-xMin)*xScale),
                   (int)((0-yMin)*yScale));
        drawAxes(g);//Draw the axes
        g.setColor(Color.BLACK);
    
        //Get initial data values
        double xVal = xMin;
        int oldX = getTheX(xVal);
        int oldY = 0;
        //Use the Canvas obj number to
        // determine which method to
        // invoke to get the value for y.
  
        //Now loop and plot the points
        while(xVal &lt; xMax){
          int yVal = 0;
          //Get next data value.  Use the
          // Canvas obj number to
          // determine which array to query
          // to get the value for y
  
          switch(cnt){
            case 0 :
              yVal =
                getTheY((int)(100*alpha1Data[(int)xVal]));
              break;
            case 1 :
              yVal =
                getTheY((int)(100*alpha2Data[(int)xVal]));
              break;
            case 2 :
              yVal =
                getTheY((int)(100*alpha3Data[(int)xVal]));
              break;
            case 3 :
              yVal =
                getTheY((int)(100*alpha4Data[(int)xVal]));
              break;
            case 4 :
              yVal =
                getTheY((int)(100*alpha5Data[(int)xVal]));
              break;
            case 5 :
              yVal =
                getTheY((int)(100*alpha6Data[(int)xVal]));
          }//end switch1
  
          //Convert the x-value to an int
          // and draw the next line segment
          int x = getTheX(xVal);
          g.drawLine(oldX,oldY,x,yVal);
    
          //Increment along the x-axis
          xVal += xCalcInc;
    
          //Save end point to use as start
          // point for next line segment.
          oldX = x;
          oldY = yVal;
        }//end while loop
    
      }//end overridden paint method
      //---------------------------------//
    
      //Method to draw axes with tic marks
      // and labels in the color RED
      void drawAxes(Graphics g){
        g.setColor(Color.RED);
    
        //Lable left x-axis and bottom
        // y-axis.  These are the easy
        // ones.  Separate the labels from
        // the ends of the tic marks by
        // two pixels.
        g.drawString("" + (int)xMin,
                     getTheX(xMin),
                     getTheY(xTicLen/2)-2);
        g.drawString("" + (int)yMin,
                      getTheX(yTicLen/2)+2,
                            getTheY(yMin));
    
        //Label the right x-axis and the
        // top y-axis.  These are the hard
        // ones because the position must
        // be adjusted by the font size and
        // the number of characters.
        //Get the width of the string for
        // right end of x-axis and the
        // height of the string for top of
        // y-axis
        //Create a string that is an
        // integer representation of the
        // label for the right end of the
        // x-axis.  Then get a character
        // array that represents the
        // string.
        int xMaxInt = (int)xMax;
        String xMaxStr = "" + xMaxInt;
        char[] array = xMaxStr.
                             toCharArray();
    
        //Get a FontMetrics object that can
        // be used to get the size of the
        // string in pixels.
        FontMetrics fontMetrics =
                        g.getFontMetrics();
        //Get a bounding rectangle for the
        // string
        Rectangle2D r2d =
               fontMetrics.getStringBounds(
                   array,0,array.length,g);
        //Get the width and the height of
        // the bounding rectangle.  The
        // width is the width of the label
        // at the right end of the
        // x-axis.  The height applies to
        // all the labels, but is needed
        // specifically for the label at
        // the top end of the y-axis.
        int labWidth =
                     (int)(r2d.getWidth());
        int labHeight =
                    (int)(r2d.getHeight());
    
        //Label the positive x-axis and the
        // positive y-axis using the width
        // and height from above to
        // position the labels.  These
        // labels apply to the very ends of
        // the axes at the edge of the
        // plotting surface.
        g.drawString("" + (int)xMax,
                    getTheX(xMax)-labWidth,
                     getTheY(xTicLen/2)-2);
        g.drawString("" + (int)yMax,
                  getTheX(yTicLen/2)+2,
                  getTheY(yMax)+labHeight);
    
        //Draw the axes
        g.drawLine(getTheX(xMin),
                             getTheY(0.0),
                             getTheX(xMax),
                             getTheY(0.0));
    
        g.drawLine(getTheX(0.0),
                            getTheY(yMin),
                            getTheX(0.0),
                            getTheY(yMax));
    
        //Draw the tic marks on axes
        xTics(g);
        yTics(g);
      }//end drawAxes
    
      //---------------------------------//
    
      //Method to draw tic marks on x-axis
      void xTics(Graphics g){
        double xDoub = 0;
        int x = 0;
    
        //Get the ends of the tic marks.
        int topEnd = getTheY(xTicLen/2);
        int bottomEnd =
                       getTheY(-xTicLen/2);
    
        //If the vertical size of the
        // plotting area is small, the
        // calculated tic size may be too
        // small.  In that case, set it to
        // 10 pixels.
        if(topEnd &lt; 5){
          topEnd = 5;
          bottomEnd = -5;
        }//end if
    
        //Loop and draw a series of short
        // lines to serve as tic marks.
        // Begin with the positive x-axis
        // moving to the right from zero.
        while(xDoub &lt; xMax){
          x = getTheX(xDoub);
          g.drawLine(x,topEnd,x,bottomEnd);
          xDoub += xTicInt;
        }//end while
    
        //Now do the negative x-axis moving
        // to the left from zero
        xDoub = 0;
        while(xDoub &gt; xMin){
          x = getTheX(xDoub);
          g.drawLine(x,topEnd,x,bottomEnd);
          xDoub -= xTicInt;
        }//end while
    
      }//end xTics
      //---------------------------------//
    
      //Method to draw tic marks on y-axis
      void yTics(Graphics g){
        double yDoub = 0;
        int y = 0;
        int rightEnd = getTheX(yTicLen/2);
        int leftEnd = getTheX(-yTicLen/2);
    
        //Loop and draw a series of short
        // lines to serve as tic marks.
        // Begin with the positive y-axis
        // moving up from zero.
        while(yDoub &lt; yMax){
          y = getTheY(yDoub);
          g.drawLine(rightEnd,y,leftEnd,y);
          yDoub += yTicInt;
        }//end while
    
        //Now do the negative y-axis moving
        // down from zero.
        yDoub = 0;
        while(yDoub &gt; yMin){
          y = getTheY(yDoub);
          g.drawLine(rightEnd,y,leftEnd,y);
          yDoub -= yTicInt;
        }//end while
    
      }//end yTics
    
      //---------------------------------//
    
      //This method translates and scales
      // a double y value to plot properly
      // in the integer coordinate system.
      // In addition to scaling, it causes
      // the positive direction of the
      // y-axis to be from bottom to top.
      int getTheY(double y){
        double yDoub = (yMax+yMin)-y;
        int yInt = (int)(yDoub*yScale);
        return yInt;
      }//end getTheY
      //---------------------------------//
    
      //This method scales a double x value
      // to plot properly in the integer
      // coordinate system.
      int getTheX(double x){
        return (int)(x*xScale);
      }//end getTheX
      //---------------------------------//
    
    }//end inner class MyCanvas
    //===================================//
  
  }//end inner class Plotter
  //====================================================//

  
}//end class Java3D007</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java &quot;java 3D&quot; Alpha Interpolator </p>
<p>-end- </p>
</body>
</html>
