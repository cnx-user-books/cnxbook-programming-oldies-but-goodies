<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Standard Input and Output in Java by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Standard Input and Output Streams<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 34, Revised 10/03/99</P>
<P><!-toc file=Java034a.htm words=Preface-><A HREF="#preface">Preface</A><BR>
<!--endtoc--><!-toc file=Java034b.htm words=Discussion-><A HREF="#discussion">Discussion</A><BR>
<!--endtoc--><!-toc file=Java034c.htm words=Review-><A HREF="#review">Review</A><!--endtoc--> </P>
<P><!-next=Java034a.htm><!-first=Java034.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of those persons who are already familiar with C++ and who are making the transition into Java. <!-prev=Java034.htm-></P>
<!-next=Java034b.htm><!-first=Java034.htm->
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="discussion"></A>Discussion</H2>
</FONT><B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is a stream?</P>
</B></I></FONT><P>Both Java and C++ support the notion of input and output streams. In both cases, the notion represents a stream of bytes entering into the program from an external source, or a stream of bytes flowing from the program to an external sink. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is standard I/O?</P>
</B></I></FONT><P>The <I>standard input</I> and <I>standard output</I> stream notion is based on the concept of working on a system that has a <I>standard input device</I> and a <I>standard output device</I>. </P>
<P>On DOS and UNIX systems, the default <I>standard input device</I> is the keyboard, but it can be redirected to a different device at the operating system level. </P>
<P>Likewise, the default <I>standard output device</I> is the screen, but it can be redirected at the operating system level to another device. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is I/O redirection?</P>
</B></I></FONT><P>DOS users will be familiar with the following command that causes a directory listing to be produced and stored in a disk file named <B>director.txt</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>dir &gt; director.txt</PRE></TD>
</TR>
</TABLE>

<P>This is a DOS command that <I>redirects</I> the standard output to a device other than the screen: namely to a disk file. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The read() method</P>
</B></I></FONT><P>The Java <B>read()</B> method can read and return a single byte from the <I>standard input device</I> and <U>store that byte in an integer</U><I>.</I> It returns an integer value of <B>-1</B> if it encounters an end-of-file (<B>eof</B>). </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Why store it in an int?</P>
</B></I></FONT><P>Storing the byte into the low end of an integer, makes it possible for the program to distinguish between the integer value of -1 for <B>eof</B> and the 8-bit character consisting of the bits </P>
<P>11111111 </P>
<P>This would be interpreted as -1 if the interpretation were being made on eight bits alone. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is a keyboard eof?</P>
</B></I></FONT><P>An <B>eof</B> can be simulated on a DOS system keyboard by holding down the <I>ctrl</I> key and pressing the <B>z</B> key. </P>
<P>Likewise, an <B>eof</B> can be simulated on a UNIX system keyboard by holding down the <I>ctrl</I> key and pressing the <B>d</B> key at the beginning of a line. </P>
<P>Other systems may have different ways of simulating an <B>eof</B> from the keyboard. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Reading a stream of bytes from the keyboard</P>
</B></I></FONT><P>The following Java code fragment will read a stream of bytes from the <I>standard input device</I> until encountering an <B>eof</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>while(System.in.read() != -1){
  //do something 
}//end while loop</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is the OOP structure involved here?</P>
</B></I></FONT><P>This code fragment accesses the <B>read()</B> <I>method</I> of the object referred to by the <I>class variable</I> named <B>in</B> of the <I>class</I> named <B>System</B>. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Displaying characters on the standard output device</P>
</B></I></FONT><P>Likewise, the following two code fragments will each display a string argument on the Java <I>standard output device</I>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>System.out.println("String argument")
System.out.print("String argument")</PRE></TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is the OOP structure involved here?</P>
</B></I></FONT><P>In the first case, the code fragment accesses the <B>println()</B> <I>method</I> of the object referred to by the <I>class variable</I> named <B>out</B> of the <I>class</I> named <B>System</B>. In the second case, the <B>print()</B><I>method</I> is accessed. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>What is the difference between the two?</P>
</B></I></FONT><P>The difference between the two is that the <B>println()</B> method automatically inserts a <I>newline</I> at the end of the string argument whereas the <B>print()</B> method leaves the display cursor at the end of the string argument. (This is somewhat analogous to the use of <B>WriteLn </B>and <B>Write </B>in Pascal.) </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>How is this done in C++?</P></B></I></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Although both Java and C++ embrace the concept of <I>stream input/output</I>, the mechanism for achieving <I>input/output<B> </B></I>is significantly different between the two, with C++ still supporting the older <I>non-object-oriented</I> style of C and also providing a new <I>object-oriented</I> style peculiar to C++. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Do we need another example of Java I/O?</P>
</B></I></FONT><P>Several examples of Java <I>input/output</I> have been presented in previous lessons, so there is no need to provide another one here. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>The tip of the iceberg</P>
</B></I></FONT><P>Stream I/O is a fairly complex topic in Java. We will have a lot more to say about stream I/O in subsequent lessons. The above introduction was simply the tip of the iceberg. </P>
<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>Character streams (as opposed to byte streams)</P>
</B></I></FONT><P>The stream I/O capability of Java was enhanced to deal with 16-bit Unicode characters in the JDK 1.1 update to the development kit. The following statement was extracted from a JavaSoft document that discusses the new features added to the JDK 1.1 version. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>IO Enhancements </P>
<P>The I/O package has been extended with character streams, which are like byte streams except that they contain 16-bit Unicode characters rather than eight-bit bytes. Character streams make it easy to write programs that are not dependent upon a specific character encoding, and are therefore easy to internationalize. Nearly all of the functionality available for byte streams is also available for character streams. </TD>
</TR>
</TABLE>

<B><I><FONT FACE="Arial" COLOR="#ff0000"><P>How can you identify a character stream?</P>
</B></I></FONT><P>The classes that support this 16-bit functionality are easy to spot. They usually have the word <I>reader</I> or <I>writer</I> in their names. We will also be discussing this new functionality in a subsequent lesson. <!-prev=Java034a.htm-></P>
<!-next=Java034c.htm><!-first=Java034.htm->
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review"></A>Review</H2>
</FONT><P>Q - The Java <B>read()</B> method reads and returns a single byte from the <I>standard input device.</I> It stores that byte according to what <I>type</I>. What does the method return if the user enters an <B>eof</B>? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The Java <B>read()</B> method reads and returns a single byte from the <I>standard input device</I> and <U>stores that byte in an integer</U><I>.</I> It returns an integer value of <B>-1</B> if the user enters an <B>eof</B>.</FONT> </P>
<P>Q - What keystroke combination can be used to simulate an <B>eof</B> at the keyboard of a DOS system? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An <B>eof</B> can be simulated on a DOS system keyboard by holding down the <I>ctrl</I> key and pressing the <B>z</B> key.</FONT> </P>
<P>Q - Provide a Java code fragment illustrating how you would read a stream of bytes from the <I>standard input device</I> until encountering an <B>eof </B>and quit reading when the <B>eof</B> is encountered. Explain in object-oriented terms how your code fragment works. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The following Java code fragment will read a stream of bytes from the <I>standard input device</I> until encountering an <B>eof</B>.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE>while(System.in.read() != -1) { //do something }</PRE></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>This code fragment accesses the <B>read()</B><I>method</I> of the object referred to by the <I>class variable</I> named <B>in</B> of the <I>class</I> named <B>System</B>.</FONT> </P>
<P>Q - Provide a Java code fragment illustrating two different ways to display a <B>String</B> argument on the Java <I>standard output device</I>. Explain how your code works in object-oriented terms. Make certain that you explain the difference between the two. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The following two code fragments will each display a string argument on the Java <I>standard output device</I>.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE>System.out.println("String argument")
System.out.print("String argument")</PRE></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>In the first case, the code fragment accesses the <B>println()</B> <I>method</I> of the object referred to by the <I>class variable</I> named <B>out</B> of the <I>class</I> named <B>System</B>. In the second case, the <B>print()</B> <I>method</I> is accessed instead of the <B>println()</B> method.</FONT> </P>
<FONT SIZE=2 COLOR="#0000ff"><P>The difference between the two is that the <B>println()</B> method automatically inserts a <B><I>newline</B></I>at the end of the string argument whereas the <B>print()</B> method leaves the display cursor at the end of the string argument.</FONT> </P>
<P><!-prev=Java034b.htm-><!-first=Java034.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
