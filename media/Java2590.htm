<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Images, Drawn Graphics, and Event Handling in a MIDlet</h2>
<i>Learn how to paint images, draw graphics, and do event handling on a cell 
phone screen.</i>
<p><b>Published:</b>&nbsp; September 9, 2008<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<ul>
		<li><a href="#The_MIDlet_named_Canvas03">The MIDlet named Canvas03</a></li>
		<li><a href="#The_MIDlet_named_Canvas04">The MIDlet named Canvas04</a><ul>
		<li><a href="#Move_the_off-screen_image_generation_code">Move the 
		off-screen image-generation code</a></li>
		<li><a href="#Paint_only_the_portion_of_the_screen_that_has_changed">
		Paint only the portion of the screen that has changed</a></li>
		<li>
		<a href="#Eliminate_multiple_repainting_on_multiple_presses_of_the_SELECT_key">
		Eliminate multiple repainting on the SELECT key</a></li>
	</ul>
		</li>
	</ul>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p>This is the second part of a two-part lesson in a series of tutorial lessons designed 
to teach you how to write programs using the Sun Java Wireless Toolkit for 
CLDC.&nbsp; The first lesson in the series was titled <i>Getting Started with MIDlets and the Sun 
Java Wireless Toolkit for CLDC</i>.&nbsp; The previous lesson was titled <i>
Programming MIDlet Graphics using the Canvas Class (see
<a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p>In this lesson, you will learn how to mix image file data and drawn graphics 
on a cell phone screen.&nbsp; You will learn how to draw various shapes such as 
rectangles, circles, arcs, filled triangles, and rounded rectangles.&nbsp; You 
will learn how to use an off-screen image, and how to use the event handling 
capability of the Canvas class for 
	simple animation.&nbsp; You will also learn how to make your MIDlet 
animations efficient by minimizing the screen area that must be repainted.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Partial class hierarchy for MIDP 2.0.</li>
	<li><a href="#Figure_2">Figure 2</a>. Output from the MIDlet named 
	Canvas03 in Sun emulator.</li>
	<li><a href="#Figure_3">Figure 3</a>. MIDlet output without clearing the 
	screen.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the class for the 
	MIDlet named Canvas03.</li>
	<li><a href="#Listing_2">Listing 2</a>. Add and register an EXIT command on 
	the Canvas.</li>
	<li><a href="#Listing_3">Listing 3</a>. The remainder of the outer class 
	named Canvas03.</li>
	<li><a href="#Listing_4">Listing 4</a>. The beginning of the member class 
	named MyCanvas.</li>
	<li><a href="#Listing_5">Listing 5</a>. The constructor for the class named 
	MyCanvas.</li>
	<li><a href="#Listing_6">Listing 6</a>. Beginning of the overridden paint 
	method.</li>
	<li><a href="#Listing_7">Listing 7</a>. Get and save the dimensions of the 
	three images.</li>
	<li><a href="#Listing_8">Listing 8</a>. Paint the screen white.</li>
	<li><a href="#Listing_9">Listing 9</a>. Create an off-screen image.</li>
	<li><a href="#Listing_10">Listing 10</a>. Get a Graphics object representing 
	the off-screen image.</li>
	<li><a href="#Listing_11">Listing 11</a>. Draw a rectangular border on the 
	off-screen Image object.</li>
	<li><a href="#Listing_12">Listing 12</a>. Draw a filled triangle on the 
	off-screen Image object.</li>
	<li><a href="#Listing_13">Listing 13</a>. Draw three images on the 
	off-screen Image object.</li>
	<li><a href="#Listing_14">Listing 14</a>. Draw a red rectangle around the 
	red ball image.</li>
	<li><a href="#Listing_15">Listing 15</a>. Draw a closed red circular arc on 
	the off-screen Image.</li>
	<li><a href="#Listing_16">Listing 16</a>. Draw the green rectangle and the 
	blue rounded rectangle.</li>
	<li><a href="#Listing_17">Listing 17</a>. Draw the off screen image onto the 
	Canvas.</li>
	<li><a href="#Listing_18">Listing 18</a>. Beginning of the overridden 
	keyPressed method.</li>
	<li><a href="#Listing_19">Listing 19</a>. Repaint the screen with the image 
	in the new position.</li>
	<li><a href="#Listing_20">Listing 20</a>. Overridden paint method in the 
	MIDlet named Canvas04.</li>
	<li><a href="#Listing_21">Listing 21</a>. Beginning of the overridden 
	keyPressed method.</li>
	<li><a href="#Listing_22">Listing 22</a>. The remaining arrow keystroke 
	tests in Canvas04.</li>
	<li><a href="#Listing_23">Listing 23</a>. Code to eliminate wasteful 
	repainting of the screen.</li>
	<li><a href="#Listing_24">Listing 24</a>. Source code for the MIDlet named 
	Canvas03.</li>
	<li><a href="#Listing_25">Listing 25</a>. Source code for the MIDlet named 
	Canvas04.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p>As I told you in Part 1 of this lesson, if you are familiar with graphics 
programming in J2SE without the benefit of Java 2D and Java 3D, you will 
probably be reasonably comfortable with the material in this lesson.&nbsp; J2ME 
graphics is very similar to graphics programming in the early days of Java, but 
with some interesting new wrinkles.</p>
<p><font color="#ff0000"><b>Partial class hierarchy for MIDP 2.0</b></font></p>
<p>A partial class hierarchy for MIDP 2.0 is shown in Figure 1.&nbsp; Figure 1 
includes all of the classes that are contained in the package named <b>
javax.microedition.lcdui</b>.&nbsp; In addition, Figure 1 includes three classes 
that are contained in other 
packages.</p>
<p><b><a name="Figure_1">Figure 1</a>. Partial class hierarchy for MIDP 2.0. </b>

<table bgcolor="#ffffff" border="1" cols="1" width="477">
	<tr>
		<td>
		<ul>
			<li>Object<ul>
				<li><b>Displayable</b><ul>
					<li><b>Screen</b><ul>
						<li><b>TextBox</b></li>
						<li><b>Alert</b></li>
						<li><b>List</b></li>
						<li><b>Form</b></li>
					</ul>
					</li>
					<li><b>Canvas (abstract)</b><ul>
						<li>GameCanvas (abstract)</li>
					</ul>
					</li>
				</ul>
				</li>
				<li><b>Display</b></li>
				<li><b>Ticker</b></li>
				<li><b>AlertType</b></li>
				<li><b>Image</b></li>
				<li><b>Item</b><ul>
					<li><b>Gauge</b></li>
					<li><b>ChoiceGroup</b></li>
					<li>CustomItem</li>
					<li><b>DateField</b></li>
					<li><b>ImageItem</b></li>
					<li><b>Spacer</b></li>
					<li><b>StringItem</b></li>
					<li><b>TextField</b></li>
				</ul>
				</li>
				<li><b>Timer</b></li>
				<li><b>TimerTask</b></li>
				<li><b>Command</b></li>
				<li><b>Graphics</b></li>
				<li><b>Font</b></li>
			</ul>
			</li>
		</ul>
		</td>
	</tr>
</table>
&nbsp;<p>I have discussed and illustrated all of the classes shown in boldface <i>
(plus the <b>Choice</b> interface, the <b>CommandListener</b> interface, and the
<b>ItemCommandListener</b> interface)</i> in earlier lessons <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; I discussed the <b>Canvas</b> 
class and the <b>Graphics</b> class in Part 1 of this lesson.&nbsp; I will 
expand my discussion of those two classes in Part 2.</p>
<p>I will discuss and illustrate the<b> GameCanvas</b> class in a future 
lesson.&nbsp; I will leave the <b>CustomItem</b> class as an exercise for the student.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>I will present and explain two MIDlets in this lesson.&nbsp; I will begin 
with the MIDlet program named <b>Canvas03</b>.&nbsp; This MIDlet will introduce three major programming concepts not covered 
in earlier lessons:</p>
<ul>
	<li>The mixture of image file data and drawn graphics on a <b>Canvas</b>.</li>
	<li>The use of an off-screen image buffer.</li>
	<li>The use of the event handling capability of the <b>Canvas</b> class for 
	simple animation.</li>
</ul>
<p>In addition, this MIDlet will illustrate a variety of drawing capabilities of 
the <b>Graphics</b> class including:</p>
<ul>
	<li>Rectangles</li>
	<li>Arcs</li>
	<li>Filled triangles</li>
	<li>Rounded rectangles</li>
</ul>
<p><font color="#FF0000">
 <b>Output from the MIDlet named Canvas03 in Sun emulator</b></font></p>
<p>Figure 2 shows an output from the MIDlet named <b>Canvas03</b> when run in 
the Sun cell phone emulator.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. Output from the MIDlet named Canvas03 in 
	Sun emulator. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2590a1.jpg" width="310" height="489"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Simple animation</b></font></p>
<p>When the MIDlet first starts running, the large black rectangle containing 
the three images and the drawn graphics are centered on the screen.&nbsp; The 
arrow keys on the emulator keypad can be used to move the rectangle and its 
contents to the position shown in Figure 2, or to any other location on the 
screen.</p>
<p><font color="#FF0000"><b>The MIDlet named Canvas04</b></font></p>
<p>When I have finished explaining the MIDlet named <b>Canvas03</b>, I will present 
and explain an updated version of the MIDlet named <b>Canvas04</b>.&nbsp; To all outward 
appearances, the behavior of this MIDlet is the same as the previous one.&nbsp; 
However, it contains several modifications that make it more efficient during 
the animation.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<table align="right" border="0" cellpadding="0" cellspacing="0" width="275">
	<tr>
		<td width="10">&nbsp;</td>
		<td>
		<table border="1" cellpadding="5" cellspacing="0" width="100%">
			<tr>
				<td bgcolor="#eeeeee"><b>MIDlet testing</b><br>
				The MIDlet presented in this lesson was tested using a Java SE 6 
				compiler, targeted at a V1.4 virtual machine, and WTK 2.5.2 
				running under Windows XP.
				</td>
			</tr>
		</table>
		</td>
	</tr>
</table>
<h3><a name="The_MIDlet_named_Canvas03">The MIDlet named Canvas03</a></h3>
<p>Being a little more specific than before, the purpose of this MIDlet is to 
illustrate the following major programming concepts involving the use of the <b>
Canvas</b> class and the <b>Graphics</b> class:</p>
<ul>
	<li>Creating an off-screen image.</li>
	<li>Importing <b>Image</b> files and drawing them in specified locations on 
	the off-screen image.</li>
	<li>Drawing a variety of shapes in different colors on the off-screen image, 
	including the following:<ul>
		<li>Rectangle</li>
		<li>Filled triangle</li>
		<li>Full circular arc</li>
		<li>Rounded rectangle</li>
	</ul>
	</li>
	<li>Drawing the off-screen image onto the <b>Canvas</b> in a specified 
	location.</li>
	<li>Handling <b>keyPressed</b> events on the <b>Canvas</b> to cause the 
	off-screen image to be drawn at different locations on the <b>Canvas</b> as 
	a result of the user having pressed the following keys <i>(simple animation)</i>:<ul>
		<li>RIGHT</li>
		<li>LEFT</li>
		<li>UP</li>
		<li>DOWN</li>
		<li>SELECT</li>
	</ul>
	</li>
</ul>
<p>In addition, the MIDlet implements an EXIT command that can be used to 
terminate the MIDlet and cause it to enter the destroyed state.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>I will present and explain this MIDlet code in fragments.&nbsp; A complete 
listing of the MIDlet code is shown in Listing 24 near the end of the lesson.</p>
<p><font color="#FF0000">
<b>Beginning of the class for the MIDlet named Canvas03</b></font></p>
<p>The beginning of the class, including the beginning of the constructor is 
shown in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the class for the MIDlet 
named Canvas03. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>public class Canvas03 extends MIDlet{
  Canvas myCanvas;

  public Canvas03(){//constructor
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    
    //Guarentee that the screen gets painted.
    myCanvas.repaint();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 1 instantiates an object of the member class named <b>MyCanvas</b> 
and then calls the method named <b>repaint</b> on that object to guarantee that 
it is properly painted on the cell phone emulator screen.&nbsp; This produces 
the output shown in Figure 2, except that the large black rectangle is centered 
in the emulator screen at this point.</p>
<p><font color="#FF0000">
<b>Add and register an EXIT command on the Canvas</b></font></p>
<p>Listing 2 adds an EXIT command to the <b>Canvas</b> and registers a <b>
CommandListener</b> object on the <b>Canvas</b> to cause the MIDlet to enter the 
destroyed state when the command is activated.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Add and register an EXIT command on the 
Canvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Add an EXIT command and register a CommandListener
    // to handle the EXIT command.
    myCanvas.addCommand(new Command("EXIT",
                                         Command.EXIT,2));
    myCanvas.setCommandListener(
      new CommandListener(){
        public void commandAction(
                          Command cmd,Displayable source){
          if(cmd.getCommandType() == Command.EXIT){
            destroyApp(true);
          }//end if
        }//end commandAction
      }//end new CommandListener
    );//end setCommandListener
  }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Because this is the only command that is registered on the <b>Canvas</b>, and 
because it is one of the commands that are eligible for occupying the position of 
the left soft key in the Sun cell phone emulator, the EXIT command appears at 
the bottom-left of the screen in Figure 2.</p>
<p><font color="#FF0000">
<b>The remainder of the outer class named Canvas03</b></font></p>
<p>The remainder of the outer class named <b>Canvas03</b> is shown in Listing 3.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. The remainder of the outer class named 
Canvas03. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public void startApp(){
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Everything in Listing 3 has been covered in earlier lessons <i>(see
<a href="#Resources">Resources</a>)</i>, so Listing 3 shouldn't require further 
explanation. </p>
<p><font color="#FF0000">
<b>The beginning of the member class named MyCanvas</b></font></p>
<p>Listing 4 shows the beginning of the member class named <b>MyCanvas</b>.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. The beginning of the member class named 
MyCanvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  class MyCanvas extends Canvas{
    Image redBallImage;
    Image greenBallImage;
    Image blueBallImage;
    int frameWidth = 200;
    int frameHeight = 200;
    int redBallWidth = 0;
    int redBallHeight = 0;
    int greenBallWidth = 0;
    int greenBallHeight = 0;
    int blueBallHeight = 0;
    int blueBallWidth = 0;
    int horizBorder = 50;
    int vertBorder = 50;
    int horizDrawPoint = 0;
    int vertDrawPoint = 0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>There is no technical requirement for the class named <b>MyCanvas</b> to be a 
member class.&nbsp; I made it a member class strictly for programming 
convenience.&nbsp; It is necessary, however, for the class to extend the library 
class named <b>Canvas</b>.</p>
<p>The code in Listing 4 declares a large number of working variables and 
initializes some of them.&nbsp; <i>(Hopefully you will recognize that 
initialization of the <b>int</b> variables to a value of zero is not necessary because 
that is the default.&nbsp; I did that simply for clarity.)</i></p>
<p><font color="#FF0000">
<b>The constructor</b></font></p>
<p>This is where things start to get interesting.&nbsp; Listing 5 shows the 
constructor for the class named <b>MyClass</b>.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. The constructor for the class named 
MyCanvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    MyCanvas(){//constructor
      setFullScreenMode(false);
      horizDrawPoint = getWidth()/2;
      vertDrawPoint = getHeight()/2;
    }//end constructor</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The setFullScreenMode method</b></font></p>
<p>As you learned in a previous lesson, the first statement in the constructor is superfluous because false is the default 
value.&nbsp; I included this statement to make it easy for you experiment with 
the difference between normal mode and full-screen mode.&nbsp; If you set the 
<b>setFullScreenMode</b> parameter to true, the display will 
change to full-screen mode.&nbsp; Making this change will hide the EXIT command 
in the Sun cell phone emulator.&nbsp; <i>(I don't know how to expose the command in 
full-screen mode.)</i></p>
<p><font color="#FF0000"><b>Initialize the drawing point coordinate values</b></font></p>
<p>The last two statements in Listing 5 are not superfluous.&nbsp; The contents 
of the variables named <b>horizDrawPoint</b> and <b>vertDrawPoint</b> will be 
used later to position the image on the emulator screen.&nbsp; The code in 
Listing 5 initializes the values of the two variables to point to the center of 
the screen.</p>
<p><font color="#FF0000">
<b>Beginning of the overridden paint method</b></font></p>
<p>The overridden paint method begins in Listing 6.&nbsp; Recall that this 
method will be called whenever it is necessary to display the <b>Canvas</b> 
object on the cell phone screen.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Beginning of the overridden paint method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void <b>paint</b>(Graphics g){
      try{
        //Create three Image objects
        redBallImage = Image.createImage(
                                 "/Canvas03/redball.PNG");
        greenBallImage = Image.createImage(
                               "/Canvas03/greenball.PNG");
        blueBallImage = Image.createImage(
                                "/Canvas03/blueball.PNG");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Three image objects</b></font></p>
<p>The code in Listing 6 creates three objects of the class <b>Image</b> that 
point to three image files with the <a name="following_names">following names</a>:</p>
<ul>
	<li>redball.png</li>
	<li>greenball.png</li>
	<li>blueball.png</li>
</ul>
<p>You should have no difficulty recognizing the three images resulting from 
these files in the MIDlet output in Figure 2.&nbsp; They are the spheres at the 
vertices of the olive-drab triangle.</p>
<p>I first discussed the use of the method named <b>createImage</b> to create <b>
Image</b> objects from image files in the earlier lesson titled <i>Using Alerts, 
Images, Timers, and Gauges in MIDlets (see <a href="#Resources">Resources</a>)</i>.&nbsp; 
You may find it useful to go back and review that lesson to refresh your memory 
on this topic.</p>
<p><font color="#FF0000"><b>You will need some image files</b></font></p>
<p>If you run this MIDlet, you will need to provide three small image files to 
replace the image files in the above <a href="#following_names">list</a>.&nbsp; 
Be sure to copy those files into the same directory as the directory that 
contains your source code.&nbsp; Either change the names of your image files to 
match the names of my files, or change the code in Listing 6 to match the names 
of your image files.</p>
<p><font color="#FF0000">
<b>Get and save the dimensions of the three images</b></font></p>
<p>Having created the three <b>Image</b> objects, the code in Listing 7 calls 
methods of the <b>Image</b> class to get and save the width and height of each 
image.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Get and save the dimensions of the three images. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        redBallWidth = redBallImage.getWidth();
        redBallHeight = redBallImage.getHeight();
        greenBallWidth = greenBallImage.getWidth();
        greenBallHeight = greenBallImage.getHeight();
        blueBallWidth = blueBallImage.getWidth();
        blueBallHeight = blueBallImage.getHeight();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Although all of my images have the same width and height, and the width is 
equal to the height, that should not be a requirement for your images.&nbsp; The 
code in Listing 7 is written to accommodate images of different sizes and 
shapes.</p>
<p><font color="#FF0000">
<b>Paint the screen white</b></font></p>
<p>Listing 8 begins by setting the drawing color to white and then painting the 
entire screen with the new drawing color.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Paint the screen white. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        g.setColor(0xffffff);
        g.fillRect(0,0,getWidth(),getHeight());
        
        g.setColor(0x000000);//Set drawing color to black</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is accomplished by drawing a filled rectangle with dimensions that match 
the dimensions of the <b>Canvas</b> object.&nbsp; Note however that because 
Figure 2 was run with the <b>Canvas</b> in normal mode as opposed to full-screen 
mode, the gray bar at the bottom of the screen was not painted over.</p>
<p><font color="#FF0000">
 <b>MIDlet output without clearing the screen</b></font></p>
<p>If the screen had not been painted white in Listing 8, the subsequent drawing 
would simply have been placed on top of what was already there.&nbsp; This would 
not only allow the screen that was showing before the MIDlet was launched to 
show through, it would also produce multiple images of the newly drawn material 
as the arrow keys are used to move the new material around on the screen.&nbsp; 
A sample of this phenomenon is shown in Figure 3.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. MIDlet output without clearing the screen. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="1" src="java2590a2.jpg" width="312" height="473"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the drawing color to black</b></font></p>
<p>Listing 8 sets the drawing color to black after the screen has been painted 
white.</p>
<p><font color="#FF0000">
<b>Create an off-screen image</b></font></p>
<p>The code in Listing 9 is completely new to this series of lessons.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Create an off-screen image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        Image osi = Image.createImage(frameWidth,
                                      frameHeight);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>Image</b> class in MIDP 2.0 provides six different overloaded versions 
of the method named <b>createImage</b>.&nbsp; Five of those methods create 
immutable <b>Image</b> objects from various sources of image data.&nbsp; Here is 
part of what Sun has to say about the sixth overloaded version that is used in 
Listing 9:</p>
<blockquote>
	<p><i>&quot;Creates a new, mutable image for off-screen drawing. Every pixel 
	within the newly created image is white. The width and height of the image 
	must both be greater than zero.&quot;</i></p>
</blockquote>
<p>The fact that the image is <i>mutable</i> means that it may be modified.&nbsp; 
In other words, that means it will be possible for the MIDlet to either draw on 
the off-screen image or deposit image file data on the off-screen image or both.</p>
<p><font color="#FF0000">
<b>Get a Graphics object representing the off-screen Image</b></font></p>
<p>The overridden <b>paint</b> method always receives an incoming reference to 
an object of the class <b>Image</b>.&nbsp; You can think of the <b>Image</b> 
object as representing the screen.&nbsp; When you draw on the object, the 
results of that drawing effort will appear on the screen <i>(when the <b>Canvas</b> 
object is displayed on the screen)</i>.</p>
<p>When you need to draw on an off-screen image, you need to get a <b>Graphics</b> 
object that represents the off-screen image <i>(all drawing methods are methods 
of the <b>Graphics</b> class)</i>.&nbsp; Listing 
10 gets such a <b>Graphics</b> object.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Get a Graphics object representing the 
off-screen image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        Graphics osg = osi.getGraphics();
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>What does Sun have to say about the getGraphics 
method?</b></font></p>
<p>Here is part of what Sun has to say about the <b>getGraphics</b> method of 
the <b>Image</b> class:</p>
<blockquote>
	<p><i>&quot;Creates a new <b>Graphics</b> object that renders to this image...
	</i></p>
	<p><i>The newly created <b>Graphics</b> object has the following properties:
	</i></p>
	<ul>
		<li><i>the destination is this <b>Image</b> object;</i></li>
		<li><i>the clip region encompasses the entire <b>Image</b>;</i></li>
		<li><i>the current color is black;</i></li>
		<li><i>the font is the same as the font returned by 
		Font.getDefaultFont();</i></li>
		<li><i>the stroke style is SOLID; and </i></li>
		<li><i>the origin of the coordinate system is located at the upper-left 
		corner of the <b>Image</b>.</i></li>
	</ul>
	<p><i>The lifetime of <b>Graphics</b> objects created using this method is 
	indefinite. They may be used at any time, by any thread.&quot;</i></p>
</blockquote>
<p>It is important to note that the off-screen image is not an object of the 
class <b>Canvas</b>.&nbsp; Rather it is an object of the class <b>Image</b>.&nbsp; 
The <b>Graphics</b> object that is received as a parameter to the overridden <b>
paint</b> method <i>&quot;renders to&quot;</i> the <b>Canvas</b> object, whereas the <b>
Graphics</b> object obtained in Listing 10 <i>&quot;renders to&quot;</i> the <b>Image</b> 
object.</p>
<p><font color="#FF0000"><b>What can you do with an off-screen image?</b></font></p>
<p>Presumably, if you knew how to do it, you could create an off-screen <b>Image</b> 
object and then write it out into an image file somewhere.&nbsp; However, we 
won't attempt to do that in this MIDlet.&nbsp; In this MIDlet, we will 
eventually cause the contents of the off-screen image to be drawn on the <b>
Canvas</b> and displayed on the cell phone screen.</p>
<p><font color="#FF0000">
<b>Draw a rectangular border on the off-screen Image object</b></font></p>
<p>Listing 11 calls the <b>drawRect</b> method of the <b>Graphics</b> class to 
draw a rectangle around the edge of the off-screen <b>Image</b> object.&nbsp; 
<i>(The width and height of the off-screen image was established in Listing 9.)</i>&nbsp; This produces the black rectangle shown in Figure 2.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Draw a rectangular border on the 
off-screen Image object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        osg.<b>drawRect</b>(0,0,frameWidth-1,frameHeight-1);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note the requirement to set the width and height dimensions of the rectangle 
to one less than the corresponding dimensions of the off-screen <b>Image</b> 
object.&nbsp; Otherwise, the lines representing the right and bottom sides of 
the rectangle would be off the edge of the off-screen <b>Image</b> object.</p>
<p><font color="#FF0000">
<b>Draw a filled triangle on the off-screen Image object</b></font></p>
<p>After setting the drawing color to that shown in Figure 2, the code in 
Listing 12 calls the <b>fillTriangle</b> method of the <b>Graphics</b> class to draw a filled triangle 
on the off-screen <b>Image</b> with 
its vertices specified by the three pairs of coordinate values shown in Listing 
12.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Draw a filled triangle on the off-screen 
Image object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        osg.setColor(0xa0a000);
        osg.<b>fillTriangle</b>(horizBorder,
                         vertBorder,
                         frameWidth - horizBorder,
                         vertBorder,
                         frameWidth/2,
                         frameHeight - vertBorder);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I will leave it as an exercise for the student to decipher how the coordinate 
values contained in the variables referenced in Listing 12 result in the 
vertices shown in Figure 2 or the vertices shown in Figure 3.</p>
<p><font color="#FF0000"><b>What about the color?</b></font></p>
<p>Up to this point, I have been deferring a discussion of the color value until 
a later time.&nbsp; That time has arrived.</p>
<p>The parameter that is passed to the <b>setColor</b> method in Listing 12 is a 
32-bit value of type <b>int</b> represented by the following three hexadecimal 
values:</p>
<ul>
	<li>a0</li>
	<li>a0</li>
	<li>00</li>
</ul>
<p><font color="#FF0000"><b>A mixture of three primary colors</b></font></p>
<p>Each hexadecimal value represents a decimal value with a range from 0 to 
255.&nbsp; Each one of the three values represents the contribution to a color 
mixture of one of the following primary colors:</p>
<ul>
	<li>red</li>
	<li>green</li>
	<li>blue</li>
</ul>
<p>A value of 0 <i>(0x00)</i> results in no contribution of the associated 
primary color to the mix.&nbsp; A value of 255 <i>(0xff)</i> results in a 
maximum contribution of the associated primary color to the mix.</p>
<p>The color value in Figure 12 contains a little bit of red <i>(a0)</i>, a 
little bit of green <i>(a0)</i>, and no blue <i>(00)</i>.&nbsp; This produces 
the olive-drab color shown by the filled triangle in Figure 2.</p>
<p><font color="#FF0000">
<b>Draw three images on the off-screen Image object</b></font></p>
<p>Listing 13 calls the <b>drawImage</b> method of the <b>Graphics</b> class 
three times in succession to cause the three small<b> Image</b> objects created 
in Listing 6 to be drawn on the larger off-screen <b>Image</b> object created in 
Listing 9.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Draw three images on the off-screen 
Image object. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        osg.drawImage(redBallImage,
                      horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
                      
        osg.drawImage(greenBallImage,
                      frameWidth - horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
                      
        osg.drawImage(blueBallImage,
                      frameWidth/2,
                      frameHeight - vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Specifying the image and the coordinate values</b></font></p>
<p>The first parameter to the <b>drawImage</b> method specifies the image that 
is to be drawn.&nbsp; The next two parameters specify a pair of horizontal and 
vertical coordinate values.&nbsp; Note that the coordinate values specified for 
each image in Listing 13 matches the coordinates of a triangle vertex in Listing 
12.</p>
<p><font color="#FF0000"><b>The anchor-point value</b></font></p>
<p>The last parameter to the <b>drawImage</b> method is an anchor-point value.&nbsp; 
You learned about the use of anchor points with text in Part 1 of this lesson <i>
(see <a href="#Resources">Resources</a>)</i>.&nbsp; At that time, I told you 
that the anchor-point concept applies not only to text but to images as well.&nbsp; 
I also told you that the VCENTER anchor-point constant can be used with images 
but not with text, and the BASELINE anchor-point constant can be used with text 
but not with images.&nbsp; The HCENTER anchor-point constant can be used with 
either images or text.</p>
<p>In all three cases in Listing 13, the anchor-point value passed to the method 
was constructed from the bitwise inclusive OR of the HCENTER and VCENTER 
anchor-point constants.&nbsp; This means that the image will be drawn with its 
center located at the position specified by the horizontal and vertical 
coordinate values.&nbsp; In this case, it means that each image will be drawn 
on one vertex of the filled triangle as shown in Figure 2.</p>
<p><font color="#FF0000">
<b>Draw a red rectangle around the red ball image</b></font></p>
<p>Listing 14 calls the <b>drawRect</b> method of the <b>Graphics</b> class to 
draw a red rectangle around the red ball image as shown in Figure 2.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Draw a red rectangle around the red ball 
image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        osg.setColor(0xff0000);
        osg.drawRect(horizBorder - redBallWidth,
                     vertBorder - redBallHeight,
                     redBallWidth * 2,
                     redBallHeight * 2);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The width and the height of the red rectangle are specified to be twice the 
width and twice the height of the image.&nbsp; This code should work properly 
with your image even if it has different dimensions than my image.</p>
<p><font color="#FF0000"><b>No anchor point concept applies here</b></font></p>
<p>Note that shapes drawn with methods like <b>drawRect</b> don't support the 
concept of an anchor point parameter.&nbsp; Therefore, it is necessary to read 
the documentation for the method and then make arithmetic adjustments to the 
parameters to specify the location and size of the shape.</p>
<p>For the <b>
drawRect</b> method, the first two parameters specify the location of the 
upper-left corner of the rectangle and the next two parameters specify the width 
and height of the rectangle.&nbsp; Therefore, it was necessary to adjust the 
values for those parameters to center the rectangle on the red ball image and to 
set its width and height accordingly.</p>
<p><font color="#FF0000"><b>How do you draw a circle?</b></font></p>
<p>Neither J2SE 1.6 nor MIDP 2.0 provides a <b>drawCircle</b> method.&nbsp; 
However, J2SE provides a <b>drawOval</b> method that makes it relatively 
easy to draw an oval that fits inside an invisible rectangle.&nbsp; If the width 
and the height of the rectangle are the same, the result is a circle.</p>
<p>MIDP 2.0 doesn't even provide a <b>drawOval</b> method.&nbsp; With MIDP 2.0, 
if you need a circle, you can construct it by drawing a closed circular arc.&nbsp;
<i>(There are also other ways to draw a circle with MIDP 2.0, such as drawing a
<a href="#An_exercise_for_the_student">special case</a> of a rounded rectangle.)</i></p>
<p><font color="#FF0000">
<b>Draw a closed red circular arc on the off-screen Image</b></font></p>
<p>Listing 15 calls the <b>drawArc</b> method of the <b>Image</b> class to draw 
a red circle around the red ball image with a diameter that is twice the width 
of the image as shown in Figure 2.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Draw a closed red circular arc on the 
off-screen Image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        osg.drawArc(horizBorder - redBallWidth,
                    vertBorder - redBallHeight,
                    redBallWidth * 2,
                    redBallHeight * 2,
                    0,
                    360);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that it is necessary to draw a 360-degree arc to draw a circle.&nbsp; 
Also note that the angles are given in degrees instead of radians.&nbsp; 
Finally, note that if the width of your image is not the same as the height of 
your image, you won't draw a circle.&nbsp; Rather, you will draw something 
resembling an ellipse or an oval.&nbsp; <i>(Sun refers to it as an 
elliptical arc.)</i></p>
<p><font color="#FF0000">
<b>Draw the green rectangle and the blue rounded rectangle</b></font></p>
<p>Listing 16 draws the green rectangle and the blue rounded rectangle centered 
on the green and blue ball images shown in Figure 2.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Draw the green rectangle and the blue 
rounded rectangle. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        //Draw a green rectangle around the green ball
        // with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x00ff00);
        osg.<b>drawRect</b>(
                frameWidth - horizBorder - greenBallWidth,
                vertBorder - greenBallHeight,
                greenBallWidth * 2,
                greenBallHeight * 2);
                     
        //Draw a blue rounded rectangle around the blue
        // ball with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x0000ff);
        osg.<b>drawRoundRect</b>(
                frameWidth/2 - blueBallWidth,
                frameHeight - vertBorder - blueBallHeight,
                blueBallWidth * 2,
                blueBallHeight * 2,
                (int)(1.25 * blueBallWidth),
                (int)(1.25 * blueBallHeight));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p>


<p><font color="#FF0000"><b>The methods</b></font></p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b><a name="An_exercise_for_the_student">An exercise for the student</a></b><br />
  See if you can figure out how to use the method named drawRoundRect to draw a 
	circle.
</td></tr></table>
</td>
</tr>
</table>
<p>By now, the process should be sufficiently familiar to you that no 
explanation beyond the embedded comments in Listing 16 is necessary.&nbsp; 
However, you 
might want to take a hard look at the documentation for the <b>drawRoundRect</b> 
method, particularly with regard to how the curvature of the corners is 
achieved.</p>
<p><font color="#FF0000">
<b>Draw the off screen image onto the Canvas</b></font></p>
<p>Listing 17 calls the <b>drawImage</b> method of the <b>Graphics</b> class to 
draw the off-screen <b>Image</b> onto the <b>Canvas</b>. </p>
<p>
<b><a name="Listing_17">Listing 17</a>. Draw the off screen image onto the Canvas. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>        g.drawImage(osi,
                    horizDrawPoint,
                    vertDrawPoint,
                    Graphics.HCENTER | Graphics.VCENTER);
      
      } catch(Exception e){e.printStackTrace();}

    }//end overridden paint method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This is the same <b>drawImage</b> method that was called in Listing 13 to 
draw the three small images onto the off-screen <b>Image</b>.</p>
<p><font color="#FF0000"><b>Positioning</b></font></p>
<p>The off-screen <b>Image</b> is smaller than the <b>Canvas</b>.&nbsp; The 
parameter values specify that the off-screen <b>Image</b> will be drawn centered 
on the coordinates given by <b>horizDrawPoint</b> and <b>vertDrawPoint</b>.&nbsp; 
Recall that these coordinate values were initialized to specify a point at the 
center of the <b>Canvas</b>.&nbsp; Therefore, the first time that the off-screen
<b>Image</b> is drawn on the <b>Canvas</b>, it will be centered on the <b>Canvas</b>.</p>
<p><font color="#FF0000"><b>Simple animation</b></font></p>
<p>However, you will see shortly that when the user presses the arrow keys on the 
cell phone emulator, the values stored in <b>horizDrawPoint</b> and <b>
vertDrawPoint</b> are modified and the overridden <b>paint</b> method is called.&nbsp; 
This causes the off-screen <b>Image</b> to be drawn at a different location on 
the <b>Canvas</b> and to appear at a different location on the cell phone emulator 
screen.</p>
<p><font color="#FF0000"><b>Beginning of the overridden keyPressed method</b></font></p>
<p>Listing 17 signals the end of the overridden <b>paint</b> method.&nbsp; Listing 
18 shows the beginning of the overridden <b>keyPressed</b> method.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Beginning of the overridden keyPressed 
method.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void keyPressed(int keyCode){
      String keyName = getKeyName(keyCode);
      if(keyName.equals("LEFT")){
        horizDrawPoint -= 5;
      }else if(keyName.equals("RIGHT")){
        horizDrawPoint += 5;
      }else if(keyName.equals("UP")){
        vertDrawPoint -= 5;
      }else if(keyName.equals("DOWN")){
        vertDrawPoint += 5;
      }else if(keyName.equals("SELECT")){
        //Reset to the center.
        horizDrawPoint = getWidth()/2;
        vertDrawPoint = getHeight()/2;
      }else{
        //Do nothing if the user presses a different key.
      }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Override the keyPressed method</b></font></p>
<p>Listing 18 overrides the <b>keyPressed</b> method to implement a simple 
animation capability.&nbsp; Pressing the arrow keys moves the image in the 
direction of the arrow.&nbsp; Pressing the SELECT key resets the image to the 
center of the screen.</p>
<p>Note that pressing the UP arrow actually moves the image up the screen 
instead of down the screen.&nbsp; Also note that this code was not designed to 
be portable.&nbsp; It may 
only be compatible with the Sun cell phone emulator due to the use of specific 
key names that may be peculiar to the Sun cell phone emulator.</p>
<p>Listing 18 uses an <b>if-else</b> construct to adjust the values of the 
variables named <b>horizDrawPoint</b> and <b>vertDrawPoint</b> depending on 
whether the user presses one of the arrow keys, or presses the select key, <i>
(which is surrounded by the arrow keys in Figure 2)</i>.&nbsp; The <b>else</b> 
clause in Listing 18 is superfluous.&nbsp; I included it for clarity.</p>
<p><font color="#FF0000">
<b>Repaint the screen with the image in the new position</b></font></p>
<p>Having <i>(possibly)</i> modified the values stored in the variables named <b>
horizDrawPoint</b> and <b>vertDrawPoint</b>, Listing 19 calls the <b>repaint</b> 
method on the <b>Canvas</b> object <i>(multiple presses of the SELECT key 
changes the values stored in the variables only once, if at all)</i>.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Repaint the screen with the image in the 
new position. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      <b>this.repaint</b>();
    }//end keyPressed
  }//end member class MyCanvas

}//end class Canvas03</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The call to the <b>repaint</b> method sends a message to the AMS requesting 
that the overridden <b>paint</b> method <i>(that began in Listing 6)</i> be 
called.&nbsp; Among other things, the overridden <b>paint</b> method clears the
<b>Canvas</b> by painting it white and then draws the off-screen image on the 
canvas at the location specified by the values stored in the variables named <b>
horizDrawPoint</b> and <b>vertDrawPoint</b>.&nbsp; If the value stored in either 
of the variables has changed, the large rectangle and its contents shown in 
Figure 2 moves accordingly.</p>
<p>Listing 19 also signals the end of the <b>Canvas03</b> class definition.</p>
<h3><a name="The_MIDlet_named_Canvas04">The MIDlet named Canvas04</a></h3>
<p><font color="#FF0000"><b>Making the MIDlet more efficient</b></font></p>
<p>This is an update to the MIDlet named <b>Canvas03</b>.&nbsp; This MIDlet 
contains several modifications to improve the efficiency of the MIDlet insofar as the simple 
animation is concerned without changing the behavior of the MIDlet.&nbsp; The modifications 
are:</p>
<ul>
	<li>Move the code that creates the off-screen image from the overridden <b>
	paint</b> method to the constructor for the <b>Canvas</b> class so that it 
	is only executed once.</li>
	<li>Paint only that portion of the screen that changes each time the black 
	rectangle and its contents move.</li>
	<li>Eliminate multiple repainting of the screen on repetitive presses of the 
	SELECT key.</li>
</ul>
<p>Efficiency isn't particularly important for this demonstration MIDlet, but it 
could be very important for a real MIDlet that is more computationally 
demanding.&nbsp; Therefore, you need to think in terms of efficiency, 
particularly when animation is involved.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>A complete listing of this MIDlet is provided in Listing 25.&nbsp; Much of 
the code is identical to the code in the MIDlet named <b>Canvas03</b>.&nbsp; 
Therefore, I won't repeat the explanation of that code.&nbsp; Instead, I will 
explain only the code that has changed.</p>
<h4><a name="Move_the_off-screen_image_generation_code">Move the off-screen 
image-generation code</a></h4>
<p>In the MIDlet named <b>Canvas03</b>, the code that creates and populates the 
off-screen image is located in the overridden <b>paint</b> method.&nbsp; This 
would be a good location for that code if the contents of the off-screen image 
changes while the MIDlet is running.&nbsp; However, that isn't the 
case for this MIDlet.&nbsp; Once the off-screen image for this MIDlet is created, it never changes.&nbsp; 
Because that code is in the overridden <b>paint</b> method, it is executed 
every time the user pressed an arrow key.</p>
<p><font color="#FF0000"><b>The modified paint method</b></font></p>
<p>In the MIDlet named <b>Canvas04</b>, the code that creates and populates the 
off-screen image has been moved <i>(with very few modifications)</i> to the 
constructor for the <b>Canvas</b> class.&nbsp; <i>(You can view the modified 
constructor in Listing 25.)</i>&nbsp; As a result, that code will only 
be executed once when the <b>Canvas</b> object is instantiated.&nbsp; This leaves the overridden <b>paint</b> method shown in Listing 20, which is 
short and much more efficient than the overridden <b>paint</b> method in <b>
Canvas03</b>.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Overridden paint method in the MIDlet 
named Canvas04. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    public void <b>paint</b>(Graphics g){
      //Paint the screen white
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      g.setColor(0x000000);//Set drawing color to black
      
      //Draw off-screen image on the Canvas
      g.drawImage(osi,
                  horizDrawPoint,
                  vertDrawPoint,
                  Graphics.HCENTER | Graphics.VCENTER);

    }//end overridden paint method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As you will see shortly, the next modification causes the execution of the 
overridden <b>paint</b> method to be even more efficient.</p>
<h4><a name="Paint_only_the_portion_of_the_screen_that_has_changed">Paint only 
the portion of the screen that has changed</a></h4>
<p><font color="#FF0000"><b>Two overloaded versions of the repaint method</b></font></p>
<p>The last statement in Listing 19, which is the last statement in the MIDlet named <b>Canvas03</b>, 
is a call to the method named <b>repaint</b>.&nbsp; <i>(Note the empty parameter 
list in the call to the <b>repaint</b> method in Listing 19.)</i>&nbsp; As 
of MIDP 2.0, there are two overloaded versions of the <b>repaint</b> method.&nbsp; 
One is the version that is called in Listing 19, which causes the entire <b>
Canvas</b> 
to be repainted.</p>
<p>The other version requires four parameters.&nbsp; These parameters specify a rectangular 
portion of the <b>Canvas</b>.&nbsp; When this version of the <b>repaint</b> method is 
called, only that portion of the <b>Canvas</b> contained within the specified rectangle 
is repainted.&nbsp; Because the painting of the <b>Canvas</b> <i>(and hence the screen)</i> is a high-overhead 
process, limiting the area that is repainted can significantly improve the 
efficiency of a MIDlet.</p>
<p><font color="#FF0000"><b>No changes to the overridden paint method are 
required</b></font></p>
<p>It is important to note that the use of the second version of the <b>repaint</b> 
method to paint only a rectangular portion of the <b>Canvas</b> doesn't require any 
changes to the overridden <b>paint</b> method.&nbsp; The reduction in the screen 
area that is repainted takes place behind the scenes at the system level.&nbsp; The overridden paint method 
shown in Listing 20 will do the job regardless of which version of the <b>
repaint</b> method is called.</p>
<p><font color="#FF0000"><b>Modifications to the overridden keyPressed method</b></font></p>
<p>The remaining modifications were made to the overridden <b>keyPressed</b> 
method.&nbsp; As before, the <b>keyPressed</b> method is overridden to implement 
a simple animation capability.&nbsp; Pressing the arrow keys moves the image in 
the direction of the arrow, and pressing the SELECT key resets the image to the 
center of the screen.&nbsp; Also as before, this code is probably not portable 
and may only be compatible with the Sun cell phone emulator due to the use of 
specific key names.</p>
<p><font color="#FF0000">
<b>Beginning of the overridden keyPressed method</b></font></p>
<p>The beginning of the modified <b>keyPressed</b> method is shown in Listing 
21.&nbsp; To understand the differences, compare the code in Listing 21 with the 
code in Listing 18 and Listing 19.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Beginning of the overridden keyPressed 
method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    public void <b>keyPressed</b>(int keyCode){
      int step = 5;//Distance moved on each click.
      String keyName = getKeyName(keyCode);
      
      if(keyName.equals("LEFT")){
        horizDrawPoint -= step;
        //Repaint only the portion of the screen that 
        // needs to change.
        this.<b>repaint</b>(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2,
                     frameWidth + step,
                     frameHeight);
                     
        //Set multipleSelects to false to cause the SELECT
        // key to repaint the screen the next time it is
        // pressed..
        multipleSelects = false;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<p><font color="#FF0000"><b>A different repaint call for each arrow key</b></font></p>
<p>In the MIDlet named <b>Canvas03</b>, the call to the repaint method is 
deferred until the end of the method.&nbsp; The call is made with no parameters 
regardless of whether the user presses an arrow key or the SELECT key.&nbsp; 
This causes the entire screen to be repainted each time the user presses one of 
those five keys.</p>
<p>However, in the MIDlet named <b>
Canvas04</b>, a different call to the <b>repaint</b> method is associated with 
each arrow key and the SELECT key.&nbsp; Furthermore, each call to the <b>
repaint</b> method contains different parameter values depending on which key 
is pressed.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The rectangular repaint area</b><br />
  I will leave it as an exercise for the student to 
decipher the construction of the four parameters in Listing 21 to determine how 
they specify the rectangular portion of the screen that will be repainted.
</td></tr></table>
</td>
</tr>
</table>
<p>The code in Listing 21 tests to see if the user pressed the LEFT arrow key.&nbsp; 
If so, a call is made to the overloaded version of the <b>repaint</b> method 
that requires parameter to specify a rectangular area of the screen that is to 
be repainted.</p>
<p><font color="#FF0000"><b>Set multipleSelects to false</b></font></p>
<p>When control returns from the <b>repaint</b> method, the code in Listing 21 
sets the value of a new variable named <b>multipleSelects</b> to false.&nbsp; I 
will explain the reason for this later.</p>
<p><font color="#FF0000">
<b>The remaining arrow keystroke tests in Canvas04</b></font></p>
<p>Listing 22 shows the tests for the RIGHT, UP, and DOWN arrow keys.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. The remaining arrow keystroke tests in 
Canvas04. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(keyName.equals("RIGHT")){
        horizDrawPoint += step;
        this.<b>repaint</b>(horizDrawPoint - frameWidth/2 - step,
                     vertDrawPoint - frameHeight/2,
                     frameWidth + step,
                     frameHeight);
        multipleSelects = false;
      }else if(keyName.equals("UP")){
        vertDrawPoint -= step;
        this.<b>repaint</b>(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2,
                     frameWidth,
                     frameHeight + step);
        multipleSelects = false;
      }else if(keyName.equals("DOWN")){
        vertDrawPoint += step;
        this.<b>repaint</b>(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2 - step,
                     frameWidth,
                     frameHeight + step);
        multipleSelects = false;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The logic for each of these tests is the same as the logic in Listing 21.&nbsp; 
However, a different rectangular area of the <b>Canvas</b> is identified for repainting 
in each case.</p>
<h4>
<a name="Eliminate_multiple_repainting_on_multiple_presses_of_the_SELECT_key">
Eliminate multiple repainting on the SELECT key</a></h4>
<p>When the user presses the SELECT key, the image is moved to the center of the 
screen.&nbsp; In the MIDlet named <b>Canvas03</b>, if the user pressed the 
SELECT key again without pressing an arrow key, the entire <b>Canvas</b> is 
repainted.&nbsp; Repainting the <b>Canvas </b>on repetitive presses of the SELECT key 
is wasteful because the contents of the <b>Canvas </b>don't change after the first 
time the SELECT key is pressed.</p>
<p><font color="#FF0000">
<b>Code to eliminate wasteful repainting of the screen</b></font></p>
<p>Listing 23 contains the code that eliminates the wasteful repainting of the 
<b>Canvas </b><i>(and hence the screen)</i><b> </b>on repetitive presses of the SELECT key.&nbsp; </p>
<p>
<b><a name="Listing_23">Listing 23</a>. Code to eliminate wasteful repainting of 
the screen. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      }else if(keyName.equals("SELECT")){
        //Reset to the center.
        horizDrawPoint = getWidth()/2;
        vertDrawPoint = getHeight()/2;
        if(!multipleSelects){
          //If the user presses SELECT two or more times
          // in succession, the screen will only be
          // repainted the first time.
          //Repaint the entire screen with the off-screen
          // image centered on the screen.
          this.repaint();
          multipleSelects = true;
        }//end if
      }else{
        //Do nothing if the user presses a different key.
      }//end else

    }//end keyPressed</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A new variable named multipleSelects</b></font></p>
<p>If you examine the code for the class named <b>MyCanvas</b> in Listing 25, you will find the declaration 
and initialization of a new <b>boolean</b> variable named <b>multipleSelects</b>.&nbsp; 
The variable is initialized to a value of false.&nbsp; The value stored in this 
variable toggles between true and false depending on whether or not the screen 
should be repainted when the user presses the SELECT key.</p>
<p><font color="#FF0000"><b>Pressing the arrow keys sets the variable to false</b></font></p>
<p>As you saw in Listing 22, whenever the user presses an arrow key, the value 
of <b>multipleSelects</b> is set to false indicating that the screen should be 
repainted the next time the user presses the SELECT key.</p>
<p><font color="#FF0000"><b>Pressing SELECT sets the variable to true</b></font></p>
<p>As you can see in Listing 23, when the user presses the SELECT key, the 
entire <b>Canvas </b>is repainted once and then the value of <b>multipleSelects</b> is 
set to true.&nbsp; This prevents <b>Canvas</b> from being repainted again if the user presses 
the SELECT key again without pressing one of the arrow keys.</p>
<p>Listing 23 also signals the end of the overridden <b>keyPressed</b> method 
and the end of the discussion of the MIDlet named <b>Canvas04</b>.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the MIDlet code from Listing 24 and Listing 25.&nbsp; 
Run 
the MIDlets in the updated MIDlet development framework named <b>WTKFramework03</b> 
that I provided in the lesson titled <i>Using Alerts, Images, Timers, and Gauges 
in MIDlets (see <a href="#Resources">Resources</a>)</i>.&nbsp; Experiment with the 
MIDlet code, making changes and running your modified MIDlets in the framework 
program.&nbsp; See if you can explain the results produced by your changes.</p>
<p>Don't forget that you will need to download and install the latest version of 
the Sun Java Wireless Toolkit for CLDC <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
As of the date this lesson is being written, the latest version of the toolkit 
is WTK2.5.2.</p>
<p>If you run either of these MIDlets, you will need to provide three small image files to 
replace the image files in the above <a href="#following_names">list</a>.&nbsp; 
Be sure to copy those files into the same directory as the directory that 
contains your source code, and either change the names of your image files to 
match the names of my files, or change the code in Listing 6 to match the names 
of your image files.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I began by presenting and explaining the MIDlet program named <b>Canvas03</b>.&nbsp; This MIDlet introduces three major programming concepts not covered 
in earlier lessons:</p>
<ul>
	<li>The mixture of image file data and drawn graphics on a <b>Canvas</b>.</li>
	<li>The use of an off-screen image.</li>
	<li>The use of the event handling capability of the <b>Canvas</b> class for 
	simple animation.</li>
</ul>
<p>In addition, the MIDlet named <b>Canvas03 </b>illustrates a variety of drawing capabilities of 
the <b>Graphics</b> class including:</p>
<ul>
	<li>Rectangles</li>
	<li>Arcs</li>
	<li>Filled triangles</li>
	<li>Rounded rectangles</li>
</ul>
<p>Following that, I presented and explained an updated version of the MIDlet 
named <b>Canvas04 </b>that is more efficient during the animation process.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://java.sun.com/products/sjwtoolkit/download-2_5.html">
	Download</a> Sun Java Wireless Toolkit 2.5 for CLDC Release</li>
	<li><a href="http://en.wikipedia.org/wiki/MIDlet">MIDlet</a>: From 
	Wikipedia, the free encyclopedia</li>
	<li><a href="http://www.scmad.com/j2me-glossary1.php">MIDlet</a>: According 
	to SCMAD Certification Center</li>
	<li><a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html">J2ME 
	Tutorial, Part 1: Creating MIDlets</a> by Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step4">
	Pre-verifying</a> MIDlet code according to Vikram Goyal</li>
	<li>
	<a href="http://today.java.net/pub/a/today/2005/02/09/j2me1.html?page=2#step7">
	Deploying</a> a MIDlet according to Vikram Goyal</li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/device/device;jsessionid=3F91C410E754F34B1A44DEBCE011ED18">
	The Java ME Device Table</a></span></li>
	<li><span class="style2">
	<a href="http://developers.sun.com/mobility/midp/ttips/getAppProperty/index.html">
	Retrieving MIDlet Attributes</a> by Richard Marejka</span></li>
	<li><a href="http://developers.sun.com/mobility/learn/midp/lifecycle/">
	Learning Path: MIDlet Life Cycle</a></li>
	<li><span class="style2">
	<a href="http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html?page=1">
	When Runtime.exec() won't</a> By </span>Michael C. Daconta</li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration">
	Connected Limited Device Configuration</a> <i>(CLDC)</i> from
	<span class="style2">Wikipedia</span></li>
	<li><span class="style2">
	<a href="http://en.wikipedia.org/wiki/Mobile_Information_Device_Profile">
	Mobile Information Device Profile</a> <i>(MIDP)</i> from Wikipedia</span></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr030/">CLDC 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr139/">CLDC 1.1</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr037/">MIDP 1.0</a></li>
	<li>Online API documentation for
	<a href="http://java.sun.com/javame/reference/apis/jsr118/">MIDP 2.0</a></li>
	<li><a href="http://www.pictureresize.org/online-images-converter.html">Free 
	Online Image Converter</a></li>
	<li><a href="http://www.dickbaldwin.com/java/Java062.htm">62</a>
	<font color="#000000">Event Handling in JDK 1.0.2, The Event Class</font></li>
	<li><a href="http://www.dickbaldwin.com/java/Java080.htm">80</a>
	<font color="#000000">Event Handling in JDK 1.1, A First Look, Delegation 
	Event Model</font></li>
	<li><a href="http://www.dickbaldwin.com/java/Java102.htm">102</a>
	<font color="#000000">Handling Events in Extended Components without 
	Listener Objects</font></li>
	<li><a href="http://www.developer.com/java/other/article.php/3300881">1640</a> 
	The Essence of OOP using Java, Anonymous Classes</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3719111">
	2570</a> Getting Started with MIDlets and the Sun Java Wireless Toolkit for 
	CLDC</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3721706">
	2572</a> Capturing Output Produced by Programs Running in a Child Process</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3724381">
	2574</a> Back to Basics with MIDlets and the Sun Java Wireless Toolkit for 
	CLDC</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3727396">
	2576</a> Introduction to the MIDlet User Interface, A First Look</li>
	<li>
	<a target="new" href="http://www.developer.com/java/j2me/article.php/3730141">
	2578</a> Handling Life-Cycle Issues with the MIDlet User Interface</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3736301">2580</a> 
	Using Alerts, Images, Timers, and Gauges in MIDlets</li>
	<li><a href="http://www.developer.com/java/other/article.php/3742196">2582</a> 
	Using Lists in MIDlets</li>
	<li><a href="http://www.developer.com/java/other/article.php/3747896">2584</a> 
	Using Forms and Items in MIDlets</li>
	<li><a href="http://www.developer.com/java/j2me/article.php/3753321">2586</a> 
	Programming MIDlets for Interactive Behavior</li>
	<li><a href="http://www.developer.com/java/other/article.php/3758876">2588</a> 
	Programming MIDlet Graphics using the Canvas Class</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
24 and Listing 25.<p>
<b><a name="Listing_24">Listing 24</a>. Source code for the MIDlet named Canvas03. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Canvas03.java
Copyright 2007, R.G.Baldwin

The purpose of this MIDlet is to illustrate the following
major programming concepts involving the use of the 
Canvas class and the Graphics class:

1. Creating an off-screen image.

2. Importing Image files and drawing them in specified 
locations on the off-screen image.

3. Drawing a variety of shapes in different colors on the
off-screen image, including the following:

  rectangle
  filled triangle
  arc (full circle)
  rounded rectangle

4. Drawing the off-screen image onto the Canvas in a 
specified location.

5. Handling keyPressed events on the Canvas to cause the 
off-screen image to be drawn at different locations on the
Canvas as a result of the user having pressed the 
following keys (simple animation):

  RIGHT
  LEFT
  UP
  DOWN
  SELECT

In addition, the MIDlet implements an EXIT command that 
can be used to terminate the MIDlet and cause it to enter
the destroyed state.

More detailed comments on the behavior of the program are
embedded in the program code.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package Canvas03;

import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;
import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Image;

public class Canvas03 extends MIDlet{
  Canvas myCanvas;

  public Canvas03(){
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    
    //Guarentee that the screen gets painted.
    myCanvas.repaint();
    
    //Add an EXIT command and register a CommandListener
    // to handle the EXIT command.
    myCanvas.addCommand(new Command("EXIT",
                                         Command.EXIT,2));
    myCanvas.setCommandListener(
      new CommandListener(){
        public void commandAction(
                          Command cmd,Displayable source){
          if(cmd.getCommandType() == Command.EXIT){
            destroyApp(true);
          }//end if
        }//end commandAction
      }//end new CommandListener
    );//end setCommandListener
  }//end constructor

  public void startApp(){
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//
  
  //Member class
  class MyCanvas extends Canvas{
    Image redBallImage;
    Image greenBallImage;
    Image blueBallImage;
    int frameWidth = 200;
    int frameHeight = 200;
    int redBallWidth = 0;
    int redBallHeight = 0;
    int greenBallWidth = 0;
    int greenBallHeight = 0;
    int blueBallHeight = 0;
    int blueBallWidth = 0;
    int horizBorder = 50;
    int vertBorder = 50;
    int horizDrawPoint = 0;
    int vertDrawPoint = 0;
    
    MyCanvas(){//constructor
      //The following statement is superfluous because
      // false is the default. Set to true for full-screen
      // mode. Note: changing to true will hide the EXIT 
      // command.
      setFullScreenMode(false);
      horizDrawPoint = getWidth()/2;
      vertDrawPoint = getHeight()/2;
    }//end constructor

    public void paint(Graphics g){
      try{
        //Create three Image objects
        redBallImage = Image.createImage(
                                 "/Canvas03/redball.PNG");
        greenBallImage = Image.createImage(
                               "/Canvas03/greenball.PNG");
        blueBallImage = Image.createImage(
                                "/Canvas03/blueball.PNG");

        //Get and save the dimensions of the three images.
        redBallWidth = redBallImage.getWidth();
        redBallHeight = redBallImage.getHeight();
        greenBallWidth = greenBallImage.getWidth();
        greenBallHeight = greenBallImage.getHeight();
        blueBallWidth = blueBallImage.getWidth();
        blueBallHeight = blueBallImage.getHeight();
        
        //Paint the entire screen white.
        g.setColor(0xffffff);
        g.fillRect(0,0,getWidth(),getHeight());
        
        g.setColor(0x000000);//Set drawing color to black

        //Create an off screen image.
        Image osi = Image.createImage(frameWidth,
                                      frameHeight);
      
        //Get the Graphics object belonging to the off
        // screen image.
        Graphics osg = osi.getGraphics();

        //Draw a rectangle around the osg object. Note
        // the requirement to set the dimensions of the
        // rectangle to one less than the dimensions of
        // the osg to prevent the right and bottom sides
        // of the rectangle from falling off the edge of
        // the osg
        osg.drawRect(0,0,frameWidth-1,frameHeight-1);
        
        //Draw a filled triangle on the osg object.
        osg.setColor(0xa0a000);
        osg.fillTriangle(horizBorder,
                         vertBorder,
                         frameWidth - horizBorder,
                         vertBorder,
                         frameWidth/2,
                         frameHeight - vertBorder);

        // Draw the three images on the osg object with
        // each image centered on a vertex of the
        // triangle.
        osg.drawImage(redBallImage,
                      horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
        osg.drawImage(greenBallImage,
                      frameWidth - horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
        osg.drawImage(blueBallImage,
                      frameWidth/2,
                      frameHeight - vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);

        //Draw a red rectangle around the red ball image
        // with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0xff0000);
        osg.drawRect(horizBorder - redBallWidth,
                     vertBorder - redBallHeight,
                     redBallWidth * 2,
                     redBallHeight * 2);
       
        //Draw a red circle around the red ball image with
        // a diameter that is twice the width of the
        // image. Note that in MIDP 2.0, it is necessary
        // to draw a 360-degree arc to draw a circle.
        // Also note that the angles are given in degrees
        // instead of radians.
        osg.drawArc(horizBorder - redBallWidth,
                    vertBorder - redBallHeight,
                    redBallWidth * 2,
                    redBallHeight * 2,
                    0,
                    360);
        
        //Draw a green rectangle around the green ball
        // with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x00ff00);
        osg.drawRect(
                frameWidth - horizBorder - greenBallWidth,
                vertBorder - greenBallHeight,
                greenBallWidth * 2,
                greenBallHeight * 2);
                     
        //Draw a blue rounded rectangle around the blue
        // ball with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x0000ff);
        osg.drawRoundRect(
                frameWidth/2 - blueBallWidth,
                frameHeight - vertBorder - blueBallHeight,
                blueBallWidth * 2,
                blueBallHeight * 2,
                (int)(1.25 * blueBallWidth),
                (int)(1.25 * blueBallHeight));
        
        
      
        //Draw the off screen image onto the Canvas.
        // Center the image on the coordinates given by
        // the first two parameters.
        g.drawImage(osi,
                    horizDrawPoint,
                    vertDrawPoint,
                    Graphics.HCENTER | Graphics.VCENTER);
      
      } catch(Exception e){e.printStackTrace();}

    }//end overridden paint method
    //--------------------------------------------------//
    
    //Override the keyPressed method to implement a crude
    // animation capability. Pressing the arrow keys moves
    // the image in the direction of the arrow.  Pressing
    // the SELECT key resets the image to the center of
    // the screen. Note that pressing the UP arrow
    // actually moves the image up the screen instead of
    // down the screen
    //This code may only be compatible with the Sun cell
    // phone emulator due to the use of specific key
    // names.
    public void keyPressed(int keyCode){
      String keyName = getKeyName(keyCode);
      if(keyName.equals("LEFT")){
        horizDrawPoint -= 5;
      }else if(keyName.equals("RIGHT")){
        horizDrawPoint += 5;
      }else if(keyName.equals("UP")){
        vertDrawPoint -= 5;
      }else if(keyName.equals("DOWN")){
        vertDrawPoint += 5;
      }else if(keyName.equals("SELECT")){
        //Reset to the center.
        horizDrawPoint = getWidth()/2;
        vertDrawPoint = getHeight()/2;
      }else{
        //Do nothing if the user presses a different key.
      }//end else
      
      //Repaint the screen with the image in the new
      // position.
      this.repaint();
    }//end keyPressed
  }//end member class MyCanvas

}//end class Canvas03
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Source code for the MIDlet named Canvas04. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Canvas04.java
Copyright 2007, R.G.Baldwin

This is an update to the MIDlet named Canvas03 to improve 
the efficiency of the MIDlet insofar as the simple 
animation is concerned.

The updates were:
1. Move the creation of the off-screen image to the
   constructor for the Canvas class so that it only
   needs to be executed once.
2. Paint only that portion of the screen that changes
   each time the black rectangle and its contents move..
3. Eliminate repainting the screen on multiple presses
   of the SELECT key.
   
The following comments were not modified when Canvas03
was updated to Canvas04.

The purpose of this MIDlet is to illustrate the following
major programming concepts involving the use of the 
Canvas class and the Graphics class:

1. Creating an off-screen image.

2. Importing Image files and drawing them in specified 
locations on the off-screen image.

3. Drawing a variety of shapes in different colors on the
off-screen image, including the following:

  rectangle
  filled triangle
  arc (full circle)
  rounded rectangle

4. Drawing the off-screen image onto the Canvas in a 
specified location.

5. Handling keyPressed events on the Canvas to cause the 
off-screen image to be drawn at different locations on the
Canvas as a result of the user having pressed the 
following keys (simple animation):

  RIGHT
  LEFT
  UP
  DOWN
  SELECT

In addition, the MIDlet implements an EXIT command that 
can be used to terminate the MIDlet and cause it to enter
the destroyed state.

More detailed comments on the behavior of the program are
embedded in the program code.

Tested using a Java SE 6 compiler, targeted at a V1.4
virtual machine, and WTK 2.5.2 running under Windows XP.
*********************************************************/

package Canvas04;

import javax.microedition.lcdui.Display;
import javax.microedition.midlet.MIDlet;
import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Image;

public class Canvas04 extends MIDlet{
  Canvas myCanvas;

  public Canvas04(){
    System.out.println("Construct MIDlet");
    myCanvas = this.new MyCanvas();
    
    //Guarentee that the screen gets painted.
    myCanvas.repaint();
    
    //Add an EXIT command and register a CommandListener
    // to handle the EXIT command.
    myCanvas.addCommand(new Command("EXIT",
                                         Command.EXIT,2));
    myCanvas.setCommandListener(
      new CommandListener(){
        public void commandAction(
                          Command cmd,Displayable source){
          if(cmd.getCommandType() == Command.EXIT){
            destroyApp(true);
          }//end if
        }//end commandAction
      }//end new CommandListener
    );//end setCommandListener
    
  }//end constructor

  public void startApp(){
    //Make the Canvas the current display.
    Display.getDisplay(this).setCurrent(myCanvas);
  }//end startApp

  public void pauseApp(){
  }//end pauseApp

  public void destroyApp(boolean unconditional){
    System.out.println("Destroy MIDlet");
    notifyDestroyed();
  }//end destroyApp
  //----------------------------------------------------//
  
  //Member class
  class MyCanvas extends Canvas{
    Image redBallImage;
    Image greenBallImage;
    Image blueBallImage;
    int frameWidth = 200;
    int frameHeight = 200;
    int redBallWidth = 0;
    int redBallHeight = 0;
    int greenBallWidth = 0;
    int greenBallHeight = 0;
    int blueBallHeight = 0;
    int blueBallWidth = 0;
    int horizBorder = 50;
    int vertBorder = 50;
    int horizDrawPoint = 0;
    int vertDrawPoint = 0;
    Image osi;
    boolean multipleSelects = false;//new to the update
    
    MyCanvas(){//constructor
      try{
        //The following statement is superfluous because
        // false is the default. Set to true for
        // full-screen mode. Note: changing to true will
        // hide the EXIT command.
        setFullScreenMode(false);
        horizDrawPoint = getWidth()/2;
        vertDrawPoint = getHeight()/2;
        
        //Create the off-screen image one time only.
        //Create three Image objects
        redBallImage = Image.createImage(
                                 "/Canvas04/redball.PNG");
        greenBallImage = Image.createImage(
                               "/Canvas04/greenball.PNG");
        blueBallImage = Image.createImage(
                                "/Canvas04/blueball.PNG");

        //Get and save the dimensions of the three images.
        redBallWidth = redBallImage.getWidth();
        redBallHeight = redBallImage.getHeight();
        greenBallWidth = greenBallImage.getWidth();
        greenBallHeight = greenBallImage.getHeight();
        blueBallWidth = blueBallImage.getWidth();
        blueBallHeight = blueBallImage.getHeight();

        //Create an off screen image.
        osi = Image.createImage(frameWidth,frameHeight);
      
        //Get the Graphics object belonging to the off-
        // screen image.
        Graphics osg = osi.getGraphics();

        //Draw a rectangle around the osg object. Note
        // the requirement to set the dimensions of the
        // rectangle to one less than the dimensions of
        // the osg to prevent the right and bottom sides
        // of the rectangle from falling off the edge of
        // the osg
        osg.drawRect(0,0,frameWidth-1,frameHeight-1);
        
        //Draw a filled triangle on the osg object.
        osg.setColor(0xa0a000);
        osg.fillTriangle(horizBorder,
                         vertBorder,
                         frameWidth - horizBorder,
                         vertBorder,
                         frameWidth/2,
                         frameHeight - vertBorder);

        // Draw the three images on the osg object with
        // each image centered on a vertex of the
        // triangle.
        osg.drawImage(redBallImage,
                      horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
        osg.drawImage(greenBallImage,
                      frameWidth - horizBorder,
                      vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);
        osg.drawImage(blueBallImage,
                      frameWidth/2,
                      frameHeight - vertBorder,
                      Graphics.HCENTER|Graphics.VCENTER);

        //Draw a red rectangle around the red ball image
        // with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0xff0000);
        osg.drawRect(horizBorder - redBallWidth,
                     vertBorder - redBallHeight,
                     redBallWidth * 2,
                     redBallHeight * 2);
       
        //Draw a red circle around the red ball image with
        // a diameter that is twice the width of the
        // image. Note that in MIDP 2.0, it is necessary
        // to draw a 360-degree arc to draw a circle.
        // Also note that the angles are given in degrees
        // instead of radians.
        osg.drawArc(horizBorder - redBallWidth,
                    vertBorder - redBallHeight,
                    redBallWidth * 2,
                    redBallHeight * 2,
                    0,
                    360);
        
        //Draw a green rectangle around the green ball
        // with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x00ff00);
        osg.drawRect(
                frameWidth - horizBorder - greenBallWidth,
                vertBorder - greenBallHeight,
                greenBallWidth * 2,
                greenBallHeight * 2);
                     
        //Draw a blue rounded rectangle around the blue
        // ball with the width and height of the rectangle
        // being twice the width and height of the image.
        osg.setColor(0x0000ff);
        osg.drawRoundRect(
                frameWidth/2 - blueBallWidth,
                frameHeight - vertBorder - blueBallHeight,
                blueBallWidth * 2,
                blueBallHeight * 2,
                (int)(1.25 * blueBallWidth),
                (int)(1.25 * blueBallHeight));
      
      } catch(Exception e){e.printStackTrace();}
      
    }//end constructor
    //--------------------------------------------------//

    public void paint(Graphics g){
      
      //Paint the screen white. Note, only that portion of
      // the screen specified in the call to the repaint
      // method actually gets painted if the overloaded
      // version of the repaint method that requires
      // parameters is called. However, it is not
      // necessary for the paint method to take this into
      // account.
      g.setColor(0xffffff);
      g.fillRect(0,0,getWidth(),getHeight());
      
      g.setColor(0x000000);//Set drawing color to black
    
      //Draw the off screen image onto the Canvas.
      // Center the image on the coordinates given by
      // the first two parameters.
      g.drawImage(osi,
                  horizDrawPoint,
                  vertDrawPoint,
                  Graphics.HCENTER | Graphics.VCENTER);

    }//end overridden paint method
    //--------------------------------------------------//
    
    //Override the keyPressed method to implement a simple
    // animation capability. Pressing the arrow keys moves
    // the image in the direction of the arrow.  Pressing
    // the SELECT key resets the image to the center of
    // the screen. Note that pressing the UP arrow
    // actually moves the image up the screen instead of
    // down the screen
    //This code may only be compatible with the Sun cell
    // phone emulator due to the use of specific key
    // names.
    public void keyPressed(int keyCode){
      int step = 5;//Distance moved on each click.
      String keyName = getKeyName(keyCode);
      
      if(keyName.equals("LEFT")){
        horizDrawPoint -= step;
        //Repaint only the portion of the screen that 
        // needs to change.
        this.repaint(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2,
                     frameWidth + step,
                     frameHeight);
        //Set multipleSelects to false to cause the SELECT
        // key to repaint the screen the next time it is
        // pressed..
        multipleSelects = false;
      }else if(keyName.equals("RIGHT")){
        horizDrawPoint += step;
        this.repaint(horizDrawPoint - frameWidth/2 - step,
                     vertDrawPoint - frameHeight/2,
                     frameWidth + step,
                     frameHeight);
        multipleSelects = false;
      }else if(keyName.equals("UP")){
        vertDrawPoint -= step;
        this.repaint(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2,
                     frameWidth,
                     frameHeight + step);
        multipleSelects = false;
      }else if(keyName.equals("DOWN")){
        vertDrawPoint += step;
        this.repaint(horizDrawPoint - frameWidth/2,
                     vertDrawPoint - frameHeight/2 - step,
                     frameWidth,
                     frameHeight + step);
        multipleSelects = false;
      }else if(keyName.equals("SELECT")){
        //Reset to the center.
        horizDrawPoint = getWidth()/2;
        vertDrawPoint = getHeight()/2;
        if(!multipleSelects){
          //If the user presses SELECT two or more times
          // in succession, the screen will only be
          // repainted the first time.
          //Repaint the entire screen with the off-screen
          // image centered on the screen.
          this.repaint();
          multipleSelects = true;
        }//end if
      }else{
        //Do nothing if the user presses a different key.
      }//end else

    }//end keyPressed
  }//end Member class MyCanvas

}//end class Canvas04
//======================================================//
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2008, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java J2ME MIDlet &quot;cell phone emulator&quot; &quot;wireless toolkit&quot; WTK MIDP CLDC 
Displayable TextBox Ticker TextField Alerts Images Timers Gauges Lists Forms 
Items String StringItem ImageItem ChoiceGroup DateField Command CommandListener 
ItemCommandListener Canvas Graphics &quot;anchor point&quot; keyPressed paint repaint</p>
<p>-end- 
<br>
<br>
</p>
</body>
</html>
