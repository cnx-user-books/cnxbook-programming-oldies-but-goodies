<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2 align="center">Understanding Transforms in Java 3D</h2>
<i>Learn to understand transforms in Java 3D and how to write Java 3D code that makes use of that understanding.</i>
<p><b>Published:</b>&nbsp; December 18, 2007<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1552</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Experimental_Results">Experimental Results</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a></li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Download">Download</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p><font color="#ff0000"><b>Part of a series</b></font></p>
<p>This lesson is part of a series designed to start with Java 3D basics and 
work up to some very complicated programs, such as the program that I explained 
in the earlier lesson titled &quot;Understanding Lighting in the Java 3D API&quot; <i>(see
<a href="#Resources">Resources</a>).</i></p>
<p>The first lesson in this series was titled &quot;Back to Basics in the Java 3D 
API&quot;.&nbsp; The previous lesson was titled &quot;Understanding Transforms in Java 2D.&quot;&nbsp; 
This lesson is titled &quot;Understanding Transforms in Java 3D.&quot;</p>
<p>My current plan is for future lessons to deal with user and object 
interaction, advanced animation, and textures in Java 3D.</p>
<p><font color="#ff0000"><b>What you will learn</b></font></p>
<p>In this lesson, you will learn to understand transforms in Java 3D.&nbsp; You will 
also learn how to write Java 3D code that makes use of that understanding.</p>
<p><b><font color="#ff0000">Compiling and running Java 3D programs</font></b></p>
<p>In order to compile and run programs using the Java 3D API, you will need to 
download and install the Java 3D API software.&nbsp; As of the date of this writing, 
version 1.5.0 is available for <a href="#Download">download</a>.</p>
<p>In addition, you will need to <a href="#Download">download</a> 
and install either <b>Microsoft DirectX</b> or <b>OpenGL</b>.&nbsp; All of the sample 
programs in this series of tutorials were developed and tested using Microsoft 
DirectX.&nbsp; They were not tested using OpenGL.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Visible objects in Java 3D.</li>
	<li><a href="#Figure_2">Figure 2</a>. A sphere rendered in 3D with its 
	skin intact.</li>
	<li><a href="#Figure_3">Figure 3</a>. A sphere rendered in 3D without its 
	skin.</li>
	<li><a href="#Figure_4">Figure 4</a>. Two renderings of the Alice ice 
	skater.</li>
	<li><a href="#Figure_5">Figure 5</a>. Matrix operations for the three 
	basic Java 2D transforms.</li>
	<li><a href="#Figure_6">Figure 6</a>. Matrix operations for the five 3D transforms.</li>
	<li><a href="#Figure_7">Figure 7</a>. BranchGroup hierarchy for the 
	program named Java3D010.</li>
	<li><a href="#Figure_8">Figure 8</a>. Sample screen output and user input 
	GUI for Java3D010.</li>
	<li><a href="#Figure_9">Figure 9</a>. Translation followed by rotation.</li>
	<li><a href="#Figure_10">Figure 10</a>. Transform matrices for parameters 
	shown in Figure 9.</li>
	<li><a href="#Figure_11">Figure 11</a>. Rotation followed by translation.</li>
	<li><a href="#Figure_12">Figure 12</a>. Translation followed by rotation 
	followed by translation and scale.</li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. The method named translate.</li>
	<li><a href="#Listing_2">Listing 2</a>. The method named scale.</li>
	<li><a href="#Listing_3">Listing 3</a>. The method named displayMatrix.</li>
	<li><a href="#Listing_4">Listing 4</a>. The method named getAxesGroup.</li>
	<li><a href="#Listing_5">Listing 5</a>. Beginning of the constructor for the 
	class named Scene.</li>
	<li><a href="#Listing_6">Listing 6</a>. Create and prepare two ColorCube 
	objects.</li>
	<li><a href="#Listing_7">Listing 7</a>. Add visible axes to the 
	blueCubeGroup.</li>
	<li><a href="#Listing_8">Listing 8</a>. Create and display a scaling 
	transform.</li>
	<li><a href="#Listing_9">Listing 9</a>. Create and display a translation 
	transform.</li>
	<li><a href="#Listing_10">Listing 10</a>. Create and display a rotation 
	transform.</li>
	<li><a href="#Listing_11">Listing 11</a>. Create and add another set of 
	axes.</li>
	<li><a href="#Listing_12">Listing 12</a>. Create and display another 
	translation transform.</li>
	<li><a href="#Listing_13">Listing 13</a>. Complete the hierarchy.</li>
	<li><a href="#Listing_14">Listing 14</a>. Complete the constructor and the 
	classes.</li>
	<li><a href="#Listing_15">Listing 15</a>. Listing for the program named 
	Java3D010.</li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<p><font color="#ff0000"><b>Types of transforms of interest</b></font></p>
<p>This lesson will be concerned with transforms of the following types:</p>
<ul>
	<li>Scaling</li>
	<li>Translation</li>
	<li>Rotation</li>
</ul>
<p><font color="#ff0000"><b>Prerequisite background knowledge</b></font></p>
<p>To understand transforms in either 2D or 3D <i>(particularly the rotation 
transform)</i> you need to have some understanding of trigonometry.&nbsp; I'm sorry, 
but that is simply the way that it is.&nbsp; In addition, it will be helpful if you 
have some knowledge of matrices and matrix algebra.</p>
<p>While I will do my best to help you understand transforms, trying to teach 
you the requisite background knowledge is beyond the scope of this tutorial.&nbsp; I 
will provide only a brief discussion of the requisite background.&nbsp; For technical 
background, I recommend that you study the previous lesson titled &quot;Understanding 
Transforms in Java 2D&quot; and the articles titled &quot;Trigonometry&quot;, &quot;Planar 
transformations&quot;, &quot;Spatial transformations&quot;, and &quot;A little algebra&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Visible objects in Java 3D</b></font></p>
<p>Just to get us started, Figure 1 shows some spheres produced using Java 3D.&nbsp; 
The quality of the rendering of the yellow and white spheres in Figure 1 was 
purposely kept low to cause the facets to be visible.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Visible objects in Java 3D. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a01.jpg" width="236" height="236"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Constructed using a mesh</b></font></p>
<p>Visible objects in 3D are typically constructed by constructing a mesh of 
inter-connected polygons <i>(usually triangles)</i> and then covering that mesh 
with a skin.&nbsp; For example, Figure 2 shows a sphere rendered in 3D with its 
skin intact.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. A sphere rendered in 3D with its skin 
	intact. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a03.jpg" width="435" height="337"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Let's see the mesh</b></font></p>
<p>Figure 3 shows the same sphere rendered in 3D with its skin removed.&nbsp; <i>(Figures 2 and 3 were created using the Alice program 
development environment.&nbsp; See <a href="#Resources">Resources</a>.)</i></p>
<p>
 <b><a name="Figure_3">Figure 3</a>. A sphere rendered in 3D without its skin.</b><table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a02.jpg" width="437" height="338"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Figure 3 shows the mesh of inter-connecting triangles that I mentioned 
earlier.&nbsp; </p>
<p><font color="#FF0000"><b>A wireframe drawing</b></font></p>
<p>A rendering of the mesh as shown in Figure 3 is often referred to as a<i> 
wireframe</i> drawing.&nbsp; <i>(Figure 3 is an Alice wireframe rendering.&nbsp; 
Most wireframe drawings probably don't include the 3D rendering created through 
the use of the light source in Figure 3.&nbsp; Wireframe drawings are often 
just black lines on a white background.)</i></p>
<p><font color="#FF0000"><b>Visual attributes</b></font></p>
<p>Various visual attributes of the object <i>(such as shading, color, etc.)</i> 
are achieved by the color, intensity, and other appearance factors that are 
applied to the section of skin that is drawn to cover each individual triangle.&nbsp; 
For example, in Figure 2, the skin sections covering the triangles in the upper 
right are very light while the skin covering the triangles in the lower left are 
much darker.&nbsp; This effect is used to create the optical illusion that we 
refer to as a 3D rendering.</p>
<p><font color="#FF0000"><b>Controlling the quality</b></font></p>
<p>Often, it is possible to control the number of triangles that are used to 
construct the mesh.&nbsp; Up to a point, the quality of the 3D rendering of an 
object can be improved by constructing the mesh with more triangles.</p>
<p>For example, the rendering quality of the yellow and white spheres in Figure 
1 was purposely made low in order to expose the facets on the surface of the two 
spheres.&nbsp; A wireframe drawing of these spheres would show that it was 
constructed with a small number of triangles.&nbsp; The sphere in Figures 2 and 
3, on the other hand, was constructed using a larger number of triangles, which 
resulted in better rendering quality.&nbsp; The sphere in Figure 
2 looks more like a true sphere than the yellow and white spheres in Figure 1.</p>
<p>Just to show that these concepts apply to more complex visual objects 
than spheres, Figure 4 shows a <i>solid</i> rendering and a <i>wireframe</i> 
rendering of the Alice ice skater object.&nbsp; <i>(A good way to get some experience in 3D programming 
very quickly is to visit my web page 
titled &quot;Learn to Program using Alice&quot; (see <a href="#Resources">
Resources</a>) and study some of the tutorial 
lessons that you will find there.)</i></p>



<p><b><a name="Figure_4">Figure 4</a>. Two renderings of the Alice ice skater.</b>
<table border="1" bgcolor="#ffffff">
	<tr>
		<td><img border="0" src="java1552a04.jpg" width="149" height="342"></td>
		<td><img border="0" src="java1552a05.jpg" width="154" height="338"></td>
	</tr>
</table>
</p>


<p>As you can see, the object in Figure 4 is constructed from hundreds of 
inter-connected triangles.</p>
<p><font color="#ff0000"><b>What is a point?</b></font></p>
<p>A point is a location in 3D space defined by three coordinate values <i>
(x,y,z)</i>.&nbsp; The value for x defines the location of the point relative to an <i>
origin</i> along the x-axis <i>(see the red line in Figures 2 and 3.)</i>.&nbsp; The value for y defines 
the location of the point along the y-axis <i>(see the green line in Figures 2 
and 3)</i>.&nbsp; The value for z defines the location of the point along the 
z-axis <i>(see the blue line in Figures 2 and 3.)</i>.&nbsp; The x, y, and z 
axes intersect at the <i>origin</i> in 3D space.&nbsp; The sphere in Figures 2 
and 3 is centered on that origin.</p>
<p>The locations where the triangles connect to one another in Figures 3 and 4 
are referred to as the vertices.&nbsp; The location of each vertex is specified 
by a point and its three coordinate values.&nbsp; Generally speaking, the 
transforms that are applied to 3D objects involve modifying the coordinate 
values that specify each vertex.</p>
<p><font color="#FF0000"><b>The x, y, and z axes</b></font></p>
<p>The axes may or may not be visible in the 
graph.&nbsp; <i>(I purposely made them visible in Figures 2 and 3.)</i>&nbsp; 
However, even when they are not visible, they are assumed to be present.</p>
<p>The x-axis is typically considered to be the horizontal axis with positive 
values going from left to right.&nbsp; This is the case in Java 3D.&nbsp; The y-axis 
is typically considered to be the vertical axis with positive values going from bottom 
to top.&nbsp; <i>(Fortunately, unlike Java 2D, the positive direction for y in 
Java 3D is from bottom to top.)</i>&nbsp; The z-axis is typically considered to 
go from back to front, protruding out of the screen toward the viewer.&nbsp; In 
Java 3D, the positive z direction is toward the viewer.</p>
<p><font color="#ff0000"><b>Where is the origin?</b></font></p>
<p>In Java 3D, the origin is at the center of the universe.&nbsp; While it is 
possible to change the apparent location of the origin on the screen by working 
with the <b>ViewingPlatform</b>, the origin will be generally at the center of 
the <b>Canvas</b> object used to display the universe in this program.</p>
<p><font color="#ff0000"><b>What is a vector?</b></font></p>
<p>According to Wikipedia <i>(see <a href="#Resources">Resources</a>)</i>, 
there are several kinds of vectors.&nbsp; A <i>spatial vector</i> is an object 
defined by both magnitude and direction; in contrast to a <i>scalar</i>, an 
object with magnitude only.</p>
<p>Also, according to Wikipedia, the word vector is used to describe a 
one-dimensional, directional matrix; a <i>row vector</i> or a <i>column vector</i>.&nbsp; 
I will use the word vector in both senses <i>(spatial and matrix)</i> in this 
lesson.&nbsp; Hopefully the sense in which the word is being used will be clear from 
the context of the discussion.</p>
<p><font color="#ff0000"><b>What is a transform?</b></font></p>
<p>In the sense that it will be used in this lesson, a transform is an operation 
that converts the coordinate values for every point that defines an object into a 
different set of coordinate values.&nbsp; The object that is defined by the new 
coordinate values will probably be recognizable as representing the original 
object, although it may be a different size <i>(scale)</i>, may be in a different 
location <i>(translation)</i>, may have a different orientation <i>(rotation)</i>, may be squashed in one dimension or the other, or 
may be flipped across one or both of the axes.</p>
<p><font color="#ff0000"><b>What is an affine transform?</b></font></p>
<p>The transforms that will be used in this lesson are actually affine 
transforms.&nbsp; According to the Java 3D documentation:</p>
<blockquote>
	<p><i>&quot;An affine matrix can translate, rotate, reflect, scale 
	anisotropically, and shear. Lines remain straight, and parallel lines remain 
	parallel, but the angle between intersecting lines can change. In order for 
	a transform to be classified as affine, the 4th row must be: [0, 0, 0, 1].&quot;</i></p>
</blockquote>
<p><font color="#ff0000"><b>Translation</b></font></p>
<p>To translate an object means to move the object from one location in 3D space 
to a different location in 3D space.&nbsp; <i>(You will see how this is 
accomplished later.)</i>&nbsp; We can translate an object by translating all of the 
points that define the object.&nbsp; We can translate a point by adding offsets to the 
x, y, and z coordinate values that define the location of the point.</p>
<p>If we express the original coordinates of a point as x1, y1, and z1, and express 
the offsets as tx, ty, and tz, we can express the coordinates of the new 
location of the point as:</p>
<pre>x2 = x1 + tx
y2 = y1 + ty
z2 = z1 + tz</pre>
<p><font color="#ff0000"><b>Scaling</b></font></p>
<p>To scale an object means to change the locations of all the points that 
represent the object according to a very specific formula.&nbsp; Typically, but not 
always, a scaling transform will change the size of the object, making it larger 
or smaller.&nbsp; <i>(Note that scaling by factors of 1 or -1 doesn't change the size.)</i>&nbsp; 
We can accomplish a scaling transform by multiplying the x, y, and z coordinate values of 
all the points that define the object by the same or by different scale factors.</p>
<p>If the scale factors used to multiply the coordinate values are the 
same, the object will simply become larger or smaller <i>(and could be flipped 
across the axes if the scale factors are negative)</i>.&nbsp; If the scale factors 
applied to each axis are different, the object may be squashed in one dimension or the other, or 
possibly even flipped across the axes, but will probably still be 
recognizable as representing the same object.</p>
<p>The scale factors that are used in a scaling transform are expressed relative 
to the origin.&nbsp; For example, a scale factor of 2.0 will cause a coordinate value 
for a point to represent the coordinate value for a new point that is twice as 
far from the origin.</p>
<p>If we express the original coordinates of a point as x1, y1, and z1, and express 
the scale factors as sx, sy, and sz, then we can express the coordinates of the new 
location of the point as:</p>
<pre>x2 = x1 * sx
y2 = y1 * sy
z2 = z1 * sx</pre>
<p><font color="#ff0000"><b>Rotation</b></font></p>
<p>Rotation is much less intuitive than either translation or scaling, and 
requires a fair knowledge of trigonometry to understand.&nbsp; However, it is 
possible to create and use rotation transforms in a cookbook fashion without 
understanding why they work.</p>
<p>The following equations for rotating a point around the origin in 2D space 
are derived in &quot;Planar transformations&quot; <i>(see
<a href="#Resources">Resources</a>)</i>, where v represents the 
angle of rotation.</p>
<pre>x2 = x1 * cos(v) - y1 * sin(v)
y2 = x1 * sin(v) + y1 * cos(v)</pre>
<p>These equations are extended into 3D in &quot;Spatial transformations&quot; <i>(see
<a href="#Resources">Resources</a>)</i>.&nbsp; Things get a good bit more 
complicated in 3D.&nbsp; In 2D, you can only rotate within the x-y plane, 
meaning that you can only rotate around the origin.&nbsp; However, in 3D, you 
are not constrained to rotate within any one of the x-y, y-z, or z-x planes.&nbsp; 
Rather, you can rotate around any or all of the three axes.&nbsp; As a result, there 
are three sets of rotation equations involved.&nbsp; I will show you those three 
sets of equations later in conjunction with the matrix equations for transforms.</p>
<p><font color="#ff0000"><b>Positive angle of rotation</b></font>&nbsp;</p></p>
<p>The author who derived these equations tells us that they assume that a 
positive rotation angle is counterclockwise around the axis.&nbsp; What this 
means is that if you stand at the positive end of an axis and face the origin, a 
positive angle of rotation around that axis will be counterclockwise. </p>
<p><font color="#ff0000"><b>Matrices</b></font></p>
<p>In the earlier lesson titled &quot;Understanding Transforms in Java 2D&quot; <i>(see
<a href="#Resources">Resources</a>)</i>, I taught you about the use of matrices 
to perform transforms in Java 2D.&nbsp; I also taught you about <i>homogeneous 
coordinates</i>.</p>
<p>The article titled &quot;Planar transformations&quot; <i>(see
<a href="#Resources">Resources</a>)</i> gives us the matrix 
equations shown in Figure 2, which can be solved to accomplish translation, 
scaling, and rotation transforms in 2D. </p>
<p>
 <b><a name="Figure_5">Figure 5</a>. Matrix operations for the three basic 
	Java 2D transforms. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre>Translation  	
|x2|   <b>|1 0 tx|</b> |x1|
|y2| = <b>|0 1 ty|</b>*|y1|
|1 |   <b>|0 0  1|</b> |1 |

Scaling 	
|x2|   <b>|sx 0 0|</b> |x1|
|y2| = <b>|0 sy 0|</b>*|y1|
|1 |   <b>|0  0 1|</b> |1 |

Rotation 	
|x2|   <b>|cos(v) -sin(v) 0|</b> |x1|
|y2| = <b>|sin(v) cos(v)  0|</b>*|y1|
|1 |   <b>|0        0     1|</b> |1 |
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
</p>
<p><font color="#FF0000"><b>Transform equations for Java 3D</b></font></p>
<p>Although not nearly as explicit, in the article titled &quot;Spatial 
transformations&quot; <i>(see <a href="#Resources">Resources</a>)</i>, that same 
author gives enough information to make it possible for us to extend the 2D 
equations into a set of 3D equations.&nbsp; The 3D versions of the homogeneous 
transform matrix equations are shown in Figure 6.</p>
<p><b><a name="Figure_6">Figure 6</a>. Matrix operations for the five 3D transforms. </b>
<table bgcolor="#ffffff" border="1" cols="1" width="477">
	<tr>
		<td>
		<pre>Translation  	
|x2|   |1 0 0 tx| |x1|
|y2| = |0 1 0 ty|*|y1|
|z2|   |0 0 1 tz| |z1|
|1 |   |0 0 0 1 | |1 |

Scaling 	
|x2|   |sx 0 0 0| |x1|
|y2| = |0 sy 0 0|*|y1|
|z2|   |0 0 sz 0| |z1|
|1 |   |0 0 0  1| |1 |

Rotation around the z-axis
|x2|   |cos(v) -sin(v)  0   0| |x1|
|y2| = |sin(v)  cos(v)  0   0|*|y1|
|z2|   |0         0     1   0| |z1|
|1 |   |0         0     0   1| |1 |

Rotation around the x-axis
|x2|   |1    0        0    0| |x1|
|y2| = |0  cos(v)  -sin(v) 0|*|y1|
|z2|   |0  sin(v)  cos(v)  0| |z1|
|1 |   |0    0       0     1| |1 |

Rotation around the y-axis
|x2|   |cos(v)  0  sin(v)  0| |x1|
|y2| = |   0    1    0     0|*|y1|
|z2|   |-sin(v) 0  cos(v)  0| |z1|
|1 |   |   0    0    0     1| |1 |
</pre>
		</td>
	</tr>
</table>
&nbsp;<p>It is probably worth noting that the 3D matrix equation for rotating 
around the z-axis in Figure 6 is very similar to the 2D rotation equation shown 
in Figure 5.&nbsp; One way to think about this is that 2D is simply 3D 
constrained to include only the x-y plane.&nbsp; Therefore, rotation around the 
origin in 2D is analogous to rotation around the z-axis in 3D.</p>
<p><font color="#ff0000"><b>Compound operations</b></font></p>
<p>As you learned in the earlier lesson on 2D, one of the advantages of using 
the homogeneous form of the matrix equations is that this makes it possible to combine a series of transforms into a 
single matrix multiplication by first multiplying the individual matrices that 
represent of the individual transforms to produce a single compound matrix.&nbsp; 
Instead of having to perform a series of individual transforms on each point 
that represents an object, a compound transform matrix can be created first, and 
each point can be transformed by multiplying the column vector that represents 
that point by the compound matrix that represents the entire set of transforms.&nbsp; 
The savings in computational requirements can be enormous.</p>
<p><font color="#ff0000"><b>The good news</b></font></p>
<p>It is possible to write Java 3D programs where almost your entire thought 
process revolves around the creation and use of transform matrices down to the 
element level.&nbsp; However, the good news is that it is possible to write most Java 3D programs 
without having to think too deeply about matrices.&nbsp; This is because the Java 
3D 
API provides convenience methods that abstract most of the matrix operations 
behind a fairly common Java programming interface.&nbsp; Even when you use the 
convenience methods, however, it is a good idea to have some appreciation as to 
what is actually taking place behind the curtains.</p>
<p><font color="#FF0000"><b>The overall Java 3D program structure</b></font></p>
<p>The overall program structure of a Java 3D scene is a hierarchical tree.&nbsp; The 
universe is the root of the tree.&nbsp; Moving down from the root, we next 
encounter an object of the class <b>Locale</b>.&nbsp; Here is a little what Sun 
has to say about the <b>Locale</b> class:</p>
<blockquote>
	<p><i>&quot;A Locale object defines a high-resolution position within a 
	VirtualUniverse, and serves as a container for a collection of 
	BranchGroup-rooted subgraphs (branch graphs), at that position...</i></p>
	<p><i>A Locale object defines methods to set and get its high-resolution 
	coordinates, and methods to add, remove, and enumerate the branch graphs.&quot;</i></p>
</blockquote>
<p>Thus, the <b>Locale</b> object is a node in the tree, which may have one or 
more children of the class <b>BranchGroup</b>.</p>
<p><font color="#FF0000"><b>The BranchGroup class</b></font></p>
<p>Here is some of what Sun has to say about the <b>BranchGroup</b> class:</p>
<blockquote>
	<p><i>&quot;The BranchGroup serves as a pointer to the root of a scene graph 
	branch; BranchGroup objects are the only objects that can be inserted into a 
	Locale's set of objects.&quot;</i></p>
</blockquote>
<p>Thus, the <b>BranchGroup</b> is also a node in the tree, which may have one 
or more children of the type <b>Node</b>.&nbsp; The <b>Node</b> class is an 
abstract class that, as of Java 3D version 1.5.0, has two subclasses:</p>
<ul>
	<li>Group</li>
	<li>Leaf</li>
</ul>
<p>This means, therefore, that a <b>BranchGroup</b> object may have any number 
of children of the types <b>Group</b> and <b>Leaf</b>.</p>
<p><font color="#FF0000"><b>The Leaf class</b></font></p>
<p>Here is some of what Sun has to say about the <b>Leaf</b> class:</p>
<blockquote>
	<p><i>&quot;The Leaf node is an abstract class for all scene graph nodes that 
	have no children. Leaf nodes specify lights, geometry, and sounds. They 
	specify special linking and instancing capabilities for sharing scene graphs 
	and provide a view platform for positioning and orienting a view in the 
	virtual world.&quot;</i></p>
</blockquote>
<p>In this program, we will be using a <b>ColorCube</b> object, which is a 
subclass of the <b>Leaf</b> class.&nbsp; This tells us that a <b>ColorCube</b> 
object can be added as a child of a <b>BranchGroup</b> object, which we will do.</p>
<p><font color="#FF0000"><b>The Group class</b></font></p>
<p>Here is some of what Sun has to say about the <b>Group</b> class:</p>
<blockquote>
	<p><i>&quot;The Group node object is a general-purpose grouping node. Group nodes 
	have exactly one parent and an arbitrary number of children that are 
	rendered in an unspecified order (or in parallel). Null children are 
	allowed; no operation is performed on a null child node. Operations on Group 
	node objects include adding, removing, and enumerating the children of the 
	Group node. The subclasses of Group node add additional semantics.&quot;</i></p>
</blockquote>
<p>The subclasses of the <b>Group</b> class are:</p>
<ul>
	<li>BranchGroup</li>
	<li>OrderedGroup</li>
	<li>Primitive</li>
	<li>SharedGroup</li>
	<li>Switch</li>
	<li><b>TransformGroup</b></li>
	<li>ViewSpecificGroup </li>
</ul>
<p>Several of these classes, in turn, have several different subclasses.&nbsp; 
Thus, there are a fairly large number of types of objects that can be added as 
children to a <b>BranchGroup</b> object.&nbsp; However, in this program, we will 
use only <b>Leaf</b> objects and <b>TransformGroup</b> objects as children of a
<b>BranchGroup</b> object.</p>
<p><font color="#FF0000"><b>The TransformGroup class</b></font></p>
<p>Here is some of what Sun has to say about the <b>TransformGroup</b> class:</p>
<blockquote>
	<p><i>&quot;Group node that contains a <b>transform</b>. The TransformGroup node 
	specifies a single spatial transformation, via a Transform3D object, that 
	can position, orient, and scale all of its children. </i></p>
	<p><i>The specified transformation must be affine. ...&nbsp; </i></p>
	<p><i>The effects of transformations in the scene graph are cumulative. The 
	concatenation of the transformations of each TransformGroup in a direct path 
	from the Locale to a Leaf node defines a composite model transformation (CMT)...&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Contains a transform...</b></font></p>
<p>Although the documentation states that a <b>TransformGroup</b> object <i>
&quot;contains a transform,&quot;</i> it is important to understand that the transform is 
not a child of the object.&nbsp; Rather, the transform is a property of the 
object that is established by calling the <b>setTransform</b> method on the 
object, passing a reference to an object of the type <b>Transform3D</b> as a 
parameter.&nbsp; Thus, there can be only one transform associated with a <b>
TransformGroup</b> object, whereas the object may have many children of the type
<b>Node</b>.</p>
<p><font color="#FF0000"><b>The effects are cumulative...</b></font></p>
<p>What this means is that the effect of the transform contained in a <b>
TransformGroup</b> object will be applied to all objects that are children, 
grand children, great grandchildren, etc. of the <b>TransformGroup</b> object in 
the hierarchy.</p>
<p><font color="#FF0000"><b>A BranchGroup hierarchy</b></font></p>
<p>Figure 7 shows the <b>BranchGroup</b> hierarchy for the program that I will 
present and explain in this lesson.</p>
<p>
 <b><a name="Figure_7">Figure 7</a>. BranchGroup hierarchy for the program named 
	Java3D010. </b>
<table border="1" cols="1" width="477"bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <ul>
		<li>BranchGroup mainBranchGroup<ul>
			<li><i>ColorCube redCube</i></li>
			<li>TransformGroup firstTransGroup <font color="#FF0000"><b>
			(translate)</b></font><ul>
				<li>TransformGroup rotatedGroup <font color="#FF0000"><b>
				(rotate)</b></font><ul>
					<li>TransformGroup plainAxesGroup <b>(scale)</b><ul>
						<li><i>ColorCube xAxis</i></li>
						<li><i>ColorCube yAxis</i></li>
						<li><i>ColorCube zAxis</i></li>
					</ul></li>
					<li>TransformGroup secondTransGroup <font color="#FF0000">
					<b>(translate)</b></font><ul>
						<li>TransformGroup scaledGroup <font color="#FF0000"><b>
						(scale)</b></font><ul>
							<li>TransformGroup blueCubeGroup <b>(rotate)</b><ul>
								<li><i>ColorCube with blue face in front (anonymous object)</i></li>
								<li>TransformGroup blueCubeAxes <b>(scale)</b><ul>
									<li><i>ColorCube xAxis</i></li>
									<li><i>ColorCube yAxis</i></li>
									<li><i>ColorCube zAxis</i></li>
								</ul></li>
							</ul></li>
						</ul></li>
					</ul></li>
				</ul></li>
			</ul></li>
		</ul></li>
		</ul>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Example screen output and user input GUI</b></font></p>
<p>Figure 8 shows an example of the user input GUI and the screen output 
produced by the program.</p>
<p>
 <b><a name="Figure_8">Figure 8</a>. Sample screen output and user input GUI for 
	Java3D010. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a06.jpg" width="471" height="235"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The user input GUI</b></font></p>
<p>The user input GUI on the right side of Figure 8 makes it possible for the 
user to enter parameters to control the behavior of the four transforms that are 
executed in the program:</p>
<ul>
	<li>Translate</li>
	<li>Rotate</li>
	<li>Translate</li>
	<li>Scale</li>
</ul>
<p><font color="#FF0000"><b>The Replot button</b></font></p>
<p>When the user clicks the <b>Replot</b> button at the bottom of the input GUI, 
the program constructs and displays a new 3D universe as shown on the left in 
Figure 8, making use of the user input parameters and the <b>TransformGroup</b> 
hierarchy shown in Figure 7.</p>
<p><font color="#FF0000"><b>Eight leaf objects</b></font></p>
<p>There are eight <b>Leaf</b> objects in the hierarchy and they are all objects 
of the class <b>ColorCube</b>.&nbsp; Those eight objects are highlighted in 
Italics in the hierarchy in Figure 7.&nbsp; They are also clearly visible in the 
universe in Figure 8.</p>
<p>The universe in Figure 8 shows two sets of 3D axes <i>(three objects per set)</i> 
constructed from long skinny <b>ColorCube</b> objects.&nbsp; One set of axes is 
in the upper right portion of the universe image in Figure 8.&nbsp; The other 
set protrudes from inside a large <b>ColorCube</b> object with a blue face on 
the front, a red face on the left side, and a violet face on the top.</p>
<p>The remaining <b>ColorCube</b> object is centered on the origin in 3D space 
with its red face showing.</p>
<p><font color="#FF0000"><b>Transforms highlighted in boldface</b></font></p>
<p>The transforms that are executed by the program are shown as boldface words 
inside parentheses in Figure 7.&nbsp; The four transforms shown in red boldface 
are the transforms over which the user has control via the entry of parameters 
in the input GUI in Figure 8.&nbsp; <i>(These are the transforms listed in the 
leftmost column in the GUI in Figure 8.)</i></p>
<p>The transforms shown in black boldface in Figure 7 have hard-coded parameters 
that are outside the control of the user.&nbsp; For example, the two black
<b>scale</b> transforms near the top and bottom of Figure 7 are used to scale 
the dimensions of <b>ColorCube</b> objects to turn them into long skinny objects 
for use as the 3D axes shown in Figure 8.&nbsp; Similarly, the black <b>rotate</b> 
transform near the middle of Figure 7 is used to rotate a <b>ColorCube</b> 
object so that its blue face will be toward the user when it first appears on 
the screen <i>(perpendicular to the z-axis)</i>.</p>
<p><font color="#FF0000"><b>The redCube object</b></font></p>
<p>The <b>ColorCube</b> object named <b>redCube</b> near the top of Figure 7 is 
positioned above all transforms in the hierarchy.&nbsp; Therefore, it is not 
affected by any of the transforms and it appears at the center of the universe 
in Figure 8 in its natural form.&nbsp; The natural form has it located at the 
origin with the red face perpendicular to the z-axis.</p>
<p><font color="#FF0000"><b>The red translate and rotate transforms</b></font></p>
<p>The red <b>translate</b> and <b>rotate</b> transforms near the top of Figure 
7 correspond to the top two transforms in the list in the leftmost column of the 
input GUI in Figure 8.&nbsp; These two transforms affect the remaining seven <b>
ColorCube</b> objects at the leaves of the hierarchy because all seven of those 
leaf objects belong to <b>TransformGroup</b> objects that are descendants <i>
(children, grand children, etc.)</i> of the group named <b>rotatedGroup</b>.</p>
<p><font color="#FF0000"><b>The topmost black scale transform</b></font></p>
<p>However, the black <b>scale</b> transform shown with the <b>plainAxisGroup</b> 
in Figure 7<b> </b>affects only the three <b>ColorCube</b> objects that are 
children of the <b>plainAxisGroup</b>.&nbsp; This transform is a property of 
that group and none of the other <b>ColorCube</b> objects are children of that 
group.</p>
<p><font color="#FF0000"><b>The red translate and scale transforms</b></font></p>
<p>The red <b>translate</b> and <b>scale</b> transforms near the center of 
Figure 7 correspond to the bottom two transforms in the list in the leftmost 
column of the input GUI in Figure 8.&nbsp; These two transforms affect the 
remaining four <b>ColorCube</b> objects because they are all descendants of the 
group named <b>scaledGroup</b>.&nbsp; However, they don't affect the four <b>
ColorCube</b> objects that appear further up the hierarchy.</p>
<p><font color="#FF0000"><b>Keep these hierarchical relationships in mind</b></font></p>
<p>You should keep these hierarchical relationships in mind later as you run the 
program and experiment with the input parameters that control the behavior of 
the four transforms shown in red boldface in Figure 7.</p>
<p><font color="#FF0000"><b>Enough background, let's see some code</b></font></p>
<p>With that as background material, it's time to examine a program that 
makes it easy to experiment with and hopefully easy to understand how to create 
and to use transforms in Java 3D.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>In this lesson, I will present and explain a Java 3D program named <b>
Java3D010</b>.&nbsp; This program is very similar to the Java 2D program named
<b>Java2D001</b> in the earlier lesson titled &quot;Understanding transforms in Java 
2D&quot; <i>(see <a href="#Resources">Resources</a>)</i>.</p>
<p><font color="#FF0000"><b>Purpose</b></font></p>
<p>The purpose of this program is to make it easy to experiment with the 
following four transforms executed in sequence:</p>
<ul>
	<li>Translate</li>
	<li>Rotate</li>
	<li>Translate</li>
	<li>Scale</li>
</ul>
<p><font color="#FF0000"><b>Operation</b></font></p>
<p>The program creates a user input GUI that can be used to vary the parameters 
used for the sequence of transforms listed above <i>(see Figure 8)</i>.&nbsp; 
Eight ColorCube objects are contained in the universe.&nbsp; </p>
<p>Two of the <b>ColorCube</b> objects are shown in Figure 8 as the red square 
and the red and blue cube.&nbsp; The remaining six <b>ColorCube</b> objects are 
arranged into two sets of three per set.&nbsp; These are long skinny <b>
ColorCube</b> objects that are arranged to simulate two visible sets of 3D axes.</p>
<p>The <b>ColorCube</b> objects are inserted as children of <b>TransformGroup</b> 
objects at different levels of the <b>BranchGroup</b> hierarchy <i>(see Figure 
7)</i>.&nbsp; Because 
they occur at different levels of the hierarchy, the different objects are 
subjected to different transforms depending on their position in the hierarchy.&nbsp; 
Only the cube with the blue face showing and its associated visible axes are 
subjected to all four transforms in the above list.</p>
<p>A <b>Replot</b> button allows the user to modify input parameters, re-compute 
the transforms, and produce a new output by clicking the button.</p>
<p>Clicking the <b>Replot</b> button when one of the input fields contains <b>
String</b> data that cannot be converted to a numeric type will cause the 
program to abort with a <b>NumberFormatException</b>.&nbsp; For example, a blank 
field falls into this category.</p>
<p>The program was tested using Java SE 6, and Java 3D 1.5.0 running under 
Windows XP.</p>
<h2 align="center"><a name="Experimental_Results">Experimental Results</a></h2>
<p><font color="#FF0000"><b>Translate and then rotate</b></font></p>
<p>One of the main purposes of this program is to provide you with a tool for 
experimenting with transforms in Java 3D.&nbsp; I will walk you through a few 
experiments to get you started down that path.&nbsp; Let's begin by taking a look at 
what happens if you reverse the order of rotation and translation.&nbsp; We will begin by translating first 
and then rotating.</p>
<p>Recall from Figure 7 that the universe contains eight <b>ColorCube</b> 
objects.&nbsp; The top left image in Figure 9 shows the result of translating 
seven of those objects by 
the distances and in the directions shown in the top row of input parameter values in the GUI 
to its right.&nbsp; No rotation was applied to those objects at this point.&nbsp; </p>
<p>
 <b><a name="Figure_9">Figure 9</a>. Translation followed by rotation. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a07.jpg" width="470" height="470"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Which objects are affected?</b></font></p>
<p>Referring back to the hierarchy in Figure 7, we see that this translation 
transform affects all of the objects other than the object referred to by <b>redCube</b>.&nbsp; Thus, 
the <b>redCube</b> object remains centered on the origin while all of the other objects are 
translated to the right, up, and forward toward the viewer.</p>
<p><font color="#FF0000"><b>Add a rotation transform</b></font></p>
<p>The bottom left image in Figure 9 shows the result of rotating the seven 
objects by 
the angles and around the axes shown in the second line of parameters in the GUI in the bottom right 
after those seven objects have been translated by the distances and in the 
directions given in the top right GUI.&nbsp; </p>
<p>Prior to this rotation, the axes belonging to each of the seven objects were 
parallel to the corresponding axes belonging to the universe.&nbsp; However, 
once this rotation transform has been executed, the axes belonging to those 
objects are no longer parallel to the axes belonging to the universe.&nbsp; 
Rather, those axes are now aligned with the little stubs protruding from the 
large cube.&nbsp; <i>(Each of these stubs is itself a long skinny <b>ColorCube</b> 
object.)</i></p>
<p>The stub protruding from the blue face represents the new direction for the 
positive z axis belonging to the large cube.&nbsp; The stub protruding from the 
violet face represents the new direction for the positive y axis.&nbsp; The 
other two stubs represent the new directions for the positive and negative x 
axes.</p>
<p><font color="#FF0000"><b>Transform matrices for parameters shown in Figure 9</b></font></p>
<p>Figure 10 shows the transform matrices for the parameters shown in the two 
GUIs in Figure 9.&nbsp; The matrices on the left in Figure 10 correspond to the 
top right GUI in Figure 9.&nbsp; The matrices on the right in Figure 10 correspond 
to the bottom right GUI in Figure 9.</p>



<p><b><a name="Figure_10">Figure 10</a>. Transform matrices for parameters shown 
in Figure 9.</b><table border="1" bgcolor="#ffffff">
	<tr>
		<td><pre>Default xform matrix.
  <b>1.00</b>   0.00   0.00   0.00
  0.00   <b>1.00</b>   0.00   0.00
  0.00   0.00   <b>1.00</b>   0.00
  0.00   0.00   0.00   <b>1.00</b>
Scaling xform matrix
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
secondTransGroup xform matrix
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
Rotation xform matrix
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
firstTransGroup xform matrix
  1.00   0.00   0.00   <b>0.40</b>
  0.00   1.00   0.00   <b>0.50</b>
  0.00   0.00   1.00   <b>0.60</b>
  0.00   0.00   0.00   1.00</pre></td>
		<td><pre>Default xform matrix.
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
Scaling xform matrix
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
secondTransGroup xform matrix
  1.00   0.00   0.00   0.00
  0.00   1.00   0.00   0.00
  0.00   0.00   1.00   0.00
  0.00   0.00   0.00   1.00
Rotation xform matrix
  <b>0.24  -0.91   0.34</b>   0.00
  <b>0.88   0.06  -0.47</b>   0.00
  <b>0.41   0.42   0.81</b>   0.00
  0.00   0.00   0.00   1.00
firstTransGroup xform matrix
  1.00   0.00   0.00   <b>0.40</b>
  0.00   1.00   0.00   <b>0.50</b>
  0.00   0.00   1.00   <b>0.60</b>
  0.00   0.00   0.00   1.00</pre></td>
	</tr>
</table>
</p>


<p><font color="#FF0000"><b>Individual transform matrices</b></font></p>
<p>Note that each matrix shown in Figure 10 is an individual transform matrix.&nbsp; 
The top matrix shown in each group corresponds to the default transform matrix 
that is applied if no other transforms are performed.&nbsp; Each of the 
remaining four matrices in the group corresponds to one of the transforms listed in the user 
input GUI.</p>
<p>The order of the display of the transform matrices in Figure 10 is reversed 
relative to the order of the transforms listed in the GUI in Figure 9.&nbsp; The bottom matrix in a 
group corresponds to the first transform at the top of the GUI.&nbsp; The matrix 
immediately below the default matrix corresponds to the last transform at the 
bottom of the GUI.</p>
<p><font color="#FF0000"><b>The compound transform matrix</b></font></p>
<p>The actual transform that is applied to seven of the <b>ColorCube</b> objects is the product of 
some of 
the matrices in the group.</p>
<p>The interesting values in the matrices in 
Figure 10 are highlighted in boldface.&nbsp; If you scan down the matrices on 
the left in Figure 10, you will see that every matrix except the last one is the 
same as the default matrix at the top.&nbsp; The default matrix is an <i>
identity matrix</i>.&nbsp; The product of two or more identity matrices is another identity matrix.</p>
<p>Only the bottom matrix in the group of matrices on the left in Figure 10 will 
cause the product of the matrices to be different from the identity matrix.&nbsp; In fact, 
since the bottom matrix is the only matrix that is different from an identity 
matrix, the 
product matrix will be identical to the bottom matrix.</p>
<p><font color="#FF0000"><b>The translation values</b></font></p>
<p>The three boldface 
values in the bottom matrix are the translation values: tx, ty, and tz <i>(see Figure 
6)</i>.&nbsp; You will note that these three values match the three parameter 
values for the first translation in the top right GUI in Figure 9.</p>
<p><font color="#FF0000"><b>Add the rotation transform</b></font></p>
<p>The group of matrices on the right in Figure 10 contains two transform 
matrices that differ from the identity matrix.&nbsp; One is the translation 
matrix at the bottom right.&nbsp; It is the same as the translation matrix at 
the bottom left.&nbsp; The other matrix that differs from an identity matrix is the rotation matrix 
that is second from the bottom on the right.</p>
<p>This rotation matrix is actually the product 
of the three individual transform matrices that represent rotation around the x, y, and 
z-axes shown in Figure 6.&nbsp; If you are of a mind to do so, you should be 
able to get the sine and cosine values for the angles involved, enter those 
values into three transform matrices using the matrix formulas shown in Figure 
6, multiply them together, and replicate the values shown in Figure 10.</p>
<p><font color="#FF0000">
 <b>Rotation followed by translation</b></font></p>
<p>Now we will reverse the order of translation and rotation.&nbsp; Figure 11 
shows the result of rotating and translating the seven objects by the same parameter values as in 
Figure 9, but reversing the order.</p>
<p>
 <b><a name="Figure_11">Figure 11</a>. Rotation followed by translation. </b>
<table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a08.jpg" width="472" height="471"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two cubes in the same place</b></font></p>
<p>The top left image in Figure 11 shows the result of applying rotation 
without first applying translation.&nbsp; This image may look strange at first, but it makes 
sense once you think about it.&nbsp; The image in the top left of Figure 11 
shows two cubes of the same size, both 
centered at the origin in 3D space.&nbsp; <i>(There are also six of the long 
skinny <b>ColorCube</b> objects centered on the origin as well.)</i></p>
<p>The cube with the blue face has been 
rotated around all three axes.&nbsp; The cube with the red face has not been 
rotated.&nbsp; Therefore, what we see in this image is the intersection of the 
two cubes.&nbsp; Only the portions of the red cube that protrude outside of the 
blue cube are visible.&nbsp; <i>(There is nothing to prevent two objects from occupying 
exactly the same space in Java 3D.)</i> </p>
<p><font color="#FF0000"><b>Now translate seven of the cubes</b></font></p>
<p>The bottom left image in Figure 11 shows the result of following the rotation 
with translation by the same distances and in the same directions as in Figure 
9.</p>
<p>If you compare the bottom left image in Figure 11 with the bottom left image 
in Figure 9, you will see that they are significantly different.</p>
<p>Translation causes each of the cubes <i>(other than the red cube)</i> to be translated along the axes belonging to 
the cube.&nbsp; Since those axes were pointing in different directions in 
Figures 9 and 11 when the 
translation took place, the cubes ended up in a different 
location in 3D space in each of the two cases.</p>
<p><font color="#FF0000"><b>The transform matrices</b></font></p>
<p>I will leave it as exercise for the student to interpret the transform 
matrices that are displayed on the command line screen.</p>
<p><font color="#FF0000"><b>Translation followed by rotation followed by 
translation and scale</b></font></p>

<p>Figure 12 shows the result of:</p>
<ul>
	<li>Translating the seven cubes</li>
	<li>Rotating the seven cubes</li>
	<li>Translating four of the seven cubes again</li>
	<li>Scaling those four</li>
</ul>
<p>Therefore, Figure 12 illustrates all four of the types of transforms that are 
the topic of this lesson.</p>
<p>
 <b><a name="Figure_12">Figure 12</a>. Translation followed by rotation followed by 
translation and scale.</b><table border="0" cols="1" bgcolor="#ffffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1552a09.jpg" width="471" height="471"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Translate and rotate</b></font></p>
<p>The top left image in Figure 12 shows the result of executing a translation 
followed by a rotation.&nbsp; Recall from Figure 7 that this universe contains 
eight <b>ColorCube</b> objects.&nbsp; One has its red face perpendicular to the 
z-axis, which is the viewpoint of the viewer.&nbsp; Also, recall from Figure 7 
that no transforms are applied to this object.&nbsp; Therefore, it always looks 
like a red square centered on the origin.</p>
<p>The remaining seven <b>ColorCube</b> objects consist of two groups of three, 
which are used to simulate two sets of 3D axes, plus one that is initially 
oriented so that its blue face is perpendicular to the z-axis.</p>
<p><font color="#FF0000"><b>Translation and rotation transforms affect seven of 
the eight objects</b></font></p>
<p>Recall from Figure 7 that the first translation and the rotation affect all 
seven of these <b>ColorCube</b> objects in the same way.&nbsp; As a result, 
following the first translation and rotation, all seven objects are located at 
the same point in 3D space with the same orientation.</p>
<p>At this point, the six <b>ColorCube</b> objects that simulate the 3D axes 
occupy the same space <i>(in pairs)</i> so they are visually indistinguishable 
from one another in pairs.&nbsp; Furthermore, because they are centered on the 
same point as the cube with the blue face, they appear to protrude from the four 
faces of the cube as shown in the top image in Figure 12.</p>
<p><font color="#FF0000"><b>Translate and scale four of the seven objects</b></font></p>
<p>The bottom image in Figure 12 shows the result of applying an additional 
translation along the x-axis followed by a scaling transform that scales along 
the x-dimension.</p>
<p>Referring back to Figure 7, we see that these two transforms affect only four 
of the <b>ColorCube</b> objects.&nbsp; The affected objects are the object with 
the blue face and one set of three objects that are used to simulate a set of 3D 
axes.&nbsp; These four objects are affected in exactly the same way.&nbsp; They 
are translated along the x-axis and then they are scaled along the x-dimension.</p>
<p><font color="#FF0000"><b>Three objects are left behind</b></font></p>
<p>Because one set of three <b>ColorCube</b> objects is not affected by these 
two transforms, those three objects remain in their current location at their 
current size and orientation as shown in the bottom left image in Figure 12.&nbsp;
<i>(These are the three long skinny <b>ColorCube</b> objects in the upper right 
portion of the image.)</i></p>
<p><font color="#FF0000"><b>Four objects are translated</b></font></p>
<p>The other four objects are translated in the direction of their respective 
x-axes.&nbsp; Since all four objects have the same orientation, they are all 
translated by the same distance in the same direction.&nbsp; Thus, they stay 
together and continue to be centered at the same point in 3D space.</p>
<p><font color="#FF0000"><b>A very important point</b></font></p>
<p>It is very important to note that when an object is translated or rotated in 
Java 3D, that translation or rotation takes place relative to the axes belonging 
to that object and do not take place relative to the axes belonging to the 
universe.&nbsp; Thus, an object that has previously been rotated such that its 
axes are not parallel to the axes belonging to the universe will not move 
parallel to the x-axis of the universe when it is translated in the x direction.</p>
<p>In this case, the four <b>ColorCube</b> objects move down, to the left, and 
slightly forward toward the viewer.&nbsp; You will note that the translated long 
skinny <b>ColorCube</b> object that has its maximum dimension in x appears to be 
aligned with the corresponding long skinny <b>ColorCube</b> object that was not 
translated and remains in the upper right portion of the image.&nbsp; This is 
because the x axes belonging to these two objects coincide.&nbsp; They coincide 
because they were earlier translated and rotated in an identical fashion.</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<font color="#FF0000"><b>Will explain in fragments</b></font><p>As is my custom, 
I will present and explain this program in fragments.&nbsp; A complete listing of the 
program is provided in Listing 15. </p>
<p>Before getting into the main body of the program, I will present and explain 
several utility methods that are called throughout the main body of the 
program.&nbsp; The first utility method that I will explain is a method named <b>
translate</b>, which is shown in its entirety in Listing 1.</p>
<p><font color="#FF0000"><b>The method named translate</b></font></p>
<p>This is the method that is called in the main body of the program whenever it 
is necessary to create a <b>TransformGroup</b> object that will translate a 
specific node in addition to all of its other children.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. The method named translate.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to translate that node according to that vector.
    TransformGroup translate(Node node,Vector3f vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setTranslation(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end translate</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A parameter of type node</b></font></p>
<p>This method receives two incoming parameters.&nbsp; The first parameter is a 
reference to an object of the type<b> Node</b>.&nbsp; As we learned earlier, <b>
Node</b> is the superclass of both <b>Leaf</b> and <b>Group</b>.&nbsp; 
Therefore, the first parameter could be a reference either to a visible object 
such as <b>ColorCube</b>, or to another <b>TransformGroup</b> object.</p>
<p><font color="#FF0000"><b>A parameter of type Vector3f</b></font></p>
<p>The second parameter is a reference to an object of type <b>Vector3f</b>.&nbsp; 
This object encapsulates three numeric values of type <b>float</b>, which are 
the desired translation distances along the x, y, and z axes.</p>
<p><font color="#FF0000"><b>The purpose of the method</b></font></p>
<p>The purpose of the method is to create and return a <b>TransformGroup</b> 
object that will translate that node and all of its children <i>(as well as any 
other children that may be added to the group later)</i> according to the distances 
encapsulated in the vector.</p>
<p><font color="#FF0000"><b>A new TransformGroup object</b></font></p>
<p>This method begins by creating a new <b>Transform3D</b> object and setting 
its <b>translation</b> property to the vector object containing the translation 
distances.&nbsp; Then it creates a new <b>TransformGroup</b> object and sets its
<b>transform</b> property to the new <b>Transform3D</b> object.</p>
<p><font color="#FF0000"><b>Two alternatives programming approaches</b></font></p>
<p>One alternative would have been to eliminate the first parameter and simply 
return the new <b>TransformGroup</b> method at this point.&nbsp; If programmed 
that way, the code that called the method could immediately add the node as a 
child to the <b>TransformGroup</b>.</p>
<p>However, I elected to incorporate that step into the method.&nbsp; The 
incoming node object is added as a child to the new <b>TransformGroup</b> object
<i>(by calling the <b>addChild</b> method)</i> and the <b>TransformGroup</b> 
object with the node already added as a child is returned.</p>
<p><font color="#FF0000"><b>The method named scale</b></font></p>
<p>This is the method that is called in the main body of the program whenever it 
is necessary to create a <b>TransformGroup</b> object that will scale a specific 
node in addition to all of its other children.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. The method named scale. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to scale that node according to that vector.
    TransformGroup scale(Node node,Vector3d vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setScale(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end scale</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As is the case with the translate method explained above, this method 
receives a <b>Node</b> parameter and a <b>Vector3f</b> parameter.&nbsp; In this 
case, the purpose is to create and return a <b>TransformGroup</b> object that 
will scale that specific node and all of its children in addition to any other 
children that may also be added as children of the group.</p>
<p>The code in this method is almost identical to the code in the <b>translate</b> 
method.&nbsp; However, that method calls the <b>setTranslation</b> method on the 
new <b>Transform3D</b> object to set its <b>transform</b> property, whereas this 
method calls the <b>setScale</b> method on the new <b>Tarnsform3D</b> object to 
set its <b>scale</b> property.</p>
<p><font color="#FF0000"><b>The method named tiltTheAxes</b></font></p>
<p>The purpose of the method is to create and return a <b>TransformGroup</b> 
object that will cause all of the leaf objects that are descendants of a 
specific node <i>(plus all of the leaf objects that are descendants of any other 
nodes that may later be added as children of <b>TransformGroup</b> object)</i> to be 
rotated around their x, y, and z axes.</p>
<p>Except for a change in the name of one variable, this method is identical to 
a method having the same name that I explained in the lesson titled &quot;Combining 
Rotation and Translation in Java 3d&quot; <i>(see <a href="#Resources">Resources</a>)</i>.&nbsp; 
Therefore, I won't repeat that explanation in this lesson.</p>
<p><font color="#FF0000"><b>The method named displayMatrix</b></font></p>
<p>This method receives an incoming parameter that is a reference to a <b>
Transform3D</b> object and displays the contents of the 4x4 matrix contained in 
that <b>Transform3D</b> object.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. The method named displayMatrix.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    void displayMatrix(Transform3D transform){
      //Retrieve the contents of the matrix into an array.
      // The first four elements of the array contain the
      // first row of the matrix, etc.
      double[] matrixData = new double[16];
      transform.get(matrixData);
      
      for(int outCnt = 0;outCnt &lt; 16;outCnt += 4){
        for(int cnt = 0;cnt &lt; 4;cnt++){
          System.out.printf(
                       &quot;%6.2f ",matrixData[cnt + outCnt]);
        }//end inner loop
        System.out.println();
      }//end outer loop
    }//end displayMatrix</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in this method is very straightforward.&nbsp; The comments in 
Listing 3 should suffice as an explanation.</p>
<p><font color="#FF0000"><b>The method named getAxesGroup</b></font></p>
<p>This is a convenience method that constructs and returns a <b>TransformGroup</b> object containing a set of what look like three orthogonal axes.&nbsp;
<i>(See the upper right portion of the bottom left image in Figure 12.)</i>&nbsp; Each of the three individual axes is constructed from a long skinny
<b>ColorCube</b> object.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. The method named getAxesGroup.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    TransformGroup getAxesGroup(){
      ColorCube xAxis = new ColorCube();
      //Scale the ColorCube to make it long and skinny
      // in the x dimension.
      TransformGroup xGroup = <b>scale</b>(
                          xAxis,
                          new Vector3d(0.25,0.01,0.01));
      
      ColorCube yAxis = new ColorCube();
      TransformGroup yGroup = <b>scale</b>(
                          yAxis,
                          new Vector3d(0.01,0.25,0.01));
                          
      ColorCube zAxis = new ColorCube();
      TransformGroup zGroup = <b>scale</b>(
                          zAxis,
                          new Vector3d(0.01,0.01,0.25));
                          
      TransformGroup axesGroup = new TransformGroup();
      axesGroup.addChild(xGroup);
      axesGroup.addChild(yGroup);
      axesGroup.addChild(zGroup);
                          
      return axesGroup;
    }//end getAxesGroup</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in this method is straightforward and shouldn't require any 
explanation beyond the embedded comments.</p>
<p><font color="#FF0000"><b>Beginning of the class named Java3D010 </b></font></p>
<p>As I mentioned earlier, a complete listing of the program is provided in 
Listing 15.&nbsp; All of the code down to the beginning of the constructor for 
the class named <b>Scene</b> is totally straightforward.&nbsp; That code deals 
with creating the GUI, servicing the <b>Replot</b> button, etc.</p>
<p><font color="#FF0000">
<b>Beginning of the constructor for the class named Scene</b></font></p>
<p>The <b>Scene</b> class is an inner class from which the universe is 
instantiated.&nbsp; One of the functions of the <b>Replot</b> button is to 
dispose of the old <b>Scene</b> object and to create a new <b>Scene</b> object.&nbsp; 
When the new <b>Scene</b> object is created, it will be created according to the 
transform parameter values that have been entered by the user into the GUI shown 
on the right in Figure 8.</p>
<p>The constructor for the <b>Scene</b> class begins in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. Beginning of the constructor for the class 
named Scene.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    Scene(){//constructor
    
      //Create a temporary TransformGroup object.
      System.out.println("\nDefault xform matrix.");
      TransformGroup tempXformGroup = 
                                     new TransformGroup();
      Transform3D tempXform = new Transform3D();
      tempXformGroup.getTransform(tempXform);
      displayMatrix(tempXform);

      //Construct the universe.
      createACanvas();
      createTheUniverse();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A temporary TransformGroup object</b></font></p>
<p>Listing 5 begins by creating a temporary <b>TransformGroup</b> object for the sole purpose of displaying the default transform matrix that is contained in a new TransformGroup object.&nbsp; 
The default transform matrix is the identity shown at the top left of Figure 10.</p>
<p><font color="#FF0000"><b>The big bang!</b></font></p>
<p>Then the code in Listing 5 calls the following two methods to create the 
universe:</p>
<ul>
	<li>createACanvas</li>
	<li>createTheUniverse</li>
</ul>
<p>The code in these two methods is similar or identical to code that I have 
explained in earlier lessons on Java 3D so I won't repeat that explanation in 
this lesson.</p>
<p><font color="#FF0000">
<b>Create and prepare two ColorCube objects</b></font></p>
<p>Listing 6 creates the two different <b>ColorCube</b> objects shown in Figure 8.&nbsp; 
One of them is rotated around its vertical axes so that its blue face is 
perpendicular to the z axis.&nbsp; This object is added as a child to the <b>
TransformGroup</b> named <b>blueCubeGroup</b>.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Create and prepare two ColorCube objects. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //The following ColorCube displays its red face
      // without being rotated.
      ColorCube redCube = new ColorCube(0.125f);

      //Create a cube and rotate it to cause it to display
      // its blue face.
      TransformGroup blueCubeGroup =
                        tiltTheAxes(new ColorCube(0.125f),
                        0.0d,//x-axis
                        3*Math.PI/2.0d,//y-axis
                        0.0d);//z-axis</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Add visible axes to the blueCubeGroup</b></font></p>
<p>Listing 7 calls the <b>getAxesGroup</b> method to get a set of visible axes
<i>(constructed from long skinny ColorCube objects).&nbsp; </i>They are added as 
children to the <b>blueCubeGroup</b>, producing the blue cube with the 
protruding axes shown in Figure 8.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Add visible axes to the blueCubeGroup. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      TransformGroup blueCubeAxes = getAxesGroup();
      blueCubeGroup.addChild(blueCubeAxes);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Construct the transform hierarchy</b></font></p>
<p>We have now eaten our way through the appetizers and it's time for the main 
course.&nbsp; The code that follows constructs the hierarchy of <b>Leaf</b> and
<b>TransformGroup</b> objects.</p>
<p>The transforms in the hierarchy are constructed using the parameter values 
entered by the user in the GUI shown in Figure 8.&nbsp; Note that this code 
constructs the hierarchy from the leaves toward the root.&nbsp; This is the 
reverse of the order in which the transforms are listed in the GUI.</p>
<p><font color="#FF0000"><b>Create and display a scaling transform</b></font></p>
<p>Listing 8 creates a scaling transform that will be applied to the <b>
blueCubeGroup</b>.&nbsp; According to the hierarchy in Figure 7, the <b>
blueCubeGroup</b> includes the blue cube <i>(anonymous <b>ColorCube</b> with the 
blue face in front)</i> and the <b>blueCubeAxes</b>.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Create and display a scaling transform.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      TransformGroup scaledGroup = scale(
                                  blueCubeGroup,
                                  new Vector3d(sx,sy,sz));

      //Display the scaling transform matrix.
      System.out.println("Scaling xform matrix");
      scaledGroup.getTransform(tempXform);
      displayMatrix(tempXform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 8 displays the scaling transform matrix.</p>
<p><font color="#FF0000"><b>Create and display a translation transform</b></font></p>
<p>Listing 9 creates and displays a translation transform.&nbsp; <i>(This is the 
translation transform that is listed near the bottom of the GUI in Figure 8.)</i>&nbsp; 
This transform will be applied to the <b>scaledGroup</b>.&nbsp; According to the 
hierarchy in Figure 7, the <b>
scaledGroup</b> contains the <b>blueCubeGroup</b>, which in turn contains the 
<i>blue cube</i> and the <b>blueCubeAxes</b>.&nbsp; Only the <i>blue cube</i> and <b>
blueCubeAxes</b> will be affected by this transform.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Create and display a translation 
transform.</b><table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      TransformGroup secondTransGroup = translate(
                               scaledGroup,
                               new Vector3f(tx2,ty2,tz2));
                          
      //Display the secondTransGroup transform matrix.
      System.out.println("secondTransGroup xform matrix");
      secondTransGroup.getTransform(tempXform);
      displayMatrix(tempXform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that the <i>blue cube</i> will be translated in a direction indicated by the 
corresponding axes belonging to the <b>blueCubeGroup</b>, even if the axes 
belonging to the <b>blueCubeGroup</b> have been rotated.</p>
<p><font color="#FF0000">
<b>Create and display a rotation transform</b></font></p>
<p>Listing 10 creates a rotation transform that will be applied to the
<b>secondTransGroup</b>.&nbsp; According to the hierarchy in Figure 7, the <b>
secondTransGroup</b> contains the <b>scaledGroup</b>, which in turn contains the
<b>blueCubeGroup</b>.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Create and display a rotation transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      TransformGroup rotatedGroup = 
                             tiltTheAxes(secondTransGroup,
                             xAngle,//x-axis
                             yAngle,//y-axis
                             zAngle);//z-axis
                    
      //Display the rotation transform matrix.
      System.out.println("Rotation xform matrix");
      rotatedGroup.getTransform(tempXform);
      displayMatrix(tempXform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Will also apply rotation to a new set of axes</b></font></p>
<p>As you will see in Listing 11, the rotation transform will also be applied to 
a new set of simulated axes named <b>plainAxesGroup</b>.&nbsp; The purpose of 
adding <b>plainAxesGroup</b> at this point is to show the location and 
orientation of the <i>blue cube</i> immediately before the final translation is 
executed.&nbsp; <i>(See Figure 8.)</i>&nbsp; The <i>blue cube</i>, <b>blueCubeAxes</b>, 
and <b>plainAxesGroup</b> will all be rotated.&nbsp; Rotation takes place around 
the local axis <i>(rather than the axes belonging to the universe)</i>, even if 
the cube has been translated away from the origin.</p>
<p><font color="#FF0000">
<b>Create and add another set of axes</b></font></p>
<p>Listing 11 creates the <b>plainAxesGroup</b> and adds it to the <b>rotatedGroup</b> for 
the purpose described above.</p>

<p>
<b><a name="Listing_11">Listing 11</a>. Create and add another set of axes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Create and add the plainAxesGroup to the
      // rotatedGroup.
      TransformGroup plainAxesGroup = getAxesGroup();
      rotatedGroup.addChild(plainAxesGroup);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Create and display another translation transform</b></font></p>
<p>Listing 12 creates and displays the translation transform shown at the top of the 
GUI in Figure 8.&nbsp; This translation will be applied the <b>rotatedGroup</b>.&nbsp; 
According to the hierarchy in Figure 7, the <b>rotatedGroup</b> contains the <b>
plainAxesGroup</b> and the <b>secondTransGroup</b>, which in turn contains the 
<b>scaledGroup</b>.&nbsp; The <b>scaledGroup</b> contains the <b>blueCubeGroup</b>.&nbsp; Thus, the 
<b>plainAxesGroup</b>, the <i>blue cube</i>, and <b>blueCubeAxes</b> will all 
be translated by this transform.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Create and display another translation 
transform. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      TransformGroup firstTransGroup = translate(
                               rotatedGroup,
                               new Vector3f(tx1,ty1,tz1));
                          
      //Display the firstTransGroup transform matrix.
      System.out.println("firstTransGroup xform matrix");
      firstTransGroup.getTransform(tempXform);
      displayMatrix(tempXform);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Complete the hierarchy</b></font></p>
<p>Listing 13 completes the hierarchy by adding the <b>firstTransGroup</b> to 
the <b>mainBranchGroup</b>.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Complete the hierarchy. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Construct the main group.
      mainBranchGroup.addChild(firstTransGroup);
      //Add the redCube to mark the origin. None of the
      // transforms are applied to the redCube.
      mainBranchGroup.addChild(redCube);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Finally, the code in Listing 13 adds a <b>ColorCube</b> object with the red 
face exposed as a child of the <b>BranchGroup</b> object.&nbsp; This cube is not 
subjected to any of the transforms.&nbsp; Therefore, it is centered on the 
origin of the universe when the universe is rendered, marking the location of 
the origin.</p>
<p><font color="#FF0000">
<b>Complete the constructor and the classes</b></font></p>
<p>Listing 14 completes the constructor for the <b>Scene</b> class.&nbsp; It 
also signals the end of the <b>Scene</b> class and the class named <b>Java3D010</b>.&nbsp; 
Hence, Listing 14 is the end of the program.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Complete the constructor and the 
classes. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(mainBranchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
    
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//

  }//end inner class Scene

}//end class Java3D010</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to compile and execute the code from Listing 15.&nbsp; Experiment 
with the code, making changes, and observing the results of your changes.</p>
<p>Remember, you will need to download and install the Java 3D API plus either 
Microsoft DirectX or OpenGL to compile and execute these programs.&nbsp; See
<a href="#Download">Download</a> for links to the web sites from which this 
material can be downloaded. </p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, you learned to understand transforms in Java 3D and how to write Java 3D code that makes use of that understanding.</p>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>The topics for future lessons include interactive Java 3D programs, advanced 
animation, and surfaces.</p>
<h2 align="center"><a name="Download">Download</a></h2>
<ul>
	<li>
	<a href="http://java.sun.com/developer/onlineTraining/java3d/javaa3d.zip">
	Getting Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by 
	Dennis J Bouvier</li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/collateral/examples.zip">
	Source code</a> for example programs from the Bouvier tutorial above</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Version 1.5.0</a> of the Java 3D API</li>
	<li><a href="http://java.sun.com/products/java-media/3D/download.html">
	Implementation documentation</a> for version 1.5.0 of the Java 3D API</li>
	<li>
	<a href="http://www.gamesforwindows.com/en-US/AboutGFW/Pages/DirectX10.aspx">
	Microsoft DirectX10</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
</ul>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li><a href="http://www.dickbaldwin.com/toc.htm">Dick Baldwin's tutorial web 
	site</a></li>
	<li><a href="http://java.sun.com/products/java-media/3D/">Main page</a> for 
	the Java 3D AP</li>
	<li>Java 3D <a href="http://wiki.java.net/bin/view/Javadesktop/Java3DFAQ">
	FAQ</a></li>
	<li>
	<a href="http://java.sun.com/products/java-media/3D/reference/api/index.html">
	Online documentation</a> for Java 3D version 1.3 <i>(see Download above for 
	v1.5.0 documentation)</i></li>
	<li><a href="http://java.sun.com/developer/onlineTraining/java3d/">Getting 
	Started with the Java 3D&#8482; API</a>, A Tutorial for Beginners by Dennis J 
	Bouvier</li>
	<li>
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/javax/media/j3d/doc-files/intro.html">
	Introduction to the Java 3D API</a> with links to other tutorial information</li>
	<li>Various Java 3D <a href="http://www.java3d.org/">resources</a></li>
	<li>Another Java 3D <a href="http://www.java3d.org/tutorial.html">tutorial</a></li>
	<li><a href="http://www.ia.hiof.no/~borres/cgraph/math/twod/p-twod.html">
	Planar transformations</a></li>
	<li>
	<a href="http://www.ia.hiof.no/~borres/cgraph/math/threed/p-threed.html">
	Spatial transformations</a></li>
	<li>
	<a href="http://www.ia.hiof.no/~borres/cgraph/math/algebra/p-algebra.html">A 
	little algebra</a></li>
	<li><a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">
	Cartesian coordinate system</a>, Wikipedia</li>
	<li><a href="#Resources">Orthogonality</a>, Wikipedia</li>
	<li><a href="http://en.wikipedia.org/wiki/Trigonometry">Trigonometry</a>, 
	Wikipedia</li>
	<li><a href="http://en.wikipedia.org/wiki/Vector">Vector</a>, Wikipedia</li>
	<li>
	<a href="http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Tech/Chapter05/formatterPrintf.html">
	System.out.printf() - J2SE5.0</a></li>
	<li>
	<a href="http://www.dickbaldwin.com/tocalice.htm">Learn to Program using 
	Alice</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/626051">306</a> 
	Java 2D Graphics, Simple Affine Transforms&nbsp;</li>
	<li>
	<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
	1468</a> Plotting Engineering and Scientific Data using Java</li>
	<li>
	<a href="http://www.developer.com/java/other/article.php/3673761">1516</a> 
	Introduction to Alice Programming</li>
	<li><a href="http://www.developer.com/java/other/article.php/3622246">1540</a> 
	Understanding Lighting in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3701536">1541</a> 
	Back to Basics in the Java 3D API</li>
	<li><a href="http://www.developer.com/java/article.php/3704116">1542</a> 
	Digging a Little Deeper into the Java 3D API</li>
	<li><a href="http://www.developer.com/java/data/article.php/3706721">1544</a> 
	Simple Animation with the Java 3D API</li>
	<li><a href="http://www.developer.com/java/other/article.php/3709341">1546</a> 
	Understanding the Alpha Time-Base Class in Java 3D</li>
	<li><a href="http://www.developer.com/java/other/article.php/3712226">1548</a> Combining Rotation and Translation in Java 3d</li>
	<li><a href="http://www.developer.com/java/other/article.php/3714626">1550</a> Understanding Transforms in Java 2D</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program discussed in this lesson is presented in
Listing 15 below.
<p>
<b><a name="Listing_15">Listing 15</a>. Listing for the program named Java3D010. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File Java3D010.java
Copyright 2007, R.G.Baldwin

This program is very similar to the Java2D program named
 Java2D001.
 
The purpose of this program is to make it easy to
experiment with the following four transforms executed
in sequence:

translate
rotate
another translate
scale

The program creates a user input GUI that can be used to 
vary the parameters used for the sequence of transforms

Two ColorCube objects and two sets of three long skinny 
ColorCube objects arranged to simulate a visible set of
3D axes are added as children at different levels of the 
branch group hierarchy. The different objects are 
subjected to different transforms depending on their 
position in the hierarchy.  Only the cube with the blue 
face showing and its associated visible axes are subjected
to all four transforms in the above list.

A Replot button allows the user to modify input 
parameters, recompute the transforms, and produce a new
output by clicking the button.  Clicking the Replot button
when one of the input fields contains String data that
can't be converted to a numeric type will cause the
program to abort with a NumberFormatException.  For 
example, a blank field falls in this category.

Tested using Java SE 6, and Java 3D 1.5.0 running under
Windows XP.
*********************************************************/
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.geometry.ColorCube;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.Node;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector3d;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.Label;
import java.awt.TextField;
import java.awt.Button;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

//This is the top-level driver class for this program.
public class Java3D010 extends Frame{
  Scene scene = new Scene();
  
  TextField sxTxt = new TextField("1.0");
  TextField syTxt = new TextField("1.0");
  TextField szTxt = new TextField("1.0");
  
  TextField tx2Txt = new TextField("0.0");
  TextField ty2Txt = new TextField("0.0");
  TextField tz2Txt = new TextField("0.0");
  
  TextField xAngleTxt = new TextField("0.0");
  TextField yAngleTxt = new TextField("0.0");
  TextField zAngleTxt = new TextField("0.0");
  
  TextField tx1Txt = new TextField("0.0");
  TextField ty1Txt = new TextField("0.0");
  TextField tz1Txt = new TextField("0.0");
  
  //These instance variables are accessed by the
  // constructor for a Scene object when it is
  // instantiated. They are defined in this enclosing
  // class rather than in the Scene class because they
  // need to be set before the constructor for the Scene
  // object is called.
  
  //Scaling parameters.
  double sx = 1.5; //scale X
  double sy = 1.0; //scale Y
  double sz = 1.0; //scale Z
  
  //Translation parameters for first translation.
  float tx1 = 0.7f; //translate X
  float ty1 = 0.0f; //translate Y
  float tz1 = 0.0f; //translate Z

  //Rotation parameters.
  double xAngle = 0.0;//rotate around X
  double yAngle = 0.0;//rotate around Y
  double zAngle = Math.PI/4.0d;//rotate around z
  
  //Translation parameters for second translation.
  float tx2 = 0.3f;//translate X again
  float ty2 = 0.0f;//translate Y again
  float tz2 = 0.0f;//translate Z again
  //----------------------------------------------------//
  
  public static void main(String[] args){
    Java3D010 thisObj = new Java3D010();
  }//end main
  //----------------------------------------------------//
  
  public Java3D010(){//top-level constructor
    setTitle("Copyright 2007, R.G.Baldwin");
    setBounds(236,0,235,235);
    
    //Construct the user input panel and add it to the
    // CENTER of the Frame. Arrange the fields from top to
    // bottom in the order that the transforms are
    // actually executed.
    Panel inputPanel = new Panel();
    inputPanel.setLayout(new GridLayout(0,4));
    
    inputPanel.add(new Label("Xform",Label.CENTER));
    inputPanel.add(new Label("X",Label.CENTER));
    inputPanel.add(new Label("Y",Label.CENTER));
    inputPanel.add(new Label("Z",Label.CENTER));
    
    //Input data for the first translation.
    inputPanel.add(new TextField("Trans"));
    inputPanel.add(tx1Txt);
    inputPanel.add(ty1Txt);
    inputPanel.add(tz1Txt);
    
    //Input data for the rotation.
    inputPanel.add(new TextField("Rot (deg)"));
    inputPanel.add(xAngleTxt);
    inputPanel.add(yAngleTxt);
    inputPanel.add(zAngleTxt);
    
    //Input data for the second translation.
    inputPanel.add(new TextField("Trans"));
    inputPanel.add(tx2Txt);
    inputPanel.add(ty2Txt);
    inputPanel.add(tz2Txt);
    
    //Input scaling data.
    inputPanel.add(new TextField("Scale"));
    inputPanel.add(sxTxt);
    inputPanel.add(syTxt);
    inputPanel.add(szTxt);
    
    add(inputPanel,BorderLayout.CENTER);


    //Add a button that allows the user to change the
    // input parameter values, recompute the transforms,
    // and replot the cube.
    Button button = new Button("Replot");
    button.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          
          //Get user input values from the text fields,
          // convert them to numeric types, and store them
          // in instance variables that are accessible to
          // the constructor for the Scene object.  Note
          // that the parse methods will cause the program
          // to abort with a NumberFormatException if a
          // field contains a string that cannot be
          // converted to the appropriate numeric type
          // (including an empty string caused by a blank
          // field).
          
          //Data for the first translation.
          tx1 = Float.parseFloat(tx1Txt.getText());
          ty1 = Float.parseFloat(ty1Txt.getText());
          tz1 = Float.parseFloat(tz1Txt.getText());

          //Data for the rotation.  Convert the rotation
          // angles from degrees to radians.
          xAngle = (Double.parseDouble(
                    xAngleTxt.getText()) * Math.PI/180.0);
          yAngle = (Double.parseDouble(
                    yAngleTxt.getText()) * Math.PI/180.0);
          zAngle = (Double.parseDouble(
                    zAngleTxt.getText()) * Math.PI/180.0);
          
          //Data for the second translation.
          tx2 = Float.parseFloat(tx2Txt.getText());
          ty2 = Float.parseFloat(ty2Txt.getText());
          tz2 = Float.parseFloat(tz2Txt.getText());

          //Scaling data
          sx = Double.parseDouble(sxTxt.getText());
          sy = Double.parseDouble(syTxt.getText());
          sz = Double.parseDouble(szTxt.getText());
  
          //Instantiate a new Scene object.  Dispose of
          // the old object to conserve resources.
          // Otherwise the program aborts after clicking
          // the Replot button 32 times with a message
          // regarding a limit on the number of allowable
          // Canvas objects that can be rendered.
          scene.dispose();
          scene = new Scene();
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    
    //Finish constructing the GUI.
    add(button,BorderLayout.SOUTH);

    setVisible(true);

    //This window listener is used to terminate the
    // program when the user clicks the X button.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener

  }//end constructor
  //----------------------------------------------------//

  //This is an inner class, from which the universe will
  // be  instantiated.
  class Scene extends Frame{
    
    //Declare instance variables that are used later by
    // the program.
    Canvas3D canvas3D;
    SimpleUniverse simpleUniverse;
    BranchGroup mainBranchGroup = new BranchGroup();
    //--------------------------------------------------//

    Scene(){//constructor
    
      //Create a temporary TransformGroup object for the
      // sole purpose of displaying the default transform
      // matrix that is contained in a new TransformGroup
      // object.
      System.out.println("\nDefault xform matrix.");
      TransformGroup tempXformGroup = 
                                     new TransformGroup();
      Transform3D tempXform = new Transform3D();
      tempXformGroup.getTransform(tempXform);
      displayMatrix(tempXform);

      //Construct the universe.
      createACanvas();
      createTheUniverse();

      //Create two different ColorCube objects.  Rotate
      // one of them around its vertical axes so that it
      // will display its blue face.  The names given to
      // the cubes are based on the color of the face that
      // is displayed on the front following this
      // rotation transform.
      
      //The following ColorCube displays its red face
      // without being rotated.
      ColorCube redCube = new ColorCube(0.125f);

      //Create a cube and rotate it to cause it to display
      // its blue face.
      TransformGroup blueCubeGroup =
                        tiltTheAxes(new ColorCube(0.125f),
                        0.0d,//x-axis
                        3*Math.PI/2.0d,//y-axis
                        0.0d);//z-axis
                    
      //Add a set of axes to the blueCubeGroup .
      TransformGroup blueCubeAxes = getAxesGroup();
      blueCubeGroup.addChild(blueCubeAxes);
      
      //Now perform a series of transforms based on the
      // user input data.  Note that this code constructs
      // the branch group hierarchy from the leaves toward
      // the root.
      

      //Create a scaling transform, which will be applied
      // to the blueCubeGroup.  The blueCubeGroup includes
      // the blue cube and the blueCubeAxes.
      TransformGroup scaledGroup = scale(
                                  blueCubeGroup,
                                  new Vector3d(sx,sy,sz));

      //Display the scaling transform matrix.
      System.out.println("Scaling xform matrix");
      scaledGroup.getTransform(tempXform);
      displayMatrix(tempXform);
                          

      //Create a translation transform, which will be
      // applied to the scaledGroup.  The scaledGroup
      // contains the blueCubeGroup, which in turn
      // contains the blue cube and the blueCubeAxes.
      // Only the blue cube and blueCubeAxes will be
      // affected by this transform.
      //Note that the blue cube is translated in a
      // direction indicated by the corresponding axes
      // belonging to the blueCubeGroup, even if the axes
      // belonging to the blueCubeGroup have been rotated.
      TransformGroup secondTransGroup = translate(
                               scaledGroup,
                               new Vector3f(tx2,ty2,tz2));
                          
      //Display the secondTransGroup transform matrix.
      System.out.println("secondTransGroup xform matrix");
      secondTransGroup.getTransform(tempXform);
      displayMatrix(tempXform);
                          

      //Create a rotation transform, which will be applied
      // to the secondTransGroup.  The secondTransGroup
      // contains the scaledGroup, which in turn contains
      // the blueCubeGroup. The transform
      // will also be applied to a new set of axes named
      // plainAxesGroup.
      //The purpose of adding plainAxesGroup at this point
      // is to show the location and orientation of the
      // blue cube immediately before the final
      // translation is executed.

      //The blue cube, blueCubeAxes, and plainAxesGroup
      // will all be rotated.  Rotation takes place around
      // the local axis (rather than the 3D-space axes),
      // even if the cube has been translated away from
      // the origin.
      TransformGroup rotatedGroup = 
                             tiltTheAxes(secondTransGroup,
                             xAngle,//x-axis
                             yAngle,//y-axis
                             zAngle);//z-axis
                    
      //Display the rotation transform matrix.
      System.out.println("Rotation xform matrix");
      rotatedGroup.getTransform(tempXform);
      displayMatrix(tempXform);

      //Create and add the plainAxesGroup to the
      // rotatedGroup.
      TransformGroup plainAxesGroup = getAxesGroup();
      rotatedGroup.addChild(plainAxesGroup);
      
      
      //Create the first translation transform, which will
      // be applied the rotatedGroup.  The rotatedGroup
      // contains the plainAxesGroup and the
      // secondTransGroup, which in turn contains the
      // scaledGroup. The scaledGroup contains the 
      // blueCubeGroup. Thus, the
      // plainAxesGroup, the blue cube, and blueCubeAxes
      // will all be translated by this transform.
      TransformGroup firstTransGroup = translate(
                               rotatedGroup,
                               new Vector3f(tx1,ty1,tz1));
                          
      //Display the firstTransGroup transform matrix.
      System.out.println("firstTransGroup xform matrix");
      firstTransGroup.getTransform(tempXform);
      displayMatrix(tempXform);
      

      //Construct the main group.
      mainBranchGroup.addChild(firstTransGroup);
      //Add the redCube to mark the origin. None of the
      // transforms are applied to the redCube.
      mainBranchGroup.addChild(redCube);
      
      
      //Populate the universe by adding the branch group
      // that contains the objects.
      simpleUniverse.addBranchGraph(mainBranchGroup);
      
      //Do the normal GUI stuff.
      setTitle("Copyright 2007, R.G.Baldwin");
      setBounds(0,0,235,235);
      setVisible(true);
    
      //This listener is used to terminate the program 
      // when the user clicks the X-button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(WindowEvent e){
            System.exit(0);
          }//end windowClosing
        }//end new WindowAdapter
      );//end addWindowListener
      
    }//end constructor
    //--------------------------------------------------//
    
    //Create a Canvas3D object to be used for rendering
    // the Java 3D universe.  Place it in the CENTER of
    // the Frame.
    void createACanvas(){
      canvas3D = new Canvas3D(
              SimpleUniverse.getPreferredConfiguration());
      add(BorderLayout.CENTER,canvas3D);
    }//end createACanvas
    //--------------------------------------------------//
    
    //Create an empty Java 3D universe and associate it 
    // with the Canvas3D object in the CENTER of the
    // frame.  Also specify the apparent location of the
    // viewer's eye.
    void createTheUniverse(){
      simpleUniverse = new SimpleUniverse(canvas3D);
      simpleUniverse.getViewingPlatform().
                             setNominalViewingTransform();
    }//end createTheUniverse
    //--------------------------------------------------//
    
    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to translate that node according to that vector.
    TransformGroup translate(Node node,Vector3f vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setTranslation(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end translate
    //--------------------------------------------------//
    
    //Given an incoming node object and a vector object,
    // this method will return a transform group designed
    // to scale that node according to that vector.
    TransformGroup scale(Node node,Vector3d vector){
      
        Transform3D transform3D = new Transform3D();
        transform3D.setScale(vector);
        TransformGroup transformGroup = 
                                     new TransformGroup();
        transformGroup.setTransform(transform3D);

        transformGroup.addChild(node);
        return transformGroup;
    }//end scale
    //--------------------------------------------------//
    
    //The purpose of this method is to create and return
    // a transform group designed to perform a counter-
    // clockwise rotation about the x, y, and z axes 
    // belonging to an incoming node.  The three incoming
    // angle values must be specified in radians. Don't
    // confuse this with a RotationInterpolator.  This is
    // not an interpolation operation.  Rather, it is a
    // one-time transform.
    TransformGroup tiltTheAxes(Node node,
                               double xAngle,
                               double yAngle,
                               double zAngle){

      Transform3D tiltAxisXform = new Transform3D();
      Transform3D tempTiltAxisXform = new Transform3D();
      
      //Construct and then multiply two rotation transform
      // matrices.
      tiltAxisXform.rotX(xAngle);
      tempTiltAxisXform.rotY(yAngle);
      tiltAxisXform.mul(tempTiltAxisXform);
      
      //Construct the third rotation transform matrix and
      // multiply it by the result of previously 
      // multiplying the two earlier matrices.
      tempTiltAxisXform.rotZ(zAngle);
      tiltAxisXform.mul(tempTiltAxisXform);


      TransformGroup rotatedGroup = new TransformGroup(
                                           tiltAxisXform);
      rotatedGroup.addChild(node);
      
      return rotatedGroup;
    }//end tiltTheAxes
    //--------------------------------------------------//
    
    //This method displays the contents of the 4x4 matrix
    // contained in a Transform3D object.
    void displayMatrix(Transform3D transform){
      //Retrieve the contents of the matrix into an array.
      // The first four elements of the array contain the
      // first row of the matrix, etc.
      double[] matrixData = new double[16];
      transform.get(matrixData);
      
      for(int outCnt = 0;outCnt &lt; 16;outCnt += 4){
        for(int cnt = 0;cnt &lt; 4;cnt++){
          System.out.printf(
                       &quot;%6.2f ",matrixData[cnt + outCnt]);
        }//end inner loop
        System.out.println();
      }//end outer loop
    }//end displayMatrix
    //--------------------------------------------------//
    
    //This method constructs and returns a TransformGroup
    // object containing a set of what look like three
    // orthogonal axes.  Each of the three individual axes
    // is constructed from a long skinny ColorCube
    // object.    
    TransformGroup getAxesGroup(){
      ColorCube xAxis = new ColorCube();
      TransformGroup xGroup = scale(
                          xAxis,
                          new Vector3d(0.25,0.01,0.01));
      
      ColorCube yAxis = new ColorCube();
      TransformGroup yGroup = scale(
                          yAxis,
                          new Vector3d(0.01,0.25,0.01));
                          
      ColorCube zAxis = new ColorCube();
      TransformGroup zGroup = scale(
                          zAxis,
                          new Vector3d(0.01,0.01,0.25));
                          
      TransformGroup axesGroup = new TransformGroup();
      axesGroup.addChild(xGroup);
      axesGroup.addChild(yGroup);
      axesGroup.addChild(zGroup);
                          
      return axesGroup;
    }//end getAxesGroup
    //--------------------------------------------------//

  }//end inner class Scene

}//end class Java3D010</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2007, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java &quot;java 3D&quot; &quot;Java 2D&quot; canvas scale translate shear rotate transform</p>
<p>-end- </p>
</body>
</html>
