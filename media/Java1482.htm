<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the 
FFT Algorithm</h2>
    <i>Baldwin explains several different programs used for spectral analysis.&nbsp; 
He also explains the impact of the sampling frequency and the Nyquist folding 
frequency on spectral analysis.</i><p><b>Published:</b>&nbsp; July 6, 2004 <br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 1482</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a>
  <ul>
  <li><a href="#Sampling_Frequency_and_Nyquist_Folding_Frequency">Sampling 
	Frequency and Nyquist Folding Frequency</a></li>
	<li><a href="#Spectral_Analysis_using_a_DFT_Algorithm">Spectral Analysis 
	using a DFT Algorithm</a></li>
	<li><a href="#Spectral_Analysis_using_an_FFT_Algorithm">Spectral Analysis 
	using an FFT Algorithm</a></li>
  </ul>
  <li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#Whats_Next">What's Next?</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a>
  </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
  <p><font color="#FF0000"><b>The how and the why of spectral analysis</b></font></p>
<p>A previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3374611">Fun with Java, 
How and Why Spectral Analysis Works</a> explained how and why spectral 
analysis works.&nbsp; An understanding of that lesson is a prerequisite to 
	understanding this lesson.</p>
<p><font color="#FF0000"><b>Programs to perform spectral analysis</b></font></p>
<p>In this lesson I will provide and explain different programs used for performing spectral analysis.&nbsp; The first program 
is a very general program that implements a Discrete Fourier Transform <i>(DFT)</i> 
algorithm.<i>&nbsp; </i>I will explain this program in detail.</p>
<p>The second program is a less general, but much faster 
program that implements a Fast Fourier Transform <i>(FFT)</i> algorithm.&nbsp; I 
will defer an explanation of this program until a future lesson.&nbsp; I am 
providing it here so that you can use it and compare it with the DFT program in 
terms of speed and flexibility.</p>
<p><font color="#FF0000"><b>Fundamental aspects of spectral analysis</b></font></p>
<p>I will use the DFT program to illustrate several fundamental aspects of 
spectral analysis that center around the sampling frequency and the Nyquist 
folding frequency.</p>
<p><font color="#FF0000"><b>Visual illustration of sampling</b></font></p>
<p>I will also provide and explain a program that produces a visual illustration 
of the impact of the sampling frequency and the Nyquist folding frequency.</p>
<p><font color="#FF0000"><b>Plotting programs</b></font></p>
<p>Finally, I will provide, but will not explain two different programs used for 
display purposes.&nbsp; These are newer versions of graphics display programs 
that I explained in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them. </p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p>Before I get into the technical details, here is a preview of the programs 
and their purposes that I will present and explain in this lesson:</p>
<ul>
	<li><b>Dsp029</b> - Provides a visual illustration of the impact of the 
	sampling frequency and the Nyquist folding frequency.</li>
	<li><b>Dsp028</b> - Driver program for doing spectral analysis using a DFT 
	algorithm.</li>
	<li><b>ForwardRealToComplex01</b> - Class that implements the DFT algorithm.</li>
	<li><b>Dsp030</b> - Driver program for doing spectral analysis using an FFT 
	algorithm.</li>
	<li><b>ForwardRealToComplexFFT01</b> - Class that implements the FFT 
	algorithm <i>(will defer explanation until a future lesson).</i></li>
	<li><b>Graph03</b> - Used to display results of spectral analysis. <i>
	(The concepts were explained in an earlier lesson.)</i></li>
	<li><b>Graph06</b> - Used to display the impact of sampling frequency and the Nyquist 
	folding frequency<i>.</i>&nbsp; Also used to display the results of spectral 
	analysis.<i>&nbsp;&nbsp; (The concepts were explained in an earlier lesson).</i></li>
</ul>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p>This will be a long lesson involving lots of code and lots of explanations, 
so fill your cup with java and let's get started.</p>
<h3><a name="Sampling_Frequency_and_Nyquist_Folding_Frequency">Sampling 
Frequency and the Nyquist Folding Frequency</a></h3>
<p>I will begin the discussion with<b> </b> the program named<b> Dsp029</b>, 
which provides a visual illustration of the impact of the 
	sampling frequency and the Nyquist folding frequency.&nbsp; A complete listing of 
this program is shown in Listing 16 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Display sinusoids</b></font></p>
<p>This program generates and displays up to five sinusoids having the same 
sampling frequency but having different sinusoidal frequencies and amplitudes.&nbsp; 
The program provides a visual illustration of the way in which frequencies above one-half the sampling frequency fold back into the area bounded by zero and 
one-half the sampling frequency.</p>
<blockquote>
	<p><i>(The frequency at one-half the sampling frequency is known as the Nyquist folding frequency.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Input parameters</b></font></p>
<p>The program gets its input parameters from a file named <b>Dsp029.txt</b>.&nbsp; If that file doesn't exist in the current directory, the program uses a set of default parameters.</p>
<p>Each parameter value must be stored as characters on a separate line in the file named 
<b>Dsp029.txt</b>.&nbsp; The required parameters are shown in Figure 1.
</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length as type int
Number of sinusoids as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

<b>Figure 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#FF0000"><b>The length of the two lists</b></font></p>
<p>The number of values in each of the lists must
match the value for the number of sinusoids.&nbsp; Also, you must not allow blank 
lines at the end of the data in the file.</p>
<p><font color="#FF0000"><b>Frequency value specifications</b></font></p>
<p>Each frequency value is specified as a type <b>double</b> value representing a fractional part of the
sampling frequency.</p>
<blockquote>
	<p><i>(For example, a <b>double</b> value of 0.5 specifies 
	one-half the sampling frequency, or the Nyquist folding frequency.&nbsp; A
	<b>double</b> value of 2.0 specifies a frequency that is twice the sampling 
	frequency.)</i></p>
</blockquote>
<p>Figure 2 shows the contents of the file named <b>Dsp029.txt</b> that I used to produce the output 
shown in Figure 3.&nbsp; I will discuss that output later.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
50.0
5
0.03125
0.0625
0.125
0.25
0.5
90
90
90
90
90

<b>Figure 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p><font color="#FF0000"><b>The plotting program named Graph06</b></font></p>
<p>The plotting program that is used to plot the
output data from this program requires that the
program implement <b>GraphIntfc01</b>.&nbsp; I discussed that interface in the 
earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>.&nbsp; For example,
the plotting program named <b>Graph06</b> can be used
to plot the data produced by this program.&nbsp; When it is used, the program is 
executed and its output is plotted by entering the following at the command 
line prompt:</p>
<p><b><font face="Arial Narrow">java Graph06 Dsp029</font></b></p>
<p><font color="#FF0000"><b>Program output</b></font></p>
<p>
Figure 3 shows the output produced by running the program named <b>Dsp029</b> 
with the parameters shown in Figure 2.</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a1.jpg" width="409" height="431">

<b>Figure 3 Program output for five sinusoids</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>


<p><font color="#FF0000"><b>Five horizontal plots</b></font></p>
<p>Each of the five horizontal plots in Figure 3 shows a sampled sinusoid.&nbsp; 
Each of the vertical bars represents one sample value for a given sinusoid.</p>
<p>If you examine the frequency values in Figure 2 carefully, you will see that 
they represent the sampling frequency divided by the factors 32, 16, 8, 4, and 
2.&nbsp; Thus, the last frequency value is the Nyquist folding frequency and the 
first four frequency values are related to that frequency by multiples of two.</p>
<p>The horizontal plot at the top of Figure 3 is a reasonably well defined 
cosine wave.&nbsp; The horizontal plot at the bottom of Figure 3 shows the 
result of having exactly two samples per cycle of the sinusoid.&nbsp; Using this 
plotting scheme, the sampled sinusoid is represented as a square wave.&nbsp; 
Using another plotting 
scheme <i>(such as that used in the program named <b>Graph03</b>)</i> the 
sampled sinusoid at the bottom would be represented as a triangular wave.</p>
<p><font color="#FF0000"><b>An upper frequency limit</b></font></p>
<p>Regardless 
of the plotting scheme used, it should be obvious that a set of uniform samples 
cannot possibly represent frequencies higher than one-half the sampling frequency 
because then there would be less than one sample per cycle of the sinusoid.</p>
<p><font color="#FF0000"><b>The Nyquist folding frequency</b></font></p>
<p>Now I will show you why the frequency at one-half the sampling frequency is referred to as the 
<i>folding</i> frequency using the new set of frequency values shown in Figure 
4.</p>
<blockquote>
	<p><i>(Figure 4 shows the values read from the file named <b>Dsp029.txt</b> 
	and displayed in an improved format.)</i></p>
</blockquote>
<p>In this case, the third 
frequency in the list is one-half the sampling frequency, which is the folding 
frequency.&nbsp; The two frequencies on either side of that one have values that 
are symmetrical about the folding frequency.</p>
<p>

<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length: 50
Number sinusoids: 5
Frequencies
0.125
0.25
0.5
0.75
0.875
Amplitudes
90.0
90.0
90.0
90.0
90.0

<b>Figure 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>

<p><font color="#FF0000"><b>The program output</b></font></p>
<p>The five horizontal plots in Figure 5 show the result of running the program 
named <b>Dsp029 </b>with the frequencies shown in Figure 4.</p>

<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a2.jpg" width="409" height="431">

<b>Figure 5 Program output for five sinusoids</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
<p>The center plot in Figure 5 is the sampled representation of the folding 
frequency.</p>
<p>The top two plots in Figure 5 are obviously the sampled 
representations of the two lower frequencies specified by the first two 
frequencies in Figure 4.</p>
<p><font color="#FF0000"><b>Not so obvious ...</b></font></p>
<p>However, it is not so obvious that the bottom two plots in Figure 5 are the sampled representations of the two higher 
frequencies specified by the last two frequencies in Figure 4.&nbsp; They look 
exactly like the top two plots but in reverse order.</p>
<p><font color="#FF0000"><b>Unable to distinguish ...</b></font></p>
<p>Frequencies above one-half the sampling frequency are not distinguishable by 
viewing the sampled data.&nbsp; 
In fact, they are converted to lower frequencies by sampling process.&nbsp; The 
new lower frequencies fold around a point in 
the frequency spectrum given by one-half the sampling frequency.&nbsp; That is 
why it is called the folding frequency.&nbsp; <i>(In 1933, this frequency was named after 
scientist <a href="http://www.webopedia.com/TERM/N/Nyquists_Law.html">Harry 
Nyquist</a>.)</i></p>
<p><font color="#FF0000"><b>One more example</b></font></p>
<p>Let's look at one more example of plotted sinusoids.&nbsp; Consider the frequency values shown in 
Figure 6.&nbsp; The second and third frequencies are symmetrical about the 
sampling frequency.&nbsp; The fourth and fifth frequencies are symmetrical about 
twice the sampling frequency.&nbsp; The first frequency value is 
the same distance from zero as the other four frequencies are from the sampling 
frequency and twice the sampling frequency.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length: 50
Number sinusoids: 5
Frequencies
0.1
0.9
1.1
1.9
2.1
Amplitudes
90.0
90.0
90.0
90.0
90.0

<b>Figure 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#FF0000"><b>The program output</b></font></p>
<p>Figure 7 shows the output produced by running the program named <b>Dsp029
</b>with the frequency 
parameters specified by Figure 6.</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a3.jpg" width="409" height="431">

<b>Figure 7 Program output for five sinusoids</b>
</pre>
</td>
</tr>
</tbody>                                
</table>

</p>
<p><font color="#FF0000"><b>The sinusoids are indistinguishable</b></font></p>
<p>Although the actual frequencies of the five cosine functions are 
significantly different, once they are sampled, they are indistinguishable.&nbsp; 
The sampling process converts the actual frequencies to new frequencies 
that not only fold around one-half the sampling frequency, they also fold around 
all multiples of one-half the sampling frequency.</p>
<p><font color="#FF0000"><b>Enough talk, let's see some code</b></font></p>
<p>The program named <b>Dsp029</b> is provided in Listing 16 near the end of the 
lesson.&nbsp; I will discuss the program in fragments, beginning with the fragment shown in Listing 1.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class <b>Dsp029</b> implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  int numberSinusoids = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.25,0.5,0.75,0.9};
  //Amplitudes of the sinusoids
  double[] amp = {75,75,75,75,75};
  //End default parameters

<b>Listing 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The code in Listing 1 defines a convenience constant representing the value 
of pi and then defines the set of default parameters that will be used by the 
program in the event that the file named <b>Dsp029.txt</b> does not exist in the 
current directory.</p>
<p><font color="#FF0000"><b>Create array objects to hold sinusoidal data</b></font></p>
<p>The code in Listing 2 creates five array objects that will be populated with 
sinusoidal data.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  double[] data1 = new double[len];
  double[] data2 = new double[len];
  double[] data3 = new double[len];
  double[] data4 = new double[len];
  double[] data5 = new double[len];

<b>Listing 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Get the parameters</b></font></p>
<p>The constructor begins in Listing 3.&nbsp; The code in this fragment invokes 
the method named <b>getParameters</b> to read the parameters from the file named
<b>Dsp029.txt</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public Dsp029(){//constructor

    if(new File("Dsp029.txt").<b>exists</b>()){
      <b>getParameters</b>();
    }//end if

<b>Listing 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Before invoking the <b>getParameters</b> method, however, the program invokes 
the <b>exists</b> method of the <b>File </b>class to confirm that the file 
actually exists.&nbsp; If the file doesn't exist, the call to <b>getParameters</b> is skipped, 
causing the default parameters defined in Listing 1 to be used instead.</p>
<p><font color="#FF0000"><b>The getParameters method</b></font></p>
<p>The <b>getParameters</b> method is straightforward, so I won't discuss it in 
detail.&nbsp; You can view it in Listing 16.&nbsp; Suffice it to say that the 
method reads the input parameters from the disk file and writes their values into 
the variables declared in Listing 1, overwriting the default values stored in 
those variables.</p>
<p>In addition, the <b>getParameters</b> method displays the values read from the disk file in the 
format shown in Figure 4 and Figure 6.</p>
<p><font color="#FF0000"><b>Create the sinusoidal data</b></font></p>
<p>For simplicity, this program always generates five sinusoids, even if fewer than five were requested as the input parameter 
value for <b>numberSinusoids</b>.&nbsp; In that case, the extra sinusoids are generated using default values and 
are simply ignored when the sinusoids are plotted.</p>
<p>The code fragment in Listing 4 creates the sinusoidal data for each of the 
five specified frequencies and saves that data in the array objects that were 
created in Listing 2.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int n = 0;n < len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop

  }//end constructor

<b>Listing 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The end of the constructor</b></font></p>
<p>Listing 4 also signals the end of the constructor.&nbsp; When the constructor 
terminates, an object of the <b>Dsp029</b> class has been instantiated.&nbsp; The 
five arrays shown in Listing 4 have been populated with sinusoidal data 
according to the parameters read from the file named <b>Dsp029.txt</b> or 
according to the 
default values of the parameters shown in Listing 1.</p>
<p><font color="#FF0000"><b>Plotting the sinusoidal data</b></font></p>
<p>In order to better understand what is going on in the plotting process, it 
would be helpful for you to read the previous lesson entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>.&nbsp; However, assuming that 
you don't have the time to do that, I will provide a very brief explanation as to how the 
plotting programs work.</p>
<p><font color="#FF0000"><b>Using Graph06 to plot the sinusoidal data</b></font></p>
<p>To use the plotting program named <b>Graph06</b> to plot the sinusoidal data, I needed to do the following:</p>
<ul>
	<li>Define and compile the program named <b>Dsp029</b>, implementing the interface named <b>GraphIntfc01</b>.&nbsp; 
	The definition of that interface is shown in Listing 5</li>
	<li>Start the plotting program named <b>Graph06</b> running by entering <i> <b>
	java Graph06 Dsp029</b></i> at the command line prompt.</li>
</ul>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>public interface GraphIntfc01{
  public int getNmbr();
  public double f1(double x);
  public double f2(double x);
  public double f3(double x);
  public double f4(double x);
  public double f5(double x);
}//end GraphIntfc01

<b>Listing 5</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>What does this do?</b></font></p>
<p>When executed in this manner, the program named <b>Graph06</b> instantiates 
an object of the class named <b>Dsp029</b> and then invokes the interface 
methods on that object to obtain the data to be plotted.</p>
<p>In this case, the constructor for the <b>Dsp029</b> class populates the five 
array objects with sinusoidal data.&nbsp; The subsequent invocation of the 
interface methods by the program named <b>Graph06</b> causes that sinusoidal 
data to be retrieved and plotted by <b>Graph06</b>.</p>
<p><font color="#FF0000"><b>The GraphIntfc01 interface methods</b></font></p>
<p>A brief description of each of the interface methods is provided in the 
following sections.</p>
<p><font color="#ff0000"><b>The getNmbr method</b></font></p>
<p>Plotting programs based on <b>GraphIntfc01 </b>can be used to plot any number 
of functions from one to five.</p>
<p>The method named <b>getNmbr</b> must return an integer value between 1 and 5 
that specifies the number of functions to be plotted.&nbsp; The plotting program uses 
that value to divide the total plotting surface into the specified number of 
plotting areas, and plots each of the functions named <b>f1</b> through <b>fn</b> 
in one of those plotting areas.</p>
<p><font color="#ff0000"><b>The methods named f1, f2, f3, f4, and f5</b></font></p>
<p>As you can see in Listing 5, each of these methods receives a <b>double</b> 
value as an incoming parameter and returns a <b>double</b> value.&nbsp; In essence, 
each of these methods receives a value for the horizontal coordinate <b>x</b> 
and returns the corresponding value for the vertical coordinate <b>y</b>.</p>
<p><font color="#ff0000"><b>One plotting area per method</b></font></p>
<p>Each of these methods provides the data to be plotted in one plotting area.&nbsp; 
The method named <b>f1</b> provides the data for the top plotting area; the 
method named <b>f2</b> provides the data for the first plotting area down from 
the top, and so forth.</p>
<blockquote>
	<p><i>(For example, if the <b>getNmbr</b> method returns a value of 4, the 
	method named <b>f5</b> will never be invoked.&nbsp; If <b>getNmbr</b> returns 5, 
	the method named <b>f5</b> will be invoked to provide the data for the 
	bottom plotting area.)</i></p>
</blockquote>
<p><font color="#ff0000"><b>How does it work?</b></font></p>
<p>Each plotting area contains a horizontal axis.&nbsp; The plotting program moves 
across the horizontal axis in each plotting area one step at a time <i>(moving 
in incremental steps equal to the plotting parameter named xCalcInc, which you 
will find if you examine the code for <b>Graph06</b>).</i></p>
<p>At each step along the way, the plotting program invokes the method 
associated with that plotting area, <i>(f1, f2, etc.),</i> passing the 
horizontal position as a parameter to the method.</p>
<p>The value returned by the method is assumed to be the vertical value 
associated with that horizontal position, and that is the vertical value that is 
plotted for that horizontal position.</p>
<p><font color="#ff0000"><b>Doesn't know and doesn't care</b></font></p>
<p>The plotting program doesn't know, and doesn't care how the interface method decides on 
the value to return for each value that it receives as an incoming parameter.&nbsp; 
The plotting program simply invokes the methods to get the data, and then plots 
the returned values.</p>
<p><font color="#ff0000"><b>Computed <i>&quot;on the fly&quot;</i></b></font></p>
<p>For example, the returned values could be computed and returned <i>&quot;on the 
fly,&quot;</i> as was the case in the example program named <b>Graph01Demo</b>, which 
I explained in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>.</p>
<p><font color="#ff0000"><b>Returned from an array</b></font></p>
<p>On the other hand, the values could have been computed earlier and saved in 
an array.&nbsp; That is the case with all the programs that I will explain in 
this lesson.</p>
<p><font color="#ff0000"><b>From a disk file, a database, the Internet, etc.</b></font></p>
<p>The returned values could be read from a disk file, obtained from a database 
on another computer, or obtained from any other source such as another computer 
on the Internet.</p>
<p>All that matters is that when the plotting program invokes one of the five 
methods named <b>f1</b> through <b>f5</b>, passing a <b>double</b> value as a 
parameter, it expects to receive a <b>double</b> value as a return value, and it 
will plot the value that it receives.</p>
<p><font color="#FF0000"><b>The getNmbr method</b></font></p>
<p>The <b>getNmbr</b> method for the class named <b>Dsp029</b> is shown in 
Listing 6.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return numberSinusoids;
  }//end getNmbr

<b>Listing 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>This is a very simple method.&nbsp; It returns the value stored in the 
variable named <b>numberSinusoids</b>.&nbsp; This variable may contain the 
default value established by Listing 1, or may contain the value read from the 
file named <b>Dsp029.txt</b> by the method named <b>getParameters</b>.</p>
<p><font color="#FF0000"><b>The method named f1</b></font></p>
<p>The code for the method named <b>f1</b> is shown in Listing 7.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 || index > data1.length-1){
      return 0;
    }else{
      return data1[index];
    }//end else
  }//end function

<b>Listing 7</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Note that there is not a one-to-one correspondence between horizontal 
coordinate values and pixels on the screen.&nbsp; For example, it may sometimes 
be necessary to plot 90 values across an area of the screen containing 110 
pixels.&nbsp; The plotting program must interpolate properly to deal 
with that issue.&nbsp; Therefore, the plotting program deals with horizontal 
coordinates at type <b>double</b> and then converts those coordinate values to 
integer pixel values when the time comes to actually draw the material on the 
screen.</p>
<p><font color="#FF0000"><b>Round from double to int</b></font></p>
<p>The method named <b>f1</b> receives an incoming horizontal coordinate value 
as type <b>double</b>.&nbsp; It rounds that value to the nearest value of type
<b>long</b> and casts it to type <b>int</b> to determine the index value to use 
when retrieving the corresponding vertical value from the array object.</p>
<p>If the index value is outside the bounds of the array, the method simply 
returns a value of zero.&nbsp; Otherwise, it uses the index value to return the 
value stored in the array object at that index.</p>
<p><font color="#FF0000"><b>The remaining interface methods</b></font></p>
<p>The remaining four interface methods are identical to the method named <b>f1</b>, 
except that each method returns data values stored in a different array object.&nbsp; 
Therefore, I won't discuss those methods.</p>
<p><font color="#FF0000"><b>That's it for Dsp029</b></font></p>
<p>That's about it for the program named <b>Dsp029</b>.&nbsp; If you understand 
this program, you are well ahead of the game.&nbsp; The overall structure for 
the programs named <b>Dsp028</b> and <b>Dsp030</b> are very similar to the 
structure for <b>Dsp029</b>.&nbsp; The big difference is the manner in which 
they populate the array objects with the data that is to be plotted.&nbsp; 
Instead of simply plotting sinusoids, they perform spectral analysis on 
sinusoids and provide the results of the spectral analysis to be plotted.</p>
<p><font color="#FF0000"><b>Using the interface named GraphIntfc01</b></font></p>
<p>As you learned earlier, this is a very simple interface.&nbsp; However, 
because the class named <b>Dsp029</b> implements the interface, the interface 
definition file must be in the same directory as the source file for <b>Dsp029</b> 
in order to successfully compile <b>Dsp029</b>.&nbsp; Therefore, I have provided 
a complete listing of <b>GraphIntfc01</b> in Listing 17 near the end of the 
lesson.</p>
<p><font color="#FF0000"><b>The program named Graph06</b></font></p>
<p>A complete listing of the program named <b>Graph06</b> is provided in Listing 
18 near the end of the lesson.&nbsp; This is simply a newer version of graphics 
display programs that I explained in the earlier lesson entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>.&nbsp; Therefore, I 
won't repeat that explanation here.&nbsp; The comments at the beginning and 
spread throughout the program provide considerable information about it.</p>
<p><font color="#FF0000"><b>Operational aspects of Graph06</b></font></p>
<p>However, an explanation of the operational aspects of the program will be 
useful here.&nbsp; You can use this program to display the output produced by <b>
Dsp029</b> by entering the following at the command line prompt:<p><b>
<font face="Arial Narrow">java Graph06 Dsp029</font></b><p>As you saw in Figure 
3 and other previous figures, this program provides the following text fields for user input, along with a button labeled
<b>Graph</b>:
<ul>
	<li><b>xMin</b> = minimum x-axis value</li>
	<li><b>xMax</b> = maximum x-axis value</li>
	<li><b>yMin</b> = minimum y-axis value</li>
	<li><b>yMax</b> = maximum y-axis value</li>
	<li><b>xTicInt</b> = tic interval on x-axis</li>
	<li><b>yTicInt</b> = tic interval on y-axis</li>
	<li><b>xCalcInc</b> = calculation interval</li>
	</ul>
	<p>These text fields make it possible for you to adjust the plotting parameters and to re-plot the graphs 
as many times as needed.</p>
<p>You can modify any of these parameters and then click the <b>Graph</b> button to cause the five functions to be re-plotted according to the new 
plotting parameters.</p>
<h3><a name="Spectral_Analysis_using_a_DFT_Algorithm">Spectral Analysis using a 
DFT Algorithm</a></h3>
<p>Now that you have a good idea where we are heading, it's time to start doing 
some spectral analysis.</p>
<p>Let's begin by looking at some output obtained by performing a spectral 
analysis on the same five sinusoids shown in Figure 3.&nbsp; The parameters used 
to perform this spectral analysis are shown in Figure 8.&nbsp; <i>(I will 
explain each of these parameters as we go along.)</i></p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length: 400
Sample for zero time: 0
Lower frequency bound: 0.0
Upper frequency bound: 1.0
Number spectra: 5
Frequencies
0.03125
0.0625
0.125
0.25
0.5
Amplitudes
90.0
90.0
90.0
90.0
90.0

<b>Figure 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Although more parameters are required to perform spectral analysis than are 
required to simply generate and plot the sinusoids, the number of sinusoids, the 
frequencies of the sinusoids, and the amplitudes of the sinusoids in Figure 8 
are the same as in Figure 2.</p>
<p><font color="#FF0000"><b>The spectral analysis output</b></font></p>
<p>The output produced by performing spectral analysis on these five sinusoids 
is shown in Figure 9.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a4.jpg" width="409" height="431">

<b>Figure 9 Spectral analysis of five sinusoids.</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The format explained</b></font></p>
<p>Five separate spectral analyses were performed and the results of those five 
spectral analyses are shown in Figure 9.&nbsp; Each of the horizontal lines in 
Figure 9 is the horizontal axis used to display the result of performing a 
spectral analysis on a different sinusoid.&nbsp; In other words, Figure 9 
contains five separate graphs moving from the top to the bottom of the display.&nbsp; 
The individual graphs have alternating white and gray backgrounds to make them 
easier to separate visually.</p>
<p>The top graph in Figure 9 shows the result of performing a spectral analysis 
on the top sinusoid in Figure 3.&nbsp; Moving down the page, each graph in 
Figure 9 shows the result of performing a spectral analysis on the 
corresponding sinusoid in Figure 3.</p>
<p><font color="#FF0000"><b>The frequency axes</b></font></p>
<p>The horizontal axes in Figure 9 represent the frequency range from zero to 
the sampling frequency.</p>
<blockquote>
	<p><i>(The frequency range covered is specified by the <b>Lower frequency 
	bound</b> and the <b>Upper frequency bound</b> parameters in Figure 8.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The horizontal units</b></font></p>
<p>The horizontal units in Figure 9 don't represent frequency in an absolute 
sense of cycles per second or Hertz.&nbsp; Rather, the horizontal units in 
Figure 9 represent the frequency bins for which spectral energy was computed.&nbsp; 
In this case, the spectral energy for each sinusoid was computed in 400 equally 
spaced bins distributed between zero and the sampling frequency.</p>
<blockquote>
	<p><i>(The number of frequency bins for each individual spectrum computed by 
	this program is equal to the <b>Data length</b> parameter in Figure 8.&nbsp; 
	Those frequency bins are distributed uniformly between the <b>Lower 
	frequency bound</b> and the <b>Upper frequency bound</b> parameters in 
	Figure 8.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Location of the folding frequency</b></font></p>
<p>Because the right-most end of each horizontal axis in Figure 9 represents the 
sampling frequency, the center of each horizontal axis represents one-half the 
sampling frequency, or the Nyquist folding frequency.&nbsp; Thus, the frequency 
represented by the center of each horizontal axis represents the frequency 
specified by a value of 0.5 in Figure 8.</p>
<p><font color="#FF0000"><b>A peak at the folding frequency</b></font></p>
<p>You can see a large peak in energy at the folding frequency of the bottom 
graph in Figure 9.&nbsp; That peak corresponds to the frequency of the fifth 
sinusoid specified in the parameters shown in Figure 8.&nbsp; <i>(This also corresponds to the spectrum of the bottom graph in 
Figure 3.)</i></p>
<p>Knowing that, you should be able to correlate each of the peaks to the left 
of center in Figure 9 with the frequencies of the sinusoids specified in Figure 
8 and with the individual sinusoids plotted in Figure 3.</p>
<p><font color="#FF0000"><b>The frequency folding effect</b></font></p>
<p>Figure 9 clearly shows the frequency folding effect of the sampling process 
illustrated earlier.&nbsp; As you can see, the peaks in the various graphs to 
the right of the folding frequency are mirror images of the peaks to the left of 
the folding frequency.&nbsp; In other words, given a set of samples of a 
sinusoid, the spectral analysis process is unable to determine whether the peak 
is above or below the folding frequency, so the energy is equally distributed 
between two peaks on opposite sides of the folding frequency.</p>
<p><font color="#FF0000"><b>Size of the peak at the folding frequency</b></font></p>
<p>Note that the peak in the bottom graph is approximately twice the height of 
the peaks in the other graphs.&nbsp; This is because the peak at the folding 
frequency has no mirror-image partner, and all the energy is concentrated in 
that single peak.</p>
<blockquote>
	<p><i>(Another interpretation is that two mirror-image peaks converge at the 
	folding frequency causing the resulting peak to be twice as large as either 
	mirror-image peak.&nbsp; I will illustrate this effect with another example 
	later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A short fat peak at the top</b></font></p>
<p>You may also have noticed that the peaks in the top graph are shorter and wider 
than the peaks in the other graphs.&nbsp; This may be because the actual 
frequency of the sinusoid for the top graph is about half way between the values 
of the twelfth and thirteenth bins for which spectral energy was computed.&nbsp; 
Thus, the energy in the sinusoid was spread between the bins on either side of 
the actual frequency.</p>
<p>This frequency spreading effect can be minimized by increasing the data 
length to 800 samples.&nbsp; This causes the frequency bins to be only half as 
wide and the peak in the top graph becomes tall and narrow just like the peaks 
in the other graphs.&nbsp; You should try this and observe the result when you 
run the program later.</p>
<p>It is also instructive to plot these spectra with a data length of 400 using 
the program named <b>Graph06</b>.&nbsp; This will show you how the energy is 
distributed between the frequency bins.&nbsp; This is most effective when the 
graph is expanded as described in the next section.</p>
<p><font color="#FF0000"><b>Mapping the peaks to pixels</b></font></p>
<p>The broadening of the peak in the top graph may also have to do with the 
requirement to map the peaks in the spectrum to the locations of the actual 
pixels on the screen.&nbsp; If the location of the peak falls between the 
positions of two pixels, the plotting program must interpolate the energy in the 
peak so as to display that energy in actual pixel locations.</p>
<p>This effect can be minimized by plotting the same number of spectral values 
across a wider area of the screen.&nbsp; When you run this program later, click 
the maximize button on the <b>Frame</b> to cause the display to occupy the entire screen.&nbsp; That 
will give you a much better look at the actual shape of each of the peaks.&nbsp; 
Do this using both <b>Graph03</b> and <b>Graph06</b> to plot the results.</p>
<blockquote>
	<p><i>(Note:&nbsp; When switching between the plotting programs, you may 
	need to delete the class files from the old program and compile the new 
	program to avoid having class files with the same names from the two 
	programs becoming intermingled in the same directory.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Another DFT example</b></font></p>
<p>This next example is designed to illustrate the following features of the DFT 
algorithm which don't generally apply to an FFT algorithm:</p>
<ul>
	<li>Ability to do spectral analysis on data of arbitrary lengths.&nbsp; <i>
	(With most FFT algorithms, the data length must be a power of two.)</i></li>
	<li>Ability to zero in on an arbitrary range of frequencies and to ignore 
	all other frequencies.&nbsp; <i>(Most FFT algorithms always compute the 
	spectrum at uniform frequency increments from zero to one unit less than the sampling 
	frequency.)</i></li>
</ul>
<p>As mentioned earlier, the DFT algorithm is much more flexible while the FFT 
algorithm is much faster, particularly for large data lengths.</p>
<p><font color="#FF0000"><b>Peaks merge at the folding frequency</b></font></p>
<p>In addition to illustrating these fundamental aspects of the DFT algorithm, 
this example also illustrates how the mirror image peaks on either side of the 
folding frequency merge into a single larger peak as the data frequency 
approaches the folding frequency.</p>
<p><font color="#FF0000"><b>The input parameters</b></font></p>
<p>The input parameters are shown in Figure 10.&nbsp; Note in particular the 
values for the following parameters:</p>
<ul>
	<li>Data length: 200</li>
	<li>Sample for zero time: 0</li>
	<li>Lower frequency bound: 0.4</li>
	<li>Upper frequency bound: 0.6</li>
</ul>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length: 200
Sample for zero time: 0
Lower frequency bound: 0.4
Upper frequency bound: 0.6
Number spectra: 5
Frequencies
0.492
0.494
0.496
0.498
0.5
Amplitudes
90.0
90.0
90.0
90.0
90.0

<b>Figure 10</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>A different data length</b></font></p>
<p>As you can see, the data length for this experiment is different from the 
data length of 400 used earlier.&nbsp; In addition, neither data length is a 
power of two.</p>
<p><font color="#FF0000"><b>Computational frequency bounds</b></font></p>
<p>As you can also see, the lower and upper frequency bounds are not 0.0 and 1.0 
as in the earlier cases.&nbsp; In this case, the frequency bounds describe a 
much narrower range centered on the folding frequency.</p>
<p><font color="#FF0000"><b>Frequencies are close to the folding frequency</b></font></p>
<p>Finally, the frequencies of each of the five sinusoids specified in Figure 10 
is progressively closer to the folding frequency with the frequency of the fifth 
sinusoid being equal to the folding frequency.</p>
<p><font color="#FF0000"><b>The spectral analysis output</b></font></p>
<p>The output from the spectral analysis for each of the five sinusoids is shown 
in Figure 11.&nbsp; <i>(Another interesting view of the same results is shown 
later in Figure 14.)</i></p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a5.jpg" width="409" height="431">

<b>Figure 11 Spectral analysis of five sinusoids.</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Peaks are symmetrical to the folding frequency</b></font></p>
<p>The spectral peaks shown in Figure 11 are symmetrical to the folding frequency, 
which in turn is centered horizontally in each of the graphs.&nbsp; As you 
already know, the peaks are always symmetrical to the folding frequency due to the 
frequency folding at that frequency.</p>
<p>The folding frequency is centered horizontally due to the way that I defined 
the lower and upper frequency bounds, and the way that I adjusted the plotting 
parameters.</p>
<p><font color="#FF0000"><b>Peaks are well defined and wider than before</b></font></p>
<p>The peaks are well defined because I computed the spectral energy at 200 
points across the specified frequency range from 0.4 to 0.6.&nbsp; Thus, the 
frequency bins at which I computer spectral energy were much narrower than 
before.</p>
<p>The peaks are wider because I displayed a much smaller slice of the entire 
frequency spectrum in the same physical screen space.</p>
<p><font color="#FF0000"><b>Peaks merge at the folding frequency</b></font></p>
<p>As the frequency of each sinusoid approaches the folding frequency, the two 
mirror-image peaks corresponding to that sinusoid merge into a single peak with twice the height at the folding 
frequency.&nbsp; This agrees with what you saw in Figure 9, but on a much more 
detailed basis.</p>
<p>It would be difficult to perform this experiment using an FFT algorithm 
because of the inherent limitations built into the algorithm.&nbsp; The FFT 
algorithm sacrifices flexibility for speed.</p>
<p><font color="#FF0000"><b>Implementing the DFT algorithm</b></font></p>
<p>At this point, I will present and explain two different programs:</p>
<ul>
	<li><b>Dsp028</b> - Driver program for doing spectral analysis using a DFT 
	algorithm.</li>
	<li><b>ForwardRealToComplex01</b> - Class that implements the DFT algorithm.</li>
</ul>
<p>In addition, I will present, but will not explain the plotting program named
<b>Graph03</b>.</p>
<p><font color="#FF0000"><b>The Dsp028 program</b></font></p>
<p>This driver program is similar in many respects to the program named <b>
Dsp029</b> that I explained earlier.&nbsp; It differs mainly in how it populates 
the array objects containing the data that is plotted by the plotting program.</p>
<p>The program named <b>Dsp029</b> simply populates those array objects with 
five sinusoidal functions.&nbsp; The program named <b>Dsp028</b> also creates 
five sinusoidal functions.&nbsp; However, it passes those functions to a static method 
named <b>transform</b> belonging to the <b>ForwardRealToComplex01</b> class to 
perform spectral analysis on those functions.&nbsp; The results of the spectral 
analysis are used to populate the five array objects whose contents are plotted 
by the plotting program.</p>
<p>Because of the similarity of the two programs, my discussion of <b>Dsp028</b> 
will be much more brief than was my discussion of <b>Dsp029</b>.</p>
<p><font color="#FF0000"><b>Computes and displays the magnitude spectrum</b></font></p>
<p>The program named <b>Dsp028 </b>computes and displays the magnitude of the spectral content for up to five sinusoids having different frequencies and amplitudes.</p>
<blockquote>
	<p><i>(Future lessons will discuss other aspects of spectral analysis such 
	as the complex spectrum, zero time, and the phase angle.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Input parameters</b></font><p>The program gets input parameters from a file named <b>Dsp028.txt</b>.&nbsp; If that file doesn't exist in the current directory, the program uses a set of default parameters.

As with the program named <b>Dsp029</b>, each parameter value must be stored as characters on a separate line in the file named
<b>Dsp028.txt</b>.&nbsp; The required parameters are shown in Figure mm.<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length as type int
Sample number representing zero time as type int
Lower frequency bound as type double
Upper frequency bound as type double
Number of spectra as type int.&nbsp; Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

<b>Figure mm Required input parameters for Dsp028.</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p>

Don't allow blank lines at the end of the data in the file.</p>
<p>

The number of values in each of the lists must
match the value for the number of spectra.</p>
<p>

<font color="#FF0000"><b>Specification of sinusoidal frequencies</b></font></p>
<p>

As before, each frequency value is specified as a <b>double</b> value representing a fractional part of the
sampling frequency.&nbsp; For example, a value of 0.5
specifies a frequency that is one-half the sampling
frequency.</p>
<p>

<font color="#FF0000"><b>Example contents for Dsp028.txt</b></font></p>
<p>

Figure 12 shows the contents of the file named <b>Dsp028.txt</b> that represent 
the parameters shown in Figure 10.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
200
0
0.4
0.6
5
0.492
0.494
0.496
0.498
0.5
90
90
90
90
90

<b>Figure 12 Contents of Dsp028.txt file</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p>

<font color="#FF0000"><b>Performing the spectral analysis</b></font></p>
<p>

A static method named <b>transform</b> belonging to the
class named <b>ForwardRealToComplex01</b> is used to
perform the actual spectral analysis.&nbsp; The
method named <b>transform</b> does not implement an FFT algorithm.&nbsp; Rather, 
it is more general than, but much slower than an FFT algorithm.</p>
<p>

<font color="#FF0000"><b>Will discuss the code in fragments</b></font></p>
<p>As usual, I will discuss the code in fragments.&nbsp; A complete listing of 
the program is presented in Listing 19 near the end of the lesson.&nbsp; Because 
of the similarity of <b>Dsp028</b> with <b>Dsp029</b> discussed earlier, the fragments for <b>Dsp028</b> will be much larger and will be explained in much 
less detail.</p>
<p>The class definition begins in Listing 8.&nbsp; For reasons that you already 
understand, this class implements the interface named <b>GraphIntfc01</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
<b>class Dsp028 implements GraphIntfc01</b>{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  //Sample that represents zero time.
  int zeroTime = 0;
  //Low and high frequency limits for the
  // spectral analysis.
  double lowF = 0.0;
  double highF = 1.0;
  int numberSpectra = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.2,0.3,0.4,0.5};
  //Amplitudes of the sinusoids
  double[] amp = {60,70,80,90,100};
  //End default parameters

<b>Listing 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The code in Listing 8 defines a set of default parameter values that are used 
in the event that a file named <b>Dsp028.txt</b> does not exist in the current 
directory.</p>
<p><font color="#FF0000"><b>Declare array variables</b></font></p>
<p>The code in Listing 9 declares several array variables that will be used to 
point to array objects whose purposes are explained in the comments.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  //Following arrays will contain data that is
  // input to the spectral analysis process.
  double[] data1;
  double[] data2;
  double[] data3;
  double[] data4;
  double[] data5;

  //Following arrays receive information back
  // from the spectral analysis that is not used
  // in this program.
  double[] real;
  double[] imag;
  double[] angle;

  //Following arrays receive the magnitude
  // spectral information back from the spectral
  // analysis process.
  double[] magnitude1;
  double[] magnitude2;
  double[] magnitude3;
  double[] magnitude4;
  double[] magnitude5;

<b>Listing 9</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The constructor</b></font></p>

<p>The constructor for the class begins in Listing 10.&nbsp; The constructor 
begins by getting the parameters from a file named <b>Dsp028.txt</b>.&nbsp; If 
that file doesn't exist in the current directory, default parameters are used.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public Dsp028(){//constructor

    if(new File("Dsp028.txt").exists()){
      getParameters();
    }//end if

<b>Listing 10</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Always processes five sinusoids</b></font></p>

For simplicity, this program always processes
 five sinusoids, even if fewer than five
 were requested as the input parameter
 for <b>numberSpectra</b>.&nbsp; In that case, the
 extra sinusoids are processed using default values
 and simply ignored when the results are
 plotted.</p>
<p><font color="#FF0000"><b>Create the raw sinusoidal data</b></font></p>
<p>The code in Listing 11 instantiates array objects and creates the sinusoidal 
data upon which spectral analysis will be performed.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //First create empty array objects.
    double[] data1 = new double[len];
    double[] data2 = new double[len];
    double[] data3 = new double[len];
    double[] data4 = new double[len];
    double[] data5 = new double[len];
    //Now populate the array objects
    for(int n = 0;n < len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop

<b>Listing 11</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Perform the spectral analysis</b></font></p>
<p>The code in Listing 12 creates array objects to receive the results and 
invokes the static <b>transform</b> method of the <b>forwardRealToComplex01</b> 
class five times in succession to perform the spectral analysis on each of the 
five sinusoids.</p>
<blockquote>
	<p><i>(I will explain the <b>transform</b> method that performs the spectral 
	analysis shortly.)</i></p>
</blockquote>
<p>Only the magnitude data is displayed by this program.&nbsp; Therefore, the arrays that 
receive the other spectral analysis results from the <b>transform</b> method are 
discarded each time a new spectral analysis is performed.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    magnitude1 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    <b>ForwardRealToComplex01.transform(data1,real,
      imag,angle,magnitude1,zeroTime,lowF,highF);</b>

    magnitude2 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data2,real,
      imag,angle,magnitude2,zeroTime,lowF,highF);

    magnitude3 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data3,real,
      imag,angle,magnitude3,zeroTime,lowF,highF);

    magnitude4 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data4,real,
      imag,angle,magnitude4,zeroTime,lowF,highF);

    magnitude5 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data5,real,
      imag,angle,magnitude5,zeroTime,lowF,highF);
  }//end constructor

<b>Listing 12</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The spectral magnitude results</b></font></p>
<p>Note that the magnitude results are saved in the array objects referred to by
<b>magnitude1</b>, <b>magnitude2</b>, etc.&nbsp; This will be important later 
when I discuss the interface methods defined by <b>Dsp028</b>.</p>
<p><font color="#FF0000"><b>The end of the constructor</b></font></p>
<p>Listing 12 also signals the end of the constructor.&nbsp; When the 
constructor terminates, the object has been instantiated and populated with 
spectral analysis results for five sinusoids using the parameters specified by 
the file named <b>Dsp028.txt</b>.</p>
<p><font color="#FF0000"><b>The getParameters method</b></font></p>
<p>The getParameters method used in this program is the same as that used in <b>
Dsp029</b>, so I won't discuss it further.</p>
<p><font color="#FF0000"><b>The interface methods</b></font></p>
<p>The <b>Dsp028</b> class must define the same six interface methods as the <b>Dsp029</b> class discussed earlier.&nbsp; The only difference 
in the interface methods is the identification of the array objects from which the methods return data 
when the methods are invoked.</p>
<p>The code in Listing 13 is typical of the code for methods <b>f1</b> through
<b>f5</b>.&nbsp; As you can see, these methods return the data stored in the 
magnitude arrays.&nbsp; These are the spectral analysis results that are plotted 
in Figure 9, Figure 11, and later in Figure 14.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index < 0 ||
                index > magnitude1.length-1){
      return 0;
    }else{
      return <b>magnitude1[index]</b>;
    }//end else
  }//end function

<b>Listing 13</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The program named Graph03</b></font></p>
<p>The plots in Figure 9 and Figure 11 were produced by entering the following 
at the command line prompt:</p>
<p><b><font face="Arial Narrow">java Graph03 Dsp028</font></b></p>
<p>The program named <b>Graph03</b> is very similar to the program named <b>
Graph06</b> discussed earlier.&nbsp; In fact, the program named <b>Graph06</b> 
can be used to produce very similar plots where the sample values are 
represented by vertical bars instead of being represented by connected dots.&nbsp; 
This results in the very interesting display shown in Figure 14.&nbsp; Each of 
the vertical bars in Figure 14 represents a computational frequency bin.&nbsp; <i>
(Compare Figure 14 with Figure 11.)</i></p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a6.jpg" width="409" height="431">

<b>Figure 14 Spectral analysis of five sinusoids.</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p>In any event, <b>Graph03</b> is so similar to <b>Graph06</b> that I'm not 
going to discuss it further.&nbsp; A complete listing of the program named <b>
Graph03</b> is provided in Listing 20 near the end of the lesson.</p>
<p><font color="#FF0000"><b>The transform method of the ForwardRealToComplex01 
class</b></font></p>
<p>That brings us to the heart of this lesson, which is the method that actually 
implements the DFT algorithm and performs the spectral analysis.&nbsp; This is a 
method named <b>transform</b>, which is a static method of the class named <b>
ForwardRealToComplex01</b>.&nbsp; You saw this method being invoked five times 
in the code in Listing 12.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font></p>
<p>As usual, I will discuss this method in fragments.&nbsp; A complete listing 
of the class is presented in Listing 21 near the end of the lesson.</p>
<p>The <b>transform</b> method is a rather straightforward implementation of the 
concepts that I explained in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3374611">Fun with Java, 
How and Why Spectral Analysis Works</a>.&nbsp; If you 
have not done so already, I strongly urge you go to back and study that lesson 
at this time.&nbsp; You need to understand those concepts in order for the code 
in the <b>transform</b> method to make sense.</p>
<p><font color="#FF0000"><b>A brief description</b></font></p>
<p>For those of you who don't have the time to go back and study that lesson in 
detail, a brief description of the DFT algorithm follows.</p>
<p>Using a notation that I described in the earlier lesson, the expressions that 
you must evaluate to determine the frequency spectral content of a target time 
series at a frequency F are shown in Figure 15.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Real(F) = S(n=0,N-1)[x(n)*cos(2Pi*F*n)]
Imag(F) = S(n=0,N-1)[x(n)*sin(2Pi*F*n)]

ComplexAmplitude(F) = Real(F) - j*Imag(F)
Power(F) = Real(F)*Real(F) + Imag(F)*Imag(F)
Amplitude(F) = SqRt(Power(F))

<b>Figure 15</b>
</pre>
</td>
</tr>
</tbody>                                
</table>
</p>
<p><font color="#ff0000"><b>What does this really mean?</b></font></p>
<p>Before you panic, let me explain what this means in layman's terms.&nbsp;
  Given a time series, <b>x(n)</b>, you can determine if that time series
contains a cosine component or a sine component at a given frequency, <b>F</b>,
by doing the following: 
 </p>
     
<ul>
    <li> Create one new time series, <b>cos(n)</b>, which is a cosine function 
 with the frequency <b>F</b>.</li>
     <li> Create another new time series, <b>sin(n)</b>, which is a sine
function   with the frequency <b>F</b>.</li>
     <li> Multiply <b>x(n)</b> by <b>cos(n)</b> and compute the sum of the
 products.&nbsp;  Save this value, calling it <b>Real(F)</b>.&nbsp; This
is an estimate of the amplitude, if any, of the cosine component with the
matching frequency contained in the time series <b>x(n)</b>.</li>
     <li> Multiply <b>x(n)</b> by <b>sin(n)</b> and compute the sum of the
 products.&nbsp;  Save this value, calling it <b>Imag(f)</b>.&nbsp; This
is an estimate of the amplitude, if any, of the sine component with the matching 
frequency contained in the time series <b>x(n)</b>.</li>
   <li>Consider the values for <b>Real(F)</b> and <b>Imag(F)</b> to be the 
real and imaginary parts of a complex number.</li>
   <li>Consider the sum of the squares of the real and imaginary parts to 
represent the power at that frequency in the time series.</li>
	<li>Consider the square root of the power to be the amplitude at that 
	frequency in the time series.&nbsp; <i>(This is the value that is plotted in 
	Figure 9, Figure 11, and Figure 14.)</i></li>
       
</ul>
    <font color="#FF0000"><b>Compute the complex energy at each frequency</b></font><p>That is all there is to it.&nbsp; For each frequency of interest, you 
can  use this process to compute a complex number, <b>Real(F)-jImag(F)</b>, 
which  represents the complex energy corresponding to that frequency in the target time series.</p>
<p>Similarly, you can compute the sum of the squares of the real and imaginary 
parts and consider that to be a measure of the power at that frequency in 
the time series.&nbsp; The square root of the power is the amplitude of the 
energy at that frequency.</p>
<p><font color="#FF0000"><b>Nested for loops</b></font></p>
<p>Normally we are interested in more than one frequency, so we would repeat
  the above procedure once for each frequency of interest.&nbsp; This suggests 
the use of nested <b>for</b> loops in the algorithm.&nbsp; The outer loop 
specifies the frequency of interest.&nbsp; The inner loop computes the sum of 
the products at a particular frequency.</p>
<p><font color="#FF0000"><b>Description of the transform method</b></font></p>
<p>The static method named <b>transform</b> performs a real
to complex Fourier transform.&nbsp; The method does not implement the FFT algorithm.&nbsp; 
Rather, it implements
a straightforward sampled data version of the
continuous Fourier transform defined using
integral calculus.&nbsp; <i>(See ForwardRealToComplexFFT01
for an FFT algorithm.)</i></p>
<p><font color="#FF0000"><b>The return values</b></font></p>
<p>The method returns the following:</p>
<ul>
	<li>Real part of the spectral analysis result</li>
	<li>Imaginary part of the spectral analysis result</li>
	<li>Magnitude of the spectral analysis result</li>
	<li>Phase angle of the spectral analysis result in degrees</li>
</ul>
<p><font color="#FF0000"><b>The transform method parameters</b></font></p>
<p>The method parameters are: </p>
<ul>
	<li>double[] data - incoming real data </li>
	<li>double[] realOut - outgoing real data </li>
	<li>double[] imagOut - outgoing imaginary data </li>
	<li>double[] angleOut - outgoing phase angle in degrees </li>
	<li>double[] magnitude - outgoing amplitude spectrum </li>
	<li>int zero - the index of the incoming data
sample that represents zero time </li>
	<li>double lowF - low frequency limit for computation as a fraction of
sampling frequency </li>
	<li>double highF - high frequency limit for computation as a fraction of
sampling frequency&nbsp; </li>
</ul>
<p><font color="#FF0000"><b>Frequency increment, magnitude spectrum, and number 
of returned values</b></font></p>
<p>The computational frequency increment is the difference between the
high and low limits divided by the length of
the magnitude array.</p>
<p>The magnitude or amplitude is computed as the square root of
the sum of the squares of the real and imaginary
parts.&nbsp; This value is divided by the incoming
data length, which is given by <b>data.length</b>.</p>
<p>The method returns a number of points in the frequency
domain equal to the incoming data length
regardless of the high and low frequency
limits.</p>
<p><font color="#FF0000"><b>The beginning of the transform method</b></font></p>
<p>The class and the <b>transform</b> method begin in Listing 14.&nbsp; The code 
in Listing 14 is described above.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
public class ForwardRealToComplex01{

  public static void transform(
                              double[] data,
                              double[] realOut,
                              double[] imagOut,
                              double[] angleOut,
                              double[] magnitude,
                              int zero,
                              double lowF,
                              double highF){
    double pi = Math.PI;//for convenience
    int dataLen = data.length;
    double delF = (highF-lowF)/data.length;

<b>Listing 14</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The remainder of the method and the class</b></font></p>
<p>The nested <b>for</b> loops discussed above are included in the code shown in 
Listing 15.&nbsp; As suggested above, the outer loop iterates on frequency while 
the inner loop iterates on the values that make up the incoming samples.&nbsp; 
The code in the inner loop computes the sum of the product of the time series 
and the reference cosine and sine functions.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i < dataLen;i++){
      double freq = lowF + i*delF;
      double real = 0.0;
      double imag = 0.0;
      double ang = 0.0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j < dataLen; j++){
        real += data[j]*Math.cos(
                             2*pi*freq*(j-zero));
        imag += data[j]*Math.sin(
                             2*pi*freq*(j-zero));
      }//end inner loop
      
      realOut[i] = real/dataLen;
      imagOut[i] = imag/dataLen;
      magnitude[i] = (Math.sqrt(
                 real*real + imag*imag))/dataLen;

      //Calculate and return the phase
      // angle in degrees.
      if(imag == 0.0 && real == 0.0){ang = 0.0;}
      else{ang = Math.atan(imag/real)*180.0/pi;}

      if(real < 0.0 && imag == 0.0){ang = 180.0;}
      else if(real < 0.0 && imag == -0.0){
                                   ang = -180.0;}
      else if(real < 0.0 && imag > 0.0){
                                   ang += 180.0;}
      else if(real < 0.0 && imag < 0.0){
                                  ang += -180.0;}
      angleOut[i] = ang;
    }//end outer loop
  }//end transform method

}//end class ForwardRealToComplex01

<b>Listing 15</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Store results in output array objects</b></font></p>
<p>At the end of each iteration of the inner loop, code in the outer loop 
deposits the real, imaginary, magnitude, and phase angle results in the output 
array objects.&nbsp; To accomplish this, the code:</p>
<ul>
	<li>Computes the magnitude or amplitude as the square root of the sum of the 
	squares of the real and imaginary parts.</li>
	<li>Performs some trigonometry operations to determine the phase angle in 
	degrees based on the values of the real and imaginary parts.</li>
</ul>
<p><font color="#FF0000"><b>Now you know about the DFT algorithm</b></font></p>
<p>Now you know about the DFT algorithm.&nbsp; You also know about some of the 
fundamental aspects of spectral analysis involving the sampling frequency and the 
folding frequency.</p>
<p>Future lessons will discuss other aspects of spectral analysis including:</p>
<ul>
	<li>Frequency resolution versus data length.</li>
	<li>The relationship between the phase angle and delays in the time domain.</li>
	<li>The reversible nature of the Fourier transform involving both forward 
	and inverse Fourier transforms.</li>
</ul>
<h3><a name="Spectral_Analysis_using_an_FFT_Algorithm">Spectral Analysis using 
an FFT Algorithm</a></h3>
<p>At this point, I will present a similar spectral 
analysis program that uses an FFT algorithm.&nbsp; I will present this program 
with very little discussion.&nbsp; I am providing it in this lesson for two primary purposes:</p>
<ul>
	<li>To allow you to experiment and appreciate the flexibility of the DFT as compared to the 
	FFT.</li>
	<li>To allow you to experiment and appreciate the speed of the FFT as compared to the DFT.</li>
</ul>
<p><font color="#FF0000"><b>The program named Dsp030</b></font></p>
<p>The program named<b> Dsp030 </b>is very similar to <b>Dsp028</b>.&nbsp; The major differences 
are:</p>
<ul>
	<li>Because it uses an FFT algorithm, <b>Dsp030</b> is much less flexible 
	than <b>Dsp028</b>, particularly with respect to data length and selection 
	of the frequencies of interest.</li>
	<li>Because it uses an FFT algorithm, <b>Dsp030</b> is much faster than <b>
	Dsp028</b>, particularly when used to perform spectral analysis on long data 
	lengths.</li>
</ul>
<p>A complete listing of <b>Dsp030</b> is provided in Listing 22.</p>
<p><font color="#FF0000"><b>Description of the program named Dsp030</b></font></p>
<p>This program uses an FFT algorithm to compute and display the
magnitude of the spectral content for up to five
sinusoids having different frequencies and
amplitudes.&nbsp; <i>(See the program named <b>Dsp028</b> for a program that
does not use an FFT algorithm.)</i></p>
<p><font color="#FF0000"><b>The input parameters</b></font></p>
<p>The program gets input parameters from a file named <b>Dsp030.txt</b>. If that file doesn't exist in the
current directory, the program uses a set of
default parameters.</p>
<p>Each parameter value must be stored as characters
on a separate line in the file named <b>Dsp030.txt</b>.&nbsp;
The required input parameters are shown in Figure 16.&nbsp; <i>(Contrast this 
with the required input parameters for <b>Dsp028</b> shown in Figure mm.)</i></p><p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<b>Data length as type int
Number of spectra as type int. Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.</b>

<b>Figure 16 Required input parameters for Dsp030.</b>
</pre></td></tr></tbody></table></p>
<p>Note in contrast with Figure mm, the required input parameters for <b>Dsp030</b> 
do not include the sample number representing zero time, the lower frequency 
bound for computation of the spectra, and the upper frequency bound for 
computation of the spectra.</p>
<blockquote>
	<p><i>(The computational frequency range cannot be 
specified for the FFT algorithm.&nbsp; It always computes the spectra from zero 
to one unit less than the sampling frequency.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Restrictions on the data length</b></font></p>
<p>Note also that the data length must always be a power of two.&nbsp; Otherwise, the 
FFT algorithm will fail to run properly.</p>
<blockquote>
	<p><i>(This restriction is an important contributor to the speed achieved by the 
	FFT algorithm.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The sinusoidal frequency values</b></font></p>
<p>As with <b>Dsp028</b>,<b> </b>the number of values in each of the lists must
match the value for the number of spectra.</p>
<p>All frequency values are specified as a <b>double</b> representing a 
fractional part of the sampling frequency.</p>
<p>Figure 17 shows the parameters used to produce the spectral analysis plots 
shown later in Figure 18.</p>
<blockquote>
	<p><i>(Note that the data length is a power of two as 
required by the FFT.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
256
5
0.1
0.2
0.3
0.5
0.005
90
90
90
90
90

<b>Figure 17</b>
</pre></td></tr></tbody></table></p>
<p><font color="#FF0000"><b>The plotting program</b></font></p>
<p>The plotting program that is used to plot the
output data from this program requires that the
program implement <b>GraphIntfc01</b>. For example,
the plotting program named <b>Graph03</b> can be used
to plot the data produced by this program. This requires that you enter the 
following at the command line prompt:</p>
<p><b><font face="Arial Narrow">java Graph03 Dsp030</font></b></p>

<p>The plotting program named Graph06 can also be used to plot the data produced 
by this program, requiring that you enter the following at the command line 
prompt:</p>
<p><b><font face="Arial Narrow">java Graph06 Dsp030</font></b></p>

<p><font color="#FF0000"><b>The transform method</b></font></p>
<p>A static method named <b>transform</b> belonging to the
class named <b>ForwardRealToComplexFFT01</b> is used to
perform the actual spectral analysis. The method
named <b>transform</b> implements an FFT algorithm. The
FFT algorithm requires that the data length be
a power of two.&nbsp; This method will be discussed very briefly later.</p>
</p><p><font color="#FF0000"><b>A sample FFT spectral analysis</b></font></p><p>
The output produced by running <b>Dsp030</b> using the input parameters shown in 
Figure 17 is shown in Figure 18.</p><p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a7.jpg" width="409" height="431">

<b>Figure 18 FFT of five sinusoids.</b>
</pre></td></tr></tbody></table></p><p><font color="#FF0000"><b>Nothing special 
here</b></font></p>
<p>There is nothing special about this 
particular spectral analysis.&nbsp; I presented it here to illustrate the use of 
the FFT algorithm for spectral analysis.&nbsp; You should be able to produce the same results 
using the same program and the same parameters.</p>
<p><font color="#FF0000"><b>A matching DFT spectral analysis</b></font></p>
<p>Figure 19 shows the parameters required for the program named <b>Dsp028</b> 
to perform a DFT spectral analysis producing the same results as those produced 
by the FFT analysis shown in Figure 18.&nbsp; Note that the data length has been 
set to 256 and the computational frequency range extends from zero to the 
sampling frequency in Figure 19.</p><p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
Data length: 256
Sample for zero time: 0
Lower frequency bound: 0.0
Upper frequency bound: 1.0
Number spectra: 5
Frequencies
0.1
0.2
0.3
0.5
0.0050
Amplitudes
90.0
90.0
90.0
90.0
90.0

<b>Figure 19</b>
</pre></td></tr></tbody></table></p><p><font color="#FF0000"><b>The matching DFT 
output</b></font></p>
<p>The DFT output produced by running <b>Dsp028</b> with the parameters shown in 
Figure 19 is shown in Figure 20.</p><p>
<table border="1" cols="1" width="400" bgcolor="#99FFCC">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java1482a8.jpg" width="409" height="431">

<b>Figure 20 DFT of five sinusoids.</b>
</pre></td></tr></tbody></table></p><p>Hopefully you noticed that Figure 20 
looks almost exactly like Figure 18.&nbsp; This is how it should be.&nbsp; The DFT 
algorithm and the FFT algorithm are simply two different algorithms for 
computing the same results.&nbsp; However, the DFT algorithm is much more 
flexible than the FFT algorithm 
while the FFT algorithm is much faster than the DFT algorithm.</p>
<p><font color="#FF0000"><b>Repeat these two experiments</b></font></p>
<p>I recommend that you repeat these two experiments several times increasing 
the data length to a higher power of two each time you run the experiments.</p>
<p>On my machine, the DFT algorithm used by <b>Dsp028 </b>becomes noticeably 
slow by the time the data length reaches 2048 samples.&nbsp; However, the FFT 
algorithm used by <b>Dsp030 </b>is still reasonably responsive at a data length 
of 131,072 samples.</p>
<blockquote>
	<p><i>(Performing the DFT on five input samples each having a data length of 
	131,072 samples would require an intolerably long time on my machine.)</i></p>
</blockquote>
<p>If what you need is speed for long data lengths, the FFT is your best 
approach.&nbsp; On the other hand, if you need more flexibility than the FFT 
provides and the data length is not too long, then the DFT may be your best 
approach.</p>
<p><font color="#FF0000"><b>The ForwardRealToComplexFFT01 class</b></font></p>
<p>The <b>ForwardRealToComplexFFT01</b> class containing the method that 
implements the FFT algorithm is provided in Listing 23 near the end of this 
lesson.&nbsp; </p>
<p>The FFT algorithm is based on some very complicated signal processing 
concepts.&nbsp; I'm not going to explain how this algorithm works in this lesson 
because I haven't given you the proper background for understanding it.&nbsp; I 
plan to explain additional signal processing concepts in future lessons that 
will prepare you to understand how the FFT algorithm works.</p>
<p>Fortunately, you don't have to understand how the FFT algorithm works to be able to use it.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Programs</a></h2><p>I encourage you to copy, compile, and run the programs provided in this lesson.&nbsp; 
Experiment with them, making changes and observing the results of your changes.</p><p>I suggest that you begin by compiling and running the following files to 
confirm that everything is working correctly on your machine before attempting to compile and 
run the spectral analysis programs:</p>
<ul>
	<li>
<b>Dsp029.java</b></li>
	<li>
<b>GraphIntfc01.java</b></li>
	<li>
<b>Graph06.java</b></li>
</ul>
</p><p>Make sure that you create an appropriate file named <b>Dsp029.txt</b>, as 
described in Figure 2.&nbsp; You should be able to reproduce my results if 
everything is working correctly.</p>
<p>Once you confirm that things are working correctly, copy, compile, and run 
the spectral analysis programs.&nbsp; Experiment with the parameters and try to 
understand the result of making changes to the parameters.&nbsp; Confirm the 
flexibility of the DFT algorithm and the speed of the FFT algorithm.</p><h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson I have provided and explained programs that illustrate the 
impact of sampling and the Nyquist folding frequency.</p>
<p>I have also provided and explained several different programs used for 
performing spectral analysis.&nbsp; The first program was a very general program that 
implements a Discrete Fourier Transform <i>(DFT)</i> algorithm.<i>&nbsp; </i>I 
explained this program in detail.</p>
<p>The second program was a less general, but much faster program that 
implements a Fast Fourier Transform <i>(FFT)</i> algorithm.&nbsp; I will defer an 
explanation of this program until a future lesson.&nbsp; I provided it in this lesson 
so that you can use it and compare it with the DFT program in terms of speed and 
flexibility.</p>
<h2 align="center"><a name="Whats_Next">What's Next?</a></h2><p>Future lessons will discuss other aspects of spectral analysis including:</p><ul>
	<li>Frequency resolution versus data length.</li><li>The relationship between the phase angle and delays in the time domain.</li><li>The reversible nature of the Fourier transform involving both forward 
	and inverse Fourier transforms.</li><li>Additional material aimed towards an understanding of the 
	signal processing concepts behind the FFT algorithm.</li></ul><h2 align="center"><a name="Complete_Program_Listings">Complete Program Listings</a></h2><p>
Complete listings of all the programs discussed in this lesson follow.</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp029.java
Copyright 2004, R.G.Baldwin
Rev 5/6/04

Generates and displays up to five sinusoids
having different frequencies and amplitudes. Very
useful for providing a visual illustration of the
way in which frequencies above half the sampling
frequency fold back down into the area bounded
by zero and half the sampling frequency (the
Nyquist folding frequency).

Gets input parameters from a file named
Dsp029.txt.&nbsp; If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp029.txt.
The required parameters are as follows:

Data length as type int
Number of sinusoids as type int.&nbsp; Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

The number of values in each of the lists must
match the value for the number of spectra.

Note:&nbsp; All frequency values are specified as a
double representing a fractional part of the
sampling frequency.

Here is a set of sample parameter values.&nbsp; Don't
allow blank lines at the end of the data in the
file.

400.0
5
0.1
0.9
1.1
1.9
2.1
90
90
90
90
90

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.&nbsp; For example,
the plotting program named Graph06 can be used
to plot the data produced by this program.&nbsp; When
it is used, the usage information is:

java Graph06 Dsp029

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp029 implements GraphIntfc01{
&nbsp; final double pi = Math.PI;//for simplification

&nbsp; //Begin default parameters
&nbsp; int len = 400;//data length
&nbsp; int numberSinusoids = 5;
&nbsp; //Frequencies of the sinusoids
&nbsp; double[] freq = {0.1,0.25,0.5,0.75,0.9};
&nbsp; //Amplitudes of the sinusoids
&nbsp; double[] amp = {75,75,75,75,75};
&nbsp; //End default parameters

&nbsp; //Following arrays will be populated with
&nbsp; // sinusoidal data to be plotted
&nbsp; double[] data1 = new double[len];
&nbsp; double[] data2 = new double[len];
&nbsp; double[] data3 = new double[len];
&nbsp; double[] data4 = new double[len];
&nbsp; double[] data5 = new double[len];

&nbsp; public Dsp029(){//constructor

&nbsp;&nbsp;&nbsp; //Get the parameters from a file named
&nbsp;&nbsp;&nbsp; // Dsp029.txt.&nbsp; Use the default parameters
&nbsp;&nbsp;&nbsp; // if the file doesn't exist in the current
&nbsp;&nbsp;&nbsp; // directory.
&nbsp;&nbsp;&nbsp; if(new File("Dsp029.txt").exists()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getParameters();
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Note that this program always generates
&nbsp;&nbsp;&nbsp; // five sinusoids, even if fewer than five
&nbsp;&nbsp;&nbsp; // were requested as the input parameter
&nbsp;&nbsp;&nbsp; // for numberSinusoids.&nbsp; In that case, the
&nbsp;&nbsp;&nbsp; // extras are generated using default values
&nbsp;&nbsp;&nbsp; // and simply ignored when the results are
&nbsp;&nbsp;&nbsp; // plotted.

&nbsp;&nbsp;&nbsp; //Create the raw data.&nbsp; Note that the
&nbsp;&nbsp;&nbsp; // argument for a sinusoid at half the
&nbsp;&nbsp;&nbsp; // sampling frequency would be (2*pi*x*0.5).
&nbsp;&nbsp;&nbsp; // This would represent one half cycle or pi
&nbsp;&nbsp;&nbsp; // radians per sample.
&nbsp;&nbsp;&nbsp; for(int n = 0;n < len;n++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end constructor
&nbsp; //-------------------------------------------//

&nbsp; //This method gets processing parameters from
&nbsp; // a file named Dsp029.txt and stores those
&nbsp; // parameters in instance variables belonging
&nbsp; // to the object of type Dsp029.
&nbsp; void getParameters(){
&nbsp;&nbsp;&nbsp; int cnt = 0;
&nbsp;&nbsp;&nbsp; //Temporary holding area for strings.&nbsp; Allow
&nbsp;&nbsp;&nbsp; // space for a few blank lines at the end
&nbsp;&nbsp;&nbsp; // of the data in the file.
&nbsp;&nbsp;&nbsp; String[] data = new String[20];
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Open an input stream.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Dsp029.txt"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and save the strings from each of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the lines in the file.&nbsp; Be careful to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // avoid having blank lines at the end,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which may cause an ArrayIndexOutOfBounds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception to be thrown.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((data[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.readLine()) != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; //Move the parameter values from the
&nbsp;&nbsp;&nbsp; // temporary holding array into the instance
&nbsp;&nbsp;&nbsp; // variables, converting from characters to
&nbsp;&nbsp;&nbsp; // numeric values in the process.
&nbsp;&nbsp;&nbsp; cnt = 0;
&nbsp;&nbsp;&nbsp; len = (int)Double.parseDouble(data[cnt++]);
&nbsp;&nbsp;&nbsp; numberSinusoids = (int)Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; for(int fCnt = 0;fCnt < numberSinusoids;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq[fCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; for(int aCnt = 0;aCnt < numberSinusoids;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amp[aCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Print parameter values.
&nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; System.out.println("Data length: " + len);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Number sinusoids: " + numberSinusoids);
&nbsp;&nbsp;&nbsp; System.out.println("Frequencies");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSinusoids;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(freq[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; System.out.println("Amplitudes");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSinusoids;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(amp[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end getParameters
&nbsp; //-------------------------------------------//
&nbsp; //The following six methods are required by the
&nbsp; // interface named GraphIntfc01.&nbsp; The plotting
&nbsp; // program pulls the data values to be plotted
&nbsp; // by invoking these methods.
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to
&nbsp;&nbsp;&nbsp; // process.&nbsp; Must not exceed 5.
&nbsp;&nbsp;&nbsp; return numberSinusoids;
&nbsp; }//end getNmbr
&nbsp; //-------------------------------------------//
&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > data1.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data1[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > data2.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data2[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > data3.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data3[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > data4.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data4[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > data5.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data5[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//

}//end class Dsp029

<b>Listing 16</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File GraphIntfc01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

This interface must be implemented by classes
whose objects produce data to be plotted by
programs such as Graph03 and Graph06.

Tested using SDK 1.4.2 under WinXP.
************************************************/

public interface GraphIntfc01{
&nbsp; public int getNmbr();
&nbsp; public double f1(double x);
&nbsp; public double f2(double x);
&nbsp; public double f3(double x);
&nbsp; public double f4(double x);
&nbsp; public double f5(double x);
}//end GraphIntfc01

<b>Listing 17</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Graph06.java
Copyright 2002, R.G.Baldwin
Revised 5/15/04

Very similar to Graph03, except that
each point is displayed as a
rectangle, centered on the sample.
Can be used to explain integration
through summation of the sample values.

Note:&nbsp; This program requires access to
the interface named GraphIntfc01.

This is a plotting program.&nbsp; It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.&nbsp; The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.&nbsp; If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.&nbsp; For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.&nbsp; It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.&nbsp; A
cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.&nbsp; If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.&nbsp; Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.&nbsp; This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.&nbsp; Depending
on the nature of that class, this may
be redundant in some cases.&nbsp; However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.&nbsp; Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph06{
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{
&nbsp;&nbsp;&nbsp; if(args.length == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pass command-line paramater
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(args[0]);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no command-line parameter given
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(null);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }// end main
}//end class Graph06 definition
//===================================//

class GUI extends JFrame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements ActionListener{

&nbsp; //Define plotting parameters and
&nbsp; // their default values.
&nbsp; double xMin = 0.0;
&nbsp; double xMax = 400.0;
&nbsp; double yMin = -100.0;
&nbsp; double yMax = 100.0;

&nbsp; //Tic mark intervals
&nbsp; double xTicInt = 20.0;
&nbsp; double yTicInt = 20.0;

&nbsp; //Tic mark lengths.&nbsp; If too small
&nbsp; // on x-axis, a default value is
&nbsp; // used later.
&nbsp; double xTicLen = (yMax-yMin)/50;
&nbsp; double yTicLen = (xMax-xMin)/50;

&nbsp; //Calculation interval along x-axis
&nbsp; double xCalcInc = 1.0;

&nbsp; //Text fields for plotting parameters
&nbsp; JTextField xMinTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xMin);
&nbsp; JTextField xMaxTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xMax);
&nbsp; JTextField yMinTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yMin);
&nbsp; JTextField yMaxTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yMax);
&nbsp; JTextField xTicIntTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xTicInt);
&nbsp; JTextField yTicIntTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yTicInt);
&nbsp; JTextField xCalcIncTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xCalcInc);

&nbsp; //Panels to contain a label and a
&nbsp; // text field
&nbsp; JPanel pan0 = new JPanel();
&nbsp; JPanel pan1 = new JPanel();
&nbsp; JPanel pan2 = new JPanel();
&nbsp; JPanel pan3 = new JPanel();
&nbsp; JPanel pan4 = new JPanel();
&nbsp; JPanel pan5 = new JPanel();
&nbsp; JPanel pan6 = new JPanel();

&nbsp; //Misc instance variables
&nbsp; int frmWidth = 408;
&nbsp; int frmHeight = 430;
&nbsp; int width;
&nbsp; int height;
&nbsp; int number;
&nbsp; GraphIntfc01 data;
&nbsp; String args = null;

&nbsp; //Plots are drawn on the canvases
&nbsp; // in this array.
&nbsp; Canvas[] canvases;

&nbsp; //Constructor
&nbsp; GUI(String args)throws
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{

&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save for use later in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ActionEvent handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.args = args;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // target class using the String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name of the class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc01)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(args).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newInstance();
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test class named junk.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; //Create array to hold correct
&nbsp;&nbsp;&nbsp; // number of Canvas objects.
&nbsp;&nbsp;&nbsp; canvases =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Canvas[data.getNmbr()];

&nbsp;&nbsp;&nbsp; //Throw exception if number of
&nbsp;&nbsp;&nbsp; // functions is greater than 5.
&nbsp;&nbsp;&nbsp; number = data.getNmbr();
&nbsp;&nbsp;&nbsp; if(number > 5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NoSuchMethodException(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Too many functions.&nbsp; "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "Only 5 allowed.");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Create the control panel and
&nbsp;&nbsp;&nbsp; // give it a border for cosmetics.
&nbsp;&nbsp;&nbsp; JPanel ctlPnl = new JPanel();
&nbsp;&nbsp;&nbsp; ctlPnl.setLayout(//?rows x 4 cols
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GridLayout(0,4));
&nbsp;&nbsp;&nbsp; ctlPnl.setBorder(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EtchedBorder());

&nbsp;&nbsp;&nbsp; //Button for replotting the graph
&nbsp;&nbsp;&nbsp; JButton graphBtn =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("Graph");
&nbsp;&nbsp;&nbsp; graphBtn.addActionListener(this);

&nbsp;&nbsp;&nbsp; //Populate each panel with a label
&nbsp;&nbsp;&nbsp; // and a text field.&nbsp; Will place
&nbsp;&nbsp;&nbsp; // these panels in a grid on the
&nbsp;&nbsp;&nbsp; // control panel later.
&nbsp;&nbsp;&nbsp; pan0.add(new JLabel("xMin"));
&nbsp;&nbsp;&nbsp; pan0.add(xMinTxt);

&nbsp;&nbsp;&nbsp; pan1.add(new JLabel("xMax"));
&nbsp;&nbsp;&nbsp; pan1.add(xMaxTxt);

&nbsp;&nbsp;&nbsp; pan2.add(new JLabel("yMin"));
&nbsp;&nbsp;&nbsp; pan2.add(yMinTxt);

&nbsp;&nbsp;&nbsp; pan3.add(new JLabel("yMax"));
&nbsp;&nbsp;&nbsp; pan3.add(yMaxTxt);

&nbsp;&nbsp;&nbsp; pan4.add(new JLabel("xTicInt"));
&nbsp;&nbsp;&nbsp; pan4.add(xTicIntTxt);

&nbsp;&nbsp;&nbsp; pan5.add(new JLabel("yTicInt"));
&nbsp;&nbsp;&nbsp; pan5.add(yTicIntTxt);

&nbsp;&nbsp;&nbsp; pan6.add(new JLabel("xCalcInc"));
&nbsp;&nbsp;&nbsp; pan6.add(xCalcIncTxt);

&nbsp;&nbsp;&nbsp; //Add the populated panels and the
&nbsp;&nbsp;&nbsp; // button to the control panel with
&nbsp;&nbsp;&nbsp; // a grid layout.
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan0);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan1);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan2);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan3);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan4);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan5);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan6);
&nbsp;&nbsp;&nbsp; ctlPnl.add(graphBtn);

&nbsp;&nbsp;&nbsp; //Create a panel to contain the
&nbsp;&nbsp;&nbsp; // Canvas objects.&nbsp; They will be
&nbsp;&nbsp;&nbsp; // displayed in a one-column grid.
&nbsp;&nbsp;&nbsp; JPanel canvasPanel = new JPanel();
&nbsp;&nbsp;&nbsp; canvasPanel.setLayout(//?rows,1 col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GridLayout(0,1));

&nbsp;&nbsp;&nbsp; //Create a custom Canvas object for
&nbsp;&nbsp;&nbsp; // each function to be plotted and
&nbsp;&nbsp;&nbsp; // add them to the one-column grid.
&nbsp;&nbsp;&nbsp; // Make background colors alternate
&nbsp;&nbsp;&nbsp; // between white and gray.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Add the object to the grid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvasPanel.add(canvases[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Add the sub-assemblies to the
&nbsp;&nbsp;&nbsp; // frame.&nbsp; Set its location, size,
&nbsp;&nbsp;&nbsp; // and title, and make it visible.
&nbsp;&nbsp;&nbsp; getContentPane().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(ctlPnl,"South");
&nbsp;&nbsp;&nbsp; getContentPane().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(canvasPanel,"Center");

&nbsp;&nbsp;&nbsp; setBounds(0,0,frmWidth,frmHeight);

&nbsp;&nbsp;&nbsp; if(args == null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph06, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2002, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Richard G. Baldwin");
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph06/" + args +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Copyright 2002, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "R. G. Baldwin");
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Set to exit on X-button click
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; //Guarantee a repaint on startup.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; //This event handler is registered
&nbsp; // on the JButton to cause the
&nbsp; // functions to be replotted.
&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent evt){
&nbsp;&nbsp;&nbsp; //Re-instantiate the object that
&nbsp;&nbsp;&nbsp; // provides the data
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc01)Class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forName(args).newInstance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; }catch(Exception e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Known to be safe at this point.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Otherwise would have aborted
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // earlier.
&nbsp;&nbsp;&nbsp; }//end catch

&nbsp;&nbsp;&nbsp; //Set plotting parameters using
&nbsp;&nbsp;&nbsp; // data from the text fields.
&nbsp;&nbsp;&nbsp; xMin = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xMinTxt.getText());
&nbsp;&nbsp;&nbsp; xMax = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xMaxTxt.getText());
&nbsp;&nbsp;&nbsp; yMin = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yMinTxt.getText());
&nbsp;&nbsp;&nbsp; yMax = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yMaxTxt.getText());
&nbsp;&nbsp;&nbsp; xTicInt = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; yTicInt = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; xCalcInc = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xCalcIncTxt.getText());

&nbsp;&nbsp;&nbsp; //Calculate new values for the
&nbsp;&nbsp;&nbsp; // length of the tic marks on the
&nbsp;&nbsp;&nbsp; // axes.&nbsp; If too small on x-axis,
&nbsp;&nbsp;&nbsp; // a default value is used later.
&nbsp;&nbsp;&nbsp; xTicLen = (yMax-yMin)/50;
&nbsp;&nbsp;&nbsp; yTicLen = (xMax-xMin)/50;

&nbsp;&nbsp;&nbsp; //Repaint the plotting areas
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end actionPerformed
&nbsp; //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
&nbsp; int cnt;//object number
&nbsp; //Factors to convert from double
&nbsp; // values to integer pixel locations.
&nbsp; double xScale;
&nbsp; double yScale;

&nbsp; MyCanvas(int cnt){//save obj number
&nbsp;&nbsp;&nbsp; this.cnt = cnt;
&nbsp; }//end constructor

&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){
&nbsp;&nbsp;&nbsp; //Get and save the size of the
&nbsp;&nbsp;&nbsp; // plotting surface
&nbsp;&nbsp;&nbsp; width = canvases[0].getWidth();
&nbsp;&nbsp;&nbsp; height = canvases[0].getHeight();

&nbsp;&nbsp;&nbsp; //Calculate the scale factors
&nbsp;&nbsp;&nbsp; xScale = width/(xMax-xMin);
&nbsp;&nbsp;&nbsp; yScale = height/(yMax-yMin);

&nbsp;&nbsp;&nbsp; //Set the origin based on the
&nbsp;&nbsp;&nbsp; // minimum values in x and y
&nbsp;&nbsp;&nbsp; g.translate((int)((0-xMin)*xScale),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((0-yMin)*yScale));
&nbsp;&nbsp;&nbsp; drawAxes(g);//Draw the axes
&nbsp;&nbsp;&nbsp; g.setColor(Color.BLACK);

&nbsp;&nbsp;&nbsp; //Get initial data values
&nbsp;&nbsp;&nbsp; double xVal = xMin;
&nbsp;&nbsp;&nbsp; int oldX = getTheX(xVal);
&nbsp;&nbsp;&nbsp; int oldY = 0;
&nbsp;&nbsp;&nbsp; //Use the Canvas obj number to
&nbsp;&nbsp;&nbsp; // determine which method to
&nbsp;&nbsp;&nbsp; // invoke to get the value for y.
&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp; }//end switch

&nbsp;&nbsp;&nbsp; //Now loop and plot the points
&nbsp;&nbsp;&nbsp; while(xVal < xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int yVal = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get next data value.&nbsp; Use the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Canvas obj number to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // determine which method to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // invoke to get the value for y.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch1


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Convert the x-value to an int
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and draw the next horizontal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line segment

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = getTheX(xVal+xCalcInc/2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(oldX,yVal,x,yVal);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw a vertical line at the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // old x-value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int yZero = getTheY(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(oldX,yZero,oldX,yVal);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw a vertical line at the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // new y-value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,yZero,x,yVal);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Increment along the x-axis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xVal += xCalcInc;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save end point to use as start
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point for next line segment.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldX = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = yVal;
&nbsp;&nbsp;&nbsp; }//end while loop

&nbsp; }//end overridden paint method
&nbsp; //---------------------------------//

&nbsp; //Method to draw axes with tic marks
&nbsp; // and labels in the color RED
&nbsp; void drawAxes(Graphics g){
&nbsp;&nbsp;&nbsp; g.setColor(Color.RED);

&nbsp;&nbsp;&nbsp; //Lable left x-axis and bottom
&nbsp;&nbsp;&nbsp; // y-axis.&nbsp; These are the easy
&nbsp;&nbsp;&nbsp; // ones.&nbsp; Separate the labels from
&nbsp;&nbsp;&nbsp; // the ends of the tic marks by
&nbsp;&nbsp;&nbsp; // two pixels.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMin,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMin,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMin));

&nbsp;&nbsp;&nbsp; //Label the right x-axis and the
&nbsp;&nbsp;&nbsp; // top y-axis.&nbsp; These are the hard
&nbsp;&nbsp;&nbsp; // ones because the position must
&nbsp;&nbsp;&nbsp; // be adjusted by the font size and
&nbsp;&nbsp;&nbsp; // the number of characters.
&nbsp;&nbsp;&nbsp; //Get the width of the string for
&nbsp;&nbsp;&nbsp; // right end of x-axis and the
&nbsp;&nbsp;&nbsp; // height of the string for top of
&nbsp;&nbsp;&nbsp; // y-axis
&nbsp;&nbsp;&nbsp; //Create a string that is an
&nbsp;&nbsp;&nbsp; // integer representation of the
&nbsp;&nbsp;&nbsp; // label for the right end of the
&nbsp;&nbsp;&nbsp; // x-axis.&nbsp; Then get a character
&nbsp;&nbsp;&nbsp; // array that represents the
&nbsp;&nbsp;&nbsp; // string.
&nbsp;&nbsp;&nbsp; int xMaxInt = (int)xMax;
&nbsp;&nbsp;&nbsp; String xMaxStr = "" + xMaxInt;
&nbsp;&nbsp;&nbsp; char[] array = xMaxStr.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toCharArray();

&nbsp;&nbsp;&nbsp; //Get a FontMetrics object that can
&nbsp;&nbsp;&nbsp; // be used to get the size of the
&nbsp;&nbsp;&nbsp; // string in pixels.
&nbsp;&nbsp;&nbsp; FontMetrics fontMetrics =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.getFontMetrics();
&nbsp;&nbsp;&nbsp; //Get a bounding rectangle for the
&nbsp;&nbsp;&nbsp; // string
&nbsp;&nbsp;&nbsp; Rectangle2D r2d =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fontMetrics.getStringBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array,0,array.length,g);
&nbsp;&nbsp;&nbsp; //Get the width and the height of
&nbsp;&nbsp;&nbsp; // the bounding rectangle.&nbsp; The
&nbsp;&nbsp;&nbsp; // width is the width of the label
&nbsp;&nbsp;&nbsp; // at the right end of the
&nbsp;&nbsp;&nbsp; // x-axis.&nbsp; The height applies to
&nbsp;&nbsp;&nbsp; // all the labels, but is needed
&nbsp;&nbsp;&nbsp; // specifically for the label at
&nbsp;&nbsp;&nbsp; // the top end of the y-axis.
&nbsp;&nbsp;&nbsp; int labWidth =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2d.getWidth());
&nbsp;&nbsp;&nbsp; int labHeight =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2d.getHeight());

&nbsp;&nbsp;&nbsp; //Label the positive x-axis and the
&nbsp;&nbsp;&nbsp; // positive y-axis using the width
&nbsp;&nbsp;&nbsp; // and height from above to
&nbsp;&nbsp;&nbsp; // position the labels.&nbsp; These
&nbsp;&nbsp;&nbsp; // labels apply to the very ends of
&nbsp;&nbsp;&nbsp; // the axes at the edge of the
&nbsp;&nbsp;&nbsp; // plotting surface.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMax,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMax)-labWidth,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMax,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax)+labHeight);

&nbsp;&nbsp;&nbsp; //Draw the axes
&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(xMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMax),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(0.0));

&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax));

&nbsp;&nbsp;&nbsp; //Draw the tic marks on axes
&nbsp;&nbsp;&nbsp; xTics(g);
&nbsp;&nbsp;&nbsp; yTics(g);
&nbsp; }//end drawAxes

&nbsp; //---------------------------------//

&nbsp; //Method to draw tic marks on x-axis
&nbsp; void xTics(Graphics g){
&nbsp;&nbsp;&nbsp; double xDoub = 0;
&nbsp;&nbsp;&nbsp; int x = 0;

&nbsp;&nbsp;&nbsp; //Get the ends of the tic marks.
&nbsp;&nbsp;&nbsp; int topEnd = getTheY(xTicLen/2);
&nbsp;&nbsp;&nbsp; int bottomEnd =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(-xTicLen/2);

&nbsp;&nbsp;&nbsp; //If the vertical size of the
&nbsp;&nbsp;&nbsp; // plotting area is small, the
&nbsp;&nbsp;&nbsp; // calculated tic size may be too
&nbsp;&nbsp;&nbsp; // small.&nbsp; In that case, set it to
&nbsp;&nbsp;&nbsp; // 10 pixels.
&nbsp;&nbsp;&nbsp; if(topEnd < 5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topEnd = 5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bottomEnd = -5;
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short
&nbsp;&nbsp;&nbsp; // lines to serve as tic marks.
&nbsp;&nbsp;&nbsp; // Begin with the positive x-axis
&nbsp;&nbsp;&nbsp; // moving to the right from zero.
&nbsp;&nbsp;&nbsp; while(xDoub < xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub += xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative x-axis moving
&nbsp;&nbsp;&nbsp; // to the left from zero
&nbsp;&nbsp;&nbsp; xDoub = 0;
&nbsp;&nbsp;&nbsp; while(xDoub > xMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub -= xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end xTics
&nbsp; //---------------------------------//

&nbsp; //Method to draw tic marks on y-axis
&nbsp; void yTics(Graphics g){
&nbsp;&nbsp;&nbsp; double yDoub = 0;
&nbsp;&nbsp;&nbsp; int y = 0;
&nbsp;&nbsp;&nbsp; int rightEnd = getTheX(yTicLen/2);
&nbsp;&nbsp;&nbsp; int leftEnd = getTheX(-yTicLen/2);

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short
&nbsp;&nbsp;&nbsp; // lines to serve as tic marks.
&nbsp;&nbsp;&nbsp; // Begin with the positive y-axis
&nbsp;&nbsp;&nbsp; // moving up from zero.
&nbsp;&nbsp;&nbsp; while(yDoub < yMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub += yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative y-axis moving
&nbsp;&nbsp;&nbsp; // down from zero.
&nbsp;&nbsp;&nbsp; yDoub = 0;
&nbsp;&nbsp;&nbsp; while(yDoub > yMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub -= yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end yTics

&nbsp; //---------------------------------//

&nbsp; //This method translates and scales
&nbsp; // a double y value to plot properly
&nbsp; // in the integer coordinate system.
&nbsp; // In addition to scaling, it causes
&nbsp; // the positive direction of the
&nbsp; // y-axis to be from bottom to top.
&nbsp; int getTheY(double y){
&nbsp;&nbsp;&nbsp; double yDoub = (yMax+yMin)-y;
&nbsp;&nbsp;&nbsp; int yInt = (int)(yDoub*yScale);
&nbsp;&nbsp;&nbsp; return yInt;
&nbsp; }//end getTheY
&nbsp; //---------------------------------//

&nbsp; //This method scales a double x value
&nbsp; // to plot properly in the integer
&nbsp; // coordinate system.
&nbsp; int getTheX(double x){
&nbsp;&nbsp;&nbsp; return (int)(x*xScale);
&nbsp; }//end getTheX
&nbsp; //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.&nbsp; Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to
&nbsp;&nbsp;&nbsp; // process.&nbsp; Must not exceed 5.
&nbsp;&nbsp;&nbsp; return 4;
&nbsp; }//end getNmbr

&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; return (x*x*x)/200.0;
&nbsp; }//end f1

&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; return -(x*x*x)/200.0;
&nbsp; }//end f2

&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; return (x*x)/200.0;
&nbsp; }//end f3

&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; return 50*Math.cos(x/10.0);
&nbsp; }//end f4

&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/20.0);
&nbsp; }//end f5

}//end sample class junk

<b>Listing 18</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp028.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

Computes and displays the magnitude of the
spectral content for up to five sinusoids having
different frequencies and amplitudes.

Gets input parameters from a file named
Dsp028.txt.&nbsp; If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp028.txt.
The required parameters are as follows:

Data length as type int
Sample number representing zero time as type int
Lower frequency bound as type double (See note)
Upper frequency bound as type double
Number of spectra as type int.&nbsp; Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

The number of values in each of the lists must
match the value for the number of spectra.

Note:&nbsp; All frequency values are specified as a
double representing a fractional part of the
sampling frequency.&nbsp; For example, a value of 0.5
specifies a frequency that is half the sampling
frequency.

Here is a set of sample parameter values.&nbsp; Don't
allow blank lines at the end of the data in the
file.

400
0
0.0
1.0
5
0.1
0.2
0.3
0.4
0.45
60
70
80
90
100

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.&nbsp; For example,
the plotting program named Graph03 can be used
to plot the data produced by this program.&nbsp; When
it is used, the usage information is:

java Graph03 Dsp028

A static method named transform belonging to the
class named ForwardRealToComplex01 is used to
perform the actual spectral analysis.&nbsp; The
method named transform does not implement an FFT
algorithm.&nbsp; Rather, it is more general than, but
much slower than an FFT algorithm.&nbsp; (See the
program named Dsp030 for the use of an FFT
algorithm.)

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp028 implements GraphIntfc01{
&nbsp; final double pi = Math.PI;//for simplification

&nbsp; //Begin default parameters
&nbsp; int len = 400;//data length
&nbsp; //Sample that represents zero time.
&nbsp; int zeroTime = 0;
&nbsp; //Low and high frequency limits for the
&nbsp; // spectral analysis.
&nbsp; double lowF = 0.0;
&nbsp; double highF = 1.0;
&nbsp; int numberSpectra = 5;
&nbsp; //Frequencies of the sinusoids
&nbsp; double[] freq = {0.1,0.2,0.3,0.4,0.5};
&nbsp; //Amplitudes of the sinusoids
&nbsp; double[] amp = {60,70,80,90,100};
&nbsp; //End default parameters

&nbsp; //Following arrays will contain data that is
&nbsp; // input to the spectral analysis process.
&nbsp; double[] data1;
&nbsp; double[] data2;
&nbsp; double[] data3;
&nbsp; double[] data4;
&nbsp; double[] data5;

&nbsp; //Following arrays receive information back
&nbsp; // from the spectral analysis that is not used
&nbsp; // in this program.
&nbsp; double[] real;
&nbsp; double[] imag;
&nbsp; double[] angle;

&nbsp; //Following arrays receive the magnitude
&nbsp; // spectral information back from the spectral
&nbsp; // analysis process.
&nbsp; double[] magnitude1;
&nbsp; double[] magnitude2;
&nbsp; double[] magnitude3;
&nbsp; double[] magnitude4;
&nbsp; double[] magnitude5;

&nbsp; public Dsp028(){//constructor

&nbsp;&nbsp;&nbsp; //Get the parameters from a file named
&nbsp;&nbsp;&nbsp; // Dsp028.txt.&nbsp; Use the default parameters
&nbsp;&nbsp;&nbsp; // if the file doesn't exist in the current
&nbsp;&nbsp;&nbsp; // directory.
&nbsp;&nbsp;&nbsp; if(new File("Dsp028.txt").exists()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getParameters();
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Note that this program always processes
&nbsp;&nbsp;&nbsp; // five sinusoids, even if fewer than five
&nbsp;&nbsp;&nbsp; // were requested as the input parameter
&nbsp;&nbsp;&nbsp; // for numberSpectra.&nbsp; In that case, the
&nbsp;&nbsp;&nbsp; // extras are processed using default values
&nbsp;&nbsp;&nbsp; // and simply ignored when the results are
&nbsp;&nbsp;&nbsp; // plotted.

&nbsp;&nbsp;&nbsp; //Create the raw data.&nbsp; Note that the
&nbsp;&nbsp;&nbsp; // argument for a sinusoid at half the
&nbsp;&nbsp;&nbsp; // sampling frequency would be (2*pi*x*0.5).
&nbsp;&nbsp;&nbsp; // This would represent one half cycle or pi
&nbsp;&nbsp;&nbsp; // radians per sample.
&nbsp;&nbsp;&nbsp; //First create empty array objects.
&nbsp;&nbsp;&nbsp; double[] data1 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data2 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data3 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data4 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data5 = new double[len];
&nbsp;&nbsp;&nbsp; //Now populate the array objects
&nbsp;&nbsp;&nbsp; for(int n = 0;n < len;n++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Compute magnitude spectra of the raw data
&nbsp;&nbsp;&nbsp; // and save it in output arrays.&nbsp; Note that
&nbsp;&nbsp;&nbsp; // the real, imag, and angle arrays are not
&nbsp;&nbsp;&nbsp; // used later, so they are discarded each
&nbsp;&nbsp;&nbsp; // time a new spectral analysis is performed.
&nbsp;&nbsp;&nbsp; magnitude1 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplex01.transform(data1,real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag,angle,magnitude1,zeroTime,lowF,highF);

&nbsp;&nbsp;&nbsp; magnitude2 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplex01.transform(data2,real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag,angle,magnitude2,zeroTime,lowF,highF);

&nbsp;&nbsp;&nbsp; magnitude3 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplex01.transform(data3,real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag,angle,magnitude3,zeroTime,lowF,highF);

&nbsp;&nbsp;&nbsp; magnitude4 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplex01.transform(data4,real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag,angle,magnitude4,zeroTime,lowF,highF);

&nbsp;&nbsp;&nbsp; magnitude5 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplex01.transform(data5,real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag,angle,magnitude5,zeroTime,lowF,highF);
&nbsp; }//end constructor
&nbsp; //-------------------------------------------//

&nbsp; //This method gets processing parameters from
&nbsp; // a file named Dsp028.txt and stores those
&nbsp; // parameters in instance variables belonging
&nbsp; // to the object of type Dsp028.
&nbsp; void getParameters(){
&nbsp;&nbsp;&nbsp; int cnt = 0;
&nbsp;&nbsp;&nbsp; //Temporary holding area for strings.&nbsp; Allow
&nbsp;&nbsp;&nbsp; // space for a few blank lines at the end
&nbsp;&nbsp;&nbsp; // of the data in the file.
&nbsp;&nbsp;&nbsp; String[] data = new String[20];
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Open an input stream.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Dsp028.txt"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and save the strings from each of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the lines in the file.&nbsp; Be careful to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // avoid having blank lines at the end,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which may cause an ArrayIndexOutOfBounds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception to be thrown.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((data[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.readLine()) != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; //Move the parameter values from the
&nbsp;&nbsp;&nbsp; // temporary holding array into the instance
&nbsp;&nbsp;&nbsp; // variables, converting from characters to
&nbsp;&nbsp;&nbsp; // numeric values in the process.
&nbsp;&nbsp;&nbsp; cnt = 0;
&nbsp;&nbsp;&nbsp; len = (int)Double.parseDouble(data[cnt++]);
&nbsp;&nbsp;&nbsp; zeroTime = (int)Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; lowF = Double.parseDouble(data[cnt++]);
&nbsp;&nbsp;&nbsp; highF = Double.parseDouble(data[cnt++]);
&nbsp;&nbsp;&nbsp; numberSpectra = (int)Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; for(int fCnt = 0;fCnt < numberSpectra;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq[fCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; for(int aCnt = 0;aCnt < numberSpectra;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amp[aCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Print parameter values.
&nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; System.out.println("Data length: " + len);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Sample for zero time: " + zeroTime);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Lower frequency bound: " + lowF);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Upper frequency bound: " + highF);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Number spectra: " + numberSpectra);
&nbsp;&nbsp;&nbsp; System.out.println("Frequencies");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSpectra;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(freq[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; System.out.println("Amplitudes");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSpectra;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(amp[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end getParameters
&nbsp; //-------------------------------------------//
&nbsp; //The following six methods are required by the
&nbsp; // interface named GraphIntfc01.&nbsp; The plotting
&nbsp; // program pulls the data values to be plotted
&nbsp; // by invoking these methods.
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to
&nbsp;&nbsp;&nbsp; // process.&nbsp; Must not exceed 5.
&nbsp;&nbsp;&nbsp; return numberSpectra;
&nbsp; }//end getNmbr
&nbsp; //-------------------------------------------//
&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude1.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude1[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude2.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude2[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude3.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude3[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude4.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude4[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude5.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude5[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//

}//end class Dsp028

<b>Listing 19</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Graph03.java
Copyright 2002, R.G.Baldwin

This program is very similar to Graph01
except that it has been modified to
allow the user to manually resize and
replot the frame.

Note:&nbsp; This program requires access to
the interface named GraphIntfc01.

This is a plotting program.&nbsp; It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.&nbsp; The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.&nbsp; If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.&nbsp; For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.&nbsp; It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.&nbsp; A
cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.&nbsp; If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.&nbsp; Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.&nbsp; This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.&nbsp; Depending
on the nature of that class, this may
be redundant in some cases.&nbsp; However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.&nbsp; Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph03{
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{
&nbsp;&nbsp;&nbsp; if(args.length == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pass command-line paramater
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(args[0]);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no command-line parameter given
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GUI(null);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }// end main
}//end class Graph03 definition
//===================================//

class GUI extends JFrame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements ActionListener{

&nbsp; //Define plotting parameters and
&nbsp; // their default values.
&nbsp; double xMin = 0.0;
&nbsp; double xMax = 400.0;
&nbsp; double yMin = -100.0;
&nbsp; double yMax = 100.0;

&nbsp; //Tic mark intervals
&nbsp; double xTicInt = 20.0;
&nbsp; double yTicInt = 20.0;

&nbsp; //Tic mark lengths.&nbsp; If too small
&nbsp; // on x-axis, a default value is
&nbsp; // used later.
&nbsp; double xTicLen = (yMax-yMin)/50;
&nbsp; double yTicLen = (xMax-xMin)/50;

&nbsp; //Calculation interval along x-axis
&nbsp; double xCalcInc = 1.0;

&nbsp; //Text fields for plotting parameters
&nbsp; JTextField xMinTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xMin);
&nbsp; JTextField xMaxTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xMax);
&nbsp; JTextField yMinTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yMin);
&nbsp; JTextField yMaxTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yMax);
&nbsp; JTextField xTicIntTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xTicInt);
&nbsp; JTextField yTicIntTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + yTicInt);
&nbsp; JTextField xCalcIncTxt =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JTextField("" + xCalcInc);

&nbsp; //Panels to contain a label and a
&nbsp; // text field
&nbsp; JPanel pan0 = new JPanel();
&nbsp; JPanel pan1 = new JPanel();
&nbsp; JPanel pan2 = new JPanel();
&nbsp; JPanel pan3 = new JPanel();
&nbsp; JPanel pan4 = new JPanel();
&nbsp; JPanel pan5 = new JPanel();
&nbsp; JPanel pan6 = new JPanel();

&nbsp; //Misc instance variables
&nbsp; int frmWidth = 408;
&nbsp; int frmHeight = 430;
&nbsp; int width;
&nbsp; int height;
&nbsp; int number;
&nbsp; GraphIntfc01 data;
&nbsp; String args = null;

&nbsp; //Plots are drawn on the canvases
&nbsp; // in this array.
&nbsp; Canvas[] canvases;

&nbsp; //Constructor
&nbsp; GUI(String args)throws
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NoSuchMethodException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassNotFoundException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException{

&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save for use later in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ActionEvent handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.args = args;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // target class using the String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name of the class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc01)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(args).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newInstance();
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate an object of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test class named junk.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; //Create array to hold correct
&nbsp;&nbsp;&nbsp; // number of Canvas objects.
&nbsp;&nbsp;&nbsp; canvases =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Canvas[data.getNmbr()];

&nbsp;&nbsp;&nbsp; //Throw exception if number of
&nbsp;&nbsp;&nbsp; // functions is greater than 5.
&nbsp;&nbsp;&nbsp; number = data.getNmbr();
&nbsp;&nbsp;&nbsp; if(number > 5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NoSuchMethodException(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Too many functions.&nbsp; "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "Only 5 allowed.");
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Create the control panel and
&nbsp;&nbsp;&nbsp; // give it a border for cosmetics.
&nbsp;&nbsp;&nbsp; JPanel ctlPnl = new JPanel();
&nbsp;&nbsp;&nbsp; ctlPnl.setLayout(//?rows x 4 cols
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GridLayout(0,4));
&nbsp;&nbsp;&nbsp; ctlPnl.setBorder(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EtchedBorder());

&nbsp;&nbsp;&nbsp; //Button for replotting the graph
&nbsp;&nbsp;&nbsp; JButton graphBtn =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new JButton("Graph");
&nbsp;&nbsp;&nbsp; graphBtn.addActionListener(this);

&nbsp;&nbsp;&nbsp; //Populate each panel with a label
&nbsp;&nbsp;&nbsp; // and a text field.&nbsp; Will place
&nbsp;&nbsp;&nbsp; // these panels in a grid on the
&nbsp;&nbsp;&nbsp; // control panel later.
&nbsp;&nbsp;&nbsp; pan0.add(new JLabel("xMin"));
&nbsp;&nbsp;&nbsp; pan0.add(xMinTxt);

&nbsp;&nbsp;&nbsp; pan1.add(new JLabel("xMax"));
&nbsp;&nbsp;&nbsp; pan1.add(xMaxTxt);

&nbsp;&nbsp;&nbsp; pan2.add(new JLabel("yMin"));
&nbsp;&nbsp;&nbsp; pan2.add(yMinTxt);

&nbsp;&nbsp;&nbsp; pan3.add(new JLabel("yMax"));
&nbsp;&nbsp;&nbsp; pan3.add(yMaxTxt);

&nbsp;&nbsp;&nbsp; pan4.add(new JLabel("xTicInt"));
&nbsp;&nbsp;&nbsp; pan4.add(xTicIntTxt);

&nbsp;&nbsp;&nbsp; pan5.add(new JLabel("yTicInt"));
&nbsp;&nbsp;&nbsp; pan5.add(yTicIntTxt);

&nbsp;&nbsp;&nbsp; pan6.add(new JLabel("xCalcInc"));
&nbsp;&nbsp;&nbsp; pan6.add(xCalcIncTxt);

&nbsp;&nbsp;&nbsp; //Add the populated panels and the
&nbsp;&nbsp;&nbsp; // button to the control panel with
&nbsp;&nbsp;&nbsp; // a grid layout.
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan0);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan1);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan2);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan3);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan4);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan5);
&nbsp;&nbsp;&nbsp; ctlPnl.add(pan6);
&nbsp;&nbsp;&nbsp; ctlPnl.add(graphBtn);

&nbsp;&nbsp;&nbsp; //Create a panel to contain the
&nbsp;&nbsp;&nbsp; // Canvas objects.&nbsp; They will be
&nbsp;&nbsp;&nbsp; // displayed in a one-column grid.
&nbsp;&nbsp;&nbsp; JPanel canvasPanel = new JPanel();
&nbsp;&nbsp;&nbsp; canvasPanel.setLayout(//?rows,1 col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new GridLayout(0,1));

&nbsp;&nbsp;&nbsp; //Create a custom Canvas object for
&nbsp;&nbsp;&nbsp; // each function to be plotted and
&nbsp;&nbsp;&nbsp; // add them to the one-column grid.
&nbsp;&nbsp;&nbsp; // Make background colors alternate
&nbsp;&nbsp;&nbsp; // between white and gray.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].setBackground(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color.LIGHT_GRAY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCanvas(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setBackground(Color.WHITE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Add the object to the grid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvasPanel.add(canvases[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Add the sub-assemblies to the
&nbsp;&nbsp;&nbsp; // frame.&nbsp; Set its location, size,
&nbsp;&nbsp;&nbsp; // and title, and make it visible.
&nbsp;&nbsp;&nbsp; getContentPane().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(ctlPnl,"South");
&nbsp;&nbsp;&nbsp; getContentPane().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(canvasPanel,"Center");

&nbsp;&nbsp;&nbsp; setBounds(0,0,frmWidth,frmHeight);

&nbsp;&nbsp;&nbsp; if(args == null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph03, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2002, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Richard G. Baldwin");
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTitle("Graph03/" + args +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Copyright 2002, " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "R. G. Baldwin");
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; setVisible(true);

&nbsp;&nbsp;&nbsp; //Set to exit on X-button click
&nbsp;&nbsp;&nbsp; setDefaultCloseOperation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT_ON_CLOSE);

&nbsp;&nbsp;&nbsp; //Guarantee a repaint on startup.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; //This event handler is registered
&nbsp; // on the JButton to cause the
&nbsp; // functions to be replotted.
&nbsp; public void actionPerformed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionEvent evt){
&nbsp;&nbsp;&nbsp; //Re-instantiate the object that
&nbsp;&nbsp;&nbsp; // provides the data
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(args != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (GraphIntfc01)Class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forName(args).newInstance();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new junk();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; }catch(Exception e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Known to be safe at this point.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Otherwise would have aborted
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // earlier.
&nbsp;&nbsp;&nbsp; }//end catch

&nbsp;&nbsp;&nbsp; //Set plotting parameters using
&nbsp;&nbsp;&nbsp; // data from the text fields.
&nbsp;&nbsp;&nbsp; xMin = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xMinTxt.getText());
&nbsp;&nbsp;&nbsp; xMax = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xMaxTxt.getText());
&nbsp;&nbsp;&nbsp; yMin = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yMinTxt.getText());
&nbsp;&nbsp;&nbsp; yMax = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yMaxTxt.getText());
&nbsp;&nbsp;&nbsp; xTicInt = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; yTicInt = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yTicIntTxt.getText());
&nbsp;&nbsp;&nbsp; xCalcInc = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xCalcIncTxt.getText());

&nbsp;&nbsp;&nbsp; //Calculate new values for the
&nbsp;&nbsp;&nbsp; // length of the tic marks on the
&nbsp;&nbsp;&nbsp; // axes.&nbsp; If too small on x-axis,
&nbsp;&nbsp;&nbsp; // a default value is used later.
&nbsp;&nbsp;&nbsp; xTicLen = (yMax-yMin)/50;
&nbsp;&nbsp;&nbsp; yTicLen = (xMax-xMin)/50;

&nbsp;&nbsp;&nbsp; //Repaint the plotting areas
&nbsp;&nbsp;&nbsp; for(int cnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt < number; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canvases[cnt].repaint();
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end actionPerformed
&nbsp; //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
&nbsp; int cnt;//object number
&nbsp; //Factors to convert from double
&nbsp; // values to integer pixel locations.
&nbsp; double xScale;
&nbsp; double yScale;

&nbsp; MyCanvas(int cnt){//save obj number
&nbsp;&nbsp;&nbsp; this.cnt = cnt;
&nbsp; }//end constructor

&nbsp; //Override the paint method
&nbsp; public void paint(Graphics g){

&nbsp;&nbsp;&nbsp; //Get and save the size of the
&nbsp;&nbsp;&nbsp; // plotting surface
&nbsp;&nbsp;&nbsp; width = canvases[0].getWidth();
&nbsp;&nbsp;&nbsp; height = canvases[0].getHeight();

&nbsp;&nbsp;&nbsp; //Calculate the scale factors
&nbsp;&nbsp;&nbsp; xScale = width/(xMax-xMin);
&nbsp;&nbsp;&nbsp; yScale = height/(yMax-yMin);

&nbsp;&nbsp;&nbsp; //Set the origin based on the
&nbsp;&nbsp;&nbsp; // minimum values in x and y
&nbsp;&nbsp;&nbsp; g.translate((int)((0-xMin)*xScale),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((0-yMin)*yScale));
&nbsp;&nbsp;&nbsp; drawAxes(g);//Draw the axes
&nbsp;&nbsp;&nbsp; g.setColor(Color.BLACK);

&nbsp;&nbsp;&nbsp; //Get initial data values
&nbsp;&nbsp;&nbsp; double xVal = xMin;
&nbsp;&nbsp;&nbsp; int oldX = getTheX(xVal);
&nbsp;&nbsp;&nbsp; int oldY = 0;
&nbsp;&nbsp;&nbsp; //Use the Canvas obj number to
&nbsp;&nbsp;&nbsp; // determine which method to
&nbsp;&nbsp;&nbsp; // invoke to get the value for y.
&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp; }//end switch

&nbsp;&nbsp;&nbsp; //Now loop and plot the points
&nbsp;&nbsp;&nbsp; while(xVal < xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int yVal = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get next data value.&nbsp; Use the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Canvas obj number to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // determine which method to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // invoke to get the value for y.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(cnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f1(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f2(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f3(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f4(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yVal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(data.f5(xVal));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end switch1

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Convert the x-value to an int
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and draw the next line segment
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = getTheX(xVal);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(oldX,oldY,x,yVal);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Increment along the x-axis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xVal += xCalcInc;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save end point to use as start
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point for next line segment.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldX = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldY = yVal;
&nbsp;&nbsp;&nbsp; }//end while loop

&nbsp; }//end overridden paint method
&nbsp; //---------------------------------//

&nbsp; //Method to draw axes with tic marks
&nbsp; // and labels in the color RED
&nbsp; void drawAxes(Graphics g){
&nbsp;&nbsp;&nbsp; g.setColor(Color.RED);

&nbsp;&nbsp;&nbsp; //Lable left x-axis and bottom
&nbsp;&nbsp;&nbsp; // y-axis.&nbsp; These are the easy
&nbsp;&nbsp;&nbsp; // ones.&nbsp; Separate the labels from
&nbsp;&nbsp;&nbsp; // the ends of the tic marks by
&nbsp;&nbsp;&nbsp; // two pixels.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMin,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMin,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMin));

&nbsp;&nbsp;&nbsp; //Label the right x-axis and the
&nbsp;&nbsp;&nbsp; // top y-axis.&nbsp; These are the hard
&nbsp;&nbsp;&nbsp; // ones because the position must
&nbsp;&nbsp;&nbsp; // be adjusted by the font size and
&nbsp;&nbsp;&nbsp; // the number of characters.
&nbsp;&nbsp;&nbsp; //Get the width of the string for
&nbsp;&nbsp;&nbsp; // right end of x-axis and the
&nbsp;&nbsp;&nbsp; // height of the string for top of
&nbsp;&nbsp;&nbsp; // y-axis
&nbsp;&nbsp;&nbsp; //Create a string that is an
&nbsp;&nbsp;&nbsp; // integer representation of the
&nbsp;&nbsp;&nbsp; // label for the right end of the
&nbsp;&nbsp;&nbsp; // x-axis.&nbsp; Then get a character
&nbsp;&nbsp;&nbsp; // array that represents the
&nbsp;&nbsp;&nbsp; // string.
&nbsp;&nbsp;&nbsp; int xMaxInt = (int)xMax;
&nbsp;&nbsp;&nbsp; String xMaxStr = "" + xMaxInt;
&nbsp;&nbsp;&nbsp; char[] array = xMaxStr.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toCharArray();

&nbsp;&nbsp;&nbsp; //Get a FontMetrics object that can
&nbsp;&nbsp;&nbsp; // be used to get the size of the
&nbsp;&nbsp;&nbsp; // string in pixels.
&nbsp;&nbsp;&nbsp; FontMetrics fontMetrics =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.getFontMetrics();
&nbsp;&nbsp;&nbsp; //Get a bounding rectangle for the
&nbsp;&nbsp;&nbsp; // string
&nbsp;&nbsp;&nbsp; Rectangle2D r2d =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fontMetrics.getStringBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array,0,array.length,g);
&nbsp;&nbsp;&nbsp; //Get the width and the height of
&nbsp;&nbsp;&nbsp; // the bounding rectangle.&nbsp; The
&nbsp;&nbsp;&nbsp; // width is the width of the label
&nbsp;&nbsp;&nbsp; // at the right end of the
&nbsp;&nbsp;&nbsp; // x-axis.&nbsp; The height applies to
&nbsp;&nbsp;&nbsp; // all the labels, but is needed
&nbsp;&nbsp;&nbsp; // specifically for the label at
&nbsp;&nbsp;&nbsp; // the top end of the y-axis.
&nbsp;&nbsp;&nbsp; int labWidth =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2d.getWidth());
&nbsp;&nbsp;&nbsp; int labHeight =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2d.getHeight());

&nbsp;&nbsp;&nbsp; //Label the positive x-axis and the
&nbsp;&nbsp;&nbsp; // positive y-axis using the width
&nbsp;&nbsp;&nbsp; // and height from above to
&nbsp;&nbsp;&nbsp; // position the labels.&nbsp; These
&nbsp;&nbsp;&nbsp; // labels apply to the very ends of
&nbsp;&nbsp;&nbsp; // the axes at the edge of the
&nbsp;&nbsp;&nbsp; // plotting surface.
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)xMax,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMax)-labWidth,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(xTicLen/2)-2);
&nbsp;&nbsp;&nbsp; g.drawString("" + (int)yMax,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(yTicLen/2)+2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax)+labHeight);

&nbsp;&nbsp;&nbsp; //Draw the axes
&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(xMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(xMax),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(0.0));

&nbsp;&nbsp;&nbsp; g.drawLine(getTheX(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMin),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheX(0.0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(yMax));

&nbsp;&nbsp;&nbsp; //Draw the tic marks on axes
&nbsp;&nbsp;&nbsp; xTics(g);
&nbsp;&nbsp;&nbsp; yTics(g);
&nbsp; }//end drawAxes

&nbsp; //---------------------------------//

&nbsp; //Method to draw tic marks on x-axis
&nbsp; void xTics(Graphics g){
&nbsp;&nbsp;&nbsp; double xDoub = 0;
&nbsp;&nbsp;&nbsp; int x = 0;

&nbsp;&nbsp;&nbsp; //Get the ends of the tic marks.
&nbsp;&nbsp;&nbsp; int topEnd = getTheY(xTicLen/2);
&nbsp;&nbsp;&nbsp; int bottomEnd =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getTheY(-xTicLen/2);

&nbsp;&nbsp;&nbsp; //If the vertical size of the
&nbsp;&nbsp;&nbsp; // plotting area is small, the
&nbsp;&nbsp;&nbsp; // calculated tic size may be too
&nbsp;&nbsp;&nbsp; // small.&nbsp; In that case, set it to
&nbsp;&nbsp;&nbsp; // 10 pixels.
&nbsp;&nbsp;&nbsp; if(topEnd < 5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topEnd = 5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bottomEnd = -5;
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short
&nbsp;&nbsp;&nbsp; // lines to serve as tic marks.
&nbsp;&nbsp;&nbsp; // Begin with the positive x-axis
&nbsp;&nbsp;&nbsp; // moving to the right from zero.
&nbsp;&nbsp;&nbsp; while(xDoub < xMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub += xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative x-axis moving
&nbsp;&nbsp;&nbsp; // to the left from zero
&nbsp;&nbsp;&nbsp; xDoub = 0;
&nbsp;&nbsp;&nbsp; while(xDoub > xMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = getTheX(xDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(x,topEnd,x,bottomEnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDoub -= xTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end xTics
&nbsp; //---------------------------------//

&nbsp; //Method to draw tic marks on y-axis
&nbsp; void yTics(Graphics g){
&nbsp;&nbsp;&nbsp; double yDoub = 0;
&nbsp;&nbsp;&nbsp; int y = 0;
&nbsp;&nbsp;&nbsp; int rightEnd = getTheX(yTicLen/2);
&nbsp;&nbsp;&nbsp; int leftEnd = getTheX(-yTicLen/2);

&nbsp;&nbsp;&nbsp; //Loop and draw a series of short
&nbsp;&nbsp;&nbsp; // lines to serve as tic marks.
&nbsp;&nbsp;&nbsp; // Begin with the positive y-axis
&nbsp;&nbsp;&nbsp; // moving up from zero.
&nbsp;&nbsp;&nbsp; while(yDoub < yMax){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub += yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp;&nbsp;&nbsp; //Now do the negative y-axis moving
&nbsp;&nbsp;&nbsp; // down from zero.
&nbsp;&nbsp;&nbsp; yDoub = 0;
&nbsp;&nbsp;&nbsp; while(yDoub > yMin){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = getTheY(yDoub);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine(rightEnd,y,leftEnd,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yDoub -= yTicInt;
&nbsp;&nbsp;&nbsp; }//end while

&nbsp; }//end yTics

&nbsp; //---------------------------------//

&nbsp; //This method translates and scales
&nbsp; // a double y value to plot properly
&nbsp; // in the integer coordinate system.
&nbsp; // In addition to scaling, it causes
&nbsp; // the positive direction of the
&nbsp; // y-axis to be from bottom to top.
&nbsp; int getTheY(double y){
&nbsp;&nbsp;&nbsp; double yDoub = (yMax+yMin)-y;
&nbsp;&nbsp;&nbsp; int yInt = (int)(yDoub*yScale);
&nbsp;&nbsp;&nbsp; return yInt;
&nbsp; }//end getTheY
&nbsp; //---------------------------------//

&nbsp; //This method scales a double x value
&nbsp; // to plot properly in the integer
&nbsp; // coordinate system.
&nbsp; int getTheX(double x){
&nbsp;&nbsp;&nbsp; return (int)(x*xScale);
&nbsp; }//end getTheX
&nbsp; //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.&nbsp; Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to
&nbsp;&nbsp;&nbsp; // process.&nbsp; Must not exceed 5.
&nbsp;&nbsp;&nbsp; return 4;
&nbsp; }//end getNmbr

&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; return (x*x*x)/200.0;
&nbsp; }//end f1

&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; return -(x*x*x)/200.0;
&nbsp; }//end f2

&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; return (x*x)/200.0;
&nbsp; }//end f3

&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; return 50*Math.cos(x/10.0);
&nbsp; }//end f4

&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; return 100*Math.sin(x/20.0);
&nbsp; }//end f5

}//end sample class junk

<b>Listing 20</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ForwardRealToComplex01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

The static method named transform performs a real
to complex Fourier transform.

Does not implement the FFT algorithm. Implements
a straight-forward sampled-data version of the
continuous Fourier transform defined using
integral calculus.&nbsp; See ForwardRealToComplexFFT01
for an FFT algorithm.

Returns real, imag, magnitude, and phase angle in
degrees.

Incoming parameters are:
&nbsp; double[] data - incoming real data
&nbsp; double[] realOut - outgoing real data
&nbsp; double[] imagOut - outgoing imaginary data
&nbsp; double[] angleOut - outgoing phase angle in
&nbsp;&nbsp;&nbsp; degrees
&nbsp; double[] magnitude - outgoing amplitude
&nbsp;&nbsp;&nbsp; spectrum
&nbsp; int zero - the index of the incoming data
&nbsp;&nbsp;&nbsp; sample that represents zero time
&nbsp; double lowF - Low freq limit as fraction of
&nbsp;&nbsp;&nbsp; sampling frequency
&nbsp; double highF - High freq limit as fraction of
&nbsp;&nbsp;&nbsp; sampling frequency

The frequency increment is the difference between
high and low limits divided by the length of
the magnitude array

The magnitude is computed as the square root of
the sum of the squares of the real and imaginary
parts.&nbsp; This value is divided by the incoming
data length, which is given by data.length.

Returns a number of points in the frequency
domain equal to the incoming data length
regardless of the high and low frequency
limits.
************************************************/

public class ForwardRealToComplex01{

&nbsp; public static void transform(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] realOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] imagOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] angleOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] magnitude,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int zero,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double lowF,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double highF){
&nbsp;&nbsp;&nbsp; double pi = Math.PI;//for convenience
&nbsp;&nbsp;&nbsp; int dataLen = data.length;
&nbsp;&nbsp;&nbsp; double delF = (highF-lowF)/data.length;
&nbsp;&nbsp;&nbsp; //Outer loop iterates on frequency
&nbsp;&nbsp;&nbsp; // values.
&nbsp;&nbsp;&nbsp; for(int i=0; i < dataLen;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double freq = lowF + i*delF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double real = 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double imag = 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double ang = 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Inner loop iterates on time-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // series points.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=0; j < dataLen; j++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real += data[j]*Math.cos(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2*pi*freq*(j-zero));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag += data[j]*Math.sin(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2*pi*freq*(j-zero));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; realOut[i] = real/dataLen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagOut[i] = imag/dataLen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magnitude[i] = (Math.sqrt(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real*real + imag*imag))/dataLen;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Calculate and return the phase
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // angle in degrees.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(imag == 0.0 && real == 0.0){ang = 0.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{ang = Math.atan(imag/real)*180.0/pi;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(real < 0.0 && imag == 0.0){ang = 180.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(real < 0.0 && imag == -0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ang = -180.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(real < 0.0 && imag > 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ang += 180.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(real < 0.0 && imag < 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ang += -180.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[i] = ang;
&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp; }//end transform method

}//end class ForwardRealToComplex01

<b>Listing 21</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/* File Dsp030.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

Uses an FFT algorithm to compute and display the
magnitude of the spectral content for up to five
sinusoids having different frequencies and
amplitudes.

See the program named Dsp028 for a program that
does not use an FFT algorithm.

Gets input parameters from a file named
Dsp030.txt.&nbsp; If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp030.txt.
The required parameters are as follows:

Data length as type int
Number of spectra as type int.&nbsp; Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

CAUTION: THE DATA LENGTH MUST BE A POWER OF TWO.
OTHERWISE, THIS PROGRAM WILL FAIL TO RUN
PROPERLY.

The number of values in each of the lists must
match the value for the number of spectra.

Note:&nbsp; All frequency values are specified as a
double representing a fractional part of the
sampling frequency.&nbsp; For example, a value of 0.5
specifies a frequency that is half the sampling
frequency.

Here is a set of sample parameter values.&nbsp; Don't
allow blank lines at the end of the data in the
file.

128.0
5
0.1
0.2
0.3
0.4
0.45
60
70
80
90
100

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.&nbsp; For example,
the plotting program named Graph03 can be used
to plot the data produced by this program.&nbsp; When
it is used, the usage information is:

java Graph03 Dsp030

A static method named transform belonging to the
class named ForwardRealToComplexFFT01 is used to
perform the actual spectral analysis.&nbsp; The method
named transform implements an FFT algorithm.&nbsp; The
FFT algorithm requires that the data length be
a power of two.

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp030 implements GraphIntfc01{
&nbsp; final double pi = Math.PI;//for simplification

&nbsp; //Begin default parameters
&nbsp; int len = 128;//data length
&nbsp; int numberSpectra = 5;
&nbsp; //Frequencies of the sinusoids
&nbsp; double[] freq = {0.1,0.2,0.3,0.4,0.5};
&nbsp; //Amplitudes of the sinusoids
&nbsp; double[] amp = {60,70,80,90,100};
&nbsp; //End default parameters

&nbsp; //Following arrays will contain data that is
&nbsp; // input to the spectral analysis process.
&nbsp; double[] data1;
&nbsp; double[] data2;
&nbsp; double[] data3;
&nbsp; double[] data4;
&nbsp; double[] data5;

&nbsp; //Following arrays receive information back
&nbsp; // from the spectral analysis that is not used
&nbsp; // in this program.
&nbsp; double[] real;
&nbsp; double[] imag;
&nbsp; double[] angle;

&nbsp; //Following arrays receive the magnitude
&nbsp; // spectral information back from the spectral
&nbsp; // analysis process.
&nbsp; double[] magnitude1;
&nbsp; double[] magnitude2;
&nbsp; double[] magnitude3;
&nbsp; double[] magnitude4;
&nbsp; double[] magnitude5;

&nbsp; public Dsp030(){//constructor

&nbsp;&nbsp;&nbsp; //Get the parameters from a file named
&nbsp;&nbsp;&nbsp; // Dsp030.txt.&nbsp; Use the default parameters
&nbsp;&nbsp;&nbsp; // if the file doesn't exist in the current
&nbsp;&nbsp;&nbsp; // directory.
&nbsp;&nbsp;&nbsp; if(new File("Dsp030.txt").exists()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getParameters();
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Note that this program always processes
&nbsp;&nbsp;&nbsp; // five sinusoids, even if fewer than five
&nbsp;&nbsp;&nbsp; // were requested as the input parameter
&nbsp;&nbsp;&nbsp; // for numberSpectra.&nbsp; In that case, the
&nbsp;&nbsp;&nbsp; // extras are processed using default values
&nbsp;&nbsp;&nbsp; // and simply ignored when the results are
&nbsp;&nbsp;&nbsp; // plotted.

&nbsp;&nbsp;&nbsp; //Create the raw data.&nbsp; Note that the
&nbsp;&nbsp;&nbsp; // argument for a sinusoid at half the
&nbsp;&nbsp;&nbsp; // sampling frequency would be (2*pi*x*0.5).
&nbsp;&nbsp;&nbsp; // This would represent one half cycle or pi
&nbsp;&nbsp;&nbsp; // radians per sample.
&nbsp;&nbsp;&nbsp; //First create empty array objects.
&nbsp;&nbsp;&nbsp; double[] data1 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data2 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data3 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data4 = new double[len];
&nbsp;&nbsp;&nbsp; double[] data5 = new double[len];
&nbsp;&nbsp;&nbsp; //Now populate the array objects
&nbsp;&nbsp;&nbsp; for(int n = 0;n < len;n++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; //Compute magnitude spectra of the raw data
&nbsp;&nbsp;&nbsp; // and save it in output arrays.&nbsp; Note that
&nbsp;&nbsp;&nbsp; // the real, imag, and angle arrays are not
&nbsp;&nbsp;&nbsp; // used later, so they are discarded each
&nbsp;&nbsp;&nbsp; // time a new spectral analysis is performed.
&nbsp;&nbsp;&nbsp; magnitude1 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplexFFT01.transform(data1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real,imag,angle,magnitude1);

&nbsp;&nbsp;&nbsp; magnitude2 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplexFFT01.transform(data2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real,imag,angle,magnitude2);

&nbsp;&nbsp;&nbsp; magnitude3 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplexFFT01.transform(data3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real,imag,angle,magnitude3);

&nbsp;&nbsp;&nbsp; magnitude4 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplexFFT01.transform(data4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real,imag,angle,magnitude4);

&nbsp;&nbsp;&nbsp; magnitude5 = new double[len];
&nbsp;&nbsp;&nbsp; real = new double[len];
&nbsp;&nbsp;&nbsp; imag = new double[len];
&nbsp;&nbsp;&nbsp; angle = new double[len];
&nbsp;&nbsp;&nbsp; ForwardRealToComplexFFT01.transform(data5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real,imag,angle,magnitude5);
&nbsp; }//end constructor
&nbsp; //-------------------------------------------//

&nbsp; //This method gets processing parameters from
&nbsp; // a file named Dsp030.txt and stores those
&nbsp; // parameters in instance variables belonging
&nbsp; // to the object of type Dsp030.
&nbsp; void getParameters(){
&nbsp;&nbsp;&nbsp; int cnt = 0;
&nbsp;&nbsp;&nbsp; //Temporary holding area for strings.&nbsp; Allow
&nbsp;&nbsp;&nbsp; // space for a few blank lines at the end
&nbsp;&nbsp;&nbsp; // of the data in the file.
&nbsp;&nbsp;&nbsp; String[] data = new String[20];
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Open an input stream.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Dsp030.txt"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and save the strings from each of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the lines in the file.&nbsp; Be careful to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // avoid having blank lines at the end,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which may cause an ArrayIndexOutOfBounds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception to be thrown.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((data[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.readLine()) != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; //Move the parameter values from the
&nbsp;&nbsp;&nbsp; // temporary holding array into the instance
&nbsp;&nbsp;&nbsp; // variables, converting from characters to
&nbsp;&nbsp;&nbsp; // numeric values in the process.
&nbsp;&nbsp;&nbsp; cnt = 0;
&nbsp;&nbsp;&nbsp; len = (int)Double.parseDouble(data[cnt++]);
&nbsp;&nbsp;&nbsp; numberSpectra = (int)Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; for(int fCnt = 0;fCnt < numberSpectra;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq[fCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; for(int aCnt = 0;aCnt < numberSpectra;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aCnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amp[aCnt] = Double.parseDouble(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data[cnt++]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Print parameter values.
&nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; System.out.println("Data length: " + len);
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Number spectra: " + numberSpectra);
&nbsp;&nbsp;&nbsp; System.out.println("Frequencies");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSpectra;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(freq[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; System.out.println("Amplitudes");
&nbsp;&nbsp;&nbsp; for(cnt = 0;cnt < numberSpectra;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(amp[cnt]);
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end getParameters
&nbsp; //-------------------------------------------//
&nbsp; //The following six methods are required by the
&nbsp; // interface named GraphIntfc01.&nbsp; The plotting
&nbsp; // program pulls the data values to be plotted
&nbsp; // by invoking these methods.
&nbsp; public int getNmbr(){
&nbsp;&nbsp;&nbsp; //Return number of functions to
&nbsp;&nbsp;&nbsp; // process.&nbsp; Must not exceed 5.
&nbsp;&nbsp;&nbsp; return numberSpectra;
&nbsp; }//end getNmbr
&nbsp; //-------------------------------------------//
&nbsp; public double f1(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude1.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude1[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f2(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude2.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude2[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f3(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude3.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude3[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f4(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude4.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude4[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//
&nbsp; public double f5(double x){
&nbsp;&nbsp;&nbsp; int index = (int)Math.round(x);
&nbsp;&nbsp;&nbsp; if(index < 0 ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index > magnitude5.length-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magnitude5[index];
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end function
&nbsp; //-------------------------------------------//

}//end class Dsp030

<b>Listing 22</b>
</pre></td></tr></tbody></table></p><p>&nbsp;</p><table border="1" cols="1" width="400" bgcolor="#ffff00">
<tr>
<td>
<pre>
/*File ForwardRealToComplexFFT01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

The static method named transform performs a real
to complex Fourier transform using a crippled
complex-to-complex FFT algorithm.&nbsp; It is crippled
in the sense that it is not being used to its
full potential as a complex-to-complex forward
or inverse FFT algorithm.

See ForwardRealToComplex01 for a slower but more
general approach that does not use an FFT
algorithm.

Returns real, imag, magnitude, and phase angle in
degrees.

Incoming parameters are:
&nbsp; double[] data - incoming real data
&nbsp; double[] realOut - outgoing real data
&nbsp; double[] imagOut - outgoing imaginary data
&nbsp; double[] angleOut - outgoing phase angle in
&nbsp;&nbsp;&nbsp; degrees
&nbsp; double[] magnitude - outgoing amplitude
&nbsp;&nbsp;&nbsp; spectrum

The magnitude is computed as the square root of
 the sum of the squares of the real and imaginary
 parts.&nbsp; This value is divided by the incoming
 data length, which is given by data.length.

CAUTION: THE INCOMING DATA LENGTH MUST BE A
POWER OF TWO. OTHERWISE, THIS PROGRAM WILL FAIL
TO RUN PROPERLY.

Returns a number of points in the frequency
domain equal to the incoming data length.&nbsp; Those
points are uniformly distributed between zero and
one less than the sampling frequency.
************************************************/

public class ForwardRealToComplexFFT01{

&nbsp; public static void transform(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] realOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] imagOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] angleOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] magnitude){
&nbsp;&nbsp;&nbsp; double pi = Math.PI;//for convenience
&nbsp;&nbsp;&nbsp; int dataLen = data.length;
&nbsp;&nbsp;&nbsp; //The complexToComplex FFT method does an
&nbsp;&nbsp;&nbsp; // in-place transform causing the output
&nbsp;&nbsp;&nbsp; // complex data to be stored in the arrays
&nbsp;&nbsp;&nbsp; // containing the input complex data.
&nbsp;&nbsp;&nbsp; // Therefore, it is necessary to copy the
&nbsp;&nbsp;&nbsp; // input data to this method into the real
&nbsp;&nbsp;&nbsp; // part of the complex data passed to the
&nbsp;&nbsp;&nbsp; // complexToComplex method.
&nbsp;&nbsp;&nbsp; System.arraycopy(data,0,realOut,0,dataLen);

&nbsp;&nbsp;&nbsp; //Perform the spectral analysis.&nbsp; The results
&nbsp;&nbsp;&nbsp; // are stored in realOut and imagOut. The +1
    // causes it to be a forward transform. A -1
    // would cause it to be an inverse transform.
&nbsp;&nbsp;&nbsp; complexToComplex(1,dataLen,realOut,imagOut);

&nbsp;&nbsp;&nbsp; //Compute the magnitude and the phase angle
&nbsp;&nbsp;&nbsp; // in degrees.
&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt < dataLen;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magnitude[cnt] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Math.sqrt(realOut[cnt]*realOut[cnt]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + imagOut[cnt]*imagOut[cnt]))/dataLen;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(imagOut[cnt] == 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; && realOut[cnt] == 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] = 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] = Math.atan(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagOut[cnt]/realOut[cnt])*180.0/pi;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(realOut[cnt] < 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; && imagOut[cnt] == 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] = 180.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else if(realOut[cnt] < 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; && imagOut[cnt] == -0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] = -180.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else if(realOut[cnt] < 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; && imagOut[cnt] > 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] += 180.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else if(realOut[cnt] < 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; && imagOut[cnt] < 0.0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleOut[cnt] += -180.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp; }//end transform method
&nbsp; //-------------------------------------------//

&nbsp; //This method computes a complex-to-complex
&nbsp; // FFT.&nbsp; The value of sign must be 1 for a
&nbsp; // forward FFT.
&nbsp; public static void complexToComplex(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sign,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double real[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double imag[]){
&nbsp;&nbsp;&nbsp; double scale = 1.0;
&nbsp;&nbsp;&nbsp; //Reorder the input data into reverse binary
&nbsp;&nbsp;&nbsp; // order.
&nbsp;&nbsp;&nbsp; int i,j;
&nbsp;&nbsp;&nbsp; for (i=j=0; i < len; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j>=i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double tempr = real[j]*scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double tempi = imag[j]*scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real[j] = real[i]*scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag[j] = imag[i]*scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real[i] = tempr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag[i] = tempi;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m = len/2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (m>=1 && j>=m) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j -= m;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m /= 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j += m;
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Input data has been reordered.
&nbsp;&nbsp;&nbsp; int stage = 0;
&nbsp;&nbsp;&nbsp; int maxSpectraForStage,stepSize;
&nbsp;&nbsp;&nbsp; //Loop once for each stage in the spectral
&nbsp;&nbsp;&nbsp; // recombination process.
&nbsp;&nbsp;&nbsp; for(maxSpectraForStage = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepSize = 2*maxSpectraForStage;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxSpectraForStage < len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxSpectraForStage = stepSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepSize = 2*maxSpectraForStage){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double deltaAngle =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign*Math.PI/maxSpectraForStage;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Loop once for each individual spectra
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int spectraCnt = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spectraCnt < maxSpectraForStage;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++spectraCnt){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angle = spectraCnt*deltaAngle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double realCorrection = Math.cos(angle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double imagCorrection = Math.sin(angle);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int right = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int left = spectraCnt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left < len;left += stepSize){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = left + maxSpectraForStage;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double tempReal =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; realCorrection*real[right]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - imagCorrection*imag[right];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double tempImag =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; realCorrection*imag[right]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + imagCorrection*real[right];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real[right] = real[left]-tempReal;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag[right] = imag[left]-tempImag;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real[left] += tempReal;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imag[left] += tempImag;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop for individual spectra
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxSpectraForStage = stepSize;
&nbsp;&nbsp;&nbsp; }//end for loop for stages
&nbsp; }//end complexToComplex method

}//end class ForwardRealToComplexFFT01

<b>Listing 23</b>
</pre></td></tr></table>
<p>&nbsp;</p>
     
<hr size="3" width="100%" align="center">    
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p>
     
<h4> <a name="About_the_author">About the author</a></h4><b>
<a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects, and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p>
     
<p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p>
     
<p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p>
     
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
  </p>
     
<p>-end- </p>
   </body>
</html>
