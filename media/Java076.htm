<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Vectors, Hashtables, and Enumerations<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 76, Revised 01/11/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#enumeration interface">Enumeration Interface</a></li>

<li><a href="#sample enumeration program">Sample Enumeration Program</a></li>

<ul><li><a href="#interesting code fragments in enumeration program">Interesting
Code Fragments in Enumeration Program</a></li>

<li><a href="#program listing for enumeration program">Program Listing for
Enumeration Program</a></li></ul>

<li><a href="#vector class">Vector Class</a></li>

<li><a href="#hashtable class">Hashtable Class</a></li>

<li><a href="#sample program">Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#program listing">Program Listing</a></li></ul>

<li><a href="#review">Review</a></li></ul>

<hr align=left width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
classes at ACC are responsible for knowing and understanding all of the
material in this lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
Several previous lessons dealt with data structures of the "reinvent your
own" variety. The Java API provides some data structures which you can
often use without the requirement to invent your own. The classes that
provide these structures are contained in the <b>java.util</b> package.
In this lesson, we will be interested in the <b>Vector</b> class, the <b>Hashtable</b>
class, and the <b>Enumeration</b> interface.

<p>The <b>java.util</b> package also provides a <b>Stack</b> class, but
according to several books on the subject, it doesn't behave the way we
normally expect a stack to behave (I haven't tested it myself). In particular,
the <b>Stack</b> class apparently extends the <b>Vector</b> class which
makes it possible to instantiate an object of the <b>Stack</b> class, and
then access methods of the <b>Vector</b> class that violate the <b>LIFO</b>
behavior that we normally expect from a stack.

<p>If I have the time later, I will prepare a lesson on creating a stack
using the <b>Vector</b> class that doesn't have this shortcoming.
<center><h2><a name="enumeration interface"></a><font color="#ff0000">Enumeration Interface</font></h2></center>
Let's begin with what is possibly the most abstract and the most difficult
of the three to get a grip on. <b>Enumeration </b>is not a class, it is
an interface.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td>Therefore, any class can be designed to implement the <b>Enumeration</b>
interface.</td></tr></table>
If a class implements the <b>Enumeration</b> interface, and if the methods
of that class are properly designed and coded, then an object of that class
can be used to <i>enumerate </i>an object of the class for which it was
<u>specifically designed</u>.

<p>What do we mean when we say that we are going to <i>enumerate</i> an
object? We mean that we will provide a pair of methods by which a using
program can:
<ul><li>
Obtain in <i>sequential </i>fashion all of the objects <i>stored in</i>
the object being enumerated (actually what we obtain are references to
the objects because in Java, references to objects, rather than actual
objects are stored in other objects).</li>

<li>
Obtain (at any point in the process) a <b>boolean</b> value indicating
whether or not there are any more objects to be obtained.</li></ul>
Note the use of the words <i>specifically designed</i> above. There is
no such thing as a general-purpose enumeration object or a general-purpose
enumeration class. All enumeration objects are instances of a class specifically
designed to enumerate objects of some specific class.

<p>A class that implements the <b>Enumeration</b> interface must provide
a definition for the following two methods that are declared in the interface.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public boolean <b>hasMoreElements</b>()
&nbsp; public Object <b>nextElement</b>()</pre></td></tr></table>
The benefits of the <b>Enumeration</b> interface occur when a class that
deals with sets of objects has the ability to provide an object of a class
that implements the <b>Enumeration</b> interface (an enumeration object)
capable of enumerating <u>an instance of the class that deals with sets
of objects</u>.

<p>For example, if an object of a linked-list class has the ability to
provide an enumeration object on itself, code within the scope of the linked
list object can obtain that enumeration object and use it to interate through
all the nodes in the linked list.

<p>The methods of the <b>Enumeration</b> interface can be invoked on the
enumeration object to provide that code with a sequence of references to
the nodes in the list. Then depending on access control considerations,
the code can access the individual nodes in that specific linked-list object
to do something useful.

<p>It is important to note that an enumeration object is not really an
object of the <b>Enumeration</b> class, because there is no such class.
Rather, <b>Enumeration</b> is an interface and it is not possible to instantiate
objects of an interface type.

<p>However, if an object is instantiated from a class that implements the
<b>Enumeration</b> interface, then insofar as the two methods declared
in the <b>Enumeration</b> interface are concerned, the object can be treated
as if it were of type <b>Enumeration</b>.

<p>Unless the class from which the enumeration object is instantiated contains
members that are not declared in the <b>Enumeration</b> interface, you
really don't need to care about the actual class from which it was instantiated.
You can always refer to it as type <b>Enumeration</b>.

<p>It is also important to note that an enumeration object normally won't
contain any hard data. Rather, it will normally contain a reference to
the specific object that it was instantiated to enumerate, and such other
data as may be necessary for it to reliably execute its two methods. Note
however, that an enumeration object designed to enumerate an object which
is a complex data structure may require very complex methods to accomplish
its task..

<p>When the <b>nextElement()</b> method of an enumeration object returns
a reference to an object, that reference will always be of the generic
type <b>Object</b> and it will normally be necessary for you to downcast
it to its true type in order to do much with it that is useful.

<p>As mentioned earlier, and repeated here for emphasis, an enumeration
object can exist only as a partner to another object containing data to
be enumerated. In other words, there is no such thing as a useful standalone
enumeration object . An enumeration object exists for the sole purpose
of providing its methods to enumerate another object of a specific class.
<center><h2><a name="sample enumeration program"></a><font color="#ff0000">Sample Enumeration
Program</font></h2></center>
Enumeration objects don't need to be complex. The following sample program
illustrates a simple class that stores <b>String </b>data in an array and
a simple enumeration object that can be used to enumerate an object of
that class.

<p>The program defines a class named <b>MyDataStruct </b>that creates a
simple data structure consisting of an array of <b>String </b>data.

<p>The class provides a method that <u>returns an object of a class that
implements</u> the <b>Enumeration </b>interface (an enumeration object
).

<p>The two methods of the <b>Enumeration </b>interface class can then be
invoked on the enumeration object to iterate through the original data
structure retrieving each data element in the structure. The enumeration
object serves as a structured pathway into the object that it was instantiated
to enumerate.

<p>One of the two methods of the <b>Enumeration</b> interface can be used
to determine if there are any elements in the data structure that haven't
already been retrieved.

<p>The other method in the <b>Enumeration</b> interface can be used to
retrieve the next element.

<p>In this program, the controlling class
<ul><li>
instantiates an object of type <b>MyDataStruct</b>,</li>

<li>
invokes the <b>getEnum()</b> method to get an enumeration object , and</li>

<li>
uses that object to interate through the data structure retrieving and
displaying each of the elements in the structure.</li></ul>
The program was tested using JDK 1.1.3 under Win 95. The output from running
the program is shown in the comments at the beginning of the complete program
listing in a later section.
<center><h3><a name="interesting code fragments in enumeration program"></a><font color="#ff0000">Interesting
Code Fragments in Enumeration Program</font></h3></center>
The first interesting code fragment is the beginnings of the class used
to instantiate an enumeration object . As you can see, this class implements
the <b>Enumeration</b> interface. As you can also see, it contains the
three essential instance variables.
<ul><li>
One to keep a count of the objects as they are returned by the <b>nextElement()</b>
method.</li>

<li>
One to keep track of the total size (total number of elements) of the object
being enumerated.</li>

<li>
One to reference the object being enumerated.</li></ul>
In this case, the object being enumerated is a simple array of references
to objects of type <b>Object.</b><br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>MyEnumerator implements Enumeration</b>{
&nbsp; int <b>count</b>;//store iteration counter here
&nbsp; int <b>length</b>;//store array length here
&nbsp; Object[] <b>dataArray</b>;//store reference to data array here</pre></td></tr></table>
The next interesting code fragment is the constructor for the class. Enumeration
objects are not instantiated directly by the program that will use the
enumeration object . Rather, they are instantiated and returned by the
object that is to be enumerated, normally as a result of a method call
on that object. Only that object can provide the required information when
the enumeration object is instantiated.

<p>This constructor receives the information for the three critical instance
variables and stores that information in those variables.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; MyEnumerator(int <b>count</b>,int <b>length</b>,Object[] <b>dataArray</b>){
&nbsp;&nbsp;&nbsp; this.<b>count </b>= <b>count</b>;
&nbsp;&nbsp;&nbsp; this.<b>length </b>= <b>length</b>;
&nbsp;&nbsp;&nbsp; this.<b>dataArray </b>= <b>dataArray</b>;
&nbsp; }//end constructor</pre></td></tr></table>
The next interesting code fragment is one of the two required methods in
a class that implements the <b>Enumeration</b> interface. This method returns
a <b>boolean</b> indicating whether or not there are any more elements
that haven't already been retrieved. In the case of a simple array of <b>Object</b>
references, this is a very simple method. In a more complex structure,
such as a tree for example, this method might be more complex.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public boolean <b>hasMoreElements</b>(){
&nbsp;&nbsp;&nbsp; return (count &lt; length);
&nbsp; }//end hasMoreElements</pre></td></tr></table>
The next interesting code fragment is the other of the two methods required
of a class that implements the <b>Enumeration</b> interface. This method
will return a reference to the next element from the data structure. The
return value will be typed as the generic type <b>Object</b>. Again, for
a simple array of <b>Object</b> references, this is a very simple method.
For a more complicated structure such as a tree, this could be a very complex
method.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public Object <b>nextElement</b>(){
&nbsp;&nbsp;&nbsp; return dataArray[count++];
&nbsp; }//end nextElement</pre></td></tr></table>
And that's all there is to the class that is used to instantiate the <b>Enumerator</b>
object in this simple program.

<p>The next interesting code fragment is the beginning of the class definition
for a class that can maintain an array of <b>Object</b> references and
provide an enumerator object to methods that request it. For purposes of
illustration, this class was made very simple with the initialization of
the data in the array being hard-coded into the program.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>MyDataStruct</b>{
&nbsp; String[] data;//array of refs to <b>String </b>objects
&nbsp;&nbsp;
&nbsp; MyDataStruct(){//constructor
&nbsp;&nbsp;&nbsp; data = new String[4];
&nbsp;&nbsp;&nbsp; data[0] = "zero";
&nbsp;&nbsp;&nbsp; data[1] = "one";
&nbsp;&nbsp;&nbsp; data[2] = "two";
&nbsp;&nbsp;&nbsp; data[3] = "three";
&nbsp; }//end constructor&nbsp;</pre></td></tr></table>
The next interesting code fragment is a method that must exist, in some
form, in every class that supports enumeration. This is the method that,
when called, instantiates and returns an enumeration object specific to
the object on which the method was invoked. In this case, the method invokes
the parameterized constructor of the <b>MyEnumerator</b> class and returns
the object that results from that invocation.

<p>You might want to go back and compare the parameters passed to the constructor
with the formal argument list of the constructor defined earlier.

<p>The first parameter is used to initialize a counter in the enumerator
object (this could be hard-coded into the constructor and as such would
not require a parameter).

<p>The second parameter is the length of the array.

<p>The third parameter is a reference to the array in the object that is
to be enumerated (this could also be formulated differently using the <b>this</b>
reference).
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; Enumeration <b>getEnum</b>(){
&nbsp;&nbsp;&nbsp; return new <b>MyEnumerator</b>(0,data.length,data);
&nbsp; }//end getEnum()</pre></td></tr></table>
And that is the end of the simple data structure class being used to illustrate
<b>Enumeration</b> in this sample program.

<p>The remaining code is the code in the controlling class that
<ul><li>
instantiates a data structure object,</li>

<li>
gets an enumeration object for that object, and</li>

<li>
invokes the two methods on that enumeration object to retrieve and display
the <b>String</b> data stored in the data structure object.</li></ul>
&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class Enum01{//controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; MyDataStruct myDataStruct = <b>new MyDataStruct()</b>;
&nbsp;&nbsp;&nbsp; Enumeration myEnumeration = <b>myDataStruct.getEnum()</b>;
&nbsp;&nbsp;&nbsp; while(myEnumeration.<b>hasMoreElements</b>()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(myEnumeration.<b>nextElement</b>());
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end main()
}//end controlling class</pre></td></tr></table>
So, as you can see, although <b>Enumeration</b> can be very complex for
certain kinds of data structures, complexity is not a requirement. Hopefully
this will give you a firm grounding in the concept of <b>Enumeration</b>
so that we can make use of <b>Enumeration</b> in the discussions of the
<b>Vector</b> and <b>Hashtable</b> classes that follows.
<center><h3><a name="program listing for enumeration program"></a><font color="#ff0000">Program
Listing for Enumeration Program</font></h3></center>
A complete listing of the program follows.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Enum01.java Copyright 1997, R.G.Baldwin
This program illustrates the Enumeration interface.

The program defines a class named MyDataStruct that creates
a simple data structure consisting of an array of String
data.

The class provides a method that returns an object of a&nbsp;
class that implements the Enumeration interface (an&nbsp;
enumeration object ).

The two methods of the Enumeration interface class can&nbsp;
then be invoked on the enumeration object&nbsp; to iterate&nbsp;
through the original data structure fetching each data&nbsp;
element in the structure.

The two methods of the Enumeration interface are:
&nbsp; public boolean hasMoreElements()
&nbsp; public Object nextElement()

The first method can be used to determine if there are any
elements in the data structure that haven't already been
fetched.&nbsp; The second method can be used to fetch the next
element.

The controlling class instantiates an object of type
MyDataStruct, invokes the getEnum() method to get an
enumeration object , and then uses that object to interate
through the data structure fetching and displaying each
of the elements in the structure.

The program was tested using JDK 1.1.3 under Win 95.

Running this program produces the following output:
&nbsp;&nbsp;
zero
one
two
three
**********************************************************/
import java.util.*;
//=======================================================//

//The following class is used by the MyDataStruct class
// to instantiate an object that implements the Enumeration
// interface.
class MyEnumerator implements Enumeration{
&nbsp; int count;//store iteration counter here
&nbsp; int length;//store array length here
&nbsp; Object[] dataArray;//store reference to data array here
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Constructor
&nbsp; MyEnumerator(int count,int length,Object[] dataArray){
&nbsp;&nbsp;&nbsp; this.count = count;
&nbsp;&nbsp;&nbsp; this.length = length;
&nbsp;&nbsp;&nbsp; this.dataArray = dataArray;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method defines one of the methods that are
&nbsp; // declared in the Enumeration interface.
&nbsp; public boolean hasMoreElements(){
&nbsp;&nbsp;&nbsp; return (count &lt; length);
&nbsp; }//end hasMoreElements
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method defines the other method that is declared
&nbsp; // in the Enumeration interface.
&nbsp; public Object nextElement(){
&nbsp;&nbsp;&nbsp; return dataArray[count++];
&nbsp; }//end nextElement
&nbsp;&nbsp;
}//end class MyEnumerator
//=======================================================//

//This class can be used to instantiate a simple data
// structure object that has the ability to provide an
// enumeration object&nbsp; to a using program.
class MyDataStruct{
&nbsp; String[] data;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; MyDataStruct(){//constructor
&nbsp;&nbsp;&nbsp; //Hard code the data for illustration purposes only
&nbsp;&nbsp;&nbsp; data = new String[4];
&nbsp;&nbsp;&nbsp; data[0] = "zero";
&nbsp;&nbsp;&nbsp; data[1] = "one";
&nbsp;&nbsp;&nbsp; data[2] = "two";
&nbsp;&nbsp;&nbsp; data[3] = "three";
&nbsp; }//end constructor&nbsp;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method will return an enumeration object&nbsp; to a
&nbsp; // using program.
&nbsp; Enumeration getEnum(){
&nbsp;&nbsp;&nbsp; return new MyEnumerator(0,data.length,data);
&nbsp; }//end getEnum()
&nbsp; //-----------------------------------------------------//
}//end class MyDataStruct
//=======================================================//

class Enum01{//controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Instantiate an object of type MyDataStruct
&nbsp;&nbsp;&nbsp; MyDataStruct myDataStruct = new MyDataStruct();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get an enumeration object&nbsp; that describes the object
&nbsp;&nbsp;&nbsp; // of type MyDataStruct
&nbsp;&nbsp;&nbsp; Enumeration myEnumeration = myDataStruct.getEnum();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the enumeration object&nbsp; to iterate and display
&nbsp;&nbsp;&nbsp; // each element in the object of type MyDataStruct.
&nbsp;&nbsp;&nbsp; while(myEnumeration.hasMoreElements()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(myEnumeration.nextElement());
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end main()
}//end controlling class
//=======================================================//</pre></td></tr></table>
.
<center><h2><a name="vector class"></a><font color="#ff0000">Vector Class</font></h2></center>
Our next topic in this lesson is the <b>Vector</b> class. An object of
the <b>Vector</b> class is essentially an array that can grow or shrink
as needed to accommodate adding and removing items after the <b>Vector</b>
object has been created.

<p>This is a very handy class in that it provides the convenience of <i>indexed</i>
access and at the same time does not confine you to the use of an array
whose size is established at compile time.

<p>Two terms are important when discussing objects of the <b>Vector</b>
class are <b>capacity</b> and <b>capacityIncrement</b>.

<p>The <b>capacity</b> specifies how many objects can be stored in the
<b>Vector</b> object at its current size, and is always at least as large
as the number of objects stored in the <b>Vector </b>object (<b>elementCount</b>).
Whenever the <b>capacity</b> needs to be increased, it increases in chunks
the size of <b>capacityIncrement</b>.

<p>There are three overloaded constructors that allow you to control how
the object is constructed in terms of initial <b>capacity</b> and <b>capacityIncrement</b>.
You should take a look at the options in the JDK documentation.

<p>There are a large number of methods that allow you to use a <b>Vector
</b>object. A sampling of some of those methods follows. You should review
the remaining methods in the JDK documentation package.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><ul><li><b>addElement</b>(Object) - Adds the specified object to the end of this
vector, increasing its size by one.&nbsp;</li>

<li><b>removeElement</b>(Object) - Removes the first occurrence of the argument
from this vector.&nbsp;</li>

<li><b>removeElementAt</b>(int) - Deletes the object at the specified index.&nbsp;</li>

<li><b>capacity</b>() - Returns the current capacity of this vector.&nbsp;</li>

<li><b>contains</b>(Object) - Tests if the specified object is a component
in this vector.&nbsp;</li>

<li><b>elementAt</b>(int) - Returns the object at the specified index.&nbsp;</li>

<li><i><b>elements</b>() - Returns an enumeration of the objects of this vector.</i>&nbsp;</li>

<li><b>firstElement</b>() - Returns the first object of this vector.&nbsp;</li>

<li><b>insertElementAt</b>(Object, int) - Inserts the specified object as a
component in this vector at the specified <b>index</b>.&nbsp;</li>

<li><b>isEmpty</b>() - Tests if this vector has no components.&nbsp;</li>

<li><b>lastElement</b>() - Returns the last component of the vector.&nbsp;</li></ul></td></tr></table>
Note in particular the <i>italicized</i> method named <b>elements()</b>.
This is the method that returns an enumeration object for an object of
the <b>Vector</b> class. We will be using the <b>elements()</b> method
in a sample program later in this lesson.
<center><h2><a name="hashtable class"></a><font color="#ff0000">Hashtable Class</font></h2></center>
Objects of the <b>Hashtable</b> class are a little more complicated than
objects of the <b>Vector</b> class. Fortunately for us, the folks at JavaSoft
have already done most of the hard work, and all we have to do is to take
advantage of what they provided for us to use.

<p>A hashtable stores object references by mapping keys to values. Any
non-null object can be used as a key or as a value.

<p>Objects used as keys in a hashtable must implement the <b>hashCode()</b>
method. This is a method that converts an object into a (hopefully) unique
identifier by way of applying a mathematical algorithm to the object. <b>hashCode()
</b>is a method in the <b>Object</b> class and a default version is inherited
by all classes in Java.

<p>Many of the classes in the standard Java API override the <b>hashCode()</b>
method for objects of that class. This includes the <b>String</b> class
that we will be using for key values in a subsequent sample program.

<p>Similarly, objects used as keys in a hashtable must implement the <b>equals()</b>
method. The <b>equals()</b> method is defined in the <b>Object</b> class
and overridden by many classes (including <b>String</b>) in the standard
Java API.

<p>Two terms of interest when using hashtables are <b>capacity</b> and
<b>load factor</b>, because these terms affect the efficiency of the object
relative to storing and retrieving objects. You can find a more detailed
discussion of these terms in the JDK documentation.

<p>So, the bottom line is that when you want to store an object in a hashtable,
you provide two objects. One is used as a <i>key</i> and the other is stored
as a <i>value</i>. To retrieve the object that has been stored, you simply
provide the <i>key</i> again, and the code in the method retrieves and
returns the object that was stored as a <i>value</i>.

<p>All <i>value</i> objects are typed as the generic type <b>Object</b>.

<p>There are three overloaded <b>Hashtable</b> constructors that allow
you to instantiate <b>Hashtable</b> objects for different values of <b>capacity</b>
and <b>load factor</b>. You should take a look at your options in the JDK
documentation in this regard.

<p>As with <b>Vector</b>, there are quite a few of methods available to
help you use hashtables. A sampling of these methods follows. You should
review the remaining methods in the JDK documentation.
<br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><dl><dt><b>contains</b>(Object) - Tests if some key maps into the specified value
in this hashtable.&nbsp;</dt>

<dt><b>containsKey</b>(Object) - Tests if the specified object is a key in
this hashtable.&nbsp;</dt>

<dt><i><b>elements</b>() - Returns an enumeration of the values in this hashtable.</i>&nbsp;</dt>

<dt><i><b>keys</b>() - Returns an enumeration of the keys in this hashtable.&nbsp;</i></dt>

<dt><b>get</b>(Object) - Returns the value to which the specified key is mapped
in this hashtable.&nbsp;</dt>

<dt><b>isEmpty</b>() - Tests if this hashtable maps no keys to values.&nbsp;</dt>

<dt><b>put</b>(Object, Object) - Maps the specified <b>key </b>to the specified
<b>value </b>in this hashtable.&nbsp;</dt></dl></td></tr></table>
It is important to note that references to first-class objects can be stored
in a hashtable; not just data. In the sample program that follows, we will
be storing references to objects that contain instance methods, and then
retrieving the references to the objects for the purpose of invoking the
instance methods contained in the objects.
<center><h2><a name="sample program"></a><font color="#ff0000">Sample Program</font></h2></center>
This program is <u>not intended to accomplish anything useful</u> other
than to illustrate how to use the <b>Vector </b>and <b>Hashtable </b>classes,
and the <b>Enumeration </b>interface.

<p>In addition, it illustrates some other important Java programming concepts
such as <u>registering a list of objects</u> for some particular purpose,
<u>processing all the objects</u> on the list of registered objects, working
at the <u>generic</u> <b>Object </b>level and <u>downcasting when needed</u>,
etc.

<p>The program is fairly long and somewhat complex, so we will take it
in small steps.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
The scenario is as follows. This program provides the capability to instantiate
objects describing people where each object contains a name, an age, and
a weight. The program also provides the capability to compare two such
objects on the basis of either age or weight to determine which is the
lesser of the two.

<p>A controlling class is used to used to test the program. The <b>main()</b>
method of the controlling class instantiates some objects containing the
names, ages, and weights of several people.

<p>The main method of the controlling class also instantiates an object
which serves as a <u>manager</u> for comparing these objects in pairs to
report which is <i>younger </i>and which is <i>lighter</i>.

<p>A method named <b>registerPair()</b> of the <b>CompareManager</b> class
is invoked to register three pairs of objects for later comparison.

<p>These actions are shown in the following code fragment.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Instantiate a manager to handle the comparisons
&nbsp;&nbsp;&nbsp; CompareManager compareManager = <b>new CompareManager()</b>;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Register three pairs of data objects with the
&nbsp;&nbsp;&nbsp; // manager
&nbsp;&nbsp;&nbsp; compareManager.<b>registerPair</b>(new Data("Tom",65,180),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Dick",60,170));
&nbsp;&nbsp;&nbsp; compareManager.<b>registerPair</b>(new Data("Harry",40,160),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Dick",60,170));
&nbsp;&nbsp;&nbsp; compareManager.<b>registerPair</b>(new Data("Harry",40,160),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Tom",65,180));</pre></td></tr></table>
Note that these objects are submitted as <i>anonymous</i> objects, although
that isn't a requirement of the program.

<p>The manager creates a list of pairs of such objects as they are submitted
(registered), and when requested to do so, compares and reports on all
of the pairs contained in the registered list. (Actually, to keep things
simple, the manager encapsulates each pair in an object and registers that
object).

<p>Therefore, this program illustrates the type of operation often referred
to as <i>registering </i>objects, and then processing all of the registered
objects upon request.

<p>Registration lists occur in many different kinds of operations in Java
such as event handling, Model-View- Controller using Observable, etc.

<p>Note that all of the objects in this program are handled as generic
<b>Object </b>types and downcast to the required type when needed.

<p>Therefore, this program also illustrates the use of downcasting from
<b>Object </b>to actual types in addition to the concepts and mechanics
of <i>registration</i>.

<p>When the controlling class asks the manager to perform the comparisons
on all the objects in the list of registered objects, that request is made
on the basis of a comparison of either <b>AGE</b> or <b>WEIGHT</b>. A class
named <b>CompareHow </b>is defined for the sole purpose of defining symbolic
constants for <b>AGE </b>and <b>WEIGHT</b>. This class also defines a symbolic
constant for <b>INVALID </b>that is used to confirm that the program works
as expected when a request is made to compare on an <b>INVALID </b>basis.

<p>The next code fragment shows the <b>main()</b> method in the controlling
class asking the <b>CompareManager</b> object to compare all of the registered
pairs of objects and to report on the results. Note that three calls to
<b>compareAll()</b> are made, one for each symbolic constants.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; <b>compareManager</b>.<b>compareAll</b>(CompareHow.<b>AGE</b>);
&nbsp;&nbsp;&nbsp; compareManager.compareAll(CompareHow.<b>WEIGHT</b>);
&nbsp;&nbsp;&nbsp; compareManager.compareAll(CompareHow.<b>INVALID</b>);</pre></td></tr></table>
And that is all that happens in the <b>main()</b> method of the controlling
class.

<p>There is a small class definition for a class named <b>Data</b>. This
class is used to encapsulate the name, age, and weight data for a person
in an object. The code for this class is too simple to merit being shown
in this section. You can see it in the complete program listing that follows
near the end of the lesson.

<p>Likewise, as mentioned earlier, there is a small class definition for
a class named <b>CompareHow</b> whose sole purpose is to define the symbolic
<b>String</b> constants for <b>AGE</b>, <b>WEIGHT</b>, and <b>INVALID</b>.
These symbolic constants are used later as keys in a hashtable. Again,
this class is too simple to merit being shown in this section.

<p>An interface named <b>Comparable </b>is defined which declares a method
named <b>comparePair()</b>. This method is implemented in several different
classes in the program.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>interface <b>Comparable</b>{
&nbsp; public void <b>comparePair</b>(String how, Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2);
}//end Comparable interface</pre></td></tr></table>
Therefore, another concept that is illustrated by this program is the definition
and use of user-defined interfaces.

<p>Note that the definition of the <b>Comparable </b>interface would also
have been a good place to define the symbolic constants mentioned above
since the definition of constants is allowed in an interface.

<p>The manager class (which is instantiated by and communicated with by
the controlling class) is named <b>CompareManager</b>. This class is used
to
<ul><li>
maintain a list of registered pairs of objects and then</li>

<li>
manage the actual comparison of all the object-pairs in the list of registered
pairs.</li></ul>
This class makes use of an object of a class named <b>CompareTool </b>to
actually perform the comparisons when time comes to compare the objects.
The object of the class named <b>CompareTool </b>does some fairly complicated
things using a <b>Hashtable </b>object.

<p>The list of registered pairs of objects is maintained in an object of
type <b>Vector</b>. Therefore, this program illustrates the use of the
<b>Vector </b>class for maintaining a list of registered objects.

<p>The following code fragment shows the beginning of the definition of
the <b>CompareManager</b> class where the instance variables for the references
to the <b>CompareTool</b> object and the <b>Vector</b> object are declared.
Note that the reference to the <b>CompareTool</b> object is maintained
as a generic <b>Object</b> type.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>CompareManager</b>{
&nbsp; <b>Object </b>compareTool;
&nbsp; <b>Vector </b>myListOfObjects;</pre></td></tr></table>
Rather than to deal with pairs of individual objects in the registration
list, this manager class defines an inner-class named <b>PairOfObj </b>that
is used to encapsulate each pair of objects into a single object that is
then registered by placing a reference to that object in the <b>Vector
</b>object used to maintain the list.

<p>An inner-class is used for this purpose as shown in the next code fragment.
Although it is a very simple class, the fact that it is an inner class
probably merits displaying and discussing it in this section.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; class <b>PairOfObj</b>{
&nbsp;&nbsp;&nbsp; Object obj1;
&nbsp;&nbsp;&nbsp; Object obj2;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <b>PairOfObj</b>(Object obj1,Object obj2){//<b>constructor
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.obj1 = obj1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.obj2 = obj2;
&nbsp;&nbsp;&nbsp; }//end constructor
&nbsp; }//end inner-class PairOfObj</pre></td></tr></table>
The constructor for the <b>CompareManager </b>object (shown below) instantiates
a <b>CompareTool </b>object named <b>compareTool </b>and a <b>Vector </b>object
named <b>myListOfObjects </b>to use as described above.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; <b>CompareManager</b>(){//<b>constructor </b>for a manager object
&nbsp;&nbsp;&nbsp; this.compareTool = <b>new CompareTool()</b>;
&nbsp;&nbsp;&nbsp; myListOfObjects = <b>new Vector()</b>;
&nbsp; }//end constructor</pre></td></tr></table>
The <b>CompareManager </b>class contains a method named <b>registerPair()</b>
that is invoked from the outside to register a pair of objects for later
comparison. This method <u>encapsulates</u> references to the two incoming
objects into a single object and then invokes the <b>addElement()</b> method
on the <b>Vector </b>object to create the list of registered objects.

<p>No provisions are made to remove objects from the list of registered
objects as is frequently the case when a registration list is used to maintain
a list of registered objects. Obviously, this wouldn't be difficult given
the methods that are available to manipulate the contents of the <b>Vector</b>
object. Also, this registration method doesn't make any effort to prevent
duplicated objects in the list which is sometimes done.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>registerPair</b>(Object obj1,Object obj2) {
&nbsp;&nbsp;&nbsp; this.myListOfObjects.<b>addElement</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PairOfObj(obj1,obj2));
&nbsp; }//end registerPair</pre></td></tr></table>
The <b>CompareManager </b>class also contains a method named <b>compareAll()</b>
that is invoked to compare and report on all of the objects in the list
of registered objects. This method has a single <b>String </b>parameter
which is intended to be one of the symbolic constants defined earlier which
specifies how the comparison is to be made (<b>AGE </b>or <b>WEIGHT</b>).

<p>The <b>compareAll()</b> method invokes the <b>elements()</b> method
on the <b>Vector</b> object which instantiates and returns an object that
implements the <b>Enumeration </b>interface. In other words, it returns
an enumeration object. On the basis of the previous discussion, you should
be aware of what this enumeration object is, and what can be done with
it.

<p>Methods of the <b>Enumeration </b>interface are then used to extract
each of the composite objects from the list of registered objects. Each
of the objects in the pair is then extracted from the registered composite
object, and passed, along with a string parameter specifying how to perform
the comparison, to a method named<b> comparePair()</b> which is a method
of the <b>CompareTool </b>object described earlier. Note that <b>comparePair()</b>
is declared in the <b>Comparable </b>interface and must be defined in all
classes that implement that interface.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>compareAll</b>(String how){
&nbsp;&nbsp;&nbsp; Enumeration <b>myEnum </b>= myListOfObjects.<b>elements()</b>;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <b>while</b>(myEnum.<b>hasMoreElements()</b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object <b>aPairOfObj </b>= myEnum.<b>nextElement()</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Comparable)<b>compareTool</b>).<b>comparePair</b>(how,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PairOfObj)<b>aPairOfObj</b>).obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PairOfObj)<b>aPairOfObj</b>).obj2);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end compareAll
}//end CompareManager class</pre></td></tr></table>
Note the requirements for downcasting from <b>Object</b> to the true type
to be able to access the methods and variables of the objects which have
been maintained as the generic type <b>Object</b>.

<p>That is the end of the <b>compareAll()</b> method and the end of the
<b>CompareManager</b> class as well.

<p>Now we will discuss the <b>CompareTool </b>class from which an object
is instantiated to actually perform the comparison between two objects.

<p>This is a little tricky, so you may need to pay close attention.

<p>This class contains two inner-classes named <b>AgeCompare </b>and <b>WeightCompare</b>.
Each of these classes implements the <b>Comparable </b>interface, and therefore
defines a method named <b>comparePair()</b>.

<p>However, the <b>comparePair()</b> methods differ between the two classes.
In one case, the code is designed to compare two objects on the basis of
the instance variable named <b>age</b>. In the other case, the method is
designed to compare two objects on the basis of the instance variable named
<b>weight</b>.

<p>These are the two methods that are <u>ultimately invoked</u> to make
the actual comparisons, with the <u>choice between methods</u> being based
on a <b>String </b>object that is passed in with the objects that are to
be compared. The <b>String</b> object specifies either <b>AGE</b> or <b>WEIGHT</b>.

<p>The following code fragment shows the beginning of the <b>CompareTool</b>
class and the declaration of a reference variable to a <b>Hashtable</b>
object along with the instantiation of that object.

<p>This code fragment also shows one of the inner-classes named <b>AgeCompare</b>
discussed above. The two inner-classes are very similar, so only one is
shown here. You can view the other one in the complete program listing
near the end of this lesson.

<p>Note that these inner classes define a method having the same name,
<b>comparePair()</b>, as a method in their parent class. Also note that
in all three cases this method implements the <b>Comparable</b> interface.
However, the implementation in all three cases is different depending on
the class in which is is defined and the needs of objects of that class.
The code to actually make the comparisons is straightforward, once you
get past the downcasting requirements.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>CompareTool implements Comparable</b>{
&nbsp; private <b>Hashtable </b>myHashTable = <b>new Hashtable()</b>;
&nbsp; //_____________________________________________________//

&nbsp; <b>private class AgeCompare implements Comparable</b> {
&nbsp;&nbsp;&nbsp; public void <b>comparePair</b>(String how,Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In AgeCompare method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp1 = (Data)obj1;//Cast incoming objects to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp2 = (Data)obj2;// the correct type.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the comparison on age
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(temp1.age&lt;temp2.age)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is younger than " + temp2.name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is not younger than " + temp2.name);
&nbsp;&nbsp;&nbsp; }//end trace()
&nbsp; }//end inner-class AgeCompare</pre></td></tr></table>
This is where things become a little more complicated, so pay close attention.
The constructor for the <b>CompareTool </b>class instantiates an object
of class <b>Hashtable </b>and stores (<i>puts</i>) two objects in the <b>Hashtable
</b>along with appropriate key values.

<p>One object that is stored in the <b>Hashtable </b>is a reference to
an object of type <b>AgeCompare </b>along with a key value of <b>AGE</b>.

<p>The other object that is stored in the <b>Hashtable </b>is a reference
to an object of type <b>WeightCompare </b>along with a key value of <b>WEIGHT</b>.

<p>Make certain that you understand that these two objects are instantiated
from the inner classes described above and what that implies.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public <b>CompareTool</b>(){//constructor
&nbsp;&nbsp;&nbsp; myHashTable.<b>put</b>( CompareHow.<b>AGE</b>, <b>new AgeCompare()</b> );
&nbsp;&nbsp;&nbsp; myHashTable.<b>put</b>( CompareHow.<b>WEIGHT</b>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>new WeightCompare()</b> );
&nbsp; }//end constructor&nbsp;</pre></td></tr></table>
Once the <b>CompareTool</b> object is constructed, it contains a very special
<b>Hashtable</b> object. By invoking the <b>get()</b> method on the <b>Hashtable
</b>object, passing one of the two <i>keys </i>as a parameter, it is possible
to <u>obtain a reference</u> to an object that <u>contains an instance
method</u> designed to <u>perform a comparison</u> between two objects
on the basis of <u>either age or weight</u>. This method can then be invoked
to actually perform the comparison.

<p>Therefore, this program illustrates the use of a <b>Hashtable </b>object
to store and retrieve references to objects <u>containing useful instance
methods</u> (as opposed simply to data values) on the basis of a <i>key
</i>value.

<p>(This concept may seem very foreign to you at this point, but we will
be making heavy use of the concept when we explore the use of the <b>invoke()</b>
method of the <b>Method</b> class in the <i>reflection</i> API around lesson
262.)

<p>The <b>CompareTool </b>class implements the <b>Comparable </b>interface,
meaning that it defines the method named <b>comparePair()</b> also. This
is the method that is called by the object of the <b>CompareManager</b>
class to compare two objects. In addition to the references to the two
objects that are to be compared, this method also receives a <b>String
</b>parameter specifying how to make the comparison: <b>AGE </b>or <b>WEIGHT</b>.

<p>However, this method doesn't actually make the comparison. Rather, it
first tests to confirm that the incoming <b>String </b>constant is <u>contained
as a key</u> in the <b>Hashtable</b>. If it is a valid <i>key</i> value,
it invokes the <b>get()</b> method on the <b>Hashtable</b> object, passing
that <i>key</i> as a parameter, and in return receives a reference to an
object associated with that <i>key</i>. The referenced object contains
a method of the same name, <b>comparePair()</b>. The <b>comparePair()</b>
method of the referenced object is <u>invoked to perform the actual comparison</u>.

<p>Therefore, by using the incoming <b>key </b>value to access the <b>Hashtable
</b>object, this method gains <u>access to another method</u> that is designed
to perform the comparison in a manner that is consistent with the <i>key
</i>value.

<p>This is an interesting concept on <i>selection</i>. In the case of this
simple program, only two different methods are represented by objects in
the <b>Hashtable</b>. However, there could be dozens, hundreds, or even
thousands of different methods represented by objects in the hashtable,
and <i>selection </i>among them could be made simply on the basis of the
<i>key </i>value associated with each. In effect, this is an approach to
<i>selection</i> that goes beyond <b>if</b> <b>else</b> and <b>switch case</b>.

<p>Note that when this method named <b>comparePair()</b> invokes the method
named <b>comparePair()</b>, it is invoking a method that is defined in
one of the objects stored in the hashtable. It is <u>not making a recursive
call on itself</u>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>comparePair</b>(String how, Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2){
&nbsp;&nbsp;&nbsp; if(myHashTable.<b>containsKey</b>(how)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object theMethod = myHashTable.get(how);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Comparable)theMethod).<b>comparePair</b>(how,obj1,obj2 );
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; else System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Invalid Key, could throw exception here");
&nbsp; }//end comparePair()</pre></td></tr></table>
While this may not be the most straightforward way to accomplish this,
it does illustrate the use of a <b>Hashtable </b>object in a rather interesting
way. In particular, the <b>Hashtable </b>object doesn't simply contain
data values, it contains references to objects that in turn contain methods
of interest. Those methods are selectable on the basis of <i>key</i> values.

<p>As mentioned earlier, we will be making heavy use of this concept when
we use of the <b>invoke()</b> method of the <b>Method</b> class in the
<i>reflection</i> API to create <i>smart event adapters</i> in the Advanced
portion of the tutorial around lesson 262.

<p>If the incoming <b>String </b>parameter is <u>not contained</u> as a
<b>key </b>in the <b>Hashtable</b>, an "Invalid Key" message is displayed
and no attempt is made to compare the objects. This would be a good place
to throw an exception.

<p>As mentioned earlier, this particular program isn't intended to be useful
for anything other than to illustrate the use of the <b>Vector</b>, and
<b>Hashtable </b>classes along with the <b>Enumeration </b>interface, and
also to illustrate some other important concepts such as creating and maintaining
a list of registered objects, downcasting from <b>Object </b>to true type,
etc. It is also intended to get you prepared to understand what you will
encounter in the Advanced portion of the tutorial in relation to the <i>reflection</i>
API.

<p>The output from the program is contained in the comments at the beginning
of the program listing.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
A complete program listings follows so you can see the interesting code
fragments in context.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File Hash01.java Copyright 1997, R.G.Baldwin
This program is not intended to accomplish anything
particularly useful other than to illustrate how to use
the Vector and Hashtable, and the Enumeration&nbsp;
interface.

This program was tested using JDK 1.1.3 under Win95.

The output from the program is:
&nbsp;&nbsp;
<b>In AgeCompare method
Tom is not younger than Dick
In AgeCompare method
Harry is younger than Dick
In AgeCompare method
Harry is younger than Tom
In WeightCompare method
Tom is not lighter than Dick
In WeightCompare method
Harry is lighter than Dick
In WeightCompare method
Harry is lighter than Tom
Invalid Key, could throw exception here
Invalid Key, could throw exception here
Invalid Key, could throw exception here
</b>**********************************************************/
import java.util.*;
//=======================================================//

//This is the controlling class used to test everything
// else.
class <b>Hash01</b>{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Instantiate a manager to handle the comparisons
&nbsp;&nbsp;&nbsp; CompareManager compareManager = new CompareManager();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Register three pairs of data objects with the
&nbsp;&nbsp;&nbsp; // manager
&nbsp;&nbsp;&nbsp; compareManager.registerPair(new Data("Tom",65,180),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Dick",60,170));
&nbsp;&nbsp;&nbsp; compareManager.registerPair(new Data("Harry",40,160),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Dick",60,170));
&nbsp;&nbsp;&nbsp; compareManager.registerPair(new Data("Harry",40,160),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Data("Tom",65,180));

&nbsp;&nbsp;&nbsp; //Request comparison of all pairs of objects on the
&nbsp;&nbsp;&nbsp; // basis of age and weight (separately). Also
&nbsp;&nbsp;&nbsp; // request comparison on the basis of an invalid
&nbsp;&nbsp;&nbsp; // parameter.
&nbsp;&nbsp;&nbsp; compareManager.compareAll(CompareHow.AGE);
&nbsp;&nbsp;&nbsp; compareManager.compareAll(CompareHow.WEIGHT);
&nbsp;&nbsp;&nbsp; compareManager.compareAll(CompareHow.INVALID);
&nbsp; }//end main
}//end class Hash01
//=======================================================//

//This is the class used to package the data for
// submission to the comparison manager.
class <b>Data</b>{
&nbsp; String name;
&nbsp; int age;
&nbsp; int weight;
&nbsp;&nbsp;
&nbsp; Data(String name,int age,int weight){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.age = age;
&nbsp;&nbsp;&nbsp; this.weight = weight;
&nbsp; }//end constructor
}//end class Data
//=======================================================//

//Define some string constants that are used later as
// keys in a hash table.
class <b>CompareHow</b>{
&nbsp; public static final String AGE = "AGE";
&nbsp; public static final String WEIGHT = "WEIGHT";
&nbsp; public static final String INVALID = "INVALID";
}//end class CompareHow
//=======================================================//

//Define the Comparable interface.&nbsp; Note that it declares
// the method named comparePair() that is defined in
// several classes that implement the interface.
interface <b>Comparable</b>{
&nbsp; public void comparePair(String how,Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2);
}//end Comparable interface
//=======================================================//

//This class is used to manage the process of comparing
// pairs of objects
class <b>CompareManager</b>{
&nbsp; //Stores a reference to an object that does the work
&nbsp; // of comparing objects on the basis of a String
&nbsp; // parameter that define how the objects are to be&nbsp;
&nbsp; // compared.
&nbsp; Object compareTool;
&nbsp;&nbsp;
&nbsp; //Stores a list of references to objects each of which
&nbsp; // contains a pair of objects to be compared.
&nbsp; Vector myListOfObjects;
&nbsp; //_____________________________________________________//
&nbsp;&nbsp;
&nbsp; //Define an inner class of the CompareManager class
&nbsp; // that is used to package a pair of incoming&nbsp;
&nbsp; // objects into a single object for storage in a
&nbsp; // Vector object.
&nbsp; class <b>PairOfObj</b>{
&nbsp;&nbsp;&nbsp; Object obj1;
&nbsp;&nbsp;&nbsp; Object obj2;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; PairOfObj(Object obj1,Object obj2){//constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.obj1 = obj1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.obj2 = obj2;
&nbsp;&nbsp;&nbsp; }//end constructor
&nbsp; }//end inner-class PairOfObj
&nbsp; //_____________________________________________________//
&nbsp;&nbsp;
&nbsp; CompareManager(){//<b>constructor </b>for a manager object
&nbsp;&nbsp;&nbsp; //Instantiate a tool object which will be used to&nbsp;
&nbsp;&nbsp;&nbsp; // actually perform the comparisons
&nbsp;&nbsp;&nbsp; this.compareTool = new CompareTool();
&nbsp;&nbsp;&nbsp; //Instantiate a Vector object to contain a list of&nbsp;
&nbsp;&nbsp;&nbsp; // registered objects
&nbsp;&nbsp;&nbsp; myListOfObjects = new Vector();
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//

&nbsp; //This method maintains a list of registered objects
&nbsp; // in a Vector object where each registered object&nbsp;
&nbsp; // contains a pair of objects that are to be compared&nbsp;
&nbsp; // later all at the same time.
&nbsp; public void <b>registerPair</b>(Object obj1,Object obj2) {
&nbsp;&nbsp;&nbsp; this.myListOfObjects.addElement(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PairOfObj(obj1,obj2));
&nbsp; }//end registerPair
&nbsp; //-----------------------------------------------------//
&nbsp;
&nbsp; //This method compares all the pairs of objects contained
&nbsp; // in the list of registered objects. The comparison is
&nbsp; // performed on the basis of the how parameter (age or
&nbsp; // weight).
&nbsp; public void <b>compareAll</b>(String how){
&nbsp;&nbsp;&nbsp; //Create an enumeration object for the objects in the&nbsp;
&nbsp;&nbsp;&nbsp; // list of registered objects.
&nbsp;&nbsp;&nbsp; Enumeration myEnum = myListOfObjects.elements();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the enumeration object to process all the objects
&nbsp;&nbsp;&nbsp; // in the list of registered objects.&nbsp; Each registered
&nbsp;&nbsp;&nbsp; // object contains a pair of objects that are to be
&nbsp;&nbsp;&nbsp; // compared.
&nbsp;&nbsp;&nbsp; while(myEnum.hasMoreElements()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get the next registered object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object aPairOfObj = myEnum.nextElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Extract and compare the pair of objects contained
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the registered object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Comparable)compareTool).comparePair(how,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PairOfObj)aPairOfObj).obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PairOfObj)aPairOfObj).obj2);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end compareAll
}//end CompareManager class
//=======================================================//

//This class is used to instantiate an object which
// performs the actual comparisons based on a parameter
// named how and using references to methods that are
// stored in a hash table along with key values that
// match the parameter named how.&nbsp; The parameter named
// how is used to fetch a reference to a method from the
// hash table and that reference is used to invoke the
// method to which it refers.
class <b>CompareTool </b>implements Comparable{
&nbsp; //Store references to different comparison methods in
&nbsp; // a hash table for later reference.
&nbsp; private Hashtable myHashTable = new Hashtable();
&nbsp; //_____________________________________________________//
&nbsp;&nbsp;
&nbsp; //This inner class contains one of the methods used to&nbsp;
&nbsp; // compare objects. This one is designed to compare on&nbsp;
&nbsp; // the basis of the instance variable named age. Note
&nbsp; // that the name of the method in this inner class is
&nbsp; // the same as the name of a method in the parent class
&nbsp; // of this class and is also the same as the method
&nbsp; // declared in the interface named Comparable.
&nbsp; private class <b>AgeCompare </b>implements Comparable {
&nbsp;&nbsp;&nbsp; public void comparePair(String how,Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In AgeCompare method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp1 = (Data)obj1;//Cast incoming objects to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp2 = (Data)obj2;// the correct type.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the comparison on age
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(temp1.age&lt;temp2.age)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is younger than " + temp2.name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is not younger than " + temp2.name);
&nbsp;&nbsp;&nbsp; }//end trace()
&nbsp; }//end inner-class AgeCompare
&nbsp; //_____________________________________________________//

&nbsp; //This inner class contains one of the methods used to&nbsp;
&nbsp; // compare objects. This one is designed to compare on&nbsp;
&nbsp; // the basis of the instance variable named weight. Note
&nbsp; // that the name of the method in this inner class is
&nbsp; // the same as the name of a method in the parent class
&nbsp; // of this class and is also the same as the method
&nbsp; // declared in the interface named Comparable.
&nbsp; private class <b>WeightCompare </b>implements Comparable {
&nbsp;&nbsp;&nbsp; public void comparePair(String how,Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("In WeightCompare method");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp1 = (Data)obj1;//Cast incoming objects to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data temp2 = (Data)obj2;// the correct type.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the comparison on weight
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(temp1.weight&lt;temp2.weight)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is lighter than " + temp2.name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else System.out.println(temp1.name +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " is not lighter than " + temp2.name);
&nbsp;&nbsp;&nbsp; }//end trace()
&nbsp; }//end inner-class WeightCompare
&nbsp; //_____________________________________________________//

&nbsp; //This is the constructor for the CompareTool class.
&nbsp; // It instantiates two objects, each containing a&nbsp;
&nbsp; // method named comparePair() and stores references to
&nbsp; // them in the hash table, each with a different key.
&nbsp; // The key values are designed to match the how&nbsp;
&nbsp; // parameter that is passed in to specify how the&nbsp;
&nbsp; // comparison is to be performed.&nbsp; Later, the how&nbsp;
&nbsp; // parameter is used to fetch the reference to a
&nbsp; // particular method and that reference is used to
&nbsp; // invoke the method.
&nbsp; public <b>CompareTool</b>(){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; //Initialize myHashTable and store references to&nbsp;
&nbsp;&nbsp;&nbsp; // methods in a hash table using string constants from
&nbsp;&nbsp;&nbsp; // the CompareHow class as keys.
&nbsp;&nbsp;&nbsp; myHashTable.put( CompareHow.AGE, new AgeCompare() );
&nbsp;&nbsp;&nbsp; myHashTable.put( CompareHow.WEIGHT,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WeightCompare() );
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//

&nbsp; //This is the method that is called to compare two
&nbsp; // objects on the basis of the how parameter.
&nbsp; //Note that the name of this method is the same as the
&nbsp; // name of a method in each of the inner classes, and&nbsp;
&nbsp; // is also the same as the name of the method declared
&nbsp; // in the interface named Comparable.
&nbsp; public void <b>comparePair</b>(String how, Object obj1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj2){
&nbsp;&nbsp;&nbsp; //Use incoming how parameter to extract the reference
&nbsp;&nbsp;&nbsp; // to the correct method from the hash table to use for
&nbsp;&nbsp;&nbsp; // this comparison and assign the reference to a local
&nbsp;&nbsp;&nbsp; // variable named theMethod.&nbsp; Test to confirm that the
&nbsp;&nbsp;&nbsp; // value of the how parameter is actually a key in the
&nbsp;&nbsp;&nbsp; // hashtable.&nbsp; If not, simply display a message.&nbsp; Note
&nbsp;&nbsp;&nbsp; // that this would be a good place to throw an&nbsp;
&nbsp;&nbsp;&nbsp; // exception.
&nbsp;&nbsp;&nbsp; if(myHashTable.containsKey(how)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object theMethod = myHashTable.get(how);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use the local variable named theMethod to invoke&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the correct comparison method on the incoming&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // objects.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that this is the invocation of a method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // named comparePair() that is defined in one of&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the inner classes of this class and is contained
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the object referenced in the hash table.&nbsp; It
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is not a recursive call to this version of&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comparePair().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Comparable)theMethod).<b>comparePair</b>(how,obj1,obj2 );
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; else System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Invalid Key, could throw exception here");
&nbsp; }//end comparePair()
&nbsp; //-----------------------------------------------------//
}//end CompareTool class
//=======================================================//</pre></td></tr></table>

<center><h2><a name="review"></a><font color="#ff0000">Review</font></h2></center>
Q - Write a Java program that meets the following specifications.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/* File SampProg153.java Copyright 1998, R.G.Baldwin
From lesson 76

Without viewing the solution that follows, write a Java
application that uses the Vector class to implement a
LIFO stack.&nbsp; Make certain that the data in the stack is
available only on a LIFO basis using the methods shown
below.&nbsp; Make the stack class capable of accommodating&nbsp;
objects of any type. Throw an exception if the user&nbsp;
attempts to pop an empty stack.

Methods:
isEmpty() -&nbsp;&nbsp;&nbsp; returns true if this stack is empty.&nbsp;
pop() -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Removes and returns the object from the top
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of this stack.
push(Object) - Pushes an item onto the top of this stack.&nbsp;

This program was tested using JDK 1.1.3 under Win95.

The output from the program is:

Mary Jones
Sue Williams
Joe Johnson
Dick Baldwin
java.util.NoSuchElementException
**********************************************************/
import java.io.*;
import java.util.*;

//=======================================================//
class MyStack{
&nbsp; //Note that this class contains and does not extend
&nbsp; // Vector.
&nbsp; private Vector stack = new Vector();
&nbsp; //-----------------------------------------------------//

&nbsp; boolean isEmpty(){
&nbsp;&nbsp;&nbsp; return stack.isEmpty();
&nbsp; }//end isEmpty()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; void push(Object item){
&nbsp;&nbsp;&nbsp; stack.addElement(item);
&nbsp; }//end push()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; Object pop()throws NoSuchElementException{
&nbsp;&nbsp;&nbsp; Object temp = stack.lastElement();
&nbsp;&nbsp;&nbsp; stack.removeElementAt((stack.size()-1));

//&nbsp;&nbsp;&nbsp; stack.removeElementAt(stack.lastIndexOf(temp));
&nbsp;&nbsp;&nbsp; return temp;
&nbsp; }//end pop()
&nbsp; //-----------------------------------------------------//
}//end class MyStack

//=======================================================//
class SampProg153{//controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; MyStack stack = new MyStack();
&nbsp;&nbsp;&nbsp; stack.push(new TestClass("Dick","Baldwin"));
&nbsp;&nbsp;&nbsp; stack.push(new TestClass("Joe","Johnson"));
&nbsp;&nbsp;&nbsp; stack.push(new TestClass("Sue","Williams"));
&nbsp;&nbsp;&nbsp; stack.push(new TestClass("Mary","Jones"));

&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(!stack.isEmpty())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(stack.pop());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Try to pop an empty stack
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(stack.pop());

&nbsp;&nbsp;&nbsp; }catch(NoSuchElementException e){System.out.println(e);}
&nbsp; }// end main
}//end class SampProg153 definition
//======================================================//

class TestClass{
&nbsp; String first;
&nbsp; String last;
&nbsp;&nbsp;
&nbsp; TestClass(String first, String last){//constructor
&nbsp;&nbsp;&nbsp; this.first = first;
&nbsp;&nbsp;&nbsp; this.last = last;
&nbsp; }//end constructor
&nbsp; //----------------------------------------------------//
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return first + " " + last;
&nbsp; }//end toString()
}//end TestClass
//======================================================//</pre></td></tr></table>
Q - Write a Java program that meets the following specifications.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/* File SampProg154.java Copyright 1998, R.G.Baldwin
From lesson 76

Without viewing the solution that follows, write a Java
application that uses the Vector class to implement a
LIFO structure similar to a stack.&nbsp;&nbsp;

This structure has set and get methods that mirror the
typical push and pop methods in a stack.

However, this structure also has an enumerator that allows
you to access the individual elements in the structure
in sequential order, and to modify them in the process.

Make the structure class capable of accommodating&nbsp;
objects of any type. Throw an exception if the user&nbsp;
attempts to get an element from an empty structure.

Methods:
isEmpty() -&nbsp;&nbsp; Returns true if the structure is empty.&nbsp;
get() -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Removes and returns the object from the top
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the structure.
set(Object) - Stores an element onto the top of the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure.&nbsp;

This program was tested using JDK 1.1.3 under Win95.

Typical output from the program is:
Set the structure
Enumerate and modify the structure
Dick Baldwin
Joe Johnson
Sue Williams
Mary Jones
Get the modified structure
Mary Modified
Sue Modified
Joe Modified
Dick Modified
java.util.NoSuchElementException
**********************************************************/
import java.io.*;
import java.util.*;

//=======================================================//
class MyStructure{
&nbsp; private Vector structure = new Vector();
&nbsp; //-----------------------------------------------------//

&nbsp; boolean isEmpty(){
&nbsp;&nbsp;&nbsp; return structure.isEmpty();
&nbsp; }//end isEmpty()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; void set(Object item){
&nbsp;&nbsp;&nbsp; structure.addElement(item);
&nbsp; }//end set()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; Object get()throws NoSuchElementException{
&nbsp;&nbsp;&nbsp; Object temp = structure.lastElement();
&nbsp;&nbsp;&nbsp; structure.removeElementAt(structure.size()-1);
&nbsp;&nbsp;&nbsp; return temp;
&nbsp; }//end get()
&nbsp; //-----------------------------------------------------//

&nbsp; Enumeration getEnumerator(){
&nbsp;&nbsp;&nbsp; return new Enumerator(this);
&nbsp; }//end getEnumerator()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; int getSize(){
&nbsp;&nbsp;&nbsp; return structure.size();
&nbsp; }//end getSize()
&nbsp; //-----------------------------------------------------//

&nbsp; Object getElement(int which){
&nbsp;&nbsp;&nbsp; return structure.elementAt(which);
&nbsp; }//end getElement()
&nbsp; //-----------------------------------------------------//&nbsp;
}//end class MyStructure

//=======================================================//

class Enumerator implements Enumeration{
&nbsp; MyStructure theStructure;
&nbsp; int elementCounter;
&nbsp; //-----------------------------------------------------//

&nbsp; Enumerator(MyStructure theStructure){//constructor
&nbsp;&nbsp;&nbsp; this.theStructure = theStructure;
&nbsp;&nbsp;&nbsp; elementCounter = 0;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp; public boolean hasMoreElements(){
&nbsp;&nbsp;&nbsp; return (elementCounter &lt; theStructure.getSize());
&nbsp; }//end hasMoreElements
&nbsp; //-----------------------------------------------------//

&nbsp; public Object nextElement(){
&nbsp;&nbsp;&nbsp; return theStructure.getElement(elementCounter++);
&nbsp; }//end nextElement
}//end class Enumerator
//=======================================================//

class SampProg154{//controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; MyStructure structure = new MyStructure();
&nbsp;&nbsp;&nbsp; System.out.println("Set the structure");
&nbsp;&nbsp;&nbsp; structure.set(new TestClass("Dick","Baldwin"));
&nbsp;&nbsp;&nbsp; structure.set(new TestClass("Joe","Johnson"));
&nbsp;&nbsp;&nbsp; structure.set(new TestClass("Sue","Williams"));
&nbsp;&nbsp;&nbsp; structure.set(new TestClass("Mary","Jones"));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enumerate and modify the structure");
&nbsp;&nbsp;&nbsp; Enumeration enum = structure.getEnumerator();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; TestClass temp;
&nbsp;&nbsp;&nbsp; while(enum.hasMoreElements()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = (TestClass)enum.nextElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the element
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(temp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Modify the element
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp.last = "Modified";
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Get the modified structure");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(!structure.isEmpty())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(structure.get());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Try to get element from an empty structure
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(structure.get());

&nbsp;&nbsp;&nbsp; }catch(NoSuchElementException e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }// end main
}//end class SampProg154 definition
//=======================================================//

class TestClass{
&nbsp; String first;
&nbsp; String last;
&nbsp;&nbsp;
&nbsp; TestClass(String first, String last){//constructor
&nbsp;&nbsp;&nbsp; this.first = first;
&nbsp;&nbsp;&nbsp; this.last = last;
&nbsp; }//end constructor
&nbsp; //----------------------------------------------------//
&nbsp; public String toString(){
&nbsp;&nbsp;&nbsp; return first + " " + last;
&nbsp; }//end toString()
}//end TestClass
//======================================================//</pre></td></tr></table>
.

<p>-end-<!--end--></body></html>