<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>More on Java Interfaces by Richard G. Baldwin </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MSOFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->More on Interfaces<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 46, Revised 10/03/99. </P>
<P><!-toc file=Java046a.htm words=Preface-><A HREF="#preface">Preface</A><BR>
<!--endtoc--><!-toc file=Java046b.htm words=Introduction-><A HREF="#introduction">Introduction</A><BR>
<!--endtoc--><!-toc file=Java046c.htm words=Sample Program-><A HREF="#sampleprogram">Sample Program</A><BR>
<!--endtoc--><!-toc file=Java046d.htm words=What Are Interfaces and What Are They Good For-><A HREF="#whatareinterfaces">What Are Interfaces and What Are They Good For?</A><BR>
<!--endtoc--><!-toc file=Java046e.htm words=The Bottom Line on Interfaces-><A HREF="#thebottomlineoninterfaces">The Bottom Line on Interfaces</A><BR>
<!--endtoc--><!-toc file=Java046f.htm words=Review-><A HREF="#review">Review</A><!--endtoc--> </P>
<P><!-next=Java046a.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of persons already familiar with C++ who are making the transition into Java. </P>
<P><!-prev=Java046.htm-><!-next=Java046b.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><P>The concept of the <I>interface </I>can sometimes be fairly difficult to comprehend. Before getting into a lot of technical details, lets see if we can present an overview that will help you to understand the details when we get to them. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The concept of the <I>interface</I> does not exist in C++.</TD>
</TR>
</TABLE>

<P>First of all, why does the interface exist in the first place? Many books provide answers to this question from a justification viewpoint. I will simply try to answer it from a practical programming viewpoint and will leave the justification to others. </P>
<P>Probably the <U>most important aspect</U> of the interface concept is that it allows you to treat a <U>number of objects</U>, instantiated from <U>different classes</U>, as if they were all of the <U>same type</U>, or you can treat an object of a given true type as a different type. At least that is true to a <U>limited extent</U>. </P>
<P>At its simplest level, an interface definition has a <I>name</I>, and <I>declares </I>one or more <I>methods</I>. </P>
<P>Only the method signatures are provided. The actual <I>implementations </I>(bodies) of the methods are <U>not provided</U>. </P>
<P>In addition to method declarations, an interface can <U>also declare constants</U>. Nothing else may be included inside the body of an interface definition. </P>
<P>Now please bear with me and concentrate as I attempt to explain what this all means. </P>
<P>Assume that there is an interface definition named X which declares methods A, B, and C. </P>
<P>Assume further that there are three different classes named P, D, and Q. </P>
<P>Each class <I>claims to implement</I> the interface named X. </P>
<P>Each class also provides a <U>full definition</U> for methods A, B, and C </P>
<P>All of this being true, a <U>group of mixed objects</U> of types P, D, and Q can be <U>treated</U> as if they were <U>all of type X</U> (to a limited extent). </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Multiple objects of different classes can be treated as if they are all of the same <U>common type</U> where the type is indicated by the <U>name of the interface</U>.</TD>
</TR>
</TABLE>

<P>For example, a reference variable for an object of Class P, D, or Q could be assigned to a reference variable of type X. (Normally a reference variable of one type cannot be assigned to a reference variable of another type, except in some special cases.) </P>
<P>Similarly, a new object of class P, D, or Q could be instantiated and its reference could immediately be assigned to a variable of type X <U>without a variable of type P, D, or Q ever having existed</U>. </P>
<P>The references to a group of objects of types P, D, and Q could be assigned to the individual elements of an array of variables of type X. </P>
<P>Or the elements in the array of type X could be used in the instantiation statements of the objects when they are first instantiated and may be the only reference variables ever to exist to refer to the objects. </P>
<P>Having done these things, a reference variable of type X could then be used to access methods A, B, or C of the object to which it refers. </P>
<P>It is important to note that the behavior of methods A, B, and C could <U>differ significantly between objects</U> of classes P, D, and Q. </P>
<P>The actual implementation of a method A, B, or C could be <U>tailored to the specific class</U> in which it is defined. Only the <U>method signature must be the same</U> among the different classes which <I>implement </I>the interface. </P>
<P>A previous paragraph used the terminology "to a limited extent." If one or more of the classes P, D, and Q, define instance methods which are <U>not declared in the interface X</U>, then a reference variable of type X <U>cannot</U> be used to access those instance methods. Those methods can only be accessed using a reference variable of the class in which the method is defined. </P>
<P>Reference variables of the type X can <U>only be used</U> to access methods declared in the interface X (or one of its superinterfaces which we will get to later). </P>
<P>Another limitation is that even though you can consider the interface name as a type for purposes of storing references to objects, <B><U>you cannot instantiate an object of the interface type itself</B></U>. </P>
<P>An interface definition does not have a constructor, so it is not possible to invoke the <B>new</B> operator on an interface type. </P>
<P>By the way, if the classes P, D, and Q implement the interface X as described above, a method in another class can invoke the methods named A, B, and C on objects of type P, D, and Q without ever knowing their true type (the class from which they were instantiated). This is accomplished by casting those objects as type X when the method is invoked. An example program which illustrates this important aspect of interfaces is presented later in the lesson. </P>
<P><!-prev=Java046a.htm-><!-next=Java046c.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="sampleprogram"></A>Sample Program</H2>
</FONT><P ALIGN="JUSTIFY">The following sample program illustrates some of these concepts. </P>
<P>Two interfaces are defined and named <I>Constants</I> and <I>MyIntfc</I>. The <I>Constants </I>interface defines two constants and the <I>MyIntfc </I>interface declares a <B>set()</B> method and a <B>get()</B> method. </P>
<P>The constants and the methods could have been <U>combined</U> into a single interface definition. However, they were separated to illustrate that a single class can <I>implement </I>two or more interfaces using a comma-separated list of interface names. </P>
<P>Two class are defined named <B>ClassA</B> and <B>ClassB</B>. Each of these classes implements both of the interfaces listed above. This means that each class defines the <I>set()</I> method and the <I>get()</I> method declared in <I>MyIntfc</I>. Each class also makes use of the constants defined in the interface named <I>Constants</I>. </P>
<P>It is important to note that in defining the two interface methods, each class defines it in a manner that is appropriate to its own class <U>without concern</U> for how it is defined in other classes. </P>
<P>One of the classes, <B>ClassA</B>, also defines another method named <B>show() </B>which is not declared in the interface. This method is used to demonstrate that a method that is not declared in the interface <U>cannot be accessed</U> using a reference variable of the interface type. </P>
<P>The <B>main </B>method in the controlling class named <B>Intfc01 </B>executes a series of instantiations, method invocations, and assignments designed to illustrate the characteristics described above. </P>
<P>The comments and the print statements embedded in the program should make it self-explanatory at this point. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Intfc01.java Copyright 1997, R.G.Baldwin
Revised 08/12/99
Illustrates use of interface.

The interface definitions for Constants and MyIntfc are 
contained in the files named Constants.java and 
MyIntfc.java.  The compiler requires them to be in separate
source files.

The interface named Constants contains two constants.
The interface named MyIntfc contains declarations for set()
and get().

Different versions of set() and get() are implemented in 
ClassA and ClassB.

The output from running the program is: (manual line breaks
were inserted to make it fit the display format)

Instantiate objA of type ClassA, then set, and show data.
In set() method for classA, using pi from Constants 
  interface: 12.28
In show() method for ClassA, data = 12.28

Assign objA to ref var of type MyIntfc named objAA.
Invoke set() method on objAA to modify the data.
In set() method for classA, using pi from Constants 
  interface: 24.56
Invoke get() method on objAA to display the modified data.
objA data = 24

Instantiate object of type ClassB named objB.  Immediately 
  assign the ref to a type MyIntfc ref var instead of a 
  type ClassB ref var.
Invoke its set() method to store some data.
In set() method for classB, using intConstant from 
  Constants interface: 1375
Invoke its get() method to display the data.
objB data = 1375

Successfully assign objA to objB and display objB
objB data = 24

Invoke set() method on objAA to modify its data.
In set() method for classA, using pi from Constants 
  interface: 98.24
Successfully assign objAA to objB and display objB
objB data = 98

Restore objB to its original type and value.
In set() method for classB, using intConstant from 
  Constants interface: 1375
Successfully assign objB to objAA and display objAA
objAA data = 1375

Attempt to assign objB to objA fails because
  "Explicit cast needed to convert MyIntfc to ClassA."

Attempt to invoke show() method of objAA fails because
"Method show() not found in interface MyIntfc".
End of program.

*/
//=======================================================//
class ClassA implements Constants,MyIntfc{
  double data;
  
  //Define versions of set() and get() appropriate to 
  // ClassA
  public void set(int inData){
    //note use of pi from Constants interface
    data = (double)inData*pi;
    System.out.println(
      "In set() method for classA, using pi from " +
                           "Constants interface: " + data);
  }//end set()
  
  public int get(){
    return (int)data;
  }//end get()
  
  //Define a show method for ClassA not declared in 
  // interface MyIntfc
  void show(){
    System.out.println(
            "In show() method for ClassA, data = " + data);
  }//end show() method
}//end ClassA
//=======================================================//

class ClassB implements Constants,MyIntfc{
  int data;
  
  //Define versions of set() and get() appropriate to 
  // ClassB
  public void set(int inData){
    //note use of intConstant from Constants interface
    data = inData*intConstant;
    System.out.println(
      "In set() method for classB, using intConstant " +
                     " from Constants interface: " + data);
  }//end set()
  
  public int get(){
    return data;
  }//end get()
}//end ClassB
//=======================================================//

class Intfc01{
  public static void main(String[] args){
    System.out.println(
      "Instantiate objA of type ClassA, then set, and " +
                                             "show data.");
    ClassA objA = new ClassA();
    objA.set(2);
    objA.show();    
  
    System.out.println("\nAssign objA to ref var of " +
                              "type MyIntfc named objAA.");
    MyIntfc objAA = objA;
    System.out.println("Invoke set() method on objAA " +
                                    "to modify the data.");
    objAA.set(4);  
    System.out.println("Invoke get() method on objAA to " +
                             "display the modified data.");
    System.out.println("objA data = " + objAA.get());
    
    System.out.println(
      "\nInstantiate object of type ClassB named objB." +
            "  Immediately assign\n the ref to a type " +
            "MyIntfc ref var instead of a type ClassB " +
                                              "ref var.");
    MyIntfc objB = new ClassB();
    System.out.println("Invoke its set() method to " +
                                      "store some data.");
    objB.set(11);
    System.out.println("Invoke its get() method to " +
                                     "display the data.");
    System.out.println("objB data = " + objB.get());

    System.out.println("\nSuccessfully assign objA to " +
                                  "objB and display objB");
    objB = objA;
    System.out.println("objB data = " + objB.get());

    System.out.println("\nInvoke set() method on objAA " +
                                    "to modify its data.");
    objAA.set(16);    
    System.out.println("Successfully assign objAA to " +
                                  "objB and display objB");
    objB = objAA;
    System.out.println("objB data = " + objB.get());
    
    System.out.println("\nRestore objB to its original " +
                                        "type and value.");
    //objB already defined as type MyIntfc
    objB = new ClassB();
    objB.set(11);
    System.out.println("Successfully assign objB to " +
                                "objAA and display objAA");
    objAA = objB;
    System.out.println("objAA data = " + objAA.get());

    System.out.println("\nAttempt to assign objB to " +
      " objA fails because\n  \"Explicit cast needed to " +
                           "convert MyIntfc to ClassA.\"");
    //objA = objB; //statement removed by making it comment
    
    System.out.println(
      "\nAttempt to invoke show() method of objAA fails " +
      "because\n \"Method show() not found in interface " +
                                             "MyIntfc\".");
    //objAA.show();//statement removed by making it 
    // a comment
    
    System.out.println("End of program.");

  }//end main
}//end class Intfc01
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java046b.htm-><!-next=Java046d.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="whatareinterfaces"></A>What Are Interfaces and What Are They Good For?</H3>
</FONT><P><A HREF="#interfacesandmultipleinheritance">Interfaces and Multiple Inheritance</A><BR>
<A HREF="#defininganinterface">Defining an Interface</A><BR>
<A HREF="#implementinganinterface">Implementing an Interface</A><BR>
<A HREF="#aninterfaceasatype">An Interface as a Type</A></P>
<P>According to <U>The Java Tutorial</U> by Campione and Walrath:</P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>An interface is a collection of method definitions (without implementations) and constant values. </P>
<P>You use interfaces to define a protocol of behavior that can be implemented by any class anywhere in the class hierarchy. </P>
<P>Interfaces are useful for: </P>

<UL>
<I><LI>capturing </I>similarities between unrelated classes without forcing a class relationship </LI>
<I><LI>declaring </I>methods that one or more classes are expected to implement </LI>
<I><LI>revealing </I>an object's programming interface without revealing its class (objects such as these are called anonymous objects and can be useful when shipping a package of classes to other developers) </UL>
</TT></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="interfacesandmultipleinheritance"></A>Interfaces and Multiple Inheritance</H3></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ allows the programmer to create a new class as a subclass of <U>two or more</U> different superclasses. This is called <I>multiple inheritance</I>. </TD>
</TR>
</TABLE>

<P>Java does not allow multiple inheritance. Some authors suggest that the Java <I>interface</I> is a substitute for multiple inheritance. Other authors disagree. Here is what Campione and Walrath have to say on the subject in <U>The Java Tutorial</U>.</P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Often interfaces are touted as an alternative to multiple class inheritance. While interfaces may solve some of the same problems as multiple class inheritance, they are quite different animals. In particular: </P>

<UL>
<LI>you cannot inherit variables from an interface </LI>
<LI>you cannot inherit method implementations from an interface. </LI>
<LI>the interface hierarchy is independent of the class hierarchy--classes that implement the same interface may or may not be related through the class hierarchy. </LI></UL>

<P>This is not true for multiple inheritance. </TT></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="defininganinterface"></A>Defining an Interface</H3>
</FONT><P><A HREF="#theinterfacedeclaration">Declaration</A><BR>
<A HREF="#theinterfacebody">Body</A></P>
<P>You define an interface in much the same way that you define a class. The interface definition has two components:</P>

<UL>
<LI>declaration </LI>
<LI>body</LI></UL>

<P>An interface presented in schematic view might look like this:</P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>interfaceDeclaration{
  //interfaceBody
}//end of interface definition</PRE></TD>
</TR>
</TABLE>

<P>The <B>interfaceDeclaration </B>declares various attributes about the interface (name, whether it extends another interface, etc.). </P>
<P>The <B>interfaceBody </B>contains the constant and method declarations within the interface. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="theinterfacedeclaration"></A>Declaration</H4>
</FONT><P>A minimum interface declaration contains the Java keyword <B>interface</B> and the name of the interface. </P>
<P>By convention, interface names begin with upper-case letters just like class names but this is not a requirement. </P>
<P>An interface declaration can have two other components: </P>

<UL>
<LI>the <I>public </I>access specifier and </LI>
<LI>a list of <I>"superinterfaces"</I>.</LI></UL>

<P>An interface can <I>extend </I>other interfaces. </P>
<P>However, while a class can only extend one other class, an interface can <U>extend any number of interfaces</U>. </P>
<P>Here is a full interface definition which includes the body as well as the declaration. (the body is discussed later). </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>public <B>interface </B>MyIntfc extends interfaceX, interfaceY{
  public final double <B>pi </B>= 6.14;
  public final int <B>intConstant </B>= 125;
  void <B>set(int</B> inData);
  int <B>get</B>();
}//end interface MyIntfc</PRE></TD>
</TR>
</TABLE>

<P>The <I>public </I>access specifier indicates that the interface can be used by any class in any package. If omitted, the interface will only be accessible to classes that are defined in the same package. </P>
<P>The <I>extends </I>clause is similar to the extends clause in a class declaration. An interface can extend multiple interfaces (while a class can only extend one). </P>
<P>An interface <U>cannot extend classes</U>. </P>
<P>The list of superinterfaces is a comma-separated list of all of the interfaces extended by the new interface. </P>
<P>An interface <U>inherits all constants and methods</U> from its <I>superinterface </I>unless: </P>

<UL>
<LI>the interface <I>hides </I>a constant with another of the same name, or </LI>
<I><LI>redeclares </I>a method with a new method declaration.</LI></UL>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="theinterfacebody"></A>Body</H4>
</FONT><P>The <U>body</U> of the interface <U>contains method declarations</U>. </P>
<P>The method declaration is <U>terminated by a semicolon</U> and <U>no body</U> is provided for the method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ programmers will recognize this as being generally the same as a function prototype.</TD>
</TR>
</TABLE>

<P>You may not use <I>transient</I>, <I>volatile</I>, <I>private</I>, <I>protected</I>, or <I>synchronized </I>in a member declaration in an interface. </P>
<P>All methods declared in an interface are implicitly <I>public </I>and <I>abstract</I>. </P>
<P>The body of the interface may also define constants. Constant values defined in an interface are implicitly <I>public</I>, <I>static</I>, and <I>final</I>. </P>
<P>A complete interface definition for an interface named <B>MyIntfc</B> was provided above which declared two methods, <B>set()</B> and <B>get()</B>, and defined two constants, <B>pi</B>, and <B>intConstant</B>. The interface extended <B>interfaceX</B> and <B>interfaceY</B>. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="implementinganinterface"></A>Implementing an Interface</H3>
</FONT><P>You use an interface by defining a class that <I>implements </I>the interface by name. </P>
<P>When a class claims to <I>implement </I>an interface, it must provide a <U>full definition</U> for <U>all the methods</U> declared in the interface as well as all of the methods declared in all of the superinterfaces of that interface. </P>
<P>A class can implement <U>more than one</U> interface by including several interface names in a comma-separated list of interface names. In that case, the class must provide a full definition for all of the methods declared in all of the interfaces listed as well as all of the superinterfaces of those interfaces. </P>
<P>Here is an example of a class which implements two interfaces: <B>Constants </B>and <B>MyIntfc</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class ClassA <B>implements Constants,MyIntfc</B>{
  double data;
  
  //Define versions of set() and get() appropriate to 
  // ClassA
  public void set(int inData){
    //note use of pi from Constants interface
    data = (double)inData*pi;
    System.out.println(
      "In set() method for classA, using pi from " +
                           "Constants interface: " + data);
  }//end set()
  
  public int get(){
    return (int)data;
  }//end get()
  
  //Define a show method for ClassA not declared in 
  // interface MyIntfc
  void show(){
    System.out.println(
            "In show() method for ClassA, data = " + data);
  }//end show() method
}//end ClassA
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P>As you can see, this class provides a full definition of the methods <B>set()</B> and <B>get()</B> from the interface named <B>MyIntfc </B>and also uses constants defined in the interface named <B>Constants</B>. </P>
<P>In addition, the class provides a definition for a method named <B>show()</B> which is not declared in either of the interfaces. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="aninterfaceasatype"></A>An Interface as a Type</H3>
</FONT><P>The definition of an interface is a definition of a <U>new reference data type</U>. You can use interface names just about anywhere that you would use other type name. </P>
<P>However, <B><U>you cannot instantiate objects of the interface type</B></U>. It doesn't have a constructor. </P>
<P>The example program presented at the beginning of this lesson contains numerous examples of using the name of an interface as a type. The sample program presented in the next section elaborates on the importance of the interface as a type. </P>
<P><!-prev=Java046c.htm-><!-next=Java046e.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="thebottomlineoninterfaces"></A>The Bottom Line on Interfaces</H2>
</FONT><P><A HREF="#interestingcodefragments">Interesting Code Fragments</A><BR>
<A HREF="#programlisting">Program Listing</A></P>
<P>So, in the final analysis, what really is the bottom line on interfaces. What are they really good for? </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>The interface makes it possible for a method in one class to invoke methods on objects of other classes, without the requirement to know the true class of those objects, provided that those objects are instantiated from classes that implement one or more specified interfaces.</TD>
</TR>
</TABLE>

<P>In other words, objects of classes that implement specified interfaces can be passed into the methods of other objects as the generic type <B>Object</B>, and the methods of the other object can invoke methods on the incoming objects by <U>first casting them as the interface type</U>. </P>
<P>This provides a significant degree of generality in your programming capability. The next sample program illustrates the solution to a classical problem where generality is very important. </P>
<P>Assume that you are a member of a programming team and you have been tasked to define a class and write the methods of that class which will manipulate incoming objects of unknown types based on whether one object is less than, equal to, or greater than another object. Perhaps you are writing a class to sort objects, or to create and maintain a list of objects in "proper order." A very important question is what constitutes proper order. </P>
<P>Obviously if the objects are of unknown type, you cannot know if one is greater than another. You must rely on the objects being <U>able to compare themselves</U> and to tell you which is greater. This means that the classes from which the objects were instantiated must contain methods which perform the comparisons and return the answer, and it means that you must be able to invoke those methods on the objects. </P>
<P>Generally, you cannot invoke any methods on an object of the generic type <B>Object</B> other than those methods defined in the class named <B>Object</B>. This means that you cannot invoke the methods of the objects defined in the true class of those objects without some additional tools, and that is where the interface as a type comes into play. </P>
<P>The trick is for you to define an interface that declares the necessary comparison methods and to require that any objects passed into your methods implement that interface. Once you receive a pair of objects (as the generic type <B>Object</B>), you can cast them as the interface type and invoke their methods to determine which is greater. </P>
<P>At this point, all you care about is the answer provided by the methods of those objects. You don't care about the methodology. You leave the methodology up to the designer of the class for the objects that you receive and assume that those objects know how to compare themselves properly. For example, for some good reason the designer of the class may have decided that 5 is less than 4, and we will take that decision to be valid. You depend on the designer of that class to make those kinds of decisions. </P>
<P>For example, the incoming objects may contain information about people such as names and ages. In a sorting operation, it might be appropriate to order the objects in terms of age, or it might be just as appropriate to order them in terms of alphabetic names. You leave that decision up to the designer of the class from which your incoming objects were instantiated. </P>
<P>You simply require that a decision be made by requiring that the class implement the interface that you define. This in turn requires the designer of the class to implement the decisions in the form of a set of methods that can be used to compare the objects. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="interestingcodefragments"></A>Interesting Code Fragments</H3>
</FONT><P>This program illustrates the use of an interface to make it possible for a method named <B>compare()</B> in a class named <B>LibraryClass </B>to invoke the methods of objects passed in as the generic type <B>Object</B>. </P>
<P>The method named <B>compare()</B> isn't required to know the <U>true type</U> (the class from which they were instantiated) of the incoming objects. However, it does require that they be of a type that implements the interface named <B>Intfc02A</B>. This makes it possible to <B>cast </B>the incoming objects according to that interface type and invoke the methods of the objects. (Note that only those methods declared in the interface can be invoked in this manner.) </P>
<P>The output produced by this program is shown in the comments in the full program listing. </P>
<P>The program defines three classes and one interface. One class is the controlling class named <B>Intfc02</B> that is used to exercise the other two classes. </P>
<P>The second class is a class named <B>UserClass</B> which implements the interface named <B>Intfc02A</B>. Objects of this class are suitable for being passed as type <B>Object</B> to the method named <B>compare()</B> and to be manipulated there. </P>
<P>The third class is a class named <B>LibraryClass</B>. This class contains the method named <B>compare()</B> that is used to manipulate the objects of unknown type (actually of type <B>UserClass</B> but only you and I know that). </P>
<P>The first interesting code fragment is the code in the controlling class named <B>Intfc02</B> which is used to exercise the other two classes. The following statement is typical of what you will find there. As you can see, this code fragment instantiates two objects of type <B>UserClass</B>, and passes them to the <B>compare()</B> method of a new object of type <B>LibraryClass</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>new <B>LibraryClass().compare</B>(
                        new <B>UserClass(5),new</B> UserClass(6));</PRE></TD>
</TR>
</TABLE>

<P>The next interesting code fragment is the class named <B>UserClass</B> whose objects are suitable for processing by an object of the class named <B>LibraryClass</B>. They are suitable because <B>UserClass</B> implements the interface named <B>Intfc02A </B>which is a requirement of the <B>compare()</B> method of the class named <B>LibraryClass</B>. </P>
<P>By defining the methods named <B>LT</B>, <B>EQ</B>, and <B>GT</B>, this class makes it possible for the <B>compare()</B> method to invoke these three methods to compare two objects of type <B>UserClass</B>. </P>
<P>By <U>implementing the interface</U> named <B>Intfc02A</B>, <B>UserClass</B> makes it possible for the method named <B>compare()</B> of the class named <B>LibraryClass </B>to receive objects of this type as the generic type <B>Object </B>(without knowing their true type) and to <B>cast </B>them to type <B>Intfc02A </B>for purposes of invoking the methods of <B>UserClass</B>. </P>
<B><P>UserClass</B> defines three methods that are declared in the interface named <B>Intfc02A</B>. These methods can be used to determine if an object of this class is <I>less than</I>, <I>equal to</I>, or <I>greater than</I> another object of the same class that is passed in as a parameter to the method. </P>
<P>(It probably would have been safer to use the <B>instanceOf()</B> method to confirm that the two objects are of the correct type, and if not to throw an exception.) </P>
<P>The three methods are very similar, so only the one named <B>LT </B>is shown here. </P>
<P>Note first that this class implements the interface named <B>Intfc02A</B> which is a requirement of the method named <B>compare()</B>. </P>
<P>Note next that when the method named <B>LT</B> is invoked on an object of the <B>UserClass</B> type, it receives an object of type <B>Object</B> as a parameter. The object on which it is invoked (<B>this</B>) is to be compared to the object passed in as a parameter. It <B>casts </B>the incoming object to its own type (<B>UserClass</B>) in order to access the instance variable named <B>data</B> that comes in with the object. (Otherwise access to the instance variable would not be possible.) </P>
<P>Finally, note how the parentheses are positioned in the casting operation. It is easy to get this wrong. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class <B>UserClass </B>implements <B>Intfc02A</B>{
  int data;
  
  public boolean LT(Object<B> </B>obj){//test for less than
    if(this.data &lt; ((<B>UserClass)obj).data)return</B> true;
    else return false;
  }//end LT()

  //...</PRE></TD>
</TR>
</TABLE>

<P>That brings us to the class named <B>LibraryClass</B>. This class contains a method that compares two objects of <U>any class</U> that implements the interface named <B>Intfc02A</B>. </P>
<P>(To reiterate, even though we exercised the method named <B>compare()</B> using <U>only</U> objects of type <B>UserClass</B>, the method named <B>compare()</B> can compare two objects of <U>any class</U> that implements the interface named <B>Intfc02A</B>, but as currently written, they must be of the same class.) </P>
<P>The actual comparison methods are <U>defined in the class of the incoming objects</U>. The <B>compare()</B> method of the <B>LibraryClass </B>object <B>casts </B>the incoming objects as the <U>interface type</U> (<B>Intfc02A</B>) and invokes the instance methods of those objects. </P>
<P>Although the method named <B>compare()</B> invokes three different methods on the incoming objects, each invocation is very similar to the other two, so only the invocation of the method named <B>LT</B> is shown here. </P>
<P>Note that the method named <B>compare()</B> receives two incoming objects as the generic type <B>Object</B> and <U>casts only one of them</U> as the interface type in order to invoke its methods, passing the other object intact (<U>without casting</U>) to the method. (Recall that the object is subsequently <B>cast</B> as type <B>UserClass</B> inside the method of class <B>UserClass</B> into which it is passed.) </P>
<P>Again, note the placement of the parentheses in the casting operation. It is critical that you get them placed correctly. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class LibraryClass{
  void <B>compare(Object objA,Object objB</B>){
    System.out.println("objA less than objB? " 
                             + ((<B>Intfc02A)objA).LT(objB</B>) );
  //...
  }//end compare() method
}//end LibraryClass</PRE></TD>
</TR>
</TABLE>

<P>You can view the code that was omitted in the complete program listing that follows in the next section. </P>
<P>A listing of the interface definition is shown below. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Intfc02A.java Copyright 1997, R.G.Baldwin
Interface definition used to support Intfc02.java
Illustrates use of interface.
*/

public <B>interface Intfc02A</B>{
  public boolean <B>LT(Object</B> obj);//test less than
  public boolean <B>GT(Object</B> obj);//test greater than
  public boolean <B>EQ(Object</B> obj);//test equal to  
}//end interface Intfc02A</PRE></TD>
</TR>
</TABLE>

<P>A complete listing of the program follows in the next section. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="programlisting"></A>Program Listing</H3>
</FONT><P>The output from running this program is shown in the comments at the top of the program listing. Some of the interesting code fragments are shown highlighted in <B>boldface</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Intfc02.java Copyright 1997, R.G.Baldwin
This program illustrates the use of an interface to make 
it possible for a method in a library class to invoke a 
method of an object passed in simply as type Object.

Note that the method in the library class isn't required
to know the true type of objects passed in.  However, it
does require that they be of a type that implements the
interface named Intfc02A.  This makes it possible to
cast the incoming object according to that interface type 
and invoke the methods of the object.

This program produces the following output:

<B>Compare 5 and 6
objA less than objB? true
objA equal to objB? false
objA greater than objB? false

Compare 5 and 5
objA less than objB? false
objA equal to objB? true
objA greater than objB? false

Compare 5 and 4
objA less than objB? false
objA equal to objB? false
objA greater than objB? true </B> 
  
This program was tested using JDK 1.1.3 under Win95.
**********************************************************/

//This class is used to test the ability of the method
// named compare() of the class named LibraryClass to
// properly process objects of the class named UserClass.
// The class named UserClass implements an interface
// required by the method named compare() of the class 
// named LibraryClass to make such processing possible.
class <B>Intfc02</B>{
  public static void main(String[] args){
    System.out.println("Compare 5 and 6");
    new <B>LibraryClass().compare(new</B> <B>UserClass(5</B>),
                                         new <B>UserClass(6</B>));
    System.out.println("\nCompare 5 and 5");
    new LibraryClass().compare(new UserClass(5),
                                         new UserClass(5));
    System.out.println("\nCompare 5 and 4");
    new LibraryClass().compare(new UserClass(5),
                                         new UserClass(4));
  }//end main
}//end class Intfc02
//=======================================================//

//This is a user class whose objects are suitable for 
// processing by an object of the class named LibraryClass
// because this class implements the interface named 
// Intfc02A which is a requirement of the compare() method
// of the class named LibraryClass.

//By defining the methods named LT, EQ, and GT, this
// class makes it possible for the compare() method
// to compare two objects of this class using the methods
// defined in this class.  

//By implementing the interface named Intfc02A, this class
// makes it possible for the method named compare() of the
// class named LibraryClass to receive objects of this type
// simply as type Object (without knowing their true type)
// and then cast them to type Intfc02A for purposes of 
// invoking the methods of this class.

class <B>UserClass implements Intfc02A</B>{
  int data;
  
  UserClass(int data){//constructor
    this.data = data;
  }//end constructor
  //-----------------------------------------------------//
  
  //Define three methods that are declared in the 
  // interface named Intfc02A. These methods can be used
  // to determine if an object of this class is less than,
  // equal to, or greater than another object of this
  // class that is passed in as a parameter to the method.
  
  public boolean <B>LT(Object </B>obj){//test for less than
    if(this.data &lt; ((<B>UserClass)obj).data)return</B> true;
    else return false;
  }//end LT()
  //-----------------------------------------------------//
    
  public boolean <B>GT(Object</B> obj){//test for greater than
    if(this.data  ((UserClass)obj).data)return true;
    else return false;
  }//end GT()
  //-----------------------------------------------------//
    
  public boolean <B>EQ(Object</B> obj){//test for equal to
    if(this.data == ((UserClass)obj).data)return true;
    else return false;
  }//end EQ()
    
}//end UserClass
//=======================================================//

//This class contains a method that compares two objects
// of any class that implements the interface named 
// Intfc02A. 

//The actual comparison methods are defined in the class
// of the incoming objects.  The method of this class
// casts those objects as the interface type and invokes
// the instance methods of the objects.
class LibraryClass{
  void <B>compare(Object objA,Object objB</B>){
    System.out.println("objA less than objB? " 
                             + ((<B>Intfc02A)objA).LT(objB</B>) );
    System.out.println("objA equal to objB? " 
                             + ((Intfc02A)objA).EQ(objB) );
    System.out.println("objA greater than objB? " 
                             + ((Intfc02A)objA).GT(objB) );
  }//end compare() method
}//end LibraryClass
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java046d.htm-><!-next=Java046f.htm><!-first=Java046.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review"></A>Review</H2>
</FONT><P>Q - To a limited extent, the interface concept allows you to treat a number of objects, instantiated from different classes, as if they were all of the same type: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - At its simplest level, an interface definition has a <I>name</I>, and <I>declares </I>one or more <I>methods</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q- In an interface definition, both the method signatures and the actual <I>implementations </I>(bodies) of the methods are provided: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Only the method signatures are provided. The actual <I>implementations </I>(bodies) of the methods are <U>not provided</U>.</FONT> </P>
<P>Q - An interface definition can contain only method declarations: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In addition to method declarations, an interface can <U>also declare constants</U>. Nothing else may be included inside the body of an interface definition.</FONT> </P>
<P>Q - If classes P, D, and Q all <I>implement</I> interface X, a reference variable for an object of class P, D, or Q could be assigned to a reference variable of type X: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - If classes P, D, and Q all <I>implement</I> interface X, then all of the methods declared in X must be exactly the same in classes P, D, and Q: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The interface simply declares the signatures for methods. Classes that implement the interface are free to provide a body for those methods which best suits the needs of the class.</FONT> </P>
<P>Q - If classes P, D, and Q all <I>implement</I> interface X a reference variable for an object of class P, D, or Q could be assigned to a reference variable of type X and that reference variable could be used to access all of the methods of the class (which are not excluded using public, private, or protected): True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. If one or more of the classes P, D, and Q, define instance methods which are <U>not declared in the interface X</U>, then a variable of type X <U>cannot</U> be used to access those instance methods. Those methods can only be accessed using a reference variable of the class in which the method is defined. Reference variables of the type X can <U>only be used</U> to access methods declared in the interface X (or one of its superinterfaces).</FONT> </P>
<P>Q - The <B>new</B> operator must be used to instantiate an object which is of the type of an interface: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Even though you can consider the interface name as a type for purposes of storing references to objects, you cannot instantiate an object of the interface type itself.</FONT> </P>
<P>Q - One of the difficulties of implementing interfaces is the requirement to coordinate the definition of interface methods among the classes that implement the interface: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In defining interface methods, each class defines the methods in a manner that is appropriate to its own class <U>without concern</U> for how it is defined in other classes.</FONT> </P>
<P>Q - As with classes, multiple interface definitions can be combined into the same source file: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A- False. The compiler requires interface definitions to be in separate files.</FONT> </P>
<P>Q - List four ways in which interfaces are useful: </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - See the following list:</P>

<UL>
<LI>To a limited extent, the interface concept allows you to treat a number of objects, instantiated from different classes, as if they were all of the same type</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Capturing similarities between unrelated classes without forcing a class relationship</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Declaring methods that one or more classes are expected to implement</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Revealing an object's programming interface without revealing its class (objects such as these are called anonymous objects and can be useful when shipping a package of classes to other developers)</LI></UL>

</FONT><P>Q - A minimum interface declaration contains the Java keyword <B>interface, </B>the name of the interface, and the name of the interface that it extends: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. A minimum interface declaration contains the Java keyword <B>interface</B> and the name of the interface. There is no requirement to specify the name of the interface that it extends, because it may not extend another interface.</FONT> </P>
<P>Q - An interface can <I>extend </I>any number of other interfaces: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Just like a class definition can extend any number of other classes, an interface can <I>extend </I>any number of other interfaces: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. A class can extend only one other class.</FONT> </P>
<P>Q - An interface can <I>extend </I>any number of other interfaces but not more than one class: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. An interface cannot extend a <B>class</B>.</FONT> </P>
<P>Q - An interface inherits all constants and methods from its <I>superinterface</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. See reasons below:</FONT> </P>
<FONT SIZE=2 COLOR="#0000ff"><P>An interface <U>inherits all constants and methods</U> from its <I>superinterface </I>unless:</P>

<UL>
<LI>the interface <I>hides </I>a constant with another of the same name, or</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>redeclares </I>a method with a new method declaration.</LI></UL>

</FONT><P>Q - The method declaration in an interface consists of the method signature followed by a pair of empty curly braces: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The method declaration is <U>terminated by a semicolon</U> and <U>no body</U> (no curly braces) is provided for the method.</FONT> </P>
<P>Q - The keyword <B>private</B> is used to restrict access to the members of an interface only to classes within the same package: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. You may not use <B>private </B>in a member declaration in an interface.</FONT> </P>
<P>Q - All methods declared in an interface are implicitly <I>public </I>and <I>abstract</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In addition to declaring methods, the body of the interface may also define constants. Constant values defined in an interface are implicitly <I>public</I>, <I>static</I>, and <I>final</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - You use an interface by defining a class that extends the interface by name: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. You use an interface by defining a class that <I>implements </I>(not extends) the interface by name.</FONT> </P>
<P>Q - When a class claims to <I>implement </I>an interface, it must provide a full definition for all the methods declared in the interface as well as all of the methods declared in all of the superinterfaces of that interface: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - A class can implement more than one interface by including several interface names in a comma-separated list of interface names, and by providing a full definition for all of the methods declared in all of the interfaces listed as well as all of the superinterfaces of those interfaces: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Whenever a class implements an interface, it is allowed to define only those methods declared in the interface: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Whenever a class implements an interface, the class must define all of the methods declared in the interface, but is also free to define other methods as well.</FONT> </P>
<P>Q - The definition of an interface is a definition of a new reference data type. You can use interface names just about anywhere that you would use other type names, except that you cannot ____________________. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - You cannot <U>instantiate objects of the interface type</U>.</FONT> </P>
<P>Q - Explain in your own words the "bottom line" benefits of the use of an interface. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The interface makes it possible for a method in one class to invoke methods on objects of other classes, without the requirement to know the true class of those objects, provided that those objects are all instantiated from classes that implement one or more specified interfaces. In other words, objects of classes that implement specified interfaces can be passed into methods of other objects as the generic type <B>Object</B>, and the methods of the other objects can invoke methods on the incoming objects by first casting them as the interface type.</FONT> </P>
<P>Q - Write a Java program that meets the following specification. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
/*File SampProg23.java from lesson 46
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates the use of an interface.

Put your interface definitions in the files named 
SampProg23Intfc2.java and SampProg23Intfc1.java.

The interface named SampProg23Intfc2 contains two 
constants named pi and intConstant with values of 3.14
and 125 respectively.

The interface named SampProg23Intfc1 contains 
declarations for set() and get(). set() receives an int 
and returns void.  get() receives nothing and returns 
an int.

Implement both interfaces in ClassA and ClassB.

Implement different versions of set() and get() 
in ClassA and ClassB.

Define a show() method in ClassA that is not declared in
either interface.

Illustrate that a reference of the interface type cannot
be used to invoke the show() method.

The output from running the program should be (line breaks
were manually inserted to force the mater to fit the 
narrow format):
  
Instantiate objA of type ClassA, then set, and show data.
In set() method for classA, using pi: 12.28
In show() method for ClassA, data = 12.28

Assign objA to ref var of type SampProg23Intfc1 named 
objAA.
Invoke set() method on objAA to modify the data.
In set() method for classA, using pi: 24.56
Invoke get() method on objAA to display the modified data.
objA data = 24

Instantiate object of type ClassB named objB.  Assign
 the ref to a type SampProg23Intfc1 ref var.
Invoke its set() method to store some data.
In set() method for classB, using intConstant: 1375
Invoke its get() method to display the data.
objB data = 1375

Successfully assign objA to objB and display objB
objB data = 24

Invoke set() method on objAA to modify its data.
In set() method for classA, using pi: 98.24
Successfully assign objAA to objB and display objB
objB data = 98

Restore objB to its original type and value.
In set() method for classB, using intConstant: 1375
Successfully assign objB to objAA and display objAA
objAA data = 1375

Attempt to assign objB to objA fails because
  "Explicit cast needed to convert SampProg23Intfc1 to 
   ClassA."

Attempt to invoke show() method of objAA fails because
"Method show() not found in interface SampProg23Intfc1".
End of program.  

**********************************************************/

class ClassA implements SampProg23Intfc2,SampProg23Intfc1{
  double data;
  
  //Define versions of set() and get() appropriate to 
  // ClassA
  public void set(int inData){
    data = (double)inData*pi;//note use of pi
    System.out.println(
      "In set() method for classA, using pi: "+data);
  }//end set()
  
  public int get(){
    return (int)data;
  }//end get()
  
  //Define a show method for ClassA not declared 
  // in interface SampProg23Intfc1
  void show(){
    System.out.println(
      "In show() method for ClassA, data = " + data);
  }//end show() method
}//end ClassA
//=======================================================//
class ClassB implements SampProg23Intfc2,SampProg23Intfc1{
  int data;
  
  //Define versions of set() and get() appropriate to 
  // ClassB
  public void set(int inData){
    data = inData*intConstant;//note use of intConstant
    System.out.println(
      "In set() method for classB, using intConstant: "
        + data);
  }//end set()
  
  public int get(){
    return data;
  }//end get()
}//end ClassB
//=======================================================//
class SampProg23{
  public static void main(String[] args){
    System.out.println(
      "Instantiate objA of type ClassA, then set, and "
      + "show data.");
    ClassA objA = new ClassA();
    objA.set(2);
    objA.show();    
  
    System.out.println(
      "\nAssign objA to ref var of type SampProg23Intfc1 "
      + "named objAA.");
    SampProg23Intfc1 objAA = objA;
    System.out.println(
      "Invoke set() method on objAA to modify the data.");
    objAA.set(4);  
    System.out.println(
      "Invoke get() method on objAA to display the "
      + "modified data.");
    System.out.println("objA data = " + objAA.get());
    
    System.out.println(
      "\nInstantiate object of type ClassB named objB.  "
      + "Assign\n"
      + " the ref to a type SampProg23Intfc1 ref var.");  
    SampProg23Intfc1 objB = new ClassB();
    System.out.println(
      "Invoke its set() method to store some data."); 
    objB.set(11);
    System.out.println(
      "Invoke its get() method to display the data.");
    System.out.println("objB data = " + objB.get());

    System.out.println(
    "\nSuccessfully assign objA to objB and display objB");
    objB = objA;
    System.out.println("objB data = " + objB.get());

    System.out.println(
    "\nInvoke set() method on objAA to modify its data.");
    objAA.set(16);    
    System.out.println(
    "Successfully assign objAA to objB and display objB");
    objB = objAA;
    System.out.println("objB data = " + objB.get());
    
    System.out.println(
      "\nRestore objB to its original type and value.");
    objB = new ClassB();//objB already defined as type 
                        // SampProg23Intfc1
    objB.set(11);
    System.out.println(
    "Successfully assign objB to objAA and display objAA");
    objAA = objB;
    System.out.println("objAA data = " + objAA.get());

    System.out.println(
    "\nAttempt to assign objB to objA fails because\n"
      + "  \"Explicit cast needed to convert "
      + "SampProg23Intfc1 to ClassA.\"");
    //statement removed by making it a comment
    //objA = objB; 
    
    System.out.println(
      "\nAttempt to invoke show() method of objAA fails "
        + "because\n"
      + "\"Method show() not found in interface "
      + "SampProg23Intfc1\".");
    //statement removed by making it a comment
    //objAA.show();
    
    System.out.println("End of program.");

  }//end main
}//end class SampProg23</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg23Intfc1.java from lesson 46
Copyright 1997, R.G.Baldwin
Interface definition used to support SampProg23.java
Illustrates use of interface.
*/

public interface SampProg23Intfc1{
  void set(int inData);
  int get();
}//end interface SampProg23Intfc1.java
//==================================================</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg23Intfc2.java from lesson 46
Copyright 1997, R.G.Baldwin
Interface file to support File SampProg23.java
Illustrates use of interface.
*/

public interface SampProg23Intfc2{
  public final double pi = 6.14;
  public final int intConstant = 125;
}//end interface SampProg23Intfc2
//=============================================</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java046e.htm-><!-first=Java046.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
