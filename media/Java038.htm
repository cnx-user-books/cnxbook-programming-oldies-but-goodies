<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Expressions in Java by Richard G Baldwin </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Classes<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 38, Revised 10/01/99</P>


<P>
<!-toc file=Java038a.htm words=Preface-><A HREF="#preface">Preface</A><BR><!--endtoc-->
<!-toc file=Java038b.htm words=Introduction-><A HREF="#introduction">Introduction</A><BR><!--endtoc-->
<!-toc file=Java038c.htm words=The Creation of Classes-><A HREF="#thecreationofclasses">The Creation of Classes</A><BR><!--endtoc-->
<!-toc file=Java038d.htm words=The Class Declaration-><A HREF="#theclassdeclaration">The Class Declaration</A><BR><!--endtoc-->
<!-toc file=Java038e.htm words=Declaring the Superclass of a Class-><A HREF="#declaringthesuperclassofaclass">Declaring the Superclass of a Class</A><BR><!--endtoc-->
<!-toc file=Java038f.htm words=Identifying Interfaces Implemented by a Class-><A HREF="#identifying">Identifying Interfaces <I>Implemented</I> by a Class</A><BR><!--endtoc-->
<!-toc file=Java038g.htm words=The Body of the Class-><A HREF="#thebodyoftheclass">The Body of the Class</A><BR><!--endtoc-->
<!-toc file=Java038h.htm words=Review-><A HREF="#review">Review</A><!--endtoc-->
</P>




<P><!-next=Java038a.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of persons already familiar with C++ and who are making the transition into Java. </P>




<P><!-prev=Java038.htm-><!-next=Java038b.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><P>An <I>object </I>is an <I>instance of a class</I>. </P>
<P>All variables and functions in Java <U>must</U> be contained in a class or an object. </P>
<P>Three primary characteristics of an object-oriented programming language are: </P>

<UL>
<I><LI>encapsulation</I> </LI>
<I><LI>inheritance</I> </LI>
<I><LI>polymorphism</I>.</LI></UL>

<P>The class is the central concept of Java that supports <B>encapsulation</B>. </P>
<P>The class <U>provides the plan</U> from which objects are built. This plan defines the <U>data</U> that is to be stored in an object, and the <U>methods</U> for manipulating that data. </P>
<P>The data is variously referred to as <I>data members,</I> <I>fields</I>, and <I>variables</I>, depending on which book you are reading. </P>
<P>The data can be sub-divided further into <I>static </I>or <I>non-static</I>, often referred also as <I>class variables</I> and i<I>nstance variables</I> respectively. </P>
<P>The methods are also often referred to as <I>member functions</I>, and can be <I>static </I>or <I>non-static</I>. </P>
<P>Static methods are often referred to as <I>class methods</I> while non-static methods are often referred to as <I>instance methods</I>. </P>
<P>We say that objects instantiated from a class have <I>state </I>and <I>behavior</I>. </P>
<P>The current state of an object is determined by the <U>current values of its variables</U> and its behavior is defined by its <U>methods</U>. </P>




<P><!-prev=Java038a.htm-><!-next=Java038c.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="thecreationofclasses"></A>The Creation of Classes</H2>
</FONT><P>The definition of a class deals with two parts: <I>declaration </I>and <I>body </I>using the general syntax shown below. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>classDeclaration{
  classBody
}</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ programmers should note that the closing curly brace in a class definition is <U>not </U>followed by a semicolon as is the case in C++.</TD>
</TR>
</TABLE>

<P>The <I>declaration </I>notifies the compiler of the <I>name </I>of the class, and also can provide other information such as </P>

<UL>
<LI>the class from which it is derived (<I>superclass</I>), </LI>
<I><LI>access </I>privileges, and </LI>
<LI>whether or not it <I>implements </I>one or more <I>interfaces</I>.</LI></UL>

<P>The class body contains the <I>declarations </I>for, and possibly the <I>initialization </I>of, all data members (both class variables and instance variables) as well as the <U>full definition</U> of all <I>methods</I>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ programmers should note that unlike C++, the f<U>ull definition of all methods</U> (both class methods and instance methods) must appear <U>inside the class definition</U>, and this does <U>not </U>make them <I>inline </I>methods. The concept of an <I>inline </I>method is <U>not supported</U> by Java.</TD>
</TR>
</TABLE>

<P>Variables may be declared either </P>

<UL>
<LI>inside the body of the class (member variables), or </LI>
<LI>inside the body of a method in the class (local variables).</LI></UL>

<P>(Variables can also be declared in the formal argument list of methods and in the argument list of exception handlers. We will have more to say about this later.) </P>
<P>Note that variables that are declared inside the body of a method are <U>not member variables</U> of the class. Rather, they are <U>local variables</U> in the method. </P>
<P>Therefore, we could expand our general syntax diagram to be as shown below. This diagram may be helpful as long as you <U>don't take it too literally</U>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>className{
  //instance variable declarations
  //class variable declarations
  //instance methods{
      //local variables
      //control code
    }//end instance method
  //class methods{
      //local variables
      //control code
    }//end class method
}//end class definition</PRE></TD>
</TR>
</TABLE>





<P><!-prev=Java038b.htm-><!-next=Java038d.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="theclassdeclaration"></A>The Class Declaration</H3>
</FONT><P>The <I>minimum </I>information in a class declaration must include </P>

<UL>
<LI>the <B>class </B>keyword, and </LI>
<LI>the <I>name </I>of the class.</LI></UL>

<P>Class <I>names </I>must be <U>any legal Java identifiers</U>. By convention, many Java programmers begin the name of the class using an upper-case letter. </P>
<P>In Java, the name of the class becomes the name of a new type. </P>
<P>In addition to naming the class, the declaration can also provide the following information: </P>

<UL>
<LI>The class from which this class is derived (its <I>superclass</I>) </LI>
<LI>A list of <I>interfaces </I>implemented by the class </LI>
<LI>Whether the class is <B>public</B>, <B>abstract</B>, or <B>final</B>.</LI></UL>





<P><!-prev=Java038c.htm-><!-next=Java038e.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="declaringthesuperclassofaclass"></A>Declaring the Superclass of a Class</H4>
</FONT><P>By default, every class in Java is derived, either directly or indirectly, from the class named <B>Object</B>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ does not have a class that is the <I>superclass </I>of all other classes, such as <B>Object</B> in Java.</TD>
</TR>
</TABLE>

<P>A new class may be derived directly from <B>Object</B>, or may be derived from another class that is derived from <B>Object</B> or may be derived from another class further down the inheritance hierarchy. </P>
<P>The immediate parent class of a new class is known as its <I>superclass</I>. (Sometimes we use the word <I>superclass</I> to indicate the collection of classes in the inheritance hierarchy from which a specific class is derived.) </P>
<P>If you do not specify the <I>superclass </I>for a new class, it will derive directly from <B>Object</B>. (The <B>Object </B>class is defined in the package named java.lang.) </P>
<P>The keyword <B>extends</B> is used in the class declaration to specify the immediate <I>superclass </I>of the new class using the syntax shown below. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class MyNewClassName <B>extends </B>SuperClassName{
  //body of class
}</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ programmers should note that inheritance in Java does <U>not </U>involve a specification of an access specifier, <I>public</I>, <I>private</I>, or <I>protected</I> at the inheritance interface. In other words, inheritance access control cannot be used in Java to modify the access control assigned to a member of the parent class.</TD>
</TR>
</TABLE>

<P>Although it is <U>allowable</U> to extend <B>Object </B>as shown below, this <U>isn't necessary</U> because <B>Object </B>is the default parent class when no other parent class is specified. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class MyNewClassName <B>extends Object</B>{
  //body of class
}</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A class inherits the variables and methods of its superclass, and of the superclass of that class, etc., all the way back up the family tree to the single class which is the root of all inheritance: <B>Object</B>.</TD>
</TR>
</TABLE>

<P>Thus, an object that is instantiated from a class contains all the variables and methods defined for that <U>that class and all its ancestors</U>. </P>
<P>However, the methods may have been modified <I>(overridden)</I> somewhere along the way. Also, access to those variables and methods may have been restricted through use of the <B>public</B>, <B>private</B>, and <B>protected</B> keywords. </P>
<P>We will be discussing much of this in increasing detail as we continue through this lesson. </P>




<P><!-prev=Java038d.htm-><!-next=Java038f.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="identifying">Identifying Interfaces <I>Implemented</I> by a Class</A></H3>
</FONT><P><A HREF="#publicabstractandfinalclasses">Public, Abstract, and Final Classes</A><BR>
<A HREF="#abriefwordaboutpackages">A Brief Word About Packages</A><BR>
<A HREF="#publicclasses">Public Classes</A><BR>
<A HREF="#abstractclasses">Abstract Classes</A><BR>
<A HREF="#finalclasses">Final Classes</A><BR>
<A HREF="#classdeclarationsummary">Class Declaration Summary</A></P>
<P>&nbsp;</P>
<P>According to Campione and Walrath, http://java.sun.com/books/Series/Tutorial/java/javaOO/interfaces.html, The Java Tutorial: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>An <B>interface </B>declares a set of methods and constants <U>without</U> specifying the implementation for any of the methods.</TD>
</TR>
</TABLE>

<P>A class may <I>implement </I><U>one or more</U> interfaces using the keyword <B>implements </B>and a comma-delimited list of <B>interface </B>names as shown below. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class MyClassName <I>extends </I><B>MySuperClass 
</B><I>                  implements </I><B>MyInterface</B>, <B>UrInterface </B>{
  //body of class
}</PRE></TD>
</TR>
</TABLE>

<P>Whenever a <B>class </B>claims to implement an <B>interface</B>, you can be assured that it provides a definition for all the methods declared within that <B>interface</B>. Otherwise, the <B>class </B>cannot be compiled. </P>
<P>There is a similarity between an <B>interface </B>and an <B>abstract </B>class, which will be discussed later. However, while an <B>abstract </B>class may contain some method definitions, method definitions are not allowed in an <B>interface</B>. Therefore, the purpose of the <B>interface </B>matches the name. Its sole purpose is to <I>declare </I>the <B>interface</B>, but not to define how that <B>interface </B>is implemented. </P>
<P>We will have a lot more to say about the <B>interface</B> in a subsequent lesson, particularly with respect to how and why you would use it. For the time being, let it suffice to say that if your class <I>implements</I> an <B>interface</B>, you must provide a complete definition for all methods declared in the <B><I>interface</B></I>. </P>
<P>When implementing an <B>interface</B>, the method signatures of the methods defined in the class <U>must match</U> the signatures of the methods declared in the <B>interface</B>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="publicabstractandfinalclasses"></A>Public, Abstract, and Final Classes</H4>
</FONT><P>Classes can be declared to be either <B>public</B>, <B>abstract</B>, or <B>final</B>, or some <I>combination </I>of the three. This is accomplished using the appropriate modifiers ahead of the keyword <B>class </B>in the class declaration. However, before we can make any sense out of this, we need to know a little about how classes are grouped into packages. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="abriefwordaboutpackages"></A>A Brief Word About Packages</H4>
</FONT><P>Later we will learn how to group classes into packages. For the time being, consider a <I>package </I>to be a <U>group of probably related classes</U> in the same subdirectory. </P>
<P>In the simplest case, the classes must be in a <I>directory </I>having the <U>same name as the package</U>. As a practical matter, for those familiar with pathnames, you can consider the package to be the same as the fully-qualified pathname to the directory containing a specific class file. </P>
<P>For example, again, quoting Campione and Walrath, </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>"the <I>.class</I> files for <I>java.util</I> are in a directory named <I>util </I>in a directory named <I>java </I>somewhere in your CLASSPATH." </TT></TD>
</TR>
</TABLE>

<P>For the time being, consider <I>CLASSPATH </I>to be a system environmental variable (that can be set at runtime or in your autoexec.bat file) which tells your system where to search for the required class files. </P>
<P>However the <I>simplest case</I> described above <I>doesn't normally exist</I> and this can lead to some confusion. After installing a Java development kit such as Sun's JDK 1.1.5, it is <U>not likely</U> that you will find a directory named java which has a subdirectory named util which contains a large number of files with an extension of class. </P>
<P>The later versions of Java have the capability to search <I>consolidated </I>files using the <I>zip consolidation </I>technology. This results in a considerable savings of disk space. The zip <I>consolidation </I>technology has the ability to remember the directory structure that contained the files before they were <I>consolidated</I>. Therefore it is probably closer to the truth to paraphrase the above quotation something like the following: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Somewhere on your disk, you will find a zip file containing a large number of class files. <U>Prior to consolidation</U>, the <I>.class</I> files for <I>java.util</I> were in a directory named <I>util, which</I> was in a directory named <I>java</I>. Wherever this zip file is stored, it must be somewhere in your CLASSPATH.<TT> </TT></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="publicclasses"></A>Public Classes</H4>
</FONT><P>Before getting into access control for classes, note that there is no special relationship between the inheritance hierarchy and the location of class files in packages. A class file may be in the same package as the class file for its superclass, or it may be in a different package. Similarly, it may or may not be in the same package as the class files for its siblings. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>By default, a class can be <U>used only</U> by the objects of other classes in the <U>same</U> package.</TD>
</TR>
</TABLE>

<P>You can make the class available to objects of classes <U>outside</U> that package by declaring it to be <B>public </B>using the following syntax. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><B>public </B>class MyClass extends MySuperClass 
                     implements MyIntfc, UrIntfc {
  //body of class
}</PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="abstractclasses"></A>Abstract Classes</H4>
</FONT><P>An <B>abstract </B>class is a class that is <U>designed to be inherited from</U> <I>(subclassed)</I>. It is <U>not </U>intended to be a class from which objects are instantiated. </P>
<P>An <B>abstract </B>class may contain <B>abstract </B>methods, but this is <U>not a requirement</U>. </P>
<P>An <B>abstract </B>method is a method for which only the method signature (known as a function prototype in C++) is provided. We will discuss the reasons for creating <B>abstract </B>classes later. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="finalclasses"></A>Final Classes</H4>
</FONT><P>The opposite of an <B>abstract </B>class is a <B>final </B>class. A <B>final </B>class <U>cannot be subclassed</U>. The reasons for using <B>final </B>classes will also be discussed later. </P>
<P>While it is technically possible to declare a class with several combinations of <B>public</B>, <B>abstract</B>, and <B>final</B>, it doesn't make any sense to cause a class to be both <B>abstract </B>and <B>final</B>, and an attempt to do so will result in a <U>compiler error</U>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="classdeclarationsummary"></A>Class Declaration Summary</H4>
</FONT><P>Taking all factors into account, the syntax for a class definition is as follows: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><I>Modifiers</I> <B>class ClassName</B> <I>extends SuperClassName 
                          implements InterfaceNames</I> {
  ...
}</PRE></TD>
</TR>
</TABLE>

<P>where the items in Italics are optional and the items in boldface are required. </P>

<UL>
<I><LI>Modifiers </I>declare whether the class is <B><I>public</B></I>, <B><I>abstract</B></I>, or <B><I>final</B>.</I> </LI>
<B><LI>ClassName </B>defines the name that will be used to instantiate objects of the type or to access class members. This becomes the name of a new type. </LI>
<B><I><LI>SuperClassName </B></I>is the name of the <I>immediate superclass</I> from which the class is <I>subclassed</I>. </LI>
<B><I><LI>InterfaceNames</I> </B>is a comma-separated list of interfaces <I>implemented </I>by the class.</LI></UL>

<P>Other than the opening and closing braces, <U>only </U>the <U>class keyword</U> and the <U>name</U> for the class are <U>required</U>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>If you don't specify otherwise, Java assumes a<I> non-final, non-public, non-abstract, subclass</I> of the class <B>Object </B>that <I>doesn't </I>implement any interfaces.</TD>
</TR>
</TABLE>
<P>. </P>




<P><!-prev=Java038e.htm-><!-next=Java038g.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="thebodyoftheclass"></A>The Body of the Class</H3>
</FONT><P><A HREF="#membervariables">Member Variables</A><BR>
<A HREF="#constants">Constants</A><BR>
<A HREF="#methods">Methods</A> </P>
<P>As mentioned earlier, the definition of a class consists of two parts: </P>

<UL>
<LI>declaration </LI>
<LI>body.</LI></UL>

<P>The previous section described the class declaration. This section describes the class body. </P>
<P>The body is made up of two types of members: </P>

<UL>
<LI>variables </LI>
<LI>methods.</LI></UL>

<P>Each of these comes in two varieties, </P>

<UL>
<LI>class </LI>
<LI>instance</LI></UL>

<P>(as in <I>class variables</I> and <I>instance variables</I>). </P>
<P>An object instantiated from a class is said to have </P>

<UL>
<LI>state </LI>
<LI>behavior.</LI></UL>

<P>The current values of the variables define the current <I>state </I>of an object, while the methods define its <I>behavior</I>. </P>
<P>Typically in object-oriented programming, we <U>restrict direct access to the variables</U> and provide access to those variables only through <I>accessor methods</I>, but this is <U>not</U> required. </P>
<P>Some or all of the variables may be declared in such a way (using the keyword <B>final</B>) that they behave like constants . </P>
<P>Objects instantiated from the class contain all the <I>members</I> of the class, and may also contain other members that are inherited from the superclass and its ancestors. </P>
<P>For example, all objects in Java inherit directly or indirectly from the <B>Object </B>class. Thus, every object contains the members of the <B>Object </B>class. </P>
<P>Therefore, the <B>Object </B>class defines the basic state and behavior of every object in Java. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Note that this <U>differs significantly</U> from C++ where there is no central class from which all other classes inherit. Thus, there is no basic definition of the state and behavior of a class in C++.</TD>
</TR>
</TABLE>

<P>The <B>Object </B>class imparts several important behaviors to its descendants including: </P>

<UL>
<LI>ability to <I>compare </I>oneself to another object </LI>
<LI>ability to <I>convert </I>to a string </LI>
<LI>ability to <I>wait </I>on a condition variable </LI>
<LI>ability to <I>notify </I>other objects that a condition variable has changed, etc. </LI>
<LI>ability to <I>create a new object</I> that is the clone of an existing object </LI>
<LI>ability to define code that will be executed immediately prior to garbage collection of an object </LI>
<LI>ability to <I>identify the class type</I> for an existing object</LI></UL>

<P>These capabilities will be discussed in more detail later when we discuss the Java standard library classes. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="membervariables"></A>Member Variables</H4>
</FONT><P>The minimum declaration for member variables in both Java and C++ includes the <I>type </I>and the <I>name </I>using the following syntax. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>type variableName;</PRE></TD>
</TR>
</TABLE>

<P>This syntax is the <U>same</U> as used when declaring variables in other parts of the program, such as </P>

<UL>
<LI>declaring local variables in methods </LI>
<LI>declaring arguments in the formal argument list for methods </LI>
<LI>declaring arguments in the formal argument list for exception handlers.</LI></UL>

<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A <U>member variable</U> declaration appears <U>within</U> the class body, but <U>outside</U> the definition of any method.</TD>
</TR>
</TABLE>

<P>A variable declared <U>within</U> the definition of a method becomes a <U>local</U> variable to that method and is <U>not</U> a member variable of the class. </P>
<P>The <I>type </I>of a member variable determines the values that can be assigned to it as well as the operations that can be performed on it. </P>
<P>The <I>name </I>of a member variable can be any legal Java identifier. </P>
<P>Typically Java programmers begin the variable name with a <U>lower-case letter</U>, but this is not required. </P>
<P>The names of all member variables must be <U>unique within the class</U>. </P>
<P>In Java, a member <I>variable </I>and a <I>method </I>can have the <U>same name</U>. </P>
<P>Java allows you to <U>initialize</U> member variables when you declare them. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, member variables may not have the same name as methods. If they are the same, a compiler error will result. </P>
<P>Beyond simply declaring the type and the name of a member variable, there are some differences between Java and C++, in syntax and interpretation. Some of those differences follow: </P>

<UL>
<LI>Both languages allow you to declare static member variables using the same syntax with generally the same interpretation (but in C++, you <U>must re-declare</U> static member variables outside the class definition).. </LI>
<LI>Both languages allow you to provide an access specifier for the member variable using the keywords public, private, and protected, but the <U>syntax and the interpretation is different</U> between the two languages. </LI>
<LI>Both languages (are intended to) recognize the keyword <I>volatile </I>using generally the same syntax with generally the same interpretation. However, Sun's JDK 1.0 ignores volatile. </LI>
<LI>C++ does not recognize the keywords <I>transient </I>and <I>final </I>used with member variable declarations in Java. </LI></UL>

<P>In addition to the differing use of syntax and attributes described above, Java allows you to <U>initialize</U> member variables of primitive types with you declare them. This is <U>not allowed</U> in C++.</TD>
</TR>
</TABLE>

<P>The complete syntax of a member variable declaration in Java is as follows where the italicized items are optional and the boldface items are required. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><I>accessSpecifier static final transient volatile</I> <B>type variableName</B> 
<I>       = initialValueForPrimitiveTypes or new type(optionalParameters)</I><B>;</PRE></B></TD>
</TR>
</TABLE>

<P>A brief interpretation of the modifiers is described below. More detailed discussions follow in this or other lessons. </P>

<UL>
<I><LI>accessSpecifier </I>determines which other classes have access to the variable. </LI>
<I><LI>static </I>determines whether the variable is a <I>class variable</I> or an <I>instance variable</I>. </LI>
<I><LI>final </I>indicates that the variable is a constant and <U>cannot be modified</U>. </LI>
<I><LI>transient </I>variables are apparently not supported as of this writing (Dec. 97 )and will not be discussed further. </LI>
<I><LI>volatile </I>variables are apparently not supported as of this writing (Dec. 97) and will not be discussed further.</LI></UL>

<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Another important difference between Java and C++ has to do with the declaration of static member variables. In C++, if you declare a member variable to be static within a class, you must <U>re-declare</U> it again outside the class using the name of the class, the name of the variable, and the scope resolution operator. If it is of a primitive type, you can also initialize it when you re-declare it, but that is not required. </P>
<P>Java does <U>not</U> require re-declaration of static member variables outside the class, and if they are of primitive type, they can be initialized inside the class when they are declared.</TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="constants"></A>Constants</H4>
</FONT><P>The <B>final</B> keyword is used in Java to cause a variable to <U>behave like a constant</U>, meaning that it cannot be modified after it is declared and initialized. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The <B>final </B>keyword is not supported by C++.</TD>
</TR>
</TABLE>

<P>Because a <B>final</B> variable is a constant, it must be given a value (initialized) <U>when it is declared</U>. A typical declaration of a final variable follows: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class Circle{
  <B>final </B>float PI = 3.14159;
  ...
}</PRE></TD>
</TR>
</TABLE>

<P>If you write code that attempts to modify a final variable, you will get a compiler error. </P>
<P>Later we will learn that the <B>final </B>keyword can also be applied to methods, meaning that they <U>cannot be overridden</U>. Similarly, the <B>final</B> keyword can be applied to class definitions meaning that they <U>cannot be subclassed</U>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="methods"></A>Methods</H4>
</FONT><P><A HREF="#themethoddeclaration">The Method Declaration</A><BR>
<A HREF="#returningavaluefromamethod">Returning a Value from a Method</A><BR>
<A HREF="#thenameofthemethod">The Name of the Method</A><BR>
<A HREF="#otherelementsofamethoddeclaration">Other Elements of a Method Declaration</A><BR>
<A HREF="#passinginformationtoamethod">Passing Information to a Method</A><BR>
<A HREF="#thethiskeyword">The<I> this </I>Keyword</A><BR>
<A HREF="#thesuperkeyword">The <I>super</I> Keyword</A><BR>
<A HREF="#localvariables">Local Variables</A></P>
<P>&nbsp;</P>
<P>The implementation of a method can also be thought of as consisting of two parts: </P>

<UL>
<LI>declaration </LI>
<LI>body.</LI></UL>

<P>This can be seen schematically in the following. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>returnType functionName( formal argument list){
  //body
}</PRE></TD>
</TR>
</TABLE>

<P>In both Java and C++, the minimum declaration consists of </P>

<UL>
<LI>return type </LI>
<LI>name </LI>
<LI>formal argument list.</LI></UL>

<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In Java, the full definition of the method, including the body, <U>must </U>be placed <U>inside the class definition</U>.</TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the method can be declared inside the class definition with the full definition including the body being placed outside the class. Alternately, under certain circumstances, in C++, the full definition <U>can </U>be placed inside the class definition, which makes it an <I>automatic inline function</I>. </P>
<P>Placing the full definition of the method inside the class definition in Java does <U>not </U>cause it to be an <I>inline </I>method. Java doesn't support the concept of <I>inline</I> methods. </P>
<P>Java does not make provisions for the programmer to distinguish between inline and ordinary methods. (Sometimes the compiler may choose to make a method inline for efficiency purposes.)</TD>
</TR>
</TABLE>

<P>In both Java and C++, methods may have <U>numerous other attributes</U> including <I>access </I>control, <I>static </I>or <I>non-static,</I> etc. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The syntax used to cause a method to be static as well as the interpretation of static methods is generally the same between Java and C++ (although the syntax used to access a static method differs between the two). </P>
<P>The syntax used to establish <I>access control</I> and the interpretation of access control <U>differs significantly</U> between Java and C++.</TD>
</TR>
</TABLE>

<P>In both Java and C++, parameters are optional, and in both cases, the formal argument list (method signature) consists simply of a set of <U>empty parentheses</U> if there are no parameters. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Optionally C++ allows the keyword void to be used in an empty argument list. Pascal omits the parentheses entirely when there are no parameters for a function or procedure.</TD>
</TR>
</TABLE>

<P>The parameters are used in both Java and C++ to <U>pass information to</U> the body of the method, and can also be used to <U>pass information from</U> the body of the method back to the calling method in certain situations. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Stated differently, method parameters are used to provide information to a method from outside the scope of the method or to pass information from the scope of the method to the outside world.</TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="themethoddeclaration"></A>The Method Declaration</H4>
</FONT><P>The method declaration in both Java and C++ provides the following information: </P>

<UL>
<I><LI>Name </I>of the method </LI>
<I><LI>Type </I>of return value or <I>void</I> for none </LI>
<I><LI>Number</I>, <I>types</I>, and <I>order </I>of arguments </LI>
<I><LI>Access </I>control</LI></UL>

<P>The <U>minimum</U> required information is the </P>

<UL>
<LI>return type </LI>
<LI>name </LI>
<LI>number and type of arguments.</LI></UL>

<P>In some cases, the number of arguments is zero, in which case the argument list is simply left blank. </P>
<P>Java and C++ use the <U>same syntax</U> and <U>same interpretation</U> for the name, return type, and arguments. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The syntax and interpretation of <I>access control</I> is significantly <U>different</U> between Java and C++.</TD>
</TR>
</TABLE>

<P>The following code fragment shows a minimal method declared within a class. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class MyClass{
  ...
<B>  int myMethod(){      
    ...
  }</B>//end myMethod
}//end class</PRE></TD>
</TR>
</TABLE>

<P>This code declares a method named <B>myMethod, which</B> returns a value of type <B>int </B>and requires <U>no arguments</U>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="returningavaluefromamethod"></A>Returning a Value from a Method</H4>
</FONT><P>Both Java and C++ require that the method declaration indicate the type of the return value. </P>
<P>If there is no return value, the type of the return value must be specified as <B>void</B>. </P>
<P>In both Java and C++, the <B>return </B>keyword is used to return a value (or an object) using the syntax shown below. </P>
<P>The <B>return</B> keyword is followed by an expression which evaluates to the value (or object) to be returned. The expression can be very complex, or can be as simple as the name of an object, a primitive variable, or a constant. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>return <I>expression</I>;</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Methods and functions in C++ can return a variable or object either by <I>value </I>(a copy is returned), by <I>pointer</I>, or by <I>reference</I>. </P>
<P>Java does not support pointers, so it cannot return a pointer.</TD>
</TR>
</TABLE>

<U><P>All primitive types</U> in Java are <U>returned by value</U> which means that a copy of the result of evaluating the expression is returned. </P>
<U><P>All object types</U> in Java are often said to be <U>returned by reference</U>. </P>
<P>What this really means is that a <U>copy of a reference variable</U> is returned meaning that the reference variable is actually returned by value. </P>
<P>However, since the copy of the reference variable can be used to access the object, it doesn't matter that it is only a copy. Furthermore, the existence of the copy of the reference variable is sufficient to prevent the object from becoming eligible for garbage collection when the method terminates. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>As a practical matter, returning a reference to an object in Java is similar to returning a pointer to a dynamically allocated object in C++, except that the syntax for dealing with the returned item is much simpler in Java. In either case, the item that is returned is the (direct or indirect) address of a location in dynamic memory where the object is stored.</TD>
</TR>
</TABLE>

<P>The following Java application illustrates returning by value and by reference. The output from the program is shown in the comments at the beginning of the program. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File return3.java Copyright 1997, R.G.Baldwin
Illustrates returning by value and by reference in Java.

The output from the program is:

<B>Value returned is 5
Value of instance variable in returned object is 10
</B>********************************************************/

//An object of this class will be returned by reference
class <B>NewClass</B>{ 
  int instanceVariable = 10;
}//end NewClass
//=====================================================//

class <B>return3 </B>{ //define the <B>controlling class

</B>  int <B>returnValue</B>() {//function which returns by value
    return 5; //return a primitive type by value
  }//end returnValue()
  //---------------------------------------------------//

  //function which returns by reference  

  NewClass <B>returnReference</B>() {
    return <B>new NewClass();//return</B> an object by reference
  }//end returnReference()
  //---------------------------------------------------//

  public static void <B>main</B>(String[] args){ //main method
    return3 obj = <B>new return3();//instantiate</B> object
    System.out.println(
              "Value returned is " + <B>obj.returnValue()</B> );
    System.out.println(
      "Value of instance variable in returned object is "
              + <B>obj.returnReference().instanceVariable</B> );
  }//end main
}//End return3 class.</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The following C++ program is similar to the above Java application. In this case, the program illustrates returning by <I>value</I>, <I>pointer</I>, and <I>reference</I>. If you examine the structure of this program carefully and compare it with the above Java application, you will note that returning by pointer in C++ is very similar to returning by reference in Java, because <U>all reference objects in Java are instantiated in dynamic memory</U> (on the heap). </P>
<P>In C++, you must make certain that anything that you return by reference is guaranteed to persist after the function terminates. For that reason, the value that was returned by reference was made a static variable in the following C++ program. </P>
<P>The output from running this program is shown in the comments near the beginning of the program. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>/*File return3.cpp Copyright 1997, R.G.Baldwin
Illustrates returning by value, reference, and pointer
in C++.

The output from this program was:

Value returned by value was 5
Value returned by reference was 15
Value contained in object returned by pointer was 10

******************************************************/

#include&lt;iostream.h
//an object of this type will be returned by pointer
class NewClass{
public:
  int instanceVariable;
  NewClass(){instanceVariable = 10;}//constructor
};//end NewClass

  //function to return by value
  int returnValue() {return 5;}

  //function to return by reference
  int returnReference(){
    static int localVar = 15;
    return localVar;
  }//end returnReference()

  //function to return by pointer
  NewClass* returnPointer() {
    return new NewClass;
  }//end returnPointer()

class return3 {
public:
  static void classMain(){
  cout &lt;&lt; "Value returned by value was "
                                &lt;&lt; returnValue() &lt;&lt; endl;
  cout &lt;&lt; "Value returned by reference was "
                            &lt;&lt; returnReference() &lt;&lt; endl;
  cout &lt;&lt; "Value contained in object returned by pointer"
    " was " &lt;&lt; returnPointer()-instanceVariable &lt;&lt; endl;
  }//end classMain
};//End return3 class definition.
//=====================================================//

void main()
{
  //call the class method named classMain
  return3::classMain();
}//end main

//End C++ program</PRE></TD>
</TR>
</TABLE>

<U><P>Neither</U> Java nor C++ <U>require</U> that the calling program <U>recognize</U> the return value. On the other hand, all but the very latest Pascal compilers require that the program recognize returned values from functions. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>All but the very latest Pascal compilers require that the program recognize returned values from functions.</TD>
</TR>
</TABLE>

<P>If a Java program returns a reference to an object and that reference is not assigned to a reference variable (or used in a larger overall expression), the object is immediately eligible for garbage collection (assuming that the reference is not already stored in some other reference variable). </P>
<P>This is illustrated by the following Java application, which makes a call to a method that returns a reference, but ignores the returned reference. The program then requests garbage collection and goes to sleep for one second. The object that was ignored is finalized and garbage collected while the main thread is sleeping and before the program actually terminates. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File return4.java Copyright 1997, R.G.Baldwin
Illustrates ignoring a return value in Java.

The ignored object is finalized and garbage collected
before the program terminates.

The output from the program is:

<B>This program ignores returned object
Requesting garbage collection
Going to sleep for one second
Finalizing object 10
Terminating program
</B>********************************************************/

//An object of this class will be returned by reference
class <B>NewClass</B>{ 
  int instanceVariable = 10;
  //---------------------------------------------------//
    
  //Override the finalize method for this class
  protected void <B>finalize</B>(){
    System.out.println("Finalizing object " 
                                    + instanceVariable);
  }//end overridden finalize method  
}//end NewClass
//=====================================================//

class <B>return4 </B>{ //define the controlling class
  //function which returns by reference
  NewClass <B>returnReference</B>() {
    <B>return new NewClass();//return</B> object by reference
  }//end returnReference()
//-----------------------------------------------------//

  public static void <B>main</B>(String[] args){//main method
    //Set up to run finalizer on exit
    System.runFinalizersOnExit(true);
    
    return4 obj = new return4();//instantiate object
    
    //Call method and ignore return value
    <B>obj.returnReference()</B>; 
    System.out.println(
              "This program ignores returned object");
    System.out.println("Requesting garbage collection");
    <B>System.gc();//request</B> garbage collection 
    System.out.println("Going to sleep for one second");
    try{
      Thread.currentThread().sleep(1000);
    }catch(InterruptedException e){}
    System.out.println("Terminating program");
  }//end main
}//End return4 class.</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>If a C++ program returns a pointer to an object in dynamic memory and the value of that pointer is not assigned to a pointer variable, the opportunity to return that memory to the operating system is <U>lost forever</U>, and a <U>memory leak</U> will have occurred (assuming that the address is not already stored in some other pointer variable).</TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In Java, the type of the returned value or object must <U>match</U> the return <U>type</U> specified in the method declaration, <B>or </B>must <U>match a subclass</U> of the specified type.</TD>
</TR>
</TABLE>

<P>Matching a subclass of the specified type is possible because all classes in Java inherit from the common root <B>Object</B>, and generally it is acceptable to store a reference to an object in a reference variable which is a superclass of that object. </P>
<P>Later we will discuss the topics of <I>upcasting </I>and <I>downcasting </I>to deal with situations of this sort. </P>
<P>Later we will also discuss using the <U>interface as a type</U>. If the return type is an interface type, the returned object in Java must implement the specified interface. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the type of the returned value <U>must match</U> the return type specified in the method declaration,</TD>
</TR>
</TABLE>

<P>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="thenameofthemethod"></A>The Name of the Method</H4>
</FONT><P>The name of the method can be any legal Java or C++ identifier, depending on the language being used.</P>
<B><I><P>Method Overloading:</B></I> Both Java and C++ support a concept known as <I>method overloading</I>. </P>
<I><P>Method overloading</I> allows two or more methods to <U>share the same name</U>, provided that the <U>formal argument lists</U> of the two are different in a way which is discernible to the compiler. </P>
<P>In other words, the compiler must be able to examine a call to the method and determine, on the basis of the parameters being passed to the method, which version of the method to use in that instance. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, some argument lists may appear at first glance to be different, but are not discernibly different to the compiler due to factors such as default arguments and automatic type conversions. This results in ambiguity errors at compile time.</TD>
</TR>
</TABLE>

<P>The compiler determines at compile time which version of the overloaded function to call by matching the number and/or order of types in the argument list and the parameters used in the method call. (The names of the parameters are of no consequence in this regard.) </P>
<P>You cannot declare two methods with the <U>same name</U> and the <U>same formal argument list</U>. The following code fragment shows a Java class with four overloaded methods, one of which is not legal because it has the same name and the same argument list as the previous method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class MyClass{
  ...
  void myFunction(int x, int y) { ... }
  void myFunction(int x) { ... }
  void myFunction(int x, float y) { ... }
<B>//void myFunction(int a, float b) { ... } //not allowed
</B>}//end MyClass</PRE></TD>
</TR>
</TABLE>

<P>An object-oriented language is expected to support <I>encapsulation</I>, <I>inheritance</I>, and <B><I>polymorphism</B></I>. </P>
<P>Function overloading provides a feature that some authors refer to as <B>compile-time polymorphism</B>. Other authors, however, do not consider this to be polymorphism. </P>
<P>In both Java and C++, two or more overloaded versions of the same method can return <U>different types</U>. The return type is of no particular consequence in method overloading. </P>
<B><I><P>Constructors:</B> </I>In both Java and C++, any method whose name is the same as the name of the class is a <I>constructor</I>. </P>
<P>Constructors do not specify a return type, and a constructor cannot contain a return statement. </P>
<P>Constructors can be overloaded. </P>
<P>Although you can put any legal code into a constructor, the <U>primary purpose</U> of a constructor is to <U>initialize</U> a new object. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the constructor is automatically called whenever you instantiate a new object using any legal method of instantiation. It is also allowable in C++ to make <U>direct calls</U> to the constructor.</TD>
</TR>
</TABLE>

<P>In Java, when instantiating an object, you <U>always make a direct call to the constructor</U> as an argument to the <B>new </B>operator as in the following code fragment. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>MyClass obj = new <B>MyClass(7, 3.14)</B>;</PRE></TD>
</TR>
</TABLE>

<P>This statement accomplishes <I>declaration</I>, <I>instantiation</I>, and <I>initialization </I>all in one statement. The code on the left of the assignment operator accomplishes declaration (notifying the compiler of the name of the object). </P>
<P>The <B>new </B>operator accomplishes instantiation by causing memory to be set aside to contain the object. </P>
<P>The call to the constructor as the right operand of the <B>new </B>operator initializes the object, presumably using the two parameters that are passed to the constructor. </P>
<P>In both Java and C++, if you don't provide a constructor, the system will provide a default constructor for you (the default constructor takes no parameters and is often referred to as the <B>NoArg</B> constructor). </P>
<P>In Java, the default constructor will <U>automatically initialize</U> the member variables to zero or the equivalent of zero. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The default constructor in C++ does not perform any initialization.</TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>You can think of the default constructor in Java as a method having the same name as the class with an <U>empty argument list</U> that you (sometimes) don't have to write.</TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Think of the default constructor in C++ as the constructor which gets called when you instantiate an object without any parameters as in: </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>MyClass obj;</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>In both languages, if you provide one or more constructors, the default constructor is <U>not provided for you automatically</U>. If you need a constructor with no arguments in that case, you <U>must provide it yourself</U>.</TD>
</TR>
</TABLE>

<B><I><P>Overriding Methods:</B> </I>In both Java and C++, an instance of a class (an object) contains all the instance variables and instance methods of the class and all its superclasses. </P>
<P>Both languages also support the notion that a class may <I>override </I>a method in a superclass having the <U>same signature</U>. The purpose of overriding a method is to change its behavior relative to objects of a subclass. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The procedures for overriding methods are <U>completely different</U> between Java and C++. They are so different, that the method of overriding methods in C++ will not be discussed further here.</TD>
</TR>
</TABLE>

<P>You must not confuse <U>overloading</U> and <U>overriding</U> methods. As a matter of terminology, note that: </P>

<UL>
<U><LI>Overloading </U>methods in Java requires that they have the same <I>name </I>but a <B><U>different</B></U> argument list. </LI></UL>
<DIR>
<DIR>

<U><P>Overriding </U>methods in Java requires that they have the same<B><U> </B></U>signature including the argument list and all the other elements that go to make up the signature.</P></DIR>
</DIR>

<P>In Java, if a class defines a method with the same signature as a method in a superclass, the new method <U>will override</U> the superclass method insofar as objects of that subclass type are concerned. Whenever that method is invoked on an object of the subclass, the overridden version will be invoked. This will be discussed in more detail later. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="otherelementsofamethoddeclaration"></A>Other Elements of a Method Declaration</H4>
</FONT><P>The full declaration of a method is shown below with the optional items shown in Italics and the required items shown in boldface. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><I>accessSpecifier static abstract final native synchronized 
</I>    <B>returnType methodName(</B> <I>paramList </I><B>)</B> <I>throws exceptionList</PRE></I></TD>
</TR>
</TABLE>

<P>Some of these modifiers will be discussed briefly here, and in more detail later. Others will not be discussed until later. </P>

<UL>
<I><LI>accessSpecifier </I>determines how and if other objects can access the method. </LI>
<I><LI>static </I>methods can be accessed without the requirement to instantiate an object of the type. </LI>
<I><LI>abstract </I>indicates that the method is not defined in the class, but rather is intended to be defined in a subclass (overridden). </LI>
<I><LI>final </I>prevents a method from being overridden. </LI>
<I><LI>native </I>has to do with using native methods which will be discussed is a subsequent lesson. </LI>
<I><LI>synchronized </I>has to do with multithreading which will be discussed in a subsequent lesson. </LI>
<I><LI>paramList </I>is the optional list of parameters that may be passed to the method. </LI>
<I><LI>throws </I>exceptionList has to do with exception handling.</LI></UL>

<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="passinginformationtoamethod"></A>Passing Information to a Method</H4>
</FONT><P>In Java, all methods must be declared and defined <U>within the class</U>, and you must provide the <I>types </I>of the arguments as well as the <I>names </I>of the arguments. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, you can declare a method in a class and define it either inside the class (under certain restricted conditions) or define it outside the class. When you <U>declare</U> a method in C++, you are required to specify the types of arguments, but you are not required to provide names for the arguments (but you can if you want to). When you <U>define</U> the method, you must provide names for the arguments.</TD>
</TR>
</TABLE>

<P>In both languages, the arguments behave as <U>local variables</U> in the body of the method having the specified names. Those variables are <U>initialized</U> by the values passed as parameters into the method. The scope of these variables is the full extent of the method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, any argument can be passed by <I>value </I>(copy), <I>pointer</I>, or <I>reference</I>. (For those who remember their Pascal, passing by value in C++ is the same as passing by value in Pascal, and passing by reference in C++ is essentially the same as passing a VAR parameter in Pascal.) </P>
<P>Java doesn't support pointers so you <U>cannot pass by pointer</U> in Java.</TD>
</TR>
</TABLE>

<P>Many books will state that In Java, all arguments of <U>primitive</U> types are passed by <U>value</U> and all <U>objects</U> are passed by <U>reference</U>. </P>
<P>It is probably more correct to say that in Java we pass primitive variables by value and we pass references to objects, also by value. </P>
<P>What this really means is that Java also passes reference variables by value. Normally the fact that the method receives a copy of the reference variable doesn't matter. It can use that copy to access the object referred to by the reference variable. This makes it possible for the code in the body of the method to modify the object referred to by the copy of the reference variable. </P>
<P>However, it does matter if you want the code in the method to modify the original value of the reference variable (make the original reference variable refer to a different object). That is not possible because the method doesn't have access to the original. It only has access to the copy. </P>
<P>When you pass a reference variable that refers to an object, you are passing a form of <U>address</U> that specifies where the object is stored in memory. However, what you pass may not be the direct address where the object is stored. Rather, it may be the address of another reference to the object. This differs depending on the JVM. One approach is more efficient for some types of operations while the other approach is more efficient for other types of operations. </P>
<P>In Java, C++, and Pascal, modifying a local variable in a method that was created by passing by value will <U>not modify the original variable</U> that was passed to the method. </P>
<P>On the other hand, modifying an object in a method using a local reference variable that was initialized by passing a copy of a reference variable <U>will modify the original object</U>. In Java, this amounts to modifying the object referred to by the reference variable that was passed to the method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>Modifying variables passed by pointer in C++ is more complicated, but pointers can also be used to modify the original variable passed to the method.</TD>
</TR>
</TABLE>

<P>The following Java application illustrates passing primitive variables by value and passing references to objects. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File pass1.java Copyright 1997, R.G.Baldwin
Illustrates passing primitive variables by value and 
passing references to objects.

The output from running this program is:

<B>In main
Value of primitiveVariable is 200
Value contained in object is 100
In function passVariables
Value of primitiveVariable is 200
Value contained in incoming object is 100
Modifying values of arguments
Still in function passVariables
Value of primitiveVariable is 201
Value contained in object is 101
Back in main
Value of primitiveVariable is still 200
Value contained in obj is now 101
</B>********************************************************/

//class used to instantiate an object
class NewClass{ 
  int instanceVariable = 100;
}//end NewClass

class pass1 { //define the controlling class

  //function used to illustrate argument passing
  void passVariables(int primVar, NewClass refVar){
    System.out.println("In function passVariables");
    System.out.println("Value of primitiveVariable is " 
                                            + primVar);
    System.out.println("Value contained in incoming " +
                 "object is " + refVar.instanceVariable);

    System.out.println("Modifying values of arguments");
    refVar.instanceVariable = 101;
    primVar = 201;      

    System.out.println("Still in function passVariables");
    System.out.println("Value of primitiveVariable is " 
                                              + primVar);
    System.out.println("Value contained in object is " 
                              + refVar.instanceVariable);
        
  }//end function passVariables

  public static void main(String[] args){ //main method
    //instantiate object for dispatching methods
    pass1 anObject = new pass1();
        
    NewClass obj = new NewClass();//instantiate object
    int primitiveVariable = 200;  //primitive variable

    System.out.println("In main");
    System.out.println("Value of primitiveVariable is " 
                                    + primitiveVariable);
    System.out.println("Value contained in object is " 
                                 + obj.instanceVariable);

    //Invoke method and pass parameters
    anObject.passVariables(primitiveVariable,obj);

    System.out.println("Back in main");
    System.out.println("Value of primitiveVariable is " +
                           "still " + primitiveVariable);
    System.out.println("Value contained in obj is now " 
                                 + obj.instanceVariable);
  }//end main
}//End pass1 class.</PRE></TD>
</TR>
</TABLE>

<P>In Java, if you want a method to modify a primitive variable that is passed to the function, you must encapsulate that primitive variable in an object wrapper and pass a reference to the object. However, you can't use the standard wrapper classes such as <B>Integer</B> for this purpose. </P>
<P>The standard wrapper classes provide immutable (can't be modified) object wrappers around the primitive data types. However, it isn't difficult to define your own wrapper classes to serve this purpose. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, you can pass a <I>pointer (which points to a function)</I> into another function and use that pointer in the second function to call the pointed-to function.</TD>
</TR>
</TABLE>

<P>The capability described in the C++ sidebar above is <U>not directly supported by Java</U>. However, in some cases, you might be able to accomplish nearly the same thing by encapsulating the first function as an instance method of an object and then passing the object into another method where the first method can be executed via the object. </P>
<P>This continues to be the topic of numerous discussions (and debates) on the various Java newsgroups. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="thethiskeyword"></A>The <I>this</I> Keyword</H4>
</FONT><P>Normally, methods in both Java and C++ have <U>direct access to the member variables of the class</U>. </P>
<P>In both languages, an argument name for a method or the name of a local variable in a method <U>can be the same</U> as the name of a member variable in the class. In this case, the local variable of the method is said to <I>hide </I>the member variable. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, whenever an instance method is invoked, a hidden pointer named <B>this </B>is passed to the method. The <B>this </B>pointer always points to the object which was used to call the method.</TD>
</TR>
</TABLE>

<P>In Java, whenever an instance method is invoked, a hidden reference named <B>this </B>is passed to the method. The <B>this </B>reference always refers to the object which was used to call the method. </P>
<P>In both languages, <B>this </B>can be used to access the instance variables hidden by the local variables of the same name. </P>
<P>One prominent author refers to this as a way to <I>"disambiguate"</I> the member variable name. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>The use of the <B>this</B> pointer is illustrated in the following C++ program. The output from the program is shown in the comments at the beginning of the program. </P>
<P>The following C++ program uses the <B>this</B> pointer to "disambiguate" the member variable name. </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>/*File hide1.cpp Copyright 1997, R.G.Baldwin
Illustrates use of this pointer to access a hidden
member variable.

The output from this program is:

Local myVar contains 10
Instance variable myVar contains 5
 
******************************************************/

#include&lt;iostream.h

class hide1 {
  int myVar;  //member variable named myVar
public:
  hide1(){myVar = 5;}//constructor
  //function with argument named myVar
  void myFunction(int myVar){
    cout &lt;&lt; "Local myVar contains " &lt;&lt; myVar &lt;&lt; endl;
    cout &lt;&lt; "Instance variable myVar contains "
                                 &lt;&lt; <B>this-myVar</B> &lt;&lt; endl;
  }//end myFunction
  static void classMain(){
    hide1 obj; //declare an object of this type
    obj.myFunction(10);
  }//end classMain
};//End hide1 class definition.
//=====================================================//

void main()
{
  //call the class method named classMain
  hide1::classMain();
}//end main</PRE></TD>
</TR>
</TABLE>

<P>The following Java application illustrates the use of the <B>this </B>reference to <I>disambiguate </I>a hidden instance variable twice: once in the constructor and once in the method named myFunction. The syntax used in the constructor is very commonly used in Java. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File hide1.java Copyright 1997, R.G.Baldwin
Illustrates use of this pointer to access a hidden 
instance variable.

The output from this program is:

Local myVar contains 10
Instance variable myVar contains 5
**********************************************************/

class <B>hide1 </B>{
  int myVar;  //instance variable named myVar

  //Constructor with argument named myVar
  public <B>hide1(int</B> myVar){//constructor
    //Note use of the this reference here.
    <B>this.myVar</B> = myVar;
  }//end constructor
  //-----------------------------------------------------//
  
  //Function with argument named myVar
  void <B>myFunction(int</B> myVar){ 
    System.out.println("Local myVar contains " + myVar);
    
    //Note the use of the this reference here
    System.out.println("Instance variable myVar contains " 
                                             + <B>this.myVar</B>);
  }//end myFunction
  //-----------------------------------------------------//

  public static void <B>main</B>(String[] args){ //main method
    //instantiate object of this type passing in 5
    hide1 obj = new hide1(5);
    //use it to call the method passing in 10
    obj.myFunction(10); 
  }//end main method
}//End hide1 class definition.</PRE></TD>
</TR>
</TABLE>

<P>The concept of the <B>this</B> reference is so important that we need to emphasize its characteristics. </P>
<P>In both Java and C++, when an object is used to invoke an instance method, an address or a reference to the object is passed to the method. That address or reference is contained in an entity named <B>this</B>. </P>
<P>In Java, <B>this</B> is used as a reference to the object. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, <B>this</B> is used as a pointer to the object.</TD>
</TR>
</TABLE>

<P>In Java, the reference contained in <B>this </B>is a reference to the object that was used to invoke the method. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, the <B>this</B> pointer contains the actual address of the object in memory.</TD>
</TR>
</TABLE>

<P>In both Java and C++, the code in the body of the method can use <B>this </B>to access instance members of that specific object for a variety of purposes. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="thesuperkeyword"></A>The <I>super </I>Keyword</H4>
</FONT><P>If your method <I>overrides </I>a method in its superclass, you can use the keyword <B>super </B>to <U>bypass</U> the overridden version in the class and invoke the version in the superclass. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P><B><I>super</B></I> is a concept of Java that <U>does not exist</U> in C++, at least not with a similar implementation.</TD>
</TR>
</TABLE>

<P>Likewise, if your method hides a member variable in the superclass, you can use the keyword <B>super </B>to access the member variable in the superclass. </P>
<P>You can also use <B>super</B> in a constructor of your class to invoke the constructor in the superclass. </P>
<P>The following program uses <B>super</B> to disambiguate a local variable in a method and an instance variable in the superclass having the same name. </P>
<P>The program also uses <B>super</B> to call the superclass constructor from the subclass constructor, which is another important use of <B>super</B>. </P>
<P>When <B>super(parameters)</B> is used to invoke the superclass constructor, it must be the first executable statement in the constructor. </P>
<P>Whenever you invoke the constructor of a class to instantiate an object, if your constructor doesn't have a call to <B>super()</B> as the first executable statement in the constructor, the call is made anyway. </P>
<P>In other words, in order to construct an object of a class, it is necessary to first construct that part of the object attributable to the superclass. That normally happens automatically, making use of the superclass constructor that doesn't take any parameters. </P>
<P>If you want to use a version of the superclass constructor that takes parameters, you can make your own call to <B>super(parameters)</B> as the first executable statement in your constructor as is the case in this program. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File super1.java Copyright 1997, R.G.Baldwin
Illustrates use of super reference to access constructor in
superclass.  Also illustrates use of super to disambiguate
local variable from instance variable in superclass.

The output from this program is:

<B>In base class constructor. Setting baseData to 100
In subclass constructor. Setting subClassData to 200
In main
Instance var in base class contains 100
Instance var in subclass contains 200
In function myFunc
Value of local baseData var is 300
Value of instance var named basedata is 100
</B>**********************************************************/
class <B>base</B>{
  int <B>baseData</B>;

  public base(int <B>baseData){//base</B> class constructor
    System.out.print("In base class constructor. ");
    System.out.println("Setting baseData to " + <B>baseData</B>);
    <B>this.baseData</B> = <B>baseData</B>;
  }//end base constructor
}//end base class definition
//=======================================================//

class super1 extends base{
  int subClassData;

  public <B>super1</B>(){ //subclass constructor
    <B>super(100); //call superclass constructor with 100
</B>    System.out.print("In subclass constructor. ");
    System.out.println("Setting subClassData to 200");
    subClassData = 200;
  }//end subclass constructor
  //-----------------------------------------------------//

  //Function to illustrate use of super to disambiguate 
  //  local variable and instance variable with same name
  void <B>myFunc</B>(){ 
    //create var to hide base instance var
    int baseData = 300;
    System.out.println("In function myFunc");
    System.out.println("Value of local baseData var is "
                                               + baseData);
    System.out.println("Value of instance var named " +
                          "basedata is " + <B>super.baseData</B>);
  }//end function myFunc
  //-----------------------------------------------------//

  public static void <B>main</B>(String[] args){ //main method
    //instantiate an object of this type 
    super1 obj = new super1();
    System.out.println("In main");
    System.out.println("Instance var in base class " +
                               "contains " + obj.baseData);
    System.out.println("Instance var in subclass contains "
                                       + obj.subClassData);

    //Call method to illustrate use of super to 
    // disambiguate local variable and instance variable 
    // with same name
    obj.myFunc();
  }//end main method
}//End super1 class definition.</PRE></TD>
</TR>
</TABLE>

<P>As mentioned earlier, if your method <I>overrides </I>a method in its superclass, you can use the keyword <B>super </B>to <U>bypass</U> the overridden version and invoke the version in the superclass. </P>
<P>This is illustrated by the following program. This program contains an overridden version of a superclass method named <B>myMethod()</B> that uses the value of an incoming parameter to decide whether to invoke the superclass version or to execute its own code. </P>
<P>Obviously it would be <U>possible to do both</U> as well. In other words, there is no reason that an overridden method could not invoke the superclass version using the <B>super</B> keyword, and then execute additional code to provide additional behavior. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File super2.java Copyright 1997, R.G.Baldwin
Illustrates bypassing a local overridden method in favor
of the method in the superclass.

The output from this program is:

<B>In main
Incoming parameter is false
Overridden method invoked
Incoming parameter is true
Base-class method invoked
</B>
**********************************************************/
class <B>base</B>{
<B>  void myMethod(boolean superFlag){//method</B> to override
    System.out.println("Incoming parameter is " 
                                            + superFlag);  
    System.out.println("Base-class method invoked");
  }//end myMethod
}//end base class definition
//=======================================================//

class <B>super2 extends base</B>{
<B>  void myMethod(boolean superFlag){//override</B> myMethod()
    //Make decision to invoke this version or the version
    // in the superclass.
    if(superFlag)super.myMethod(superFlag);//super version
    else{ //this version
      System.out.println("Incoming parameter is " 
                                              + superFlag);
      System.out.println("Overridden method invoked");
    }//end else
  }//end overridden myMethod()
  //-----------------------------------------------------//

  public static void <B>main</B>(String[] args){ //main method
    //instantiate an object of this type 
    super2 obj = new super2();
    System.out.println("In main");
    //Invoke overridden version of myMethod()
   <B> obj.myMethod(false)</B>;
    //Invoke superclass version of myMethod()
   <B> obj.myMethod(true)</B>;
  }//end main method
}//End super2 class definition.</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<FONT COLOR="#ff0000"><H4 ALIGN="CENTER"><A NAME="localvariables"></A>Local Variables</H4>
</FONT><P>As in most modern programming languages, Java allows you to declare variables and objects in the body of a method (or within a block of statements within the body of a method). Variables declared in this manner are commonly known as <I>automatic local variables</I>. </P>
<P>The <U>visibility</U> of such a variable is limited to the block of statements in which it is declared. </P>
<P>The <U>life</U> of such a variable is limited to the period during which control remains within the block of statements in which it is declared. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>C++ allows you to declare variables in a method as <I>static </I>variables. In this case, the variable continues to exist for the entire life of the overall program, and furthermore, values stored in a <I>static </I>variable persist from one method call to the next call to the same method. This concept is not supported by Java.</TD>
</TR>
</TABLE>

<P>Both Java and C++ allow you to use the <B>new</B> operator to instantiate objects in dynamic memory within the body of a method. </P>
<P>In Java, the actual life of the object (period during which it occupies memory) extends until it is <I>garbage collected</I> but the <U>useful life</U> of the object extends until it becomes eligible for garbage collection. (Once it becomes eligible for garbage collection, it can no longer be accessed, and therefore cannot serve any useful purpose.) </P>
<P>The object becomes <I>eligible </I>for garbage collection as soon as its reference is no longer contained in a reference variable. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<P>In C++, that object continues to occupy memory until the <B>delete </B>operator is used to return the memory occupied by the object to the operating system.</TD>
</TR>
</TABLE>





<P><!-prev=Java038f.htm-><!-next=Java038h.htm><!-first=Java038.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review"></A>Review</H2>
</FONT><P>Q - Object-oriented programming requires <I>encapsulation</I>, <I>inheritance</I>, and <I>polymorphism. The</I> <B>class </B>is the central concept of Java primarily intended to support which of the three? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The class is the central concept of Java that supports <B>encapsulation</B>.</FONT> </P>
<P>Q - The class provides the <U>plan</U> from which objects are built. This plan defines the <U>data</U> that is to be stored in an object, and the <U>methods</U> for manipulating that data: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - According to Baldwin's Java tutorial, the definition of a class consists of two parts. What are they. Provide a pseudocode fragment to illustrate your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The definition of a class deals with two parts: <I>declaration </I>and <I>body </I>using the general syntax shown below.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><FONT COLOR="#0000ff">classDeclaration{
  classBody
}</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - The <I>declaration</I> of a class notifies the compiler of the <I>name</I> of the class, and can provide other information as well. What are three other types of information that the declaration can provide to the compiler? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <I>declaration </I>notifies the compiler of the <I>name </I>of the class, and also can provide other information such as</P>

<UL>
<LI>the class from which it is derived (<I>superclass</I>),</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>access </I>privileges, and</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>whether or not it <I>implements </I>one or more <I>interfaces</I>.</LI></UL>

</FONT><P>Q - According to Baldwin's Java tutorial, what is contained in the <I>classBody </I>of a class definition? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The classBody contains the <I>declarations </I>for, and possibly the <I>initialization </I>of, all data members (both class variables and instance variables) as well as the full definition of all <I>methods</I>.</FONT> </P>
<P>Q - There are at least two different places where variables can be declared. What are those places? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Variables may be declared either</P>

<UL>
<LI>inside the body of the class, or</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>inside the body of a method in the class.</LI></UL>

</FONT><P>Q - Variables which are declared inside the body of a method are member variables of the class: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Variables that are declared inside the body of a method are <U>not</U> member variables of the class. Rather, they are <U>local variables</U> in the method.</FONT> </P>
<P>Q - In addition to the use of open and close braces, what is the <I>minimum</I> information that a class declaration must provide? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <I>minimum </I>information in a class declaration must provide is:</P>

<UL>
<LI>the <I>class </I>keyword, and</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>the <I>name </I>of the class.</LI></UL>

</FONT><P>Q - By default, every class in Java is derived, either directly or indirectly, from the class named ___________. Provide the name of the class. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - By default, every class in Java is derived, either directly or indirectly, from the class named <B>Object</B>.</FONT> </P>
<P>Q - The immediate parent class of a new class is known as its <I>superclass</I>: True or False? If false explain why and provide a code fragment to illustrate your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. The immediate parent class of a new class is known as its <I>superclass</I>.</FONT> </P>
<P>Q - If you do not specify the <I>superclass </I>for a new class, it will derive directly from _______. Provide the name of the class and the package in which it is defined. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - If you do not specify the <I>superclass </I>for a new class, it will derive directly from <B>Object</B>. (The Object class is defined in the package named java.lang.)</FONT> </P>
<P>Q - What is the keyword that is used in the class declaration to specify the <I>superclass</I> of the new class. Provide a code fragment illustrating your answer and the proper usage syntax of the keyword. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The keyword <B>extends</B> is used in the class declaration to specify the superclass of the new class using the syntax shown below.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><FONT COLOR="#0000ff">class MyNewClassName <B>extends </B>SuperClassName{
  //body of class
}</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Is it <U>allowable</U> to extend <B>Object </B>as shown below. If not, why not. If it is allowable, is it necessary? </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE>class MyNewClassName <B>extends Object</B>{
  //body of class
}</PRE></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - Although it is <U>allowable</U> to extend <B>Object </B>as shown, this <U>isn't necessary</U> because <B>Object </B>is the default parent class when no other parent class is specified.</FONT> </P>
<P>Q - Provide the definition of an interface from Baldwin's Java tutorial, and identify the specific lesson that contains that definition. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Lesson Java038.htm. According to Campione and Walrath,</FONT> </P>
<FONT COLOR="#0000ff"><TT><P>"An <B>interface </B>declares a set of methods and constants <U>without</U> specifying the implementation for any of the methods."</FONT></TT> </P>
<P>Q - Because Java doesn't support multiple-inheritance, a class may implement only one interface: True or False? If false, explain why and show a code fragment that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. A class may <I>implement </I><U>one or more</U> interfaces using the keyword <B>implements </B>and a comma-delimited list of interface names as shown below.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><FONT COLOR="#0000ff">class MyClassName <I>extends </I><B>MySuperClass 
</B><I>                implements </I><B>MyInterface</B>, <B>UrInterface </B>{
  //body of class
}</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Whenever a class claims to implement an interface, can you be assured that it provides a definition for all the methods declared within that interface. Yes or No? If yes, how can you be assured? If no, why not? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Whenever a class claims to implement an interface, you can be assured that it provides a definition for all the methods declared within that interface. Otherwise, it <U>cannot be compiled</U>.</FONT> </P>
<P>Q - There is a similarity between an <I>interface </I>and an <I>abstract </I>class, but there is an essential difference. What is that difference? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An abstract class <U>may contain</U> some method definitions. However, method definitions are not allowed in an interface.</FONT> </P>
<P>Q - According to Baldwin's Java tutorial, the sole purpose of an interface is to declare the interface, but not to define how that interface is implemented: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. The purpose of the interface matches the name. Its sole purpose is to declare the interface, but not to define how that interface is implemented.</FONT> </P>
<P>Q - When implementing an interface, the method signatures of the methods in the class <U>must match</U> the signatures of the methods declared in the interface with the one exception that the return type is not required to match: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. When implementing an interface, the method signatures of the methods in the class <U>must match</U> the signatures of the methods declared in the interface in all respects.</FONT> </P>
<P>Q - Classes can be declared to be either <B>p_______</B>, <B>a_______</B>, or <B>f________</B>, or some <I>combination </I>of the three, by using the appropriate modifiers ahead of the keyword <B>class </B>in the class declaration. Provide the missing modifiers. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Classes can be declared to be either <B>public</B>, <B>abstract</B>, or <B>final</B>, or some <I>combination </I>of the three.</FONT> </P>
<P>Q - We can consider a <I>package </I>to be a <U>group of related classes</U>. In the simplest case, the classes must either be in a <I>directory </I>having the <U>same name as the package</U>, or in a <I>subdirectory </I>of that directory, or a subdirectory of that subdirectory, etc. True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - You can consider <I>PATH </I>to be a system environmental variable (that can be set at runtime or in your autoexec.bat file) which tells your system where to search for the required class files: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. <I>CLASSPATH, </I>(not PATH), is the system environmental variable (that can be set at runtime or in your autoexec.bat file) which tells your system where to search for the required class files.</FONT> </P>
<P>Q - After installing a Java development application such as Sun's JDK 1.1, it is likely that you will find a directory named <B>java </B>which has a subdirectory named <B>util </B>which contains a large number of files with an extension of <I>class</I>: True or False? If false, explain why and also explain what you are likely to find. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. After installing a Java development application such as Sun's JDK 1.1, it is <U>not</U> likely that you will find a directory named <B>java </B>which has a subdirectory named <B>util </B>which contains a large number of files with an extension of <I>class </I>as a result of the following improvements to the storage of <I>class</I> files in Java..</FONT> </P>
<FONT SIZE=2 COLOR="#0000ff"><P>The later versions of Java have the capability to search consolidated files using the <I>zip consolidation </I>technology. This results in a considerable savings of disk space. The zip consolidation technology has the ability to remember the directory structure that contained the files before they were consolidated. Therefore it is probably closer to the truth to paraphrase the above something like the following:</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<P><FONT COLOR="#0000ff">Somewhere on your disk, you will find a zip file containing a large number of class files. <U>Prior to consolidation</U>, the <I>.class</I> files for <I>java.util</I> were in a directory named <I>util </I>that was in a directory named <I>java</I>. Wherever this zip file is stored, it must be somewhere in your CLASSPATH. </FONT></TD>
</TR>
</TABLE>

<P>Q - By default, a class can be used by the objects of all other classes in the program: True or False? If false, explain why and provide a code fragment showing how to make it possible for a class to be used by the objects of all other classes in the program.. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. By default, a class can be used <U>only</U> by the objects of other classes in the same package. You can make the class available to objects of classes <U>outside </U>the current package by declaring it to be <B>public </B>using the following syntax.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><B><FONT COLOR="#0000ff">public </B>class MyClass extends MySuperClass 
                     implements MyIntfc, UrIntfc {
  //body of class
}</PRE></FONT></TD>
</TR>
</TABLE>

<P>C - An <I>abstract </I>class is a class that is <U>designed to be inherited from</U> <I>(subclassed)</I>. It is <U>not </U>intended to be a class from which objects are instantiated: True or False? If false, explain why and provide a code a fragment to illustrate your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. An <I>abstract </I>class is a class that is <U>designed to be inherited from</U> <I>(subclassed)</I>.</FONT> </P>
<P>Q - An <I>abstract </I>class must contain <I>abstract methods</I>: True or False? If false, explain why and also provide a description of an <I>abstract method</I>. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. An abstract class <U>may</U> contain abstract methods, but this is <U>not a requirement</U>. An <I>abstract method</I> is a method for which only the method signature is provided.</FONT> </P>
<P>Q - A <B>final </B>class cannot be subclassed: True or False? If false, explain why and provide a code fragment to illustrate our answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. A <B>final </B>class <U>cannot be subclassed</U> (inherited from).</FONT> </P>
<P>Q - You can declare a class using various combinations of <B>public</B>, <B>abstract</B>, and <B>final</B>. One allowable combination to declare a class that is <B>abstract </B>and <B>public</B>: True or False. If false, explain what will happen if you attempt to do this. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. It is allowable to declare a class to be <B>abstract </B>and <B>public</B>.</FONT> </P>
<P>Q - You can declare a class using various combinations of <B>public</B>, <B>abstract</B>, and <B>final</B>. One allowable combination to declare a class that is <B>abstract </B>and <B>final</B>: True or False. If false, explain what will happen if you attempt to do this. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. While it is technically possible to declare a class with several combinations of <B>public</B>, <B>abstract</B>, and <B>final</B>, it doesn't make any sense to cause a class to be <U>both abstract and final</U>, and an attempt to do so will result in a <U>compiler error</U>.</FONT> </P>
<P>Q - Taking all factors into account, show the complete syntax for a class declaration as provided in Baldwin's Java tutorial. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Taking all factors into account, the syntax for a class declaration is as follows:</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><I><FONT COLOR="#0000ff">Modifiers</I> <B>class ClassName</B> <I>extends SuperClassName 
                          implements InterfaceNames</I> {
  ...
}</PRE></FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>where the items in italics are optional and the items in boldface are required.</P>

<UL>
<I><LI>Modifiers </I>declare whether the class is <B><I>public</B></I>, <B><I>abstract</B></I>, or <B><I>final</B></I></FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>ClassName </I>defines the name which will be used to instantiate objects of the type or to access class members</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>SuperClassName </I>is the name of the <I>immediate parent</I> from which the class is derived <I>(subclassed)</I></FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>InterfaceNames</I> is a comma-separated list of interfaces <I>implemented </I>by the class</LI></UL>

</FONT><P>Q - When declaring a class, if you don't specify otherwise, Java assumes a<I> non-final, non-public, non-abstract, subclass</I> of the class <B>Object </B>that <I>doesn't </I>implement any interfaces: True or False? If false, explain why and provide a code fragment that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - According to Baldwin's Java tutorial, the body of a class is made up of two types of members and each type comes in two different varieties. What are the two types of members, and what are the two varieties? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The body of a class is made up of two types of members:</P>

<UL>
<LI>variables</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>methods.</LI></UL>

<P>Each of these comes in two varieties,</P>

<UL>
<LI>class</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>instance</LI></UL>

<P>as in <I>class variables</I> and <I>instance variables</I>.</FONT> </P>
<P>Q - Some or all of the variables in a class may be declared in such a way that they behave like constants using the keyword _________. Provide the keyword. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Some or all of the variables may be declared in such a way that they behave like constants using the keyword <B>final</B>.</FONT> </P>
<P>Q - In the absence of overridden methods, there is a class that defines the basic state and behavior of all objects. What is the name of that class? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - All objects in Java inherit directly or indirectly from the <B>Object </B>class. Thus, every object contains the members of the <B>Object </B>class. Therefore, the <B>Object </B>class defines the basic state and behavior of every object in Java.</FONT> </P>
<P>Q - The <B>Object</B> class imparts several important behaviors to all objects in Java. List and describe four of those behaviors. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <B>Object </B>class imparts several important behaviors to its descendants including:</P>

<UL>
<LI>ability to <I>compare </I>oneself to another object</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>ability to <I>convert </I>to a string</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>ability to <I>wait </I>on a condition variable</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>ability to <I>notify </I>other objects that a condition variable has changed, etc.</LI></UL>

</FONT><P>Q - Where does the declaration of a member variable appear within the class body? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - A <U>member variable</U> declaration appears <U>within</U> the class body, but <U>outside</U> the definition of any method.</FONT> </P>
<P>Q - A member variable declaration can appear anywhere within the class body including within the definition of a method: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. A <U>member variable</U> declaration appears <U>within</U> the class body, but <U>outside</U> the definition of any method. If declared <U>within</U> the definition of a method, it becomes a <U>local</U> variable to that method and is <U>not</U> a member variable of the class.</FONT> </P>
<P>Q - What is determined by the <I>type</I> of a member variable? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <I>type </I>of a member variable determines the values that can be assigned to it as well as the operations that can be performed on it.</FONT> </P>
<P>Q - The names of all member variables must be <U>unique within the class</U>: True or False? If false, explain why and provide a code fragment that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. The names of all member variables must be <U>unique within the class.</U></FONT> </P>
<P>Q - In Java, a member <I>variable </I>and a <I>method </I>can have the <U>same name</U>: True or False. If false, explain why and provide a code fragment that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. In Java, a member <I>variable </I>and a <I>method </I>can have the <U>same name</U>.</FONT> </P>
<P>Q - Java allows you to <U>initialize</U> member variables of primitive types with you declare them: True or False. If false, explain why and provide a code fragment that illustrates your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. Java allows you to <U>initialize</U> member variables of primitive types with you declare them.</FONT> </P>
<P>Q - Show the complete syntax of a member variable declaration as provided in Baldwin's Java tutorial. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The complete syntax of a member variable declaration in Java is as follows where the italicized items are optional and the boldface items are required.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><I><FONT COLOR="#0000ff">accessSpecifier static final transient volatile</I> <B>type variableName</B> 
<I>     = initialValueForPrimitiveTypes or new type(optional parameters)</I><B>;</PRE></B></FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A brief interpretation of the modifiers is described below.</P>

<UL>
<I><LI>accessSpecifier </I>determines which other classes have access to the variable.</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>static </I>determines whether the variable is a <I>class variable</I> or an <I>instance variable</I>.</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>final </I>indicates that the variable is a constant and <U>cannot be modified</U>.</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>transient </I>variables will not be discussed further.</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>volatile </I>variables will not be discussed further.</LI></UL>

</FONT><P>Q - The <B>final</B> keyword is used in Java to cause a variable to <U>behave like a constant</U>. A <B>final</B> variable can be initialized at any time after it is declared: True or False. If false, explain why and provide a code fragment to illustrate your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Because it is a constant, a <B>final</B> variable must be given a value <U>when it is declared</U>. A typical declaration of a final variable follows:</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><FONT COLOR="#0000ff">class Circle{
  <B>final </B>float PI = 3.14159;
  ...
}</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - What is the significance of applying the <B>final</B> keyword to a method? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <B>final </B>keyword can be applied to methods, meaning that they cannot be overridden.</FONT> </P>
<P>Q - What, according to Baldwin's Java tutorial, are the three required elements of the minimum declaration of a method? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The minimum declaration consists of</P>

<UL>
<LI>return type</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>name</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>formal argument list.</LI></UL>

</FONT><P>Q - In Java, the full definition of the method, including the body, may be placed either inside or outside the class definition. Placing it inside causes it to be an <B>inline </B>method: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java, the full definition of the method, including the body, <U>must </U>be placed inside the class definition, and this does <U>not </U>cause it to be an <B>inline </B>method. Java does not make provisions for the programmer to distinguish between <B>inline </B>and ordinary methods.</FONT> </P>
<P>Q - In Java, parameters are optional, and the formal argument list (method signature) consists simply of a set of <U>empty</U> <U>parentheses</U> if there are no parameters: True or False? If false, explain why and provide a code fragment to illustrate your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Baldwin's Java tutorial provides a four-part list showing the information contained in a method declaration. What are the items on that list. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The items on the list of information contained in a method declaration are:</P>

<UL>
<I><LI>Name </I>of the method</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>Type </I>of return value</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>Number</I>, <I>types</I>, and <I>order </I>of arguments</FONT> </LI>
<I><FONT SIZE=2 COLOR="#0000ff"><LI>Access </I>control</LI></UL>

</FONT><P>Q - What is the minimum required information in a Java method declaration? Provide a code fragment that illustrates a minimal method declaration within a class declaration where the method returns a value of type <B>int</B> and requires no arguments.. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The <U>minimum</U> required information for a Java method declaration is:</P>

<UL>
<LI>return type</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>name</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>number and type of arguments.</LI></UL>

<P>The following code fragment shows a minimal method declared within a class.</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE">
<PRE><FONT COLOR="#0000ff">class MyClass{
  //...
  int myMethod(){
    //...
  }//end myMethod
}//end class</PRE></FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>This code declares a method named myMethod that returns a value of type int and requires no arguments.</FONT> </P>
<P>Q - How do you specify the return type of a method for a method that does not return a value? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - If there is no return value, the type of the return value is specified as <B>void</B>.</FONT> </P>
<P>Q - In Java, all primitive types in Java are returned by _______. Provide the missing word and explain what this means. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - All primitive types in Java are returned by <B>value </B>which means that a copy of the variable is returned.</FONT> </P>
<P>Q - All object types in Java are returned by __________. Provide the missing word. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - All object types in Java are returned by <B>reference</B>.</FONT> </P>
<P>Q - In Java, the type of the returned value <U>must match</U> the return type specified in the method declaration, <I>except </I>for a special case where this is not required. Describe that special case and explain why it is possible. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - In Java, the type of the returned value <U>must match</U> the return type specified in the method declaration, <U>except</U> that the actual return type may be a <B>subclass </B>of the specified return type. This is possible because all classes in Java inherit from the common root <B>Object</B>.</FONT> </P>
<P>Q - Because of the strong type checking in Java, it is not acceptable to store a reference to an object in a reference variable that is a <I>superclass </I>of that object: True or False. If false, explain your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Generally it <U>is acceptable</U> to store a reference to an object in a reference variable which is a <I>superclass </I>of that object. This gets involved in the topics of <I>upcasting </I>and <I>downcasting</I>.</FONT> </P>
<P>Q - Describe the difference between <I>method overloading</I> and <I>method overriding</I> in Java. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - <I>Method <B>overloading </B></I>allows two or more methods to share the same name, provided that the formal argument lists of the two are different in a way which is discernible to the compiler.</FONT> </P>
<I><FONT SIZE=2 COLOR="#0000ff"><P>Method <B>overriding </B></I>allows the behavior of a method defined in a class to be modified relative to objects of a <I>subclass</I> of that class. <I>Method overriding</I> requires the name, return type, and argument list (as well as any modifiers such as <B>public</B>) of the new method to match the method signature of the overridden method.</FONT> </P>
<P>Q - The compiler determines at compile time which version of the overloaded method to call based on what? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The compiler determines at compile time which version of the overloaded method to call based on the number and/or order of types in the method signature and the parameters used in the method call. (The names of the parameters are of no consequence in this regard.)</FONT> </P>
<P>Q - What do we call the method whose name is the same of the name of the class of which it is a member? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Any method whose name is the same as the name of the class of which it is a member is a <I>constructor</I>.</FONT> </P>
<P>Q - What is the proper return type for a constructor? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Constructors do not specify a return type, and a constructor cannot contain a return statement.</FONT> </P>
<P>Q - Constructors can be overloaded: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True. Constructors can be overloaded.</FONT> </P>
<P>Q - In Java, the constructor is automatically called whenever you instantiate a new object using code such as the following: True or False? If false, explain why and provide a code fragment that illustrates your answer. </P>

<UL>
<TT><LI>MyClass myObject; //instantiate a new object</LI></UL>

</TT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java, you must make an <U>explicit call</U> to the constructor to instantiate a new object. Sample code is shown below.</P>

<UL>
</FONT><FONT COLOR="#0000ff"><TT><LI>MyClass myObject = new MyClass();</LI></UL>

</FONT></TT><P>Q - Any time that you define a new class in Java, you must provide a constructor: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java, if you don't provide a constructor, the system will provide a default constructor for you.</FONT> </P>
<P>Q - Method arguments behave as global variables: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Method arguments behave as <U>local variables</U> in the body of the method having the specified names. Those variables are <U>initialized</U> by the values passed as parameters into the method.</FONT> </P>
<P>Q - In Java, all arguments of <U>primitive</U> types must be passed by reference while all <U>objects</U> must be passed by value: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Just the reverse is true. In Java, all arguments of <U>primitive</U> types must be passed by <U>value</U> while all <U>objects</U> must be passed by <U>reference</U>.</FONT> </P>
<P>Q - In Java, modifying a local <I>primitive </I>variable in a method which was created by passing the variable to the method will modify the original variable which was passed to the method: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java, all <I>primitive </I>variables are passed by value. Modifying a local variable in a method that was created by passing by value will <U>not modify the original variable</U> that was passed to the method.</FONT> </P>
<P>Q - In Java, when an object is used to invoke an instance method, an address is passed to the method contained in an entity named <B>this</B>. The address contained in <B>this </B>is the address of the object that invoked the method. The code in the body of the method can use <B>this </B>to access instance members of that specific object for a variety of purposes: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - If your method <I>overloads </I>a method in its superclass, you can use the keyword <B>super </B>to <U>bypass</U> the <I>overloaded </I>version in the class and invoke the version in the superclass: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Should read <I>override</I> instead of <I>overload</I>. If your method <I>overrides </I>a method in its superclass, you can use the keyword <B>super </B>to <U>bypass</U> the overridden version in the class and invoke the version in the superclass.</FONT> </P>
<P>Q - Write a Java application that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg14.java from lesson 38
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates returning by value and by 
reference in Java.

Also cause your program to display a terminating message
with your name.

The output from the program should be:

Primitive value returned is 5
Value of instance variable in returned object is 10
Terminating, Dick Baldwin
**********************************************************/
class NewClass{//obj of this class will be returned by ref
  int instanceVariable = 10;
}//end NewClass

class SampProg14 { //define the controlling class

  int returnValue() {//function which returns by value
    return 5; //return a primitive type by value
  }//end returnValue()

  NewClass returnReference() {//function returns by ref
    return new NewClass(); //return an object by reference
  }//end returnReference()

  public static void main(String[] args){ // main method
    SampProg14 obj = new SampProg14();//instantiate object
    System.out.println(
      "Primitive value returned is " + obj.returnValue() );
    System.out.println(
      "Value of instance variable in returned object is " +
       obj.returnReference().instanceVariable );
    System.out.println("Terminating, Dick Baldwin");    
  }//end main
}//End SampProg14 class.  Note no semicolon required</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg15.java from lesson 38
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates passing primitive variables 
by value and passing objects by reference.

Provide a termination message with your name.

The output from running this program should be:

In main
Value of primitiveVariable is 200
Value contained in ordinary obj is 100
In function passVariables
Value of primitiveVariable is 200
Value contained in ordinary obj is 100
Modifying values of arguments
Still in function passVariables
Value of primitiveVariable is 201
Value contained in ordinary obj is 101
Back in main
Value of primitiveVariable is still 200
Value contained in obj is now 101
Terminating, Dick Baldwin
**********************************************************/
//class used to instantiate a reference obj
class NewClass{ 
  int instanceVariable = 100;
}//end NewClass

class SampProg15 { //define the controlling class

  //function used to illustrate argument passing
  void passVariables(int primVar, NewClass refVar){
    System.out.println("In function passVariables");
    System.out.println(
      "Value of primitiveVariable is " 
      + primVar);
    System.out.println(
      "Value contained in ordinary obj is " 
      + refVar.instanceVariable);

    System.out.println("Modifying values of arguments");
    refVar.instanceVariable = 101;
    primVar = 201;  

    System.out.println(
      "Still in function passVariables");  
    System.out.println(
      "Value of primitiveVariable is " 
      + primVar);
    System.out.println(
      "Value contained in ordinary obj is " 
      + refVar.instanceVariable);
  
  }//end function passVariables

  public static void main(String[] args){ //main method
    //instantiate object for dispatching methods
    SampProg15 anObject = new SampProg15();
  
    NewClass obj = new NewClass();//ordinary object
    int primitiveVariable = 200;  //primitive variable

    System.out.println("In main");
    System.out.println(
      "Value of primitiveVariable is " 
      + primitiveVariable);
    System.out.println(
      "Value contained in ordinary obj is " 
      + obj.instanceVariable);

    //call method
    anObject.passVariables(primitiveVariable,obj);

    System.out.println("Back in main");
    System.out.println(
      "Value of primitiveVariable is still " 
      + primitiveVariable);
    System.out.println("Value contained in obj is now " 
      + obj.instanceVariable);
    System.out.println("Terminating, Dick Baldwin");

  }//end main
}//End SampProg15 class.  Note no semicolon required</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg16.java from lesson 38
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates use of the "this" keyword to 
access an instance variable that is hidden by a local
variable.

Provide a termination message with your name.

The output from this program should be:

Local variable myVar contains 10
Instance variable myVar contains 5
Terminating, Dick Baldwin
===========================================================
*/

class SampProg16 {
  int myVar;  //instance variable named myVar

  public SampProg16(){myVar = 5;}//constructor

  void myFunction(int myVar){ //function w/arg named myVar
    System.out.println("Local variable myVar contains " 
      + myVar);
    System.out.println("Instance variable myVar contains " 
      + this.myVar);
  }//end myFunction

  public static void main(String[] args){ //main method
    SampProg16 obj = new SampProg16(); 
    obj.myFunction(10); //use it to call the method
    System.out.println("Terminating, Dick Baldwin");
  }//end main method
}//End SampProg16 class definition.</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that meets the following specifications. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg17.java from lesson 38
Copyright 1997, R.G.Baldwin
Without viewing the following solution, write a Java
application that illustrates use of super keyword to 
access the constructor in a superClass.  Also illustrate
the use of the super keyword to disambiguate a local 
variable from an instance variable in the superClass.

The output from this program should be:

In superClass constructor. Setting superClassData to 100
In subClass constructor. Setting subClassData to 200
In main
Instance var in superClass contains 100
Instance var in subClass contains 200
In function myFunc
Value of local superClassData var is 300
Value of instance var named superClassData is 100
Terminating, Dick Baldwin
**********************************************************/
class superClass{
  int superClassData;

  public superClass(){//superClass constructor
    System.out.print("In superClass constructor. ");
    System.out.println("Setting superClassData to 100");
    superClassData = 100;
  }//end superClass constructor

}//end superClass definition

class SampProg17 extends superClass{
  int subClassData;

  public SampProg17(){ //subClass constructor
    super(); //call superClass constructor
    System.out.print("In subClass constructor. ");
    System.out.println("Setting subClassData to 200");
    subClassData = 200;
  }//end subClass constructor

  //Function to illustrate use of super to disambiguate 
  // local variable and instance variable with same name
  void myFunc(){ 
    //create var to hide superClass instance var
    int superClassData = 300; 
    System.out.println("In function myFunc");
    System.out.println(
      "Value of local superClassData var is "
      + superClassData);
    System.out.println(
      "Value of instance var named superClassData is "
      + super.superClassData);
  }//end function myFunc

  public static void main(String[] args){ //main method
    //instantiate an object to dispatch method calls
    SampProg17 obj = new SampProg17();
    System.out.println("In main");
    System.out.println(
      "Instance var in superClass contains " 
      + obj.superClassData);
    System.out.println(
      "Instance var in subClass contains " 
      + obj.subClassData);

    //Call method to illustrate use of super 
    // to disambiguate local variable and instance 
    // variable with same name
    obj.myFunc();
    System.out.println("Terminating, Dick Baldwin");
  }//end main method
}//End SampProg17 class definition.</PRE></TD>
</TR>
</TABLE>





<P><!-prev=Java038g.htm-><!-first=Java038.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
