<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center">Redeye Correction in Digital Photographs</h2>
<i>Learn how to write a Java program that can be used to correct for redeye problems 
in digital photographs.</i>
<p><b>Published:</b>&nbsp; March 19, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 363</p>
<ul>
	<li><a href="#Preface">Preface</a>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#What_you_have_learned_from_earlier_lessons">What you have 
		learned from earlier lessons</a></li>
		<li><a href="#What_you_will_learn_in_this_lesson">What you will learn in 
		this lesson</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul>
		</li>
		<li><a href="#Supplementary_material">Supplemental material</a></li>
	</ul>
	</li>
	<li><a href="#General Background Information">General background information</a><ul>
		<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
		<li><a href="#Software_installation_and_testing">Software installation 
		and testing</a></li>
		<li><a href="#Redeye_correction">Redeye correction</a></li>
	</ul>
	</li>
	<li><a href="#The_program_named_RedEye05">The program named RedEye05</a><ul>
	<li><a href="#Introductory_remarks">Introductory remarks</a></li>
	<li><a href="#The_constructor">The constructor</a></li>
	<li><a href="#Create_listener_objects">Create listener objects</a></li>
	<li><a href="#The_zoom_method">The zoom method</a></li>
	<li><a href="#The_drawLasso_method">The drawLasso method</a></li>
	<li><a href="#The_isRedeye_method">The isRedeye method</a></li>
	<li><a href="#The_fixRedeye_method">The fixRedeye method</a></li>
	<li><a href="#The_smoothEdges_method">The smoothEdges method</a></li>
	<li><a href="#The_averagePixels_method">The averagePixels method</a></li>
	<li><a href="#Reduce_and_recombine_the_zoomed_image">Reduce and recombine 
	the zoomed image</a></li>
	<li><a href="#Commit_the_modified_image">Commit the modified image</a></li>
	<li><a href="#Writing_output_files">Writing output files</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the program</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listing</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Edit the color of your digital photos.</li>
	<li>Create a lasso to isolate pixels by dragging the mouse in an image.</li>
	<li>Blur, soften, or sharpen your digital photos.</li>
	<li>Remove <i>redeye</i> from your digital photos.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="What_you_have_learned_from_earlier_lessons">What you have learned 
from earlier lessons</a></h3>
<p>If you have studied the <a href="#Resources">earlier lessons</a> in this 
series, among other things, you have learned:</p>
<ul>
	<li>How to download, install, and test a Java multimedia library from 
	Georgia Institute of Technology.</li>
	<li>How to edit the pixels in an image on a pixel-by-pixel basis using a 
	program written entirely in Java.</li>
	<li>About the HSB color model and how to use that model to adjust the hue, 
	saturation, and brightness of your digital photos. </li>
	<li>Many aspects of image processing, including color distance, projecting 
	3D coordinates onto a 2D display plane, and edge detection.</li>
	<li>How to write an animated flocking program.</li>
	<li>How to sharpen or soften your digital photos.</li>
	<li>How to control temperature and tint in a digital photograph.</li>
</ul>
<h3><a name="What_you_will_learn_in_this_lesson">What you will learn in this 
lesson</a></h3>
<p>You will learn how to write the code to correct for redeye problems in 
digital photographs.&nbsp; For example, the top image in Figure 1 shows a portion of a digital 
photograph with a serious redeye problem.&nbsp; The bottom image in Figure 1 
shows the results obtained by using this program to correct the 
redeye problem.</p>



<p>
 <b><a name="Figure_1">Figure 1</a>. Sample results from the redeye correction 
	program</b>.
<table bgcolor="#FEFFF0"  border="0" cols="1">
<tr><td><img border="0" src="java363a1.jpg" width="291" height="167"></td></tr>
<tr><td><img border="0" src="java363a2.jpg" width="291" height="167"></td></tr>
</table></p>

<p><font color="#FF0000"><b>Other things that you will learn</b></font></p>
<p>In addition to learning how to correct for redeye problems in digital 
photographs, you will also learn several important Java programming techniques 
that were employed to make this an effective program that is easy to use.</p>
<p><font color="#FF0000"><b>Enlarging an image and identifying problem pixels</b></font></p>
<p>For example, one of the most important techniques used in this program allows the user 
to 
enlarge the image of the eye and to place a 
circular lasso around the offending redeye pixels to help identify the pixels that 
will be considered for a color change.&nbsp; Figure 2 shows a screen shot 
captured from this step in the process.</p>
<p>
 <b><a name="Figure_2">Figure 2</a>. A lasso surrounding offending pixels in an 
	enlarged version of the eye.</b><table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java363a3.jpg" width="473" height="495"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Correcting the problem pixels</b></font></p>
<p>Figure 3 shows the results of applying redeye decision and correction algorithms to the 
pixels inside the lasso shown in Figure 2.</p>
<p>
 <b><a name="Figure_3">Figure 3</a>. Results of applying redeye decision and correction 
	algorithms to pixels inside the lasso. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java363a4.jpg" width="473" height="495"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Preservation of highlights</b></font></p>
<p>As you can see in Figure 3, the redeye correction algorithm preserves some of 
the highlights in the original image and softens the edges of the 
color-corrected area to avoid a &quot;blank stare&quot; look in the finished product.</p>
<p><font color="#FF0000"><b>Merging two images</b></font></p>
<p>After the redeye correction is performed on the enlarged version of the 
eye, the modified image is reduced back to its normal size and merged back into the 
main display producing results similar to those shown in the bottom image of 
Figure 1.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Sample results from the redeye 
	correction program. </li>
	<li><a href="#Figure_2">Figure 2</a>. A lasso surrounding offending pixels 
	in an enlarged version of the eye.</li>
	<li><a href="#Figure_3">Figure 3</a>. Results of applying redeye decision 
	and correction algorithms to pixels inside the lasso. </li>
	<li><a href="#Figure_4">Figure 4</a>. Decision and correction algorithms 
	applied to a color wheel.</li>
	<li><a href="#Figure_5">Figure 5</a>. HSB values that define the redeye 
	color wedge. </li>
	<li><a href="#Figure_6">Figure 6</a>. Application of decision and correction 
	algorithms to skin near the eye</li>
	<li><a href="#Figure_7">Figure 7</a>. A success story.</li>
	<li><a href="#Figure_8">Figure 8</a>. A difficult case to correct. </li>
	<li><a href="#Figure_9">Figure 9</a>. Enlarged images from the difficult 
	case. </li>
	<li><a href="#Figure_10">Figure 10</a>. Incorrect use of the override 
	option. </li>
	<li><a href="#Figure_11">Figure 11</a>. Program GUI at startup.<b> </b></li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Beginning of the constructor. </li>
	<li><a href="#Listing_2">Listing 2</a>. Register a listener object on the 
	text field.&nbsp; </li>
	<li><a href="#Listing_3">Listing 3</a>. Create and display the picture. </li>
	<li><a href="#Listing_4">Listing 4</a>. Resize and move the GUI. </li>
	<li><a href="#Listing_5">Listing 5</a>. Register a listener object on the 
	picture frame.&nbsp; </li>
	<li><a href="#Listing_6">Listing 6</a>. Register an ActionListener object on 
	the Zoom button. </li>
	<li><a href="#Listing_7">Listing 7</a>. Beginning of the zoom method. </li>
	<li><a href="#Listing_8">Listing 8</a>. Identify the rectangular sub image 
	that will be scaled. </li>
	<li><a href="#Listing_9">Listing 9</a>. Get, scale, and display the 
	rectangular sub image. </li>
	<li><a href="#Listing_10">Listing 10</a>. Perform miscellaneous tasks on the 
	zoomed picture. </li>
	<li><a href="#Listing_11">Listing 11</a>. Register a MouseListener object on 
	the zoomed picture. </li>
	<li><a href="#Listing_12">Listing 12</a>. Register a MouseMotionListener 
	object on the zoomed picture. </li>
	<li><a href="#Listing_13">Listing 13</a>. Beginning of the drawLasso method. </li>
	<li><a href="#Listing_14">Listing 14</a>. Create and draw the lasso. </li>
	<li><a href="#Listing_15">Listing 15</a>. Register an anonymous listener 
	object on the Fix Redeye button.</li>
	<li><a href="#Listing_16">Listing 16</a>. Beginning of the isRedeye method. </li>
	<li><a href="#Listing_17">Listing 17</a>. Get the pixel color. </li>
	<li><a href="#Listing_18">Listing 18</a>. Test the color against the redeye 
	criterion. </li>
	<li><a href="#Listing_19">Listing 19</a>. Beginning of the fixRedeye method. </li>
	<li><a href="#Listing_20">Listing 20</a>. Change color of offending redeye 
	pixels to gray. </li>
	<li><a href="#Listing_21">Listing 21</a>. Smooth the edges and display the 
	modified image. </li>
	<li><a href="#Listing_22">Listing 22</a>. The method named smoothEdges.</li>
	<li><a href="#Listing_23">Listing 23</a>. The averagePixels method. </li>
	<li><a href="#Listing_24">Listing 24</a>. Beginning of the event handler on 
	the Recombine Images button. </li>
	<li><a href="#Listing_25">Listing 25</a>. Merge the two images. </li>
	<li><a href="#Listing_26">Listing 26</a>. Dispose of the zoomed picture. </li>
	<li><a href="#Listing_27">Listing 27</a>. Register an ActionListener object 
	on the Commit button. </li>
	<li><a href="#Listing_28">Listing 28</a>. Source code listing for the 
	program named RedEye05. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplemental material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample 
programs that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<p>The program that I will explain in this lesson requires access to that class 
library.</p>
<h3><a name="Redeye_correction">Redeye correction</a></h3>
<p>Although there are a large number of products available for performing redeye 
correction on digital photographs, this technology is far from being completely 
settled.</p>
<p><font color="#FF0000"><b>A major problem related to the size of the camera</b></font></p>
<p>The redeye problem is a major problem for the manufacturers of small, 
relatively inexpensive digital cameras where the flash is positioned physically 
close to the optics.&nbsp; The problem is not one of resolution, but rather is 
one of size.&nbsp; When the flash is very close to the optics, <i>(as is almost 
always the case with a small camera)</i>, the reflection of the flash from the 
retina at the back of the eyeball comes straight back into the optics.</p>
<p><font color="#FF0000"><b>A red filter</b></font></p>
<p>Apparently the retina has the characteristic of filtering out colors other than 
red in the reflected light.&nbsp; This is what causes the redeye problem on the millions of digital 
photographs that are taken daily on small digital cameras.</p>
<p><font color="#FF0000"><b>Jockeying for the best patent</b></font></p>
<p>A quick search of the web indicates that individuals and companies are 
jockeying for position trying to nail down a patent on the best way to solve the 
problem.&nbsp; This includes not only software solutions, but also hardware 
solutions associated with the camera itself.</p>
<p><font color="#FF0000"><b>An ideal solution</b></font></p>
<p>A hardware solution at the camera would be the best solution.&nbsp; Lacking 
that, in the ideal 
case for a software solution, you would simply present your digital photographs containing images of people 
to a software program and it would do a perfect job of first identifying and then 
correcting all of the redeye problems in the photographs.&nbsp; Few, if any 
current products provide that ideal capability.</p>
<p><font color="#FF0000"><b>Identification of redeye problems</b></font></p>
<p>There are software products that attempt to identify redeye problems in a digital 
photo.&nbsp; These products must first discriminate against false positives such as red buttons on a dress, 
or red berries on a holly wreath.&nbsp; <i>(You wouldn't be happy with a product 
that changes the color of the berries on the holly wreaths in your Christmas 
pictures from red to some other color.)</i> Then they must correct the problems 
that are identified.&nbsp; </p>
<p><font color="#FF0000"><b>Pattern recognition software</b></font></p>
<p>Such programs make use of facial recognition or other 
pattern-recognition algorithms to separate the actual redeye problems from the 
false positives.&nbsp; Sometimes they are successful and sometimes they are not 
successful.&nbsp; Most of these programs fall back on the human user to 
identify the redeye problems when the automated algorithm is unable to do 
so.&nbsp; <i>(The human brain has a fantastic pattern recognition capability.)</i></p>
<p><font color="#FF0000"><b>Program will depend on the user</b></font></p>
<p>The program that I will explain in this lesson makes no attempt to 
automatically identify the redeye problems in a digital photo.&nbsp; Instead, 
this program depends entirely on the user to identify the areas containing 
offending redeye pixels.</p>
<p><font color="#FF0000"><b>Decision and correction algorithms</b></font></p>
<p>Once the user has identified the general area containing offending pixels using a 
circular lasso as shown in Figure 2, this program applies decision and 
correction algorithms that 
attempt to exclude any non-offending pixels and to correct the 
color of the remaining pixels inside the lasso.&nbsp; I will usually refer to 
these algorithms hereafter simply as the <i>decision algorithm</i> and the <i>
correction algorithm</i>.</p>
<p><font color="#FF0000"><b>A difficult task</b></font></p>
<p>Even after the user has identified a group of potentially offending pixels, deciding which pixels are 
actually redeye pixels with a high degree of certainty is a difficult task.</p>
<p>If you carefully examine a large number 
of digital photos with redeye problems, you will find that the colors of offending 
pixels often overlap the colors of normal body parts in the 
vicinity of the eye.</p>
<p><font color="#FF0000"><b>Use of HSB for discrimination</b></font></p>
<p>The identification of a pixel as an offending redeye pixel 
in this program is made on the basis of the hue, saturation, and brightness value of the pixel.&nbsp; 
Not only does this approach do a pretty good job, it also gives you another 
opportunity to work with the HSB color model.&nbsp; <i>(See <a href="#Resources">
Resources</a> for earlier lessons involving the HSB color model.)</i></p>
<p><font color="#FF0000"><b>Threshold constants</b></font></p>
<p>Constants in the program establish the allowable range for each of the HSB 
parameters that are interpreted to represent a redeye pixel color.&nbsp; I have experimented with different values for different 
images and have come up with a set of values that seem to work well for most 
digital photos.&nbsp; The set of HSB parameter values that I have settled on can be described by the image of the color wheel in Figure 4.</p>
<p>
 <b><a name="Figure_4">Figure 4</a>. Decision and correction algorithms applied 
	to a color wheel.</b><table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java363b1.jpg" width="209" height="232"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Interpreting the color wheel results</b></font></p>
<p>What you are seeing in Figure 4 is the top surface of an HSB color cone.&nbsp;
<i>(See the earlier lesson titled The HSB Color Model in <a href="#Resources">
Resources</a> for an explanation of 
the HSB color cone)</i>.&nbsp; The gray area in Figure 4 shows the top surface of a 
3D wedge in the cone that extends downward to a brightness value of 0.2.&nbsp; Any pixel with a color inside the wedge is considered to be an 
offending redeye pixel.</p>
<p>The parameters that define the shape and position of the wedge 
are shown in Figure 5.</p>
<p>
 <b><a name="Figure_5">Figure 5</a>. HSB values that define the redeye color 
	wedge. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8" >
  <tbody>
    <tr>
      <td>
      <pre>
     0.95 &lt;= Hue &lt;= 1.05
     Saturation > 0.43
     Brightness > 0.2 </pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Some care is required</b></font></p>
<p>Although these parameters work reasonably well for many digital photos, it is 
still important to avoid including pixels in the lasso that fall outside of the 
wedge if possible.&nbsp; For example, the top and bottom images in Figure 6 
show what happens when the lasso is allowed to include the iris and some of the 
skin in the area of the eye.</p>



<p>
 <b>
 <a name="Figure_6">Figure 6</a>. Application of decision and correction 
	algorithms to skin near the eye.</b>
<table bgcolor="#FEFFF0"  border="0" cols="1">
<tr><td><img border="0" src="java363b2.jpg" width="473" height="301"></td></tr>
<tr><td><img border="0" src="java363b3.jpg" width="473" height="301"></td></tr>
</table></p>

<p>The top image in Figure 6 shows the lasso and the bottom image shows the 
results of applying the redeye decision and correction algorithms to all of the pixels 
contained inside of the lasso.</p>



<p><font color="#FF0000"><b>Color of skin and iris modified</b></font> </p>
<p>As you can see from the bottom image in Figure 6, some of the pixels in the 
iris and some of the pixels in the skin were inside the wedge of colors that 
were deemed to be offending redeye pixels.&nbsp; Therefore, these pixels were 
also colored gray in addition to the actual redeye pixels.</p>
<p><font color="#FF0000"><b>A success story</b></font></p>
<p>Figure 7 shows one of many success stories that I could show you where I was 
able to do a very good job of correcting the redeye problem on a digital 
photograph.</p>




<p>
 <b>
 <a name="Figure_7">Figure 7</a>. A success story.</b>
<table bgcolor="#FEFFF0"  border="0" cols="1">
<tr><td><img border="0" src="java363b5.jpg" width="145" height="65"></td></tr>
<tr><td><img border="0" src="java363b6.jpg" width="145" height="65"></td></tr>
</table></p>

<p><font color="#FF0000"><b>Some cases are more difficult</b></font></p>
<p>There are some cases, however, that this program can't handle by applying the 
existing decision algorithm for identifying offending redeye pixels.&nbsp; One such case 
is shown in the top image in Figure 8.&nbsp; Selecting either eye in the top 
image of Figure 8 and 
applying the decision and corrections algorithms results in essentially no change in the appearance of the 
eye.</p>



<p>
 <b><a name="Figure_8">Figure 8</a>. A difficult case to correct. </b>
<table bgcolor="#FEFFF0"  border="0" cols="1">
<tr><td><img border="0" src="java363c1.jpg" width="178" height="75"></td></tr>
<tr><td><img border="0" src="java363c4.jpg" width="178" height="75"></td></tr>
</table></p>

<p><font color="#FF0000"><b>Enlarged view of the difficult case</b></font></p>
<p>The reason for the problem is shown in the top image of Figure 9 where the 
right eye from Figure 8 has been selected and enlarged by a factor of sixteen.</p>




<p>
 <b><a name="Figure_9">Figure 9</a>. Enlarged images from the difficult case.
	</b>
<table bgcolor="#FEFFF0"  border="1" cols="1">
<tr><td><img border="0" src="java363c2.jpg" width="473" height="491"></td></tr>
<tr><td><img border="0" src="java363c3.jpg" width="473" height="491"></td></tr>
</table></p>

<p><font color="#FF0000"><b>Offending redeye pixel colors are outside the wedge</b></font></p>
<p>The color of the offending pixels in the top image of Figure 9 is a&nbsp; deep purple instead of being closer to red.&nbsp; In fact, the hue value 
for the offending pixels in this case is in the neighborhood of 0.9, which causes them to be 
well outside of the wedge shown in the HSB color wheel in Figure 4.&nbsp; 
Therefore, when the decision algorithm described by the wedge in Figure 4 is 
applied to the pixels inside the lasso, they are not deemed to be offending 
redeye pixels and their colors are not changed.</p>
<p><b><font color="#FF0000">Would sliders be a good idea?</font></b></p>
<p>At one point, I considered adding three sliders to the GUI and allowing the user to 
change the threshold values for hue, saturation, and brightness.&nbsp; This 
would make it possible for the user to change the shape and position of the wedge 
shown in Figure 4 on a case by case basis.</p>
<p><font color="#FF0000"><b>Too complex</b></font></p>
<p>On further reflection, however, I decided that would be far too complex.&nbsp; 
The average 
person trying to correct redeye problems in digital photos wouldn't even know what 
the HSB color model is, much less how to adjust the parameters to control the 
sensitivity of the decision algorithm.</p>
<p><font color="#FF0000"><b>An Override button</b></font></p>
<p>The solution that I came up with was to place an <b>Override</b> radio button 
on the GUI.&nbsp; When the user encounters a case that is not amenable to the 
existing decision algorithm, the user can select the <b>Override</b> button to 
eliminate the application of the decision algorithm.&nbsp; When that is done, 
the program will simply assume that every pixel within the lasso is an offending 
pixel and change the color of the pixels accordingly.</p>
<p><font color="#FF0000"><b>Experimental results</b></font></p>
<p>The bottom image in Figure 9 shows the results of selecting the override 
button before clicking the <b>Fix Redeye</b> button after having placed the 
lasso as shown in the top image in Figure 9.</p>
<p>Clicking the <b>Recombine Images</b> button to merge this modified image back 
into the image shown in the top of Figure 8 produced the results shown in the 
bottom of Figure 8.&nbsp; <i>(Note that only the right eye has had the redeye 
problem corrected in the bottom image in Figure 8.&nbsp; The left eye remains 
the same as before.)</i></p>
<p><font color="#FF0000"><b>A word of caution</b></font></p>
<p>Just as a word of caution, the two images in Figure 10 show what happens if 
the <i>override</i> option is used without being careful about the placement of 
the lasso around the offending redeye pixels.</p>




<p>
 <b>
 <a name="Figure_10">Figure 10</a>. Incorrect use of the override option.
</b>
<table bgcolor="#FEFFF0"  border="0" cols="1">
<tr><td><img border="0" src="java363c5.jpg" width="385" height="301"></td></tr>
<tr><td><img border="0" src="java363c6.jpg" width="385" height="301"></td></tr>
</table></p>

<p>As described earlier, when the override button is selected, the program assumes that 
every pixel inside the lasso 
is an offending redeye pixel and changes its color to gray.</p>
<p><font color="#FF0000"><b>Behavior of the decision algorithm</b></font></p>
<p>On the bright side, a comparison of the bottom image in Figure 10 with the 
bottom image in Figure 6 shows an example of the behavior of the decision 
algorithm.&nbsp; A large portion of the girl's face was included in the lasso in 
both cases.&nbsp; The bottom image in Figure 6 shows the results of applying the 
decision and correction algorithms to each of the pixels within the 
lasso.&nbsp; In the case of Figure 6, a small percentage of the pixels outside 
the pupil of the eye were found to fall within the offending pixel color wedge.&nbsp; 
Those were the only pixels for which the color was changed to gray.</p>
<p>On the other hand, the decision algorithm was overridden in the bottom image 
in Figure 10, and all of the pixels contained within the lasso were changed to 
gray.</p>
<p><font color="#FF0000"><b>A grayscale image</b></font></p>
<p>Another interesting aspect of the bottom image in Figure 10 is the appearance 
of the gray circle.&nbsp; As you can see, when the pixels within the lasso are 
converted to gray, they are converted to a grayscale image instead of being 
converted to a solid gray color.&nbsp; This maintains the structural quality of 
the pupil, including highlights, and avoids the &quot;blank stare&quot; look that would be 
produced by replacing the color of the offending pixels with a solid gray color.</p>
<center>
<h2> <a name="The_program_named_RedEye05">The program named RedEye05</a></h2>
</center>
<h3><a name="Introductory_remarks">Introductory remarks</a></h3>
<p>The purpose of this program is to demonstrate a programming technique using 
Java for 
correcting redeye problems in digital photographs.</p>
<p><font color="#FF0000"><b>The graphical user interface <i>(GUI)</i></b></font></p>
<p>The program begins by displaying a GUI in the upper left corner of the screen 
as shown in Figure 11.</p>
<p>
 <b><a name="Figure_11">Figure 11</a>. Program GUI at startup. </b>
<table border="0" cols="1" bgcolor="#FEFFF0" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java363d1.jpg" width="466" height="139"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Browsing for the input file</b><br />
  If you prefer to browse for the input file, you can easily upgrade the program 
	to provide that capability using the <b>setMediaPath</b> and <b>pickAFile</b> 
	methods of Ericson's <b>FileChooser</b> class.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>The input image file</b></font></p>
<p>At that point, the GUI contains a text field for entry of the name of the 
image file to be processed and some other user-input components, which 
are all disabled.&nbsp; <i>(A default file name appears in the text field mainly 
for ease of test and debugging.)</i></p>
<p>If the file is in the current directory, only the file name and 
extension must be entered.&nbsp; Otherwise, the full path, name, and extension for the 
file must be entered.&nbsp; Files of types jpg, bmp, and png are supported.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Multimedia library required</b><br />
  Ericsson's multimedia library is required to compile and execute this program.
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Loading the image from the file</b></font></p>
<p>When the user 
enters the name of the image file into the text field, the file is loaded into a 
<b>Picture</b> object.&nbsp; The <b>Picture</b> object is displayed in the upper left corner of the 
screen as shown by the top image in Figure 1.&nbsp; <i>(I will often refer to 
this as the main display in the discussions that follow.)</i>&nbsp; When the 
main display appears, the GUI is moved to a location immediately below the main 
display.</p>
<p>At 
this point, the text field becomes disabled and several buttons and radio buttons are enabled.&nbsp;
<i>(Different components are enabled and disabled during the running of the program 
as appropriate.)</i></p>
<p><font color="#FF0000"><b>The overall procedure</b></font></p>
<p>The overall procedure for correcting redeye problems in a digital photograph is as follows.&nbsp; 
Once the image is loaded and displayed as shown by the top image in Figure 1, the user selects a pixel in the eye 
containing the redeye problem by clicking the mouse in the red area.&nbsp; <i>
(There is no requirement for extreme accuracy in selecting the pixel unless the 
eye is very small.)</i></p>
<p>Then the user 
selects one of five radio buttons specifying a zoom factor of 1, 2, 4, 8, or 16 
and clicks the button labeled <b>Zoom</b> in Figure 11.&nbsp; <i>(A zoom factor of 16 is selected by default at 
program startup.)</i></p>
<p><font color="#FF0000"><b>An enlarged view of the eye</b></font></p>
<p>Clicking the <b>Zoom</b> button causes the area surrounding the selected pixel to be 
enlarged by the specified zoom factor and displayed in another window to the right 
of the main display object as shown by Figure 2.&nbsp; <i>(I will often refer to 
this as the zoomed image or the zoomed picture.&nbsp; The green circular lasso 
shown in Figure 2 doesn't exist at this point.)</i></p>
<p>Clicking the <b>Zoom</b> button also causes the <b>Zoom</b> button and 
several other buttons in the GUI to be disabled.</p>
<p><font color="#FF0000"><b>Surround offending pixels with a lasso</b></font></p>
<p>To correct the redeye problem in 
the selected eye, the user surrounds the offending pixels in the zoomed image with 
a circular lasso by dragging the mouse in the zoomed image as shown in Figure 2.&nbsp; Then the user clicks 
the 
button labeled <b>Fix Redeye</b> shown in Figure 11.</p>
<p><b><font color="#FF0000">Apply the decision and correction algorithms</font></b></p>
<p>Clicking the <b>Fix Redeye</b> button causes decision and correction 
algorithms to be executed that attempt to correct the redeye problem in the area enclosed by 
the circular lasso.</p>
<p>The decision algorithm scans all of the pixels isolated by the lasso and attempts to exclude any pixels that are not part of the problem.&nbsp; 
The correction algorithm changes the color of the remaining pixels to a dark gray with highlights 
preserved as shown in Figure 3.</p>
<p><font color="#FF0000"><b>Undo the previous operation</b></font></p>
<p>Clicking the mouse in the zoomed image at any time will erase an 
existing lasso and undo the effects of having clicked the <b>Fix Redeye</b> button.&nbsp; 
Thus, the process of surrounding the offending pixels with the lasso and 
changing their color can be repeated as many times as necessary until the user is satisfied 
that the best fit of the circular lasso and the offending pixels has been 
achieved.</p>
<p><font color="#FF0000"><b>Merge the two images</b></font></p>
<p>Then the user clicks the button labeled <b>Recombine Images</b> in Figure 11 to cause the 
modified zoomed image to be reduced back to its original size and merged back 
into the main display as shown by the bottom image in Figure 1.</p>
<p><font color="#FF0000"><b>If the user is not happy...</b></font></p>
<p>If the user is not happy with the results at this point, the 
entire process can be repeated by selecting the same eye again and clicking the 
<b>Zoom</b> button.&nbsp; This will undo everything back to the most recent <b>Commit</b> operation 
<i>(see below)</i>.</p>
<p><font color="#FF0000"><b>Using the Override button</b></font></p>
<p>As I explained earlier, for those cases where the decision algorithm doesn't seem to be 
capable of selecting the offending pixels inside the lasso, the user can 
override the decision algorithm by selecting the <b>Override</b> button before clicking 
the <b>Fix Redeye</b> button.&nbsp; In this case, the user should be very 
careful to avoid including pixels from the eyelid, the iris, etc., in the lasso 
because the color of all of the pixels inside the lasso will be changed to gray as 
shown in Figure 10.</p>
<p><font color="#FF0000"><b>Committing the main display</b></font></p>
<p>Once the user is happy with the results for the eye currently being 
processed, the user can accept the results by clicking the <b>Commit</b> button 
shown in Figure 11.&nbsp; Then the user can perform the same procedure on any other eyes in the photograph that exhibit 
redeye problems.</p>
<p>Once committed, the pixels 
are permanently changed in a backup image that is held in memory and the changes 
cannot be undone.&nbsp; However, at no time does this program modify the original image 
file.</p>
<p><font color="#FF0000"><b>Creating a circular lasso</b></font></p>
<p>As explained earlier, the user can drag the mouse in the zoomed image to 
create a circular lasso.&nbsp; An anchor point is established when the user first 
presses the mouse button to begin the drag operation.&nbsp; The lasso can be created in 
any direction from the anchor point.&nbsp; The diameter of the lasso is equal to the 
distance from the mouse pointer to the anchor point.&nbsp; The final size and position of 
the lasso are established when the user releases the mouse button to end the 
drag operation.</p>
<p>Dragging the mouse outside the bounds of the image causes the size 
of the lasso to continue to grow.&nbsp; However, if the lasso extends outside the bounds 
of the zoomed image, clicking the <b>Fix Redeye</b> button will have no effect.</p>
<p><font color="#FF0000"><b>Erasing an existing lasso</b></font></p>
<p>Once the drag operation is completed, the lasso 
remains on the screen until the user:</p>
<ul>
	<li>Clicks the zoomed image again with the 
mouse,</li>
	<li>Clicks the <b>Fix Redeye</b> button,</li>
	<li>Clicks the <b>Recombine Images</b> button, or</li>
	<li>Does something else to cause the image to be repainted such as minimizing and then 
restoring the zoomed image.</li>
</ul>
<p><font color="#FF0000"><b>Writing backup files</b></font></p>
<p><a name="Clicking_the_Write_button_">Clicking the <b>Write</b> button </a>shown in Figure 11 <i>(when it is enabled)</i> causes a backup bmp file of the 
main display to be written into the same directory 
from which the image file was read.</p>
<p>The five most recent backup files are 
saved.&nbsp; The names of the backup files are the same as the name of the original image 
file except that the characters BAKn are inserted immediately before the 
extension.&nbsp; The character n is replaced by a digit from 0 through 4.</p>
<p><font color="#FF0000"><b>Terminating and writing a final output file</b></font></p>
<p>The large X 
buttons in the upper right corners of both image displays are disabled.&nbsp; Clicking 
them does nothing.&nbsp; The program can be terminated by clicking the <b>Quit</b> button 
shown in Figure 11 <i>(when it 
is enabled)</i> or by clicking the large X in the upper right corner of the GUI at any 
time.</p>
<p>Before terminating, the program writes an output file containing the final 
state of the main display in the same format as the input file.&nbsp; The file is 
written into the folder from which the original image file was read.&nbsp; The name of 
the output file is the same as the name of the input file except that the word 
FINAL is inserted immediately before the extension.</p>
<p><font color="#FF0000"><b>Will explain in fragments</b></font></p>As is my 
custom, I will explain this program by breaking it down into code fragments and 
explaining the fragments.&nbsp; A complete listing of the program is provided in 
Listing 28 near the end of the lesson.<h3><a name="The_constructor">The 
constructor</a></h3>
<p>The class named <b>RedEye05</b> begins by declaring a large number of 
instance variables and defining a very simple <b>main</b> method that simply 
instantiates an object of the class.&nbsp; There is nothing remarkable about 
that code, so I won't bother showing it in code fragments.&nbsp; You can view 
that code in Listing 28 near the end of the lesson.</p>
<p><font color="#FF0000">
<b>Beginning of the constructor</b></font></p>
<p>The constructor begins in Listing 1.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Beginning of the constructor. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public RedEye05(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Construct the GUI. Components are arranged in the
    // GUI from left to right, top to bottom in
    // approximately the order that they are used.
    mainPanel.setLayout(new BorderLayout());
//Code deleted for brevity.

    //Add components to the north panel.
    northPanel.add(fileNameLabel);
//Code deleted for brevity.

    //Add components to the center panel
    centerPanel.add(overrideButton);
//Code deleted for brevity.

    //Add components to the south panel.
    southPanel.add(commitButton);
//Code deleted for brevity.

    //Disable the buttons until the user enters the file
    // name.
    zoom1.setEnabled(false);
//Code deleted for brevity.

    //Set the size of the GUI and display it in the upper
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);

    //Request that the focus move to the text field where
    // the file name is to be entered.
    fileNameField.requestFocus();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Much of the code in the early part of the constructor involves the physical 
construction of the GUI shown in Figure 11.&nbsp; This code is somewhat boring 
so I deleted much of it from Listing 1 for brevity.&nbsp; You can view the 
deleted code in Listing 28.</p>
<p>The remaining code in Listing 1 is straightforward, so there should be no 
need to provide an explanation for that code beyond the embedded comments.</p>
<h3><a name="Create_listener_objects">Create listener objects</a></h3>
<p>The constructor starts to be more interesting in Listing 2 where the 
constructor starts defining anonymous listener classes and registering 
objects of those classes on the various components in the GUI and the displays.</p>
<p><font color="#FF0000">
<b>Register a listener object on the text field</b></font></p>
<p>Listing 2 shows the beginning of the code that registers a listener object of 
type <b>ActionListener</b> on 
the text field shown in Figure 11.</p>
<p>When the user enters the file name in 
the text field, the <b>actionPerformed</b> method of the listener object is called.&nbsp; 
This method sets everything up properly so that the program will function as an event-driven 
picture-manipulation program until the user clicks the large X in the 
upper-right corner of the GUI.</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Register a listener object on the text 
field.&nbsp; </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field and its label to
          // prevent the user from entering anything else
          // into it and causing it to fire another event.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object.
          fileName = fileNameField.getText();
          backupPicture = new Picture(fileName);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);

          //Write the first copy of the output backup
          // file before any processing is done.
          backupPicture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);
          
          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 2 is straightforward and should not require an 
explanation beyond the embedded comments.</p>
<p><font color="#FF0000"><b>Create and display the picture</b></font></p>
<p>The <b>actionPerformed</b> method continues in Listing 3 where it creates and 
displays the picture as shown by the top image in Figure 1.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Create and display the picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          //Create the picture that will be used for
          // processing.
          //Note that the original image file is not
          // modified by this program.
          displayPicture = new Picture(backupPicture);

          //Display the picture.
          displayPicture.show();

          //Save a reference to the image. Also save the
          // width and height of the picture.
          theImage =
                (BufferedImage)(backupPicture.getImage());
          pictureWidth = backupPicture.getWidth();
          pictureHeight = backupPicture.getHeight();

          //Get and save a reference to the JFrame object
          // that contains the image.
          displayPictureFrame =
                   displayPicture.getPictureFrame().frame;

          //Get and save the insets for the JFrame object.
          leftInset =
                     displayPictureFrame.getInsets().left;
          topInset = displayPictureFrame.getInsets().top;
          rightInset =
                    displayPictureFrame.getInsets().right;
          bottomInset =
                   displayPictureFrame.getInsets().bottom;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 3 also gets and saves some miscellaneous values that will be used 
later in the program.</p>
<p><font color="#FF0000">
<b>Resize and move the GUI</b></font></p>
<p>Strictly for cosmetic purposes, Listing 4 begins by adjusting the width of 
the GUI to match the width of the main display if possible.&nbsp; Then Listing 4 
relocates the GUI to a position immediately below the main display so that it won't 
be covered up by the display.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Resize and move the GUI. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable user input controls.
          zoom1.setEnabled(true);
          zoom2.setEnabled(true);
          zoom4.setEnabled(true);
          zoom8.setEnabled(true);
          zoom16.setEnabled(true);
          zoomButton.setEnabled(true);
          commitButton.setEnabled(true);
          writeButton.setEnabled(true);
          quitButton.setEnabled(true);

          //Disable the X-button on the display.
          displayPictureFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 4 also performs some other routine tasks that are explained by the 
embedded comments.</p>
<p><font color="#FF0000"><b>Register a listener object on the picture frame</b></font></p>
<p>In order to enlarge the image in the area of a pixel selected by the user, the 
program needs a way for the user to select a pixel.&nbsp; The normal way of 
doing this is to have the user press a mouse button in the picture and to record 
the coordinates of the mouse pointer when the picture fires a mouse event.&nbsp; 
Many of the other listener objects in this program are created by code blocks in the 
constructor.&nbsp; However, the picture hasn't been loaded when the constructor 
executes, so it isn't possible to register a mouse listener on the picture at 
that point in time.</p>
<p><font color="#FF0000"><b>Defined inside of the actionPerformed method</b></font></p>
<p>The code in Listing 5 is defined inside the <b>actionPerformed</b> method 
of the <b>ActionListener</b> object that is registered on the text field shown 
in Figure 11.&nbsp; This code defines an anonymous class that implements the <b>MouseListener</b> 
interface 
and registers an object of that class on the frame containing the picture after:</p>
<ol>
	<li>The user enters the file name in the text field.</li>
	<li>The image from the file has been loaded.</li>
	<li>The <b>Picture</b> object has been created.</li>
</ol>
<p>
<b><a name="Listing_5">Listing 5</a>. Register a listener object on the picture 
frame.&nbsp; </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          displayPictureFrame.addMouseListener(
            new MouseAdapter(){
              public void mousePressed(MouseEvent e){
                //Draw a new copy of the image
                graphics = displayPicture.getGraphics();
                graphics.drawImage(
                       backupPicture.getImage(),0,0,null);
                displayPicture.repaint();

                //Prepare some working variables.
                anchorX = e.getX();
                anchorY = e.getY();
                //Draw a small white cursor to mark the
                // location of the mouse press on the
                // image.
                drawCursor();
              }//end mousePressed
            }//end new MouseAdapter
          );//end addMouseListener
          //--------------------------------------------//

        //Now finish defining the action listener that is
        // registered on the text field.
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Behavior of the mousePressed method</b></font></p>
<p>The <b>mousePressed</b> method in Listing 5 begins by drawing the backup copy of 
the image on the main display each time the user clicks the main display with the mouse.&nbsp; 
This creates a fresh copy of the image in the main display.&nbsp; <i>(Note however that 
the image being copied may contain changes made earlier when the user clicked 
the <b>Commit</b> button.)</i></p>
<p><font color="#FF0000"><b>Prepare some working variables</b></font></p>
<p>Then Listing 5 calls the <b>getX()</b> method and the <b>getY()</b> method on 
the <b>MouseEvent</b> object to get and save the location of the mouse pointer 
when the event was fired.</p>
<p><font color="#FF0000"><b>A word of caution</b></font></p>
<p>It is important to note, however, that the 
coordinate values returned by these two methods are relative to an origin at the 
upper left corner of the frame containing the picture.&nbsp; Therefore, they 
don't represent the coordinates of the pixel selected by the user relative to 
the upper-left corner of the image.&nbsp; 
Instead, the values must later be <a name="adjusted_by_the_inset_values">adjusted by the 
<i>top</i> and <i>left</i> inset values </a>in order to represent the actual coordinates of the pixel.</p>
<p><font color="#FF0000"><b>Draw a small white cursor</b></font></p>
<p>Then Listing 5 calls the <b>drawCursor</b> method to draw<b> </b>a small 
white cursor to mark the/ location of the mouse press on the image.&nbsp; The <b>
drawCursor</b> method is completely straightforward so I won't bore you with an 
explanation.&nbsp; You can view the code for the method in Listing 28.</p>
<p><font color="#FF0000"><b>Finish defining the ActionListener class</b></font></p>
<p>That signals the end of the definition and instantiation of an anonymous <b>
MouseListener</b> object on the frame containing the picture.</p>
<p>Listing 5 continues by completing the definition and instantiation of the 
anonymous <b>MouseListener</b> object being registered on the text field in 
Figure 11.</p>
<p><font color="#FF0000">
<b>Register an ActionListener object on the Zoom button</b></font></p>
<p>That brings us back to the constructor where Listing 6 defines an 
anonymous class that implements the <b>ActionListener</b> interface and 
registers an object of that class on the <b>Zoom</b> 
button shown in Figure 11.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. Register an ActionListener object on the 
Zoom button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    zoomButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Get a fresh image in order to prevent the
          // current cursor from showing in the zoomed
          // version.
          //Note however that if the user previously
          // clicked the Commit button when a cursor was
          // showing in the picture, that cursor will have
          // been permanently written into the backup
          // picture.
          graphics = displayPicture.getGraphics();
          graphics.drawImage(
                       backupPicture.getImage(),0,0,null);
          displayPicture.repaint();

          //Call the zoom method to do all the hard work.
          zoom();
        }//end action performed
      }//end newActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The actionPerformed method</b></font></p>
<p>The <b>actionPerformed</b> method shown in Listing 6 is called each time the 
user clicks the <b>Zoom</b> button.</p>
<p>This event-handler method copies the backup picture into the main 
display and then calls the <b>zoom</b> method to produce a zoomed version of the 
area surrounding the selected pixel in the main display.&nbsp; <i>(As explained 
earlier, the zoomed version makes it easier for the user to place a lasso around 
the offending redeye pixels.)</i></p>
<h3><a name="The_zoom_method">The zoom method</a></h3>
<p>I am going to put 
the explanation of the constructor on hold for now and explain the <b>zoom</b> 
method.&nbsp; I will return to the explanation of the remainder of the 
constructor later.</p>
<p><font color="#FF0000"><b>Behavior of the zoom method</b></font></p>
<p>The <b>zoom</b> method creates a new <b>Picture</b> object that contains a 
scaled rectangular sub image of the pixels surrounding the pixel selected by the user 
before clicking the <b>Zoom</b> button.&nbsp; The amount of scaling is determined 
by the radio button that is selected when the method is called.&nbsp; Scaling 
factors of 1, 2, 4, 8, and 16 are available.</p>
<p><font color="#FF0000"><b>The size of the zoomed image</b></font></p>
<p>If the selected pixel is not close to the edge of the image, the size of the 
zoomed image will be 464x464 pixels.&nbsp; If the selected pixel is close to one 
of the edges of the image, the zoomed image will be smaller.</p>
<p>There is nothing magic about the number 464 except that the size of the 
zoomed image should be evenly divisible by 16 if possible to minimize any 
corruption of the image that might result from first enlarging and later 
reducing the size of the image.</p>
<p><font color="#FF0000"><b>A convenient size</b></font></p>
<p>I chose 464 for the size of the zoomed image because that is the largest 
value that is divisible by 16 and is smaller than the widest image that I 
can publish at <a href="http://www.developer.com/java/other/article.php/3798646">
Developer.com</a>.&nbsp; You can increase the dimensions if you like but be sure 
to make each dimension evenly divisible by 16.</p>
<p><font color="#FF0000">
<b>Beginning of the zoom method</b></font></p>
<p>The <b>zoom</b> method begins in Listing 7.&nbsp; The method begins by 
enabling and disabling various buttons appropriate to the current state of the 
program.&nbsp; This will be a recurring theme throughout the program.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Beginning of the zoom method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void zoom(){
    //Enable and disable various buttons.
    zoomButton.setEnabled(false);
    commitButton.setEnabled(false);
    writeButton.setEnabled(false);
    quitButton.setEnabled(false);
    recombineButton.setEnabled(true);

    //Establish the amount of zoom that will be applied.
    if(zoom1.isSelected()){
      zoomFactor = 1;
    }else if(zoom2.isSelected()){
      zoomFactor = 2;
    }else if(zoom4.isSelected()){
      zoomFactor = 4;
    }else if(zoom8.isSelected()){
      zoomFactor = 8;
    }else{
      zoomFactor = 16;
    }//end else</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the zoom factor</b></font></p>
<p>Then Listing 7 checks to see which radio button is selected <i>(see Figure 
11)</i> and sets the zoom factor to either 1, 2, 4, 8, or 16 depending on which 
button is selected.&nbsp; The value of <b>zoomFactor</b> will be used to control 
the factor by which the image is enlarged later.</p>
<p><font color="#FF0000">
<b>Identify the rectangular sub image that will be scaled</b></font></p>
<p>Listing 8 uses the value of <b>zoomFactor</b> along with the location of the 
selected pixel to determine the location of the rectangular section of the image 
that will be copied, scaled, and presented as the zoomed image.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. Identify the rectangular sub image that 
will be scaled. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //The numerator in the following fraction needs to be
    // divisible by 16 to maintain the best picture
    // quality when the image is later restored to its
    // original size.
    zoomPictureWidth = 464/zoomFactor;
    zoomPictureHeight = 464/zoomFactor;

    //Compute the coordinates for the upper-left corner
    // along with the width and height of the rectangular
    // sub image.
    xMin = anchorX - 232/zoomFactor - leftInset;

    if(xMin < 0){//Avoid negative coordinate values.
      xMin = 0;
    }//end if

    if((xMin + zoomPictureWidth) > (pictureWidth - 1)){
      zoomPictureWidth = pictureWidth - xMin - 1;
    }//end if

    yMin = anchorY - 232/zoomFactor - topInset;

    if(yMin < 0){
      yMin = 0;//Avoid negative coordinate values.
    }//end if

    if((yMin + zoomPictureHeight) > (pictureHeight - 1)){
      zoomPictureHeight = pictureHeight - yMin - 1;
    }//end if

</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">Four values are needed</font></p>
<p>Four values are needed to specify the rectangular section of pixels that will 
be copied and scaled.</p>
<ul>
	<li>The x-coordinate of the upper left corner.</li>
	<li>The y-coordinate of the upper left corner.</li>
	<li>The width.</li>
	<li>The height.</li>
</ul>
<p>The code in Listing 8 computes those four values, being careful to avoid 
specifying a rectangle that isn't fully contained within the image.</p>
<p>As I mentioned <a href="#adjusted_by_the_inset_values">earlier</a>, 
the code in Listing 8 converts the values from coordinates relative to the upper 
left corner of the frame to coordinates relative to the upper left corner of the 
image.</p>
<p><font color="#FF0000">
<b>Get, scale, and display the rectangular sub image</b></font></p>
<p>Listing 9 calls the <b>getSubimage</b> method of the <b>BufferedImage</b> 
class on the main image to get an 
image that is a copy of the pixels contained in the rectangular sub image 
defined above.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Get, scale, and display the rectangular 
sub image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Get the subimage that will be scaled up to create
    // the zoomed image.
    BufferedImage subImage = ((BufferedImage)(
                  displayPicture.getImage())).getSubimage(
                                       xMin,
                                       yMin,
                                       zoomPictureWidth,
                                       zoomPictureHeight);
                                       
    //Use the subimage to create two new Picture objects,
    // one for backup, and the other for a working
    // picture. Both are scaled up by zoomFactor. Display
    // the working picture.
    zoomBackupPicture = new Picture(subImage);
    zoomBackupPicture = zoomBackupPicture.<b>scale</b>(
                                   zoomFactor,zoomFactor);
    zoomDisplayPicture = new Picture(zoomBackupPicture);
    zoomDisplayPicture.show();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Create a new scaled Picture object</b></font></p>
<p>Listing 9 then uses the sub image to create a new <b>Picture</b> object and 
scales it by the value of <b>zoomFactor</b> in both dimensions.&nbsp; This 
picture is saved as a zoomed backup picture and is also used to create another picture 
object, which is displayed to the right of the main display <i>(as shown in Figure 2)</i>.</p>
<p><font color="#FF0000">
<b>Perform miscellaneous tasks on the zoomed picture</b></font></p>
<p>There are several miscellaneous tasks that need to be performed with regard 
to the zoomed picture after it is created. Those&nbsp; tasks 
are handled by the code in Listing 10.</p>
<p>
<b><a name="Listing_10">Listing 10</a>. Perform miscellaneous tasks on the 
zoomed picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Get and save a reference to the JFrame object that
    // contains the working picture.
    zoomPictureFrame =
               zoomDisplayPicture.getPictureFrame().frame;

    //Disable the X-button on the zoom display.
    zoomPictureFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Position the zoomed working picture at the top of
    // the screen immediately to the right of either
    // displayPicture or the GUI, whichever is wider.
    int zoomLocationX = 0;
    if((pictureWidth + leftInset + rightInset) >
                                         this.getWidth()){
      zoomLocationX =
                    pictureWidth + leftInset + rightInset;
    }else{
      zoomLocationX = this.getWidth();
    }//end else

    zoomPictureFrame.setLocation(zoomLocationX,0);

    //Get and save a reference to the object on which the
    // circular lasso will be drawn.
    g2d = (Graphics2D)(zoomPictureFrame.getGraphics());
    zoomImage =
            (BufferedImage)(zoomBackupPicture.getImage());</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>None of the tasks are complicated so no further explanation of Listing 10 
should be required.</p>
<p><font color="#FF0000">
<b>Register a MouseListener object on the zoomed picture</b></font></p>
<p>Now that the zoomed picture exists, the program needs to make it possible to 
draw a lasso on it by dragging the mouse in the image.&nbsp; This requires that 
a <b>MouseListener</b> object and a <b>MouseMotionListener</b> object be 
registered on the frame that contains the picture.</p>
<p>Listing 11 defines an anonymous class that implements the <b>MouseListener</b> interface and registers an anonymous object 
of that class on the frame that contains the picture.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Register a MouseListener object on the 
zoomed picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Register a mousePressed listener and a mouseDragged
    // listener on the zoomPictureFrame. This is done here
    // because it couldn't be done before the zoomed
    // display picture was created.
    //--------------------------------------------------//

    // This mousePressed event handler creates a fresh
    // zoomed image using the zoomed backup picture and
    // establishes the anchor point for the ellipse that
    // will be drawn.
    zoomPictureFrame.addMouseListener(
      new MouseAdapter(){
        public void mousePressed(MouseEvent e){
          graphics = zoomDisplayPicture.getGraphics();
          graphics.drawImage(
                  zoomBackupPicture.getImage(),0,0,null);
          zoomDisplayPicture.repaint();

          zoomAnchorX = e.getX();
          zoomAnchorY = e.getY();
          zoomDeltaX = 0;
          zoomDeltaY = 0;

          //Enable the button that will be used to call
          // the method that modifies the colors of the
          // pixels enclosed by the lasso.
          fixRedeyeButton.setEnabled(true);

        }//end mousePressed
      }//end new MouseAdapter
    );//end addMouseListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Yesterday's news</b></font></p>
<p>By now, code like that shown in Listing 11 should be yesterday's news to you 
and any explanation beyond the embedded comments should not be required.</p>
<p><font color="#FF0000">
<b>Register a MouseMotionListener object on the zoomed picture</b></font></p>
<p>Listing 12 defines an anonymous class that implements the <b>MouseMotionListener</b> interface and 
registers an object of that class on the frame that contains the zoomed picture.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. Register a MouseMotionListener object on 
the zoomed picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //This mouseDragged event handler will call a method
    // to draw a lasso when the mouse is dragged in the
    // zoomed image.
    zoomPictureFrame.addMouseMotionListener(
      new MouseMotionAdapter(){
        public void mouseDragged(MouseEvent e){
          drawLasso(e.getX(),e.getY());
        }//end mouseDragged
      }//end new MouseMotionAdapter
    );//end addMouseMotionListener
    //--------------------------------------------------//

  }//end zoom method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A series of events</b></font></p>
<p>A series of events of type <b>MouseEvent</b> will be fired as the user drags the mouse 
in the zoomed picture.&nbsp; Each time such an event is fired, the <b>
mouseDragged</b> method defined in Listing 12 will be called.&nbsp; This method 
calls a method named <b>drawLasso</b>, passing the coordinates of 
the mouse pointer as parameters to the <b>drawLasso </b>method.</p>
<p>Listing 12 also signals the end of the <b>zoom</b> method.</p>
<h3><a name="The_drawLasso_method">The drawLasso method</a></h3>
<p>The <b>drawLasso</b> method, which is called from an event handler  
defined inside the <b>zoom</b> 
method in Listing 12, is not completely new to this lesson.&nbsp; I 
explained a method similar to this one in an earlier lesson titled <i>Creating a 
lasso for editing digital photos in Java (see <a href="#Resources">Resources</a>)</i>.&nbsp; 
However, due to the critical nature of this method to the operation of this 
program, I will explain the method again in this lesson.</p>
<p><font color="#FF0000"><b>Draw a circular lasso</b></font></p>
<p>The <b>drawLasso</b> method draws a circular lasso that always touches the 
anchor point established by the <b>mousePressed</b> event handler defined in Listing 
11.&nbsp; The <b>drawLasso</b> method is called each time the <b>mouseDragged</b> event handler 
method is called as a result of the user dragging the mouse in the zoomed image.</p>
<p><font color="#FF0000">
<b>Beginning of the drawLasso method</b></font></p>
<p>The <b>drawLasso</b> method begins in Listing 13.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Beginning of the drawLasso method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  private void drawLasso(int x,int y){

    //The parameters x and y contain the coordinates of
    // the mouse pointer when the event was fired. Update
    // the diameter of the circular lasso.
    zoomDeltaX = x - zoomAnchorX;
    zoomDeltaY = y - zoomAnchorY;
    diameter = (int)Math.hypot(zoomDeltaX,zoomDeltaY);

    g2d.setColor(Color.GREEN);

    //Copy the entire image from the backup picture
    // stored in memory to erase any lassos drawn
    // earlier. This causes a single circular lasso to
    // appear to track the mouse position.
    g2d.drawImage(zoomImage,
                 zoomPictureFrame.getInsets().left,
                 zoomPictureFrame.getInsets().top,null);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the diameter of the lasso</b></font></p>
<p>The method begins by using the current location of the mouse pointer along 
with the anchor point established in Listing 11 to compute the diameter of the 
circular lasso.</p>
<p><font color="#FF0000"><b>Make the lasso pure green</b></font></p>
<p>Then Listing 13 sets the color of the lasso to pure green.&nbsp; I chose this 
color because it is least likely to appear in the vicinity of a normal human 
eye.&nbsp; A pure green lasso should stand out from the background reasonably 
well as shown in Figure 2.</p>
<p><font color="#FF0000"><b>Erase the old lasso</b></font></p>
<p>Finally, Listing 13 copies the zoomed background image into the zoomed 
picture to erase the lasso that was drawn during the previous call to this 
method.&nbsp; Without this, the lasso would look like a big disorganized pile of 
hula hoops of different sizes instead of a single circle.</p>
<p><font color="#FF0000">
<b>Create and draw the lasso</b></font></p>
<p>The code in Listing 14 uses trigonometry to compute the angle and to draw the 
circle as a circular ellipse of the class <b>Ellipse2D.Double</b>.</p>
<p><font color="#FF0000"><b>An ellipse inscribed in a rectangle</b></font></p>
<p>In 
order to construct and then draw such an ellipse, you must specify the 
coordinates of the upper left corner along with the width and height of a 
rectangle in which the ellipse will be inscribed.</p>
<p>Because the ellipse is inscribed in the rectangle and the ellipse must touch 
the anchor point at all times, the upper left corner of the rectangle <i>(in 
this case a square)</i>, does not coincide with the anchor 
point except when the circle is to the right of, to the left of, above, or below 
the anchor point.</p>
<p><font color="#FF0000"><b>The major challenge</b></font></p>
<p>Therefore, the major challenge is to determine the location of the upper left 
corner of the square for all angles other than 0, 90, 180, and 270 degrees.&nbsp; 
This is accomplished by the code in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Create and draw the lasso. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //Get the angle in radians that a line joining the
    // anchor point and the current mouse location makes
    // with a horizontal line going through the anchor
    // point. This is the angle that will be used in the
    // computations required to rotate the circular
    // ellipse around the anchor point while continually
    // touching the anchor point.
    angle =
       Math.atan2((double)zoomDeltaY,(double)zoomDeltaX);

    //Create and draw a circular ellipse that touches the
    // anchor point at all times.
    ellipse = new Ellipse2D.Double(
          //Compute and specify the coordinates of the
          // upper left corner of a box that will contain
          // the circular ellipse.
          zoomAnchorX-(
                  diameter/2-Math.cos(angle)*diameter/2),
          zoomAnchorY-(
                  diameter/2-Math.sin(angle)*diameter/2),
          //Specify the width and the height of the box.
          diameter,
          diameter);

    //Draw the ellipse.
    g2d.draw(ellipse);

  }//end drawLasso</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>If you understand trigonometry</b></font></p>
<p>If you know how to program using Java and you also have a pretty good 
understanding of trigonometry, you should be able to understand, or at least to 
figure out the code in Listing 14.&nbsp; If you don't understand trigonometry, 
it is unlikely that you can understand Listing 14.&nbsp; In that case, just 
take my word for it that the code does what it is intended to do.</p>
<p>After constructing the <b>Ellipse2D.Double</b> object, Listing 14 draws it on 
the zoomed image and the <b>drawLasso</b> method terminates.</p>
<p><font color="#FF0000"><b>Fixing the redeye problem</b></font></p>
<p>After the user surrounds the offending pixels with the lasso, the user clicks 
the <b>Fix Redeye</b> button to cause the color of the offending pixels to be 
changed to gray.</p>
<p><font color="#FF0000">
<b>Register an anonymous listener object on the Fix Redeye button</b></font></p>
<p>Listing 15 defines an anonymous class that implements the A<b>ctionListener </b> 
interface&nbsp; and registers an object of that class on the button 
labeled <b>Fix Redeye</b>.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Register an anonymous listener object on 
the Fix Redeye button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    //The event handler on this button calls a method that
    // changes the color of the offending redeye pixels
    // that are enclosed in a circular lasso.
    fixRedeyeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          fixRedeye();
        }//end action performed
      }//end newActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The actionPerformed method</b></font></p>
<p>The <b>actionPerformed</b> method that is defined in Listing 15 is called 
each time the user clicks the button.&nbsp; This method in turn calls the method 
named <b>fixRedeye</b>.</p>
<p><font color="#FF0000"><b>Not a perfect circle</b></font></p>
<p>It is unlikely that the offending redeye pixels in an image will form a 
perfect circle.&nbsp; Therefore, when the user attempts to surround the 
offending pixels with a circular lasso, it is likely that 
the lasso will enclose some pixels that are not offending redeye pixels such as 
the bright highlight in Figure 2.</p>
<p><font color="#FF0000"><b>A key feature</b></font></p>
<p>The color of those non-offending pixels should not be changed.&nbsp; Therefore, one of the key features 
of this program is the application of a decision algorithm that attempts to 
separate offending redeye pixels from non-offending pixels in order to prevent 
the color of non-offending pixels from being changed.</p>
<h3><a name="The_isRedeye_method">The isRedeye method</a></h3>
<p>The decision algorithm is written into a method named <b>isRedeye</b>.&nbsp; 
As you will see later, the method named <b>fixRedeye</b> calls the <b>isRedeye</b> 
method to qualify each pixel before changing the color of the pixel.&nbsp; 
Therefore, I will explain the <b>isRedeye</b> method before I explain the <b>
fixRedeye</b> method.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The 3D wedge</b><br />
<font size="3" face="arial">
	Figure 4 shows the shape of the wedge at the top surface of the HSB color 
	cone.&nbsp; The wedge extends downward through the cone to a brightness 
	value of 0.2.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>A 3D wedge in the HSB color cone</b></font></p>
<p>The <b>isRedeye</b> method, which begins in Listing 16, is called to test a 
pixel to determine if it meets the redeye criterion.&nbsp; The method tests to 
determine if the color of the pixel is inside a 3D wedge in the HSB color cone as shown by the gray area in Figure 4.</p>
<p>Only those pixels whose color is inside the wedge are deemed to be offending 
redeye pixels.</p>
<p><font color="#FF0000">
<b>Beginning of the isRedeye method</b></font></p>
<p>The method begins by defining three <i>selectivity constants</i> for hue, saturation, and 
brightness that establish the position and shape of the wedge shown in Figure 4.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Beginning of the isRedeye method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private boolean isRedeye(Pixel pixel){

    final float hueThreshold = (float)0.95;
    final float saturationThreshold = (float)0.43;
    final float brightnessThreshold = (float)0.2;</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><font color="#FF0000"><b>The selectivity constants</b></font></p>
<p>The constants that are defined in Listing 16 control the selectivity of the 
decision algorithm.&nbsp; Increasing the values towards an upper limit of 1.0 
makes the wedge shown in Figure 4 smaller and makes the algorithm more 
selective.&nbsp; If you make the algorithm more selective, some offending redeye 
pixels may not be identified.&nbsp; <i>(This is the case with the offending 
redeye pixels in Figure 9.)</i></p>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The HSB color model</b><br />
  If this discussion doesn't seem to be making any sense to you, you probably 
	need to go back and study the<font size="3" face="arial">
	earlier lesson titled <i>The HSB Color Model</i> in <a href="#Resources">
	Resources</a> for an explanation of the HSB color cone.</font></td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Decreasing the selectivity</b></font></p>
<p>Decreasing the values of the selectivity constants causes the wedge shown 
in Figure 4 to become larger, and will make the decision algorithm less 
selective.&nbsp; This can cause the program to modify the color of pixels that 
aren't really offending redeye pixels.&nbsp; <i>(For example, some of the brown pixels in the 
iris selected and inappropriately modified in the bottom image of Figure 6.)</i></p>
<p><font color="#FF0000"><b>Values of constants and placement of lasso are 
critical</b></font></p>
<p>Therefore, the values of these constants, along with the placement of the 
lasso are critical.&nbsp; <i>(You may want to experiment with different values 
to see if you can come up with a better set of values.)</i></p>
<p><font color="#FF0000">
<b>Get the pixel color</b></font></p>
<p>Listing 17 gets the red, green, and blue color values for the pixel as 
defined by the RGB color model.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. Get the pixel color. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    Color color = pixel.getColor();
    double red = (double)color.getRed();
    double green = (double)color.getGreen();
    double blue = (double)color.getBlue();

    //Get the color as defined by the HSB color model.
    float[] hsbvals = new float[3];
    Color.RGBtoHSB(
                  (int)red,(int)green,(int)blue,hsbvals);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Then Listing 17 calls the <b>RGBtoHSB</b> method to translate the RGB color 
values into the hue, saturation, and brightness values as defined 
in the HSB color model.&nbsp; The hue, saturation, and brightness values are stored
<i>(in that order)</i> in 
the three elements of the array object referred to by <b>hsbvals</b>.</p>
<p><font color="#FF0000">
<b>Test the color against the redeye criterion</b></font></p>
<p>Listing 18 tests to determine if the pixel color is inside the wedge shown in 
Figure 4.&nbsp; If so, the method returns true.&nbsp; Otherwise, the method 
returns false.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. Test the color against the redeye 
criterion. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    if(((hsbvals[0] &gt; hueThreshold) ||
        (hsbvals[0] &lt; (1.0 - hueThreshold))) &&
        (hsbvals[1] &gt; saturationThreshold) &&
        (hsbvals[2] &gt; brightnessThreshold)){
      return true;
    }//end if
    return false;
  }//end isRedeye</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Hue values are cyclical</b></font></p>
<p>Recall that the hue values are cyclical with the three-o'clock 
position in Figure 4 representing both 0.0 and 1.0.&nbsp; Therefore, it is 
necessary to test the hue as being close to 1.0 and also as being close to 0.0 
in Listing 18.</p>
<p>Listing 18 signals the end of the <b>isRedeye</b> method.</p>
<h3><a name="The_fixRedeye_method">The fixRedeye method</a></h3>
<p>If the <b>Override</b> button shown in Figure 11 is not selected, the <b>
fixRedeye</b> method 
calls the <b>isRedeye</b> method in an attempt to exclude any pixels contained in 
the lasso that aren't offending redeye pixels.&nbsp; Then it changes the color 
of the remaining pixels in the lasso to gray while maintaining some of the 
highlights.&nbsp; The method also smooths the edges of the lasso.</p>
<p>If the <b>Override</b> button is selected, the <b>fixRedeye</b> method skips the 
call to <b>isRedeye</b> and changes the color of all the pixels inside the lasso 
as shown in Figure 10,</p>
<p><font color="#FF0000">
<b>Beginning of the fixRedeye method</b></font></p>
<p>The <b>fixRedeye</b> method begins in Listing 19.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. Beginning of the fixRedeye method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  private void fixRedeye(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(ellipse == null) return;

    //Don't allow another event to be fired by the button
    // while this method is being executed.
    fixRedeyeButton.setEnabled(false);

    //Working variables.
    Color color = null;
    int red = 0;
    int green = 0;
    int blue = 0;</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 19 is straightforward and shouldn't require an 
explanation beyond the embedded comments.</p>
<p><font color="#FF0000">
<b>Change color of offending redeye pixels to gray</b></font></p>
<p>Listing 20 begins by using a pair of nested <b>for</b> loops along with an <b>
if</b> statement to identify the 
pixels that are contained in the circular lasso <i>(ellipse)</i>.&nbsp; <i>(Note 
that it is necessary to compensate for the insets when making the test.)</i></p>
<p>If a pixel is determined to be outside of the lasso, it is simply skipped and 
the next pixel is tested.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Change color of offending redeye pixels 
to gray. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>    for(int col = 0;
              col &lt; zoomDisplayPicture.getWidth();col++){
      for(int row = 0;
             row &lt; zoomDisplayPicture.getHeight();row++){

        if(ellipse.contains( col + leftInset,
                             row + topInset)){
          //The pixel is inside the lasso. Consider
          // changing its color.
          //Get a reference to the pixel.
          Pixel pixel =
                    zoomDisplayPicture.getPixel(col,row);
          
          //Test to see if the override button is
          // selected or the color of this pixel meets
          // the red eye criterion.
          if((overrideButton.isSelected()) || 
                                       (isRedeye(pixel))){
            //This pixel is believed to be an offending
            // redeye pixel.
            color = pixel.getColor();
            red = color.getRed()/4;//Decrease red by 4.
            green = color.getGreen();
            blue = color.getBlue();
            
            //Create a gray from the average of the
            // modified red, the green, and the blue
            // color values.
            int avg = (int)((red + green + blue)/3.0);
            color = new Color(avg,avg,avg);//gray
            pixel.setColor(color);
          }//end if
        }//end if

      }//end inner loop
    }//end outer loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>When the pixel is inside the lasso...</b></font></p>
<p>Once it is determined that the pixel is inside the lasso, a test is made to 
determine if the <b>Override</b> button is selected.&nbsp; If the <b>Override</b> 
button is not selected, the <b>isRedeye</b> method is called to determine if the 
color of the pixel meets the red eye criterion.</p>
<p>If the pixel meets the 
redeye criterion, or if the <b>Override</b> button is selected <i>(in which case 
the call to the <b>isRedeye</b> method is simply skipped)</i>, code is executed to 
change the color of the pixel.</p>
<p><font color="#FF0000"><b>The new color is gray</b></font></p>
<p>The new color is gray.&nbsp; The gray <b>Color</b> object is constructed by averaging weighted versions of the 
existing colors of red, green, and blue in order to reduce the red content and also maintain the 
highlights.</p>
<p>Listing 20 also signals the end of both the inner and the outer loops.&nbsp; 
When the code in Listing 20 has been executed, all of the pixels in the zoomed 
image have been examined.&nbsp; Those inside the lasso have been qualified to 
select only offending redeye pixels.&nbsp; The colors of the offending redeye 
pixels have been changed to various shades of gray.</p>
<p><font color="#FF0000">
<b>Smooth the edges and display the modified image</b></font></p>
<p>Listing 21 calls a method named <b>smoothEdges</b>.&nbsp; This method averages pixels at 
the boundary of the lasso to avoid having a harsh color discontinuity at the 
boundary.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. Smooth the edges and display the 
modified image. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    //Call a method to smooth the edges of the area
    // contained in the lasso.
    smoothEdges();

    zoomDisplayPicture.repaint();
  }//end fixRedeye method
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 21 also signals the end of the method named <b>fixRedeye</b>.</p>
<h3><a name="The_smoothEdges_method">The smoothEdges method</a></h3>
<p>I will stipulate up front that the inclusion of this method in the program may be 
overkill.&nbsp; I'm not certain that the cosmetic improvement provided by the 
method is worthwhile except possibly in the case of images where the eye is very 
large.</p>
<p>The purpose of this method is to break up the harsh outline of the circular 
lasso used to change the color of the pixels.</p>
<p><font color="#FF0000"><b>Average a small group of pixels...</b></font></p>
<p>This method averages the colors of a small group of pixels at 
the left and right boundaries of the lasso.&nbsp; Then it sets the color of each 
pixel in the group to the average color. The number of pixels in the group is 
equal to the <b>zoomFactor</b>.</p>
<p>The probability is high that when the zoomed image is restored to its 
original size, only one of the pixels in each group will be preserved.</p>
<p><font color="#FF0000">
<b>The method named smoothEdges</b></font></p>
<p>The method is shown in its entirety in Listing 22.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. The method named smoothEdges. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  private void smoothEdges(){

    if(ellipse == null) return;

    //Smooth the left side of the circle.
    for(int row = 0;
             row &lt; zoomDisplayPicture.getHeight();row++){
      for(int col = 0;
              col &lt; zoomDisplayPicture.getWidth();col++){
        if(ellipse.contains(col + leftInset,
                            row + topInset)){
          <b>averagePixels(col,row)</b>;
          //Break out of the inner loop and process the
          // nest row.
          col = zoomDisplayPicture.getWidth();
        }//end if
      }//end inner loop
    }//end outer loop

    //Smooth the right side of the circle. This code is
    // essentially the mirror image of the code used to
    // smooth the left side.
    for(int row = 0;
              row &lt; zoomDisplayPicture.getHeight();row++){
      for(int col = zoomDisplayPicture.getWidth() - 1;
                                          col &gt;= 0;col--){
        if(ellipse.contains(col + leftInset,
                            row + topInset)){
          <b>averagePixels(col,row)</b>;
          col = -1;//Break out of inner loop.
        }//end if
      }//end inner loop
    }//end outer loop

  }//end smoothEdges</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>An exercise in indexing</b></font></p>
<p>The code in the method is simply an exercise in indexing.&nbsp; Although the 
method is tedious, it is not complex.&nbsp; Therefore, no explanation beyond the embedded 
comments should be needed.</p>
<p>The code in Listing 22 calls a method named <b>averagePixels</b> 
where the averaging of the pixel colors is actually performed.</p>
<h3><a name="The_averagePixels_method">The averagePixels method</a></h3>
<p>This method computes the average color of a group of contiguous pixels on the 
same row and sets the color of all of the pixels in the group to the average 
color.&nbsp; As mentioned above, the number of pixels in the group is equal to <b>zoomFactor</b>.</p>
<p>The <b>averagePixels</b> method is shown in its entirety in Listing 23.</p>
<p>
<b><a name="Listing_23">Listing 23</a>. The averagePixels method. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void averagePixels(int col,int row){
    //Avoid coordinate out of bounds problem.
    if((col - zoomFactor/2) &lt; 0){return;}

    //Initialize accumulators.
    int redTotal = 0;
    int greenTotal = 0;
    int blueTotal = 0;

    //Compute the sums of the color values.
    for(int cnt = col - zoomFactor/2;
                         cnt &lt; col + zoomFactor/2;cnt++ ){
      pixel = zoomDisplayPicture.getPixel(cnt,row);
      redTotal += pixel.getRed();
      greenTotal += pixel.getGreen();
      blueTotal += pixel.getBlue();
    }//end for loop

    //Now set the color of the pixels to the average
    // color.
    for(int cnt = col - zoomFactor/2;
                         cnt &lt; col + zoomFactor/2;cnt++ ){
      pixel = zoomDisplayPicture.getPixel(cnt,row);
      pixel.setRed(redTotal/zoomFactor);
      pixel.setGreen(greenTotal/zoomFactor);
      pixel.setBlue(blueTotal/zoomFactor);
    }//end for loop
  }//end averagePixels</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You should have no difficulty understanding the code in Listing 23 on the 
basis of the embedded comments.</p>
<h3><a name="Reduce_and_recombine_the_zoomed_image">Reduce and recombine the 
zoomed image</a></h3>
<p>When the user clicks the <b>Recombine Images</b> button, the zoomed image is 
reduced back to its original size and merged back into the image in the main 
display.&nbsp; This is accomplished by an event handler that begins in Listing 
24.</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Beginning of the event handler on the 
Recombine Images button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    recombineButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Return if there is no zoomDisplayPicture to
          // recombine with displayPicture.
          if(zoomDisplayPicture == null) return;

          //Enable and disable various buttons.
          zoomButton.setEnabled(true);
          commitButton.setEnabled(true);
          writeButton.setEnabled(true);
          quitButton.setEnabled(true);
          recombineButton.setEnabled(false);

          //Scale the zoomed image back down to the
          // correct size.
          zoomDisplayPicture = zoomDisplayPicture.scale(
                           1.0/zoomFactor,1.0/zoomFactor);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>You should have no difficulty understanding the code in Listing 24.&nbsp; 
When the code in Listing 24 has executed, the <b>Picture</b> object referred to 
by <b>zoomDisplayPicture</b> has been scaled back down to the original size.</p>
<p><font color="#FF0000">
<b>Merge the two images</b></font></p>
<p>Listing 25 uses a pair of nested <b>for</b> loops to merge the image from the
<b>Picture</b> object referred to by <b>zoomDisplayPicture</b> back into the 
correct position in the <b>Picture</b> object referred to by <b>pictureObject</b>.</p>
<p>
<b><a name="Listing_25">Listing 25</a>. Merge the two images. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>          for(int col = 0;col &lt; pictureWidth - 1;col++){
            for(int row = 0;row &lt; pictureHeight -1;row++){
              if((col &gt;= xMin) &&
                 (col &lt; (xMin + zoomPictureWidth)) &&
                 (row &gt;= yMin) &&
                 (row &lt; (yMin + zoomPictureHeight))){
                //Get access to the pixel that will be
                // modified.
                pixel = displayPicture.getPixel(col,row);
                //Modify the color of the pixel.
                pixel.setColor(
                     zoomDisplayPicture.getPixel(
                       col - xMin,row - yMin).getColor());
              }//end if
            }//end inner loop
          }//end outer loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Deciding where to insert the modified sub-image</b></font></p>
<p>Note that the code in Listing 25 uses <b>xMin</b>, <b>xMax</b>, <b>
zoomPictureWidth</b>, and <b>zoomPictureHeight</b>, which were established in 
Listing 8 to decide where to insert the pixels from the zoomed image.&nbsp; 
Recall that these are the four values that were used to define a sub image that 
would be copied and scaled in Listing 9.</p>
<p>When the code in Listing 25 has been executed, the pixels from the zoomed 
image have replaced the corresponding pixels in the image from which the sub 
image was originally copied.</p>
<p><font color="#FF0000">
<b>Dispose of the zoomed picture</b></font></p>
<p>Listing 26 disposes of the frame that contains the zoomed image.&nbsp; This 
causes the zoomed picture shown in Figure 2 to disappear from the screen and 
releases all resources currently held by that picture.</p>
<p>
<b><a name="Listing_26">Listing 26</a>. Dispose of the zoomed picture. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
          zoomPictureFrame.dispose();
          displayPicture.repaint();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Repaint and end the anonymous class</b></font></p>
<p>Listing 26 also repaints the main display causing the modified image to be 
displayed as shown in the bottom image in Figure 1.</p>
<p>Finally, Listing 26 signals the end of the definition of the anonymous class that 
is defined to register an <b>ActionListener</b> on the button labeled <b>Recombine Images.</b></p>
<h3><a name="Commit_the_modified_image">Commit the modified image</a></h3>
<p>Any time that the <b>Commit</b> button is enabled, the user can commit the 
image in the main display into the backup image by clicking the button labeled
<b>Commit</b>.&nbsp; This is accomplished by an <b>ActionListener</b> object 
that is instantiated from the anonymous class defined in Listing 27.</p>
<p>
<b><a name="Listing_27">Listing 27</a>. Register an ActionListener object on the 
Commit button. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
    commitButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          backupPicture = new Picture(displayPicture);
        }//end action performed
      }//end newActionListener
    );//end addActionListener</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Caution regarding the white cursor</b><br />
  <font size="3" face="arial">
	If the <b>Commit</b> button is clicked while a white cursor is showing, that 
	cursor will be committed to the backup picture and cannot be removed without 
	starting all over.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Replace the backup picture</b></font></p>
<p>When the <b>Commit</b> button is clicked, the <b>Picture</b> object referred 
by <b>backupPicture</b> is replaced by a new <b>Picture</b> object that is a 
copy of the <b>Picture</b> object referred to by <b>the displayPicture</b>.&nbsp; 
This means that all changes made up to that point in time are committed and 
cannot be undone.</p>
<h3><a name="Writing_output_files">Writing output files</a></h3>
<p>As I explained earlier, any time the <b>Write</b> button shown in Figure 11 
is enabled, the user can write an output file containing the image in the main 
display shown in Figure 1.</p>
<p>In addition, if the user clicks the <b>Quit</b> button when it is enabled, or 
clicks the large X in the upper right corner of the GUI, the program will 
terminate, and in the process will write a final output file containing the 
image in the main display.</p>
<p>Three additional anonymous classes are defined to handle these actions.&nbsp; 
However, the code in the three classes is routine so&nbsp;&nbsp; I won't bore you 
with an explanation.&nbsp; You can view that code in Listing 28.</p>
<center>
<h2><a name="Run the program"></a>Run the program</h2>
</center>
<p>I encourage you to copy the code from Listing 28.&nbsp; Compile and execute 
that code using the digital photographs of your choice.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<p>Don't forget that Ericsson's multimedia 
library is required to compile and execute this program.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson I showed you how to write a Java program that can be used to 
correct for redeye problems in digital photographs.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you will learn how to construct a complex panel and add 
it to a JFrame, including event registration using anonymous listener classes, 
BoxLayout, and resource loading via the Class class.&nbsp; This is an important 
aspect of understanding Ericson's multimedia library.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li>
	<a href="http://en.wikipedia.org/wiki/Color_model">Color model</a> from 
Wikipedia</li>
	<li>
	<a href="../Light%20and%20color:%20%20an%20introduction">Light and color:&nbsp; 
an introduction</a> by Norman Koren</li>
	<li>
<a href="http://www.ncsu.edu/scivis/lessons/colormodels/color_models2.html#(HSV)">
Color Principles - Hue, Saturation, and Value</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
	<li><a href="http://www.developer.com/java/other/article.php/3806156">352</a> 
	Adding Animated Movement to Your Java Application</li>
	<li><a href="http://www.dickbaldwin.com/java/Java353.htm">353</a> A Slider-Controlled Sharpening Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java354.htm">354</a> The DigitalPicture Interface</li>
	<li><a href="http://www.dickbaldwin.com/java/Java355.htm">355</a> The HSB Color Model</li>
	<li><a href="http://www.dickbaldwin.com/java/Java356.htm">356</a> The show Method and the PictureFrame Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java357.htm">357</a> An HSB 
	Color-Editing Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java358.htm">358</a> Applying 
	Affine Transforms to Picture Objects</li>
	<li><a href="http://www.dickbaldwin.com/java/Java359.htm">359</a> Creating a 
	lasso for editing digital photos in Java</li>
	<li><a href="http://www.dickbaldwin.com/java/Java360.htm">360</a> Wrapping 
	Up the SimplePicture Class</li>
	<li><a href="http://www.dickbaldwin.com/java/Java361.htm">361</a> A 
	Temperature and Tint Editing Program for Digital Photos</li>
	<li><a href="http://www.dickbaldwin.com/java/Java362.htm">362</a> Getting 
	Started with the PictureExplorer Class</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listing</h2>
</center>
A complete listing of the program that I explained in this lesson is shown in Listing 
28 below.
<p>
<b><a name="Listing_28">Listing 28</a>. Source code listing for the program named RedEye05. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*File RedEye05 Copyright 2009 R.G.Baldwin

The purpose of this program is to demonstrate a
programming technique for correcting redeye problems in
digital photographs.

The program begins by displaying a GUI in the upper left
corner of the screen. At that point, the GUI contains a
text field for entry of the name of the image file to be
processed and some other user-input components, which are
disabled.  If the file is in the current directory, only
the file name and extension must be entered. Otherwise,
the full path and name and extension for the file must be
entered. Files of types jpg, bmp, and png are supported.

When the user enters the name of the image file into the
text field, the file is loaded into a Picture object. The
Picture object is displayed in the upper left corner of
the screen and the GUI is moved to a location immediately
below the Picture object.  At this point, the text field
is disabled and several buttons and radio buttons are
enabled.

The overall process is as follows. The user selects a
pixel in the eye containing the redeye problem by clicking
the mouse in the red area.

Then the user selects one of five radio buttons
specifying a zoom factor of 1, 2, 4, 8, or 16 and clicks a
button labeled Zoom. (A zoom factor of 16 is selected by
default at program startup.) This causes the area
surrounding the selected pixel to be enlarged by the
selected zoom factor and displayed in another window to
the right of the original picture object and the GUI. It
also causes the Zoom button and several other buttons in
the GUI to be disabled.

To correct the redeye problem in the selected eye, the
user surrounds the offending pixels in the zoomed image
with a circular lasso by dragging the mouse in the zoomed
image. Then the user clicks a button labeled Fix Redeye.

Clicking the Fix Redeye button causes an algorithm to be
executed that attempts to correct the redeye problem in
the area enclosed by the circular lasso. The algorithm
scans all of the pixels isolated by the circular lasso,
attempts to exclude any pixels that are not part of
the problem, and changes the color of the remaining pixels
to a dark gray with highlights preserved.

Clicking the mouse in the zoomed image at any time will
erase an existing lasso and undo the effects of having
clicked the Fix Redeye button.

The process can be repeated as many times as necessary
until the user is satisfied that the best fit of the
circular lasso and the offending pixels has been achieved.
Then the user clicks a button labeled Recombine Images to
cause the modified zoomed image to be reduced back to its
original size and merged back into the original image.

If the user is not happy with the results, the entire
process can be repeated by selecting the same eye again
and clicking the Zoom button. This will undo everything
back to the most recent commit operation (see below). If
the user is happy with the results for the eye currently
being processed, the user can accept the results by
clicking the Commit button and then perform the same
procedure on the other eye. Once committed, the pixels are
permanently changed in a backup image being held in memory
and the changes cannot be undone. However, at no time does
this program modify the original image file.

As explained above, the user can drag the mouse in the
zoomed image to create a circular lasso. An anchor point
is established when the user first presses the mouse
button to begin the drag operation.

The lasso can be created in any direction from the anchor
point.  The diameter of the lasso is equal to the distance
from the mouse pointer to the anchor point. The final size
and position of the lasso is established when the user
releases the mouse button and ends the drag operation.

Dragging the mouse outside the bounds of the image
causes the size of the lasso to continue to grow. However,
if the lasso extends outside the bounds of the zoomed
image, clicking the Fix Redeye button will have no effect.

The lasso remains on the screen until the user clicks the
zoomed image again with the mouse, clicks the Fix Redeye
button, clicks the Recombine Images button, or does
something else to cause the image to be repainted such as
minimizing and then restoring the zoomed image.

Clicking the Write button (when it is enabled) causes a
backup bmp file of the displayed image to be written into
the same directory from which the image file was read. The
five most recent backup files are saved. The names of the
backup files are the same as the name of the original
image file except that the characters BAKn are inserted
immediately before the extension. The character n is
replaced by a digit from 0 through 4.

The large X buttons in the upper right corner of both
image displays are disabled.  Clicking them does nothing.

The program is terminated by clicking the Quit button
(when it is enabled) or clicking the large X in the
upper right corner of the GUI at any time.

Before terminating, the program writes an output file
containing the final state of the displayed image in the
same format as the input file. The file is written into
the folder from which the original image file was read.
The name of the output file is the same as the name of the
input file except that the word FINAL is inserted
immediately before the extension.

The class files in Ericson's multimedia library must be
accessible to the program.

Tested using Windows Vista Home Premium Edition,
Java 1.6x, and the version of Ericson's multimedia library
contained in bookClasses10-1-07.zip.
*********************************************************/

import java.awt.Graphics;
import java.awt.Image;
import java.awt.BorderLayout;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseMotionAdapter;

import java.awt.geom.Ellipse2D;
import java.awt.geom.Ellipse2D.Double;

import java.awt.image.BufferedImage;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextField;
import javax.swing.JRadioButton;
import javax.swing.ButtonGroup;
import javax.swing.WindowConstants;

import java.io.File;

public class RedEye05 extends JFrame{
  //Create the components that are used to construct the
  // GUI.
  private JPanel mainPanel = new JPanel();
  private JPanel northPanel = new JPanel();
  private JPanel centerPanel = new JPanel();
  private JPanel southPanel = new JPanel();

  private JButton fixRedeyeButton =
                                new JButton("Fix Redeye");
  private JButton writeButton = new JButton("Write File");
  private JButton zoomButton = new JButton("Zoom");
  private JButton recombineButton =
                          new JButton("Recombine Images");
  private JButton quitButton = new JButton("Quit");
  private JButton commitButton = new JButton("Commit");

  private JRadioButton zoom1 = new JRadioButton("X1");
  private JRadioButton zoom2 = new JRadioButton("X2");
  private JRadioButton zoom4 = new JRadioButton("X4");
  private JRadioButton zoom8 = new JRadioButton("X8");
  private JRadioButton zoom16 =
                             new JRadioButton("X16",true);
  private JRadioButton overrideButton = 
                             new JRadioButton("Override");
  private ButtonGroup buttonGroup = new ButtonGroup();

  private JTextField fileNameField =
                           new JTextField("RedEye05.jpg");
  private JLabel fileNameLabel = new JLabel("File Name:");

  //A reference to the original Picture object will be
  // stored here.
  private Picture backupPicture = null;
  //A reference to the picture that is zoomed will be
  // stored here.
  private Picture zoomBackupPicture = null;

  //A reference to a working copy of the original
  // Picture object will be stored here.
  private Picture displayPicture = null;
  //A reference to a working copy of the zoomed picture
  // will be stored here.
  private Picture zoomDisplayPicture = null;

  //Miscellaneous working variables.
  private Graphics graphics = null;

  private Pixel pixel = null;
  private int writeCounter = 0;

  private String fileName = null;
  private String outputPath = null;
  private String extension = null;

  private int pictureWidth = 0;
  private int pictureHeight = 0;
  private int zoomPictureWidth = 0;
  private int zoomPictureHeight = 0;
  private int xMin = 0;
  private int yMin = 0;

  private int anchorX = 0;
  private int anchorY = 0;
  private int zoomAnchorX = 0;
  private int zoomAnchorY = 0;

  private int zoomDeltaX = 0;
  private int zoomDeltaY = 0;

  private int diameter = 0;
  private double angle = 0;

  private int leftInset = 0;
  private int topInset = 0;
  private int rightInset = 0;
  private int bottomInset = 0;

  private int zoomFactor = 16;

  private BufferedImage theImage = null;
  private BufferedImage zoomImage = null;

  private JFrame displayPictureFrame = null;
  private JFrame zoomPictureFrame = null;

  private Ellipse2D.Double ellipse = null;

  private Graphics2D g2d = null;

  private final double pi = Math.PI;//convenience constant
  //----------------------------------------------------//

  public static void main(String[] args){//main method
    new RedEye05();
  }//end main method
  //----------------------------------------------------//

  public RedEye05(){//constructor

    //All close operations are handled in a WindowListener
    // object.
    setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Construct the GUI. Components are arranged in the
    // GUI from left to right, top to bottom in
    // approximately the order that they are used.
    mainPanel.setLayout(new BorderLayout());
    mainPanel.add(northPanel,BorderLayout.NORTH);
    mainPanel.add(centerPanel,BorderLayout.CENTER);
    mainPanel.add(southPanel,BorderLayout.SOUTH);

    //Add components to the north panel.
    northPanel.add(fileNameLabel);
    northPanel.add(fileNameField);
    northPanel.add(zoom1);
    northPanel.add(zoom2);
    northPanel.add(zoom4);
    northPanel.add(zoom8);
    northPanel.add(zoom16);
    buttonGroup.add(zoom1);
    buttonGroup.add(zoom2);
    buttonGroup.add(zoom4);
    buttonGroup.add(zoom8);
    buttonGroup.add(zoom16);
    northPanel.add(zoomButton);

    //Add components to the center panel
    centerPanel.add(overrideButton);
    centerPanel.add(fixRedeyeButton);
    centerPanel.add(recombineButton);

    //Add components to the south panel.
    southPanel.add(commitButton);
    southPanel.add(writeButton);
    southPanel.add(quitButton);

    //Disable the buttons until the user enters the file
    // name.
    zoom1.setEnabled(false);
    zoom2.setEnabled(false);
    zoom4.setEnabled(false);
    zoom8.setEnabled(false);
    zoom16.setEnabled(false);
    zoomButton.setEnabled(false);
    fixRedeyeButton.setEnabled(false);
    recombineButton.setEnabled(false);
    commitButton.setEnabled(false);
    writeButton.setEnabled(false);
    quitButton.setEnabled(false);

    //Set the size of the GUI and display it in the upper
    // left corner of the screen. It will be moved later
    // to a position immediately below the display of the
    // picture.
    getContentPane().add(mainPanel);
    pack();
    setVisible(true);

    //Request that the focus move to the text field where
    // the file name is to be entered.
    fileNameField.requestFocus();
    //--------------------------------------------------//

    //Register a listener on the text field. When the user
    // enters the file name in the text field, set
    // everything up properly so that the program will
    // function as an event-driven picture-manipulation
    // program until the user clicks the large X in the
    // upper-right of the GUI.
    fileNameField.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Disable the text field and its label to
          // prevent the user from entering anything else
          // into it and causing it to fire another event.
          fileNameField.setEnabled(false);
          fileNameLabel.setEnabled(false);

          //Get the file name from the text field and use
          // it to create a new Picture object.
          fileName = fileNameField.getText();
          backupPicture = new Picture(fileName);

          //Get information that will be used to write the
          // output files.
          String inputPath = new File(fileName).
                                        getAbsolutePath();
          int posDot = inputPath.lastIndexOf('.');
          outputPath = inputPath.substring(0,posDot);

          //Write the first copy of the output backup
          // file before any processing is done.
          backupPicture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");

          //Get filename extension. It will be used later
          // to write the final output file.
          extension = inputPath.substring(posDot);

          //Decorate the GUI.
          setTitle("Copyright 2009, R.G.Baldwin");

          //Create the picture that will be used for
          // processing.
          //Note that the original image file is not
          // modified by this program.
          displayPicture = new Picture(backupPicture);

          //Display the picture.
          displayPicture.show();

          //Save a reference to the image. Also save the
          // width and height of the picture.
          theImage =
                (BufferedImage)(backupPicture.getImage());
          pictureWidth = backupPicture.getWidth();
          pictureHeight = backupPicture.getHeight();

          //Get and save a reference to the JFrame object
          // that contains the image.
          displayPictureFrame =
                   displayPicture.getPictureFrame().frame;

          //Get and save the insets for the JFrame object.
          leftInset =
                     displayPictureFrame.getInsets().left;
          topInset = displayPictureFrame.getInsets().top;
          rightInset =
                    displayPictureFrame.getInsets().right;
          bottomInset =
                   displayPictureFrame.getInsets().bottom;

          //Adjust the width of the GUI to match the width
          // of the display if possible. Then relocate the
          // GUI to a position immediately below the
          // display.
          //Establish the preferred size now that the
          // input file name has been entered.
          pack();
          int packedHeight = getHeight();
          int packedWidth = getWidth();
          if((pictureWidth + 7) &gt;= packedWidth){
            //Make the width of the GUI the same as the
            // width of the display.
            setSize(pictureWidth + 7,packedHeight);
          }//Else, just leave the GUI at its current size.
          //Put the GUI in its new location immediately
          // below the display.
          setLocation(0,pictureHeight + 30);

          //Enable user input controls.
          zoom1.setEnabled(true);
          zoom2.setEnabled(true);
          zoom4.setEnabled(true);
          zoom8.setEnabled(true);
          zoom16.setEnabled(true);
          zoomButton.setEnabled(true);
          commitButton.setEnabled(true);
          writeButton.setEnabled(true);
          quitButton.setEnabled(true);

          //Disable the X-button on the display.
          displayPictureFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);
          //--------------------------------------------//

          /*
          Note that the following listener registration is
          actually inside the action listener that is
          registered on the text field. The code in the
          registration block can't be executed when the
          GUI is first constructed because a Picture
          object does not exist at that point in time.
          This code is executed after the user enters the
          image file name, the file has been read, and the
          Picture object referred to by displayPicture has
          been constructed.
          */
          displayPictureFrame.addMouseListener(
            new MouseAdapter(){
              public void mousePressed(MouseEvent e){
                //Draw a new copy of the image on the
                // display each time the user clicks the
                // image with the mouse. This creates a
                // fresh copy of the displayPicture. Note
                // however that the image being copied
                // may contain changes made earlier when
                // the user clicked the Commit button.
                graphics = displayPicture.getGraphics();
                graphics.drawImage(
                       backupPicture.getImage(),0,0,null);
                displayPicture.repaint();

                //Prepare some working variables.
                //Note that the reported coordinates for
                // a mouse press on the upper-left corner
                // of the image will not be reported
                // as 0,0 due to the top and left insets
                // of the JFrame.
                anchorX = e.getX();
                anchorY = e.getY();
                //Draw a small white cursor to mark the
                // location of the mouse press on the
                // image.
                drawCursor();
              }//end mousePressed
            }//end new MouseAdapter
          );//end addMouseListener
          //--------------------------------------------//
        //Now finish defining the action listener that is
        // registered on the text field.
        }//end actionPerformed
      }//end new ActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //The event handler on this button copies the backup
    // picture into displayPicture and then calls the zoom
    // method to produce a zoomed version of
    // displayPicture. The zoomed version makes it easier
    // to place a lass on around the offending redeye
    // pixels.
    zoomButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Get a fresh image in order to prevent the
          // current cursor from showing in the zoomed
          // version.
          //Note however that if the user previously
          // clicked the Commit button when a cursor was
          // showing in the picture, that cursor will have
          // been permanently written into the backup
          // picture.
          graphics = displayPicture.getGraphics();
          graphics.drawImage(
                       backupPicture.getImage(),0,0,null);
          displayPicture.repaint();

          //Call the zoom method to do all the hard work.
          zoom();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //The event handler on this button calls a method that
    // changes the color of the offending redeye pixels
    // that are enclosed in a circular lasso.
    fixRedeyeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          fixRedeye();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //The event handler on this button restores the zoomed
    // image to the correct size and recombines it with
    // displayPicture.
    //There is probably a way to combine the two images
    // directly without having to loop, but I haven't
    // found it yet.
    recombineButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          //Return if there is no zoomDisplayPicture to
          // recombine with displayPicture.
          if(zoomDisplayPicture == null) return;

          //Enable and disable various buttons.
          zoomButton.setEnabled(true);
          commitButton.setEnabled(true);
          writeButton.setEnabled(true);
          quitButton.setEnabled(true);
          recombineButton.setEnabled(false);

          //Scale the zoomed image back down to the
          // correct size.
          zoomDisplayPicture = zoomDisplayPicture.scale(
                           1.0/zoomFactor,1.0/zoomFactor);

          //Merge the modified image into displayPicture
          for(int col = 0;col &lt; pictureWidth - 1;col++){
            for(int row = 0;row &lt; pictureHeight -1;row++){
              if((col &gt;= xMin) &&
                 (col &lt; (xMin + zoomPictureWidth)) &&
                 (row &gt;= yMin) &&
                 (row &lt; (yMin + zoomPictureHeight))){
                //Get access to the pixel that will be
                // modified.
                pixel = displayPicture.getPixel(col,row);
                //Modify the color of the pixel.
                pixel.setColor(
                     zoomDisplayPicture.getPixel(
                       col - xMin,row - yMin).getColor());
              }//end if
            }//end inner loop
          }//end outer loop

          //Release the resources that are held by the
          // zoomed picture and repaint displayPicture.
          zoomPictureFrame.dispose();
          displayPicture.repaint();
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //When the Commit button is clicked, the
    // displayPicture is committed for the long term by
    // copying it to the backup picture. Note that if this
    // button is clicked while a white cursor is showing
    // in displayPicture, that cursor will be committed
    // to the backup picture and cannot be removed
    // without starting all over.
    commitButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          backupPicture = new Picture(displayPicture);
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register an ActionListener on the writeButton.
    // Each time the user clicks the button, a backup bmp
    // file containing the current state of displayPicture
    // is written into the directory from which the
    // original image was read. The five most recent
    // backup files are saved.
    //The names of the backup files are the same as the
    // name of the input file except that BAKn is
    // inserted immediately ahead of the extension
    // where n is a digit ranging from 0 to 4. The value
    // of n rolls over at 4 and starts back at 0.
    writeButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          displayPicture.write(outputPath
                       + "BAK" + writeCounter++ + ".bmp");
          //Reset the writeCounter if it exceeds 4 to
          // conserve disk space.
          if(writeCounter &gt; 4){
            writeCounter = 0;
          }//end if
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //The behavior of the event handler on the quit button
    // is the same as the behavior of the event handler on
    // the large X in the upper right corner of the GUI
    // that is explained below.
    quitButton.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent e){
          displayPicture.write(
                        outputPath + "FINAL" + extension);
          System.exit(0);
        }//end action performed
      }//end newActionListener
    );//end addActionListener
    //--------------------------------------------------//

    //Register a WindowListener that will respond when the
    // user clicks the large X in the upper-right corner
    // of the GUI. This event handler will write the final
    // state of displayPicture into an output file of the
    // same type as the original input file. The name will
    // be the same except that the word FINAL will be
    // inserted immediately ahead of the extension.
    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          displayPicture.write(
                        outputPath + "FINAL" + extension);
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    //--------------------------------------------------//


  }//end constructor
  //----------------------------------------------------//

  //This method creates a new Picture object that contains
  // a rectangular subimage of the pixels surrounding the
  // pixel selected by the user before clicking the Zoom
  // button.
  //The amount of zoom is determined by the radio button
  // that is selected. If the selected pixel is not close
  // to the edge of the image, the size of the zoomed
  // image will be 464x464 pixels. If the selected pixel
  // is close to one of the edges of the image, the zoomed
  // image will be smaller.
  private void zoom(){
    //Enable and disable various buttons.
    zoomButton.setEnabled(false);
    commitButton.setEnabled(false);
    writeButton.setEnabled(false);
    quitButton.setEnabled(false);
    recombineButton.setEnabled(true);

    //Establish the amount of zoom that will be applied.
    if(zoom1.isSelected()){
      zoomFactor = 1;
    }else if(zoom2.isSelected()){
      zoomFactor = 2;
    }else if(zoom4.isSelected()){
      zoomFactor = 4;
    }else if(zoom8.isSelected()){
      zoomFactor = 8;
    }else{
      zoomFactor = 16;
    }//end else

    //The numerator in the following fraction needs to be
    // divisible by 16 to maintain the best picture
    // quality when the image is later restored to its
    // original size.
    zoomPictureWidth = 464/zoomFactor;
    zoomPictureHeight = 464/zoomFactor;

    //Compute the coordinates for the upper-left corner
    // along with the width and height of the rectangular
    // sub image.
    xMin = anchorX - 232/zoomFactor - leftInset;

    if(xMin &lt; 0){//Avoid negative coordinate values.
      xMin = 0;
    }//end if

    if((xMin + zoomPictureWidth) &gt; (pictureWidth - 1)){
      zoomPictureWidth = pictureWidth - xMin - 1;
    }//end if

    yMin = anchorY - 232/zoomFactor - topInset;

    if(yMin &lt; 0){
      yMin = 0;//Avoid negative coordinate values.
    }//end if

    if((yMin + zoomPictureHeight) &gt; (pictureHeight - 1)){
      zoomPictureHeight = pictureHeight - yMin - 1;
    }//end if

    //Get the subimage that will be scaled up to create
    // the zoomed image.
    BufferedImage subImage = ((BufferedImage)(
                  displayPicture.getImage())).getSubimage(
                                       xMin,
                                       yMin,
                                       zoomPictureWidth,
                                       zoomPictureHeight);
    //Use the subimage to create two new Picture objects,
    // one for backup, and the other for a working
    // picture. Both are scaled up by zoomFactor. Display
    // the working picture.
    zoomBackupPicture = new Picture(subImage);
    zoomBackupPicture = zoomBackupPicture.scale(
                                   zoomFactor,zoomFactor);
    zoomDisplayPicture = new Picture(zoomBackupPicture);
    zoomDisplayPicture.show();

    //Get and save a reference to the JFrame object that
    // contains the working picture.
    zoomPictureFrame =
               zoomDisplayPicture.getPictureFrame().frame;

    //Disable the X-button on the zoom display.
    zoomPictureFrame.setDefaultCloseOperation(
                     WindowConstants.DO_NOTHING_ON_CLOSE);

    //Position the zoomed working picture at the top of
    // the screen immediately to the right of either
    // displayPicture or the GUI, whichever is wider.
    int zoomLocationX = 0;
    if((pictureWidth + leftInset + rightInset) &gt;
                                         this.getWidth()){
      zoomLocationX =
                    pictureWidth + leftInset + rightInset;
    }else{
      zoomLocationX = this.getWidth();
    }//end else

    zoomPictureFrame.setLocation(zoomLocationX,0);

    //Get and save a reference to the object on which the
    // circular lasso will be drawn.
    g2d = (Graphics2D)(zoomPictureFrame.getGraphics());
    zoomImage =
            (BufferedImage)(zoomBackupPicture.getImage());

    //--------------------------------------------------//
    //Register a mousePressed listener and a mouseDragged
    // listener on the zoomPictureFrame. This is done here
    // because it couldn't be done before the zoomed
    // display picture was created.
    //--------------------------------------------------//

    // This mousePressed event handler creates a fresh
    // zoomed image using the zoomed backup picture and
    // establishes the anchor point for the ellipse that
    // will be drawn.
    zoomPictureFrame.addMouseListener(
      new MouseAdapter(){
        public void mousePressed(MouseEvent e){
          graphics = zoomDisplayPicture.getGraphics();
          graphics.drawImage(
                  zoomBackupPicture.getImage(),0,0,null);
          zoomDisplayPicture.repaint();

          zoomAnchorX = e.getX();
          zoomAnchorY = e.getY();
          zoomDeltaX = 0;
          zoomDeltaY = 0;

          //Enable the button that will be used to call
          // the method that modifies the colors of the
          // pixels enclosed by the lasso.
          fixRedeyeButton.setEnabled(true);

        }//end mousePressed
      }//end new MouseAdapter
    );//end addMouseListener
    //--------------------------------------------------//

    //This mouseDragged event handler will call a method
    // to draw a lasso when the mouse is dragged in the
    // zoomed image.
    zoomPictureFrame.addMouseMotionListener(
      new MouseMotionAdapter(){
        public void mouseDragged(MouseEvent e){
          drawLasso(e.getX(),e.getY());
        }//end mouseDragged
      }//end new MouseMotionAdapter
    );//end addMouseMotionListener
    //--------------------------------------------------//

  }//end zoom method
  //----------------------------------------------------//

  //This method draws a circular lasso that always
  // touches the anchor point established by the
  // mousePressed event handler.
  //This method is called each time the mouseDragged
  // event handler fires a MouseEvent.
  private void drawLasso(int x,int y){

    //The parameters x and y contain the coordinates of
    // the mouse pointer when the event was fired. Update
    // the diameter of the circular lasso.
    zoomDeltaX = x - zoomAnchorX;
    zoomDeltaY = y - zoomAnchorY;
    diameter = (int)Math.hypot(zoomDeltaX,zoomDeltaY);

    g2d.setColor(Color.GREEN);

    //Copy the entire image from the backup picture
    // stored in memory to erase any lassos drawn
    // earlier. This causes a single circular lasso to
    // appear to track the mouse position.
    g2d.drawImage(zoomImage,
                 zoomPictureFrame.getInsets().left,
                 zoomPictureFrame.getInsets().top,null);

    //Get the angle in radians that a line joining the
    // anchor point and the current mouse location makes
    // with a horizontal line going through the anchor
    // point. This is the angle that will be used in the
    // computations required to rotate the circular
    // ellipse around the anchor point while continually
    // touching the anchor point.
    angle =
       Math.atan2((double)zoomDeltaY,(double)zoomDeltaX);

    //Create and draw a circular ellipse that touches the
    // anchor point at all times.
    ellipse = new Ellipse2D.Double(
          //Compute and specify the coordinates of the
          // upper left corner of a box that will contain
          // the circular ellipse.
          zoomAnchorX-(
                  diameter/2-Math.cos(angle)*diameter/2),
          zoomAnchorY-(
                  diameter/2-Math.sin(angle)*diameter/2),
          //Specify the width and the height of the box.
          diameter,
          diameter);

    //Draw the ellipse.
    g2d.draw(ellipse);

  }//end drawLasso
  //----------------------------------------------------//

  //This method executes an algorithm that attempts
  // to exclude any pixels contained in the lasso that
  // aren't offending redeye pixels, and change the
  // color of the remaining pixels contained in the lasso
  // to gray while maintaining some of the highlights.
  // The method also smooths the edges of the lasso.
  private void fixRedeye(){
    //Protect against clicking the button before drawing
    // a lasso.
    if(ellipse == null) return;

    //Don't allow another event to be fired while this
    // method is being executed.
    fixRedeyeButton.setEnabled(false);

    //Working variables.
    Color color = null;
    int red = 0;
    int green = 0;
    int blue = 0;

    for(int col = 0;
              col &lt; zoomDisplayPicture.getWidth();col++){
      for(int row = 0;
             row &lt; zoomDisplayPicture.getHeight();row++){
        //Change the color of the offending redeye pixels
        // inside the ellipse.
        //Note: It is necessary to compensate for the top
        // and left insets of the JFrame.
        if(ellipse.contains( col + leftInset,
                             row + topInset)){
          //The pixel is inside the lasso. Consider
          // changing its color.
          //Get a reference to the pixel.
          Pixel pixel =
                    zoomDisplayPicture.getPixel(col,row);
          //Test to see if the override button is
          // selected or the color of this pixel meets
          // the red eye criterion. If so, modify the
          // color. The new color is gray constructed
          // by averaging weighted versions of the
          // existing colors in order to reduce the red
          // content and also maintain the highlights.
          if((overrideButton.isSelected()) || 
                                       (isRedeye(pixel))){
            //This pixel is believed to be an offending
            // redeye pixel.
            color = pixel.getColor();
            red = color.getRed()/4;//Decrease red by 4.
            green = color.getGreen();
            blue = color.getBlue();
            //Create a gray from the average of the
            // modified red, the green, and the blue
            // color values.
            int avg = (int)((red + green + blue)/3.0);
            color = new Color(avg,avg,avg);//gray
            pixel.setColor(color);
          }//end if
        }//end if

      }//end inner loop
    }//end outer loop

    //Call a method to smooth the edges of the area
    // contained in the lasso.
    smoothEdges();

    zoomDisplayPicture.repaint();
  }//end fixRedeye method
  //----------------------------------------------------//

  //This method is called to test a pixel to determine if
  // it meets the redeye criterion. This is done by
  // identifying a 3D quasi-triangular wedge in the HSB
  // color model cone. Any pixel whose color is inside
  // the wedge is deemed to be an offending redeye pixel.
  private boolean isRedeye(Pixel pixel){
    //The following constants control the selectivity of
    // the algorithm relative to the decision as to
    // whether or not the color of an individual pixel
    // should be modified. Increasing the values towards
    // an upper limit of 1.0 makes the algorithm more
    // selective, in which case some problem pixels may
    // not have their color modified. Decreasing the
    // values can cause the program to modify the color
    // of pixels that aren't a part of the redeye
    // problem. Therefore, the values of these constants
    // are critical. Note, however, that they may not
    // work well for all digital photos, and an upgrade
    // with sliders that allow the user to specify the
    // values might be useful.
    final float hueThreshold = (float)0.95;
    final float saturationThreshold = (float)0.43;
    final float brightnessThreshold = (float)0.2;

    //Get pixel color as defined by the RGB color model.
    Color color = pixel.getColor();
    double red = (double)color.getRed();
    double green = (double)color.getGreen();
    double blue = (double)color.getBlue();

    //Get the color as defined by the HSB color model.
    float[] hsbvals = new float[3];
    Color.RGBtoHSB(
                  (int)red,(int)green,(int)blue,hsbvals);

    //For debug and test.
    /*
    System.out.println(hsbvals[0] + " " +
                       hsbvals[1] + " " +
                       hsbvals[2]);
    */
    //Test to see if the pixel color is in the wedge.
    //Recall that the hue values are cyclical so it is
    // necessary to test the hue as being close to 1.0
    // and  also as being close to 0.0;
    if(((hsbvals[0] &gt; hueThreshold) ||
        (hsbvals[0] &lt; (1.0 - hueThreshold))) &&
        (hsbvals[1] &gt; saturationThreshold) &&
        (hsbvals[2] &gt; brightnessThreshold)){
      return true;
    }//end if
    return false;
  }//end isRedeye
  //----------------------------------------------------//

  //The purpose of this method is to break up the harsh
  // outline of the circle used to change the color of
  // the pixels contained in the lasso.
  //This method averages the colors of a small group of
  // pixels at the left and right boundaries of the
  // lasso and sets the color of each pixel in the
  // group to the average color. The number of pixels in
  // the group is equal to the zoomFactor. The
  // probability is high that when the zoomed image is
  // restored to its original size, only one of these
  // pixels will be preserved.
  private void smoothEdges(){

    if(ellipse == null) return;

    //Smooth the left side of the circle.
    for(int row = 0;
             row &lt; zoomDisplayPicture.getHeight();row++){
      for(int col = 0;
              col &lt; zoomDisplayPicture.getWidth();col++){
        if(ellipse.contains(col + leftInset,
                            row + topInset)){
          averagePixels(col,row);
          //Break out of the inner loop and process the
          // nest row.
          col = zoomDisplayPicture.getWidth();
        }//end if
      }//end inner loop
    }//end outer loop

    //Smooth the right side of the circle. This code is
    // essentially the mirror image of the code used to
    // smooth the left side.
    for(int row = 0;
              row &lt; zoomDisplayPicture.getHeight();row++){
      for(int col = zoomDisplayPicture.getWidth() - 1;
                                          col &gt;= 0;col--){
        if(ellipse.contains(col + leftInset,
                            row + topInset)){
          averagePixels(col,row);
          col = -1;//Break out of inner loop.
        }//end if
      }//end inner loop
    }//end outer loop

  }//end smoothEdges
  //----------------------------------------------------//

  //This method computes the average color of a group of
  // contiguous pixels on the same row and sets the color
  // of all of the pixels in the group to the average
  // color.
  //The number of pixels in the group is equal to the
  // zoomFactor.
  private void averagePixels(int col,int row){
    //Avoid coordinate out of bounds problem.
    if((col - zoomFactor/2) &lt; 0){return;}

    //Initialize accumulators.
    int redTotal = 0;
    int greenTotal = 0;
    int blueTotal = 0;

    //Compute the sums of the color values.
    for(int cnt = col - zoomFactor/2;
                         cnt &lt; col + zoomFactor/2;cnt++ ){
      pixel = zoomDisplayPicture.getPixel(cnt,row);
      redTotal += pixel.getRed();
      greenTotal += pixel.getGreen();
      blueTotal += pixel.getBlue();
    }//end for loop

    //Now set the color of the pixels to the average
    // color.
    for(int cnt = col - zoomFactor/2;
                         cnt &lt; col + zoomFactor/2;cnt++ ){
      pixel = zoomDisplayPicture.getPixel(cnt,row);
      pixel.setRed(redTotal/zoomFactor);
      pixel.setGreen(greenTotal/zoomFactor);
      pixel.setBlue(blueTotal/zoomFactor);
    }//end for loop
  }//end averagePixels
  //----------------------------------------------------//


  //This method draws a small white cursor when the user
  // clicks displayPicture with the mouse.
  private void drawCursor(){
    Graphics graphics = displayPicture.getGraphics();
    graphics.drawLine(anchorX - leftInset - 1,
                      anchorY - topInset,
                      anchorX - leftInset + 1,
                      anchorY - topInset);
    graphics.drawLine(anchorX - leftInset,
                      anchorY - topInset - 1,
                      anchorX - leftInset,
                      anchorY - topInset + 1);
    displayPicture.repaint();
  }//end drawCursor
  //----------------------------------------------------//
}//end class RedEye05</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>
