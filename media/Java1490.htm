<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
  <body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>2D Fourier Transforms using Java</h2>
    <i>Learn how the 
space domain and the wavenumber domain in two-dimensional analysis are analogous 
to the time domain and the frequency domain in one-dimensional analysis.&nbsp; 
Learn about some practical examples showing how 2D Fourier transforms 
and wavenumber spectra can be useful in solving engineering problems involving 
antenna arrays.</i><p><b>Published:</b>&nbsp; July 12, 2005<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 1490</p>
     
<ul>
    <li> <a href="#Preface">Preface</a></li>
   <li><a href="#General_Discussion">General Discussion</a></li>
     <li> <a href="#Run_the_Program">Run the Programs</a></li>
     <li> <a href="#Summary">Summary</a></li>
	<li> <a href="#Whats Next">What's Next?</a></li>
     <li> <a href="#Complete_Program_Listing">Complete Program Listing</a></li>
       
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface"></a>Preface</h2>
   </center>
  <p>This is the first part of a two-part lesson.&nbsp; In this lesson, I will teach you how to perform two-dimensional <i>(2D)</i> 
	Fourier transforms using Java.&nbsp; I will</p>
<ul>
	<li>Explain the conceptual and computational aspects of 2D Fourier 
	transforms</li>
	<li>Explain the relationship between the <i>space domain</i> and the <i>
	<a href="http://scienceworld.wolfram.com/physics/Wavenumber.html">wavenumber</a></i> domain</li>
	<li>Provide sufficient background information that you will be able to 
	appreciate the importance of the 2D Fourier transform</li>
	<li>Provide Java software to perform 2D Fourier transforms</li>
	<li>Provide Java 
	software to test and exercise that capability</li>
</ul>
<p><font color="#FF0000"><b>Two separate programs</b></font></p>
<p>I will present and explain two separate programs.&nbsp; One program consists 
of a single class named <b>ImgMod30</b>.&nbsp; The purpose of this class is to satisfy the 
computational requirements for forward and inverse 2D Fourier transforms.&nbsp; 
This class also provides a method for rearranging the spectral data into a more 
useful 
format for plotting.&nbsp; The second program named <b>ImgMod31</b> will be used 
to test the 2D Fourier transform class, and also to illustrate the use of 2D 
Fourier transforms for some well known 
sample surfaces.</p>
<p>A third class named <b>ImgMod29</b> will be used to display various 3D 
surfaces resulting from the application of the 2D Fourier transform.&nbsp; I 
explained this class in an earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a>.</p>
<p><font color="#FF0000"><b>Using the class named ImgMod30</b></font></p>
<p>The 2D Fourier transform class couldn't be easier to use.&nbsp; To perform a 
forward transform execute a statement similar to the following:</p>
<pre>ImgMod30.<b>xform2D</b>(spatialData,realSpect,
                 imagSpect,amplitudeSpect);</pre>
<p>The first 
parameter in the above statement is a reference to an array object containing the data to be transformed.&nbsp; 
The other three 
parameters refer to array objects that will be populated with the results of the 
transform.</p>
<p>To perform an inverse transform execute a statement similar to the following:</p>
<pre>ImgMod30.<b>inverseXform2D</b>(realSpect,imagSpect,
                        recoveredSpatialData);</pre>
<p>The first two parameters in the above statement refer to array objects containing 
the complex spectral data 
to be transformed.&nbsp; The third parameter refers to an array that will be 
populated with the results of the inverse transform.</p>
<p>To rearrange the spectral data for plotting, execute a 
statement similar to the following where the parameter refers to an array object 
containing the spectral data to be rearranged.</p>
<pre>double[][] <b>shiftedRealSpect</b> = 
                 ImgMod30.shiftOrigin(realSpect);</pre>
<p><b><font color="#FF0000">Digital signal processing (DSP)</font></b></p>
<p>This lesson will cover some technically difficult material in the general 
area of <i>Digital Signal Processing,</i> or <i>DSP</i> for short.&nbsp; As 
usual, the better prepared you are, the more likely you are to understand the 
material.&nbsp; For example, it would be well for you to already understand the 
one-dimensional Fourier transform before tackling the 2D Fourier transform.&nbsp; 
If you don't already have that knowledge, you can learn about one-dimensional 
Fourier transforms by studying the following <a name="lessons">lessons</a>:</p>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3374611">1478 
	Fun with Java, How and Why Spectral Analysis Works</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3380031">1482 
	Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the 
	FFT Algorithm </a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3392871">1483 
	Spectrum Analysis using Java, Frequency Resolution versus Data Length </a>
	</li>
	<li><a href="http://www.developer.com/java/other/article.php/3411041">1484 
	Spectrum Analysis using Java, Complex Spectrum and Phase Angle</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3436341">1485 
	Spectrum Analysis using Java, Forward and Inverse Transforms, Filtering in 
	the Frequency Domain</a> </li>
	<li><a href="http://www.developer.com/java/other/article.php/3457251">1486 
	Fun with Java, Understanding the Fast Fourier Transform (FFT) Algorithm</a></li>
</ul>
<p>You might also enjoy studying my other lessons on
<a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a> as well.</p>
<p><font color="#FF0000"><b>Will use in subsequent lessons</b></font></p>
<p>The 2D Fourier transform has many uses.&nbsp; I will use the 2D Fourier 
transform in several future lessons involving such diverse topics as:</p>
<ul>
	<li>Processing image pixels in the wavenumber domain</li>
	<li>Advanced steganography <i>(hiding messages in images)</i></li>
	<li>Hiding watermarks and trademarks in images</li>
</ul>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them. </p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="General_Discussion">General Discussion</a></h2>
<p><font color="#FF0000"><b>Time domain and frequency domain</b></font></p>
<p>In my earlier lessons on <a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a>, 
you learned about the relationship between the <i>time domain</i> and the <i>
frequency domain.</i>&nbsp; For example, you learned that time has only one 
dimension.&nbsp; In the real world, time only goes forward.</p>
<blockquote>
	<p><i>(In the computer world, we can make it appear that time can also go 
	backwards, but this still constitutes only one dimension.)</i></p>
</blockquote>
<p>The important point is that time can only go forward or backwards.&nbsp; It 
cannot go sideways.</p>
<p><font color="#FF0000"><b>A one-dimensional Fourier transform</b></font></p>
<p>You learned that you can perform a one-dimensional Fourier transform to 
transform your data 
from the time domain into the frequency domain.&nbsp; Similarly, you can perform an 
inverse one-dimensional Fourier transform to transform your data from the frequency domain 
back into the 
time domain.</p>
<p>You learned about several characteristics of Fourier transforms.&nbsp; For 
example, you learned that a Fourier transform is both linear and reversible.&nbsp; 
You learned that convolution in the time domain is equivalent to multiplication 
in the frequency domain, and that convolution in the frequency domain is 
equivalent to multiplication in the time domain.</p>
<p>You learned that with enough computational power, you can easily transform a 
given set of data back and forth between these two domains.&nbsp; This makes it 
possible to use the domain of choice to perform a given signal processing 
operation, even if the results need to be delivered in the other domain.</p>
<p><font color="#FF0000"><b>Time domain data is purely real</b></font></p>
<p>Although it is possible to use the Fourier transform to transform a set of 
complex data from one domain to the other, real world time domain data is not 
complex data.&nbsp; Rather, it is purely real.&nbsp; Assuming 
that the data in one domain is always purely real leads to some 
simplification of the computational requirements for performing the Fourier 
transform.&nbsp; 
In general, the previous <a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a> 
lessons assumed real data in the time domain and complex data in the frequency 
domain.</p>
<p><font color="#FF0000"><b>The space domain</b></font></p>
<p>In this lesson, we will extend the concept of the Fourier transform from the 
time domain into the <i>space domain.&nbsp; </i>In making this extension, we 
will encounter some significant additional complexity.&nbsp; For example, 
while time is one-dimensional, space is three-dimensional.&nbsp; While you 
can only move forward and backwards in time, you can move up, down, and sideways 
in space.</p>
<blockquote>
	<p><i>(In order to keep the complexity of this lesson in check, we 
	will assume that space is only two-dimensional, allowing movement up, down, 
	and from side to side only.&nbsp; This will serve us well later for such 
	tasks as image processing.&nbsp; Three-dimensional Fourier transforms are 
	beyond the scope of this lesson.&nbsp; I will write a lesson on using 
	Fourier transforms in three-dimensional space later if I have the time.)</i></p>
</blockquote>
<p>It is also possible and very common to combine time domain signal processing 
with space domain signal processing.&nbsp; However, that also is beyond the 
scope of this lesson.</p>
<p><font color="#FF0000"><b>Time and space are analogous</b></font></p>
<p>We will consider the space domain to be analogous to the time domain, with 
the stipulation that the space domain has two dimensions.&nbsp; The unit of 
measure in the time domain is usually seconds, or some derivative thereof.&nbsp; 
The unit of measure in space is usually meters, or some derivative thereof.</p>
<p>As with the time domain, we will assume that all space domain 
surfaces are purely real <i>(as opposed to being complex).</i>&nbsp; This will 
allow us to simplify our computations when performing the 2D Fourier transform 
to transform our data from the space domain into the wavenumber domain.</p>
<blockquote>
	<p><i>(I must point out that from a practical viewpoint this 
	assumption is much more limiting in the space domain than in the time 
	domain.&nbsp; Complex space domain functions are quite common in such areas 
	as antenna array processing.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Frequency and wavenumber are analogous</b></font></p>
<p>We will consider the <i>wavenumber</i> domain to be analogous to the frequency 
domain.&nbsp; The unit of measure in the frequency domain is cycle per second, 
or some derivative thereof.&nbsp; The unit of measure in the wavenumber domain 
is cycles per meter or some derivative thereof.</p>
<p><font color="#FF0000"><b>Period and wavelength are analogous</b></font></p>
<p>The reciprocal of the typical unit of measure in the frequency domain is 
seconds per cycle, commonly referred to as the <i>period.</i>&nbsp; The 
reciprocal of the typical unit of measure in the wavenumber domain is meters 
per cycle, commonly referred to as the <i>wavelength.</i></p>
<p><font color="#FF0000"><b>Some real world examples</b></font></p>
<p>With all of this as background, I will begin by discussing some real world engineering 
problems for which the solution lies in an understanding of the wavenumber domain.&nbsp; 
I will use these examples to show some of the practical uses of 2D Fourier 
transforms.</p>
<p>Following that <i>(in Part 2 of this lesson),</i> I will present and explain a class that you can copy and use 
to perform 2D Fourier transforms.&nbsp; Then I will present and explain a 
program that exercises and tests the 2D Fourier transform class for some common 
3D surfaces.</p>
<p><font color="#FF0000"><b>A commercial radio station</b></font></p>
<p>Assume that you have just acquired an FCC license to build and operate a 
new commercial radio station in a small town in west Texas.&nbsp; As is 
frequently the case in west Texas, your town is situated at the intersection of 
two highways.&nbsp; One highway runs northeast and southwest.&nbsp; The 
other highway runs northwest and southwest.&nbsp; The two highways are generally 
perpendicular to one another.&nbsp; Like many highways in west Texas, each of these highways is straight as an arrow with 
very few curves.</p>
<p><font color="#FF0000"><b>Where people live</b></font></p>
<p>Your town has a small business district at the intersection of the two 
highways.&nbsp; Beyond that, most of the people who live in your town <i>(and 
who will listen to your radio station)</i> live along the two highways.&nbsp; 
Thus most of the population lives in the directions of northeast, southwest, 
northwest, and southeast from the center of town.&nbsp; There are very few 
people living in the directions of north, south, east, and west.&nbsp; That real 
estate is mostly populated by cows and cotton fields.</p>
<p><font color="#FF0000"><b>A limit on the transmitting power</b></font></p>
<p>Your new FCC license places a limit on the amount of power that you will be 
allowed to transmit.&nbsp; You would like to use that available power to reach a 
many human listeners as possible.&nbsp; If you simply construct an omnidirectional transmitting 
antenna and start broadcasting, approximately half of the power 
that you transmit will be available mostly to cows and cotton plants.&nbsp; As a result, the amount of power, and hence the <i>reach</i> 
of the power that you transmit to human listeners will be less than you would 
like for it to be.</p>
<p><font color="#FF0000"><b>A directional transmitting antenna</b></font></p>
<p>While the FCC won't allow you to increase 
the amount of power that you transmit, they will allow you to control the 
directions in which you choose to transmit that power.&nbsp; You will probably hire an expert in 
the transmission of radio signals to design a directional transmitting antenna 
system, 
which will broadcast most of the available power in the directions where the 
people live.&nbsp; Ideally, the antenna system will transmit very little of the 
available power in the directions of the cows and the cotton fields.</p>
<p><font color="#FF0000"><b>The design of the antenna system</b></font></p>
<p>The antenna designer will have many tools at her disposal.&nbsp; Whether or not 
she uses wavenumber terminology, many of 
the calculations that she performs will depend on wavenumber concepts.&nbsp; She 
will be concerned about the reciprocal wavenumber <i>(or wavelength)</i> of the 
radio signals that will be broadcast.&nbsp; She will be concerned with the 
lengths of the active elements in the antenna system, and the distance between 
active elements if she chooses to use an array of active elements.</p>
<p><font color="#FF0000"><b>Basic concepts</b></font></p>
<p>I will leave the radio station scenario at this point and discuss some more 
basic concepts.&nbsp; I will return to the radio station scenario later.&nbsp; We 
will need to start with simpler things and work our way up to the radio station 
scenario.</p>
<p>Much of this discussion will be couched in terms of receiving signals rather 
than transmitting signals.&nbsp; <i>(For most people, receiving is 
easier to understand than transmitting.)</i>&nbsp; However, most of the conclusions 
that we reach regarding antenna systems used for receiving signals are also applicable to 
antenna systems used for transmitting signals.</p>
<p><font color="#FF0000"><b>A one-dimensional space</b></font></p>
<p>Just to get us started down the right path, we will temporarily constrain space 
to have only one dimension.&nbsp; We will discuss the propagation of waves along a 
taut wire, as well as the measurement of the waves propagating along that wire.</p>
<p>Assume that a wire is fastened at both ends, is fairly taut, and is suspended 
between two walls so that it is free to move up and down only.&nbsp; Assume 
that we attach two sensors to the wire, one meter apart, and that each of these sensors 
is capable of generating an electrical signal that is proportional to 
the vertical displacement of the wire at the point where the sensor is 
attached.&nbsp; If the wire goes up, the sensor generates a positive signal.&nbsp; 
If the wire goes down, the sensor generates a negative signal.</p>
<p><font color="#FF0000"><b>Standing waves</b></font></p>
<p>There are two ways that we can approach this analysis.&nbsp; If the wire is 
very long, we can think in terms of a deformation pulse that propagates along 
the wire passing by our sensors once and only once.&nbsp; This would fall into the 
category of transient analysis.</p>
<p>On the other hand, if the wire is shorter, we can think in terms of 
vibrating one end of the wire in such a way that a standing wave will 
develop on the wire.&nbsp; This is probably the easier of the two approaches to understand 
because you may have created standing waves on a rope as a child.</p>
<p><font color="#FF0000"><b>What does a standing wave look like?</b></font></p>
<p>Once a standing wave is set up on the wire, it will take on an appearance 
very similar to the sine wave shown in Figure 1.</p>
<p align="center"><img border="0" src="java1490a.gif" width="401" height="278"></p>
<p align="center">Figure 1 A stand wave on a wire</p>
<p>Figure 1 represents a snapshot taken at a single instant in time.&nbsp; Obviously the 
wire doesn't remain in the position shown in Figure 1 for very long.&nbsp; Rather a single 
point on the wire will move up and down with time with the overall appearance 
being as shown in Figure 1.&nbsp; The distance between any two positive peaks is what we 
would refer to as the <i>wavelength</i> of the standing wave.</p>
<p><font color="#FF0000"><b>Add the sensor output signals</b></font></p>
<p>Now consider what would happen if we were to electronically add the 
electrical outputs produced by the two sensors.&nbsp; The result would depend on the 
distance between the sensors relative to the wavelength of the standing wave.&nbsp; 
For example, if the two sensors were exactly one wavelength apart, the two 
sensors would move up and down in unison, and the sum of the two signals would be 
double the signal level produced by either sensor alone.&nbsp; The result would be 
the same as if the two sensors were located at the same place on the wire.</p>
<p><font color="#FF0000"><b>A one-half wavelength spacing</b></font></p>
<p>On the other hand, if the two sensors were exactly one-half wavelength apart, 
one would go be going up when the other is going down, and the electrical output 
from one would cancel the electrical output from the other.&nbsp; In 
space processing terminology, this would be referred to as a <i>null point.</i></p>
<p><font color="#FF0000"><b>Change the wavelength of the standing wave</b></font></p>
<p>Now consider what would happen if you were to leave the two sensors in the 
same locations as before and do something to the wire 
to change the wavelength of the standing wave.&nbsp; The output from the sum of the two sensors would 
range from zero to maximum as the wavelength relative to separation varies from 
one-half wavelength to one full wavelength.&nbsp; For a one-half wavelength 
separation, the output would be zero.&nbsp; For a one-wavelength separation, the 
output would be at its maximum.</p>
<p><font color="#FF0000"><b>A two element array</b></font></p>
<p>We could refer to our two sensors as a two element array, and we could refer 
to the output produced by the sum of the two sensors as the response of the 
array.&nbsp; We could plot the response versus wavelength.&nbsp; However, in the 
same sense that it is more common to plot the response of electrical filters 
versus frequency <i>(instead of period),</i> it is probably most common 
to plot the response of arrays versus wavenumber <i>(instead of wavelength).</i>&nbsp; 
Therefore, in this lesson, we will plot the response of the array versus wavenumber.</p>
<p><font color="#FF0000"><b>How can we compute the array response?</b></font></p>
<p>This is where Fourier transforms come into play.&nbsp; We could compute the 
response of our one-dimensional array for waves propagating along the length of 
the wire by treating the elements of the array as samples in space and performing a one-dimensional 
Fourier transform on the elements of 
the array.</p>
<p><font color="#FF0000"><b>A sampled space series</b></font></p>
<p>In this case, we would consider the array elements to constitute samples 
taken in space in the same way that we consider a sampled time series to 
constitute samples taken in time.&nbsp; In other words, the array elements 
constitute a sampled space series.&nbsp; The Fourier transform of a sampled time 
series is the frequency spectrum of the time series.&nbsp; The Fourier transform 
of a sampled space series is the wavenumber spectrum of the space series.</p>
<p><font color="#FF0000"><b>Three example wavenumber spectra</b></font></p>
<p>To set the stage for what we will be seeing later, Figure 2 depicts 
three different two element arrays with different spacing in the images across the top 
of the figure.&nbsp; 
The wavenumber response for each of the three arrays is shown immediately 
below the image of the array.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center"><img border="0" src="java1490b.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490d.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490f.jpg" width="132" height="58"></td>
	</tr>
	<tr>
		<td>
		<p align="center"><img border="0" src="java1490c.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490e.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490g.jpg" width="132" height="58"></td>
	</tr>

</table>

</div>

<p align="center">Figure 2</p>
<p><font color="#FF0000"><b>Plots of 3D surfaces</b></font></p>
<p>The images shown in Figure 2 were produced using the class named <b>ImgMod29</b>, 
which I explained earlier in the lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a>.&nbsp; You can refer back to that lesson for a detailed explanation of the 
display format.&nbsp; 
Briefly, however, each of the six individual images in Figure 2 is a plot of a 3D surface, 
with the elevation of the surface at any particular point being indicated by the 
color at that point based on the colors on the calibration scale below each plot.</p>
<blockquote>
	<p><i>(The calibration scale is the strip that changes color in a smooth 
	gradient from blue through green and yellow to red with black at the left 
	end and white at the right end.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Black, white, and the colors in between</b></font></p>
<p>The lowest elevation in the plot is colored black.&nbsp; Hence 
the backgrounds are black in the top three plots.&nbsp; The highest elevation is 
colored white.&nbsp; Hence, the array elements are white in the 
top three plots.</p>
<p>Between black and white, the elevation is given by the color scale below the 
plot with the lowest elevation on the left of the scale and the highest 
elevation on the right.&nbsp; Thus, a green elevation is about half way between 
the lowest and highest elevations.&nbsp; Blue elevations are near the low end.&nbsp; 
Red elevations are near the high end.&nbsp; Aqua and yellow elevations fall in 
between as shown by the calibration scale.</p>
<p><font color="#FF0000"><b>The maximum array output</b></font></p>
<p>All three wavenumber plots have a maximum response at the center, which is 
the zero wavenumber origin.&nbsp; In effect, this corresponds to infinite 
wavelength.&nbsp; If the wavelength is infinite, it doesn't matter what the 
separation between the elements is, they will all move up and down in unison and 
their electrical outputs will add constructively to produce a maximum output.</p>
<p><font color="#FF0000"><b>Response of the leftmost array</b></font></p>
<p>Now consider the leftmost pair of images where the two array elements are 
relatively close 
together.&nbsp; The wavenumber response of this array has a pair of null points 
about midway between the center and either end, as indicated by the blue and 
black colors.&nbsp; This is the wavenumber for which the element spacing is an exact 
multiple of one-half of the wavelength, causing the elements to move in equal but opposite directions in 
response to the wave motion.&nbsp; Thus, the output from one element cancels the 
output from the other element producing zero voltage in the sum.</p>
<p>This same pair of images shows high responses at either end as 
indicated by the red areas.&nbsp; This is the wavenumber for which the element 
spacing is an exact multiple of one wavelength.</p>
<p><font color="#FF0000"><b>The Nyquist folding wavenumber</b></font></p>
<p>If this were a frequency spectrum analysis, we would say that the end 
	points are at the Nyquist folding frequency, which is one-half of the 
	sampling frequency.&nbsp; Thus, we can say that in the wavenumber domain, 
	the end points on our plots are at the Nyquist 
	folding wavenumber, which is one-half the sampling wavenumber.</p>
<p>The wavenumber spectrum is periodic.&nbsp; The section of the wavenumber spectrum that we are 
	viewing represents one complete period of a periodic wavenumber spectrum 
	ranging from minus the folding wavenumber, through zero wavenumber to plus 
	the folding wavenumber.</p>
<blockquote>
	<p><i>(If you are already familiar with this sort 
	of thing, you may have figured out that the separation between our elements 
	in this example is twice the sampling distance that determines the location of the folding 
	wavenumber.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Estimating the array response from the colors</b></font></p>
<p>The leftmost array response shows a white area at the center.</p>
<blockquote>
	<p><i>(The white area is split by the vertical component of red axes drawn on the plot.&nbsp; 
	The color of the axes has nothing to do with elevations on the surface.&nbsp; 
	I simply decided to draw them in red to make them stand out.)</i></p>
</blockquote>
<p>This array response 
also shows the two black areas mentioned earlier.&nbsp; You can use the orange, yellow, green, and aqua locations on the calibration scale to estimate the 
response of the array to different wavenumber values between maximum and minimum.</p>
<p><font color="#FF0000"><b>Additional separation between array elements</b></font></p>
<p>Now consider the two images in the center of Figure 2.&nbsp; The elements for 
this array are separated more than the elements in the leftmost pair of images.&nbsp; 
Again, the wavenumber response for this array has a maximum value at the origin, which is 
at the 
center of the wavenumber response in the lower image.&nbsp; In addition, this array response has a 
high <i>(red)</i> response at five different wavenumber zones, whereas the 
array on the left 
had only three red zones.&nbsp; Similarly, this array has a low response <i>(black 
and blue)</i> at four different wavenumber zones whereas the array on the left 
has a low response at only two wavenumber zones.</p>
<p>Thus, changing the separation between the elements has a significant impact 
on the wavenumber response of the array.</p>
<p><font color="#FF0000"><b>Separate the elements even more</b></font></p>
<p>Finally, consider the pair of images on the right where the elements are even 
further apart.&nbsp; This array response has even more peaks and valleys than 
the other two.</p>
<p><font color="#FF0000"><b>A wavenumber filter</b></font></p>
<p>The sum of the outputs from an array of sensor elements represents a form of wavenumber filter
<i>(much as the correct combination of resistors, capacitors, and inductors 
represents a frequency filter).</i>&nbsp; If we need to pass 
signals having one wavenumber and to suppress signals having a different 
wavenumber, we may be able to adjust the separation between the elements so as 
to put a peak on the desirable wavenumber and to put a null point on the 
undesirable wavenumbers.</p>
<p><font color="#FF0000"><b>A two element array is fairly limiting</b></font></p>
<p>Of course, with only two elements, we don't have very many 
degrees of freedom to work with.&nbsp; We could exercise more control over our 
wavenumber filter if we had more elements.&nbsp; 
We could do even better if we had the ability to give each element a 
different weight <i>(including a negative weight)</i> when the signals from all the elements are added together.&nbsp; 
Finally, we could do even better still if we had the ability to insert a programmable time 
delay <i>(phase shift)</i> into the output from each of the elements before adding them together.</p>
<blockquote>
	<p><i>(The use of programmable time delays falls in the category of a space 
	series that is complex rather than being purely real.&nbsp; Thus, that topic is beyond 
	the scope of this lesson.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Let's apply some weights</b></font></p>
<p>Now let's modify our scenario and 
see what we can learn in the process.&nbsp; We are going to increase the size of the array 
from two to three elements.&nbsp; We are also going to assume that we can apply 
amplification, sign reversal, or both to the element output signals before adding 
those signals together.&nbsp; The results are shown in Figure 3.&nbsp; We will 
compare the results in Figure 3 with the results discussed earlier in Figure 2, 
so this may be a good time for you to open another copy of this lesson in a 
separate browser window if you haven't already done so.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center"><img border="0" src="java1490h.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490i.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490j.jpg" width="132" height="58"></td>
	</tr>
	<tr>
		<td>
		<p align="center"><img border="0" src="java1490k.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490l.jpg" width="132" height="58"></td>
		<td>
		<p align="center"><img border="0" src="java1490m.jpg" width="132" height="58"></td>
	</tr>

</table>

</div>

<p align="center">Figure3</p>
<p><font color="#FF0000"><b>The leftmost pair of images</b></font></p>
<p>The leftmost pair of images in Figure 3 is similar to the leftmost pair of 
images in Figure 2, except that we added a third element in Figure 3.</p>
<p>All three elements in Figure 3 are weighted equally prior to summation.&nbsp; 
The separation between the left and center elements is the same as in Figure 2.&nbsp; 
The separation between the center and right elements is the same as the 
separation between the left and center elements.</p>
<p><font color="#FF0000"><b>The wavenumber response</b></font></p>
<p>The most noticeable thing about the wavenumber response for this 
three element array is that the central peak is narrower than the central peak 
for the two element array at the left of Figure 2.&nbsp; In addition, the trough 
between the central peak and the peaks at the ends 
is deeper, broader, and probably flatter <i>(although the degree of 
flatness is hard to determine from this plotting format).</i></p>
<p><font color="#FF0000"><b>Could continue lengthening the array</b></font></p>
<p>Although I won't demonstrate it, I can tell you that if I were to continue adding 
elements in this manner to increase the length of the array, the central peak and the peaks at the folding 
wavenumbers would continue getting narrower, and the trough between the peaks would 
continue getting deeper and probably flatter.</p>
<p><font color="#FF0000"><b>A more selective wavenumber filter</b></font></p>
<p>In other words, when viewed as a wavenumber 
filter, a long array is a more selective wavenumber filter than a short array.&nbsp; 
By 
properly designing an array to act as a wavenumber filter, it is possible to 
cause that filter to be very selective.</p>
<p>When we use a properly designed array to 
produce a directional antenna, it is possible to produce a highly directional 
antenna <i>(and avoid wasting our valuable radio frequency (RF) energy by sending it to cows and 
cotton plants).</i>&nbsp; I will have more to say about cows and cotton plants 
later.</p>
<p><font color="#FF0000"><b>A weighted three element array</b></font></p>
<p>Continuing with our three element array scenario, let's take a look at the center 
pair of images in Figure 3 and compare them with the leftmost images in Figure 
3.</p>
<p>For this case, the array still contains three elements with the same 
spacing as before.&nbsp; However, the electrical output from the center element is 
amplified to make it twice as strong as the outputs from the other two elements 
before the three electrical signals are added together.</p>
<p>It is a little 
hard to tell what this does to the central peak in the wavenumber response, but it definitely changes the 
shape of the response in the trough between the peaks.&nbsp; Whether or not this 
would be a beneficial change would depend on the problem being addressed.</p>
<p><font color="#FF0000"><b>A three element array with negative weighting</b></font></p>
<p>Finally, take a look at the rightmost pair of images in Figure 3.&nbsp; Once 
again, the array contains three elements and the center element is weighted 
twice as heavily as the other two.&nbsp; In addition, the sign of the electrical 
signals from the two outer elements is inverted before the three are added together.</p>
<p><font color="#FF0000"><b>The wavenumber response</b></font></p>
<p>This has a major impact on the wavenumber response of the three element array.</p>
<p>There is no longer a peak at a wavenumber value of zero.&nbsp; Rather, there 
is now a null point at zero wavenumber as indicated by the black and blue colors 
at the center of the plot.&nbsp; 
There is now a peak on each side of zero <i>(as indicated by the white and red 
colors),</i> half way between zero and the folding wavenumber.</p>
<p><font color="#FF0000"><b>A reassessment of the leftmost and center 
images</b></font></p>
<p>Remember that I told you earlier that the wavenumber response that we are 
viewing represents one complete period of a periodic wavenumber response 
extending from minus the folding wavenumber to plus the folding wavenumber.</p>
<blockquote>
	<p><i>(With these three element arrays, the separation between the elements 
	is twice the assumed sampling grid in space.&nbsp; In other words, you could 
	view each of these arrays as a five element array with an element having a 
	weight of zero in between the center element and each of the outer 
	elements.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Two full peaks but at different locations</b></font></p>
<p>If you consider the peaks at the ends of the wavenumber response for the leftmost and 
center images in Figure 3 to each represent only half a peak <i>(with the other 
half being off the scale to the left and the right),</i> all three scenarios 
have two complete peaks in their wavenumber responses.</p>
<blockquote>
	<p><i>(You could think in terms of printing the wavenumber response on 
	a piece of paper, cutting it out, and taping the two ends together to form a 
	continuous ring.&nbsp; As you made a complete traversal of the ring, you 
	would encounter two peaks.)</i></p>
</blockquote>
<p>However, 
the locations of the two peaks for the rightmost array are at completely 
different wavenumber values than are the peaks for the other two arrays.&nbsp; 
The two peaks exhibited by the rightmost array are in the locations of the two 
nulls for the center array.&nbsp; Similarly, the null points for the rightmost 
array are in the same locations as the two peaks for the center array.</p>
<p><font color="#FF0000"><b>What can we learn from these scenarios?</b></font></p>
<p>We learn that we can have a significant impact on the wavenumber response of 
an array by increasing the number of elements in the array.&nbsp; We can also 
have a significant impact on the wavenumber response by applying weights, <i>
(including sign changes),</i> to the electrical signals produced by the array elements before adding 
them together.</p>
<p><font color="#FF0000"><b>Extending into two dimensions</b></font></p>
<p>Now let's complicate things a bit by extending our array analysis into two dimensions.&nbsp; 
Up to this point, we have assumed that our sensors were attached to a wire that 
was free to move up and down only.&nbsp; As such, waves impinging on the array 
were constrained to approach the array from one end or the other.&nbsp; In this 
case the wavenumber was completely determined by the wavelength of the 
wave.</p>
<blockquote>
	<p><i>(For our purposes, the wavelength is given by the ratio of propagation speed in meters per 
second to frequency in cycles per second.&nbsp; Canceling out the units leaves us 
with wavelength in meters per cycle.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Move the array to a table top</b></font></p>
<p>Let's move our array of sensors from the wire to a large sheet of metal on 
the top of a table.&nbsp; 
For the time being, we will still place the elements in a line with uniform spacing.&nbsp; However, we will 
now assume that a wave can impinge on the array from any direction along the 
surface of the sheet of metal.</p>
<blockquote>
	<p><i>(For simplicity, we will assume that there is some sort of insulation 
	between the sheet of metal and the table top to prevent 
	waves from impinging on the array from below.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does a wave look like in this scenario?</b></font></p>
<p>Imagine a 
piece of corrugated sheet metal or fiber glass.&nbsp; <i>(Material like this is 
sometimes used to build a roof on a patio.)</i>&nbsp; When you look at it from one end, it looks something like the sine wave in Figure 1.&nbsp; However, if 
you keep it at eye level and slowly turn it, the distance between the peaks will 
appear to become shorter and shorter until finally you don't see any peaks at 
all.&nbsp; What you see at that point is something that appears to have the same thickness 
from one end to the other.&nbsp; This is the view that one of our sensors sees 
as the wavefront of an impinging wave.</p>
<p><font color="#FF0000"><b>The angle of attack is important</b></font></p>
<p>We now have a much more complex situation.&nbsp; If the waves continue to 
impinge on the array from one end or the other, the situation will be exactly 
the same as when the sensors were on the wire.&nbsp; However, the <i>apparent</i> 
wavenumber or wavelength of a wave as seen by the array will depend on the 
angle of attack.</p>
<blockquote>
	<p><i>(There is now a difference between the actual wavelength or wavenumber 
	and the apparent wavelength or wavenumber as seen by the array.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Infinite wavelength</b></font></p>
<p>For example, if the wave impinges on the array from a 
broadside direction, all of the sensors will move up and down in unison 
regardless of their separation and regardless of the actual wavelength of the wave.&nbsp; For this case, the wave 
will <i>appear</i> to the array to have infinite wavelength or zero wavenumber.</p>
<blockquote>
	<p><i>(A linear array has no 
ability to filter on the basis of wavenumber for waves that impinge on the 
array from the broadside direction.&nbsp; All waves from that direction appear 
	to have zero wavenumber.&nbsp; This will lead us later to consider the use 
	of a two-dimensional 
array.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The 2D wavenumber response of a linear array</b></font></p>
<p>Figure 4 shows the two-dimensional wavenumber 
response for a five element linear array with equal weighting for all of the 
elements.&nbsp; The array is shown at the top.&nbsp; 
The wavenumber response of the array is shown at the bottom.</p>
<blockquote>
	<p><i>(In this 
case, I placed all five elements on adjacent points on the space sampling grid 
	with no spaces in between.&nbsp; This places them so close together that you can't visually 
separate them in the image.)</i></p>
</blockquote>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490n.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490o.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 4</p>
<p><font color="#FF0000"><b>The response for a constant wavenumber</b></font></p>
<p>If you were to draw a circle centered on the crosshairs <i>(axes)</i> in the center of the 
wavenumber response, the points on that circle would represent a fixed 
wavenumber for a 
wave arriving from any direction.&nbsp; The value of the response at any 
particular point on the circle would indicate the response of the array to a 
wave having that wavenumber from that direction.</p>
<p><font color="#FF0000"><b>Response versus direction</b></font></p>
<p>If the diameter of the circle is larger than the width of the red vertical 
band, and if you were to plot that response versus direction, you would see that the 
response is maximum for the two directions that are broadside to the array and the 
response tends to drop off as the direction approaches the end fire direction of 
the array.</p>
<p><font color="#FF0000"><b>Symmetry</b></font></p>
<p>You would also notice quite a lot of symmetry.&nbsp; For example, the maximum 
response occurs in two directions that are 180 degrees apart.&nbsp; In fact, if 
you pick any direction and a given wavenumber, the response is the same for that 
direction and for the direction that is 180 degrees around from that direction.</p>
<p><font color="#FF0000"><b>Not good for the radio transmitter</b></font></p>
<p>This wouldn't be a very good design for your radio station.&nbsp; If one of 
the broadside directions of the array faces northeast and the other faces 
southwest, then the people who live in the northwest and southeast directions 
wouldn't receive a very good signal from your transmitter.&nbsp; You need a 
design that maximizes the power in the four directions where the people live, 
and that minimizes the power in the other directions.&nbsp; To accomplish that, 
we will need a two-dimensional array in place of our one-dimensional linear 
array.</p>
<p><font color="#FF0000"><b>A two-dimensional array</b></font></p>
<p>We will achieve the desired array response by using an array having thirteen 
elements in the form of a cross with very specific weighting applied to each 
element prior to summation.&nbsp; The array and the wavenumber response of the 
array are shown in Figure 5.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490p.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490q.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 5</p>
<p><font color="#FF0000"><b>Computing the wavenumber response</b></font></p>
<p>The wavenumber response of the array <i>(shown at the bottom in Figure 5)</i> 
was produced by performing a 2D Fourier transform on the weighted array <i>
(shown at the top in Figure 5).</i></p>
<p>The center element in the array was weighted by -4.5 before summation.&nbsp;
<i>(The signal from this element was amplified by a factor of 4.5 and the sign 
of the signal was inverted prior to summation.)</i></p>
<p>The twelve remaining elements were weighted by a factor of 1.0 before 
summation.</p>
<p><font color="#FF0000"><b>A constant wave number</b></font></p>
<p>Regardless of direction, the wavelength or wavenumber of the RF energy 
transmitted by a commercial radio station is the same and it doesn't change over 
time, <i>(unless the frequency on which the station broadcasts changes)</i>.</p>
<p>Once again, we can determine the wavenumber response of the array for a given 
wavenumber from any direction by drawing a circle on the response plot, centered 
at the origin, with the radius of the circle equal to the specific wavenumber of 
interest.</p>
<p><font color="#FF0000"><b>Assume a wavenumber</b></font></p>
<p>Assume that the wavenumber of interest in our case is exactly equal to the 
distance from the origin to the white spot in the upper right quadrant of the 
wavenumber response plot.&nbsp; This white spot represents the maximum response 
of the array.</p>
<blockquote>
	<p><i>(If our computation had perfect accuracy, there would be a white spot 
	at the same location in all four quadrants.)</i></p>
</blockquote>
<p>Draw a circle centered on the origin having a radius that causes the circle 
to go through the white spot.</p>
<p><font color="#FF0000"><b>Now determine the response versus direction</b></font></p>
<p>The color corresponding to the response at any point on the circle represents 
the response of the array to that wavenumber for waves arriving from that 
direction <i>(or in the case of a transmitter, for waves being transmitted in that 
direction).</i>&nbsp; </p>
<p>The circle passes through yellow, red, and white <i>(indicating a high 
response)</i> in the general directions of northeast, southeast, southwest, and 
northwest.&nbsp; This means that a strong RF signal will be transmitted to the 
people living along the highways in those four directions.</p>
<p>The circle passes through green, aqua, and blue <i>(indicating a low 
response)</i> in the general directions of north, south, east, and west.&nbsp; 
This means that very little of the precious RF energy will be transmitted to the 
cotton plants and the cows that live in those directions.</p>
<p><font color="#FF0000"><b>A possible solution to the problem</b></font></p>
<p>Thus, an array of active transmitter elements arranged and weighted as shown 
at the top of Figure 5 might be a reasonable design solution for your radio 
station.&nbsp; <i>(However, I suspect that an experienced RF engineer would have 
a much more sophisticated solution.)</i></p>
<p>In any event, you have now seen one possible practical example of the use 
of a 2D Fourier transform.</p>
<p><font color="#FF0000"><b>Arrays are used in various applications</b></font></p>
<p>Although this example was admittedly somewhat contrived, it is not far 
fetched.&nbsp; Arrays similar to those that I have been discussing are 
widely used in the technology area of spatial signal processing.&nbsp; </p>
<p><font color="#FF0000"><b>Radio astronomy</b></font></p>
<p>Perhaps the application that is most familiar to the general public <i>(due 
to widespread publicity and a very popular movie)</i> is the
<a href="http://www.space.com/scienceastronomy/astronomy/seti_funding_000801.html">
Paul Allen radio telescope</a> used in the
<a href="http://www.setileague.org/array2k/iaa2001.htm">Search for 
Extraterrestrial Intelligence <i>(SETI)</i></a><i>.</i></p>
<p>In the past, much of this work has been done using a very large dish antenna 
known as the <a href="http://www.daviddarling.info/encyclopedia/A/Arecibor.html">
Arecibo Radio Telescope</a> in Puerto Rico.&nbsp; Efforts are now underway 
involving an alternative approach that uses a large
<a href="http://www.setileague.org/array2k/array2kb.jpg">array</a> of small 
dishes instead of one large dish.</p>
<p>By properly processing and then summing the outputs produced by the dishes in 
the array, 
the users will be able to steer the telescope and possibly to also eliminate 
strong sources of interference.</p>
<p><font color="#FF0000"><b>Seismology</b></font></p>
<p>Arrays of seismometers are used by U.S. government agencies to monitor for 
seismic signals produced by earthquakes in locations nearly halfway around the 
earth.</p>
<p>By applying complex, frequency dependent weighting factors to the seismometer 
outputs before summing them, the arrays can be tuned to provide a complex 
response in wavenumber space.&nbsp; For example, the arrays can be processed to 
form response beams looking in different directions with a beam width that is 
relatively constant across a wide band of interesting frequencies.&nbsp; In addition, 
null points in the wavenumber response can be created to suppress seismic noise 
that originates from specific points on the earth such as mines, rock quarries, 
and cities.</p>
<p>The design and analysis of such array systems use 2D <i>(and sometimes 3D)</i> 
Fourier transforms.&nbsp; Because the weights that are applied are produced by 
complex frequency filters, the transform programs that are used must treat both 
the space domain data and the wavenumber data as complex <i>(instead of being 
purely real as in the examples in this lesson).</i></p>
<p><font color="#FF0000"><b>Sonar</b></font></p>
<p>Probably ninety percent of all sonar systems currently installed on surface 
ships and submarines use arrays for steering and processing both active and 
passive sonar.&nbsp; In almost all cases, these are 3D arrays.&nbsp; Some of the 
arrays contain multiple sensors on the surface of a portion of a sphere.&nbsp; 
Some contain multiple sensors located along slats that are mounted on a frame 
much like the staves on a barrel.&nbsp; Some are located on the sides of the 
vessel.&nbsp; There are probably numerous other geometries in use as well.</p>
<p>A Fourier transform program used with these arrays would normally have to be 
a 3D Fourier transform program capable of transforming from complex space functions to 
complex wavenumber functions.</p>
<p><font color="#FF0000"><b>Radar</b></font></p>
<p>One of the reasons that sonar is typically processed using arrays has to do 
with the wavelength of the signals and the operating environment.&nbsp; It is 
usually not practical to physically move a sonar sensor large enough to do the 
job in order to cause it to look in different directions.&nbsp; Thus arrays of small 
sensors are used with the ability to steer beams electronically in order to look 
in different directions.</p>
<p>Because of the shorter wavelengths involved, typical radar sensors are usually small enough that they 
can be physically turned and tilted.&nbsp; Thus, it is not unusual to see radar 
sensors turning around and tilting up and down.&nbsp; Although I'm not personally aware of 
any applications that use arrays of radar sensors, my suspicion is that there 
probably are some being used in fixed air surveillance operations.</p>
<p><font color="#FF0000"><b>Petroleum exploration</b></font></p>
<p>A large percentage of petroleum exploration involves the insertion of a 
powerful surge of acoustic energy into the ground <i>(or into the ocean)</i> and 
listening for and recording the echo signals returned by the various layers of 
the earth.&nbsp; By moving across the earth and repeating this process, a
<a href="http://sepwww.stanford.edu/sep/prof/iei/mltp/paper_html/node5.html">profile</a> 
of the earth's layering can be produced.&nbsp; An experienced exploration 
geophysicist can examine the profiles and reach conclusions as to the likelihood 
that a particular stratum contains petroleum.</p>
<p>Exploration geophysicists have been using arrays of sensors for this purpose 
for at least the past 45 years according to my personal knowledge, and probably 
for many years before that.</p>
<p><font color="#FF0000"><b>Image processing in the wavenumber domain</b></font></p>
<p>While the examples described above are interesting, they are beyond the scope 
of anything that I can demonstrate online.&nbsp; However, there are several interesting applications using 2D 
Fourier transforms that I can demonstrate 
online.&nbsp; One of those applications is image processing.</p>
<p>Future lessons will show how to use 2D Fourier transforms for such purposes 
as softening images, sharpening images, doing edge detection on images, etc.&nbsp; 
For this application, it is satisfactory to use a 2D Fourier transform program 
that assumes that the space domain data is purely real.&nbsp; Therefore, the 
program that I will present and explain in Part 2 of this lesson will make that assumption.</p>
<p><font color="#FF0000"><b>Image processing in the space domain</b></font></p>
<p>The 2D Fourier transform will be used in future lessons to help explain how 
and why 2D image convolution behaves the way it does.&nbsp; A preview of that 
material is shown in Figure 6.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490r.jpg" width="133" height="176"></td>
		<td>
		<p align="center">
		<img border="0" src="java1490s.jpg" width="133" height="176"></td>
		<td>
		<p align="center">
		<img border="0" src="java1490t.jpg" width="133" height="175"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1490u.jpg" width="133" height="176"></td>
		<td>
		<p align="center">
		<img border="0" src="java1490v.jpg" width="133" height="176"></td>
		<td>
		<p align="center">
		<img border="0" src="java1490w.jpg" width="133" height="176"></td>
	</tr>

</table>

</div>

<p align="center">Figure 6</p>
<p><font color="#FF0000"><b>Convolution versus multiplication</b></font></p>
<p>Recall that convolution in the space domain is equivalent to multiplication 
in the wavenumber domain, and vice versa.</p>
<p><font color="#FF0000"><b>A simple space function and its wavenumber spectrum</b></font></p>
<p>The top left image in Figure 6 shows a simple 3D surface in space consisting 
of a raised square.&nbsp; The wavenumber spectrum of that surface is 
shown in the lower left image in Figure 6.&nbsp; Note that the spectrum has a 
peak at a wavenumber value of zero with low values at the higher wave numbers 
near the edges.&nbsp; The peak in the center is relatively narrow with respect 
to the folding wave number at the edges.</p>
<p><font color="#FF0000"><b>A 2D convolution operator and its spectral response</b></font></p>
<p>The image in the upper center of Figure 6 shows a typical 2D convolution 
operator consisting of a value of +8 in the center surrounded by eight 
coefficients each having a value of -1.</p>
<p>The wavenumber spectral response 
of that convolution operator is shown in the lower center.&nbsp; Note that it 
has peaks at the folding wavenumbers on all four sides with a low value in the 
center.</p>
<p>The deepest part of the trough in the center is relatively narrow 
with respect to the folding wave numbers at the edges.&nbsp; However, it is 
somewhat broader than the peak in the spectrum at the 
lower left.</p>
<p><font color="#FF0000"><b>The result of convolution</b></font></p>
<p>The image in the upper right shows the result of convolving the space domain 
surface in the upper left with the convolution operator in the upper center.&nbsp; 
This output space domain surface has a green square area in the center that is 
at the same level as the green background.&nbsp; In this case, green represents 
an elevation of 0, which is about midway between the lowest elevation <i>(black)</i> 
and the highest elevation <i>(white).</i></p>
<p><font color="#FF0000"><b>Positive and negative fences</b></font></p>
<p>Surrounding the green square is a yellow and white fence representing very 
high elevations.&nbsp; Surrounding that fence is a black and blue fence, 
representing very low elevations consisting of large negative values.</p>
<p>Thus, as you move from the outside to the inside of the square in the output 
surface, the 
elevation goes from a background level of zero, to a large negative value, 
followed immediately by a large positive value, followed by zero.</p>
<p><font color="#FF0000"><b>Edge detection</b></font></p>
<p>As you can see, this is one form of edge detection.&nbsp; The edges of the 
square in the input surface have been emphasized and the flat portion of the 
input surface has been deemphasized in the convolution output.</p>
<p><font color="#FF0000"><b>Wavenumber spectrum of the convolution output</b></font></p>
<p>The wavenumber spectrum of the output from the convolution operation is shown 
in the lower right.&nbsp; The spectrum indicates that this surface is 
made up mostly of wavenumber components having mid range to high values.</p>
<p>If you are familiar with digital signal processing, you will know that in 
order for a space <i>(or time)</i> function to contain very rapid changes in 
value <i>(such as the elevation changes at the fences described above)</i> the 
function 
must contain significant high wavenumber <i>(or frequency)</i> components.&nbsp; 
That appears to be the case here.</p>
<p>Although this spectrum was produced by convolution in the space domain 
followed by a 2D Fourier transform on the convolution output, you should be able to see that the 
shape of the spectrum on the bottom right approximates the product of the 
spectrum of the original surface on the bottom left and the spectral response of 
the convolution operator in the bottom center.</p>
<p>Thus, the same results could have been produced using multiplication in the 
wavenumber domain followed by an inverse Fourier transform to produce the space 
domain result.&nbsp; Convolution in the space domain is equivalent 
to multiplication in the wavenumber domain and vice versa.</p>
<p><b><font color="#FF0000">Hidden watermarks and trademarks</font></b></p>
<p>Another interesting application that I can demonstrate online is using 2D 
Fourier transforms to hide secret trademarks and watermarks in images.&nbsp; The 
purpose of a hidden trademark or watermark is for the owner of the image to be able to demonstrate that 
the image may have been 
used inappropriately by someone else.&nbsp; Once again, this application can be 
satisfied by treating the space domain data as purely real.&nbsp; I plan to 
demonstrate how this is done in a future lesson.</p>
<h2 align="center"><a name="Run_the_Program">Run the Programs</a></h2><p>
Although I did not discuss any Java programs in Part 1 of this lesson, I will 
provide and explain two different programs in Part 2 of this lesson.&nbsp; For 
those of you who may want to get a jump on that lesson, I have included those 
two programs in Listing 1 and Listing 2 below.&nbsp; I encourage you to copy, compile, and run 
those programs.&nbsp; Modify the programs and experiment with 
them in order to learn as much as you can about 2D Fourier transforms.</p>
<p>Create some different test cases and work with them until you understand why 
they produce the results that they do.</p>
<center>    
<h2> <a name="Summary"></a>Summary</h2></center>I began by explaining how the 
space domain and the wavenumber domain in two-dimensional analysis are analogous 
to the time domain and the frequency domain in one-dimensional analysis.<p>Then 
I introduced you to some practical examples showing how 2D Fourier transforms 
and wavenumber spectra can be useful in solving engineering problems involving 
antenna arrays.</p><h2 align="center"><a name="Whats Next">What's Next?</a></h2><p>
In Part 2 of this lesson, I will provide and explain a Java class that can be 
used to perform forward and inverse 2D Fourier transforms, and can also be used 
to shift the wavenumber origin from the upper left to the center for a more 
pleasing plot of the wavenumber spectrum.</p>
<p>In addition, I will provide and explain a program that is used to:</p>
<ul>
	<li>Test the forward and inverse 2D Fourier transforms to confirm that the 
	code is correct and that the transformations behave as they should</li>
	<li>Produce wavenumber spectra for simple surfaces to help the student gain 
	a feel for the relationship that exists between the space domain and the 
	wavenumber domain</li>
</ul>
<h2 align="center"><a name="Complete_Program_Listing">Complete Program Listings</a></h2><p>
Preview listings of the 
classes that I will present and explain in Part 2 of this lesson are provided in 
Listing 1 and Listing 2 
below.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
<tbody><tr><td><pre>
/*File ImgMod30.java.java
Copyright 2005, R.G.Baldwin

The purpose of this program is to provide 2D
Fourier Transform capability to be used for image
processing and other purposes.&nbsp; The class
provides three static methods:

xform2D: Performs a forward 2D Fourier transform
 on a surface described by a 2D array of double
&nbsp;values in the space domain to produce a spectrum
 in the wavenumber domain.&nbsp; The method returns
 the real part, the imaginary part, and the
 amplitude spectrum, each in its own 2D array of
 double values.

inverseXform2D:&nbsp; Performs an inverse 2D Fourier
 transform from the wavenumber domain into the
 space domain using the real and imaginary parts
 of the wavenumber spectrum as input.&nbsp; Returns
 the surface in the space domain in a 2D array of
 double values.

shiftOrigin:&nbsp; The wavenumber spectrum produced
 by xform2D has its origin in the upper left
 corner with the Nyquist folding wave numbers
 near the center.&nbsp; This is not a very suitable
 format for visual analysis.&nbsp; This method
 rearranges the data to place the origin at the
 center with the Nyquist folding wave numbers
 along the edges.

Tested using J2SE 5.0 and WinXP
************************************************/
import static java.lang.Math.*;

class ImgMod30{
&nbsp;
&nbsp; //This method computes a forward 2D Fourier
&nbsp; // transform from the space domain into the
&nbsp; // wavenumber domain.&nbsp; The number of points
&nbsp; // produced for the wavenumber domain matches
&nbsp; // the number of points received for the space
&nbsp; // domain in both dimensions.&nbsp; Note that the
&nbsp; // input data must be purely real.&nbsp; In other
&nbsp; // words, the program assumes that there are
&nbsp; // no imaginary values in the space domain.
&nbsp; // Therefore, it is not a general-purpose 2D
&nbsp; // complex-to-complex transform.
&nbsp; static void xform2D(double[][] inputData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] realOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imagOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] amplitudeOut){

&nbsp;&nbsp;&nbsp; int height = inputData.length;
&nbsp;&nbsp;&nbsp; int width = inputData[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("height = " + height);
&nbsp;&nbsp;&nbsp; System.out.println("width = " + width);

&nbsp;&nbsp;&nbsp; //Two outer loops iterate on output data.
&nbsp;&nbsp;&nbsp; for(int yWave = 0;yWave &lt; height;yWave++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xWave = 0;xWave &lt; width;xWave++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Two inner loops iterate on input data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ySpace = 0;ySpace &lt; height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ySpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xSpace = 0;xSpace &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xSpace++){
//Compute real, imag, and ampltude. Note that it
// was necessary to sacrifice indentation to
// force&nbsp; these very long equations to be
// compatible with this narrow publication format
// and still be somewhat readable.
realOut[yWave][xWave] +=
&nbsp;(inputData[ySpace][xSpace]*cos(2*PI*((1.0*
 xWave*xSpace/width)+(1.0*yWave*ySpace/height))))
 /sqrt(width*height);

imagOut[yWave][xWave ] -=
&nbsp;(inputData[ySpace][xSpace]*sin(2*PI*((1.0*xWave*
&nbsp; xSpace/width) + (1.0*yWave*ySpace/height))))
&nbsp; /sqrt(width*height);
&nbsp;
amplitudeOut[yWave][xWave] =
 sqrt(
&nbsp; realOut[yWave][xWave] * realOut[yWave][xWave] +
&nbsp; imagOut[yWave][xWave] * imagOut[yWave][xWave]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xSpace loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ySpace loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xWave loop
&nbsp;&nbsp;&nbsp; }//end yWave loop
&nbsp; }//end xform2D method
&nbsp; //-------------------------------------------//
&nbsp;&nbsp;&nbsp;
&nbsp; //This method computes an inverse 2D Fourier
&nbsp; // transform from the wavenumber domain into
&nbsp; // the space domain.&nbsp; The number of points
&nbsp; // produced for the space domain matches
&nbsp; // the number of points received for the wave-
&nbsp; // number domain in both dimensions.&nbsp; Note that
&nbsp; // this method assumes that the inverse
&nbsp; // transform will produce purely real values in
&nbsp; // the space domain.&nbsp; Therefore, in the
&nbsp; // interest of computational efficiency, it
&nbsp; // does not compute the imaginary output
&nbsp; // values.&nbsp; Therefore, it is not a general
&nbsp; // purpose 2D complex-to-complex transform. For
&nbsp; // correct results, the input complex data must
&nbsp; // match that obtained by performing a forward
&nbsp; // transform on purely real data in the space
&nbsp; // domain.

&nbsp; static void inverseXform2D(double[][] real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] dataOut){

&nbsp;&nbsp;&nbsp; int height = real.length;
&nbsp;&nbsp;&nbsp; int width = real[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("height = " + height);
&nbsp;&nbsp;&nbsp; System.out.println("width = " + width);

&nbsp;&nbsp;&nbsp; //Two outer loops iterate on output data.
&nbsp;&nbsp;&nbsp; for(int ySpace = 0;ySpace &lt; height;ySpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xSpace = 0;xSpace &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xSpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Two inner loops iterate on input data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int yWave = 0;yWave &lt; height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yWave++){

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xWave = 0;xWave &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xWave++){
//Compute real output data. Note that it was
// necessary to sacrifice indentation to force
// this very long equation to be compatible with
// this narrow publication format and still be
// somewhat readable.
dataOut[ySpace][xSpace] +=
&nbsp;(real[yWave][xWave]*cos(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))) -
&nbsp;imag[yWave][xWave]*sin(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))))
 /sqrt(width*height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xWave loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end yWave loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xSpace loop
&nbsp;&nbsp;&nbsp; }//end ySpace loop
&nbsp; }//end inverseXform2D method
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //Method to shift the wavenumber origin and
&nbsp; // place it at the center for a more visually
&nbsp; // pleasing display.&nbsp; Must be applied
&nbsp; // separately to the real part, the imaginary
&nbsp; // part, and the amplitude spectrum for a wave-
&nbsp; // number spectrum.
&nbsp; static double[][] shiftOrigin(double[][] data){
&nbsp;&nbsp;&nbsp; int numberOfRows = data.length;
&nbsp;&nbsp;&nbsp; int numberOfCols = data[0].length;
&nbsp;&nbsp;&nbsp; int newRows;
&nbsp;&nbsp;&nbsp; int newCols;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] output =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[numberOfRows][numberOfCols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Must treat the data differently when the
&nbsp;&nbsp;&nbsp; // dimension is odd than when it is even.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(numberOfRows%2 != 0){//odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRows = numberOfRows +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numberOfRows + 1)/2;
&nbsp;&nbsp;&nbsp; }else{//even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRows = numberOfRows + numberOfRows/2;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(numberOfCols%2 != 0){//odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newCols = numberOfCols +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numberOfCols + 1)/2;
&nbsp;&nbsp;&nbsp; }else{//even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newCols = numberOfCols + numberOfCols/2;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a temporary working array.
&nbsp;&nbsp;&nbsp; double[][] temp =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[newRows][newCols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Copy input data into the working array.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] = data[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Do the horizontal shift first
&nbsp;&nbsp;&nbsp; if(numberOfCols%2 != 0){//shift for odd

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide leftmost (numberOfCols+1)/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the right by numberOfCols columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; (numberOfCols+1)/2;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back to the left by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (numberOfCols+1)/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col+(numberOfCols + 1)/2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else{//shift for even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide leftmost (numberOfCols/2) columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the right by numberOfCols columns.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols/2;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back to the left by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // numberOfCols/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols/2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; //Now do the vertical shift
&nbsp;&nbsp;&nbsp; if(numberOfRows%2 != 0){//shift for odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide topmost (numberOfRows+1)/2 rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // down by numberOfRows rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; (numberOfRows+1)/2;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back up by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (numberOfRows+1)/2 rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row+(numberOfRows + 1)/2][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else{//shift for even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide topmost (numberOfRows/2) rows down
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by numberOfRows rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows/2;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back up by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // numberOfRows/2 rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows/2][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Shifting of the origin is complete.&nbsp; Copy
&nbsp;&nbsp;&nbsp; // the rearranged data from temp to output
&nbsp;&nbsp;&nbsp; // array.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col] = temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//row loop

&nbsp;&nbsp;&nbsp; return output;
&nbsp; }//end shiftOrigin method

}//end class ImgMod30

<b>Listing 1</b></pre></td></tr></tbody></table>
<p>&nbsp;</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
<tbody><tr><td><pre>
/*File ImgMod31.java.java
Copyright 2005, R.G.Baldwin

The purpose of this program is to exercise and
test the 2D Fourier Transform methods and the
axis shifting method provided by the class named
ImgMod30.

The main method in this class reads a command-
line parameter and uses it to select a specific
case involving a particular kind of input data
in the space domain.&nbsp; The program then performs
a 2D Fourier transform on that data followed by
an inverse 2D Fourier transform.

There are 14 cases built into the program with
case numbers ranging from 0 to 13 inclusive.
Each of the cases is designed such that the
results should be known in advance by a person
familiar with 2D Fourier analysis and the wave-
number domain.&nbsp; The cases are also designed to
illustrate the impact of various space-domain
characteristics on the wave-number spectrum.
This information will be useful later when
analyzing the results of performing 2D
transforms on photographic images and other
images as well.

Each time the program is run, it produces a stack
of six output images in the upper left corner of
the screen.&nbsp; The type of each image is listed
below.&nbsp; This list is in top-to-bottom order.&nbsp; To
view the images further down in the stack, you
must&nbsp; physically move those on top to get them
out of the way.

The top-to-bottom order of the output images is
as follows:

1. Space-domain output of inverse Fourier
transform.&nbsp; Compare with original input in 6
below.
2. Amplitude spectrum in wave-number domain with
shifted origin.&nbsp; Compare with 5 below.
3. Imaginary wave-number spectrum with shifted
origin.
4. Real wave-number spectrum with shifted
origin.
5. Amplitude spectrum in wave-number domain
without shifted origin.&nbsp; Compare with 2 above.
6. Space-domain input data.&nbsp; Compare with 1
above.

In addition, the program produces some numeric
output on the command-line screen that may be
useful in confirming the validity of the inverse
transform.&nbsp; The following is an example:

height = 41
width = 41
height = 41
width = 41
2.0 1.9999999999999916
0.5000000000000002 0.49999999999999845
0.49999999999999956 0.4999999999999923
1.7071067811865475 1.7071067811865526
0.2071067811865478 0.20710678118654233
0.20710678118654713 0.20710678118655435
1.0 1.0000000000000064
-0.4999999999999997 -0.49999999999999484
-0.5000000000000003 -0.4999999999999965

The first two lines above indicate the size of
the spatial surface for the forward transform.
The second two lines indicate the size of the
wave-number surface for the inverse transform.

The remaining nine lines indicate something
about the quality of the inverse transform in
terms of its ability to replicate the original
spatial surface.&nbsp; These lines also indicate
something about the correctness or lack thereof
of the overall scaling from original input to
final output.&nbsp; Each line contains a pair of
values.&nbsp; The first value is from the original
spatial surface.&nbsp; The second value is from the
spatial surface produced by performing an inverse
transform on the wave-number spectrum.&nbsp; The two
values in each pair of values should match.&nbsp; If
they match, this indicates the probability of a
valid result.&nbsp; Note however that this is
a very small sampling of the values that make
up the original and replicated spatial data and
problems could arise in areas that are not
included in this small sample.&nbsp; The match is very
good in the example shown above.&nbsp; This example
is from Case #12.

Usage: java ImgMod31 CaseNumber DisplayType
CaseNumber from 0 to 13 inclusive.

If a case number is not provided, Case #2 will be
run by default.&nbsp; If a display type is not
provided, display type 1 will be used by default.

A description of each case is provided by the
comments in this program.

See ImgMod29 for a definition of DisplayType,
which can have a value of 0, 1, or 2.

You can terminate the program by clicking on the
close button on any of the display frames
produced by the program.

Tested using J2SE 5.0 and WinXP
************************************************/
import static java.lang.Math.*;

class ImgMod31{
&nbsp;
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Get input parameters to select the case to
&nbsp;&nbsp;&nbsp; // be run and the displayType.&nbsp; See ImgMod29
&nbsp;&nbsp;&nbsp; // for a description of displayType.&nbsp; Use
&nbsp;&nbsp;&nbsp; // default case and displayType if the user
&nbsp;&nbsp;&nbsp; // fails to provide that information.
&nbsp;&nbsp;&nbsp; // If the user provides a non-numeric input
&nbsp;&nbsp;&nbsp; // parameter, an exception will be thrown.
&nbsp;&nbsp;&nbsp; int switchCase = 2;//default
&nbsp;&nbsp;&nbsp; int displayType = 1;//default
&nbsp;&nbsp;&nbsp; if(args.length == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switchCase = Integer.parseInt(args[0]);
&nbsp;&nbsp;&nbsp; }else if(args.length == 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switchCase = Integer.parseInt(args[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType = Integer.parseInt(args[1]);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Usage: java ImgMod31 "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "CaseNumber DisplayType");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CaseNumber from 0 to 13 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DisplayType from 0 to 2 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Running case "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + switchCase + " by default.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Running DisplayType "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + displayType + " by default.");
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create the array of test data.
&nbsp;&nbsp;&nbsp; int rows = 41;
&nbsp;&nbsp;&nbsp; int cols = 41;

&nbsp;&nbsp;&nbsp; //Get a test surface in the space domain.
&nbsp;&nbsp;&nbsp; double[][] spatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpatialData(switchCase,rows,cols);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the spatial data.&nbsp; Don't display
&nbsp;&nbsp;&nbsp; // the axes.
&nbsp;&nbsp;&nbsp; new ImgMod29(spatialData,3,false,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);

&nbsp;&nbsp;&nbsp; //Perform the forward transform from the
&nbsp;&nbsp;&nbsp; // space domain into the wave-number domain.
&nbsp;&nbsp;&nbsp; // First prepare some array objects to
&nbsp;&nbsp;&nbsp; // store the results.
&nbsp;&nbsp;&nbsp; double[][] realSpect = //Real part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; double[][] imagSpect = //Imaginary part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; double[][] amplitudeSpect = //Amplitude
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; //Now perform the transform
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(spatialData,realSpect,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagSpect,amplitudeSpect);
&nbsp;
&nbsp;&nbsp;&nbsp; //Display the raw amplitude spectrum without
&nbsp;&nbsp;&nbsp; // shifting the origin first.&nbsp; Display the
&nbsp;&nbsp;&nbsp; // axes.
&nbsp;&nbsp;&nbsp; new ImgMod29(amplitudeSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);

&nbsp;&nbsp;&nbsp; //At this point, the wave-number spectrum is
&nbsp;&nbsp;&nbsp; // not in a format that is good for viewing.
&nbsp;&nbsp;&nbsp; // In particular, the origin is at the upper
&nbsp;&nbsp;&nbsp; // left corner.&nbsp; The horizontal Nyquist
&nbsp;&nbsp;&nbsp; // folding&nbsp; wave-number is near the
&nbsp;&nbsp;&nbsp; // horizontal center of the plot.&nbsp; The
&nbsp;&nbsp;&nbsp; // vertical Nyquist folding wave number is
&nbsp;&nbsp;&nbsp; // near the vertical center of the plot.&nbsp; It
&nbsp;&nbsp;&nbsp; // is much easier for most people to
&nbsp;&nbsp;&nbsp; // understand what is going on when the
&nbsp;&nbsp;&nbsp; // wave-number origin is shifted to the
&nbsp;&nbsp;&nbsp; // center of the plot with the Nyquist
&nbsp;&nbsp;&nbsp; // folding wave numbers at the edges of the
&nbsp;&nbsp;&nbsp; // plot.&nbsp; The method named shiftOrigin can be
&nbsp;&nbsp;&nbsp; // used to rearrange the data and to shift
&nbsp;&nbsp;&nbsp; // the orgin in that manner.

&nbsp;&nbsp;&nbsp; //Shift the origin and display the real part
&nbsp;&nbsp;&nbsp; // of the spectrum, the imaginary part of the
&nbsp;&nbsp;&nbsp; // spectrum, and the amplitude of the
&nbsp;&nbsp;&nbsp; // spectrum.&nbsp; Display the axes in all three
&nbsp;&nbsp;&nbsp; // cases.
&nbsp;&nbsp;&nbsp; double[][] shiftedRealSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(realSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedRealSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] shiftedImagSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(imagSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedImagSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amplitudeSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now test the inverse transform by
&nbsp;&nbsp;&nbsp; // performing an inverse transform on the
&nbsp;&nbsp;&nbsp; // real and imaginary parts produced earlier
&nbsp;&nbsp;&nbsp; // by the forward transform.
&nbsp;&nbsp;&nbsp; //Begin by preparing an array object to store
&nbsp;&nbsp;&nbsp; // the results.
&nbsp;&nbsp;&nbsp; double[][] recoveredSpatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; //Now perform the inverse transform.
&nbsp;&nbsp;&nbsp; ImgMod30.inverseXform2D(realSpect,imagSpect,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recoveredSpatialData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the output from the inverse
&nbsp;&nbsp;&nbsp; // transform.&nbsp; It should compare favorably
&nbsp;&nbsp;&nbsp; // with the original spatial surface.
&nbsp;&nbsp;&nbsp; new ImgMod29(recoveredSpatialData,3,false,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the following code to confirm correct
&nbsp;&nbsp;&nbsp; // scaling. If the scaling is correct, the
&nbsp;&nbsp;&nbsp; // two values in each pair of values should
&nbsp;&nbsp;&nbsp; // match.&nbsp; Note that this is a very small
&nbsp;&nbsp;&nbsp; // subset of the total set of values that
&nbsp;&nbsp;&nbsp; // make up the original and recovered
&nbsp;&nbsp;&nbsp; // spatial data.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; 3;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; 3;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] + " " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recoveredSpatialData[row][col] + " ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col
&nbsp;&nbsp;&nbsp; }//row
&nbsp; }//end main
&nbsp; //===========================================//
&nbsp;
&nbsp; //This method constructs and returns a 3D
&nbsp; // surface in a 2D array of type double
&nbsp; // according to the identification of a
&nbsp; // specific case received as an input
&nbsp; // parameter.&nbsp; There are 14 possible cases.&nbsp; A
&nbsp; // description of each case is provided in the
&nbsp; // comments.&nbsp; The other two input parameters
&nbsp; // specify the size of the surface in units of
&nbsp; // rows and columns.
&nbsp; private static double[][] getSpatialData(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int switchCase,int rows,int cols){
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create an array to hold the data.&nbsp; All
&nbsp;&nbsp;&nbsp; // elements are initialized to a value of
&nbsp;&nbsp;&nbsp; // zero.
&nbsp;&nbsp;&nbsp; double[][] spatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use a switch statement to select and
&nbsp;&nbsp;&nbsp; // create a specified case.
&nbsp;&nbsp;&nbsp; switch(switchCase){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a single non-zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point at the origin in the space
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // domain.&nbsp; The origin is at the upper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // left corner.&nbsp; In signal processing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // terminology, this point can be viewed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as an impulse in space.&nbsp; This produces
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a flat spectrum in wave-number space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a single non-zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point near but not at the origin in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.&nbsp; This produces a flat spectrum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in wave-number space as in case 0.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // However, the real and imaginary parts
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the transform are different from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // case 0 and the result is subject to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // arithmetic accuracy issues.&nbsp; The
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plotted flat spectrum doesn't look
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // very good because the color switches
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // back and forth between three values
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that are very close to together.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is the result of the display program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // normalizing the surface values based
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the maximum and minimum values,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which in this case are very close
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // together.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a box on the diagonal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // near the origin. This produces a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sin(x)/x shape to the spectrum with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // its peak at the origin in wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = 1;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][4] = 1;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a box at the top near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the origin.&nbsp; This produces the same
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude spectrum as case 2. However,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the real and imaginary parts, (or the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // phase) is different from case 2 due to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the difference in location of the box
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to the origin in space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a short line along the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // diagonal from upper left to lower
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // right. This results in a spectrum with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a sin(x)/x shape along that axis and a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constant along the axis that is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perpendicular to that axis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][6] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[7][7] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a short line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perpendicular to the diagonal from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // upper left to lower right.&nbsp; The
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectral result is shifted 90 degrees
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to that shown for case 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // where the line was along the diagonal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In addition, the line is shorter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resulting in wider lobes in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws horizontal lines,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // vertical lines, and lines on both
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // diagonals.&nbsp; The weights of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // individual points is such that the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // average of all the weights is 0.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The weight at the point where the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lines intersect is also 0.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produces a spectrum that is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical across the axes at 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 45, and 90 degrees.&nbsp; The value of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the spectrum at the origin is zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with major peaks at the folding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave-numbers on the 45-degree axes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In addition, there are minor peaks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at various other points as well.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][6] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][0] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][2] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][4] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][6] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][1] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][5] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][6] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][3] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][3] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a zero-frequency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sinusoid (DC) on the surface with an
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // infinite number of samples per cycle.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This causes a single peak to appear in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the spectrum at the wave-number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin.&nbsp; This origin is the upper left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // corner for the raw spectrum, and is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at the center cross hairs after the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin has been shifted to the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // center for better viewing.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 8:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // along the horizontal axis with one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sample per cycle. This function is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // under-sampled by a factor of 2.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This produces a single peak in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum at the wave number origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The result is the same as if the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sinusoidal surface had zero frequency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as in case 7..
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 9:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 2 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle.&nbsp; This is the Nyquist folding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave number.&nbsp; This causes a single
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // peak to appear in the spectrum at the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // negative folding wave number on the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // horizontal axis.&nbsp; A peak would also
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // appear at the positive folding wave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number if it were visible, but it is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // one unit outside the boundary of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plot.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 10:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the vertical axis with 2 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle.&nbsp; Again, this is the Nyquist
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // folding wave number but the sinusoid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // appears along a different axis.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // causes a single peak to appear in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum at the negative folding wave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number on the vertical axis.&nbsp; A peak
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // would also appear at the positive
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // folding wave number if it were
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // visible, but it is one unit outside
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the boundary of the plot.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*row/2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 11:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 8 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle. You might think of this surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as resembling a sheet of corrugated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // roofing material.&nbsp; This produces
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical peaks on the horizontal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // axis on either side of the wave-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/8);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 12:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 3 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle plus a sinusoidal surface on the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // vertical axis with 8 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle. This produces symmetrical peaks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the horizontal and vertical axes on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all four sides of the wave number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*row/8) + cos(2*PI*col/3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 13:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // an angle of approximately 45 degrees
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to the horizontal.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produces a pair of peaks in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave-number spectrum that are
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical about the origin at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // approximately 45 degrees relative to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double phase = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2.0*PI*col/8 - phase);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Increase phase for next row
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phase += .8;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Case must be " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "between 0 and 13 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Terminating program.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end&nbsp; switch statement
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return spatialData;
&nbsp; }//end getSpatialData
}//end class ImgMod31

<b>Listing 2</b></pre></td></tr></tbody></table><p>&nbsp;</p>
</p>

     
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4><a name="About_the_author">About the author</a></h4><b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.    
<p>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine. </p>
<p>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics. </p>
<p>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems. </p>
</i>
<p><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a>
</p>
<p><b>Keywords</b><br>
Java space time wavenumber frequency domain two-dimensional one-dimensional 2D 
Fourier transform spectra antenna array complex spectral DSP transmit wavelength 
surface Nyquist folding seismology radio astronomy sonar radar </p>
<p>-end- </p>
</body>
</html>
