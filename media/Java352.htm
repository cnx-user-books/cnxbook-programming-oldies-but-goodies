<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Java Programming by Richard G Baldwin</title>
</head>
<body bgcolor="#FEFFF0" link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<font size="3" face="arial">
<h2 align="center"><font size="+1" face="Arial, Helvetica"><b>Adding Animated 
Movement to Your Java Application</b></font></h2>
<i>Learn how to add animated movement into your program where multiple objects 
chase a lead object as it moves randomly in a given environment.</i><p><b>Published:</b>&nbsp; 
February 24, 2009<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 352</p>
<ul>
	<li><a href="#Preface">Preface</a></li>

	<ul>
		<li><a href="#General">General</a></li>
		<li><a href="#The_World_class">The World class</a></li>
		<li><a href="#Viewing_tip">Viewing tip</a><ul>
			<li><a href="#Figures">Figures</a></li>
			<li><a href="#Listings">Listings</a></li>
		</ul></li>
		<li><a href="#Supplementary_material">Supplementary material</a></li>
	</ul>
	<li><a href="#General%20Background%20Information">General
	background information</a><ul>
	<li><a href="#A_multimedia_class_library">A multimedia class library</a></li>
	<li><a href="#Software_installation_and_testing">Software installation and 
	testing</a></li>
</ul>
	</li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#Discussion%20and%20Sample%20Programs">Discussion and
	sample code</a><ul>
	<li><a href="#The_World_Class_2">The World class</a></li>
	<li><a href="#Sample_program_named_TurtleWorld01">Sample program named 
	TurtleWorld01</a></li>
	<li><a href="#The_remainder_of_the_World_class">The remainder of the World 
	class</a></li>
</ul>
	</li>
	<li><a href="#Run%20the%20program">Run the programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats%20Next">What's next?</a></li>
	<li><a href="#Resources">Resources</a></li>
	<li><a href="#Complete%20Program%20Listings">Complete program
	listings</a></li>
	<li><a href="#Copyright">Copyright</a></li>
	<li><a href="#About_the_author">About the author</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<h3> <a name="General">General</a></h3>
<p>This lesson is the next in a series <i>(see <a href="#Resources">Resources</a>)</i> 
designed to teach you how to write Java programs to do things like:</p>
<ul>
	<li>Remove <i>redeye</i> from a photographic image.</li>
	<li>Distort the human voice.</li>
	<li>Display one image inside another image.</li>
	<li>Do edge detection, blurring, and other filtering operations on images.</li>
	<li>Insert animated cartoon characters into videos of live humans.</li>
</ul>
<p>If you have ever wondered how to do these things, you've come to the right 
place.</p>
<h3><a name="The_World_class">The World class</a></h3>
<p>If you have studied the earlier lessons in 
this series <i>(see <a href="#Resources">Resources</a>)</i>, you have learned all about the <b>Turtle</b> class, its superclass named <b>
SimpleTurtle</b>, and the classes from which a turtle's contained objects are 
instantiated <i>(<b>Pen</b> and <b>PathSegment</b>)</i>.&nbsp; You have 
learned how to instantiate new <b>Turtle</b> objects, placing them in either a
<b>World</b> object or a <b>Picture</b> object.&nbsp; You have learned how to 
manipulate the <b>Turtle</b> objects once you place them in their environment.&nbsp; 
The time has come for you to learn about the environment in which a turtle lives.&nbsp; 
You will learn about the <b>World</b> class in this lesson.&nbsp; You will learn 
about the <b>Picture</b> class in a future lesson.</p>
<h3> <a name="Viewing_tip">Viewing tip</a></h3>
<p> I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the figures 
and listings while you are reading about them.</p>
<h4> <a name="Figures">Figures</a></h4>
<ul>
	<li><a href="#Figure_1">Figure 1</a>. Screen output from program named 
	TurtleWorld01. </li>
</ul>
<h4> <a name="Listings">Listings</a></h4>
<ul>
	<li><a href="#Listing_1">Listing 1</a>. Background color for World class 
	code fragments. </li>
	<li><a href="#Listing_2">Listing 2</a>. Background color for sample program 
	code fragments.</li>
	<li><a href="#Listing_3">Listing 3</a>. Beginning of the program named 
	TurtleWorld01. </li>
	<li><a href="#Listing_4">Listing 4</a>. Beginning of the class named Runner. </li>
	<li><a href="#Listing_5">Listing 5</a>. One of the overloaded constructors 
	for the World class. </li>
	<li><a href="#Listing_6">Listing 6</a>. The initWorld method of the World 
	class.</li>
	<li><a href="#Listing_7">Listing 7</a>. Get a reference to the list of 
	turtles. </li>
	<li><a href="#Listing_8">Listing 8</a>. The getTurtleList method of the 
	World class. </li>
	<li><a href="#Listing_9">Listing 9</a>. Beginning of the run method of the 
	Runner class. </li>
	<li><a href="#Listing_10">Listing 10</a>. The setPicture method of the World 
	class. </li>
	<li><a href="#Listing_11">Listing 11</a>. Instantiate eight Turtle objects. </li>
	<li><a href="#Listing_12">Listing 12</a>. The addModel method of the World 
	class. </li>
	<li><a href="#Listing_13">Listing 13</a>. Perform some housekeeping chores. </li>
	<li><a href="#Listing_14">Listing 14</a>. Beginning of the animation loop in 
	TurtleWorld01. </li>
	<li><a href="#Listing_15">Listing 15</a>. Process each turtle during each 
	animation cycle. </li>
	<li><a href="#Listing_16">Listing 16</a>. Control the distance between the 
	turtles. </li>
	<li><a href="#Listing_17">Listing 17</a>. The modelChanged method of the 
	World class. </li>
	<li><a href="#Listing_18">Listing 18</a>. The leader makes his move. </li>
	<li><a href="#Listing_19">Listing 19</a>. The other seven turtles make their 
	move. </li>
	<li><a href="#Listing_20">Listing 20</a>. Control the animation speed. </li>
	<li><a href="#Listing_21">Listing 21</a>. The getGraphics method of the 
	World class. </li>
	<li><a href="#Listing_22">Listing 22</a>. The paintComponent method of the 
	World class. </li>
	<li><a href="#Listing_23">Listing 23</a>. Source code for Ericson's class 
	named World. </li>
	<li><a href="#Listing_24">Listing 24</a>. Source code for the program named 
	TurtleWorld01. </li>
</ul>
<h3 align="left"> <a name="Supplementary_material">Supplementary material</a></h3>
<p> I recommend that you also study the other lessons in my extensive collection 
of online programming tutorials.&nbsp; You will find a consolidated index at
<font
 color="#000000"> <a href="http://www.dickbaldwin.com/toc.htm">
www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General background information</a></font></h2>
<h3><a name="A_multimedia_class_library">A multimedia class library</a></h3>
<p>In this series of lessons, I will present and explain many of the classes in 
a multimedia class library that was developed and released under a <b>Creative 
Commons Attribution 3.0 United States License</b> <i>(see <a href="#Resources">
Resources</a>) </i>by Mark Guzdial and Barbara Ericson at Georgia Institute of 
Technology.&nbsp; In doing this, I will also present some interesting sample programs 
that use the library.</p>
<h3><a name="Software_installation_and_testing">Software installation and 
testing</a></h3>
<p>I explained how to download, install, and test the multimedia class library 
in an earlier lesson titled <i>Multimedia Programming with Java, Getting Started 
(see <a href="#Resources">Resources</a>)</i>.</p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>I will explain Ericson's <b>World</b> class in this lesson.&nbsp; I will also 
present and explain a sample animation program in which seven <b>Turtle</b> 
objects chase another<b> Turtle</b> object around in an aquarium.&nbsp; A screen 
shot from the sample program, showing seven turtles in hot pursuit of a red and 
green turtle, is shown in Figure 1.</p>












<p>
 <b><a name="Figure_1">Figure 1</a>. Screen output from program named TurtleWorld01. </b>
<table border="0" cols="1" bgcolor="#ffffff" >
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java352a.jpg" width="459" height="367"></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and sample code</font></h2>
</center>
<h3><a name="The_World_Class_2">The World class</a></h3>
<p>A complete listing of the <b>
World</b> class is shown in Listing 23 near the end of the lesson.&nbsp; The 
only changes that were made to this listing were minor formatting changes that 
were required to make the source code fit into this narrow publication format.</p>
<p><font color="#FF0000"><b>Let's try something new</b></font></p>
<p>I'm going to try something in this lesson that I have never tried&nbsp; 
before.&nbsp; I'm going to explain the <b>World</b> class in the context of a 
sample program named <b>TurtleWorld01</b> that animates a group of turtles in a
<b>World</b> object.</p>
<p>As usual, I will explain the code in fragments.&nbsp; However, to help you know whether a 
particular code fragment came from the <b>World</b> class or came from the sample 
program, I will use two different background colors for the listings of the code 
fragments.&nbsp; The two colors are shown in Listing 1 and Listing 2.</p>
<p>
<b><a name="Listing_1">Listing 1</a>. Background color for World class code 
fragments. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>World class code fragments.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_2">Listing 2</a>. Background color for sample program 
code fragments.</b><table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>Sample program code fragments.</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h3><a name="Sample_program_named_TurtleWorld01">Sample program named 
TurtleWorld01</a></h3>
<p>This is an animated program that is designed to illustrate various features 
of the <b>World</b> class and the <b>Turtle</b> class.&nbsp; (<i>See
<a href="#Resources">resources</a> for earlier lessons on the <b>Turtle</b> 
class.)</i>&nbsp; A complete listing of the program is provided in Listing 24 near 
the end of the lesson.</p>
<p>The program places eight <b>Turtle</b> objects in a <b>World</b> object 
referred to by a variable named <b>aquarium</b>.&nbsp; One turtle is designated 
as the leader and is given a red shell to make it highly visible.&nbsp; <i>(A 
screen shot from the running program is shown in Figure 1.)</i></p>
<p>An Image from an aquarium containing a starfish and some other fish is used 
as a background picture for the aquarium.&nbsp; The lead turtle has a red shell 
and a green body.&nbsp; The body color and the shell 
color of two of the turtles are set to yellow and orange to make them stand out 
from the background.&nbsp; The remaining four turtles are presented in their 
default colors of green, cyan, and purple.</p>
<p><font color="#FF0000"><b>Follow the leader</b></font></p>
<p>All eight turtles are initially placed in random locations in the aquarium.&nbsp; 
The lead turtle swims around randomly.&nbsp; The other seven turtles converge 
rapidly 
on the leader and swim in formation following the leader while attempting to 
avoid collisions with one another.</p>
<p>Much of the time, the formation looks roughly like a hexagon with six turtles 
forming the perimeter and one turtle in the center.&nbsp; <i>(See Figure 1.)</i></p>
<p>Once started, the program will run until it is manually terminated.</p>
<p><font color="#FF0000">
<b>Beginning of the program named TurtleWorld01</b></font></p>
<p>The program begins in Listing 3 by instantiating an object of the <b>Runner</b> 
class and calling the <b>run</b> method on that object.</p>
<p>
<b><a name="Listing_3">Listing 3</a>. Beginning of the program named 
TurtleWorld01. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>import java.util.Random;
import java.util.Date;
import java.util.List;
import java.awt.Color;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the class named Runner</b></font></p>
<p>The <b>Runner</b> class of the <b>TurtleWorld01</b> program begins in Listing 
4.</p>
<p>
<b><a name="Listing_4">Listing 4</a>. Beginning of the class named Runner. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>class Runner{
  //Instantiate a random number generator.
  Random randGen = new Random(new Date().getTime());

  //Set the dimensions and instantiate a new world.
  int aquariumWidth = 450;
  int aquariumHeight = 338;
  World aquarium = new World(
                            aquariumWidth,aquariumHeight);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>Runner</b> class begins by instantiating a random-number generator 
object that will be used later to introduce randomness into the program.</p>
<p><font color="#FF0000">
<b>One of the overloaded constructors for the World class</b></font></p>
<p>Then the program sets the dimensions to match the background image in Figure 
1 and instantiates a new <b>World</b> object 
by calling the overloaded <b>World</b> constructor shown in Listing 5.</p>
<p>
<b><a name="Listing_5">Listing 5</a>. One of the overloaded constructors for the 
World class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public World(int w, int h){
    width = w;
    height = h;

    // set up the world and make it visible
    initWorld(true);
  }//end constructor
</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 5, which is a code fragment from the <b>World</b> class, begins by saving the incoming width and height values in a pair of 
private instance variables.&nbsp; <i>(You can view all of the World's instance 
variables in Listing 23.)</i>&nbsp; Then it calls the <b>initWorld</b> method,
<i>(shown in Listing 6)</i>, 
passing true as a parameter to complete the construction of the new <b>World</b> 
object.</p>
<p><font color="#FF0000">
<b>The initWorld method</b></font></p>
<p>The incoming <b>boolean</b> parameter to the <b>initWorld</b> method is used 
to determine if the world will be visible when it is instantiated.</p>
<p>
<b><a name="Listing_6">Listing 6</a>. The initWorld method of the World class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  private void initWorld(boolean visibleFlag){
    // set the preferred size
    this.setPreferredSize(new Dimension(width,height));

    // create the background picture
    picture = new Picture(width,height);

    // add this panel to the frame
    frame.getContentPane().add(this);

    // pack the frame
    frame.pack();

    // show this world
    frame.setVisible(visibleFlag);
  }//end initWorld method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The preferred size</b><br />
  I have discussed the <i>preferred size</i> in many earlier lessons.
</td></tr></table>
</td>
</tr>
</table>
<p>Listing 6 begins by calling the <b>setPreferredSize</b> method inherited from 
the <b>JComponent</b> class to set the preferred size of the <b>World</b> 
object.</p>
<p><font color="#FF0000"><b>Create an all-white background picture</b></font></p>
<p>Then Listing 6 instantiates a new default all-white <b>Picture</b> object and 
assigns the picture's reference to a private instance variable named <b>picture</b>.</p>
<p><font color="#FF0000"><b>Add the world to a JFrame object</b></font></p>
<p>One of the world's private instance variables <i>(see Listing 23)</i> is a reference variable named 
<b>frame</b> containing a reference to an empty <b>JFrame</b> object.&nbsp; Listing 
6 adds the new <b>World</b> object to the <b>JFrame</b> object.&nbsp; Therefore, 
the <b>JFrame</b> object becomes the visual container for the world.</p>
<p>Then Listing 6 calls the <b>pack</b> method on the <b>JFrame</b> object.&nbsp; 
This causes the size of the <b>JFrame</b> object to be set to the preferred size 
of the world that it contains.</p>
<p>Finally, Listing 6 causes the <b>JFrame</b> object to be visible or not 
visible, depending on the boolean value received as an incoming parameter by the
<b>initWorld</b> method.</p>
<p><font color="#FF0000">
<b><a name="Get_reference_to_the_list_of_turtles">Get reference to the list of turtles</a></b></font></p>
<p>If you examine the instance variables in Listing 23, you will see that the <b>
World</b> object creates and maintains an <b>ArrayList</b> object containing 
references to all of the turtle objects that are added to the world.&nbsp; 
Listing 7, which is a fragment from the <b>TurtleWorld01</b> program, gets and saves a reference to that list.&nbsp; 
The reference will be used for manipulating 
the turtles later.&nbsp; The reference is saved as the interface type <b>List</b>.</p>
<p>
<b><a name="Listing_7">Listing 7</a>. Get a reference to the list of turtles. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>  //Get a reference to the list of turtles maintained by
  // the World object.
  List turtleList = aquarium.getTurtleList();</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The getTurtleList method of the World class</b></font></p>
<p>As you can see in Listing 8, the
<b>getTurtleList</b> method simply returns the contents of a private instance 
variable named <b>turtleList</b>, which is a reference to the list of turtles.</p>
<p>
<b><a name="Listing_8">Listing 8</a>. The getTurtleList method of the World 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>  public List getTurtleList(){
    return turtleList;
  }//end getTurtleList methodd</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Beginning of the run method of the Runner class</b></font></p>
<p>The <b>run</b> method that was called in Listing 3 begins in Listing 9.</p>
<p>
<b><a name="Listing_9">Listing 9</a>. Beginning of the run method of the Runner 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>  void run(){
    aquarium.setPicture(new Picture("aquarium.gif"));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>The size of the World</b><br />
<font size="3" face="arial">
	Note that the size of the picture of the aquarium was determined in advance 
	and the dimensions of the world were set to the size of the picture Listing 
	4.&nbsp; Otherwise, either a portion of the world would be white, or some of 
	the picture would not be visible.</font>
</td></tr></table>
</td>
</tr>
</table>
<p>Listing 9 calls the <b>setPicture</b> method on the <b>World</b> object to 
replace the all-white picture with the background image shown in Figure 1.</p>
<p><font color="#FF0000">
<b>The setPicture method of the World class</b></font></p>
<p>As you can see in Listing 10, the <b>setPicture</b> method simply assigns the 
incoming <b>Picture</b> object's reference to the instance variable named <b>
picture</b>.&nbsp; <i>(See Listing 23.)</i></p>
<p>
<b><a name="Listing_10">Listing 10</a>. The setPicture method of the World 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public void setPicture(Picture pict){
    picture = pict;
  }//end setPicture method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Instantiate eight Turtle objects</b></font></p>
<p>Listing 11 instantiates eight new <b>Turtle</b> objects and places them in 
random locations in the <b>World</b> object referred to by <b>aquarium</b>.</p>
<p>
<b><a name="Listing_11">Listing 11</a>. Instantiate eight Turtle objects. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>    int numberTurtles = 8;

    //Place each turtle in a random location in the
    // aquarium.
    for(int cnt=0;cnt &lt; numberTurtles;cnt++){
      int xCoor =
              Math.abs(randGen.nextInt() % aquariumWidth);
      int yCoor =
             Math.abs(randGen.nextInt() % aquariumHeight);
      <b>new Turtle(xCoor,yCoor,aquarium)</b>;
    }//end for loop</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A ModelDisplay object</b><br />
<font size="3" face="arial">
	The <b>World</b> class implements the <b>ModelDisplay</b> 
interface.&nbsp; Therefore, a <b>World</b> object is also a <b>ModelDisplay</b> 
	object.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Turtle constructors</b></font></p>
<p>You learned in an earlier lesson <i>(see <a href="#Resources">Resources</a>)</i> 
that whenever you instantiate a new <b>Turtle</b> object, you can specify the 
container in which it will live:&nbsp; <b>Picture</b> object or <b>ModelDisplay</b> 
object.&nbsp; You also learned that you can optionally specify the coordinates at 
which the turtle will be placed in that container.</p>
<p><font color="#FF0000"><b>When the container is a ModelDisplay object...</b></font></p>
<p>You learned that when the specified container is a <b>ModelDisplay</b>
<i>(<b>World</b>) </i>object<i>,</i> the constructor for the <b>Turtle</b> class:</p>
<ul>
	<li>Sets the initial position coordinates for the new turtle.</li>
<li>Sets the initial body color of the new turtle to one of four default colors.</li>
	<li>Sets the initial pen color to match the body color.</li>
<li>Increments a static turtle counter in the <b>Turtle</b> class.</li>
	<li>Calls the <b>addModel</b> method on the specified <b>ModelDisplay</b> <i>
	(<b>World</b>)</i> object.</li>
</ul>
<p><font color="#FF0000">
<b>The addModel method of the World class</b></font></p>
<p>The <b>addModel</b> method of the <b>World</b> class is shown in Listing 12.</p>
<p>
<b><a name="Listing_12">Listing 12</a>. The addModel method of the World class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public void addModel(Object model){
    turtleList.add((Turtle) model);
    if (autoRepaint)
       repaint();
  }//end addModel method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The method begins by adding the new turtle's reference to the world's <b>
ArrayList</b> object that is used to maintain a list of all the turtles that
<a href="#Get_reference_to_the_list_of_turtles">belong to the world</a>.</p>
<p><font color="#FF0000"><b>To paint or not to paint...</b></font></p>
<p>Then the <b>addModel</b> method checks the value of a <b>boolean</b> instance variable named
<b>autoRepaint</b> <i>(which is true by default)</i> to determine whether or not 
to repaint the world containing the new turtle.&nbsp; The call to the <b>repaint</b> 
method causes the world's <b>paintComponent</b> method to be called.&nbsp; I 
will have more to say about this later.</p>
<p><font color="#FF0000"><b>Perform some housekeeping chores</b></font></p>
<p>Listing 13 performs some housekeeping chores in preparation for running the 
animation loop in the program named <b>TurtleWorld01</b>.</p>
<p>
<b><a name="Listing_13">Listing 13</a>. Perform some housekeeping chores. </b>
<table border="1" cols="1" width="477" bgcolor="#EFE9B8">
  <tbody>
    <tr>
      <td>
      <pre>    int angle = 0;//leader turning angle
    int leaderMove = 0;//leader move distance

    Turtle turtle = null;
    Turtle testTurtle = null;

    //First turtle in the list is the leader. Color it red
    // and get its length.
    Turtle leader = (Turtle)turtleList.get(0);
    leader.setShellColor(Color.RED);
    int turtleLength = leader.getHeight();

    //Change the shell and body colors of two of the other
    // turtles.
    turtle = (Turtle)turtleList.get(3);
    turtle.setBodyColor(Color.YELLOW);
    turtle.setShellColor(Color.ORANGE);
    turtle = (Turtle)turtleList.get(7);
    turtle.setBodyColor(Color.ORANGE);
    turtle.setShellColor(Color.YELLOW);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p dir="ltr">Most of the actions in Listing 13 involve extracting references to 
<b>Turtle</b> objects from the world's list of turtles and calling 
various methods of the <b>Turtle</b> and <b>SimpleTurtle</b> classes on those 
references.&nbsp; You learned about these methods in earlier lessons <i>(see
<a href="#Resources">Resources</a>)</i>.</p>
<p dir="ltr"><font color="#FF0000">
<b>Beginning of the animation loop in TurtleWorld01</b></font></p>
<p>The animation loop begins in Listing 14.</p>
<p>
<b><a name="Listing_14">Listing 14</a>. Beginning of the animation loop in 
TurtleWorld01. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>    while(true){//animation loop will run forever
      //Leader will move a random distance ranging fromm
      // half its length to 3/4 its length during each
      // animation cycle.      leaderMove = (int)(turtleLength/2
                    + turtleLength*randGen.nextDouble()/4);
      //Leader will turn a random amount ranging from
      // -22.5 degrees to +22.5 degrees during each
      // animation cycle.
      angle = (int)(45*(randGen.nextDouble() - 0.5));</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The animation loop will continue to run until the program is manually 
terminated.</p>
<p>Once during each animation cycle, the turtle with the red shell <i>(see 
Figure 1)</i> turns by a random amount and moves forward by a random distance.&nbsp; The 
variables named <b>leaderMove</b> and <b>angle</b> in Listing 14 are assigned 
random values that will be used later to control those actions.</p>
<p><font color="#FF0000">
<b>Process each turtle during each animation cycle</b></font></p>
<p>Each turtle in the list is processed once during each animation cycle.&nbsp; 
Listing 15 shows the beginning of a <b>for</b> loop that iterates on the list of 
turtles to accomplish that.</p>
<p>
<b><a name="Listing_15">Listing 15</a>. Process each turtle during each 
animation cycle. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>
      for(int cnt = 0;cnt &lt; turtleList.size();cnt++){
        turtle = (Turtle)turtleList.get(cnt);
        turtle.penUp();//no turtle tracks allowed</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>Control the distance between the turtles</b></font></p>
<p>Left strictly to their own devices, all seven of the turtles that are chasing 
the leader would attempt to occupy exactly the same space.&nbsp; Listing 16 
contains a <b>for</b> loop that attempts to force those seven turtles to 
maintain some distance between them.</p>
<p>
<b><a name="Listing_16">Listing 16</a>. Control the distance between the 
turtles. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>
        for(int cntr = 1;cntr &lt; turtleList.size();cntr++){
          testTurtle = (Turtle)turtleList.get(cntr);
          //Don't process leader or self.
          if((testTurtle != turtle) && (cnt != 0)){
            int separation = (int)(turtle.getDistance(
              testTurtle.getXPos(),testTurtle.getYPos()));
              //Try to keep them separated by at least
              // twice the turtleLength center to center
              if(separation &lt; 2*turtleLength){
                //Turn and move away from test turtle.
                turtle.turnToFace(testTurtle);
                turtle.turn(180);
                turtle.forward(turtleLength/3);
              }//end if
          }//end if
        }//end for loop on turtle separation</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Maintain a decent separation</b></font></p>
<p>The code in Listing 16 computes the distance between each of those seven 
turtles and six other turtles, <i>(excluding itself and the leader)</i>.</p>
<p>If the 
distance between the current turtle and a test turtle is below a specified 
threshold, the current turtle turns and moves away from the test turtle by a 
specified amount.&nbsp; While this algorithm is not perfect, it does a pretty 
good job of keeping the turtles separated as you will see if you run the program.</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>A model-view-control paradigm</b><br />
  I explained in an earlier lesson <i>(see <a href="#Resources">Resources</a>)</i> 
	that the call to the <b>modelChanged</b> method constitutes part of the use 
	of a <i>model-view-control (MVC)</i> paradigm by the <b>World</b> class.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Call the world's modelChanged method</b></font></p>
<p>You learned in an earlier lesson that if the heading, the visibility, or the 
position of a turtle is changed, the turtle object calls the world's <b>
modelChanged</b> method, which is shown in Listing 17.&nbsp; The <b>World</b> 
object may, or may not cause itself to be repainted in response to that call.</p>
<p><font color="#FF0000">
<b>The modelChanged method of the World class</b></font></p>
<p>The world's <b>modelChanged</b> method checks the value of the <b>boolean</b> 
variable named<b> autoRepaint</b>.&nbsp; If the value is true, the <b>repaint</b> 
method is called, which in turn causes the world's <b>paintComponent</b> method 
to be called.&nbsp; <i>(I'll have more to say about the <b>paintComponent</b> 
method later.)</i>&nbsp; Otherwise, it does nothing in response to the call.</p>
<p>
<b><a name="Listing_17">Listing 17</a>. The modelChanged method of the World 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public void modelChanged(){
    if (autoRepaint)
       repaint();
  }//end modelChanged method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000">
<b>The leader makes his move</b></font></p>
<p>Continuing with the <b>for</b> loop that began in Listing 15, if the current 
turtle being processed is the first turtle in the list, it is the leader.&nbsp; 
Its behavior is different from the behavior of the other seven turtles.</p>
<p>Listing 18 shows the behavior of the leader during one iteration of the 
animation loop.</p>
<p>
<b><a name="Listing_18">Listing 18</a>. The leader makes his move. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>        if(cnt == 0){
          //This is the leader

          //Force the leader to bounce off the walls.
          int xPos = leader.getXPos();
          int yPos = leader.getYPos();

          if(xPos &lt; turtleLength){
            leader.setHeading(90);
          }else if(xPos &gt; aquariumWidth -turtleLength -2){
            leader.setHeading(-90);
          }//end else

          if(yPos &lt; turtleLength){
            leader.setHeading(180);
          }else if(
                 yPos &gt; aquariumHeight -turtleLength - 2){
            leader.setHeading(0);
          }//end else

          //Leader turns a random amount and moves a
          // random distance during each animation cycle.
          leader.turn(angle);
          leader.forward(leaderMove);</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Has the leader collided with a wall?</b></font></p>
<p>Tests are performed in Listing 18 to determine if the leader has collided with one of the 
four walls of the world.&nbsp; If so, the leader's heading is set to the 
direction of the opposite wall.</p>
<p><font color="#FF0000"><b>Turn and move randomly</b></font></p>
<p>Regardless of whether or not a collision with a wall has occurred, the 
leader's heading is modified by a random amount ranging from -22.5 degrees to 
+22.5 degrees <i>(see Listing 14)</i> and the leader moves forward by a random 
distance ranging from half its length to three-fourths of its length <i>(see 
Listing 14)</i>.</p>
<p><font color="#FF0000">
<b>The other seven turtles make their move</b></font></p>
<p>If the current turtle is not the leader but instead is one of the seven turtles that follow the leader, the 
code in Listing 19 is executed.</p>
<p>
<b><a name="Listing_19">Listing 19</a>. The other seven turtles make their move. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>        }else{
          //This is not the leader.  Turn to face the
          // leader and move toward the leader.
          turtle.turnToFace(leader);
          int distanceToLeader = (int)(turtle.getDistance(
                      leader.getXPos(),leader.getYPos()));
          turtle.forward(distanceToLeader/10);
        }//end else

      }//end for loop processing all turtles</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Move towards the leader</b></font></p>
<p>Each of the seven turtles in the herd turn to face the new position of the 
leader and move toward the leader by one-tenth the distance to 
the leader.&nbsp; In theory, the members of the herd would never catch the 
leader.&nbsp; However, because the leader must turn back toward the herd when it 
collides with a wall, there are frequent collisions between the leader and the 
members of the herd.&nbsp; The leader simply blasts through the formation, 
colliding with other turtles along the way, and goes out the other side of the 
formation.&nbsp; This causes the other turtles to turn and give chase in the new 
direction.</p>
<p>Once again, every time any of the turtles moves or changes its heading, the
<b>World</b> object is given an opportunity to repaint itself.</p>
<p>Listing 19 signals the end of the <b>for</b> loop that causes the processing 
of every turtle during each animation cycle.</p>
<p><font color="#FF0000">
<b>Control the animation speed</b></font></p>
<p>At the end of each animation cycle, the program goes to sleep for 100 
milliseconds to control the overall speed of the animation.&nbsp; This is shown 
in Listing 20.</p>
<p>
<b><a name="Listing_20">Listing 20</a>. Control the animation speed. </b>
<table border="1" cols="1" width="477" bgcolor="#efe9b8">
  <tbody>
    <tr>
      <td>
      <pre>      //Control the animation speed.
      try{
        Thread.currentThread().sleep(100);
      }catch(InterruptedException ex){
      }//end catch
    }//end while loop

  }//end run
}//end class runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 20 also signals the end of the program named <b>TurtleWorld01</b>.</p>
<h3><a name="The_remainder_of_the_World_class">The remainder of the World class</a></h3>
<p>Although that is the end of the program named <b>TurtleWorld01</b>, it is not 
the end of the explanation of the class named <b>World</b>.&nbsp; There are 
several other methods in the <b>World</b> class that need to be explained.</p>
<p><font color="#FF0000"><b>Two more overloaded constructors</b></font></p>
<p>There are two more overloaded constructors for the <b>World</b> class.&nbsp; 
One receives no arguments and constructs a world that is visible by default and 
has a default size.&nbsp; The other receives a boolean value and constructs a 
world that may or may not be visible, depending on the value of the incoming 
parameter and has a default size.</p>
<p>Both of these constructors are straightforward.&nbsp; You can view the code 
for these two constructors in Listing 23.</p>
<p><font color="#FF0000"><b><a name="What_is_a_graphics_context">What is a graphics context?</a></b></font></p>
<p>According to <i>Java Graphics (see <a href="#Resources">Resources</a>)</i>:</p>
<blockquote>
	<p><i>&quot;First and foremost, you should know that in Java graphics 
	programming, one of the most important instantiated objects is the graphics 
	context. This object is an instance of the java.awt.Graphics class, and it 
	refers to an area of the screen such as an applet. A graphics context 
	provides methods for all of the drawing operations on its area. It also 
	holds &quot;contextual&quot; information about such things as the drawing area's 
	clipping region, painting color, transfer mode, and text font.&quot;</i></p>
</blockquote>
<p>Stated differently, if you want to draw on an object using methods of the <b>
Graphics</b> class or the <b>Graphics2D</b> class, you must first get a <i>
graphics context</i> on the object on which you want to draw.</p>
<p><font color="#FF0000"><b>A rectangular area...</b></font></p>
<p>I often tell my students that such an object of the <b>Graphics</b> class 
represents a rectangular area of the screen or an off-screen buffer in memory.&nbsp; 
Whatever you draw on the <b>Graphics</b> object will be drawn on the screen or 
in the off-screen buffer memory.&nbsp; <i>(As I recall, it is also possible to 
get a <b>Graphics</b> object that represents a rectangular area on a sheet of 
paper in a printer, but I haven't had a reason to think about that in a long 
time.)</i></p>
<p><font color="#FF0000"><b>The graphics context for a World object</b></font></p>
<p>You can get a graphics context on a <b>World</b> object by calling the <b>
getGraphics</b> method shown in Listing&nbsp;21.</p>
<p>
<b><a name="Listing_21">Listing 21</a>. The getGraphics method of the World 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public Graphics getGraphics(){
    return picture.getGraphics();
  }//end getGraphics method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Interestingly, when you make that call, what you receive is a reference to 
the graphics context belonging to the <b>Picture</b> object that belongs to the
<b>World</b> object.</p>
<p><font color="#FF0000"><b>Getting and clearing the world's Picture object</b></font></p>
<p>The following methods are available for working with the world's <b>Picture</b> 
object:</p>
<ul>
	<li><b>setPicture(Picture pict)</b> - replaces the world's default all-white 
	picture with a picture of your choice <i>(see Listing 10)</i>.</li>
	<li><b>getPicture()</b> - returns a reference to the world's current <b>
	Picture</b> object.</li>
<li><b>clearBackground()</b> - replaces the world's current <b>Picture</b> 
	object with an all-white picture.</li>
</ul>
<p>These methods are straightforward.&nbsp; You can view the code in Listing 23.</p>
<p><font color="#FF0000">
<b>The paintComponent method of the World class</b></font></p>
<p>The paintComponent method of the World class is shown in its entirety in 
Listing 22.</p>
<p>
<b><a name="Listing_22">Listing 22</a>. The paintComponent method of the World 
class. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>
  public synchronized void paintComponent(Graphics g){
    Turtle turtle = null;

    // draw the background image
    g.drawImage(picture.getImage(),0,0,null);

    // loop drawing each turtle on the background image
    Iterator iterator = turtleList.iterator();
    while (iterator.hasNext())
    {
      turtle = (Turtle) iterator.next();
      turtle.paintComponent(g);
    }
  }//end paintComponent method</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Painting in AWT and Swing</b><br />
  For more information on the paint mechanisms utilized by AWT and Swing, 
	including information on how to write the most efficient painting code, see 
	<a href="http://java.sun.com/products/jfc/tsc/articles/painting/index.html">
	Painting in AWT and Swing</a>.</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Update the world's visual representation</b></font></p>
<p>When an object of the <b>World</b> class decides, for whatever reason, that 
its visual representation on the screen needs to be updated <i>(see Listing 12 
and Listing 17 for example)</i>, it makes a call to the <b>
repaint</b> method inherited from the <b>Component</b> class.&nbsp; This 
ultimately results in a call to the world's <b>paintComponent</b> method.&nbsp; 
</p>
<p><font color="#FF0000"><b>Can be triggered by the operating system</b></font></p>
<p>Similarly, when the operating system decides for whatever reason that the world's screen 
representation needs to be updated, <i>(such as when it is minimized and then 
restored)</i>, the operating system causes the world's <b>
paintComponent</b> method to be called.</p>
<p>


<p><font color="#FF0000"><b>A reference to a graphics context</b></font></p>
<p>When the <b>paintComponent</b> method is called, it receives a reference to a 
graphics context that represents an area of the screen that is to be repainted.</p>


<table width="275" cellpadding="0" cellspacing="0" border="0" align="right">
<tr>
<td width="10">
<td>
  <table width="100%" cellpadding="5" cellspacing="0" border="1">
  <tr><td bgcolor="#eeeeee">
  <b>Casting the graphics context</b><br />
<font size="3" face="arial">
	Casting the graphics context reference to type <b>Graphics2D</b> makes it possible to use the 
methods of the <b>Graphics2D</b> class to draw on the graphics context.</font>
</td></tr></table>
</td>
</tr>
</table>
<p><font color="#FF0000"><b>Actually an object of the Graphics2D class</b></font></p>
<p>The graphics context is received as type <b>Graphics</b>, but it is actually a 
reference to an object of the <b>Graphics2D</b> subclass of <b>Graphics</b>.</p>
<p><font color="#FF0000"><b>Draw the current picture on the graphics context</b></font></p>
<p>Listing 22 begins by calling the <b>drawImage</b> method to draw the image 
contained in the world's current <b>Picture</b> object on the graphics context.&nbsp; 
This produced the aquarium background shown in Figure 1.</p>
<p><font color="#FF0000"><b>Call paintComponent on each of the turtles</b></font></p>
<p>Then Listing 22 uses an iterator to loop and call the <b>paintComponent</b> 
method on each <b>Turtle</b> object whose reference is stored in the list of 
turtles, passing the same graphics context received by the world's <b>
paintComponent</b> method.</p>
<p><font color="#FF0000"><b>Draw each turtle and its track</b></font></p>
<p>We learned in an earlier lesson <i>(see <a href="#Resources">Resources</a>)</i> that a turtle's <b>paintComponent</b> 
method begins by casting the incoming reference of type <b>Graphics</b> to type
<b>Graphics2D</b>.&nbsp; Then it draws the body parts of the turtle at the 
correct location, in the correct color with the correct heading.&nbsp; Then it calls the <b>
paintComponent</b> method on the <b>Pen</b> object that belongs to the turtle, 
passing the same graphics context that it received.</p>
<p><font color="#FF0000"><b>Drawing the historical turtle track</b></font></p>
<p>As a turtle moves with the pen down, the turtle's <b>Pen</b> object maintains 
a list of historical turtle movements as type <b>PathSegment</b>.&nbsp; When the <b>
paintComponent</b> method is called on the <b>Pen</b> object, it uses the 
contents of that list to reconstruct and draw line segments with the correct 
width and the correct color representing the turtle's historical path.&nbsp; 
Note, however, that the pen was never down in the sample program named 
TurtleWorld01 so no turtle tracks are produced.&nbsp; <i>(For an interesting 
effect, disable the call to the <b>penUp</b> method in Listing 15.)</i></p>
<p><font color="#FF0000"><b>The remaining methods of the World class</b></font></p>
<p>The world class defines several additional methods that I haven't discussed 
in this lesson:</p>
<ul>
	<li><b>getLastTurtle</b> - a method to get a reference to the last turtle in the 
	list of turtles.</li>
	<li><b>containsTurtle</b> - a method to determine if the list contains a reference 
	to a specific turtle object.</li>
	<li><b>remove</b> - a method to remove a specific turtle from the list.</li>
	<li><b>getWidth</b> - a method to get the width of the <b>World</b> object.</li>
	<li><b>getHeight</b> - a method to get the height of the <b>World</b> object.</li>
	<li><b>setAutoPaint</b> - a method to set the value of the <b>autoPaint</b> 
	variable to true or false.</li>
	<li><b>setVisible</b> - a method to make the <b>World</b> object visible or 
	invisible.</li>
	<li><b>getTurtleIterator</b> - a method to get an <b>Iterator</b> object on the 
	list of turtles.</li>
	<li><b>toString</b> - a method to return a string that describes a <b>World</b> 
	object.</li>
</ul>
<p>The code for all of the methods in the above list is straightforward.&nbsp; 
You can view that code in Listing 23.</p>
<p><font color="#FF0000"><b>That wraps it up</b></font></p>
<p>That brings us to the end of the explanation of the class named <b>World</b> 
and the end of the explanation of the program named <b>TurtleWorld01</b>.</p>
<center>
<h2><a name="Run the program"></a>Run the programs</h2>
</center>
<p>I encourage you to copy the code from Listing 24, compile 
the code, and execute it.&nbsp; Experiment with the code, making changes, and 
observing the results of your changes.&nbsp; Make certain that you can explain why 
your changes behave as they do.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I have explained an animation program named <b>TurtleWorld01</b> 
along with an explanation of the class named <b>World</b>.&nbsp; The program 
named <b>TurtleWorld01</b> illustrates a form of <i>flocking behavior</i> <i>
(see Wikipedia: Flocking behavior in <a href="#Resources">Resources</a>)</i> where a herd 
of turtles follow a lead turtle as it moves randomly in a <b>World</b> object 
while attempting to avoid collisions with one another.</p>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's next?</a></h2>
<p>In the next lesson, you learn how to write programs using the methods defined in the Picture and 
SimplePicture classes that are declared in the 
DigitalPicture interface.</p>
<h2 align="center"><a name="Resources">Resources</a></h2>
<ul>
	<li>
	<a rel="license" target="new" href="http://creativecommons.org/licenses/by/3.0/us/">
	Creative Commons Attribution 3.0 United States License</a></li>
	<li><a target="new" href="http://coweb.cc.gatech.edu/mediaComp-plan/101">
	Media Computation book in Java</a> - numerous downloads available</li>
	<li>
	<a target="new" href="http://www.mypearsonstore.com/bookstore/product.asp?isbn=0131496980">
	Introduction to Computing and Programming with Java: A Multimedia Approach</a></li>
	<li><a target="new" href="http://drjava.sourceforge.net/">DrJava</a> 
	download site</li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava, 
	the JavaPLT group at Rice University</a></li>
	<li><a target="new" href="http://www.cs.rice.edu/~javaplt/drjava/">DrJava 
	Open Source License</a></li>
	<li>
	<a target="new" href="http://www.developer.com/java/article.php/1440571">The 
	Essence of OOP using Java, The this and super Keywords</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java058.htm">
	Threads of Control</a></li>
	<li>
	<a target="new" href="http://java.sun.com/products/jfc/tsc/articles/painting/">
	Painting in AWT and Sw<font size="-1" face="Verdana, Arial, Helvetica">ing</font></a></li>
	<li><a target="new" href="http://en.wikipedia.org/wiki/Turtle_graphics/">
	Wikipedia Turtle Graphics</a></li>
	<li><a target="new" href="http://www.devx.com/tips/Tip/5809">IsA or HasA</a></li>
	<li>
	<a target="new" href="http://www.vectorcad3d.com/support/lathetutorial.htm">
	Vector Cad-Cam XI Lathe Tutorial</a></li>
	<li>
	<a target="new" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/classification/">
	Classification of 3D to 2D projections</a></li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java200.htm">200</a> 
	Implementing the Model-View-Controller Paradigm using Observer and 
	Observable</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java300.htm">300</a> 
	Java 2D Graphics, Nested Top-Level Classes and Interfaces</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java302.htm">302</a> 
	Java 2D Graphics, The Point2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java304.htm">304</a> 
	Java 2D Graphics, The Graphics2D Class</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java306.htm">306</a> 
	Java 2D Graphics, Simple Affine Transforms</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java308.htm">308</a> 
	Java 2D Graphics, The Shape Interface, Part 1</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java310.htm">310</a> 
	Java 2D Graphics, The Shape Interface, Part 2</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java312.htm">312</a> 
	Java 2D Graphics, Solid Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java314.htm">314</a> 
	Java 2D Graphics, Gradient Color Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java316.htm">316</a> 
	Java 2D Graphics, Texture Fill</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java318.htm">318</a> 
	Java 2D Graphics, The Stroke Interface</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java320.htm">320</a> 
	Java 2D Graphics, The Composite Interface and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java322.htm">322</a> 
	Java 2D Graphics, The Composite Interface, GradientPaint, and Transparency</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java324.htm">324</a> 
	Java 2D Graphics, The Color Constructors and Transparency</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3403921">
	400</a> Processing Image Pixels using Java, Getting Started<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3423661">
	402</a> Processing Image Pixels using Java, Creating a Spotlight<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3441391">
	404</a> Processing Image Pixels Using Java: Controlling Contrast and 
	Brightness<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3512456">
	406</a> Processing Image Pixels, Color Intensity, Color Filtering, and Color 
	Inversion <br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3522711">
	408</a> Processing Image Pixels, Performing Convolution on Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3579206">
	410</a> Processing Image Pixels, Understanding Image Convolution in Java<br>
	<a target="new" href="http://www.developer.com/java/ent/article.php/3590351">
	412</a> Processing Image Pixels,<font size="-1" face="Verdana, Arial, Helvetica"> 
	Applying Image Convolution in Java, Part 1 <br>
	</font>
	<a target="new" href="http://www.developer.com/java/other/article.php/3596351">
	414</a> Processing Image Pixels, Applying Image Convolution in Java, Part 2<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3640776">
	416</a> Processing Image Pixels, An Improved Image-Processing Framework in 
	Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3650011">
	418</a> Processing Image Pixels, Creating Visible Watermarks in Java<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3645761">
	450</a> A Framework for Experimenting with Java 2D Image-Processing Filters<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3654171">
	452</a> Using the Java 2D LookupOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3670696">
	454</a> Using the Java 2D AffineTransformOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3681466">
	456</a> Using the Java 2D LookupOp Filter Class to Scramble and Unscramble 
	Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3686856">
	458</a> Using the Java 2D BandCombineOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3696676">
	460</a> Using the Java 2D ConvolveOp Filter Class to Process Images<br>
	<a target="new" href="http://www.developer.com/java/other/article.php/3698981">
	462</a> Using the Java 2D ColorConvertOp and RescaleOp Filter Classes to 
	Process Images</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java506.htm">506</a> 
	JavaBeans, Introspection</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/2114451">
	2100</a> Understanding Properties in Java and C#</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3495121">
	2300</a> Generics in J2SE, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3782471">
	340</a> Multimedia Programming with Java, Getting Started</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3788086">
	342</a> Getting Started with the Turtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3791291">
	344</a> Continuing with the SimpleTurtle Class: Multimedia Programming with 
	Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3793401">
	346</a> Wrapping Up the SimpleTurtle Class: Multimedia Programming with Java</li>
	<li><a target="new" href="http://www.dickbaldwin.com/java/Java348.htm">348</a> 
	The Pen and PathSegment Classes: Multimedia Programming with Java</li>
	<li>
	<a target="new" href="http://www.developer.com/java/other/article.php/3795761">
	349</a> A Pixel Editor Program in Java: Multimedia Programming with Java</li>
	<li>
	<a new href="http://www.developer.com/java/other/article.php/3798646%20target=">
	350</a> 3D Displays, Color Distance, and Edge Detection</li>
	<li><a href="http://www.developer.com/java/other/article.php/3801671">351</a> 
	A Slider-Controlled Softening Program for Digital Photos</li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete program listings</h2>
</center>
Complete listings of the programs discussed in this lesson are shown in Listing 
23 and Listing 24 below.
<p>
<b><a name="Listing_23">Listing 23</a>. Source code for Ericson's class named World. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>import javax.swing.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Observer;
import java.awt.*;

/**
 * Class to represent a 2d world that can hold turtles and
 * display them
 *
 * Copyright Georgia Institute of Technology 2004
 * @author Barb Ericson ericson@cc.gatech.edu
 */
public class World
               extends JComponent implements ModelDisplay{
  ////////////////// fields ///////////////////////

  /** should automatically repaint when model changed */
  private boolean autoRepaint = true;

  /** the background color for the world */
  private Color background = Color.white;

  /** the width of the world */
  private int width = 640;

  /** the height of the world */
  private int height = 480;

  /** the list of turtles in the world */
  private List&lt;Turtle&gt; turtleList =
                                  new ArrayList&lt;Turtle&gt;();

  /** the JFrame to show this world in */
  private JFrame frame = new JFrame("World");

  /** background picture */
  private Picture picture = null;

  ////////////////// the constructors ///////////////

  /**
   * Constructor that takes no arguments
   */
  public World()
  {
    // set up the world and make it visible
    initWorld(true);
  }

  /**
   * Constructor that takes a boolean to
   * say if this world should be visible
   * or not
   * @param visibleFlag if true will be visible
   * else if false will not be visible
   */
  public World(boolean visibleFlag)
  {
    initWorld(visibleFlag);
  }

  /**
   * Constructor that takes a width and height for this
   * world
   * @param w the width for the world
   * @param h the height for the world
   */
  public World(int w, int h)
  {
    width = w;
    height = h;

    // set up the world and make it visible
    initWorld(true);
  }

  ///////////////// methods ///////////////////////////

  /**
   * Method to initialize the world
   * @param visibleFlag the flag to make the world
   * visible or not
   */
  private void initWorld(boolean visibleFlag)
  {
    // set the preferred size
    this.setPreferredSize(new Dimension(width,height));

    // create the background picture
    picture = new Picture(width,height);

    // add this panel to the frame
    frame.getContentPane().add(this);

    // pack the frame
    frame.pack();

    // show this world
    frame.setVisible(visibleFlag);
  }

  /**
   * Method to get the graphics context for drawing on
   * @return the graphics context of the background
   * picture
   */
  public Graphics getGraphics(){
    return picture.getGraphics();
  }

  /**
   * Method to clear the background picture
   */
  public void clearBackground(){
    picture = new Picture(width,height);
  }

  /**
   * Method to get the background picture
   * @return the background picture
   */
  public Picture getPicture() { return picture; }

  /**
   * Method to set the background picture
   * @param pict the background picture to use
   */
  public void setPicture(Picture pict) { picture = pict; }

  /**
   * Method to paint this component
   * @param g the graphics context
   */
  public synchronized void paintComponent(Graphics g)
  {
    Turtle turtle = null;

    // draw the background image
    g.drawImage(picture.getImage(),0,0,null);

    // loop drawing each turtle on the background image
    Iterator iterator = turtleList.iterator();
    while (iterator.hasNext())
    {
      turtle = (Turtle) iterator.next();
      turtle.paintComponent(g);
    }
  }

  /**
   * Method to get the last turtle in this world
   * @return the last turtle added to this world
   */
  public Turtle getLastTurtle()
  {
    return (Turtle) turtleList.get(turtleList.size() - 1);
  }


  /**
   * Method to add a model to this model displayer
   * @param model the model object to add
   */
  public void addModel(Object model)
  {
    turtleList.add((Turtle) model);
    if (autoRepaint)
       repaint();
  }

  /**
   * Method to check if this world contains the passed
   * turtle
   * @return true if there else false
   */
  public boolean containsTurtle(Turtle turtle)
  {
    return (turtleList.contains(turtle));
  }

  /**
   * Method to remove the passed object from the world
   * @param model the model object to remove
   */
  public void remove(Object model)
  {
    turtleList.remove(model);
  }

  /**
   * Method to get the width in pixels
   * @return the width in pixels
   */
  public int getWidth() { return width; }

  /**
   * Method to get the height in pixels
   * @return the height in pixels
   */
  public int getHeight() { return height; }

  /**
   * Method that allows the model to notify the display
   */
  public void modelChanged()
  {
    if (autoRepaint)
       repaint();
  }

  /**
   * Method to set the automatically repaint flag
   * @param value if true will auto repaint
   */
  public void setAutoRepaint(boolean value){
    autoRepaint = value;
  }

  /**
   * Method to hide the frame
   */
//  public void hide()
//  {
//    frame.setVisible(false);
//  }

  /**
   * Method to show the frame
   */
//  public void show()
//  {
//    frame.setVisible(true);
//  }

  /**
   * Method to set the visibility of the world
   * @param value a boolean value to say if should show
   * or hide
   */
  public void setVisible(boolean value)
  {
    frame.setVisible(value);
  }

  /**
   * Method to get the list of turtles in the world
   * @return a list of turtles in the world
   */
  public List getTurtleList()
  { return turtleList;}

  /**
   * Method to get an iterator on the list of turtles
   * @return an iterator for the list of turtles
   */
  public Iterator getTurtleIterator()
  { return turtleList.iterator();}

  /**
   * Method that returns information about this world
   * in the form of a string
   * @return a string of information about this world
   */
  public String toString()
  {
    return "A " + getWidth() + " by " + getHeight() +
      " world with " + turtleList.size()
                                      + " turtles in it.";
  }

} // end of World class</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<b><a name="Listing_24">Listing 24</a>. Source code for the program named TurtleWorld01. </b>
<table border="1" cols="1" width="477" bgcolor="#eeeeee">
  <tbody>
    <tr>
      <td>
      <pre>/*Program TurtleWorld01
Copyright R.G.Baldwin 2009

This is an animated program that is designed to illustrate
various features of the Turtle and World classes.

The program places eight Turtle objects in a World object
known as the aquarium. One turtle is designated as the
leader and is given a red shell to make it highly visible.

An Image from an aquarium containing a starfish and some
other fish is used as a background picture for the
aquarium.

The body color and shell color of two other turtles are
set to yellow and orange to make them stand out from the
background.

The leader swims around randomly in the aquarium.

All eight turtles are initially placed in random locations
in the aquarium. However, the other seven turtles rapidly
converge on the leader and swim in formation following the
leader while attempting to avoid collisions with one
another.

Much of the time, the formation looks roughly like a
hexagon with six turtles forming the perimeter and one
turtle in the center.

Once started, the program will run until it is manually
terminated.

Tested using Windows Vista Premium Home edition and
Ericson's multimedia library.
*********************************************************/
import java.util.Random;
import java.util.Date;
import java.util.List;
import java.awt.Color;

public class Main{
  public static void main(String[] args){
    new Runner().run();
  }//end main method
}//end class Main
//------------------------------------------------------//

class Runner{
  //Instantiate a random number generator.
  Random randGen = new Random(new Date().getTime());

  //Set the dimensions and instantiate a new world.
  int aquariumWidth = 450;
  int aquariumHeight = 338;
  World aquarium = new World(
                            aquariumWidth,aquariumHeight);

  //Get a reference to the list of turtles maintained by
  // the World object.
  List turtleList = aquarium.getTurtleList();
  //----------------------------------------------------//

  void run(){
    aquarium.setPicture(new Picture("aquarium.gif"));

    int numberTurtles = 8;

    //Place each turtle in a random location in the
    // aquarium.
    for(int cnt=0;cnt &lt; numberTurtles;cnt++){
      int xCoor =
              Math.abs(randGen.nextInt() % aquariumWidth);
      int yCoor =
             Math.abs(randGen.nextInt() % aquariumHeight);
      new Turtle(xCoor,yCoor,aquarium);
    }//end for loop

    int angle = 0;//leader turning angle
    int leaderMove = 0;//leader move distance

    Turtle turtle = null;
    Turtle testTurtle = null;

    //First turtle in the list is the leader. Color it red
    // and get its length.
    Turtle leader = (Turtle)turtleList.get(0);
    leader.setShellColor(Color.RED);
    int turtleLength = leader.getHeight();

    //Change the shell and body colors of two of the other
    // turtles.
    turtle = (Turtle)turtleList.get(3);
    turtle.setBodyColor(Color.YELLOW);
    turtle.setShellColor(Color.ORANGE);
    turtle = (Turtle)turtleList.get(7);
    turtle.setBodyColor(Color.ORANGE);
    turtle.setShellColor(Color.YELLOW);

    while(true){//animation loop will run forever
      //Leader will move a random distance ranging from
      // half its length to 3/4 its length during each
      // animation cycle.
      leaderMove = (int)(turtleLength/2
                   + turtleLength*randGen.nextDouble()/4);
      //Leader will turn a random amount ranging from
      // -22.5 degrees to +22.5 degrees during each
      // animation cycle.
      angle = (int)(45*(randGen.nextDouble() - 0.5));

      //Process each turtle in the list during each
      // animation cycle.
      for(int cnt = 0;cnt &lt; turtleList.size();cnt++){
        turtle = (Turtle)turtleList.get(cnt);
        turtle.penUp();//no turtle tracks allowed

        //Force the turtles to maintain some distanced
        // between them by comparing the distance from the
        // current turtle to every other turtle (other
        // than the leader) and making a correction when
        // too close.
        for(int cntr = 1;cntr &lt; turtleList.size();cntr++){
          testTurtle = (Turtle)turtleList.get(cntr);
          //Don't process leader or self.
          if((testTurtle != turtle) && (cnt != 0)){
            int separation = (int)(turtle.getDistance(
              testTurtle.getXPos(),testTurtle.getYPos()));
              //Try to keep them separated by at least
              // twice the turtleLength center to center
              if(separation &lt; 2*turtleLength){
                //Turn and move away from test turtle.
                turtle.turnToFace(testTurtle);
                turtle.turn(180);
                turtle.forward(turtleLength/3);
              }//end if
          }//end if
        }//end for loop on turtle separation

        if(cnt == 0){
          //This is the leader

          //Force the leader to bounce off the walls.
          int xPos = leader.getXPos();
          int yPos = leader.getYPos();

          if(xPos &lt; turtleLength){
            leader.setHeading(90);
          }else if(xPos &gt; aquariumWidth -turtleLength -2){
            leader.setHeading(-90);
          }//end else

          if(yPos &lt; turtleLength){
            leader.setHeading(180);
          }else if(
                 yPos &gt; aquariumHeight -turtleLength - 2){
            leader.setHeading(0);
          }//end else

          //Leader turns a random amount and moves a
          // random distance during each animation cycle.
          leader.turn(angle);
          leader.forward(leaderMove);
        }else{
          //This is not the leader.  Turn to face the
          // leader and move toward the leader.
          turtle.turnToFace(leader);
          int distanceToLeader = (int)(turtle.getDistance(
                      leader.getXPos(),leader.getYPos()));
          turtle.forward(distanceToLeader/10);
        }//end else

      }//end for loop processing all turtles

      //Control the animation speed.
      try{
        Thread.currentThread().sleep(100);
      }catch(InterruptedException ex){
      }//end catch
    }//end while loop

  }//end run
}//end class runner</pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>

<p> </p>
<hr align="center" size="3" width="100%">
<h2 align="center"><a name="Copyright">Copyright</a></h2>
<p>Copyright 2009, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h2 align="center"><a name="About_the_author">About the author</a></h2>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is object-oriented programming using Java and 
other OOP languages.</i><p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- </p>
</font>
</body>
</html>