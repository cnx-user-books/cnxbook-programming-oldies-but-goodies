<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Data Structures in Java: Part 4, Purpose of Implementations and Algorithms</h2>
<i>Baldwin explains that the core collection interfaces in the Java Collections
Framework allow collections to be manipulated without regard for how they
are implemented.&nbsp; The framework provides nine concrete implementations
of the interfaces.&nbsp; The framework also provides various algorithms
for manipulating the data in the collections.</i>
<p><b>Published:</b>&nbsp; May 28, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1356
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Program</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
This is the fourth lesson in a miniseries on Java data structures and the
Java Collections Framework.&nbsp; The first lesson in the miniseries was
entitled
<a href="Java1350.htm">Data Structures in Java: Part 1, Getting
Started</a>.
<p>The purpose of this miniseries is to help you learn the essential features
of Object-Oriented data structures in Java using the <i>Collections Framework</i>.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<p><font color="#000000">The index on my site provides links to the lessons
at </font><a href="http://softwaredev.earthweb.com/java">Gamelan.com</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
At least three things are included in a collections framework:
<ul>
<li>
interfaces</li>

<li>
implementations</li>

<li>
algorithms</li>
</ul>
The previous lesson discussed the purpose of the interfaces.&nbsp; This
lesson will discuss the purpose of the implementations and the algorithms
in the Collections Framework.
<center>
<h2>
<a NAME="Introduction"></a>Introduction</h2></center>
In the previous lesson, entitled <a href="Java1354.htm">Data Structures
in Java: Part 3, Purpose of Framework Interfaces</a>, we learned that the
framework provides nine concrete implementations of the interfaces in the
framework.&nbsp; These nine implementation classes are available for immediate
instantiation to produce objects to satisfy your collection needs.
<p>We also learned that the framework provides three incomplete implementations.&nbsp;
These classes are available for you to use as a starting point in defining
your own implementations.&nbsp; Default implementations of many of the
interface methods are provided in the incomplete implementations.
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
<b><font color="#FF0000">Purpose of implementations</font></b>
<p>The <i>implementations</i> in the Java Collections Framework are the
concrete definitions of the classes that implement the <i>core collection
interfaces</i>.&nbsp; For example, as of JDK 1.3, the concrete implementations
in the Java Collections Framework are provided by the following nine classes.
<ul>
<li>
HashSet</li>

<li>
TreeSet</li>

<li>
LinkedList</li>

<li>
ArrayList</li>

<li>
Vector</li>

<li>
HashMap</li>

<li>
WeakHashMap</li>

<li>
TreeMap</li>

<li>
Hashtable</li>
</ul>
<b><font color="#FF0000">Available for immediate use</font></b>
<p>These classes are available for immediate use to instantiate collection
objects.
<p>As you can see, there are two classes that obviously fall into the <i>set</i>
category, two that obviously fall into the <i>list</i> category, and three
that obviously fall into the <i>map</i> category.&nbsp; I will have more
to say about the details of these classes in subsequent lessons.
<p>This leaves two additional classes whose names don't readily divulge
the category in which they belong.
<p><b><font color="#FF0000">Vector and Hashtable classes</font></b>
<p>The classes <b>Vector</b> and <b>Hashtable</b> were part of Java even
before the Java Collections Framework became available.&nbsp; The <b>Vector</b>
class can be used to instantiate objects that fall in the general <i>list</i>
category.
<p>The <b>Hashtable</b> class can be used to instantiate objects that fall
in the <i>map</i> category.
<p>These two classes have been upgraded to make them compatible with the
Collections Framework.
<p><b><font color="#FF0000">Abstract implementations</font></b>
<p>In addition to the concrete implementations listed above, the following
three classes partially implement the interfaces, but are not intended
for instantiation.&nbsp; Rather, they are intended to be extended into
new concrete classes that you define.
<ul>
<li>
AbstractSet</li>

<li>
AbstractList</li>

<li>
AbstractMap</li>
</ul>
Therefore, by either using one of the three classes listed above as a starting
point, or by starting from scratch and fully implementing one or more of
the interfaces, you can provide new concrete implementations to augment
the framework to include collections that meet your special needs.
<p><b><font color="#FF0000">Purpose of algorithms</font></b>
<p>Algorithms are methods <i>(not necessarily exposed)</i> that provide
useful capabilities, such as searching and sorting.&nbsp; For example,
the <b>Collection</b> interface declares an exposed method named <b>contains</b>.
<p>The <b>contains</b> method
<ul>
<li>
Receives an incoming reference of type <b>Object</b> as a parameter</li>

<li>
Searches the collection looking for an element that matches the incoming
reference</li>

<li>
Returns true if the collection on which the method is invoked contains
the specified element</li>
</ul>
<b><font color="#FF0000">Different classes, different implementations</font></b>
<p>You can safely invoke the <b>contains</b> method on any object instantiated
from a class that properly implements the <b>Collection</b> interface,
even if you don't know the actual type of the collection object.
<p>The manner in which the search will be performed will probably differ
from one concrete implementation of the interface to the next.&nbsp; For
example, a <b>TreeSet</b> object will perform the search very rapidly with
a time cost of only log(n) where n is the number of elements.&nbsp; On
the other hand, for the same number of elements, because of a different
underlying data structure, a search on an <b>ArrayList</b> object will
probably require more time than a search on a <b>TreeSet</b> object.&nbsp;
As the number of elements increases, the difference in time cost between
the two will also increase.
<p>Consider the sample program shown in Listing 1.&nbsp; This program compares
the search speed of the <b>ArrayList</b> class and the <b>TreeSet</b> class.&nbsp;
A detailed discussion of the program follows Listing 1.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File SpeedTest01
Copyright 2001 R.G.Baldwin
**************************************/

import java.util.*;

public class SpeedTest01{
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String args[]){
&nbsp;&nbsp;&nbsp; new Worker().doIt();
&nbsp; }//end main()
}//end class SpeedTest01

class Worker{
&nbsp; public void doIt(){
&nbsp;&nbsp;&nbsp; int size = 500000;
&nbsp;&nbsp;&nbsp; //Create a TreeSet object
&nbsp;&nbsp;&nbsp; Collection aTree = new TreeSet();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Populate the TreeSet object with
&nbsp;&nbsp;&nbsp; // random values.&nbsp; The add() method
&nbsp;&nbsp;&nbsp; // for a set rejects duplicates.
&nbsp;&nbsp;&nbsp; Random rnGen = new Random();
&nbsp;&nbsp;&nbsp; for(int ct = 0; ct &lt; size; ct++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aTree.add(new Double(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rnGen.nextDouble()));
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create and populate an ArrayList
&nbsp;&nbsp;&nbsp; // object with the same random
&nbsp;&nbsp;&nbsp; // values
&nbsp;&nbsp;&nbsp; Collection aList =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ArrayList(aTree);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Extract a value near the center
&nbsp;&nbsp;&nbsp; // of the ArrayList object to use
&nbsp;&nbsp;&nbsp; // as a test case.
&nbsp;&nbsp;&nbsp; Object testVal =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((List)aList).get(size/2);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Search for the test value in each
&nbsp;&nbsp;&nbsp; // of the collection objects.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Measure and display the time&nbsp;
&nbsp;&nbsp;&nbsp; // required to perform the search
&nbsp;&nbsp;&nbsp; // in each case.
&nbsp;&nbsp;&nbsp; long start = new Date().getTime();
&nbsp;&nbsp;&nbsp; boolean found =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aList.contains(testVal);
&nbsp;&nbsp;&nbsp; long stop = new Date().getTime();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found + " " + (stop - start));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; start = new Date().getTime();
&nbsp;&nbsp;&nbsp; for(int x = 0; x &lt; 10000; x++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found = aTree.contains(testVal);
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; stop = new Date().getTime();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found + " " + (stop - start));

&nbsp; }//end doIt()
}// end class Worker

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p>The program begins by instantiating a <b>TreeSet</b> object and populating
it with approximately 500,000 elements as shown in Listing 2 below.&nbsp;
The values encapsulated in the objects referred to by the elements in the
collection are produced by a random number generator.
<p>Recall that the <b>add</b> method of a <b>Set</b> object rejects duplicate
elements, so there may be fewer than 500,000 elements in the object after
it is populated.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void doIt(){
&nbsp;&nbsp;&nbsp; int size = <b>500000</b>;

&nbsp;&nbsp;&nbsp; <b>Collection</b> aTree = new <b>TreeSet</b>();

&nbsp;&nbsp;&nbsp; Random rnGen = new <b>Random</b>();
&nbsp;&nbsp;&nbsp; for(int ct = 0; ct &lt; size; ct++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aTree.<b>add</b>(new Double(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rnGen.nextDouble()));
&nbsp;&nbsp;&nbsp; }//end for loop

<b>Listing 2</b></pre>
</td>
</tr>
</table>

<p>One of the capabilities of the Collection Framework is to create a new
<b>Collection</b> object and populate it with the contents of an existing
<b>Collection</b> object of a different <i>(or the same)</i> actual type.
<p>The code in Listing 3 instantiates an <b>ArrayList</b> object and populates
it with the contents of the existing <b>TreeSet</b> object.&nbsp; As a
result, we then have two different <b>Collection</b> objects of different
actual types containing the same elements.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; Collection aList =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new <b>ArrayList</b>(aTree);

<b>Listing 3</b></pre>
</td>
</tr>
</table>

<p>The objective of this program is to compare the times required to search
for and find an element in each of the collections.&nbsp; Thus, we need
a target element to search for.
<p>The code in Listing 4 below extracts a value near the center of the
<b>ArrayList</b> object using an index to find and extract the value.&nbsp;
This is a very fast operation on a <b>List</b> object.&nbsp; This value
is saved in <b>testVal</b> to be used later for test purposes.
<p>Note that the reference to the <b>ArrayList</b> object was saved as
type <b>Collection</b> in Listing 3 above.
<p>Note also that it was necessary to cast that reference to type <b>List</b>
in Listing 4 below in order to invoke the <b>get</b> method on the reference.&nbsp;
This is because the <b>Collection</b> interface does not declare a method
named <b>get</b>.&nbsp; Rather, the <b>get</b> method is added to the <b>List</b>
interface to define a more specialized form of collection.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; Object testVal =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((<b>List</b>)aList).<b>get</b>(size/2);

<b>Listing 4</b></pre>
</td>
</tr>
</table>

<p>The code in Listing 5 below invokes the <b>contains</b> method to search
for the test value in each of the collections.&nbsp; It uses the system
clock to measure the time required to find the element in each case.&nbsp;
I will assume that you understand how to use the <b>Date</b> class for
this purpose, and won't provide a detailed explanation.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; long start = new Date().getTime();
&nbsp;&nbsp;&nbsp; boolean found =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>aList.contains(testVal)</b>;
&nbsp;&nbsp;&nbsp; long stop = new Date().getTime();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found + " " + (stop - start));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; start = new Date().getTime();
&nbsp;&nbsp;&nbsp; for(int x = 0; x &lt; 10000; x++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found = <b>aTree.contains(testVal)</b>;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; stop = new Date().getTime();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found + " " + (stop - start));

&nbsp; }//end doIt()

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>The output from the program was:
<p><b><tt>true 171<br>
true 30</tt></b>
<p>The first line of output applies to the <b>ArrayList</b> object, and
the second line applies to the <b>TreeSet</b> object.
<p>As we would expect, the test value was successfully found in both cases;
hence the display of true in both cases.
<p><b><font color="#FF0000">Time required to search ArrayList</font></b>
<p>The output indicates that approximately 171 milliseconds were required
to find the test value in the <b>ArrayList</b> object.
<p><b><font color="#FF0000">Time required to search TreeSet object</font></b>
<p>On the other hand, the time required to find the test value in the <b>TreeSet</b>
object was so small that it wasn't even measurable within the granularity
of the system clock <i>(other experiments have caused me to believe that
the granularity of the system clock on this machine is at least ten milliseconds)</i>.&nbsp;
Hence, the original reported time required to find the test value in the
<b>TreeSet</b> object was zero.
<p>In order to get a measurable time value to search the <b>TreeSet</b>
object, I had to wrap the invocation of the <b>contains</b> method in a
for-loop and search for the same value 10,000 times in succession.&nbsp;
Thus, the time required to find the test value in the <b>TreeSet</b> object
was approximately 0.0030 milliseconds as compared to 171 milliseconds for
the <b>ArrayList</b> object.<i></i>
<p><i>(I'll let you do the arithmetic to see if this makes sense in terms
of the expected time cost to search the two different types of objects.&nbsp;
Don't forget the extra overhead of the for-loop.)</i>
<p><b><font color="#FF0000">Different implementations</font></b>
<p>This is a graphic demonstration that even though both objects can be
treated as type <b>Collection</b>, and the <b>contains</b> method can be
invoked on either object in a polymorphic manner, the actual implementations
of the two objects and the implementations of the <b>contains</b> methods
in those two objects are different.
<p>Each type of collection has advantages and disadvantages, depending
on your needs.
<p><b><font color="#FF0000">Polymorphic behavior applies</font></b>
<p>The important point is that if you receive a reference to the collection
object as type <b>Collection</b>, you can invoke the <b>contains</b> method
on that reference without regard to the underlying structure of the collection
object.&nbsp; This is because <i>polymorphic</i> behavior applies.
<p>Very briefly, polymorphic behavior means that the actual method that
is executed is the appropriate method for that type of object regardless
of the type of the reference to the object.&nbsp; This is one of the great
advantages of using the Java Collections Framework and passing collection
objects among methods as interface types.
<p><b><font color="#FF0000">Sorting algorithms</font></b>
<p>Some of the implementations of the Java Collection Framework maintain
their elements in a random order, and other implementations maintain their
elements in a sorted order.&nbsp; Thus, the framework also provides sorting
algorithms.&nbsp; However, the sorting algorithms used to maintain the
order of the collections are not exposed in the way that the search algorithm
is exposed <i>(via the contains() method).
</i>Rather, the sorting algorithms
are implicit in those implementations that need them, and are absent from
those implementations that don't need them.
<p><b><font color="#FF0000">Now for a little quiz</font></b>
<p>Let's see if you are still awake.&nbsp; Select the words in one pair
of parentheses in the following statement that causes the statement to
be true.
<p>The interfaces in the Collections Framework make it possible to manipulate
the contents of collections in a manner that is <i>(dependent on)</i> 
<i>(independent
of)</i> the underlying implementation of each collection.
<p><b><font color="#FF0000">And the answer is ...</font></b>
<p>The interfaces in the Collections Framework make it possible to manipulate
the contents of collections in a manner that is independent of the underlying
implementation of each collection.&nbsp; That is the beauty of basing the
framework on interfaces that declare polymorphic methods.
<p>I placed this question here to drive home the point that the methods
declared in the <b>Collection</b> interface can be invoked on collection
objects in a <i>polymorphic</i> manner.
<p>That is to say, as a user of an object instantiated from a class that
properly implements the <b>Collection</b> interface, you can invoke the
methods declared in that interface on a reference to the object and be
confident that the actual method that is invoked will be the version that
is appropriate for the class from which the object was instantiated.&nbsp;
This is polymorphic behavior.
<p>In the event that you need to invoke a method that is not declared in
the <b>Collection</b> interface <i>(such as the get() method in Listing
4 above),</i> you can pass the reference as one of the more specialized
sub-interfaces of <b>Collection</b>, such as <b>Set</b>.
<p><b><font color="#FF0000">Benefits of using the Collections Framework</font></b>
<p><a href="http://java.sun.com/docs/books/tutorial/index.html">The Java
Tutorial</a> from Sun lists and explains the following benefits of using
the Java Collections Framework.
<ul>
<li>
It reduces programming effort</li>

<li>
It increases program speed and quality</li>

<li>
It allows interoperability among unrelated APIs</li>

<li>
It reduces the effort to learn and use new APIs</li>

<li>
It reduces effort to design new APIs</li>

<li>
It fosters software reuse</li>
</ul>
For a detailed explanation of these benefits, I am simply going to refer
you directly to this excellent online book.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
So, let's recap some of what we have learned in this and the previous lessons.
<p>The core collection interfaces in the Collections Framework are shown
in Listing 6.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<ul>
<li>
<b><tt>Collection</tt></b></li>

<ul>
<li>
<tt>Set</tt></li>

<ul>
<li>
<tt>SortedSet</tt></li>
</ul>

<li>
<tt>List</tt></li>
</ul>

<li>
<b><tt>Map</tt></b></li>

<ul>
<li>
<tt>SortedMap</tt></li>
</ul>
</ul>

<p><br><b><tt>Listing 6</tt></b></td>
</tr>
</table>

<p>The basic purpose of the core collection interfaces in the Java Collections
Framework is to allow collections to be manipulated without regard for
how the collections are implemented, provided of course that the implementations
comply with the contracts.
<p>The framework provides the following nine concrete implementations <i>(classes)</i>
of the interfaces shown in Listing 1:
<ul>
<li>
HashSet</li>

<li>
TreeSet</li>

<li>
LinkedList</li>

<li>
ArrayList</li>

<li>
Vector</li>

<li>
HashMap</li>

<li>
WeakHashMap</li>

<li>
TreeMap</li>

<li>
Hashtable</li>
</ul>
For example, the classes <b>TreeSet</b> and <b>ArrayList</b> are concrete
implementations of the <b>Collection</b> interface as shown in the above
list.&nbsp; <i>(Actually, they are concrete implementations of sub-interfaces
of Collection.&nbsp; JDK 1.3 doesn't provide any direct implementations
of Collection).</i>
<p>A collection object instantiated from the class <b>TreeSet</b> and a
collection object instantiated from the class <b>ArrayList</b> can each
be viewed as being of the interface type <b>Collection</b>.
<p>Methods having the same signatures can be used to manipulate either
collection with confidence that the behavior of the method will be appropriate
for the actual type of collection involved.
<p>The framework also provides the following incomplete implementations
of the core interfaces:
<ul>
<li>
AbstractSet</li>

<li>
AbstractList</li>

<li>
AbstractMap</li>
</ul>
The purpose of these implementations is to provide you with a starting
point for defining your own concrete implementations for more specialized
collections.
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson, I will dig a little deeper into the details of the
Java Collections Framework.&nbsp; I will begin the next lesson with a sample
program that illustrates the basic purpose of the <i>core collection interfaces</i>,
which is to allow collections to be manipulated without regard for how
the collections are implemented, as long as the implementation meets the
contract of the interface.
<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2000, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor and private consultant whose primary focus is a
combination of Java and XML. In addition to the many platform-independent
benefits of Java applications, he believes that a combination of Java and
XML will become the primary driving force in the delivery of structured
information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
