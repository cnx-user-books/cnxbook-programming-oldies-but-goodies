<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->Ordered Linked-Lists<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 75, Revised 01/16/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#ordered list">Ordered List</a></li>

<li><a href="#sample program">Sample Program</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#test program">Test Program</a></li>

<li><a href="#program listing">Program Listing</a></li></ul>

<li><a href="#is a versus has a">Is A versus Has A</a></li></ul>

<hr align=left width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
This lesson was originally written on December 18, 1997 using the JDK 1.1.3
download and documentation package.

<p>Students in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
classes will be responsible for understanding all of the material in this
lesson.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
A previous lesson developed a general-purpose linked-list class, from which
a <i>queue </i>class and a <i>stack </i>class were subclassed. That lesson
promised a subsequent lesson in which the linked-list class would be expanded
to include the ability to create and maintain <u>ordered lists</u>.

<p>The watchword these days is<i> reuse, don't reinvent</i>. Therefore,
this lesson is not provided to encourage you to reinvent data structures
that can be found in class libraries. Rather, this lesson is provided primarily
as a review of much of what you should have learned in the <b><u>Introductory
Java Programming</u></b> course at ACC.

<p>If you are enrolled in Prof. Baldwin's <b><u>Intermediate Java Programming</u></b>
course and have difficulty with any of the material in this lesson, you
probably are not well-prepared for the Intermediate course.

<p>While the program in this lesson does review much of what you should
have learned in the Introductory course, there is much more that you should
have learned that it doesn't review (Java arrays for example). Therefore,
a complete understanding of the material in this lesson does not provide
assurance that you learned everything that you should have learned in the
Introductory course. In other words, an understanding of the material in
this lesson is a "necessary but not sufficient" indicator of your readiness
for the Intermediate course.
<center><h2><a name="ordered list"></a><font color="#ff0000">Ordered List</font></h2></center>
An ordered list is one in which the data is maintained in some specified
order: numeric, alphabetic, alphanumeric, etc., and can be stored and retrieved
on the basis of some <i>key</i> value.

<p>Because of its poor random-access capabilities, a linked-list is not
a particularly good underlying structure for an ordered list. However,
the development of an ordered list using a linked-list does provide some
good illustrations of important Java programming concepts (such as the
use of interface types). Therefore, we will develop an ordered list using
an upgraded version of our general-purpose linked list class (named <b>RawList</b>)
that we developed in an earlier lesson.
<center><h2><a name="sample program"></a><font color="#ff0000">Sample Program</font></h2></center>
This program upgrades the general-purpose linked-list that was developed
in an earlier lesson by adding an interface and several new methods. Only
the new material will be reviewed here. You are referred to the earlier
lesson for a review of the original material.

<p>This upgraded general-purpose linked-list is then subclassed to provide
the ability to create objects that will manage an <u>ordered list</u>.

<p>The data structures so produced operate with objects of the generic
type <b>Object </b>and therefore, can be used to accommodate <u>any type
of Java object</u> so long as that object is instantiated from a class
that <u>implements the required interface</u>.

<p>Note that the program in the previous lesson did not require implementation
of an interface. This new requirement for an interface comes about as a
result of the need to perform comparisons between objects to determine
which is greater, less than, equal to, etc. The interface is used to require
the class from which data objects are instantiated to provide methods by
which objects of the class can compare themselves against other objects
of the same class.

<p>As I mentioned in the earlier lesson, in developing this program, I
didn't give much thought to access control: <b>public</b>, <b>private</b>,
<b>protected</b>, and <i>package</i>. It is not likely that you would want
to use this code for any serious purpose, but if you do, you will need
to review and probably upgrade the access control specifiers that were
used.

<p>This program did not receive the kind of exhaustive testing that should
be applied to a program of this complexity, so if you do elect to use it
for any serious purpose, you should test it thoroughly before using it.

<p>The testing that was performed was performed using JDK 1.1.3 under Win95.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
As is often the case, we will break the program up into a set of interesting
code fragments and discuss those fragments individually. A listing of the
complete program is provided at the end of the lesson so that you can see
all of the interesting code fragments in context.

<p>The purpose of this program is to upgrade the program named <b>List02</b>
to add the capability to create and maintain ordered lists. The upgraded
version of the program is named <b>List03</b>.

<p>In addition to methods carried forward from the earlier version of the
program, methods are added to the <b>RawList </b>class to support the <u>insertion
and removal</u> of nodes interior to the list on the basis of the value
of the data object encapsulated in the node.

<p>Insertion is done on an <u>ascending</u> alphanumeric basis.

<p>The insertion of nodes having <u>duplicate data</u> values is <u>not
allowed</u>. An attempt to insert a duplicate data object causes an exception
to be thrown.

<p>The <b>RawList </b>class is then subclassed to provide a specialized
class for instantiating objects of type <b>OrderedList</b>.

<p>The prior ability to create <i>Stack </i>and <i>Queue </i>objects was
<u>not removed</u> from the program. In all cases, the data structures
so produced operate with objects of the generic type <b>Object</b>, and
can accommodate objects of any class that <u>implements the interface</u>
named <b>List03A</b>.

<p>For an understanding of how this degree of generality is accomplished,
it is suggested that you review Lesson 46 in the Introductory tutorial
which is a lesson on interfaces.

<p>A test program is provided that tests only the <b>OrderedList</b> capability
of the program. The output from running this program is shown in the comments
of the complete program listing at the end of the lesson.

<p>As mentioned above, this data structure can accommodate any object that
is instantiated from a class that implements the interface named <b>List03A</b>.
The first interesting code fragment is the definition of that interface.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>public <b>interface List03A</b>{
&nbsp; boolean <b>LTE</b>(Object inObject);
&nbsp; boolean <b>LT</b>(Object inObject);
&nbsp; boolean <b>GTE</b>(Object inObject);
&nbsp; boolean <b>EQ</b>(Object inObject);&nbsp;&nbsp;&nbsp;
}//end List03A</pre></td></tr></table>
As you can see, this interface declares four methods that <u>must be defined</u>
by any class that implements the interface. The purpose of these methods
is to compare two objects of the interface type to determine which is greater,
equal, less than, etc.

<p>The names of the methods are indicative of the type of comparison required.
For example the method named <b>GTE</b> should compare two objects to determine
if the object on which the method is invoked is <u>greater than or equal</u>
to the object passed as a parameter. (This is the point where C++ programmers
will be wishing for <u>overloaded operators</u> which are not supported
by Java).

<p>In particular, this program depends on methods defined in the class
of the object being maintained in the ordered list to compare two objects
and report back which is greater, less than, etc..

<p>As mentioned earlier, a more-detailed discussion of this kind of operation
was provided in Lesson 46 on interfaces. If you have any confusion or questions
in this regard, you should refer back to that lesson.

<p>The next interesting code fragment shows the definition of the test
class that was used to test this program. In particular note how this class
<u>implements the required interface</u>.

<p>This set of data structures is designed to accommodate objects of any
class that implements the interface named <b>List03A</b>. This class named
<b>TestClass </b>implements that interface. Therefore, objects of this
class are appropriate for use with this set of data structures.

<p>If you modify the definition of this class, you may need to <u>redefine
the methods</u> in the new class to make them appropriate for your new
class.

<p>Note that the comparison methods in this class receive a parameter which
is an object of type <b>Object </b>and then <u>cast that object</u> to
type <b>TestClass </b>in order to be able to access the instance variable
in the object. This methodology is explained more fully in Lesson 46 on
Interfaces.

<p>An object of this class contains only <u>a single instance variable</u>
that is an object of type <b>String</b>, but there is no reason that it
could not contain many instance variables such as <i>first name, last name,
social security number, age, weight, height, marital status</i>, etc.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>TestClass implements List03A</b>{
&nbsp; String <b>data</b>;
&nbsp;&nbsp;
&nbsp; TestClass(String data){//<b>constructor
</b>&nbsp;&nbsp;&nbsp; this.data = data;
&nbsp; }//end constructor
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //Compare for <b>less than or equal
</b>&nbsp; public boolean <b>LTE</b>(Object inObject){
&nbsp;&nbsp;&nbsp; int result =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data.<b>compareTo</b>(((TestClass)inObject).data);
&nbsp;&nbsp;&nbsp; if(result &lt;= 0) return true;//is LTE
&nbsp;&nbsp;&nbsp; else return false;//is not LTE
&nbsp; }//end LTE
&nbsp;&nbsp;
&nbsp; //...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}//end TestClass</pre></td></tr></table>
However, whatever the class contains in terms of instance variables, the
designer of the class <u>must determine</u> how two objects of the class
are to be compared in each required method.

<p>For example, if the class contained both the last name and the age,
it might be appropriate to use the last name variable to determine which
is greater, and it might be just as appropriate to use the age variable
for that purpose. It might be appropriate to <u>combine two or more instance
variables</u> such as last name and first name for that purpose.

<p><u>The designer of the class must decide</u>. The linked-list program
depends on the methods of the class to provide that kind of information
whenever it is needed.

<p>In this case, for the sake of simplicity, we use the single <b>String</b>
data member to compare objects of the class, and we use the <b>compareTo()</b>
method of the <b>String</b> class to assist us in that regard. Only one
of the four comparison methods is shown here because they are all very
similar.

<p>The class also contains an overridden <b>toString()</b> method, but
it is not shown here because there is nothing new about it.

<p>That brings us to the new method that <u>inserts a new node</u> into
the linked-list on the basis of the <u>value of the data object</u> encapsulated
into the node. As mentioned earlier, nodes are inserted into the list in
ascending order.

<p>This is a large method so we will discuss it in parts. The first interesting
part is the method signature and the initial test to determine if the list
is empty. If it is determined that the list is empty, the node being inserted
becomes the first node in the list.

<p>Note that this method receives a new data object as type <b>Object</b>.
Note also that it <i>throws</i> an exception of type <b>Excep</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; void <b>inByValue</b>(<b>Object </b>dataObj) <b>throws Excep</b>{
&nbsp;&nbsp;&nbsp; if(isEmpty()) //List is empty, make this the first node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = getNode(dataObj);</pre></td></tr></table>
This method does not allow the insertion of duplicate data objects, and
throws an exception if an attempt is made to insert a data object that
matches a data object already encapsulated in one of the nodes.

<p>The next interesting code fragment throws an exception if the new node
matches the first or last nodes in the list.

<p>Note the requirement to <i>cast </i>the incoming object of type <b>Object
</b>to the type of the interface in order to make it possible to access
the method named <b>EQ </b>which is declared in the interface and is an
instance method of the incoming object.

<p>You should recall that when the exception object is thrown, execution
of the code in the method is terminated immediately and the system starts
searching for an exception handler whose type matches the type of the exception.
Control is transferred directly to that exception handler, bypassing any
remaining code in the method.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; else if(((<b>List03A</b>)dataObj).<b>EQ</b>(firstNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep("Duplicate key value: " + dataObj);
&nbsp;&nbsp;&nbsp; else if(((<b>List03A</b>)dataObj).<b>EQ</b>(lastNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep("Duplicate key value: " + dataObj);</pre></td></tr></table>
Next we need to handle the two cases where the new data object is <u>less
than the first</u> data object in the list or <u>greater than the last</u>
data object in the list. If either of these two cases is true, we encapsulate
the new data object in a node and <u>attach</u> the node to the <u>front
or the back</u> of the list.

<p>Also note that even though we used the GTE method to test for greater
than the last object in the list, the object cannot possibly be equal to
the last object because we eliminated that possibility earlier. If you
go back and review the interface definition, you will note that it doesn't
include a declaration for a greater than (GT) method. So, we saved a little
programming effort here, but that may have been <u>false economy</u> since
it definitely makes the code less self-documenting and possibly more <u>difficult
to maintain</u>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).<b>LT</b>(firstNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toFront(dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).<b>GTE</b>(lastNode.dataObj))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toBack(dataObj);</pre></td></tr></table>
Having reached the point where we were not able to attach the new data
object to either end of the list, we must encapsulate the new data object
in a node object and <u>search the interior</u> of the list to <u>find
the spot</u> where it fits on the basis of its value. Having found that
spot, we must <u>rewire the references</u> so as to insert it at that spot.

<p>Along the way, we need to be <u>watching out for duplicate values</u>
and throw an exception if a duplicate if found.

<p>As in previous methods that needed to traverse the list, we will use
a <b>while </b>loop to traverse the list until the appropriate spot is
found. We will then insert it, rewiring the reference variables as required.

<p>Recall that the occurrence of a <b>null </b>reference to the next node
indicates that the <u>end of the list</u> has been reached. Since we have
already tested to see if we could hook it onto either end, we should find
an appropriate place to insert it <u>before reaching the end of the list</u>.

<p>After <u>encapsulating</u> the new data object in a node object and
<u>saving</u> a reference to the node object in <b>newPtr</b>, we drop
into our <b>while</b> loop.

<p>During each iteration of the loop, we first <u>test for duplicate</u>
and throw an exception of a duplicate is discovered.

<p>Then we test to see if we have <u>found the spot</u> to insert the new
node so that it will be greater than one node and less than the next node.
Again note that even though we are using <b>GTE</b>, it cannot be equal
because we eliminated that possibility when we tested for the duplicate.

<p>Once we find the <u>correct spot</u>, we <u>rewire the reference variables</u>
and <b>break </b>out of the loop. By now you should have no difficulty
understanding the rewiring process.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>newPtr </b>= <b>getNode</b>(dataObj);//encapsulate object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>currentRefToNode </b>= firstNode;//temp reference

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>while</b>(currentRefToNode.nextNode != <b>null</b>){&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>((((List03A)dataObj).<b>EQ</b>(//<b>test for duplicate
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode.dataObj)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep("Duplicate key value: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + dataObj);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>((((List03A)dataObj).<b>GTE</b>(//<b>is this the spot?
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.dataObj)) <b>&amp;&amp;&nbsp;
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((List03A)dataObj).<b>LT</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode.dataObj)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {//<b>Found the spot</b>.&nbsp; Rewire the reference variables
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newPtr.nextNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode = newPtr;
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>; //terminate loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<b>Didn't find the spot</b>.&nbsp; Update reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and go back to the top of the while loop.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>else currentRefToNode = currentRefToNode.nextNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; }//end else have to find a spot and insert in middle
&nbsp; }//end inByValue()</pre></td></tr></table>
If we <u>didn't find the spot</u> on the current iteration, we need to
update <b>currentRefToNode</b>, go back to the top of the loop, and try
again.

<p>There should be <u>no circumstance</u> where the <b>while</b> loop in
the above method would terminate naturally.

<p>Before entering the loop, we confirmed that the value of the data object
is <u>bracketed</u> by the values of the data objects encapsulated in the
<u>first</u> and <u>last</u> nodes in the list. That means that we should
either <u>find a duplicate </u>(in which case we throw an exception) or
should <u>find a spot</u> to insert the new node (in which case we <b>break
</b>out of the loop).

<p>This finishes our discussion of the method that is used to insert data
objects by value into the linked list.

<p>The next interesting code fragment is the method that is used to <u>remove
a data object</u> from the linked list by <u>matching the value of a key</u>
data object with the value of a data object already encapsulated in a node
in the list.

<p>Obviously this method may <u>fail to find a match</u> in which case
we will <u>throw an exception</u>.

<p>Again, this is a fairly long method so we will discuss it in parts.
The first interesting part is the signature and the test for an empty list.
As usual, we will throw an exception if the list is empty.

<p>To be repetitive, note that this method receives a data object as the
generic type <b>Object</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; Object <b>removeByValue</b>(<b>Object </b>dataObj)&nbsp; <b>throws Excep</b>{
&nbsp;&nbsp;&nbsp; if(this.<b>isEmpty</b>()) //List is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep("Empty List in removeByValue");</pre></td></tr></table>
As usual, if the list is <u>not empty</u>, the next code fragment deals
with the <u>trivial cases</u> of the key value <u>matching</u> the value
of the data object encapsulated in either the <u>first</u> or the <u>last</u>
node. By now you should have code of this variety memorized.

<p>It will be useful to point out that this code fragment makes use of
methods that were developed in the previous lesson (<b>fetchFromFront</b>
and <b>fetchFromBack</b>) so if you just tuned in at this point, you may
need to go back and review that lesson.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; else{&nbsp; //Test for a <b>match on the front node
</b>&nbsp;&nbsp;&nbsp; if(((List03A)dataObj).<b>EQ</b>(firstNode.dataObj)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return </b>fetchFromFront();//found match on front node
&nbsp;&nbsp;&nbsp; //Test for <b>match on back node</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else if(((List03A)dataObj).EQ(lastNode.dataObj)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return </b>fetchFromBack();//found match on back node</pre></td></tr></table>
Later in the discussion, we will indicate that our program would probably
be <u>more efficient</u> if we were to test at this point to determine
if the value of the data object is <u>bracketed</u> by the values of the
data objects encapsulated by the <u>first</u> and <u>last</u> nodes, and
to <u>throw an exception</u> if it is <u>not bracketed</u>. This would
probably eliminate a lot of needless searching, but we didn't recognize
that need and didn't implement that capability when we wrote the program.

<p>If we don't find a match at the front or the back, we will search for
a match interior to the list. As usual, we will use a <b>while </b>loop
to traverse the list searching for a match. This time, however, we <u>could
hit the end</u> of the list indicated by <b>lastNode </b>if no match is
found. (This possibility would have been eliminated if we had done the
bracket thing described above.)

<p>By now you should have no difficulty understanding how this code works.

<p>There are two different ways that we can decide that there is no match.

<p>If we <u>pass the appropriate point</u> in the list based on value and
haven't found a match, we will throw an exception. This prevents us from
searching the entire list when we can make an early determination that
a match doesn't exist.

<p>Also, if the value is <u>not bracketed</u> by the values of the end
points of the list, we could <u>hit the end</u> of the list without finding
a match, which will also cause us to throw an exception.

<p>A <u>more efficient approach</u> would be to test for the bracket condition
before beginning the search of the interior of the list and throwing an
exception if the value were not bracketed by the end points of the list.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node <b>currentRefToNode </b>= firstNode,<b>tempRefToNode</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>while</b>( <b>currentRefToNode.nextNode != lastNode</b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //test to see if value of dataObj <b>has been passed
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(((<b>List03A</b>)dataObj).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>LT</b>(currentRefToNode.dataObj))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<b>Can't find a match</b>, throw exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "No match found in removeByValue");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test to see if the dataObj <b>in the next node</b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>matches</b>.&nbsp; If so, delete next node.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(((List03A)dataObj).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>EQ</b>(<b>currentRefToNode.nextNode.dataObj</b>)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<b>Save ref</b> to node being removed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>tempRefToNode </b>= currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<b>Wire around the next node</b> to remove it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((currentRefToNode.nextNode).nextNode)</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return data object from saved node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return </b>tempRefToNode.dataObj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if where match was found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust references to <b>move to next node
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b> currentRefToNode = currentRefToNode.nextNode</b>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test to see if the next node is the last node.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>( currentRefToNode.nextNode == <b>lastNode </b>){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "No match found in removeByValue");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}}}//end else
&nbsp;&nbsp;&nbsp; <b>throw </b>new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Should never get this far before returning\n");
&nbsp; }//end function</pre></td></tr></table>
As was the case in the earlier lesson where we needed to remove the last
node in the list, in this case we need to be <u>looking ahead</u> to see
if the key value matches the data object encapsulated in the <u>next</u>
node. Since this list is a one-way street, we can't go backwards, so we
need to recognize the match before we are standing on the node to be removed.

<p>Once we determine that the next node is a match, we <u>save a reference</u>
to that node in <b>tempRefToNode </b>for use later in our <b>return</b>
statement. Then we <u>wire around the node</u> to remove it from the list
and <u>return</u> a reference to the data object encapsulated in the node.

<p>If the current iteration doesn't produce a match, we <u>update the reference
</u>named <b>currentRefToNode</b> so as to move us to the next node on
the next iteration.

<p>However, before returning to the top of the <b>while</b> loop for the
next iteration, we need to <u>test</u> to see if the <u>next node is the
last node</u>, and if so we conclude that there is no match and throw an
exception.

<p>Finally, as a <u>safety valve</u>, we throw an exception if control
ever reaches the end of the method without either returning the matching
data object, or throwing an exception, because this should never happen.

<p>And that <u>concludes the discussion</u> of the method to remove a node
based on matching a key value.

<p>The next interesting code fragment is the definition of the class used
to subclass the <b>RawList </b>class in such a way as to create and maintain
a list that keeps the data objects in <u>ascending alphanumeric order</u>
in the list.

<p>This is accomplished by using the methods of the <b>RawList</b> class
to insert new nodes by the value of the data encapsulated in the node and
removing nodes by value.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class <b>OrderedList </b>extends RawList{
&nbsp;&nbsp;
&nbsp; public void <b>add</b>(Object obj) throws Excep{
&nbsp;&nbsp;&nbsp; //add a new object to the list by value
&nbsp;&nbsp;&nbsp; this.<b>inByValue</b>(obj);
&nbsp; }//end add()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public Object <b>remove</b>(Object obj) throws Excep{
&nbsp;&nbsp;&nbsp; //remove and return an object from the list by value
&nbsp;&nbsp;&nbsp; return this.<b>removeByValue</b>(obj);
&nbsp; }//end remove&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void <b>printOrderedList</b>(){
&nbsp;&nbsp;&nbsp; this.<b>printRawList</b>();//use the existing print capability
&nbsp; }//end printOrderedList()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean <b>isOrderedListEmpty</b>(){
&nbsp;&nbsp;&nbsp; return this.<b>isEmpty</b>();//use the existing empty test
&nbsp; }//end isOrderedListEmpty&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
}//end OrderedList</pre></td></tr></table>
As we saw in the previous lesson where we created the <i>queue </i>and
<i>stack </i>classes, once we have the properly designed <b>RawList</b>
class, extending that class to produce our <b>OrderedList</b> class is
so simple that it is <u>almost trivial</u>.

<p>This class makes it possible to <b>add</b> and <b>remove</b> objects
from the list based on their value, and also to <u>print the list</u> and
to determine <u>if it is empty</u>. Except for the class header and the
method signatures, <u>only four lines of code</u> were required to accomplish
this.

<p>We will note, however, that a <u>significant programming effort</u>
was required to upgrade the <b>RawList</b> class to make this possible.
<center><h3><a name="test program"></a><font color="#ff0000">Test Program</font></h3></center>
A method named <b>test()</b> is provided with this program to test the
operation of the <b>OrderedList</b> class.You can view that code, along
with the output produced by invoking the test method, in the program listing
in the next section.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
A complete listing of the program follows so that you can view the entire
program in context.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/*File List03.java
Copyright 1997, R.G.Baldwin

The purpose of this program is to upgrade the program named
List02.java to add the capability to create and maintain
ordered lists.

In addition to methods carried forward from the earlier
version of the program, methods are added to the RawList&nbsp;
class to support the insertion and removal of nodes&nbsp;
interior to the list on the basis of the value of the data
object encapsulated in the node.&nbsp;

Insertion is done on an ascending alphanumeric basis. The&nbsp;
insertion of nodes having duplicate data values is not&nbsp;
allowed.&nbsp; An attempt to insert a duplicate value causes
an exception to be thrown.

The RawList class is then subclassed to provide a&nbsp;
specialized data structures for creating Ordered List&nbsp;
objects.

The prior ability to create Stack and Queue objects was
not removed from the program.
&nbsp;&nbsp;
In all cases, the data structures so produced operate
with objects of the generic type Object, and can&nbsp;
accommodate objects of any class that implements the
interface named List03A.

For an understanding of how this degree of generality is&nbsp;
accomplished, it is suggested that you review Lesson #46&nbsp;
which is a lesson on interfaces.

The test program provided in this program tests only the
Ordered List capability of the program.&nbsp; The output from&nbsp;
running this program is shown below:
//------------------------------------------

Test the ordered list
Put some data objects in an ordered list
Try to put duplicate object in ordered list
Exception: Duplicate key value: cd
The ordered list contains:
ab
cd
ef
gh
ij
kk
kl

Remove some objects from ordered list
Removed: kl
Removed: ab
Removed: gh
The ordered list now contains:
cd
ef
ij
kk
Try to remove object with no match, cf
Exception: No match found in removeByValue
Try to remove another object with no match, kj
Exception: No match found in removeByValue
End of test
//------------------------------------------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This program was tested using JDK 1.1.3 under Win95.
**********************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;
//=======================================================//

/*This program implements the following kinds of data
structures:&nbsp; unordered linked-list, ordered linked-list,
stack, and queue.

This set of data structures is designed to accommodate
objects of any class that implements the interface named
List03A.
&nbsp;
This class named TestClass implements that interface.&nbsp;&nbsp;
Therefore, objects of this class are appropriate for use&nbsp;
with this set of data structures.
&nbsp;
If you modify the definition of this class, you will need&nbsp;
to redefine the methods in the new class to make them&nbsp;
appropriate for your new class.&nbsp; The compare methods are&nbsp;
required for use by the methods in the data structures&nbsp;
that need to be able to compare two objects for less&nbsp;
than, equal, etc.&nbsp; Generally, these are the methods that
support the ordered list structure.

Note that the comparison methods in this class receive
a parameter which is an object of type Object and then
cast that object to type TestClass in order to be able
to access the instance variable in the object.&nbsp; This
methodology is explained more fully in Lesson #46 on
Interfaces.
---------------------------------------------------------*/

class TestClass implements List03A{
&nbsp; //An object of this class contains a single instance
&nbsp; // variable which is an object of type String.
&nbsp; String data;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; TestClass(String data){//constructor
&nbsp;&nbsp;&nbsp; this.data = data;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public String toString(){//overridden toString() method
&nbsp;&nbsp;&nbsp; return (data);
&nbsp; }//end toString()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //Compare for less than or equal
&nbsp; public boolean LTE(Object inObject){
&nbsp;&nbsp;&nbsp; int result =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data.compareTo(((TestClass)inObject).data);
&nbsp;&nbsp;&nbsp; if(result &lt;= 0) return true;//is LTE
&nbsp;&nbsp;&nbsp; else return false;//is not LTE
&nbsp; }//end LTE
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Compare for less than
&nbsp; public boolean LT(Object inObject){
&nbsp;&nbsp;&nbsp; int result =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data.compareTo(((TestClass)inObject).data);
&nbsp;&nbsp;&nbsp; if(result &lt; 0) return true;//is LT
&nbsp;&nbsp;&nbsp; else return false;//is not LT
&nbsp; }//end LT
&nbsp; //-----------------------------------------------------//

&nbsp; //Compare for greater than or equal
&nbsp; public boolean GTE(Object inObject){
&nbsp;&nbsp;&nbsp; int result =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data.compareTo(((TestClass)inObject).data);
&nbsp;&nbsp;&nbsp; if(result >= 0) return true;//is GTE
&nbsp;&nbsp;&nbsp; else return false;//is not GTE
&nbsp; }//end GTE
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Compare for equal
&nbsp; public boolean EQ(Object inObject){
&nbsp;&nbsp;&nbsp; int result =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data.compareTo(((TestClass)inObject).data);
&nbsp;&nbsp;&nbsp; if(result == 0) return true;//is equal
&nbsp;&nbsp;&nbsp; else return false;//is not equal
&nbsp; }//end EQ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}//end TestClass
//=======================================================//

/*This class is the controlling class which is used to test
the data structures developed in this lesson.&nbsp; This
class contains a method named test() which designed to
exercise the capabilities of the unordered linked-list,
stack, queue, and ordered list.
---------------------------------------------------------*/

class List03{//controlling class
&nbsp; public static void main(String[] args){//main
&nbsp;&nbsp;&nbsp; List03 obj = new List03();//instantiate this object&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; obj.test();//invoke the method named test()
&nbsp; }//end main
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; void test(){
&nbsp;&nbsp;&nbsp; System.out.println("\nTest the ordered list");
&nbsp;&nbsp;&nbsp; //Instantiate an OrderedList object
&nbsp;&nbsp;&nbsp; OrderedList myOrderedList = new OrderedList();
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Put some data objects in an ordered list");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("cd"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("ij"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("ab"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("kl"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("kk"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("ef"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("gh"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Try to put duplicate object in ordered list");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myOrderedList.add(new TestClass("cd"));
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}

&nbsp;&nbsp;&nbsp; System.out.println("The ordered list contains:");
&nbsp;&nbsp;&nbsp; myOrderedList.printOrderedList();

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nRemove some objects from ordered list");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + myOrderedList.remove(new TestClass("kl")));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + myOrderedList.remove(new TestClass("ab")));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + myOrderedList.remove(new TestClass("gh")));
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}

&nbsp;&nbsp;&nbsp; System.out.println("The ordered list now contains:");
&nbsp;&nbsp;&nbsp; myOrderedList.printOrderedList();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Try to remove object with no match, cf");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + myOrderedList.remove(new TestClass("cf")));
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Try to remove another object with no match, kj");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Removed: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + myOrderedList.remove(new TestClass("kj")));
&nbsp;&nbsp;&nbsp; }catch(Excep e){System.out.println("Exception: " + e);}

&nbsp;&nbsp;&nbsp; System.out.println("End of test");
&nbsp; }//end test()
}//end controlling class named class02
//=======================================================//
//=======================================================//

//This is the beginning of the classes that are used to
// instantiate several different kinds of data structures.

//=======================================================//
//=======================================================//

//This is a new exception class that is used to instantiate
// exception objects for a variety of different exceptional
// conditions within the data structure methods.

class Excep extends Exception{
&nbsp; String diagnosticData;//put diagnostic data here
&nbsp;&nbsp;
&nbsp; Excep(){//NoArg constructor
&nbsp;&nbsp;&nbsp; diagnosticData = "No diagnostic data provided";
&nbsp; }//end NoArg constructor

&nbsp; Excep(String diagnosticData){//parameterized constructor
&nbsp;&nbsp;&nbsp; this.diagnosticData = diagnosticData;
&nbsp; }//end NoArg constructor
&nbsp;&nbsp;
&nbsp; public String toString(){//override toString()
&nbsp;&nbsp;&nbsp; return diagnosticData;
&nbsp; }//end overridden toString()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Excep
//=======================================================//

//This class is used to instantiate a node in the data
// structure.&nbsp; It contains an embedded object of whatever
// type is passed in as a parameter.&nbsp; The test class
// provide with this program uses objects of the class
// namedTestClass.

class Node{
&nbsp; Object dataObj;&nbsp; //data object is stored here
&nbsp; Node nextNode;//reference to the next node in the RawList
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public Node(Object dataObj){//constructor
&nbsp;&nbsp;&nbsp; this.dataObj = dataObj;//store incoming dataObj
&nbsp; }//end constructor
}//end class Node
//=======================================================//

//Begin definition of the class used to create
//and maintain a raw list
class RawList{
&nbsp; private Node firstNode;&nbsp; //reference to first node
&nbsp; private Node lastNode;&nbsp;&nbsp; //reference to last node

&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Function to allocate memory and return a reference&nbsp;
&nbsp; // variable for a new node.
&nbsp; private Node getNode( Object dataObj)&nbsp; {
&nbsp;&nbsp;&nbsp; //get reference variable to new memory
&nbsp;&nbsp;&nbsp; Node newNode = new Node(dataObj);
&nbsp;&nbsp;&nbsp; return newNode;
&nbsp; }//end getNode()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Method to determine if The structure is empty
&nbsp; boolean isEmpty(){
&nbsp;&nbsp;&nbsp; return firstNode == null;//return true if empty
&nbsp; }//end isEmpty()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Attach a new node to the front of the RawList
&nbsp; void toFront(Object dataObj){
&nbsp;&nbsp;&nbsp; //Encapsulate the incoming object in an object of type
&nbsp;&nbsp;&nbsp; // node and assign it to a local reference variable.
&nbsp;&nbsp;&nbsp; Node newNode = this.getNode(dataObj);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now attach the new node to the front of the list&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = newNode;
&nbsp;&nbsp;&nbsp; else{ //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newNode.nextNode = firstNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = newNode;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toFront()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Attach a new node to the back of the RawList
&nbsp; void toBack(Object dataObj){
&nbsp;&nbsp;&nbsp; //Encapsulate the incoming object in an object of type
&nbsp;&nbsp;&nbsp; // node and assign it to a local reference variable.
&nbsp;&nbsp;&nbsp; Node newNode = this.getNode(dataObj);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now attach the new node to the back of the list&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = newNode;
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode.nextNode = newNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode = newNode;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end toBack()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method inserts a new node into the linked-list
&nbsp; // on the basis of its value.&nbsp; Nodes are assembled into
&nbsp; // the list in ascending order.
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; void inByValue(Object dataObj) throws Excep{
&nbsp;&nbsp;&nbsp; if(isEmpty()) //List is empty, make this the first node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = getNode(dataObj);

&nbsp;&nbsp;&nbsp; //Throw an exception if the new node matches the first
&nbsp;&nbsp;&nbsp; // or last nodes in the list.&nbsp; Duplicate values are
&nbsp;&nbsp;&nbsp; // not allowed in the list.&nbsp; Note the requirement to
&nbsp;&nbsp;&nbsp; // cast the incoming object of type Object to the
&nbsp;&nbsp;&nbsp; // type of the interface in order to make it possible
&nbsp;&nbsp;&nbsp; // to access the method named EQ which is declared in
&nbsp;&nbsp;&nbsp; // the interface and is an instance method of the&nbsp;
&nbsp;&nbsp;&nbsp; // incoming object
&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).EQ(firstNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Duplicate key value: " + dataObj);
&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).EQ(lastNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Duplicate key value: " + dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //If smaller than data in first node, attach to front.
&nbsp;&nbsp;&nbsp; // Note that this process uses the existing method
&nbsp;&nbsp;&nbsp; // to encapsulate the data object in a node object
&nbsp;&nbsp;&nbsp; // attach it to the front of the list.
&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).LT(firstNode.dataObj))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toFront(dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //if greater than or equal (can't possibly be equal
&nbsp;&nbsp;&nbsp; // because that possibility was eliminated above) to
&nbsp;&nbsp;&nbsp; // dataObj in last node, attach at the back.
&nbsp;&nbsp;&nbsp; else if(((List03A)dataObj).GTE(lastNode.dataObj))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toBack(dataObj);

&nbsp;&nbsp;&nbsp; //Didn't attach to either end.&nbsp; Must encapsulate the
&nbsp;&nbsp;&nbsp; // incoming data object in a node object, find a spot&nbsp;
&nbsp;&nbsp;&nbsp; // and insert the node somewhere in the middle of the&nbsp;
&nbsp;&nbsp;&nbsp; // list.
&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Encapsulate the incoming object in an object of&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // type node and assign it to a local reference&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variable.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node newPtr = getNode(dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Create a temp reference and initialize it to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference the front of the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //At this point, we have established that there is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a spot somewhere in the list where the node should
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // be inserted unless the data object is a duplicate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of an existing data object in the list.&nbsp; Use a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // while loop to traverse the list until that spot&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is found.&nbsp; Then insert it, rewiring the reference
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variables as required. The occurrence of a null&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference to the next node indicates that the end
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the list has been reached.&nbsp; Since we have&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // already tested to see if we could hook it onto
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // either end, we should find an appropriate place
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to insert it before reaching the end of the list.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(currentRefToNode.nextNode != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for duplicate values and throw an exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if a duplicate is discovered.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((((List03A)dataObj).EQ(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode.dataObj)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Duplicate key value: "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test to see if this is the spot to insert the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // new node so that it will be greater than one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // node and less than the next node.&nbsp; Again note
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that even though we are using GTE, it cannot
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // be equal because we eliminated that possibility
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // above.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((((List03A)dataObj).GTE(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.dataObj)) &amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((List03A)dataObj).LT(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode.dataObj)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {//Found the spot.&nbsp; Rewire the reference variables
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newPtr.nextNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode = newPtr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; //terminate loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Didn't find the spot.&nbsp; Update reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and go back to the top of the while loop.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else currentRefToNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; }//end else have to find a spot and insert in middle
&nbsp; }//end inByValue()
&nbsp; //-----------------------------------------------------//

&nbsp; //This method is used to remove a node based on a match
&nbsp; // with a key value.&nbsp;&nbsp;
&nbsp; Object removeByValue(Object dataObj)&nbsp; throws Excep{
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //List is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Empty List in removeByValue");
&nbsp;&nbsp;&nbsp; //List is not empty
&nbsp;&nbsp;&nbsp; else{&nbsp; //Test for a match on the front node
&nbsp;&nbsp;&nbsp; if(((List03A)dataObj).EQ(firstNode.dataObj)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fetchFromFront();//found match on front node
&nbsp;&nbsp;&nbsp; //Test for match on back node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else if(((List03A)dataObj).EQ(lastNode.dataObj)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fetchFromBack();//found match on back node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //No match on the front or back.&nbsp; Have to search for
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a match somewhere in the middle of the list.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; else{//have to find it in the middle of the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare temp reference variables
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode,tempRefToNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use a while loop to traverse the list searching
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for a match.&nbsp; This time, we could hit the end
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the list indicated by lastNode if no
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // match is found.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( currentRefToNode.nextNode != lastNode){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //test to see if value of dataObj has been passed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(((List03A)dataObj).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LT(currentRefToNode.dataObj))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Can't find a match, throw exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "No match found in removeByValue");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test to see if the dataObj in the next node&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // matches.&nbsp; If so, delete next node.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(((List03A)dataObj).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQ(currentRefToNode.nextNode.dataObj)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Save ref to node being removed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempRefToNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust ref variable to wire around the next
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // node which is being removed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((currentRefToNode.nextNode).nextNode);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return the saved node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempRefToNode.dataObj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if where match was found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Adjust references to move to next node
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test to see if the next node is the last node.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If so, this means that we can't find a match&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and should throw an exception without letting
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the while loop terminate.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( currentRefToNode.nextNode == lastNode ){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "No match found in removeByValue");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp; throw new Excep(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Should never get this far before returning\n");
&nbsp; }//end function
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to fetch and delete a node from&nbsp;
&nbsp; // the front of the RawList.&nbsp; Note that all objects are
&nbsp; // treated as objects of the generic type Object.
&nbsp; Object fetchFromFront() throws Excep{
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Empty list in fetchFromFront");
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node tempRefToNode = firstNode;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(firstNode == lastNode)//only one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = null; //set both to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else//more than one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Wire around the first node and return it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = firstNode.nextNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempRefToNode.dataObj;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromFront()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to fetch and delete a node from the
&nbsp; // back of the RawList
&nbsp; Object fetchFromBack() throws Excep{
&nbsp;&nbsp;&nbsp; if(this.isEmpty()) //RawList is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Excep("Empty list in fetchFromBack");
&nbsp;&nbsp;&nbsp; else { //RawList is not empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //declare and initialize a local reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node tempRefToNode = lastNode;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(firstNode == lastNode)//only one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstNode = lastNode = null;&nbsp; //set both to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {//more than one node in the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Declare and initialize another local&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The list is a one-way street.&nbsp; The last node can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only be removed by starting at the front and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // walking to the end touching each node along the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // way.&nbsp; Use a while loop to traverse the list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stopping at the node immediately before the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(currentRefToNode.nextNode != lastNode)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Cut the last node loose and set the reference
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the next node in the new last node to null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to indicate the new end of the list.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastNode = currentRefToNode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode.nextNode = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return the data object from the saved last node.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempRefToNode.dataObj;&nbsp; //fetch successful
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end fetchFromBack()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //This method is used to display the contents of the&nbsp;
&nbsp; // RawList object.
&nbsp; void printRawList(){
&nbsp;&nbsp;&nbsp; if(this.isEmpty()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Empty");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Not empty.&nbsp; Declare and initialize a local&nbsp;
&nbsp;&nbsp;&nbsp; // reference variable to the first node in the list
&nbsp;&nbsp;&nbsp; Node currentRefToNode = firstNode;

&nbsp;&nbsp;&nbsp; //Use a while loop to traverse the list&nbsp; displaying
&nbsp;&nbsp;&nbsp; // the data object in each node along the way.
&nbsp;&nbsp;&nbsp; while(currentRefToNode != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("" + currentRefToNode.dataObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRefToNode = currentRefToNode.nextNode;
&nbsp;&nbsp;&nbsp; }//end while
&nbsp; }//end printRawList()
}//end class RawList
//=======================================================//

//The above class was used to provide the raw list which
// serves as a superclass for the following specialized
// subclasses.
//=======================================================//

//This class subclasses the class named RawList in such
// a way as to provide queue behavior.&nbsp; A queue is a&nbsp;
// first-in/first-out structure.&nbsp; This can be accomplished
// by entering data into the back of a RawList object and
// removing it from the front of the object.

//As you can see, this is a very simple class.&nbsp; It simply
// invokes the methods of the RawList class on a selective
// basis.
class MyQueue extends RawList{
&nbsp; public void enqueue(Object obj){
&nbsp;&nbsp;&nbsp; this.toBack(obj);//enqueue data to the back of the list
&nbsp; }//end enqueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public Object dequeue() throws Excep{
&nbsp;&nbsp;&nbsp; //dequeue data from the front of the list
&nbsp;&nbsp;&nbsp; return this.fetchFromFront();
&nbsp; }//end dequeue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void printQueue(){
&nbsp;&nbsp;&nbsp; this.printRawList();//use the existing print capability
&nbsp; }//end printQueue()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean isQueueEmpty(){
&nbsp;&nbsp;&nbsp; return this.isEmpty();//use the existing empty test
&nbsp; }//end isQueueEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyQueue
//=======================================================//

//This class is used to subclass the RawList class in
// such a way as to provide stack behavior.&nbsp; A stack is a
// last-in/first-out structure.&nbsp; This can be accomplished
// by attaching data to the front of the list and
// removing it from the front of the list.
class MyStack extends RawList{
&nbsp; public void push(Object obj){
&nbsp;&nbsp;&nbsp; this.toFront(obj);//attach new data to front of list
&nbsp; }//end push

&nbsp; public Object pop() throws Excep{
&nbsp;&nbsp;&nbsp; //remove new data from the front of the list
&nbsp;&nbsp;&nbsp; return this.fetchFromFront();
&nbsp; }//end pop()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void printStack(){
&nbsp;&nbsp;&nbsp; this.printRawList();//use existing print capability
&nbsp; }//end printStack()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean isStackEmpty(){
&nbsp;&nbsp;&nbsp; return this.isEmpty();//use the existing empty test
&nbsp; }//end isStackEmpty&nbsp;&nbsp;&nbsp;&nbsp;
}//end class MyStack
//=======================================================//

//This class is used subclass the RawList class in such
// a way as to to create and maintain a list that
// keeps the data objects in ascending alphanumeric&nbsp;
// order in the list.&nbsp; This can be accomplished by using
// the existing methods to insert new nodes by the value&nbsp;
// of the data encapsulated in the node and removing&nbsp;
// nodes by value.&nbsp;&nbsp;
class OrderedList extends RawList{
&nbsp;&nbsp;
&nbsp; public void add(Object obj) throws Excep{
&nbsp;&nbsp;&nbsp; //add a new object to the list by value
&nbsp;&nbsp;&nbsp; this.inByValue(obj);
&nbsp; }//end add()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public Object remove(Object obj) throws Excep{
&nbsp;&nbsp;&nbsp; //remove and return an object from the list by value
&nbsp;&nbsp;&nbsp; return this.removeByValue(obj);
&nbsp; }//end remove&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void printOrderedList(){
&nbsp;&nbsp;&nbsp; this.printRawList();//use the existing print capability
&nbsp; }//end printOrderedList()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public boolean isOrderedListEmpty(){
&nbsp;&nbsp;&nbsp; return this.isEmpty();//use the existing empty test
&nbsp; }//end isOrderedListEmpty&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
}//end OrderedList
//=======================================================//</pre></td></tr></table>

<center><h2><a name="is a versus has a"></a><font color="#ff0000">Is A versus Has A</font></h2></center>
As was the case in the previous lesson on link-lists, stacks, and queues,
this program has a major flaw. In particular, it is possible to instantiate
an object of the subclass named <b>OrderedList</b> and to use that object
to invoke methods of the <b>RawList</b> class that violate the <i>ordered</i>
access requirement of the <b>OrderedList</b> class. This is because the
<b>OrderedList</b> class inherits the <b>RawList</b> class making the methods
of the <b>RawList</b> class available to code within the scope of an object
of type <b>OrderedList</b>. Thus, the <b>OrderedList</b> class "<b>is a</b>"
type of <b>RawList</b>.

<p>As before, the solution is a simple one: change the relationship of
<b>OrderedList</b> and <b>RawList</b> from one of <i>inheritance</i> to
one of <i>composition</i>. In other words, change from an "<b>is a</b>"
relationship to a "<b>has a</b>" relationship.

<p>What this means is to eliminate the inheritance relationship, and to
make an instance variable in the <b>OrderedList</b> class of type <b>RawList</b>.
This will <i>hide</i> the methods of the <b>RawList</b> class from other
code within the scope of an <b>OrderedList</b> object, but make those methods
available to code within the methods of the <b>OrderedList</b> class.

<p>Hopefully you now understand the distinction between an inheritance
relationship ("<b>is a</b>") and a composition relationship ("<b>has a</b>").
Correcting the flaw in this program will be left as an exercise for the
student.

<p>-end-<!--end--></body></html>