<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <title>... in Java by Richard G Baldwin</title>
</head>
  <body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
  
<h2>Demonstrating Java Programs using the Robot Class</h2>
 <i>Baldwin shows you how to write an animated robot program to provide a
visual  demonstration of the use of a Java GUI.</i>
<p><b>Published:</b>&nbsp; September 16, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b> 
</p>
<p>Java Programming Notes # 1476</p>
<ul>
 <li> <a href="#Preface">Preface</a></li>
 <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and Sample
Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program Listings</a></li>
 
</ul>
  
<hr size="3" width="100%" align="center"> 
<center> 
<h2> <a name="Preface"></a>Preface</h2>
</center>
 
<p> Programming in Java doesn't have to be dull and boring.&nbsp; In fact,
it's possible  to have a lot of fun while programming in Java.&nbsp; This
is the third lesson in a  short miniseries that shows you how to use the
<b>Robot</b> class to write programs  that are both fun and useful.</p>
 
<p> <b><font color="#ff0000">New features in SDK Version 1.3</font></b></p>
 
<p>One of the new features that was released in SDK Version 1.3 was the <b>Robot</b>
class.&nbsp; According to Sun, </p>
 
<blockquote> 
  <p><i>"This class is used to generate native system input events for the
 purposes of test automation, self-running demos, and other applications
where  control of the mouse and keyboard is needed. The primary purpose of
Robot is to  facilitate automated testing of Java platform implementations."</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>What is a Java robot?</b></font></p>
 
<p>The <b>Robot</b> class makes it possible for your Java program to temporarily
take  control of the  mouse and keyboard input functionality at the operating-system
level.</p>
 
<p><font color="#ff0000"><b>Several instance methods are available</b></font></p>
 
<p>The <b>Robot</b> class provides several instance methods, <i>(including
the  following),</i> by which your program can produce mouse and keyboard
input, just as  though that input were being provided by a human user.</p>
 
<ul>
   <li><b>mouseMove</b> - Moves the mouse pointer to a set of specified absolute
   screen coordinates given in pixels.</li>
   <li><b>mousePress</b> - Presses one of the buttons on the mouse.</li>
   <li><b>mouseRelease</b> - Releases one of the buttons on the mouse.</li>
   <li><b>keyPress</b> - Presses a specified key on the keyboard.</li>
   <li><b>keyRelease</b> - Releases specified key on the keyboard.</li>
 
</ul>
 
<p><font color="#ff0000"><b>A word of caution</b></font></p>
 
<p>A runaway Java <b>Robot</b> object has the ability to wrest control away
from  the human user, so you need to be a little careful.&nbsp; For example,
if you  allow your Java <b>Robot</b> program to go into an infinite loop,
making mouse  moves, clicking the mouse, and entering keystrokes, you may
find that the only  practical way to regain control of your computer is to
either turn off the power  or press the reset button to force your computer
to restart.</p>
 
<p><font color="#ff0000"><b>Three lessons in the miniseries</b></font></p>
 
<p>According to my current plans, this miniseries on the <b>Robot</b> class
 will consist of three lessons.&nbsp; The first lesson, entitled <a
 href="http://www.developer.com/java/other/article.php/2212401">Introduction
to the Java Robot Class in Java</a>,  demonstrated the  low-level nature
of  an object of the <b>Robot</b> class.&nbsp;  That was accomplished by
showing you how to create a Java robot that can  manipulate other non-Java
programs, such as Windows Notepad and Internet  Explorer.</p>
 
<p>The second lesson, entitled <a
 href="http://www.developer.com/java/other/article.php/2241561">An Automated
Test Program using the Java Robot Class</a>, showed you how to use a robot
to  perform automatic testing on a Java GUI.</p>
 
<p>This lesson will show you how to write a robot program to  provide a visual
animated demonstration of the use of a Java GUI.</p>
 
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate 
browser window.&nbsp; That will make it easier for you to scroll back and 
forth among the different listings and figures while you are reading about 
them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However,
as of the date of this writing, Gamelan doesn't maintain a consolidated index
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp;
You will find a consolidated index at <font color="#000000"> <a
 href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font> </p>
<h2 align="center"><font color="#000000"> <a name="Preview">Preview</a></font></h2>
 
<p><font color="#ff0000"><b>A machine with no purpose</b></font></p>
<p>Many years  ago when I was in engineering undergraduate school, the college
set aside one  day each year to invite parents to the college.&nbsp; On that
day, there were  numerous programs, including demonstrations of interesting
electrical and  mechanical gadgets.</p>
<p>One of the gadgets that I remember was a small wooden box  with an electrical
toggle switch on the top.&nbsp; When a person toggled the  switch to the
ON position, a small hand emerged from a trap door and toggled the  switch
back to the OFF position.&nbsp; Then the hand retreated back into the  trap
door and disappeared.&nbsp; The machine had no purpose other than to keep
 itself turned off.</p>
<p><font color="#ff0000"><b>An interesting idea</b></font></p>
<p> As I was trying to come up with an interesting idea for this lesson,
it occurred  to me that a computer simulation of that box might be interesting.</p>
<p>I will discuss  a sample program named <b>Robot03</b>  in this lesson.&nbsp;
The  sample program will show you how to write a robot program to provide
a visual  animated demonstration of the use of a Java GUI.</p>
<p>In this demonstration, the  user can use the mouse to toggle any one of
three toggle buttons from <i>not  selected</i> to <i>selected.</i>&nbsp;
As in the box described above, as soon as  this happens, an animated hand
will move to the button and toggle it back to <i> not selected.</i>&nbsp;
Then the hand will disappear.</p>
<center> 
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion 
and Sample Code</font></h2>
</center>
   
<p> <font color="#ff0000"><b>Description of the program named Robot03</b></font></p>
<p> This program illustrates the use of the <b>Robot</b> class to automatically
unselect a <b>JToggleButton</b>, which has been manually selected by the
user.</p>
<p> This program provides an example of how to create and use a software
robot in an animated fashion.&nbsp; Such animation could be useful in demonstrating
how to use a program  with a GUI.</p>
<p> <font color="#ff0000"><b>A frame with three toggle buttons</b></font></p>
<p> The program places a <b>JFrame</b> object, containing three <b>JToggleButton</b>
objects, near the upper-left corner of the screen.&nbsp;  Figure 1 shows
the GUI produced by the program on startup.</p>
<p align="center"> <img border="0" src="java1476a.gif" width="251"
 height="101">
</p>
<p align="center"> Figure 1 Program GUI on startup</p>
<p> As you can see, none of the toggle buttons are <i>selected</i> at startup.&nbsp;
 </p>
<blockquote>   
  <p> <i>(The buttons initially appear to protrude from the screen in the
Motif look and feel.)</i></p>
</blockquote>
 
<p> Unfortunately, there is no practical way for me to show you the animation
in  this lesson.&nbsp; You will need to compile and execute the program in
order to  view the animation in progress.</p>
<p> <font color="#ff0000"><b>Will fire action  events and toggle between
two states</b></font></p>
<p> When the user manually clicks any of the three buttons, or presses the
space bar while one of the buttons has the focus, the button becomes selected
 and fires an <b>ActionEvent</b>.</p>
<p> Because the button is a <b>JToggleButton</b>, it will  toggle between
being selected and not  being selected.&nbsp; When the button is not selected,
 it is colored a light shade of gray, and appears to protrude from the screen.&nbsp;
When the button is selected, it is colored a dark shade of  gray and appears
to be pushed into the screen.</p>
<p> <font color="#ff0000"><b>Focus traversal</b></font></p>
<p> If you successively press the <i>focus traversal key,</i> the focus will
traverse the components  using the <i>focus traversal policy</i> that is
in effect.</p>
<p> I did not implement a new focus traversal policy, nor did I change the
focus  traversal key.&nbsp; Therefore, the default focus traversal policy
and the  default focus traversal key are both in effect.&nbsp; </p>
<p> Successively pressing the TAB key will cause the focus to move from one
 component to the next, from left to right, and then back to the left end.</p>
<p> If you hold down the SHIFT key and successively press the TAB key, the
focus will traverse  the components in the reverse direction.</p>
<p> As mentioned earlier, pressing the space bar while a button has the focus
will  cause it to fire an <b>ActionEvent</b> and to toggle between being
selected and  not being selected.</p>
<p> <font color="#ff0000"><b>Common event handler</b></font></p>
<p> A common <b>ActionEvent</b> handler is registered on each of the  buttons.&nbsp;
The <b>ActionEvent</b> handler uses an object of the <b>Robot</b> class to
unselect the button in an animated fashion.</p>
<p> <font color="#ff0000"><b>The robot takes control of the mouse</b></font></p>
<p> As soon as the action event is fired, the robot takes control of the
mouse pointer.&nbsp; The mouse pointer changes from the default arrow-shaped
pointer into a hand-shaped pointer.&nbsp; The hand-shaped pointer becomes
animated, moving from the upper-left area of the  GUI to the center of the
button that fired the action event.</p>
<p> <font color="#ff0000"><b>The robot clicks the button</b></font></p>
<p> When the mouse pointer reaches the center of the button that fired the
event, the robot automatically clicks the button  with the mouse, causing
the button to become unselected.&nbsp; This causes the  button to once again
appear to protrude from the screen.&nbsp; It also causes  the button to change
from dark gray to light gray.</p>
<p> <font color="#ff0000"><b>Action events are disabled</b></font></p>
<p> Action events are disabled on the button after the user clicks the button
and before the robot clicks the button.&nbsp;  Action events are re-enabled
after the robot clicks the button.&nbsp; Otherwise, the program would go
into an infinite loop of firing and processing action events on the same
button.</p>
<p> <font color="#ff0000"><b>Robot relinquishes control of the mouse</b></font></p>
<p> When the button is clicked by the robot, the robot relinquishes control
of the mouse.&nbsp; The pointer returns to the upper-left area of the  GUI
and turns back into the arrow-shaped default pointer.&nbsp; The user can
then click the same, or a different button, starting the animation process
all over again.</p>
<p> <font color="#ff0000"><b>Requires V1.3 or later</b></font></p>
<p> Because the <b>Robot</b> class was released in SDK Version 1.3, this
program  requires V1.3 or later to compile and execute successfully.&nbsp;
The program  was tested on my machine using SDK 1.4.1 under WinXP</p>
<p><font color="#ff0000"><b> The beginning of the Robot03 class</b></font></p>
   
<p>I will discuss this program in fragments.&nbsp; A complete listing of
the    program is shown in Listing 19 near the end of the lesson.</p>
<p>The program named <b> Robot03</b> begins in Listing 1 where an instance
variable of type <b>Robot</b>  is declared.&nbsp; This variable will later
be used to hold a reference to an  object of the <b>Robot</b> class.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>public class Robot03 extends JFrame<br>                       implements ActionListener{<br>  Robot robot;<br><br>  public static void main(String[] args){<br>    new Robot03();<br>  }//end main<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Listing 1 also shows the <b>main</b> method, which instantiates an object
of  the <b>Robot03</b> class.</p>
 
<p>The animated behavior of this program is primarily controlled by the <b> 
ActionEvent</b> handler registered on the buttons and by methods called by
the  event handler.</p>
 
<p><font color="#ff0000"><b>The constructor</b></font></p>
   
<p>The constructor begins in Listing 2.&nbsp; The code in the constructor
is    relatively straightforward, so I won't discuss that code in detail.&nbsp;
   However, I will review the constructor code briefly to set the stage for
the    discussion of the event handler that follows.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public Robot03(){//constructor<br>    try{<br>      robot = new Robot();<br>    }catch(AWTException e){e.printStackTrace();}<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>The code in Listing 2 instantiates a new <b>Robot</b> object and saves
its  reference in the variable named <b>robot</b>, which was declared in
Listing 1.&nbsp;  Because the reference is stored in an instance variable,
it is accessible  throughout the class.</p>
 
<p><font color="#ff0000"><b>Prepare the JFrame for use</b></font></p>
   
<p>The code in Listing 3 executes several routine actions to prepare the<b>
   JFrame</b> object for use.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    setDefaultCloseOperation(<br>                          JFrame.EXIT_ON_CLOSE );<br>    getContentPane().setLayout(<br>                            new GridLayout(1,3));<br>    setBounds(20,20,250,100);<br>    setTitle("Copyright 2003, R.G.Baldwin");<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Create the buttons ...</b></font></p>
 
<p>The code in Listing 4 creates the three <b>JToggleButton</b> objects and
adds  them to the frame.</p>
 
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    JToggleButton b1 = new JToggleButton( "1" );<br>    JToggleButton b2 = new JToggleButton( "2" );<br>    JToggleButton b3 = new JToggleButton( "3" );<br><br>    getContentPane().add(b1);<br>    getContentPane().add(b2);<br>    getContentPane().add(b3);<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 
<p><font color="#ff0000"><b>Register action listeners</b></font></p>
   
<p>The code in Listing 5 registers <b>this</b> object as an action listener
on    each of the buttons.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    b1.addActionListener(this);<br>    b2.addActionListener(this);<br>    b3.addActionListener(this);<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Set the look and feel</b></font></p>
   
<p>The code in Listing 6 sets the look and feel to Sun's Motif and makes
the    GUI visible.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    String plafClassName =<br>               "com.sun.java.swing.plaf.motif." +<br>                              "MotifLookAndFeel";<br>    try{<br>       UIManager.setLookAndFeel(plafClassName);<br>     }catch(Exception ex){ex.printStackTrace();}<br><br>     //Cause the new L&amp;F to apply<br>     SwingUtilities.updateComponentTreeUI(this);<br><br>    //Make the frame visible<br>    setVisible( true );<br>  }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Listing 6 also signals the end of the constructor.</p>
 
<p><font color="#ff0000"><b>Now for something a little more interesting</b></font></p>
   
<p>Now that we have gotten beyond the preliminaries, the code should become
a    little more interesting, and I will discuss the remaining code in more
detail.</p>
<p> <font color="#ff0000"><b>Define the ActionEvent handler</b></font></p>
<p>Because the  class implements the <b>ActionListener</b> interface, the
class must define the  method named <b>actionPerformed</b>, which is declared
in that interface.&nbsp;  The definition of the <b>actionPerformed</b> method
is shown in Listing 7.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public void <b>actionPerformed</b>(ActionEvent e){<br>    JToggleButton button =<br>                  (JToggleButton)(e.getSource());<br>    <b>new HandleEvent(button,this).start();</b>
  }//end actionPerformed

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Causing the class to implement the interface and defining the event handler
 method within the class makes it possible to register <b>this</b> object
as an <b>ActionEvent</b> handler on each of the buttons as shown earlier
in Listing 5.</p>
 
<p><font color="#ff0000"><b>The time required to handle the event</b></font></p>
 
<p>One of the important considerations in writing event handlers has to do
with  the amount of time that will be required to handle the event in its
entirety.&nbsp;  If the amount of time required to handle the event will
be large, the event  handler method should spawn a new thread to do the job
and return immediately.&nbsp;  This avoids tying the event handler thread
up for long periods while previous  events are being handled.</p>
 
<p><font color="#ff0000"><b>Spawn a thread</b></font></p>
 
<p>Because of the animated nature of this event handler, quite a lot of time
 will be required to handle each event fired by a button.&nbsp; The mouse
pointer  must move across the GUI at a relatively slow speed in order to
get to and click  on the button that fired the event.</p>
 
<p>Therefore, the <b>actionPerformed </b>method in Listing 7 spawns a new
thread  from the inner class named <b>HandleEvent</b> to perform the animation.&nbsp;
 The <b>actionPerformed</b> method starts the new thread running and returns
 immediately.</p>
 
<p><font color="#ff0000"><b>The HandleEvent class</b></font></p>
   
<p>The <b>HandleEvent</b> class begins in Listing 8.&nbsp; Objects of this
   class, which extends <b>Thread</b>, are spawned to handle the animation
   associated with action events on the buttons.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  class HandleEvent extends Thread{<br>    JToggleButton button;<br>    ActionListener listener;<br><br>    HandleEvent(JToggleButton button,<br>                        ActionListener listener){<br>      this.button = button;<br>      this.listener = listener;<br>    }//end constructor<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>The constructor</b></font></p>
 
<p>The constructor for the <b>HandleEvent</b> class is shown in Listing 7.&nbsp;
 This constructor receives and saves references to:</p>
 
<ul>
   <li>The button that fired the event.</li>
   <li>The <b>ActionEvent</b> listener that is registered on the button.</li>
 
</ul>
 
<p><font color="#ff0000"><b>Click on the button</b></font></p>
 
<p>The reference to the button is needed to cause the mouse pointer to move
to  the button and click on that button in an animated fashion.</p>
 
<p><font color="#ff0000"><b>Temporarily disable the action listener</b></font></p>
 
<p>The reference to the listener is needed to temporarily disable the listener
 before the robot clicks on the button.&nbsp; Otherwise, the program would
go  into an infinite loop with the robot causing the button to fire action
events  while trying to handle those events.</p>
 
<p><font color="#ff0000"><b>The run method</b></font></p>
   
<p>The <b>run</b> method of a <b>Thread</b> object is where the behavior
of    that thread is controlled.&nbsp; The beginning of the <b>run</b> method
for    the <b>HandleEvent</b> class is shown in Listing 9.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    public void <b>run</b>(){<br>      Point location =<br>                    button.getLocationOnScreen();<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>The first task in the <b>run</b> method is to get the screen location
of the  button that fired the event.&nbsp; This information will be needed
in order to  cause the mouse pointer to move to that location and execute
a mouse click.</p>
 
<p><font color="#ff0000"><b>Disable action events</b></font></p>
   
<p>As mentioned earlier, when the robot causes a mouse click to occur on
the    button that fired the event, that button will fire another action
event.&nbsp;    If the action listener is still registered on that button,
this will result in    an infinite loop of firing and handling action events.</p>
<p>The code in Listing  10 temporarily un-registers the action listener from
the button to prevent this  from happening.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      button.<b>removeActionListener</b>(listener);<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<blockquote> 
  <p><i>(The registration of the action listener on the button will be restored
 later.)</i></p>
 </blockquote>
 
<p><font color="#ff0000"><b>Move the mouse and click the button</b></font></p>
   
<p>The code in Listing 11 invokes the method named <b>mouseMoveAndClick</b>
to    cause to program to:</p>
<ul>
   <li>Change the mouse pointer to a hand-shaped pointer in the upper left
of the    GUI.</li>
   <li>Move the pointer slowly from the upper left to the center of the button
   that fired the event.</li>
   <li>Click the button that fired the event.</li>
   <li>Restore the mouse pointer to the default pointer in the upper left
of the    GUI.</li>
   
</ul>
   
<p>This action causes the selected button to become not selected, causing
it    to pop out of the screen and to change color from dark gray to light
gray.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      <b>mouseMoveAndClick</b>(50,50,<br>              location.x + button.getWidth()/2,<br>              location.y + button.getHeight()/2);<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>The mouseMoveAndClick method</b></font></p>
   
<p>At this point, I am going to temporarily put the discussion of the <b>run</b>
   method on the back burner and discuss the method named <b>mouseMoveAndClick</b>,
   which begins in Listing 12.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>  public void mouseMoveAndClick(int xStart,<br>                                int yStart,<br>                                int xLoc,<br>                                int yLoc){<br>    robot.mouseMove(xStart,yStart);<br><br><b><font
 face="Courier New,Courier">Listing 12</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Move pointer to the starting position</b></font></p>
 
<p>Note that the invocation of this method in Listing 11 passes the coordinates
 50, 50 as the first two parameters.&nbsp; This represents a point in the
upper  left of the GUI.</p>
 
<p>The code in Listing 12 moves the mouse pointer to this location in one
step.&nbsp;  There is no slow-speed animation associated with this move.</p>
 
<p><font color="#ff0000"><b>Change to a hand-shaped curser and delay</b></font></p>
   
<p>The code in Listing 13 changes the appearance of the mouse pointer from
its    default arrow shape to the shape of a hand.&nbsp; Then a one-second
delay is    inserted before the animation actually begins.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    setCursor(new Cursor(Cursor.HAND_CURSOR));<br>    robot.delay(1000);<br><br><b><font
 face="Courier New,Courier">Listing 13</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Compute the incremental mouse pointer step size</b></font></p>
   
<p>A <b>while</b> loop will be used to cause the pointer to move in small
   steps from its current location to the center of the button that fired
the    event.&nbsp; The code in Listing 14 is used to compute the size of
the steps    in the horizontal and vertical directions.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    double div;<br>    if ((xLoc - xStart) &lt; 50.0) div = 15;<br>    else if ((xLoc - xStart) &lt; 100.0) div = 30;<br>    else div = 60;<br><br>    double xInc = (xLoc - xStart)/div;<br>    double yInc = (yLoc - yStart)/div;<br><br><b><font
 face="Courier New,Courier">Listing 14</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p><font color="#ff0000"><b>Double precision arithmetic</b></font></p>
 
<p>This is the sort of computation where errors associated with integer  arithmetic
can accumulate to produce large resulting errors.&nbsp; Therefore,  the computations
were performed using double precision to avoid this potential  problem.</p>
 
<p><font color="#ff0000"><b>Different incremental step sizes</b></font></p>
 
<p>If you examine Listing 14 carefully, you will see that the incremental
step  size used for the animation depends on how far the mouse needs to travel
to  reach the button.&nbsp; This causes the animation to be more visually
pleasing  than was the case when I simply used the same step size regardless
of distance.&nbsp; <i>(I will leave it as an exercise for the student to
ponder and understand why  this is the case.)</i></p>
 
<p><font color="#ff0000"><b>Move the mouse pointer</b></font></p>
   
<p>The code in Listing 15 initializes two variables, and then executes a
<b>   while</b> loop to move the mouse pointer in incremental steps from
its    starting position in the upper left of the GUI to the center of the
button    that fired the event.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    double x = xStart;<br>    double y = yStart;<br>    while(((int)x &lt; xLoc) || ((int)y &lt; yLoc)){<br>      x += xInc;<br>      y += yInc;<br>      robot.<b>mouseMove</b>((int)x,(int)y);<br>      robot.delay(60);<br>    }//end while loop<br><br><b><font
 face="Courier New,Courier">Listing 15</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>A 60-millisecond delay is inserted between each movement of the mouse
pointer  to enhance the animation effect.</p>
 
<p><font color="#ff0000"><b>Click the button</b></font></p>
   
<p>Once the mouse pointer arrives at the center of the button that fired
the    event, the <b>while</b> loop terminates and the code in Listing 16
is    executed.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    robot.mousePress(InputEvent.BUTTON1_MASK);<br>    robot.mouseRelease(InputEvent.BUTTON1_MASK);<br><br>    robot.delay(1000);<br><br><b><font
 face="Courier New,Courier">Listing 16</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>The code in Listing 16 first presses and then releases the left mouse
button  on the screen location that is the center of the button that fired
the event.&nbsp;  This constitutes a click and causes the button to fire
an <b>ActionEvent</b> and  to toggle from selected to not selected.</p>
   
<blockquote> 
  <p><i>(Because the event listener is no longer registered on the button,
the  event is simply ignored.&nbsp; However, the button appears to pop out
of the  screen and to change color from dark gray to light gray when it becomes
not  selected.)</i></p>
   </blockquote>
 
<p>Finally, the code in Listing 16 inserts a one-second delay to allow the
user  to savor the previous action before restoring the pointer to the default
arrow  shape in the upper left of the GUI.</p>
   
<p><font color="#ff0000"><b>Restore the mouse pointer</b></font></p>
<p>The code in    Listing 17 moves the mouse pointer back to its original
starting position in    one step, and changes its appearance from the shape
of a hand to the default    shape of an arrow.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>    robot.mouseMove(xStart,yStart);<br>    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));<br>  }//end mouseMoveAndClick<br><br><b><font
 face="Courier New,Courier">Listing 17</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>That ends one animation cycle.&nbsp; The mouse pointer is now available
for  the user to click on another button and start a new animation cycle.</p>
 
<p><font color="#ff0000"><b>Re-enable the action listener</b></font></p>
   
<p>Returning now to the remaining code in the <b>run</b> method, the code
in    Listing 18 re-registers the action listener object on the button.<br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>      button.addActionListener(listener);<br>    }//end run<br><br>  }//end class HandleEvent<br><br><b><font
 face="Courier New,Courier">Listing 18</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
 </p>
<p>Thus, that button's ability to fire action events and have them handled
by  the action listener is restored.</p>
 
<p>That ends the class named <b>HandleEvent</b>, and ends the program as
well.</p>
 
<center> 
<h2> <a name="Run the program"></a>Run the Program</h2>
</center>
       
<p>I encourage you to copy the code from Listing 19 into your text editor,
compile it, and execute it.&nbsp; Experiment with it, making changes, and
observing the results of your changes. </p>
 
<p>The <b>Robot</b>  class was first released in SDK Version 1.3, so you
will need to be running  Version 1.3 or later to successfully compile and
execute the program.&nbsp; This program was tested on my machine using SDK
1.4.1 under WinXP</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
   
<p>In this lesson, I have taught you how to write an animated robot program
to    provide a visual demonstration of the use of a Java GUI.</p>
<center> 
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
   A complete listing for the program discussed in this lesson is shown in
   Listing 19 below. <br>
 &nbsp;
<table border="1" cols="1" width="400" bgcolor="#ffff00">
 <tbody>
    <tr>
 <td> 
      <pre>/*File Robot03.java<br>Copyright 2003 R.G.Baldwin<br><br>Illustrates the use of the java.awt.Robot class<br>to automatically unselect a JToggleButton, which<br>has been manually selected by the user.<br><br>This program provides an example of how to create<br>and use a software robot in an animated fashion.<br>Such animation could be useful in demonstrating<br>how to use a program.<br><br>The program places a JFrame object,containing<br>three JToggleButton objects near the upper-left<br>corner of the screen.<br><br>The three buttons are initially not selected.  In<br>other words, they initially appear to protrude<br>from the screen in the Motif look and feel.<br><br>When the user manually clicks on any of the<br>three buttons, or presses the space bar while one<br>of the buttons has the focus, the button becomes<br>selected.  At that point, it appears to be pushed<br>into the screen.<br><br>This causes the button to fire an action event.<br><br>The action event handler uses an object of the<br>Robot class to unselect the button automatically<br>in an animated fashion.<br><br>As soon as the action event is fired, the robot<br>takes control of the mouse pointer.  The mouse<br>pointer changes from the default arrow-shaped<br>pointer into a hand-shaped pointer.  The hand<br>pointer becomes animated, moving from the upper-<br>left area of the screen to the center of the<br>button that fired the action event.  When the<br>mouse pointer reaches the center of the button,<br>the robot automatically clicks on the button,<br>causing it to become unselected.  The button<br>once again appears to protrude from the screen.<br><br>Action events are disabled on the button before<br>the robot clicks the button and are re-enabled<br>after the robot clicks the button.  Otherwise,<br>the program would go into an infinite loop of<br>firing and processing action events on the same<br>button.<br><br>When the button is unselected by the robot, the<br>robot relinquishes control of the mouse.  The<br>pointer returns to the upper-left area of the<br>screen and turns back into the arrow-shaped<br>default pointer.<br><br>The user can then click the same, or a different<br>button, starting the animation process all over<br>again.<br><br>Tested using SDK 1.4.1 under WinXP<br>************************************************/<br><br>import java.awt.*;<br>import java.awt.event.*;<br>import javax.swing.*;<br><br>public class Robot03 extends JFrame<br>                       implements ActionListener{<br><br>  Robot robot;<br><br>  public static void main(String[] args){<br>    new Robot03();<br>  }//end main<br>  //-------------------------------------------//<br><br>  public Robot03(){//constructor<br>    //Instantiate and save a new Robot object<br>    try{<br>      robot = new Robot();<br>    }catch(AWTException e){e.printStackTrace();}<br><br>    //Prepare the JFrame for use<br>    setDefaultCloseOperation(<br>                          JFrame.EXIT_ON_CLOSE );<br>    getContentPane().setLayout(<br>                            new GridLayout(1,3));<br>    setBounds(20,20,250,100);<br>    setTitle("Copyright 2003, R.G.Baldwin");<br><br>    //Create the buttons<br>    JToggleButton b1 = new JToggleButton( "1" );<br>    JToggleButton b2 = new JToggleButton( "2" );<br>    JToggleButton b3 = new JToggleButton( "3" );<br><br>    //Add the buttons to the frame<br>    getContentPane().add(b1);<br>    getContentPane().add(b2);<br>    getContentPane().add(b3);<br><br>    //Register an action listener on each of<br>    // the buttons.<br>    b1.addActionListener(this);<br>    b2.addActionListener(this);<br>    b3.addActionListener(this);<br><br>    //Set look and feel<br>    String plafClassName =<br>               "com.sun.java.swing.plaf.motif." +<br>                              "MotifLookAndFeel";<br>    try{<br>       UIManager.setLookAndFeel(plafClassName);<br>     }catch(Exception ex){ex.printStackTrace();}<br><br>     //Cause the new L&amp;F to apply<br>     SwingUtilities.updateComponentTreeUI(this);<br><br>    //Make the frame visible<br>    setVisible( true );<br>  }//end constructor<br>  //-------------------------------------------//<br><br>  //Define the event handler that is registered<br>  // on each of the buttons.<br>  public void actionPerformed(ActionEvent e){<br>    JToggleButton button =<br>                  (JToggleButton)(e.getSource());<br>    //Spawn a thread to handle the event and<br>    // return from the event handler method.<br>    new HandleEvent(button,this).start();<br>  }//end actionPerformed<br>  //-------------------------------------------//<br><br>  //Objects of this inner Thread class are<br>  // spawned to handle action events on the<br>  // buttons.<br>  class HandleEvent extends Thread{<br>    JToggleButton button;<br>    ActionListener listener;<br><br>    HandleEvent(JToggleButton button,<br>                        ActionListener listener){<br>      this.button = button;<br>      this.listener = listener;<br>    }//end constructor<br><br>    public void run(){<br>      //Get the button's location.<br>      Point location =<br>                    button.getLocationOnScreen();<br>      //Disable action events on this button<br>      // until this process is complete.  Don't<br>      // allow the robot to generate an action<br>      // event on this button.<br>      button.removeActionListener(listener);<br>      //Cause the mouse pointer to automatically<br>      // move across the screen and click on the<br>      // button that fired the event currently<br>      // being processed.  This will un-select<br>      // the toggle button.<br>      mouseMoveAndClick(50,50,<br>              location.x + button.getWidth()/2,<br>              location.y + button.getHeight()/2);<br>      //Re-enable action events on this button<br>      button.addActionListener(listener);<br>    }//end run<br><br>  }//end class HandleEvent<br>  //-------------------------------------------//<br><br>  public void mouseMoveAndClick(int xStart,<br>                                int yStart,<br>                                int xLoc,<br>                                int yLoc){<br>    //Move the mouse pointer to the starting<br>    // position<br>    robot.mouseMove(xStart,yStart);<br><br>    //Change the cursor to a hand and delay<br>    setCursor(new Cursor(Cursor.HAND_CURSOR));<br>    robot.delay(1000);<br><br>    //Use double precision to avoid cumulative<br>    // arithmetic errors.  Calculate the<br>    // incremental distance for animated mouse<br>    // pointer movement.  Make animation speed<br>    // appropriate for distance to be traveled.<br>    double div;<br>    if ((xLoc - xStart) &lt; 50.0) div = 15;<br>    else if ((xLoc - xStart) &lt; 100.0) div = 30;<br>    else div = 60;<br><br>    double xInc = (xLoc - xStart)/div;<br>    double yInc = (yLoc - yStart)/div;<br><br>    //Initialize, and then execute a loop to move<br>    // the mouse pointer from the starting<br>    // position to the center of the button.<br>    // Sleep for 60 msec between each movement.<br>    double x = xStart;<br>    double y = yStart;<br>    while(((int)x &lt; xLoc) || ((int)y &lt; yLoc)){<br>      x += xInc;<br>      y += yInc;<br>      robot.mouseMove((int)x,(int)y);<br>      robot.delay(60);<br>    }//end while loop<br><br>    //Press and then release the left mouse<br>    // button when the mouse pointer is resting<br>    // in the location of the JToggleButton.<br>    robot.mousePress(InputEvent.BUTTON1_MASK);<br>    robot.mouseRelease(InputEvent.BUTTON1_MASK);<br><br>    //Return the cursor to the starting position<br>    // and restore it to a default pointer.<br>    robot.delay(1000);<br>    robot.mouseMove(xStart,yStart);<br>    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));<br>  }//end mouseMoveAndClick<br>  //-------------------------------------------//<br><br>}//end class definition<br><br><b><font
 face="Courier New,Courier">Listing 19</font></b></pre>
 </td>
 </tr>
 
  </tbody>
</table>
  
<hr size="3" width="100%" align="center"> 
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in part
in any form or medium without express written permission from Richard Baldwin
is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
 <b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is
a college professor (at Austin Community College in Austin, TX) and private
consultant whose primary focus is a combination of Java, C#, and XML. In
addition to the many platform and/or language independent benefits of Java
and C# applications, he believes that a combination of Java, C#, and XML
will become the primary driving force in the delivery of structured information
on the Web.</i> 
<p><i>Richard has participated in numerous consulting projects, and he frequently
provides onsite training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.DickBaldwin.com">Tutorials</a>, which has gained a worldwide
following among experienced and aspiring programmers. He has also published
articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and 
has many years of experience in the application of computer technology to
real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i> 
</p>
<p>-end- <br>
&nbsp; </p>
<br>
</body>
</html>
