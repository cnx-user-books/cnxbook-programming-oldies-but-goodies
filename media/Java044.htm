<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>More on Java Inheritance by Richard G. Baldwin </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->More on Inheritance<!--endTitle--></H2>
<P>Java Programming, Lecture Notes # 44, Revised 10/03/99.</P>
<P><!-toc file=Java044a.htm words=Preface-><A HREF="#Preface">Preface</A><BR>
<!--endtoc--><!-toc file=Java044b.htm words=Introduction-><A HREF="#Introduction">Introduction</A><BR>
<!--endtoc--><!-toc file=Java044c.htm words=Creating Subclasses-><A HREF="#CreatingSubclasses">Creating Subclasses</A><BR>
<!--endtoc--><!-toc file=Java044d.htm words=Final Classes and Methods-><A HREF="#FinalClassesandMethods">Final Classes and Methods</A><BR>
<!--endtoc--><!-toc file=Java044e.htm words=Abstract Classes and Methods-><A HREF="#AbstractClassesandMethods">Abstract Classes and Methods</A><BR>
<!--endtoc--><!-toc file=Java044f.htm words=The Object Class-><A HREF="#TheObjectClass">The Object Class</A><BR>
<!--endtoc--><!-toc file=Java044g.htm words=Overriding Methods-><A HREF="#OverridingMethods">Overriding Methods</A><BR>
<!--endtoc--><!-toc file=Java044h.htm words=Object Class Methods-><A HREF="#ObjectClassMethods">Object Class Methods</A><BR>
<!--endtoc--><!-toc file=Java044i.htm words=Review-><A HREF="#Review">Review</A><!--endtoc--></P>
<!-next=Java044a.htm><!-first=Java044.htm->
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson.</P>
<P><!-prev=Java044.htm-><!-next=Java044b.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Introduction"></A>Introduction</H2>
</FONT><P>As you already know, you can create new classes by inheriting from existing classes. The new class is often called the <I>subclass </I>while the inherited class is often called the <I>superclass</I>. </P>
<P>Also as you already know, an object of the new subclass contains <U>all the variables</U> and <U>all the methods</U> of the <I>superclass </I>and all its ancestors, all the way up the family tree, to and including the class named <B>Object</B>. </P>
<P>Some of the methods may have been overridden somewhere in the family tree. </P>
<P>All classes in Java are inherited from some class. </P>
<P>The class at the top of the inheritance hierarchy is the <B>Object</B> class. This class is defined in the package named <I>java.lang</I>. Thus, the <B>Object </B>class is the root of the Java family tree. </P>
<P>You also already know that an object has <I>state </I>and <I>behavior</I>. </P>
<P>Objects of classes which you define have their state and behavior influenced by the variables and methods which they inherit as well as any new variables and methods which you add. </P>
<P>New subclasses that you define can use the inherited methods as is, or their behavior can be modified relative to objects of the new class; a process commonly known as <I>overriding a method</I>. </P>
<P>Through the use of access control, subclasses can choose to allow variables inherited from the superclass to continue to be <I>exposed </I>to further inheritance, or to <I>hide </I>them. </P>
<P>Generally as you move from the <I>root </I>through the <I>branches </I>to the <I>leaves </I>in an object-oriented family tree, the classes become <I>more specialized</I>. </P>
<P>The following definition is from <U>The Java Tutorial</U> by Campione and Walrath: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Definition: A subclass is a class that derives from another class. A subclass inherits <I>state </I>and <I>behavior </I>from all of its ancestors. The term <I>superclass </I>refers to a class's direct ancestor <U>as well as all of its ascendant classes</U>.</TD>
</TR>
</TABLE>

<P><!-prev=Java044a.htm-><!-next=Java044c.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="CreatingSubclasses"></A>Creating Subclasses</H2>
</FONT><P>As you are aware, in order to create a subclass of an existing class, we use the <I>extends</I> keyword in the definition of the new class. </P>
<P>The class definition describes all there is to know about the class such as its <I>super class</I>, its <I>variables </I>and their type, its <I>methods</I>, its <I>access control</I> specification, etc. </P>
<P><!-prev=Java044b.htm-><!-next=Java044d.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="FinalClassesandMethods"></A>Final Classes and Methods</H2>
</FONT><P>Sometimes you may not want to allow your class to be subclassed, or you may not want to allow your methods to be overridden. </P>
<P>A class which is marked with the <B>final</B> keyword cannot be subclassed. </P>
<P>A method which is marked with the <B>final</B> keyword cannot be overridden. </P>
<P><!-prev=Java044c.htm-><!-next=Java044e.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="AbstractClassesandMethods"></A>Abstract Classes and Methods</H2>
</FONT><P>The flip side of <B>final</B> is <B>abstract</B>. A class which is marked as <B>abstract </B>is designed to be subclassed. It is <U>not possible</U> to instantiate an object from an <B>abstract</B> class. </P>
<P>Likewise, a method which is marked <B>abstract</B> is designed to be overridden. An <B>abstract</B> method defines the interface only, and cannot be invoked until it if fully defined. (You may have noticed that there are some similarities between <B>abstract</B> methods and method declarations in an <B>interface</B>.) </P>
<P><!-prev=Java044d.htm-><!-next=Java044f.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="TheObjectClass"></A>The Object Class</H2>
</FONT><P>As mentioned earlier, all classes in Java inherit directly or indirectly from the <B>Object</B> class. Thus, all new classes inherit some methods which are defined in <B>Object</B>. As you might expect, those methods are of a very general nature since they apply to all objects. </P>
<P>Your new class can either use these inherited methods as is, override them, or ignore them altogether. </P>
<P><!-prev=Java044e.htm-><!-next=Java044g.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="OverridingMethods"></A>Overriding Methods</H2>
</FONT><P><A HREF="#ReplacingtheMethodImplementation">Replacing the Method Implementation</A><BR>
<A HREF="#EnhancingaSuperclassConstructor">Enhancing a Superclass Constructor</A><BR>
<A HREF="#MethodsaSubclassMustOverride">Methods a Subclass Must and Cannot Override</A></P>
<P>A subclass can either completely override the implementation of an inherited method, or the subclass can enhance the method by adding functionality to it. </P>
<P>If your method overrides a method in its superclass, you can use the keyword <B>super </B>to bypass the overridden version in the subclass and invoke the version in the superclass. </P>
<P>This was illustrated by a program named <B>super2</B> in an earlier lesson on classes. This program contained an overridden version of a superclass method named <B>myMethod()</B> that uses the value of an incoming parameter to decide whether to invoke the superclass version or to execute its own code. </P>
<P>The program is repeated below for convenience.</P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File super2.java Copyright 1997, R.G.Baldwin
Illustrates bypassing a local overridden method in favor
of the method in the superclass.

The output from this program is:

In main
Incoming parameter is false
Overridden method invoked
Incoming parameter is true
Base-class method invoked
**********************************************************/
class base{
  void myMethod(boolean superFlag){//method to override
    System.out.println(
      "Incoming parameter is " + superFlag);  
    System.out.println("Base-class method invoked");
  }//end myMethod
}//end base class definition
//=======================================================//

class super2 extends base{
  void myMethod(boolean superFlag){//override myMethod()
    //Make decision to invoke this version or the version
    // in the superclass.
    if(superFlag)
      <STRONG>super.myMethod(superFlag)</STRONG>;//super version
    else{ //this version
      System.out.println(
        "Incoming parameter is " + superFlag);
      System.out.println("Overridden method invoked");
    }//end else
  }//end overridden myMethod()
  //-----------------------------------------------------//

  public static void main(String[] args){ //main method
    //instantiate an object of this type 
    super2 obj = new super2();
    System.out.println("In main");
    //Invoke overridden version of myMethod()
    obj.myMethod(false);
    //Invoke superclass version of myMethod()
    obj.myMethod(true);
  }//end main method
}//End super2 class definition.</PRE></TD>
</TR>
</TABLE>

<P>Obviously it would be possible to do both as well. In other words, there is no reason that an overridden method could not invoke the superclass version using the <B>super </B>keyword, and also execute additional code to provide additional behavior. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ReplacingtheMethodImplementation"></A>Replacing the Method Implementation</H3>
</FONT><P>Some methods are defined with an empty implementation in the expectation that subclasses will define a completely new implementation. Whether or not the implementation of a method that is inherited is empty, your subclass can completely replace that implementation. </P>
<P>Although we haven't discussed multithreading yet, there is a very important method in the <B>Thread </B>class named <B>run()</B>. The implementation of the <B>run()</B> method in the <B>Thread </B>class is <B>completely empty</B>, meaning that it does nothing but define the method interface. </P>
<P>It doesn't make sense for the <B>run()</B> method to define a default behavior because it will ultimately be used to do whatever your thread needs to have done. The Java library programmers couldn't possibly anticipate your needs in this regard so they left it empty to allow you to define the behavior. </P>
<P>On the other hand, it cannot be marked <I>abstract</I>. That would prevent the instantiation of objects of the <B>Thread </B>class because classes containing <B>abstract</B> methods cannot be instantiated until a definition is provided for the <B>abstract</B> method. Instantiation of <B>Thread</B> objects is a critical aspect of multithreaded programming. </P>
<P>The desired result was accomplished by the Java library programmers by defining <B>run()</B> as an empty method. </P>
<P>You can completely replace the implementation of an inherited method by giving your new method the same signature as the method that you want to override and then providing whatever body makes sense for the task at hand. </P>
<P>In the case of the <B>run()</B> method, you might have something like the following: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class <B>MyThread extends Thread</B> {
  void <B>run</B>() 
    { 
      //Method body . . . 
    }
}//end class MyThread</PRE></TD>
</TR>
</TABLE>

<P>In this code fragment, the <B>run()</B> method in the class named <B>MyClass</B> overrides the <B>run() </B>method from the <B>Thread </B>class and provides its own implementation. </P>
<P>You must be careful to make certain that you <U>understand the difference</U> between <U>overriding</U> and <U>overloading</U> a method. To <I>overload </I>a method, you must <U>duplicate the method name</U>, but use a <U>different argument list</U>. </P>
<P>To <I>override </I>a method, you must match the entire method signature. </P>
<P>If you aren't careful when writing your new method signature, you will be overloading methods when you think that you are overriding them. This is a situation where you don't get any warnings from the JDK 1.1 compiler. It apparently assumes that you know what you are doing if you inadvertently <I>overload </I>instead of <I>override </I>a method. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="EnhancingaSuperclassConstructor"></A>Enhancing a Superclass Constructor</H3>
</FONT><P>Sometimes when we create the <I>constructor </I>for a subclass, we would like to invoke a parameterized constructor for the superclass also. </P>
<P>This can be accomplished by causing the <U>first line</U> of our constructor to contain the keyword <B>super</B> followed by a parameter list as though calling a method named <B>super()</B>. The parameter list must match the parameters in the argument list of the superclass constructor. </P>
<P>This has the effect of causing the constructor for the superclass to be invoked using parameters passed from the subclass before the constructor for the subclass is executed. </P>
<P>According to <U>Java in a Nutshell</U> by David Flanagan, "If <B>super</B> doesn't appear as the first statement of a constructor body, the Java compiler inserts an implicit call -- <B>super() </B>-- to the immediate superclass constructor." </P>
<P>That is, the <B>noarg</B> constructor for the superclass is automatically invoked whenever we execute the constructor for a new subclass unless we specifically invoke a parameterized constructor for the superclass. </P>
<P>The <B>super</B> keyword can also be used at other places in a method to access variables in the superclass or invoke methods in the superclass using syntax such as: </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<P><TT>super.myMethod(14);</TT> </P>
<TT><PRE>x = super.myVariable;</PRE></TT></TD>
</TR>
</TABLE>

<P>This is sometimes required when variable names or method names of the subclass duplicate and hide (or <I>shadow</I>) variable or method names of the superclass. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="MethodsaSubclassMustOverride"></A>Methods a Subclass Must and Cannot Override</H3>
</FONT><P>If the subclass is not declared to be <B>abstract</B>, it must override any methods which are declared <B>abstract </B>in the superclass. </P>
<P>In other words, an <B>abstract </B>method must be overridden to create a <I>concrete method</I> in the first <I>non-abstract</I> class in the inheritance hierarchy. </P>
<P>A subclass cannot override methods that are declared <B>final</B> in the superclass because, by definition, <B>final</B> methods cannot be overridden. </P>
<P><!-prev=Java044f.htm-><!-next=Java044h.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ObjectClassMethods"></A>Object Class Methods</H2>
</FONT><P><A HREF="#TheequalsMethod">The equals() Method</A><BR>
<A HREF="#TheClassClass">The Class Class</A><BR>
<A HREF="#ThegetClassMethod">The getClass() Method</A><BR>
<A HREF="#ThetoStringMethod">The toString() Method</A><BR>
<A HREF="#OtherMethods">Other Methods Provided by the Object Class</A></P>
<P>The <B>Object </B>class which is at the top of the Java class hierarchy provides a number of useful methods for all objects to use. A complete list of the available methods can be obtained from the API documentation available from JavaSoft. </P>
<P>For example, Object provides </P><DIR>

<P>a method by which one object may <I>compare </I>itself to another object, a method to <I>convert </I>an object to a string, a method to <I>wait </I>for a specified condition to occur, a method to <I>notify </I>other objects that a condition has changed, and a method to <I>return </I>a <B>Class</B> object that describes <I>the class</I> of the object. </P></DIR>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="TheequalsMethod"></A>The equals() Method</H3>
</FONT><P>Classes that you define will all inherit the <B>equals()</B> method from the <B>Object</B> class. You can use this method to <U>compare two objects for equality</U>. </P>
<P>Note that is is <U>not</U> the same as comparing two object references using the == operator. That test simply determines if two object references point to the same object. </P>
<P>The <B>equals()</B> method is intended to be used to determine if two separate objects are of the <U>same type</U> and contain the <U>same data</U>. The method returns <I>true </I>if the objects are <I>equal </I>and <B>false </B>otherwise. </P>
<P>The system already knows how to apply the <B>equals()</B> method to all of the standard classes and objects of which the compiler has knowledge. For example, you can already use the method to test two <B>String </B>objects for equality. </P>
<P>Your classes can override the <B>equals()</B> method to make an appropriate comparison between two objects of a type that you define. The following Java application overrides the <B>equals()</B> method to compare two objects of the new <B>equals1</B> class. (Obviously there is nothing to ascertain that your overridden <B>equals()</B> actually does the comparison properly, so you could make your overridden <B>equals()</B> method do just about anything that you want it to do.) </P>
<P>Note that the signature of the <B>equals()</B> method requires an argument of the generic type <B>Object</B>. </P>
<P>If you define the method with an argument of a different type, you will be overloading, not overriding the method. </P>
<P>Once the method begins execution, it is necessary to <I>downcast </I>the argument to type <B>equals1</B> before attempting to perform the comparison. We will have more to say about <I>upcasting </I>and <I>downcasting </I>in a subsequent lesson. In any event, pay particular attention to the parentheses in the downcast operation. </P>
<P>Also note the use of the <B>instanceof</B> operator to confirm that the incoming object is of the correct type. </P>
<P>In this example program one of the objects provided for equivalence testing is of the <U>wrong type </U>(<B>String</B>) and the overridden <B>equals()</B> method simply reports that it is not an equivalent object. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File <B>equals1.java</B> Copyright 1997, R.G.Baldwin
Illustrates overriding the equals() method of the Object 
class to determine if two objects are equivalent.  This is 
not the same as testing to see if two references point to 
the same object by using the == relational operator.

The program was tested using JDK 1.1.3 under Win95

<B>The output from this application is:
obj1 equals obj1: true
obj1 equals obj2: true
obj1 equals obj3: false
obj1 equals obj4: false
</B>**********************************************************/

class <B>equals1{//controlling</B> class
  int myData;
  
  <B>equals1(int</B> data){//constructor
    myData = data;
  }//end constructor
  //-----------------------------------------------------//
  
  //Overridden equals method
  public boolean <B>equals(Object</B> arg){
    //Test for proper type and not null.  If not null and 
    // proper type, test for equivalent data values.  Note 
    // the use of the instanceof operator.
    if( (arg != <B>null</B>) &amp;&amp; (<B>arg instanceof equals1</B>)){
      //If proper type, downcast object type to equals1 
      // type.  Then compare and return result
      return (this.myData == <B>((equals1)arg).myData</B>);
    }else return false;//not proper type, return false
  }//end method equals()
  //-----------------------------------------------------//

  public static void <B>main</B>(String[] args){
    //instantiate objects for testing
    equals1 obj1 = new equals1(2);
    equals1 obj2 = new equals1(2);
    equals1 obj3 = new equals1(3);
    String  obj4 = "A string object";
    
    //Perform tests and report results
    System.out.println("obj1 equals obj1: " 
                                      + obj1.equals(obj1));
    System.out.println("obj1 equals obj2: " 
                                      + obj1.equals(obj2));
    System.out.println("obj1 equals obj3: " 
                                      + obj1.equals(obj3));
    System.out.println("obj1 equals obj4: " 
                                      + obj1.equals(obj4));
  }//end main
  //-----------------------------------------------------//
}//end class definition for equals1</PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="TheClassClass"></A>The Class Class</H3>
</FONT><P>There is a class named <B>Class </B>which is defined as follows (See JavaSoft API Documentation): </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>public final class java.lang.Class<B> 
              extends java.lang.Object</B>{
// Methods
  public static Class <B>forName(String</B> className);
  public ClassLoader <B>getClassLoader</B>();
  public Class[] <B>getInterfaces</B>();
  public String <B>getName</B>();
  public Class <B>getSuperclass</B>();
  public boolean <B>isInterface</B>();
  public Object <B>newInstance</B>(); 
  public String <B>toString</B>();
}

Instances of the class <B>Class </B>represent classes
and interfaces in a running Java application.

There is no public constructor for the class <B>Class</B>.
<B>Class </B>objects are constructed automatically by the 
Java Virtual Machine as classes are loaded and or by 
calls to the <B>defineClass </B>method in the class loader.</PRE></TD>
</TR>
</TABLE>

<P>I mention the class named <B>Class</B> at this point to indicate that once you have a <B>Class</B> object that describes another object, you can make various inquiries about the object, such as getting its name and the name of its superclass. You can also instantiate new instances of the class without use of the <B>new</B> operator. We will use some of this capability in the next section. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ThegetClassMethod"></A>The getClass() Method</H3>
</FONT><P>The <B>getClass()</B> method of the <B>Object </B>class can be used to obtain a <B>Class</B> object that describes another object. That is, it returns an object of type <B>Class</B> (see the <B>Class </B>class above) which contains important information about the target object. </P>
<P>Having obtained an object of type <B>Class</B> that describes the <I>class</I> of an object, methods from the <B>Class </B>class shown above can then be used to obtain information about the object. </P>
<P>This is a fairly common technique in Java; <U>to create an object that describes another object</U>. Then methods can be invoked on the <I>descriptor </I>object to obtain information about the <I>target</I> object. In Java, we have Bean descriptor objects, File descriptor objects, Class descriptor objects, etc. </P>
<P>Also, having obtained an object of type <B>Class</B> that describes the <I>class</I> of an object, the <B>newInstance()</B> method of the <B>Class </B>class can be used to <U>instantiate another object of the same type</U>. The result is as though the <B>new</B> operator were used with a <B>Noarg</B> <I>constructor </I>of a known class. </P>
<P>If a reference to the new object is needed, it is necessary to declare the reference variable as the generic <B>Object</B> type, but the actual object will take on all the attributes of the actual class for which it is being instantiated. </P>
<P>The following program illustrates some of these features. First it simply instantiates an object, gets the <I>class </I>of that object, and applies some methods from the <B>Class </B>class to obtain and display other information about the object. </P>
<P>Next, it asks the user to enter a 0 or a 1 and instantiates a new object on the basis of the user input. </P>
<P>If the user enters a 0, a <B>String </B>object is instantiated. </P>
<P>Otherwise, a new object is instantiated by applying the <B>getClass()</B> method to an existing object and using the <B>newInstance()</B> method to instantiate <U>a new object of that type</U>. </P>
<P>The <B>getClass()</B> method is then used to obtain and display information about the new object. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File GetClass1.java Copyright 1997, R.G.Baldwin
Illustrates use of the getClass() method from the Object 
class and several methods from the Class class.  Also 
illustrates instantiating new objects of types which the 
compiler cannot possibly know about at compile time.

Tested using JDK 1.1.3 under Win95.

For a user input of 0, the output is:

<B>Name of class for obj1: GetClass1
Name of superclass for obj1: class java.lang.Object
Enter a 0 or a 1
0
Name of class for obj2: java.lang.String
Name of superclass for obj2: class java.lang.Object

</B>For a user input of 1, the output is:

<B>Name of class for obj1: GetClass1
Name of superclass for obj1: class java.lang.Object
Enter a 0 or a 1
1
Name of class for obj2: GetClass1
Name of superclass for obj2: class java.lang.Object

</B>**********************************************************/
import java.io.*;

class <B>GetClass1</B>{

  public static void <B>main</B>(String[] args){
    //instantiate an object of this type
    GetClass1 obj1 = <B>new GetClass1()</B>;
    
    //Use the getClass() method from the Object class and 
    // two methods from the Class class to obtain and 
    // display information about the object.
    System.out.println("Name of class for obj1: " 
                              + <B>obj1.getClass().getName()</B>);
    System.out.println("Name of superclass for obj1: " 
                        + <B>obj1.getClass().getSuperclass()</B>);

    //Now <B>instantiate another object</B> based on user input 
    // such that the compiler cannot possibly know the 
    // type of the object at compile time.
    <B>Object obj2 = null;//reference</B> to generic object
    System.out.println("Enter a 0 or a 1");//prompt
    
    try{
      int inData = System.in.read();//get user input
      if( (char)inData == <B>'0')//if</B> user entered '0'
        obj2 = <B>"String object";//create</B> a string object
      else 
        //create new object of the type of another object
        <B>obj2 = obj1.getClass().newInstance()</B>;
    }catch(Exception e){
      System.out.println("Exception " + e);
    }//end catch block

    //Now display the class and superclass of new object
    System.out.println("Name of class for obj2: " 
                              + <B>obj2.getClass().getName()</B>);
    System.out.println("Name of superclass for obj2: " 
                        + <B>obj2.getClass().getSuperclass()</B>);
  }//end main
}//end class GetClass1</PRE></TD>
</TR>
</TABLE>

<P>Note that the <B>getClass</B>() method is a <B>final </B>method and <U>cannot be overridden</U>. It returns a <B>Class </B>object (an object of type <B>Class</B>) which allows you to apply the methods of the <B>Class </B>class to the object. </P>
<P>We have only illustrated a couple of the methods available in the <B>Class</B> class, but since our primary emphasis here is the use of methods inherited from the <B>Object</B> class, we'll let it go at that. </P>
<P>It would be a good exercise for the student to design simple programs that illustrate the use of the remaining methods of class <B>Class.</B> </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ThetoStringMethod"></A>The toString() Method</H3>
</FONT><P>The <B>Object </B>class provides a to<B>String()</B> method that can be used to convert all objects to some appropriate string representation. The actual string representation depends on the type of object, and whether or not the <B>toString()</B> method of the <B>Object</B> class has been overridden.. </P>
<P>For example, the overridden <B>toString()</B> method extracts the integer contained in an <B>Integer </B>object. </P>
<P>Similarly, if you apply the overridden <B>toString()</B> method to a <B>Thread </B>object, certain information about the object important to threads will be extracted and returned as a string. </P>
<P>You can simply accept the default conversion of objects of your new classes, or you can <U>override</U> the method to cause it to convert objects of your design to strings according to your definition of conversion. </P>
<P>The following program illustrates overriding the <B>toString()</B> method for a newly-defined class so that it can be used to convert objects of that class into strings. </P>
<P>It also illustrates the default string representation for a new class when the <B>toString()</B> method is <U>not</U> overridden. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File myToString.java Copyright 1997, R.G.Baldwin
Illustrates overriding the toString() method of the 
Object class to display the data in an object.

Also illustrates default conversion of an object to a 
string when the class of the object has no overridden 
toString() method.

This program was tested using JDK 1.1.3 under Win95.

The output from the program for one run was:
  
<B>Obj w/overridden toString() method: Richard G. Baldwin
Obj w/o overridden toString() method: myOtherString@1cc74d

</B>**********************************************************/
class <B>myOtherString{//class</B> <B>without </B>overridden toString()
}//end class myOtherString
//=======================================================//

class <B>myToString{//controlling</B> class
  String first; //define instance variables for the class
  String middle;
  String last;
  
  //constructor
  <B>myToString(String</B> first, String middle, String last){
    this.first = first;
    this.middle = middle;
    this.last = last;
  }//end constructor
  //-----------------------------------------------------//
  
  //<B>Override toString()</B> method from Object class
  public String <B>toString</B>(){  
    //convert object to a string and return it
    return (first + " " + middle + " " + last);
  }//end overridden toString method
  //-----------------------------------------------------//
  
  public static void <B>main</B>(String[] args){//main method
    myToString obj = <B>new myToString(//instantiate</B> obj
                                 "Richard","G.","Baldwin");
    //display it using overridden toString()
    System.out.println(
                    "Obj w/overridden toString() method: " 
                                         + <B>obj.toString()</B>);
    //display object with <B>no overridden toString()</B> method
    System.out.println(
                   "Obj w/o overridden toString() method: "
                         + new <B>myOtherString().toString()</B>);
  }//end main method
  //-----------------------------------------------------//
}//end myToString class definition</PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="OtherMethods"></A>Other Methods provided by the Object Class</H3>
</FONT><P>Several other methods of the <B>Object </B>class will be discussed in other lessons. For example, the <B>finalize()</B> method will be discussed in lessons dealing with finalization. You will learn how to override the <B>finalize()</B> method for purposes associated with new types which you define. </P>
<P>There are also several methods which are used in multithreaded programming to cause the various threads to be synchronized when needed: </P>

<UL>
<LI>notify() </LI>
<LI>notifyAll() </LI>
<LI>wait() </LI></UL>

<P>These methods will be discussed in those lessons which deal with multithreaded programming. </P>
<P><!-prev=Java044g.htm-><!-next=Java044i.htm><!-first=Java044.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Review"></A>Review</H2>
</FONT><P>Q - The class at the top of the inheritance hierarchy is the <B>Object</B> class and this class is defined in the package named <I>java.Object</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The Object class is defined in the package named <I>java.lang.</I></FONT> </P>
<P>Q - We say that an object has <I>state </I>and <I>behavior</I>: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - In Java, a method can be defined as an empty method, normally indicating that it is intended to be overridden: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Including an empty method in a class definition will make it impossible to instantiate an object of that class: True or False. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False.</FONT> </P>
<P>Q - A subclass can invoke the constructor for the immediate superclass by causing the last line of of the subclass constructor to contain the keyword <B>super</B> followed by a parameter list as though calling a function named <B>super() </B>and the parameter list must match the method signature of the superclass constructor: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. This can only be accomplished by causing the <U>first line</U> of the constructor to contain the keyword <B>super</B> followed by a parameter list as though calling a function named <B>super()</B>. The parameter list must match the method signature of the superclass constructor.</FONT> </P>
<P>Q = The <B>equals()</B> method is used to determine if two reference variables point to the same object: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A- False. You can use the <B>equals() </B>method to compare two objects for equality. You can use the equality operator (==) to determine if two reference variables point to the same object.</FONT> </P>
<P>Q - The <B>equals()</B> method is used to determine if two separate objects are of the same type and contain the same data. The method returns <B><I>false </B></I>if the objects are <I>equal </I>and <B><I>true </B></I>otherwise. True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The method returns <B><I>true </B></I>if the objects are <I>equal </I>and <B>false </B>otherwise.</FONT> </P>
<P>Q - The <B>equals()</B> method is defined in the Object class: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Your classes can override the <B>equals()</B> method to make an appropriate comparison between two objects of a type that you define: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - You must override the <B>equals()</B> method to determine if two string objects contain the same data: True or False? If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The system already knows how to apply the <B>equals()</B> method to all of the standard classes and objects of which the compiler has knowledge. For example, you can already use the method to test two String objects or two array objects for equality.</FONT> </P>
<P>Q - Given an object named obj1, provide a code fragment that shows how to obtain the name of the class from which obj1 was instantiated and the name of the superclass of that class. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - See code fragment below:</FONT> </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffffff">
<PRE>  <FONT COLOR="#0000ff">  System.out.println("Name of class for obj1: " 
        + obj1.getClass().getName<B>()</B>);
    System.out.println("Name of superclass for obj1: " 
        + obj1.getClass().getSuperclass<B>()</B>);</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Given an object named obj2, provide a code fragment that shows how to use the <B>newInstance()</B> method to create a new object of the same type </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - See code fragment below:</FONT><FONT SIZE=2> </P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffffff">
<PRE><FONT COLOR="#0000ff">        obj2 = <B>obj1.getClass().newInstance()</B>;</PRE></FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>Q - By overriding the <B>getClass()</B> method, you can use that method to determine the name of the class from which an object was instantiated: True or False? If false, explain why. </P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. The <B>getClass()</B> method is a <B>final </B>method and cannot be overridden.</FONT><FONT SIZE=2> </P>
<P>Q - You must use the <B>new</B> operator to instantiate an object of type <B>Class</B>: True or False? If false, explain why. </P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. There is no public constructor for the class <B>Class</B>. <B>Class </B>objects are constructed automatically by the Java Virtual Machine as classes are loaded and or by calls to the defineClass method in the class loader.</FONT><FONT SIZE=2> </P>
<P>Q - The <B>Class </B>class provides a to<B>String()</B> method which can be used to convert all objects known to the compiler to some appropriate string representation. The actual string representation depends on the type of object: True or False? If false, explain why. </P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. The <B>Object </B>class (not the <B>Class</B> class) provides a to<B>String()</B> method which can be used to convert all objects known to the compiler to some appropriate string representation. The actual string representation depends on the type of object.</FONT><FONT SIZE=2> </P>
<P>Q - You can override the <B>toString() </B>method of the <B>Class</B> class to cause it to convert objects of your design to strings: True or False? If false, explain why. </P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. The <B>toString()</B> method is a method of the <B>Object</B> class, not the <B>Class</B> class.</FONT><FONT SIZE=2> </P>
<P>Q - By default, all classes in Java are either direct or indirect descendants of the <B>Class</B> class which is at the top of the inheritance hierarchy: True or False? If false, explain why. </P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P>A - False. By default, all classes in Java are either direct or indirect descendants of the <B>Object </B>class (not the <B>Class</B> class) which is at the top of the inheritance hierarchy.</FONT><FONT SIZE=2> </P>
<P>Q - Write a program that meets the following specification. </P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg20.java From lesson 44
Copyright 1997, R.G.Baldwin
Without viewing the solution which follows, write a Java
application that illustrates overriding the equals() method
of the Object class to determine if two objects are 
equivalent.  This is not the same as testing to see if two 
references point to the same object by using 
the == relational operator on the reference variables.

The output from this application should be:
obj1 equals obj1: true
obj1 equals obj2: true
obj1 equals obj3: false
obj1 equals obj4: false
Terminating, Baldwin
===========================================================
*/
class SampProg20{//controlling class
  int myData;
  
  SampProg20(int data){//constructor
    myData = data;

  }//end constructor

  public static void main(String[] args){
    //instantiate objects for testing
    SampProg20 obj1 = new SampProg20(2);
    SampProg20 obj2 = new SampProg20(2);
    SampProg20 obj3 = new SampProg20(3);
    String  obj4 = "A string object";
    
    //Perform tests and report results
    System.out.println("obj1 equals obj1: " 
      + obj1.equals(obj1));    
    System.out.println("obj1 equals obj2: " 
      + obj1.equals(obj2));
    System.out.println("obj1 equals obj3: " 
      + obj1.equals(obj3));
    System.out.println("obj1 equals obj4: " 
      + obj1.equals(obj4));
    
    System.out.println("Terminating, Baldwin");
  }//end main

  //Overridden equals method
  public boolean equals(Object arg){
    //Test for proper type and not null.  If not null and 
    // proper type, test for equivalent instance values.  
    // Note the use of the instanceof operator.
    if( (arg != null) &amp;&amp; (arg instanceof SampProg20)){
      //if proper type and not null
      //downcast Object type to SampProg20 type
      SampProg20 temp = (SampProg20)arg;
      //compare and return result
      return (this.myData == temp.myData);
    }else return false;//not proper type, return false
  }//end method equals() 
  
}//end class definition for SampProg20</PRE></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>Q - Write a program that meets the following specification. </P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg21.java from lesson 44
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates the use of the getClass() 
method from the Object class to determine the class of an
object.  Also illustrate the use of the getName() and
getSuperClass() methods from the Class class.  

Also illustrate the use of the newInstance() method to
instantiate a new object.

Provide a termination method with your name.

For a user input of 0, the output should be:

Name of class for obj1: SampProg21
Name of superclass for obj1: class java.lang.Object
Enter a 0 or a 1
0
Name of class for obj2: java.lang.String
Name of superclass for obj2: class java.lang.Object
Terminating, Baldwin

For a user input of 1, the output should be:

Name of class for obj1: SampProg21
Name of superclass for obj1: class java.lang.Object
Enter a 0 or a 1
1
Name of class for obj2: SampProg21
Name of superclass for obj2: class java.lang.Object
Terminating, Baldwin
**********************************************************/
import java.io.*;

class SampProg21{

  public static void main(String[] args){
    //instantiate an object of this type
    SampProg21 obj1 = new SampProg21();
    //Use the getClass() method from the Object class and 
    // two methods from the Class class to obtain and 
    // display information about the object.
    System.out.println("Name of class for obj1: " 
        + obj1.getClass().getName());
    System.out.println("Name of superclass for obj1: " 
        + obj1.getClass().getSuperclass());

    //Now instantiate another object based on user input 
    // such that the compiler cannot possibly know the 
    // type of the object at compile time.
    Object obj2 = null;//reference to a generic object
    System.out.println(
      "Enter a 0 or a 1");//prompt for input
    
    try{
      int inData = System.in.read();//get user input
      if( (char)inData == '0')//if user entered '0'
        //create a string object
        obj2 = "This is a String object";
      else 
        //create a new object of the type of another 
        // object
        obj2 = obj1.getClass().newInstance();
    }catch(Exception e){System.out.println(
      "Exception " + e);}

    //Now display the class and superclass of the 
    // new object
    System.out.println("Name of class for obj2: " 
        + obj2.getClass().getName());
    System.out.println("Name of superclass for obj2: " 
        + obj2.getClass().getSuperclass());
        
    System.out.println("Terminating, Baldwin");        
    
  }//end main
}//end class SampProg21</PRE></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>.Q - Write a program that meets the following specification. </P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg22.java from lesson 44
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates overriding the toString() 
method of the Object class.

The output from the program should be:
Object contains: Richard G. Baldwin
Terminating, Baldwin
**********************************************************/

class SampProg22{
  String first; //define instance variables for the class
  String middle;
  String last;
  
  SampProg22(String firstName, String middleName, 
    String lastName)
  {//constructor
    first = firstName;
    middle = middleName;
    last = lastName;
  }//end constructor
  
  public static void main(String[] args){//main method
    SampProg22 obj = new SampProg22(
      "Richard","G.","Baldwin");//instantiate object
    //Display it using overridden toString()      
    System.out.println(obj.toString());
    System.out.println("Terminating, Baldwin");
  }//end main method
  
  public String toString(){//Override toString() method
    //Convert object to a string and return it
    return ("Object contains: " + first + " " 
      + middle + " " + last);
  }//end overridden toString method
}//end SampProg22 class definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java044h.htm-><!-first=Java044.htm-></P>
<P>-end-<!--end--></P></BODY>
</HTML>
