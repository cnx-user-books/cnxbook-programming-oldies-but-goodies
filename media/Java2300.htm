<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
	<style>
<!--
.Indent      { margin-left: 4em; margin-right: 2em; }
-->
</style>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Generics in J2SE<sup><font size="-4">TM</font></sup> 
5.0, Getting Started</h2>
    <i>Learn about the compile-time type safety provided by generics 
in J2SE<sup><font size="-4">TM</font></sup> 5.0.&nbsp; Along the way, you will also learn about the enhanced 
<b>for</b> loop in J2SE<sup><font size="-4">TM</font></sup> 5.0.</i><p><b>Published:</b>&nbsp; 
April 5, 2005 <br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 2300</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
	<li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a><li><a href="#Run_the_Programs">Run the Programs</a></li>
  <li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listings</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>Many new features in J2SE<sup><font size="-4">TM</font></sup> 5.0</b></font></p>
<p>J2SE<sup><font size="-4">TM</font></sup> 5.0 contains many new language features, including:</p>
<ul>
	<li>Generics</li>
	<li>Enhanced for Loop</li>
	<li>Autoboxing/Unboxing</li>
	<li>Typesafe Enums</li>
	<li>Varargs</li>
	<li>Static Import</li>
	<li>Metadata</li>
</ul>
<p>In addition to the new language features, J2SE<sup><font size="-4">TM</font></sup> 5.0 contains many other new 
features such as new Look and Feel capabilities for Swing GUIs.</p>
<p><font color="#FF0000"><b>First in a series</b></font></p>
<p>This is the first lesson in a series designed to teach you how to use some of 
the new features in J2SE<sup><font size="-4">TM</font></sup> 5.0.&nbsp; This lesson will teach you some of the 
rudimentary aspects of the new capability commonly referred to as <i>generics.</i>&nbsp; 
This lesson will also teach you how to use the <i>enhanced<b> for</b> loop</i> 
with collections and also with arrays.</p>
<p>Future lessons will teach you how to use other aspects of generics and in addition will 
teach you how to use some of the other new features in J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<p><font color="#FF0000"><b>What is J2SE<sup><font size="-4">TM</font></sup> 5.0?</b></font></p>
<p>Many of my students have become confused by references to Java version 1.5, J2SE<sup><font size="-4">TM</font></sup> 5.0 and JDK 
5.0.&nbsp; In 
case this is also confusing to you, I will attempt to guide you through this 
nomenclature.&nbsp; If you already understand this nomenclature, just 
skip ahead to the section entitled <a href="#Viewing_tip">Viewing tip</a>.</p>
<p>As of the date of this writing, you can freely download JDK<sup><font size="-4">TM</font></sup> 5.0 from Sun's 
web site at the 
following URL:</p>
<p><a href="http://java.sun.com/j2se/1.5.0/download.jsp">
http://java.sun.com/j2se/1.5.0/download.jsp</a></p>
<p><font color="#FF0000"><b>A little historical perspective</b></font></p>
<p>Back in 1998 or 1999 when Java version 1.2 was 
released, Sun decided to refer to that version as Java 2.&nbsp; According to 
Sun:</p>
<blockquote>
	<p><i>&quot;... the &quot;2&quot; in Java 2 Platform Standard Edition indicates the 2nd 
	generation Java platform&quot;</i></p>
</blockquote>
<p>Also, around that time, 
<i>(or probably a little later),</i> they separated Java into three <i>editions:</i></p>
<ul>
	<li>Standard Edition - also known as J2SE</li>
	<li>Enterprise Edition - also known as J2EE</li>
	<li>Micro Edition - also known as J2ME</li>
</ul>
<p><font color="#FF0000"><b>What is the difference between the different 
editions?</b></font></p>
<p>Among other things, the different editions have different class libraries 
where the different class libraries have a different emphasis.&nbsp; 
I believe that at least the first two editions listed above have the same 
compiler and the same virtual machine.&nbsp; I'm not sure about the Micro 
Edition because I have never worked with it.</p>
<p><font color="#FF0000"><b>Java 2 has remained at the forefront</b></font></p>
<p>In any event, as the released versions have progressed through v1.2, 
v1.3, and v1.4, Sun has continued to refer to the product as Java 2, as 
exemplified by J2SE, J2EE, and J2ME.</p>
<p><font color="#FF0000"><b>Now there is an additional number</b></font></p>
<p>With the release of version 1.5, Sun has now attached another number to the common 
name for the product.&nbsp; If you go to the
<a href="http://java.sun.com/j2se/1.5.0/download.jsp">URL</a> given above, you 
will find that the web page is entitled:</p>
<div class="pagetitle2">
	<b>J2SE 5.0</b></div>
<div class="pagetitle">
	<b>Download Java 2 Platform Standard Edition 5.0</b></div>
<p>If things weren't confusing enough already, we how have <i>Java 2 Platform 
Standard Edition 5.0.</i>&nbsp; Thus, 5.0 has been added to the Java 2 
nomenclature.</p>
<p>According to sun <i>(boldface added for emphasis)</i></p>
<blockquote>
	<p><i>&quot;Both version numbers &quot;1.5.0&quot; and &quot;5.0&quot; are used to identify this 
	release of the Java 2 Platform Standard Edition. Version &quot;5.0&quot; is the <b>
	product version</b>, while &quot;1.5.0&quot; is the <b>developer version</b>. The 
	number &quot;5.0&quot; is used to better reflect the level of maturity, stability, 
	scalability and security of the J2SE.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>What is JDK<sup><font size="-4">TM</font></sup> 5.0?</b></font></p>
<p>According to Sun, the following two products are delivered under the Java<sup><font size="-4">TM</font></sup> 
2 Platform Standard Edition 5.0, also known as J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<ul>
	<li>J2SE<sup><font size="-4">TM</font></sup> Development Kit 5.0, also known 
	as JDK<sup><font size="-4">TM</font></sup> 5.0</li>
	<li>J2SE<sup><font size="-4">TM</font></sup> Runtime Environment 5.0 , also 
	known as JRE 5.0 <i>(as of the date of this writing, a trademark flag is not 
	included for JRE 5.0 on Sun's web page at
	<a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/version-5.0.html">
	http://java.sun.com/j2se/1.5.0/docs/relnotes/version-5.0.html</a>)</i></li>
</ul>
<p><i>(If you are going to develop Java programs, you need the JDK, which 
includes the JRE.&nbsp; If you are only going to run Java programs, you only 
need the JRE.)</i></p>
<p><font color="#FF0000"><b>Downloading JDK<sup><font size="-4">TM</font></sup> 5.0</b></font></p>
<p>If you scroll down the <a href="http://java.sun.com/j2se/1.5.0/download.jsp">
download page</a> a bit, you will find a section of the page that 
reads something like the text in Figure 1.&nbsp; The two boldface lines in Figure 
1 are 
download links on Sun's web page.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
<p align="left">JDK 5.0 Update 1 includes the JVM technology<br>
<br>
The J2SE Development Kit (JDK) supports creating J2SE
applications. More info...</p>
<p align="center">
<a href="http://dlc.sun.com/jdk/jdk-1_5_0_01-windows-i586-p.exe"><u><b>Download 
JDK for Windows</b></u></a><b>
<br>
</b>
<a href="http://javashoplm.sun.com:80/ECom/docs/Welcome.jsp?StoreId=22&PartDetailId=jdk-1.5.0_01-oth-JPR&SiteId=JSC&TransactionId=noreg">
<u><b>Download JDK for Other Platforms</b></u></a></p>
<p>Figure 1
		</td>
	</tr>
</table>
	<p><font color="#FF0000"><b>What version is this?</b></font></p>
<p>If you download and install the JDK for Windows by selecting the link on 
	Sun's web page and then enter <b>
	<font face="Arial Narrow">java -showversion</font></b> at the command 
	prompt, your output should be similar to Figure 2 <i>
	(boldface added for emphasis).</i>&nbsp; When I did this, I got <b>java 
version 1.5.0_01</b>.&nbsp; I assume that this is also true for the other 
platforms as well, although the last three digits in the version number are 
likely to change with time as Sun releases new versions designed to fix bugs.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
		<pre>C:\jnk&gt;java -showversion
<b>java version &quot;1.5.0_01&quot;</b>
Java(TM) 2 Runtime Environment, Standard Edition
 (build 1.5.0_01-b08)
Java HotSpot(TM) Client VM (build 1.5.0_01-b08,
 mixed mode, sharing)
		
<b>Figure 2</b></pre>
		</td>
	</tr>
</table>
	<p><font color="#FF0000"><b>The bottom line</b></font></p>
<p>Therefore, J2SE<sup><font size="-4">TM</font></sup> 5.0 is the name that Sun has given to the Java 2 
Platform Standard 
Edition developer version 1.5.0 or later.&nbsp; <i>(At this point, I don't know if this 
terminology is also being used with the Enterprise Edition and the Micro 
Edition.)</i></p>
<p>So now you know that when someone refers to J2SE<sup><font size="-4">TM</font></sup> 5.0, they are 
also referring to 
Java version 1.5.0.</p>
<p><font color="#FF0000"><b>What happened to the SDK?</b></font></p>
<p>For the past several years, Sun has referred to the Software Development Kit
<i>(SDK)</i> either as an alternative to or in addition to the JDK.&nbsp; Here 
is what Sun has to say about that now <i>(boldface added for emphasis):</i></p>
<blockquote>
	<p><i>&quot;Due to significant popularity within the Java developer community, 
	the development kit has <b>reverted back</b> to the name &quot;JDK&quot; from &quot;Java 2 
	SDK&quot; (or &quot;J2SDK&quot;), and the runtime environment has reverted back to &quot;JRE&quot; 
	from &quot;J2RE&quot;.&nbsp; Notice that &quot;JDK&quot; stands for &quot;J2SE Development Kit&quot; (to 
	distinguish it from the J2EE Development Kit). The name &quot;Java Development 
	Kit&quot; is no longer used, and has not been officially used since 1.1, prior to 
	the advent of J2EE and J2ME.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>More than you ever wanted to know</b></font></p>
<p>And that is probably more than you ever wanted to know about such things as </p>
<ul>
	<li>Java<sup><font size="-4">TM </font></sup>developer version 1.5.0</li>
	<li>Java<sup><font size="-4">TM </font></sup>product version 5.0</li>
	<li>Java<sup><font size="-4">TM</font></sup> 2 Platform Standard Edition 
	5.0, also known as J2SE<sup><font size="-4">TM</font></sup> 5.0</li>
	<li>J2SE<sup><font size="-4">TM</font></sup> Development Kit 5.0, also known 
	as JDK<sup><font size="-4">TM</font></sup> 
	5.0</li>
	<li>Java 2 SDK, also known as J2SDK</li>
	<li>J2SE<sup><font size="-4">TM</font></sup> Runtime Environment 5.0, also 
	known as 
	JRE 5.0</li>
</ul>
<p><font color="#FF0000"><b>What should you download?</b></font></p>
<p>However, when you need to download and use the Java<sup><font size="-4">TM
</font></sup>developer version 1.5.0, it helps to know where to find it. This is 
a problem because the nomenclature 1.5 doesn't appear anywhere on Sun's
<a href="http://java.sun.com/j2se/1.5.0/download.jsp">download page</a> as of 
the date of this writing in March of 2005.&nbsp; You must dig much deeper into Sun's web site to 
find the information that relates the <i>product version</i> 5.0 to the <i>developer 
version</i> 1.5.0 as described above.</p>
<blockquote>
	<p><i>(Or, you can do as I did, which is to take a chance, download JDK 
	5.0, install it, and test it to see if it is really version 1.5.0.x.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Downloadable documentation doesn't match online 
documentation</b></font></p>
<p>The documentation that I downloaded at that time stated</p>
<blockquote>
	<p><i>&quot;Its 
	<b>external</b> version number is 5.0 and <b>internal</b> version number is 1.5.0.&quot;</i></p>
</blockquote>
<p>The description of the <i><b>product</b> version</i> and <i><b>developer</b> version</i> 
in place of <i><b>external</b> version</i> and <i><b>internal</b> version</i> 
plus a link to an additional document entitled
<a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/version-5.0.html">Version 
5.0 or 1.5.0?</a> appears to have been added to the online documentation at a 
later point in time.&nbsp; In fact, as of the date of this writing in March of 
2005, the downloadable JDK<sup><font size="-4">TM</font></sup> 5.0 documentation still hasn't been updated to match 
the online documentation in this regard.</p>
<p>So much for all of that.&nbsp; Now on to other and possibly more interesting 
topics.</p>
<p><b><font color="#ff0000"><a name="Viewing_tip">Viewing tip</a></font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <a href="http://www.dickbaldwin.com">
www.DickBaldwin.com</a><font color="#000000">.</font></p>
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p><font color="#FF0000"><b>A new compiler warning</b></font></p>
<p>Have you recently tried to recompile a legacy program that has compiled and 
executed properly for many years only to get the following message from the 
compiler?</p>
<p><b><font face="Arial Narrow">Note: </b><i>ProgramName</i><b>.java uses unchecked or unsafe 
operations.<br>
Note: Recompile with -Xlint:unchecked for details.</b></font></p>
<p>If you followed up and recompiled as directed, you probably got a message 
from the compiler that looked something like the following:</p>
<p><font face="Arial Narrow"><i>ProgramName</i><b>.java:37: warning: [unchecked] 
unchecked call to <br>
add(E) as a member of the raw type java.util.ArrayList<br>
var1.add(new Date());</b></font></p>
<p>If so, congratulations, you have had your first encounter with a new feature in J2SE 
5.0 known as <i>generics.</i></p>
<p><font color="#FF0000"><b>What are generics?</b></font></p>
<p>Sun has this to say about generics <i>(boldface added for emphasis):</i></p>
<blockquote>
	<p><i>&quot;This long-awaited enhancement to the type system allows a type or 
	method to operate on objects of various types while providing <b>compile-time 
	type safety</b>.&nbsp; It adds compile-time type safety to the Collections Framework 
	and eliminates the drudgery of casting.&quot;</i></p>
</blockquote>
<p>In addition to the Collections Framework, generics impacts several other 
areas of Java programming as well.</p>
<p><font color="#FF0000"><b>Generics are not particularly easy</b></font></p>
<p>Don't be lulled into a false sense of security by what you will find in this 
lesson.&nbsp; Although the introductory material presented in this lesson is rather 
straightforward, a full understanding of generics can be fairly difficult.&nbsp; The tentacles of generics 
reach into many different areas of Java in very complex ways.</p>
<p>The truth of this is borne out by the fact that the excellent book entitled
<a href="http://www.amazon.com/exec/obidos/ASIN/0131483986/qid=1110389658/sr=11-1/ref=sr_11_1/102-4105266-9447324">
Java How to Program, Sixth Edition (Deitel)</a> dedicates an entire chapter 
consisting of more than 30 pages to generics.&nbsp; Furthermore, the chapter on 
generics doesn't even include many additional pages that the book dedicates to a 
discussion of the impact of generics on the Java Collections Framework.&nbsp; The book covers several topics 
in the chapter on generics,&nbsp; including the following:</p>
<ul>
	<li>Generic methods</li>
	<li>Generic classes</li>
	<li>Raw types</li>
	<li>Wildcards</li>
	<li>Generics and inheritance</li>
</ul>
<p>The impact of generics on the Java Collections Framework is covered in a 
different chapter.&nbsp; I hope that the benefits provided by generics outweigh the additional 
complexity.&nbsp; Only time will tell.</p>
<p><font color="#FF0000"><b>The Java Collections Framework</b></font></p>
<p>Even though the material that will be presented in this lesson will be 
relatively straightforward, you will need to know something about the Java 
Collections Framework for it to make much sense.&nbsp; If you need to learn more 
about the Java Collections Framework, see the lessons beginning with lesson 1350 
and extending through lesson 1380 at
<a href="http://www.dickbaldwin.com/tocint.htm">
http://www.dickbaldwin.com/tocint.htm</a>.&nbsp; Be aware, however, that those 
lessons were published long before generics existed in Java.&nbsp; If you compile 
the programs in those lessons using J2SE<sup><font size="-4">TM</font></sup> 5.0, you will get the warning messages 
from the compiler that I mentioned earlier.</p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p>I will present and explain seven simple programs in this lesson.&nbsp; Those 
programs are intended to illustrate the following concepts:</p>
<ul>
	<li>How the Java Collections Framework behaved prior to the release of J2SE 
	5.0.</li>
	<li>The effect of an incorrect cast in code that doesn't use generics.</li>
	<li>Avoiding the requirement to cast through the use of generics.&nbsp; This 
	program also includes an illustration of some of the required syntax for generics.</li>
	<li>Compile-time type safety provided by the use of generics.</li>
	<li>Syntax requirements for the use of iterators with generics.&nbsp; This 
	program also illustrates the use of the enhanced <b>for</b> loop with 
	collections, which is another new feature in J2SE<sup><font size="-4">TM</font></sup> 5.0.</li>
	<li>Use of the enhanced <b>for</b> loop with array objects.</li>
	<li>How to achieve pre-generic behavior with a collection and also eliminate 
	the compiler warnings.</li>
</ul>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p><font color="#FF0000"><b>Listings of the programs</b></font></p>
<p>Complete listings of all the programs discussed in this lesson are provided 
in Listing 11 through Listing 17 near the end of the lesson.</p>
<h3 align="center">Collection behavior 
prior to J2SE<sup><font size="-4">TM</font></sup> 5.0</h3>
<p>The main purpose of the program named <b>Generics01</b> is to establish a 
baseline against which to compare the other programs.&nbsp; A 
secondary purpose is to illustrate the warnings produced by the J2SE<sup><font size="-4">TM</font></sup> 5.0 
compiler when the syntax of the source code doesn't take generics into account.</p>
<p>A complete listing of the program named <b>Generics01</b> is shown in Listing 
11 near the end of the 
lesson.</p>
<p>As you will see later, this program was written using the program syntax and style that 
was correct prior to the release of J2SE<sup><font size="-4">TM</font></sup> 5.0.&nbsp; In particular, this program 
does not 
include the syntax necessary to take generics into account.</p>
<p><font color="#FF0000"><b>Notes at compile time</b></font></p>

<p>When this program is compiled using the J2SE<sup><font size="-4">TM</font></sup> 5.0 compiler, the text 
shown in Figure 3 appears on the screen.</p>




<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
		<pre>Note: Generics01.java uses unchecked or unsafe
operations.
Note: Recompile with -Xlint:unchecked for
details.
		
<b>Figure 3</b></pre>
		</td>
	</tr>
</table>
	<p>Note that the text in Figure 3 is not identified as either an error or a 
	warning.&nbsp; Rather, the text is identified simply as notes.&nbsp; These 
	notes provide instructions on how to recompile and get more information 
	regarding a potential problem.</p>
<p><font color="#FF0000"><b>Recompiling with the Xlint switch</b></font></p>
<p>When the program is recompiled using the Xlint switch shown in Figure 3, the 
compiler produces the text shown in Figure 4.&nbsp; Note that this text is 
identified as a warning.</p>
<blockquote>
	<p><i>(Later when we examine the code from the program named <b>Generics01</b>, you can compare it with this text to see just what the compiler is complaining 
about.)</i></p>
</blockquote>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
<pre>Generics01.java:34: warning: [unchecked] 
unchecked call to add(E) as a member of
 the raw type java.util.ArrayList
    var1.add(new Date());
            ^
1 warning
		
<b>Figure 4</b></pre>
		</td>
	</tr>
</table>
	<p><font color="#FF0000"><b>Get used to it</b></font></p>
<p>The text in Figure 3 and Figure 4 is similar to what you can expect to 
	see any time that you use the J2SE<sup><font size="-4">TM</font></sup> 5.0 compiler to compile a program that 
	includes the Java Collections Framework and doesn't use the required syntax 
	to take generics into account.&nbsp; This probably includes many of the 
	programs that you wrote, compiled, and executed successfully prior to the 
	release of J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<p><font color="#FF0000"><b>The program code</b></font></p>
<p>The code for the program named <b>Generics01</b> is shown in its entirety in 
Listing 1 <i>(and repeated in Listing 11 for your convenience in locating it 
later).</i></p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
import java.util.*;

public class Generics01{
  
  ArrayList var1 = new ArrayList();

  void runIt(){
    var1.add(new Date());
    //Note the required cast in the following
    // statement.
    System.out.println(
                  <b>((Date)var1.get(0)).getTime())</b>;
  }//runIt

  public static void main(String[] args){
    new Generics01().runIt();
  }//end main
  
}//end class Generics01

<b>Listing 1</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>The main method</b></font></p>
<p>As you can see, the <b>main</b> method in Listing 1 instantiates a new object 
of the class named <b>Generics01</b>, and invokes the method named <b>runIt</b> 
on that object.&nbsp; It is the behavior of the <b>runIt</b> method that 
interests us.&nbsp; More particularly, it is the expression highlighted in 
boldface in Listing 1 that interests us the most.</p>
<p><font color="#FF0000"><b>A baseline program</b></font></p>
<p>As mentioned earlier, the main purpose of this program is to establish a 
baseline against which we can compare the other programs to be discussed later.&nbsp; 
This program was written exactly as it would have been written prior to the 
release of generics in J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<p><font color="#FF0000"><b>An ArrayList object</b></font></p>
<p>The program declares and initializes an instance variable named <b>var1</b> 
with a reference to an object instantiated from the class named <b>ArrayList</b>.&nbsp;
<b>ArrayList</b> is one of the concrete implementations of the interfaces provided in the Java 
Collections Framework.&nbsp; Briefly, an object of the <b>ArrayList</b> class is an object that implements the <b>
List</b> interface, providing a convenient place to store references to other objects.</p>
<p>One of the methods of an <b>ArrayList</b> class is the method named <b>add</b>.&nbsp; 
This method is used to add new elements to the end of the list.</p>
<p><font color="#FF0000"><b>Adding a Date object's reference to the list</b></font></p>
<p>Listing 1 invokes the <b>add</b> method to add a new <b>Date</b> object's 
reference to the list.</p>
<blockquote>
	<p><i>(This is the method invocation that the compiler was complaining about 
	in the warning in Figure 4.)</i></p>
</blockquote>
<p>When an object's reference is added to an <b>ArrayList</b> object <i>(without 
the use of generic syntax),</i> that reference is automatically converted to and 
stored as type <b>Object</b>.</p>
<blockquote>
	<p><i>(That is probably also true even with the use of generic syntax.&nbsp; 
	I will have more to say about this later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What can you do with a reference of type Object?</b></font></p>
<p>I often tell my students that there are only twelve things that you can do 
with an object's reference that has been converted to type <b>Object</b>.&nbsp; 
The first eleven of those twelve things is to invoke any one of the eleven 
methods that are defined in the <b>Object</b> class and inherited into all 
subclasses of <b>Object</b>.&nbsp; The twelfth thing is to attempt to cast the 
reference to some other type in an attempt to invoke some other method on the 
reference after casting.</p>
<p><font color="#FF0000"><b>Invoking getTime on the reference</b></font></p>
<p>The objective of the code in this program is to invoke the method named <b>
getTime</b> on the <b>Date</b> object's reference.&nbsp; The <b>getTime</b> 
method is not one of the eleven methods that are defined in the <b>Object</b> 
class.&nbsp; Rather, it is defined in the <b>Date</b> class.</p>
<p><font color="#FF0000"><b>Change the type of the reference</b></font></p>
<p>Therefore, in order to invoke the <b>getTime</b> method on the reference 
after it is retrieved from the <b>ArrayList</b> object, the type of the 
reference must be converted from type <b>Object</b> to type <b>Date</b>.&nbsp; 
This is accomplished by the cast operation in the expression that is highlighted 
in boldface in Listing 1.</p>
<p>The boldface code in Listing 1 invokes the <b>get</b> method on the reference 
to the <b>ArrayList</b> object to retrieve the element stored at index 0 of the 
collection.&nbsp; The <b>get</b> method returns the reference as type <b>Object</b>
<i>(at least that was true prior to the introduction of generics).</i>&nbsp; 
Then the boldface expression in Listing 1 casts the reference to type <b>Date</b>, 
converting its type back to type <b>Date</b>.&nbsp; </p>
<p><font color="#FF0000"><b>Invoking the getTime method</b></font></p>
<p>Finally, the boldface expression successfully invokes the <b>getTime</b> 
method on the reference of type <b>Date</b>.</p>
<blockquote>
	<p><i>(Note that the program won't compile without the cast.)</i></p>
</blockquote>
<p>The program produces an output similar to that shown below:</p>
<p><font face="Arial Narrow">1110490974540</font></p>
<p>This is the number of milliseconds since January 1, 1970, 00:00:00 GMT 
represented by the <b>Date</b> object.</p>
<p><font color="#FF0000"><b>Casting was a necessity prior to J2SE<sup><font size="-4">TM</font></sup> 5.0</b></font></p>
<p>Prior to the release of J2SE<sup><font size="-4">TM</font></sup> 5.0, it was always necessary to cast references 
retrieved from collection objects in order to invoke any methods on them other 
than the eleven methods defined in the <b>Object</b> class.</p>
<p>Some authors refer to this casting requirement as <i>&quot;the drudgery of 
casting,&quot;</i> and indicate that casting may be eliminated through generics.</p>
<blockquote>
	<p><i>(In my opinion, from this viewpoint alone, the cure is worse than the 
	disease.&nbsp; Casting syntax is much simpler and more straightforward than generics syntax.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>May eliminate runtime errors and exceptions</b></font></p>
<p>However, it is possible for the programmer to perform an incorrect cast at 
this point in the program, which will usually result in a <b>ClassCastException</b> 
being thrown at runtime.</p>
<p>The great promise of generics is that it can sometimes cause programming 
errors to be recognized at compile time instead of encountering them at runtime.</p>
<p>Obviously, the best approach is to avoid writing programs containing 
programming errors in the first place.&nbsp; However, if you are going to write 
programs containing errors, it is usually better to catch them at compile time 
than to have them occur at runtime.&nbsp; This is the thing that may make the 
complexity of generics worthwhile.</p>
<h3 align="center">An incorrect cast in code that doesn't use generics</h3>
<p>The program named <b>Generics02</b> <i>(shown later in Listing 2)</i> illustrates the application of an 
incorrect cast to an element that is retrieved from an <b>ArrayList</b> object, 
along with the runtime error that is produced by that incorrect cast.</p>
<p><font color="#FF0000"><b>No compiler error</b></font></p>
<p>This program does not produce a compiler error.</p>
<blockquote>
	<p><i>(However, the J2SETM 5.0 
compiler does produce a warning having to do with the failure to apply 
the new generics syntax that was released in J2SETM 5.0.&nbsp; Note that earlier 
	compilers would not have produced such a warning.)</i></p>
</blockquote>
<p>The point here 
is that the compiler 
does not check to confirm that the correct cast is applied.&nbsp; This results 
in a successful compilation, but the program throws an exception at runtime.</p>
<p><font color="#FF0000"><b>A ClassCastException</b></font></p>
<p>The runtime exception that is thrown by this program is shown in Figure 5.&nbsp; 
You can compare the details of this exception with the program code later.&nbsp; 
The reference to line 46 in Figure 5 is a reference to the boldface statement in 
Listing 2.</p>

<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
<pre>Exception in thread "main" 
java.lang.ClassCastException: java.lang.String
        at Generics02.runIt(Generics02.java:46)
        at Generics02.main(Generics02.java:53)
		
<b>Figure 5</b></pre>
		</td>
	</tr>
</table>
	<p><font color="#FF0000"><b>The program code</b></font></p>
<p>The program is shown in its entirety in Listing 2 below, <i>(and also in Listing 
12 near the end of the lesson).</i>&nbsp; As before, the <b>main</b> method 
instantiates an object of the <b>Generics02</b> class and invokes the <b>runIt</b> 
method on that object.&nbsp; Also as in the previous program, this program 
instantiates a new <b>ArrayList</b> object and saves the object's reference in 
the instance variable named <b>var1</b>.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
<init>import java.util.*;

public class Generics02{
  
  ArrayList var1 = new ArrayList();
  
  void runIt(){
    var1.add(new Date());
    var1.add("abcd");
    <b>System.out.println(
                  ((Date)var1.get(1)).getTime());</b>
    System.out.println(
                 ((String)var1.get(1)).length());
  }//end runIt

  public static void main(String[] args){
    new Generics02().runIt();
  }//end main
  
}//end class Generics02

<b>Listing 2</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>The runIt method</b></font></p>
<p>The <b>runIt</b> method begins by populating the <b>ArrayList</b> object with 
references to two different objects of different types.&nbsp; One of the objects 
is type <b>Date</b>.&nbsp; The other object is type <b>String</b>.</p>
<p><font color="#FF0000"><b>A questionable programming style</b></font></p>
<p>While this is probably not a very good programming style, it is a style that 
was commonly used by Java programmers prior to the advent of generics.&nbsp; It 
was common to populate collection objects with references to a mixture of 
objects of different types.&nbsp; </p>
<blockquote>
	<p><i>(The use of generics strongly discourages this programming style, 
	although as you will see later, it is still possible even with generics.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>References are stored as type Object</b></font></p>
<p>As you already know, when these object's references are put into the 
collection, the types of all the references are automatically converted to type
<b>Object</b>.&nbsp; As you also already know, when the references are retrieved 
from the collection, if the purpose is to invoke any method on a reference other 
than one of the eleven methods defined in the <b>Object</b> class, it is 
necessary to cast the reference to a type that is consistent with the method.</p>
<p><font color="#FF0000"><b>Casting errors are likely</b></font></p>
<p>This is a scenario where the programmer is likely to make a casting error 
when casting elements retrieved from the collection.&nbsp; Unless the programmer 
uses the <b>instanceof</b> operator to determine the type of a retrieved 
reference prior to performing the cast, the programmer is depending on his 
memory to know the type of each reference in the population on the basis of the 
index of the element.&nbsp; If the programmer loses track of the types of the 
different references with respect to the element's indices, a casting error is a 
strong possibility.</p>
<p><font color="#FF0000"><b>The error scenario</b></font></p>
<p>This is the error scenario depicted by the boldface statement in Listing 2.&nbsp; 
In this case, the element at index 0 is a reference to a <b>Date</b> object, and 
the element at index 1 is a reference to a <b>String</b> object.&nbsp; However, 
the programmer mistakenly retrieves the element at index 1 and attempts to cast 
it to type <b>Date</b>, which is the type of the reference at index 0.&nbsp; 
This results in the runtime exception shown in Figure 5.</p>
<p>Of course, it has always been possible to use the <b>instanceof</b> operator 
to confirm the type of a reference before performing a cast as a way to avoid 
this type of programming error.&nbsp; Good programming practice would dictate 
the use of that construct when working with references to objects of mixed types 
in a single collection.</p>
<h3 align="center">Avoiding the requirement to cast through the use of generics</h3>
<p>The program named <b>Generics03</b> shown in Listing 3 below, <i>(and also in 
Listing 13 near the end of the lesson)</i> illustrates how generics can be used to 
avoid the requirement to cast references when they are retrieved from a 
collection.</p>
<blockquote>
	<p><i>(While casting is not difficult, avoiding the requirement to cast can 
	also avoid the possibility of casting incorrectly.)</i></p>
</blockquote>
<p>As in the previous programs, the <b>main</b> method in this program 
instantiates an object of the class named <b>Generics03</b> and invokes the 
method named <b>runIt</b> on the object.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
import java.util.*;

public class Generics03{
  
  ArrayList <b>&lt;Date&gt;</b> var1 = new ArrayList<b>&lt;Date&gt;</b>();

  void runIt(){
    var1.add(new Date());
    //Note that no cast is required in the
    // following statement.
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics03().runIt();
  }//end main
  
}//end class Generics03

<b>Listing 3</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>Instantiate an ArrayList object</b></font></p>
<p>Also, as in the previous programs, this program declares an instance variable 
named <b>var1</b> and initializes that variable with a reference to a new object 
of type <b>ArrayList</b>.&nbsp; However, the syntax that is used for this 
purpose in this program is significantly different from the syntax used for the same purpose in 
the previous two programs.</p>
<blockquote>
	<p><i>(Note the code in boldface that shows the type <b>Date</b> enclosed in 
	matching angle brackets, as in <b>&lt;Date&gt;</b>.&nbsp; This is the primary 
	syntax change required to use generics.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does this syntax mean?</b></font></p>
<p>One way to think of this syntax is that the expression on the right of the 
assignment operator containing <b>&lt;Date&gt;</b> instantiates a new <b>ArrayList</b> 
object that is capable of containing only references to objects of type <b>Date</b>.</p>
<blockquote>
	<p><i>(Those references are still stored as type <b>Object</b>.&nbsp; We 
	will see how this apparent discrepancy is reconciled later through automatic 
	casting.)</i></p>
</blockquote>
<p>Similarly, the expression on the left of the assignment operator is the 
declaration of an instance variable capable of holding a reference to an <b>ArrayList</b> 
object, which in turn is capable of containing only references to objects of 
type <b>Date</b>.</p>
<p><font color="#FF0000"><b>Must qualify both expressions</b></font></p>
<p>It is necessary to qualify the expressions on both sides of the assignment 
operator by use of the syntax <b>&lt;Date&gt;</b>.&nbsp; If the qualifier is 
included in the expression on the right, but is omitted 
from the variable declaration on the left, the compilation fails later when 
the code retrieves the reference.&nbsp; The reference is retrieved as type <b>Object</b> 
instead of type <b>Date</b>, which is inconsistent with the method named <b>
getTime</b>.</p>
<p>If the <b>&lt;Date&gt;</b> qualifier is included with the variable declaration on 
the left and omitted from the instantiation of the new object on the right, the 
program compiles and runs successfully.&nbsp; However, the compiler issues an <i>
unchecked conversion</i> warning indicating the possibility of a runtime error 
under certain conditions.</p>
<blockquote>
	<p><i>(I will have more to say about the importance of such warnings later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>What does Sun have to say?</b></font> </p>
<p>According to Sun <i>(boldface added for emphasis),</i> </p>
<blockquote>
	<p><i>&quot;Generics provides a way for you to communicate the type of a 
	collection to the compiler, so that it can be checked. Once the compiler 
	knows the element type of the collection, the compiler can check that you 
	have used the collection consistently and <b>can insert the correct casts</b> 
	on values being taken out of the collection.&quot;</i></p>
</blockquote>
<p>Note the boldface text in the above quotation indicating that the compiler 
modifies your code by inserting casts where appropriate.</p>
<p><font color="#FF0000"><b>Compile-time type safety</b></font></p>
<p>In discussing code similar to the code in Listing 3, Sun states,</p>
<blockquote>
	<p><i>&quot;... so the compiler can verify at compile time that the type 
	constraints are not violated at run time. Because the program compiles 
	without warnings, we can state with certainty that it will not throw a <b>
	ClassCastException</b> at run time. The net effect of using generics, 
	especially in large programs, is improved readability and robustness.&quot;</i></p>
</blockquote>
<p>In order to achieve compile-time type safety, it is necessary that the 
program compiles without warnings.&nbsp; Otherwise, the program may execute, but 
may throw a <b>ClassCastException</b> at runtime.</p>
<p><font color="#FF0000"><b>More on generics with collections</b></font></p>
<p>In further explaining generics as used with collections, Sun goes on to say
<i>(boldface added for emphasis):</i></p>
<blockquote>
	<p><i>&quot;... when we declare c to be of type Collection&lt;String&gt;,&nbsp; this 
	tells us something about the variable c that holds true wherever and 
	whenever it is used, and the compiler guarantees it (assuming the program 
	<b>compiles without warnings</b>). A cast, on the other hand, tells us something 
	the programmer thinks is true at a single point in the code, and the VM 
	checks whether the programmer is right only at run time.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>The bottom line</b></font></p>
<p>The bottom line on generics <i>(when used with collections)</i> seems to be 
that references to objects are still stored in the collection as type <b>Object</b>.&nbsp; 
However, when we notify the compiler of the type of data to be stored in the 
collection using syntax such as <b>&lt;Date&gt;</b>, and the program compiles without 
warnings, the compiler will do at least the following:</p>
<ul>
	<li>Ensure that only references to objects of the specified type are stored 
	in the collection, and used consistently throughout the program, thus 
	eliminating the possibility of a <b>ClassCastException</b> at runtime.</li>
	<li>Automatically cast the reference to the specified type when it is later 
	retrieved by program code.</li>
</ul>
<p><font color="#FF0000"><b>No explicit cast is required</b></font></p>
<p>That brings us back to a discussion of the code in Listing 3.&nbsp; Note that 
unlike the code in Listing 1, the print statement in Listing 3 does not contain 
an explicit cast to type <b>Date</b>, <i>(at least not in the code that I 
wrote).</i></p>
<p>As described above, having been notified that the collection can contain only 
references to objects of type <b>Date</b>, the compiler automatically inserted a 
cast to type <b>Date</b> at the appropriate place in the code, thereby 
guaranteeing that the reference is converted from type <b>Object</b> to type <b>
Date</b> before the <b>getTime</b> method is invoked on the reference.&nbsp; </p>
<p>There is still a cast involved.&nbsp; However, the cast is 
automatically inserted by the compiler.&nbsp; This eliminates the requirement for 
me <i>(the programmer</i>) to insert the cast, and also eliminates the 
possibility of me inserting an incorrect cast.</p>
<p>Once again, all of this assumes that the program compiles without warnings.</p>
<p><font color="#FF0000"><b>Program output</b></font></p>
<p>The program in Listing 3 compiled and executed correctly, producing the 
following output for one particular run.<br>
<br>
<font face="Arial Narrow">1110504030101</font></p>
<h3 align="center">Compile-time type safety provided by the use of generics</h3>
<p>The program named <b>Generics04</b> shown in Listing 4 <i>(and also in 
Listing 14)</i> illustrates the ability of generics to prevent 
the storing of the wrong type of references in a collection.&nbsp; This in turn 
can prevent runtime errors.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
import java.util.*;

public class Generics04{
  
  <b>ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();</b>
  
  void runIt(){
    var1.add("abcd");
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics04().runIt();
  }//end main

}//end class Generics04

<b>Listing 4</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>A new ArrayList object</b></font></p>
<p>The boldface statement in Listing 4 instantiates a new object of type <b>
ArrayList</b> capable of storing only references to objects of type <b>Date</b>.&nbsp; 
This object's reference is stored in the instance variable named <b>var1</b>.</p>
<blockquote>
	<p><i>(This statement is identical to the statement used for the same 
	purpose in the program in Listing 3.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Other types cannot be stored in the collection</b></font></p>
<p>Once the <b>ArrayList</b> has been constrained to contain only references to 
objects of type <b>Date</b>, the compiler will not allow a reference to an 
object of any other type <i>(other than types that are assignment compatible 
with <b>Date</b>, such as subclasses of <b>Date</b>)</i> to be stored in the collection.</p>
<blockquote>
	<p><i>(I will discuss the impact of generics on the inheritance hierarchy in 
	a future lesson.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A compiler error rather than a runtime error</b></font></p>
<p>The first statement in the <b>runIt</b> method in Listing 4 attempts to add a 
new element to the <b>ArrayList </b>object.&nbsp; The new element is a reference to a literal <b>String</b> object that encapsulates the string &quot;abcd&quot;.&nbsp; 
This results in the compiler error shown in Figure 6.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400">
	<tr>
		<td>
		<pre>Generics04.java:34: cannot find symbol
symbol  : method add(java.lang.String)
location: 
  class java.util.ArrayList&lt;java.util.Date&gt;
    var1.add("abcd");
        ^
1 error
		
<b>Figure 6</b></pre>
		</td>
	</tr>
</table>
	<p>Without the use of generics, a reference to an object of any type could 
	be added to the collection.&nbsp; This could result in a runtime error later if 
	the programmer expected an object of type <b>Date</b> when in fact the 
	object is of type <b>String</b>.&nbsp; If you are going to write programs 
	containing errors, 
	compiler errors are almost always preferable to runtime errors.</p>
<h3 align="center">Generic iterator syntax and the enhanced for loop </h3>
<p><font color="#FF0000"><b>Iterators</b></font></p>
<p>Listing 3 and Listing 4 showed you the syntax that you must use to cause a 
collection object to be treated as a generic collection.&nbsp; You must also use 
a special syntax when working with generic iterators and the Java 
Collections Framework.</p>
<p><font color="#FF0000"><b>The enhanced for loop</b></font></p>
<p>Another new feature of J2SE<sup><font size="-4">TM</font></sup> 5.0, referred to by Sun as an <i>enhanced 
<b>for</b> 
loop</i> can be used in certain situations to provide most of the benefits of an 
iterator with a somewhat simpler syntax.&nbsp; </p>
<blockquote>
	<p><i>(The enhanced for loop is also sometimes referred to as a for-each 
	loop.)</i></p>
</blockquote>
<p>The program named <b>Generics05</b>, which begins in Listing 5, illustrates both of these 
concepts.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>As in the previous programs, the <b>main</b> method instantiates an object of 
the <b>Generics05</b> class and invokes the <b>runIt</b> method on that object.&nbsp; 
You can view the <b>main</b> method as part of a listing of the entire program 
named <b>Generics05</b> in Listing 15 near the end of the lesson.</p>
<p><font color="#FF0000"><b>Instantiate a generic ArrayList object</b></font></p>
<p>This program is a little longer than the previous programs, so I will break 
it down and explain it in fragments.</p>
<p>Listing 5 shows the beginning of the <b>Generics05</b> class.&nbsp; The code 
in Listing 5 instantiates a new <b>ArrayList</b> object capable of storing 
references to objects of type <b>Date</b> only.&nbsp; The code in Listing 5 also 
saves that object's reference in a generic instance variable named <b>var1</b>.&nbsp; 
This is the same syntax that you have seen in previous listings.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
import java.util.*;

public class Generics05{
  ArrayList <b>&lt;Date&gt;</b> var1 = new ArrayList<b>&lt;Date&gt;</b>();

<b>Listing 5</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>Populate the collection</b></font></p>
<p>Listing 6 shows the beginning of the <b>runIt</b> method.&nbsp; This code 
populates the <b>ArrayList</b> object with references to three <b>Date</b> 
objects.&nbsp; The first object encapsulates the current date and time.&nbsp; 
The second object encapsulates the date and time one day later than the first.&nbsp; 
The third object encapsulates the date and time two days later than the first 
object.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the ArrayList object
    var1.add(new Date(now));
    var1.add(new Date(now + oneDay));
    var1.add(new Date(now + 2 * oneDay));

<b>Listing 6</b></pre></td></tr>
</table></p>

<p>The code in Listing 6 is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>Get and use an iterator</b></font></p>
<p>An iterator is an object instantiated from a specially designed class that 
implements the <b>Iterator</b> interface.&nbsp; The design of the class makes it 
possible for client code to gain sequential access to each element encapsulated in an 
associated collection object without a requirement to know anything about how the 
collection is structured.</p>
<blockquote>
	<p><i>(If you are unfamiliar with the use of iterators and the Java 
	Collections Framework, you can learn about those topics in my earlier 
	lessons numbered 1350 through 1380.&nbsp; You will find links to those lessons 
	at <a href="http://www.dickbaldwin.com/tocint.htm">http://www.dickbaldwin.com/tocint.htm</a>.&nbsp; Note, however, that those 
	lessons were published long before the release of J2SE<sup><font size="-4">TM</font></sup> 5.0, and therefore 
	they do 
	not explain generic iterators.&nbsp; That is the purpose of this lesson.)</i></p>
</blockquote>

<p><font color="#FF0000"><b>Required syntax</b></font></p>
<p>The first statement in Listing 7 shows the syntax required to get and save a 
reference to a generic iterator for the <b>ArrayList</b> object instantiated 
earlier in Listing 5.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
    Iterator <b>&lt;Date&gt;</b> iter = var1.iterator();
    
    //Perform the iteration
    while(iter.hasNext()){
      System.out.println(iter.next());
    }//end while loop
    
    System.out.println();//blank line

<b>Listing 7</b></pre></td></tr>
</table></p>

<p>Note the requirement to qualify the declaration of the local variable named
<b>iter</b> with the type of data stored in the collection using the syntax <b>
&lt;Date&gt;</b>.&nbsp; You might think of this as a variable capable of holding a 
reference to an iterator object, which is capable of iterating on an <b>ArrayList</b> 
object, which in turn is capable of storing references to objects of type <b>
Date</b> only.</p>
<p><font color="#FF0000"><b>Perform the iteration</b></font></p>

<p>The remaining code in Listing 7 uses the iterator to sequentially access and 
display a text representation of each of the three<b> Date </b>objects whose 
references are stored in the <b>ArrayList</b> object.&nbsp; This is standard 
code for the use of an iterator and should not require further explanation.&nbsp; 
This code produces the first three lines of text <i>(plus the blank line)</i> shown in Figure 7.</p>
<p><font color="#FF0000"><b>The program output</b></font></p>


<p>The output produced by this program depends on when you run it.&nbsp; The 
output produced for one particular run is shown in Figure 7.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400"><tr><td><pre>
Fri Mar 11 06:29:38 CST 2005
Sat Mar 12 06:29:38 CST 2005
Sun Mar 13 06:29:38 CST 2005

Fri Mar 11 06:29:38 CST 2005
Sat Mar 12 06:29:38 CST 2005
Sun Mar 13 06:29:38 CST 2005
		
<b>Figure 7</b></pre></td></tr></table>
<p>The output will be different each time you run the program depending on the 
current date and time.</p>
<p><font color="#FF0000"><b>The enhanced for loop</b></font></p>
<p>The code in Listing 8 performs the same iteration using the new enhanced <b>
for</b> loop that was released in J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
    for(Date element : var1){
      System.out.println(element);
    }//end for-each

  }//end runIt

<b>Listing 8</b></pre></td></tr>
</table></p>

<p>You might think of this syntax as meaning:</p>
<blockquote>
	<p><i>For each element of type <b>Date</b> contained in the collection 
	referred to by <b>var1</b>, get the value of the element and save it in the 
	variable named<b> element</b>.&nbsp; Then use the contents of that variable 
	to perform the operations specified within the body of the loop.</i><b>
	</b></p>
</blockquote>
<p>In this case, the only operation contained within the body of the loop is to 
display a text representation of the object referred to by the contents of the 
variable named <b>element</b>.</p>
<p><font color="#FF0000"><b>More compact syntax</b></font></p>
<p>As you can see, this approach does not require you to get an iterator and to 
explicitly use that iterator to sequentially access the elements in the collection.&nbsp; 
Thus, the syntax is more compact than the syntax shown in Listing 7.&nbsp; 
Further, by eliminating the requirement to get the iterator, this construct also 
eliminates the requirement for you to qualify the code using the <b>&lt;Date&gt;</b> 
syntax.&nbsp; All of those details are handled automatically behind the scenes.</p>
<p><font color="#FF0000"><b>Not quite as powerful as an iterator</b></font></p>
<p>Although not shown in Listing 7, the use of an iterator allows you to remove 
the most recently accessed element from a collection.&nbsp; As near as I can 
tell, the enhanced <b>for</b> loop does not provide that capability.&nbsp; 
Therefore, the enhanced <b>for</b> loop is not quite as powerful as an iterator.&nbsp; 
However, if you don't need to remove elements from the collection, the enhanced
<b>for</b> loop appears to be a good and somewhat simpler alternative to an 
iterator.</p>
<p><font color="#FF0000"><b>The output</b></font></p>
<p>The code in Listing 8 produced the last three lines of text in the output 
shown in Figure 7.&nbsp; Obviously the last three lines match the first three 
lines since they simply represent different ways to produce a text representation of 
the same three <b>Date</b> objects.</p>
<h3 align="center">Use of the enhanced <b>for</b> loop with array objects</h3>
<p>Although this has nothing to do with generics, I want to point out that the 
new enhanced <b>for</b> loop can also be used with Java array objects in 
addition to java collections.&nbsp; This is illustrated by the program shown in 
Listing 9 <i>(and also in Listing 16).</i></p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
/*File Generics06.java 
Copyright 2005, R.G.Baldwin

Illustrates use of enhanced for loop with an
array object  Requires J2SE 5.0.  Depending on
when the program is run, the output should be 
similar to the following:

Fri Mar 11 08:08:37 CST 2005
Sat Mar 12 08:08:37 CST 2005
Sun Mar 13 08:08:37 CST 2005

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics06{
  
  //Create an array object suitable for 
  // storing references to Date objects.
  Date[] var1 = new Date[3];
  
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the array object
    var1[0] = new Date(now);
    var1[1] = new Date(now + oneDay);
    var1[2] = new Date(now + 2 * oneDay);

    //Iterate on the array object using the new
    // for-each construct.
<b>    for(Date element : var1){
      System.out.println(element);
    }//end for-each</b>

  }//end runIt

  public static void main(String[] args){
    new Generics06().runIt();
  }//end main
  
}//end class Generics06

<b>Listing 9</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>Similar to Generics05</b></font></p>
<p>This program is very similar to the earlier program named <b>Generics05</b>.&nbsp; 
The main difference is that the earlier program stored the <b>
Date</b> object's references in a generic collection of type <b>ArrayList</b>.&nbsp; 
This program stores the <b>Date</b> object's references in a simple array 
object of type <b>Date</b>.</p>
<p>The main point is that this program iterates on the array object using an enhanced <b>for</b> loop with the 
exact same syntax as that used in the previous program to iterate on a generic 
collection.&nbsp; That 
code is highlighted in boldface in Listing 9.</p>
<p><font color="#FF0000"><b>What is the meaning of the code?</b></font></p>
<p>As before, you might think of the syntax of the boldface code in Listing 9 as 
meaning:</p>
<blockquote>
	<p><i>For each element of type <b>Date</b> contained in the array object 
	referred to by <b>var1</b>, get the value of the element and save it in the 
	variable named<b> element</b>.&nbsp; Then use the contents of that variable to 
	perform the operations specified within the body of the loop.</i><b>
	</b></p>
</blockquote>
<p>Otherwise, this program is completely straightforward, and I won't discuss it 
further.</p>
<h3 align="center">Reverting back to pre-J2SE<sup><font size="-4">TM</font></sup> 5.0 operation</h3>
<p>I can imagine that the true believers in generics will consider what I am 
about to tell you now to be heresy.</p>
<p><font color="#FF0000"><b>May not want to use generics</b></font></p>
<p>Suppose that for reasons of your own, you don't want to take advantage of the 
improvements in compile-time type safety provided by generics.&nbsp; For example, suppose that like many of 
us, you have lots of proven legacy code that is based on the Java Collections 
Framework.&nbsp; The programs do exactly what they are supposed to do, and you 
have no desire to upgrade them to make them fully compliant with generics.</p>
<p><font color="#FF0000"><b>Tired of seeing compiler warnings</b></font></p>
<p>Suppose also that for reasons of your own you occasionally need to recompile those programs and you don't want to see compiler warnings produced by the J2SE 
5.0 compiler with regard to generics every time you recompile.&nbsp; An interesting question is,</p>
<blockquote>
	<p><i>&quot;What is the easiest way for you to make the compiler quit complaining 
	and to keep the behavior of your programs exactly the same as before?&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>One possible solution</b></font> </p>
<p>This solution may not be the best way to accomplish this objective.&nbsp; 
There may be better ways, possibly using generic wildcards.&nbsp; Also, true 
believers in generics will probably consider this to be poor programming 
practice.&nbsp; However, I am going to show you one way to eliminate the 
compiler warnings and to keep the behavior of your programs exactly the same as 
before.</p>
<p><font color="#FF0000"><b>The program named Generics07</b></font></p>
<p>The program named <b>Generics07</b> illustrates the syntax that can be used to restore an
<b>ArrayList</b> collection to a state where it is capable of storing references to objects of mixed types.&nbsp; 
This syntax also eliminates the generics-related compiler warnings that are produced 
by the J2SE<sup><font size="-4">TM</font></sup> 5.0 compiler.</p>
<p><font color="#FF0000"><b>And the solution is ...</b></font></p>
<p>What you need to do is to qualify your collection-instantiation code using <b>
&lt;Object&gt;</b> so that each of your collection objects can store references to 
objects of type <b>Object</b> only.&nbsp; Because a reference to any object can 
be treated as type <b>Object</b>, you can then store references to objects of 
any type in the collection.&nbsp; This is exactly how collections behaved prior 
to the advent of generics in J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<p><font color="#FF0000"><b>Don't forget to cast correctly</b></font></p>
<p>Having done this, you must remember that in order to invoke any method other 
than one of the eleven methods defined in the <b>Object</b> class on a reference 
that is retrieved from the collection, you must cast the retrieved 
reference to an appropriate type just as you did before J2SE<sup><font size="-4">TM</font></sup> 5.0 was released.</p>
<p>Also remember that in doing this you have effectively disabled the 
compile-time type safety feature of generics.&nbsp; It will be up to you to make certain 
that you cast correctly.</p>
<p><font color="#FF0000"><b>The program named Generics07</b></font></p>
<p>The program named <b>Generics07</b> is shown in Listing 10 <i>(and also in 
Listing 17 near the end of the lesson).</i></p>
<p></p><table bgcolor="#ffff00" border="1" cols="1" width="400"><tr><td><pre>
import java.util.*;

public class Generics07{
  
  <b>ArrayList &lt;Object&gt; var1 = 
                         new ArrayList&lt;Object&gt;();</b>
  
  void runIt(){
    var1.add(new Date());
    //Note the requirement to perform a cast in
    // the following print statements.
    System.out.println(
                  ((Date)var1.get(0)).getTime());
    var1.add("abcd");
    System.out.println(
                 ((String)var1.get(1)).length());
  }//end runIt

  public static void main(String[] args){
    new Generics07().runIt();
  }//end main
  
}//end class Generics07

<b>Listing 10</b></pre></td></tr>
</table></p>

<p><font color="#FF0000"><b>Instantiate an ArrayList object</b></font></p>
<p>The boldface statement in Listing 10 instantiates an <b>ArrayList</b> object 
and saves that object's reference in the instance variable named <b>var1</b>.</p>
<p>Note that the expressions on both sides of the assignment operator are qualified 
using <b>&lt;Object&gt;</b>.&nbsp; This, in effect, uses generics to produce a 
collection object that behaves the same way that collection objects behaved 
prior to J2SE<sup><font size="-4">TM</font></sup> 5.0.&nbsp; This also satisfies 
the compiler so that it won't issue the warnings discussed earlier.</p>
<p><font color="#FF0000"><b>Add and display a Date object</b></font></p>
<p>This <b>ArrayList</b> object is capable of storing references to objects of 
mixed types so long as all of the objects are instantiated from classes that are 
subclasses of the class named <b>Object</b>.&nbsp; In Java, of course, all 
classes are subclasses of the class named <b>Object</b>.&nbsp; Therefore, a 
reference to an object of any type, including type<b> Date</b>,<b> </b>can be 
added to the collection.</p>
<blockquote>
	<p><i>(Note, even references to array objects, such as references of type 
	int[] can be stored in the <b>ArrayList</b> collection.)</i></p>
</blockquote>
<p>The <b>runIt</b> method begins by instantiating a new <b>Date</b> object and 
adding its reference to the collection.&nbsp; Then the code retrieves that 
reference from the collection, casts it to type <b>Date</b>, invokes the <b>
getTime</b> method on the reference, and displays the value of the <b>long</b> 
integer returned by the <b>getTime</b> method.</p>
<p><font color="#FF0000"><b>Add and display a literal String object</b></font></p>
<p>Following this, the code in Listing 10 instantiates a literal <b>String</b> 
object that encapsulates the string &quot;abcd&quot; and adds that object's reference to 
the collection.&nbsp; At this point, the collection contains a reference to an 
object of type <b>Date</b> and a reference to an object of type <b>String</b>.&nbsp; 
Both of these references are stored in the collection as type <b>Object</b>.</p>
<p>Then the code in Listing 10 retrieves the reference to the <b>String</b> 
object, casts it to type <b>String</b>, invokes the <b>length</b> method on the 
reference, and displays the <b>int</b> value returned by the <b>length</b> 
method.</p>
<p><font color="#FF0000"><b>A cast is required</b></font></p>
<p>Once again let me emphasize that when you take this approach, you must cast a 
reference that is retrieved from the collection if you need to invoke any method 
on that reference other than one of the eleven methods defined in the <b>Object</b> 
class.&nbsp; The type of the cast must be consistent with the original type of 
the object and the specific method that is to be invoked.&nbsp; This is the way 
that collections behaved in the pre-generics days.</p>
<p>By taking this approach, you have effectively disabled the compile-time type 
safety feature of generics.&nbsp; Therefore, it is up to you to make certain 
that your casts are correct.&nbsp; Programs such as this will compile without 
warnings, and it is still possible to experience a <b>ClassCastException</b> at 
runtime if you perform an incorrect cast.</p>
<p><font color="#FF0000"><b>The program output</b></font></p>
<p>The output produced by one run of the program is shown in Figure 8.</p>
<table bgcolor="#ccffff" border="1" cols="1" width="400"><tr><td><pre>
1110553047835
4
		
<b>Figure 8</b></pre></td></tr></table>
<p>The first line of text in the output depends on the current date and time, 
and will change from one run to the next.&nbsp; The second line of text in the 
output should be 4 each time you run the program unless you modify the program 
to cause the <b>String</b> object to encapsulate a literal string of a different 
length.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a>s</h2>
<p>I encourage you to copy, compile and run the following programs that are 
provided in this lesson:</p>
<ul>
	<li>Generics01</li>
	<li>Generics02</li>
	<li>Generics03</li>
	<li>Generics04</li>
	<li>Generics05</li>
	<li>Generics06</li>
	<li>Generics07</li>
</ul>
<p>You will find complete listings of these seven programs in Listing 11 through 
Listing 17.&nbsp; Experiment with the programs, making changes and observing the results of your changes.</p>
<p><font color="#ff0000"><b>Have fun and learn</b></font></p>
<p>Above all, have fun and use these programs to learn as much as you can about 
the fundamentals of generics and the enhanced <b>for</b> loop in J2SE<sup><font size="-4">TM</font></sup> 5.0.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I explained:</p>
<ul>
	<li>How the Java Collections Framework behaved prior to the release of J2SE 
	5.0.</li>
	<li>The effect of an incorrect cast in code that doesn't use generics.</li>
	<li>How to avoid the requirement to cast through the use of generics, 
	including an illustration of some of the required syntax for generics.</li>
	<li>The compile-time type safety provided by the use of generics.</li>
	<li>The syntax requirements for the use of iterators with generics.</li>
	<li>The use of the enhanced <b>for</b> loop with collections.</li>
	<li>The use of the enhanced <b>for</b> loop with array objects.</li>
	<li>How to achieve pre-generic behavior with a collection and also eliminate 
	the compiler warnings.</li>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons in this series will teach you about other new features in J2SE 
5.0, including</p>
<ul>
	<li>Generic methods</li>
	<li>Generic classes</li>
	<li>Raw types in generics</li>
	<li>Wildcards and bounded wildcards in generics</li>
	<li>The impact of inheritance on generics</li>
	<li>Autoboxing/Unboxing</li>
	<li>Typesafe Enums</li>
	<li>Varargs</li>
	<li>Static Import</li>
</ul>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program Listings</a></h2><p>
Complete listings of all the programs discussed in this lesson are provided in 
Listing 11 through Listing 17 below.</p>
<p>
<p></p><p>
<p></p>
<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics01.java 
Copyright 2005, R.G.Baldwin

Illustrates requirement to cast without the use 
of generics.

V1.5 compiler produces following warning:
Note: Generics01.java uses unchecked or unsafe
operations.
Note: Recompile with -Xlint:unchecked for
details.

Recompilation with -Xlint:unchecked produces 
the following output:
Generics01.java:34: warning: [unchecked] 
unchecked call to add(E) as a member of
the raw type java.util.ArrayList
    var1.add(new Date());
            ^
1 warning

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics01{
  
  ArrayList var1 = new ArrayList();

  void runIt(){
    var1.add(new Date());
    //Note the required cast in the following
    // statement.
    System.out.println(
                  ((Date)var1.get(0)).getTime());
  }//runIt

  public static void main(String[] args){
    new Generics01().runIt();
  }//end main
  
}//end class Generics01
//=============================================//

<b>Listing 11</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics02.java 
Copyright 2005, R.G.Baldwin

Illustrates the application of an incorrect cast 
to an element that is fetched from an ArrayList 
object and the runtime error produced by that
incorrect cast.

This program does not produce a compiler error, 
although the v1.5 compiler does produce a 
general warning having to do with the failure 
to apply the new generics syntax released in 
v1.5. (Earlier compilers would not have produced
such a warning.)

However, the compiler does not check to confirm 
that the correct cast is applied.  This results 
in the following runtime error when an incorrect 
cast is applied:

Exception in thread "main" 
  java.lang.ClassCastException: java.lang.String
        at Generics02.<init>(Generics02.java:46)
        at Generics02.main(Generics02.java:53)

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics02{
  
  ArrayList var1 = new ArrayList();
  
  void runIt(){
    var1.add(new Date());
    var1.add("abcd");
    //Note that the (Date) cast is applied to 
    // an element of type String in the following
    // statement, producing a runtime error.  The
    // problem is that the wrong index was used
    // in fetching the element.  Thus, the wrong
    // element was fetched.
    System.out.println(
                  ((Date)var1.get(1)).getTime());
    System.out.println(
                 ((String)var1.get(1)).length());
  }//end runIt

  public static void main(String[] args){
    new Generics02().runIt();
  }//end main
  
}//end class Generics02

<b>Listing 12</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics03.java 
Copyright 2005, R.G.Baldwin

Illustrates use of generics to avoid requirement 
to cast.  Requires v1.5 or later.

Program output for one run was:

1110504030101

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics03{
  
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();

  void runIt(){
    var1.add(new Date());
    //Note that no cast is required in the
    // following statement.
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics03().runIt();
  }//end main
  
}//end class Generics03

<b>Listing 13</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics04.java 
Copyright 2005, R.G.Baldwin

Illustrates ability of generics to prevent 
storing of wrong type in a collection.  
Requires v1.5 or later.

Compilation produces following error message:
Generics04.java:34: cannot find symbol
symbol  : method add(java.lang.String)
location: 
  class java.util.ArrayList&lt;java.util.Date&gt;
    var1.add("abcd");
        ^
1 error

Once the ArrayList has been declared to be of
type Date, it is not possible to add an element
of type String.  An attempt to do so produces
a compiler error.

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics04{
  
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();
  
  void runIt(){
    var1.add("abcd");
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics04().runIt();
  }//end main

}//end class Generics04

<b>Listing 14</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics05.java 
Copyright 2005, R.G.Baldwin

Illustrates required syntax for using an iterator
with generics.  Also illustrates the new for-each
construct in Java 5.0

Output for one particular run is shown below.

Fri Mar 11 06:29:38 CST 2005
Sat Mar 12 06:29:38 CST 2005
Sun Mar 13 06:29:38 CST 2005

Fri Mar 11 06:29:38 CST 2005
Sat Mar 12 06:29:38 CST 2005
Sun Mar 13 06:29:38 CST 2005

Output will be different each time the program
is run depending on the current date and time.

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics05{
  //Create an ArrayList object suitable for
  // storing references to Date objects.
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();
  
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the ArrayList object
    var1.add(new Date(now));
    var1.add(new Date(now + oneDay));
    var1.add(new Date(now + 2 * oneDay));

    //Get an iterator
    Iterator &lt;Date&gt; iter = var1.iterator();
    
    //Perform the iteration
    while(iter.hasNext()){
      System.out.println(iter.next());
    }//end while loop
    
    System.out.println();//blank line
    
    //Now perform the same iteration using 
    // the new for-each construct.
    for(Date element : var1){
      System.out.println(element);
    }//end for-each

  }//end runIt

  public static void main(String[] args){
    new Generics05().runIt();
  }//end main

}//end class Generics05

<b>Listing 15</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics06.java 
Copyright 2005, R.G.Baldwin

Illustrates use of enhanced for loop with an
array object  Requires J2SE 5.0.  Depending on
when the program is run, the output should be 
similar to the following:

Fri Mar 11 08:08:37 CST 2005
Sat Mar 12 08:08:37 CST 2005
Sun Mar 13 08:08:37 CST 2005

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics06{
  
  //Create an array object suitable for 
  // storing references to Date objects.
  Date[] var1 = new Date[3];
  
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the array object
    var1[0] = new Date(now);
    var1[1] = new Date(now + oneDay);
    var1[2] = new Date(now + 2 * oneDay);

    //Iterate on the array object using the new
    // for-each construct.
    for(Date element : var1){
      System.out.println(element);
    }//end for-each

  }//end runIt


  public static void main(String[] args){
    new Generics06().runIt();
  }//end main
  
}//end class Generics06

<b>Listing 16</b>
</pre></td></tr></tbody></table></p>

<p><table border="1" cols="1" width="400" bgcolor="#FFFF00"><tbody><tr><td><pre>
/*File Generics07.java 
Copyright 2005, R.G.Baldwin

Illustrates syntax required to restore an 
ArrayList collection to a completely generic
type capable of storing references to objects of
mixed types, while eliminating the compiler 
warning that is produced when an attempt is made
to use a Collection object in a completely 
generic sense with the v1.5 or later compiler.
This requires the use of the generic syntax to
declare the ArrayList to be of type Object.

Program output for one run was:

1110553047835
4

Tested using JDK 1.5 under WinXP.
************************************************/

import java.util.*;

public class Generics07{
  
  ArrayList &lt;Object&gt; var1 = 
                         new ArrayList&lt;Object&gt;();
  
  void runIt(){
    var1.add(new Date());
    //Note the requirement to perform a cast in
    // the following print statements.
    System.out.println(
                  ((Date)var1.get(0)).getTime());
    var1.add("abcd");
    System.out.println(
                 ((String)var1.get(1)).length());
  }//end runIt

  public static void main(String[] args){
    new Generics07().runIt();
  }//end main
  
}//end class Generics07

<b>Listing 17</b>
</pre></td></tr></tbody></table></p>




<p>
<hr size="3" width="100%" align="center">    
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p>
     
<h4> <a name="About_the_author">About the author</a></h4><b>
<a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.dickbaldwin.com">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p>
     
<p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p>
     
<p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p>
     
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
  </p>
     
<p>-end- </p>
   </body>
</html>
