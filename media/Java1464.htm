<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Fun with Java: Frame Animation</h2>
<i>Baldwin shows you how to achieve frame animation in Java.&nbsp; He accomplishes
this by showing you how to upgrade the sprite animation program from the
earlier lessons into a new program that provides both sprite animation
and frame animation.</i>
<p><b>Published:</b>&nbsp; November 25, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1464
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<b><font color="#FF0000">Having fun with Java</font></b>
<p>This is one of the lessons in a miniseries that will concentrate on
having fun while programming in Java.
<p>This miniseries will include a variety of Java programming topics that
fall in the category of <i>fun programming</i>.&nbsp; This particular lesson
is the eighth in of a group of lessons that will teach you how to write
animation programs in Java.
<p><b><font color="#FF0000">Animation programs</font></b>
<p>The first lesson in the group was entitled
<a href="Java1450.htm">Fun
with Java: Sprite Animation, Part 1</a>.&nbsp; That lesson, plus the six
lessons following that one, provided an in-depth explanation of the use
of Java for doing sprite animation.
<p>The previous lesson, <i>(and the last in the series on sprite animation),</i>
was entitled <a href="Java1462.htm">Fun with Java: Sprite Animation, Part
7</a>.
<p><b><font color="#FF0000">Frame animation</font></b>
<p>In this lesson, I will move forward and teach you how to also do <i>frame
animation</i> using Java.&nbsp; In fact, I will combine sprite animation
with frame animation in this lesson.
<p><b><font color="#FF0000">What is the difference?</font></b>
<p>What is the difference between sprite animation and frame animation?&nbsp;
This is how I view the difference between the two.
<p>With sprite animation, an image moves around on the computer screen,
but the look of that image doesn't change over time.
<p>With frame animation, the look of an image can change over time, whether
it moves or not.
<p><b><font color="#FF0000">Spherical sea creatures</font></b>
<p>In this program, I will combine the two such that spherical sea creatures
will swim around in a fish tank.&nbsp; Each creature will change the way
it looks over time.&nbsp; In particular, each creature will change its
color as it swims.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Animation in Java</font></b>
<p><font color="#000000">This is one of a group of lessons that will teach
you how to write animation programs in Java.&nbsp; These lessons will teach
you how to write sprite animation, frame animation, and a combination of
the two.</font>
<p><b><font color="#FF0000">Spherical sea creatures</font></b>
<p><font color="#000000">The first program, which was discussed in the
previous seven lessons, showed you how to use sprite animation to cause
a group of colored spherical sea creatures to swim around in a fish tank.&nbsp;
A screen shot of the output produced by that program is shown in Figure
1.</font>
<center>
<p><img SRC="java1464a.gif" height=212 width=301>
<p><font color="#000000">Figure 1.&nbsp; Animated spherical sea creatures
in a fish tank.</font></center>

<p><b><font color="#FF0000">Changing color</font></b>
<p><font color="#000000">Many sea creatures have the ability to change
their color in very impressive ways.&nbsp; The second program, which I
will cover in its entirety in this lesson, will simulate that process using
a combination of sprite and frame animation.&nbsp; <i>(This will really
be an upgrade to the previous program, and much of the code from the previous
program will be used.)</i></font>
<p><font color="#000000">Because a screen shot cannot represent changes
over time, the screen shot shown in Figure 1 also represents the output
from the program being discussed in this lesson.</font>
<p><b><font color="#FF0000">Sea worms</font></b>
<p><font color="#000000">The third program, to be discussed in the next
lesson, will use a combination of sprite animation, frame animation, and
some other techniques to cause a group of multi-colored sea worms to slither
around in the fish tank.&nbsp; In addition to slithering, the sea worms
will also change the color of different parts of their body, much like
real sea creatures.</font>
<p><font color="#000000">A screen shot of the output from the third program
is shown in Figure 2.</font>
<center>
<p><img SRC="java1464b.gif" height=212 width=301>
<p><font color="#000000">Figure 2.&nbsp; Animated sea worms in a fish tank.</font></center>

<p>Figure 3 shows the GIF image files that you will need to run these three
programs.
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td>
<center><pre><img SRC="java1464c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1464d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1464e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1464f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1464g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1464h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1464i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center>
<p>Figure 3.&nbsp; GIF image files that you will need.</center>

<p><b><font color="#FF0000">Getting the images</font></b>
<p>You should be able to capture the images by right-clicking on them individually,
and then saving them into files on your local disk.&nbsp; Having done that,
you will need to rename the files to match the names that are hard-coded
into the programs.
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
<b><font color="#FF0000">Very similar to the previous program</font></b>
<p>Although this program is quite long, most of the program is identical
to the program named <b>Animate01</b>, which was discussed in the previous
series of lessons.
<p><b><font color="#FF0000">Only discuss new material</font></b>
<p>In this lesson, I will discuss only those parts of the program that
are new or different from the previous program.&nbsp; However, I have provided
a copy of the entire program in Listing 8 near the end of the lesson.&nbsp;
You can copy it into a source file on your local disk, compile it, run
it, and see the results.
<p>Because I will be discussing only that code that is new or different,
it may be necessary for you to go back and study the previous program named
<b>Animate01</b>
in order to understand this program.
<p><b><font color="#FF0000">The makeSprite method</font></b>
<p>This program differs from the previous program in only two areas:
<ul>
<li>
The <b>Sprite</b> class from which new sprites are instantiated.</li>

<li>
The <b>makeSprite</b> method of the controlling class, which is used to
create new sprites.</li>
</ul>
Listing 1 shows an abbreviated version of the controlling class with all
of the code other than the new method named <b>makeSprite</b> removed for
brevity.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public class <b>Animate02</b> extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable{
&nbsp; //All the methods in this class are
&nbsp; // identical to those in Animate01
&nbsp; // except for the method named&nbsp;
&nbsp; // makeSprite.

&nbsp; //Code deleted for brevity
&nbsp; //---------------------------------//

&nbsp; private Sprite <b>makeSprite</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex){
&nbsp;&nbsp;&nbsp; return new <b>Sprite</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>gifImages</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 20,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Code deleted for brevity

}//end class Animate02

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The primary differences</font></b>
<p>The primary difference between this program and the previous program
named <b>Animate01</b> can be summarized as follows:
<p><b><font color="#FF0000">Each Sprite had only one image</font></b>
<p>Each <b>Sprite</b> object in the previous program had an instance variable
of type <b>Image</b>.&nbsp; The image whose reference was stored in the
instance variable was used to provide the visual manifestation of the sprite
on the screen.&nbsp; Because a given sprite owned a reference to only a
single image, that sprite always looked the same on the screen.
<p><b><font color="#FF0000">Each Sprite has an array of images</font></b>
<p>In this program, each <b>Sprite</b> object has an instance variable,
which is a reference to an array of references to <b>Image</b> objects.
<p>The images stored in the <b>Image</b> objects are used to provide the
visual manifestation of the sprites when they appear on the screen.&nbsp;
However, because each sprite now owns references to more than one image,
the sprite is able to change how it looks over time by using different
images as its visual manifestation.
<p><b><font color="#FF0000">What is an animation frame?</font></b>
<p>Each of the images in the array is typically referred to as a <i>frame</i>.&nbsp;
The process of causing a sprite to cycle through the frames, changing the
way that it looks in the process, is often referred to as <b>frame animation</b>.
<p><i>(Note that the use of the word frame in this context has nothing
to do with the Java class named Frame.)</i>
<p><b><font color="#FF0000">The substantive changes</font></b>
<p>All of the substantive changes in this program were made in the class
named <b>Sprite</b>.&nbsp; However, because the argument list for the constructor
of the <b>Sprite</b> class changed <i>(to accommodate more incoming information),</i>
it was also necessary to modify the method named <b>makeSprite</b> shown
in Listing 1.
<p>The changes that were made had to do with changes to the parameter list
for the <b>Sprite</b> constructor.&nbsp; The new parameter list includes
a reference to an array of references to <b>Image</b> objects
<i>(gifImages)
</i>along
with some other new parameters that deal with the manner in which the sprite
cycles through the frames.
<p><b><font color="#FF0000">The Sprite class</font></b>
<p>As before, the <b>Sprite</b> class is the workhorse of this animation
program.
<p>Each of the sprites swimming around in the fish tank is an object of
the class named <b>Sprite</b>.&nbsp; As is the typical objective in object-oriented
programming, a sprite knows how to take care of itself.
<p><b><font color="#FF0000">Where are you?</font></b>
<p>For example, an object of the <b>Sprite </b>class knows how to tell
other objects about the space that it occupies in the fish tank.
<p><b><font color="#FF0000">What is your speed and direction?</font></b>
<p>It knows how to tell other objects about its motion vector, which determines
the speed and direction of its motion.
<p>It knows how to use its motion vector in conjunction with a random number
generator to incrementally advance its position to the next location in
its movement through the water.&nbsp; In so doing, it knows how to protect
itself from excessive speed.
<p><b><font color="#FF0000">Oops, just hit a wall!</font></b>
<p>It knows what to do if it runs into one of the walls of the fish tank.&nbsp;
Basically, it bounces off the wall much like a pool ball bounces off the
cushions on a pool table.&nbsp; When this happens, it modifies its motion
vector accordingly.
<p><b><font color="#FF0000">Please draw a picture of yourself</font></b>
<p>When requested to do so, it knows how to draw itself onto a graphics
context that it receives along with the request.
<p><b><font color="#FF0000">Did we just collide?</font></b>
<p>When requested to do so, it can determine if it has collided with another
sprite whose reference it receives along with the request.
<p><b><font color="#FF0000">Change your appearance</font></b>
<p>Finally, this new and improved sprite knows how to use an array of images
to change how it looks over time.
<p>This is a very key class insofar as this program is concerned.&nbsp;
The behavior of the methods in this class determines the overall behavior
of the animation process.
<p><b><font color="#FF0000">Discuss in fragments</font></b>
<p>As usual, I will discuss the program in fragments.
<p>Most of the code in this revised <b>Sprite</b> class is identical to
the code in the <b>Sprite</b> class used in the previous program named
<b>Animate01</b>.&nbsp;
In keeping with the spirit of this lesson, I will not discuss the code
that I discussed in the previous lessons.&nbsp; Rather, for the most part,
I will discuss only that code that is new or different.&nbsp; When you
see <b>//...</b> in the code fragments, that means that code was omitted
for brevity.
<p><b><font color="#FF0000">The beginning of the Sprite class</font></b>
<p>Listing 2 shows the beginning of the <b>Sprite</b> class along with
some new or different declarations for instance variables.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>Sprite</b> {
&nbsp; private Image[] image;
&nbsp; private int frame;
&nbsp; private int frameDisplayIncrement;
&nbsp; private int frameDisplayDuration;
&nbsp; private int frameDurationCounter;
&nbsp; //...

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">An array of Image references</font></b>
<p>In the earlier version, the reference variable named <b>image</b> was
of type <b>Image</b>.&nbsp; However, in this version, it is of type <b>Image[]</b>.&nbsp;
In other words, it previously referred to a single object of type <b>Image</b>.&nbsp;
Now it refers to an array of references to <b>Image</b> objects.
<p><b><font color="#FF0000">The constructor</font></b>
<p>Listing 3 shows the signature for the constructor.&nbsp; The significant
thing about Listing 3 is the makeup of the formal argument list, which
I will discuss below.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public <b>Sprite</b>(//constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image[] image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int startingFrame,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameDisplayIncrement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameDisplayDuration,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">More parameters required</font></b>
<p>The constructor for the new <b>Sprite</b> class takes seven parameters,
as opposed to only four parameters for the previous version.
<p>As before, the first parameter is a reference to a <b>Component</b>
object.&nbsp; In fact, this parameter is assumed to be a reference to the
<b>Frame</b>
object in which this animation is run.
<p>This parameter is used to determine the size of the <b>Frame</b>.&nbsp;
It is also used as a required
<b>ImageObserver</b> in some of the methods
in the class. <i>(I discussed image observers in an earlier lesson in this
series.)</i>
<p><b><font color="#FF0000">An array of Image references</font></b>
<p>Whereas previously, the second parameter was a reference to an object
of type <b>Image</b>, the second parameter in the new version is a reference
to an array containing references of objects of type <b>Image</b>.
<p>The images in the array are used to provide a visual manifestation for
the sprite, and that visual manifestation changes over time.
<p><b><font color="#FF0000">Cycling through the animation frames</font></b>
<p>The third, fourth, and fifth parameters are new to this version of the
<b>Sprite</b>
class.&nbsp; These parameters are used to determine how the sprite cycles
through the set of images in the array.
<p><b><font color="#FF0000">The startingFrame parameter</font></b>
<p>The parameter named <b>startingFrame</b> specifies the first frame to
use at the beginning of the frame animation process.&nbsp; In effect, this
determines the color of a sprite when it first appears on the screen.&nbsp;
If you examine the code in Listing 8 near the end of this lesson, you will
see that different values are used for the fifteen sprites that populate
the fish tank.
<p><b><font color="#FF0000">The frameDisplayIncrement parameter</font></b>
<p>The parameter named <b>frameDisplayIncrement</b> allows for skipping
some of the images in the array of images.
<p>In this program, this value was set to 1 for all sprites.&nbsp; Thus,
when cycling through the images, each sprite uses every image as its visual
manifestation.
<p><b><font color="#FF0000">The frameDisplayDuration parameter</font></b>
<p>The parameter named <b>frameDisplayDuration</b> is used to determine
how long a given image will be used as the visual manifestation for a sprite.
<p>In this program, this value was specified as a random number with a
maximum value of 20 for each new sprite.&nbsp; Thus, each sprite will cycle
through the six images in the array at a different rate.
<p><b><font color="#FF0000">Same as previous parameters</font></b>
<p>The sixth and seventh parameters for the new constructor are the same
as the third and fourth parameters of the constructor in the previous program.&nbsp;
The sixth parameter named <b>position</b> specifies the initial position
of the sprite.
<p>The seventh parameter named <b>motionVector</b> is a motion vector,
which determines the initial speed and direction of motion for a new <b>Sprite</b>,
object.
<p><b><font color="#FF0000">Some new code</font></b>
<p>Listing 4 shows some of the code in the constructor that is new to this
version of the program.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; //...
&nbsp;&nbsp;&nbsp; frame = startingFrame;
&nbsp;&nbsp;&nbsp; this.frameDisplayIncrement =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayIncrement;

&nbsp;&nbsp;&nbsp; frameDisplayDuration =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(frameDisplayDuration);

&nbsp;&nbsp;&nbsp; if(frameDisplayDuration &lt; 5)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration = 5;
&nbsp;&nbsp;&nbsp; this.frameDisplayDuration =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration;

&nbsp;&nbsp;&nbsp; frameDurationCounter =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.frameDisplayDuration;
&nbsp;&nbsp;&nbsp; //...

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>The first two statements in Listing 4 simply save the incoming values
for <b>startingFrame</b> and <b>frameDisplayIncrement</b> in the appropriate
instance variables.
<p><b><font color="#FF0000">Duration must be positive</font></b>
<p>The code having to do with the <b>frameDisplayDuration</b> does two
things.&nbsp; First it uses the <b>abs</b> method of the <b>Math</b> class
to guarantee that the duration is a positive value.
<p><b><font color="#FF0000">Minimum duration is five animation cycles</font></b>
<p>Second, it guarantees that the value is at least 5.&nbsp; This means
that each sprite object will use an <b>Image</b> object as its visual manifestation
for at least five animation cycles <i>(or about one-half second at twelve
frames per second).</i>
<p>In this program, this means that each sprite will remain the same color
for at least five animation cycles.
<p><b><font color="#FF0000">The frameDurationCounter</font></b>
<p>As you may have surmised earlier, the instance variable named <b>frameDurationCounter</b>
is used to determine when a sprite chooses a new <b>Image</b> object as
its visual manifestation <i>(when it changes color in this program). </i>The
value of the <b>frameDurationCounter</b> is initialized in the code of
Listing 4.
<p>All of the remain code in the constructor is essentially the same as
in the previous version of the program, so I won't discuss it here.
<p><b><font color="#FF0000">The incFrame method</font></b>
<p>That brings us to a method named <b>incFrame</b>, which is completely
new to this version of the program.&nbsp; The entire method is shown in
Listing 5.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; private void <b>incFrame</b>() {
&nbsp;&nbsp;&nbsp; if ((frameDisplayDuration > 0) &amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (--frameDurationCounter &lt;= 0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset the frame trigger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDurationCounter =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Increment the frame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame += frameDisplayIncrement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (frame >= image.length)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (frame &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame = image.length - 1;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end incFrame

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>Later we will see that this method is invoked each time the sprite is
requested to update its location on the screen <i>(once during each animation
cycle).</i>
<p><b><font color="#FF0000">Decrement the frameDurationCounter</font></b>
<p>The code in this method is fairly ugly, particularly in this narrow
publication format.
<p>When you wade through it, you discover that it decrements the <b>frameDurationCounter</b><i>,
(which was initialized to the value of the frameDisplayDuration) </i>each
time the <b>incFrame</b> method is invoked<i>.</i>
<p><b><font color="#FF0000">Reset the counter and increase the frame variable</font></b>
<p>When the counter hits zero,
<ul>
<li>
The counter is reset back to the value of the <b>frameDisplayDuration</b></li>

<li>
The value of the variable named <b>frame</b> is increased by the value
of the <b>frameDisplayIncrement</b></li>
</ul>
<b><font color="#FF0000">Choose an image</font></b>
<p>Later we will see that the value of <b>frame</b> is used to choose an
image from the array of images as the visual manifestation of the sprite.
<p><b><font color="#FF0000">Bracket the value of the frame variable</font></b>
<p>Some testing is done to ensure that the value for <b>frame</b> is not
greater than the number of images in the array of images and is not less
than zero.&nbsp; If so, the value of <b>frame</b> is corrected appropriately.
<p><b><font color="#FF0000">Frame control code</font></b>
<p>This is essentially the control code that determines how the sprite
cycles through the array of images, selecting an image for its visual manifestation
during each animation cycle.&nbsp; There are only about two more statements
in the entire <b>Sprite</b> class that have anything to do with frame animation.&nbsp;
The first of those appears in Listing 6.
<p><b><font color="#FF0000">Revised updatePosition method</font></b>
<p>The code in Listing 6 shows the beginning of the revised <b>updatePosition</b>
method of the <b>Sprite</b> class.
<p>You may recall from the previous lessons that this is the method that
the <b>SpriteManager</b> invokes, once during each animation cycle, to
cause each individual sprite to draw itself on the screen in its new position.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; <b>incFrame();//increment the frame
</b>&nbsp;&nbsp;&nbsp; //...

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Incrementing the frame variable</font></b>
<p>As you can see, the first statement in this new version of the method
invokes the <b>incFrame</b> method discussed above to cause the value of
the variable named <b>frame</b> to change when appropriate.
<p>As you can also see, a great deal of code that is essentially the same
as in the previous program was deleted for brevity, taking us all the way
down to the revised method named <b>drawSpriteImage</b> shown in Listing
7.
<p><b><font color="#FF0000">The revised drawSpriteImage method</font></b>
<p>As you may recall from the previous lessons, the <b>drawSpriteImage</b>
method is the method that the <b>SpriteManager</b> invokes on each <b>Sprite</b>
object to cause the sprite to draw itself onto the offscreen graphics context
once during each animation cycle
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; <b>g.drawImage(image[frame]</b>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">What is the difference?</font></b>
<p>The difference between the new version of the <b>drawSpriteImage</b>
method and the previous version is so important that I have provided the
previous version in a different color in Listing 8 below for comparison.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#CCFFFF" >
<tr>
<td>
<pre>&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; <b>g.drawImage(image</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()

<b>//--NOTE: THIS IS CODE FROM AN EARLIER
PROGRAM--

<font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">A reference to an Image object</font></b>
<p>The thing to note in these two listings is the invocation of the <b>drawImage</b>
method.&nbsp; In both versions, the first parameter to the <b>drawImage</b>
method is a reference to the <b>Image</b> object that will be rendered
onto the screen as the visual manifestation of the sprite.
<p><b><font color="#FF0000">One Image object available</font></b>
<p>However, in the previous version of the program, this is a reference
to a single <b>Image</b> object passed into the <b>Sprite</b> constructor
when the <b>Sprite</b> object was instantiated.
<p><b><font color="#FF0000">A choice of Image objects</font></b>
<p>In the new version, this is a reference extracted from an array of references
using the <b>frame</b> variable as an index into the array.
<p>The reference to the array of <b>Image</b> objects was received as an
incoming parameter to the constructor when the <b>Sprite</b> object was
instantiated.&nbsp; In the new version, the <b>incFrame</b> method discussed
earlier is used to establish the value stored in <b>frame</b>, which identifies
the <b>Image</b> object that is used to provide the visual manifestation
for the sprite during each animation cycle.
<p><b><font color="#FF0000">Six colored spheres</font></b>
<p>In this program, the array contains references to images of six small
spheres of different colors.&nbsp; As the animation progresses and the
<b>incFrame</b>
method controls the value of the variable named <b>frame</b>, different
colored spheres are selected as the visual manifestation of a sprite, and
the sprites appear to change color over time.
<p>The remaining code in the <b>Sprite</b> class was discussed in earlier
lessons and therefore won't be discussed further here.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have taught you how to achieve frame animation in Java.&nbsp;
I accomplished this by showing you how to upgrade the sprite animation
program from the earlier lessons into a new program that provides both
sprite animation and frame animation.
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson in this series, I will provide an additional upgrade
to convert the spherical sea creatures into sea worms that have the ability
to slither around in the fish tank and to change the colors of different
parts of their bodies in a random fashion as they slither.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
8</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate02.java
Copyright 2001, R.G.Baldwin
This program displays several animated
colored spherical sea creatures&nbsp;
swimming around in an aquarium. Each&nbsp;
creature maintains generally the same&nbsp;
course until it collides with another&nbsp;
creature or with a wall.&nbsp; However,&nbsp;
the creatures have the ability to&nbsp;
change course based on the addition or&nbsp;
subtraction of random values from the&nbsp;
components of their motion vector
about once in every ten updates.

In addition, each creature uses frame&nbsp;
animation to change colors in the order
red, green blue, yellow, purple,&nbsp;
orange.&nbsp; Each creature switches among&nbsp;
the colors on a periodic rate, but the&nbsp;
period may be different for each&nbsp;
creature.&nbsp; Thus, each creature cycles&nbsp;
through the same colors, but remains a
particular color for a different&nbsp;
amount of time than the other&nbsp;
creatures.&nbsp; The amount of time that a&nbsp;
creature remains a particular color is&nbsp;
based on a random number between 5&nbsp;
and 20 updates.

The primary changes in this program
relative to the program named Animate01
were made in the Sprite class, and in&nbsp;
calls to the constructor for the Sprite
class in the makeSprite() method.

**************************************/
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Animate02 extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable{
&nbsp; //All the methods in this class are
&nbsp; // identical to those in Animate01
&nbsp; // except for the methodnamed&nbsp;
&nbsp; // makeSprite.
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];
&nbsp; //offscreen graphics context
&nbsp; private Graphics&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;
&nbsp; private MediaTracker mediaTracker;
&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate02();
&nbsp; }//end main
&nbsp; //---------------------------------//

&nbsp; Animate02() {//constructor
&nbsp;&nbsp;&nbsp; // Load and track the images
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Get and track the background&nbsp;
&nbsp;&nbsp;&nbsp; // image
&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("background02.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and track 6 images to use&nbsp;
&nbsp;&nbsp;&nbsp; // for sprites
&nbsp;&nbsp;&nbsp; gifImages[0] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("redball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);
&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("greenball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("blueball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("yellowball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("purpleball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("orangeball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Block and wait for all images to&nbsp;
&nbsp;&nbsp;&nbsp; // be loaded
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.waitForID(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Base the Frame size on the size&nbsp;
&nbsp;&nbsp;&nbsp; // of the background image.
&nbsp;&nbsp;&nbsp; //These getter methods return -1 if
&nbsp;&nbsp;&nbsp; // the size is not yet known.
&nbsp;&nbsp;&nbsp; //Insets will be used later to&nbsp;
&nbsp;&nbsp;&nbsp; // limit the graphics area to the&nbsp;
&nbsp;&nbsp;&nbsp; // client area of the Frame.
&nbsp;&nbsp;&nbsp; int width =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getWidth(this);
&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getHeight(this);

&nbsp;&nbsp;&nbsp; //While not likely, it may be&nbsp;
&nbsp;&nbsp;&nbsp; // possible that the size isn't
&nbsp;&nbsp;&nbsp; // known yet.&nbsp; Do the following&nbsp;
&nbsp;&nbsp;&nbsp; // just in case.
&nbsp;&nbsp;&nbsp; //Wait until size is known
&nbsp;&nbsp;&nbsp; while(width == -1 || height == -1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Waiting for image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWidth(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the frame
&nbsp;&nbsp;&nbsp; setSize(width,height);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2001, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; //Create and start animation thread
&nbsp;&nbsp;&nbsp; animationThread = new Thread(this);
&nbsp;&nbsp;&nbsp; animationThread.start();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner class window&nbsp;
&nbsp;&nbsp;&nbsp; // listener to terminate the&nbsp;
&nbsp;&nbsp;&nbsp; // program.
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public void run() {
&nbsp;&nbsp;&nbsp; //Create and add sprites to the&nbsp;
&nbsp;&nbsp;&nbsp; // sprite manager
&nbsp;&nbsp;&nbsp; spriteManager = new SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, backGroundImage));
&nbsp;&nbsp;&nbsp; //Create 15 sprites from 6 gif&nbsp;
&nbsp;&nbsp;&nbsp; // files.
&nbsp;&nbsp;&nbsp; for (int cnt = 0; cnt &lt; 15; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position = spriteManager.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEmptyPosition(new Dimension(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].getWidth(this),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.addSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeSprite(position, cnt % 6));
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Loop, sleep, and update sprite&nbsp;
&nbsp;&nbsp;&nbsp; // positions once each 83&nbsp;
&nbsp;&nbsp;&nbsp; // milliseconds
&nbsp;&nbsp;&nbsp; long time =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis();
&nbsp;&nbsp;&nbsp; while (true) {//infinite loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time += animationDelay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0,time -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end run method
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private Sprite makeSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex){
&nbsp;&nbsp;&nbsp; return new Sprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 20,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Overridden graphics update method&nbsp;
&nbsp; // on the Frame
&nbsp; public void update(Graphics g) {
&nbsp;&nbsp;&nbsp; //Create the offscreen graphics&nbsp;
&nbsp;&nbsp;&nbsp; // context
&nbsp;&nbsp;&nbsp; if (offScreenGraphicsCtx == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createImage(getSize().width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage.getGraphics();
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Draw the sprites offscreen
&nbsp;&nbsp;&nbsp; spriteManager.drawScene(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx);

&nbsp;&nbsp;&nbsp; // Draw the scene onto the screen
&nbsp;&nbsp;&nbsp; if(offScreenImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage, 0, 0, this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end overridden update method
&nbsp; //---------------------------------//

&nbsp; //Overridden paint method on the&nbsp;
&nbsp; // Frame
&nbsp; public void paint(Graphics g) {
&nbsp;&nbsp;&nbsp; //Nothing required here.&nbsp; All&nbsp;
&nbsp;&nbsp;&nbsp; // drawing is done in the update&nbsp;
&nbsp;&nbsp;&nbsp; // method above.
&nbsp; }//end overridden paint method

&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Animate02
//===================================//

class BackgroundImage{
&nbsp; //This class is identical to that
&nbsp; // used in Animate01
&nbsp; private Image image;
&nbsp; private Component component;
&nbsp; private Dimension size;

&nbsp; public BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image) {
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; size = component.getSize();
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end construtor
&nbsp;&nbsp;
&nbsp; public Dimension getSize(){
&nbsp;&nbsp;&nbsp; return size;
&nbsp; }//end getSize()

&nbsp; public Image getImage(){
&nbsp;&nbsp;&nbsp; return image;
&nbsp; }//end getImage()

&nbsp; public void setImage(Image image){
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end setImage()

&nbsp; public void drawBackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g) {
&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image, 0, 0, component);
&nbsp; }//end drawBackgroundImage()
}//end class BackgroundImage
//===================================//

class SpriteManager extends Vector {
&nbsp; //This class is identical to that
&nbsp; // used in Animate01
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage) {
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getEmptyPosition(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void update() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.updatePosition();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for collision. Positive&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result indicates a collision
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testForCollision(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitIndex >= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceOffSprite(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private int testForCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite) {
&nbsp;&nbsp;&nbsp; //Check for collision with other&nbsp;
&nbsp;&nbsp;&nbsp; // sprites
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void bounceOffSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawScene(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBackgroundImage(g);

&nbsp;&nbsp;&nbsp; //Iterate through sprites, drawing
&nbsp;&nbsp;&nbsp; // each sprite
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawSpriteImage(g);
&nbsp; }//end drawScene()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void addSprite(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()
&nbsp;&nbsp;
}//end class SpriteManager
//===================================//

class Sprite {
&nbsp; private Component component;
&nbsp; private Image[] image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;
&nbsp;&nbsp;
&nbsp; private int frame;
&nbsp; private int frameDisplayIncrement;
&nbsp; private int frameDisplayDuration;
&nbsp; private int frameDurationCounter;

&nbsp; public Sprite(//constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image[] image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int startingFrame,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameDisplayIncrement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameDisplayDuration,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite&nbsp;
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; frame = startingFrame;
&nbsp;&nbsp;&nbsp; this.frameDisplayIncrement =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayIncrement;
&nbsp;&nbsp;&nbsp; frameDisplayDuration =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(frameDisplayDuration);
&nbsp;&nbsp;&nbsp; if(frameDisplayDuration &lt; 5)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration = 5;
&nbsp;&nbsp;&nbsp; this.frameDisplayDuration =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration;
&nbsp;&nbsp;&nbsp; frameDurationCounter =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.frameDisplayDuration;
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image[0].getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image[0].getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp;&nbsp;&nbsp; //Compute edges of usable graphics&nbsp;
&nbsp;&nbsp;&nbsp; // area
&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().top;
&nbsp;&nbsp;&nbsp; int bottomBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Rectangle getSpaceOccupied(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//

&nbsp; void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//

&nbsp; public void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//

&nbsp; public Point getMotionVector(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//

&nbsp; public void setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//

&nbsp; public void setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void incFrame() {
&nbsp;&nbsp;&nbsp; if ((frameDisplayDuration > 0) &amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (--frameDurationCounter &lt;= 0)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset the frame trigger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDurationCounter =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameDisplayDuration;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Increment the frame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame += frameDisplayIncrement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (frame >= image.length)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (frame &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame = image.length - 1;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end incFrame
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; incFrame();//increment the frame
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Point position = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about&nbsp;
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // small random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to&nbsp;
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point randomOffset =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if

&nbsp;&nbsp;&nbsp; //Make the move
&nbsp;&nbsp;&nbsp; position.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

&nbsp;&nbsp;&nbsp; //Bounce off the walls
&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if((position.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width) >
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height) >
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp; if (bounceRequired)&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(tempMotionVector);

&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.drawImage(image[frame],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()
&nbsp; //---------------------------------//

&nbsp; public boolean testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; // Check for collision with another
&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class


<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2001, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java and XML.
In addition to the many platform-independent benefits of Java applications,
he believes that a combination of Java and XML will become the primary
driving force in the delivery of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
