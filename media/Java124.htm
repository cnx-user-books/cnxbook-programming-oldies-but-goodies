<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.06 [en] (Win95; I) [Netscape]">
   <META NAME="AUTHOR" CONTENT="Richard G. Baldwin">
   <TITLE>... in Java by Richard G Baldwin</TITLE>
</HEAD>
<BODY>
<!--start-->
<CENTER>
<H3>
<B><I>Richard G Baldwin (512) 223-4758, <A HREF="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</A>,
<A HREF="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</A></I></B></H3></CENTER>

<CENTER>
<H2>
<B><!--title-->Swing, Hidden Buttons with Icons, Icon Images, Borders, Tool Tips, Nested
Buttons, and Other Fun Stuff<!--endTitle--></B></H2></CENTER>

<P><BR>
<P>Java Programming, Lecture Notes # 124, Revised 08/26/98.
<UL>
<LI>
<A HREF="#Preface">Preface</A></LI>

<LI>
<A HREF="#Introduction">Introduction</A></LI>

<LI>
<A HREF="#Sample Program">Sample Program</A></LI>

<UL>
<LI>
<A HREF="#Interesting Code Fragments">Interesting Code Fragments</A></LI>

<LI>
<A HREF="#Program Listing">Program Listing</A></LI>
</UL>

<LI>
<A HREF="#Program Listing for PlafPanel02">Program Listing for PlafPanel02</A></LI>
</UL>

<HR WIDTH="100%">
<CENTER>
<H2>
<A NAME="Preface"></A><B><FONT COLOR="#FF0000">Preface</FONT></B></H2></CENTER>
Students in Prof. Baldwin's <B><U>Advanced Java Programming</U></B> classes
at ACC are responsible for knowing and understanding all of the material
in this lesson.
<BR>&nbsp;
<CENTER>
<H2>
<A NAME="Introduction"></A><FONT COLOR="#FF0000">Introduction</FONT></H2></CENTER>
As indicated in the title, this lesson deals with a lot of fun stuff in
Swing.&nbsp; The lesson was originally written using JDK 1.1.6 and Swing
1.0.1.&nbsp; Much that you will see in this lesson is not documented in
Swing 1.0.1 (at least if it is documented, I was unable to find it).&nbsp;
Rather, much of what you see here was created by examining the source code
for the examples that came with the Swing download and inferring the behavior
of various methods on the basis of that source code.
<P>What is a hidden button?&nbsp; If you use Netscape Communicator 4.x,
then you are familiar with the type of buttons that I refer to as hidden
buttons.
<P>For example, the "Back" button in the Netscape browser in Communicator
4.x is a button of this type.&nbsp; Its normal appearance is to display
the word <I>Back</I> and a little green icon but there are no borders to
cause it to look like a button.&nbsp; However, when you touch it with the
mouse, it suddenly displays borders that make it look like a button. The
new capability of Swing to deal with borders makes it possible to create
buttons that behave like this in Java.
<P>Swing also makes it possible to place images on buttons (or on just
about any Swing component for that matter).&nbsp; We will use <B>ImageIcon</B>
to create images to place on our buttons.
<P>Not only will we have icons on the buttons, they will change as we move
the mouse in the vicinity of the buttons.&nbsp; This is the result of a
new capability in Swing&nbsp; referred to as <I>rollover effects</I>.
<P>You have all seen tool tips in various applications.&nbsp; Swing supports
tool tips and we will demonstrate that capability in this lesson as well.
<P>As you are already aware from a previous lesson, Swing supports <I>Pluggable
Look and Feel (PL&amp;F)</I>.&nbsp; Also, as you are already aware from
a previous lesson, Swing makes it possible for components to contain other
components.&nbsp; Just for fun, we will build a pyramid of nested <B>JButton</B>
components and observe them for different <I>PL&amp;F</I> implementations.
<BR>&nbsp;
<BR>&nbsp;
<BR>
<CENTER>
<H2>
<A NAME="Sample Program"></A><FONT COLOR="#FF0000">Sample Program</FONT></H2></CENTER>
The primary purpose of this program is to demonstrate "Hidden Buttons".&nbsp;
These are buttons which don't look like buttons until you touch them with
the mouse but which "come alive" when you touch them.
<P>By coming alive, they take on the appearance of a button according to
the current look and feel.&nbsp; This behavior is implemented using the
new border capability of Swing. Also, the icon on the button changes to
a different image when you touch the button with the mouse. This illustrates
the new <B>ImageIcon</B> capability of Swing and several related behaviors
(such as rollover effects).
<P>A <I>PL&amp;F</I> control panel is provided so that you can change the
<I>L&amp;F</I>
during runtime.&nbsp; Thus, the program also illustrates the appearance
of Hidden Buttons under different look and feel implementations.
<P>As mentioned earlier, the program also illustrates the use of tooltips.
<P>And just for fun, the program illustrates that every Swing component
is a container that can contain other components.&nbsp; This capability
is illustrated by building a pyramid of nested <B>JButton</B> objects where
each object contains the objects above it.
<P>It is very interesting to observe the appearance of this pyramid under
different <I>L&amp;F</I> implementations. For example, under the JavaSoft
Metal <I>L&amp;F</I>, it doesn't have a three-dimensional pyramid look.&nbsp;
However, under the Windows and Motif <I>L&amp;F</I>, the three-dimensional
appearance is very pronounced.
<P>This program requires that several <I>gif</I> image files be placed
in the directory that contains the class files. Otherwise, you won't be
able to compile and run the program.
<P>It doesn't matter what images the gif files contain.&nbsp; Of course,
to fit in the allotted space, they should be small images.&nbsp; To be
directly compatible with this program, the names of the gif files must
be bulb1, bulb2, and bulb3. Obviously, you could modify the program to
accommodate gif files with other names as well.
<P>These gif files are used to change the icons on the buttons to illustrate
the different states of the buttons.
<P>When the program starts, two Hidden Buttons and a pyramid of nested
<B>JButton</B>
objects are displayed in a <B>JFrame</B> object on the screen.
<P>In addition, a separate <B>JFrame</B> object is displayed containing
buttons that can be used to select any of the different <I>L&amp;F</I>
implementations currently installed on the system. When you select an <I>L&amp;F</I>
implementation on this <B>JFrame</B>, it is applied to all of the components
on both <B>JFrame</B> objects.
<P>One of the Hidden Buttons is a <B>JButton</B>.&nbsp; The other is a
<B>JToggleButton</B>.&nbsp;
They are identified by the text on the buttons as well as the tool tip
that appears when you cause the mouse pointer to hover over a button for
a short period of time.
<P>In my implementation, using my three gif files, the normal state of
the buttons is to display a light bulb that is not illuminated.
<P>When you touch the button with the mouse (rollover), the borders appear
and the light bulb image changes to one that is illuminated.
<P>When you press the button, the light bulb changes to one that is blue
and it remains blue until you release the mouse button. (See a later comment
regarding the different rollover behavior of the <B>JToggleButton</B> when
it is selected.)
<P>Of course, your version will be somewhat different, depending on the
three images that you select.
<P>The buttons don't do anything when you click them because no action
listeners were registered on them.
<P>This program illustrates the <B>JToggleButton</B> which is new to Swing.
<P>Whereas a normal <B>JButton</B> object responds and returns to its original
appearance when you click it, a <B>JToggleButton</B> responds but does
not return to its original appearance.&nbsp; In other words, clicking on
a <B>JToggleButton</B> causes it to toggle between two different appearances
(and two different readable states as well).
<P>Although it isn't demonstrated in this program, the two states of a
<B>JToggleButton</B>
are true and false.&nbsp; Your program can determine the state by invoking
the <B>isSelected()</B> method on the button. The change in appearance
between being selected and not selected depends on the <I>L&amp;F</I> in
effect at the time.
<P>Note that unlike the <B>JButton</B> object, the <B>JToggleButton</B>
object doesn't change to the <B>rolloverIcon</B> when it is in the selected
state.&nbsp; It displays the <B>normalIcon</B> instead. However, like the
<B>JButton</B>,
it does display the <B>rolloverIcon</B> when it is touched by the mouse
pointer but is not selected.
<P>This program was tested using JDK 1.1.6 and Swing 1.0.1 under Windows
95
<BR>&nbsp;
<BR>&nbsp;
<BR>
<CENTER>
<H3>
<A NAME="Interesting Code Fragments"></A><FONT COLOR="#FF0000">Interesting
Code Fragments</FONT></H3></CENTER>
We will begin with the opening line of the controlling class and the <B>main()</B>
method.&nbsp; As you can see, the controlling class extends <B>JFrame</B>
so it is a <B>JFrame</B> object.
<P>The <B>main()</B> method instantiates two objects.&nbsp; The first is
an object of the type of the controlling class.&nbsp; The second is an
object of the class named <B>PlafPanel02</B>.
<P>You should already be familiar with the concept involved with this second
object.&nbsp; It was explained in an earlier lesson on <I>Pluggable Look
&amp; Feel</I>.&nbsp; This version of the <B>PlafPanel</B> class differs
from the one used in that lesson only to the extent that this is a totally
stand-alone control panel for selecting the <I>L&amp;F</I> of the associated
GUI. A complete listing of the source code for <B>PlafPanel02</B> is provided
at the end of this lesson.
<P>A GUI is associated with this <I>L&amp;F</I> control panel by passing
a reference to the GUI when the <B>PlafPanel02</B> object is instantiated.&nbsp;
From that point forward, selecting a new <I>L&amp;F</I> on the control
panel will cause the <I>L&amp;F</I> of the associated GUI to change to
the selected <I>L&amp;F </I>(the <I>L&amp;F</I> of the control panel also
changes as well).
<P>The GUI named <B>demoFrame</B> is passed to the constructor for <B>PlafPanel02</B>
to associate the GUI with the <I>L&amp;F </I>control panel in this program.
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>public class Swing09 <B>extends JFrame</B> {

&nbsp; public static void <B>main</B>(String args[]) {
&nbsp;&nbsp;&nbsp; Swing09 <B>demoFrame</B> = new <B>Swing09</B>();
&nbsp;&nbsp;&nbsp; <B>PlafPanel02</B> plafPanel = new <B>PlafPanel02(demoFrame</B>);
&nbsp; }//end <B>main()</B></PRE>
</TD>
</TR>
</TABLE>

<P>That brings us to the constructor for the primary GUI for this program.
We begin with the preliminaries by creating a title, setting the layout,
and adding a <B>JLabel</B> object that contains some explanatory information.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp; Swing09() {//constructor
&nbsp;&nbsp;&nbsp; this.<B>setTitle</B>("Copyright 1998, RG Baldwin");
&nbsp;&nbsp;&nbsp; this.getContentPane().<B>setLayout</B>(new FlowLayout());
&nbsp;&nbsp;&nbsp; this.getContentPane().add(new <B>JLabel</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Hidden Button Demo, Copyright 1998, R.G.Baldwin"));</PRE>
</TD>
</TR>
</TABLE>

<P>&nbsp;The next fragment instantiates a <B>JPanel</B> object containing
the Hidden Buttons and adds the panel to the <B>JFrame</B> object that
is the GUI. We will examine the class from which is panel is constructed
shortly.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; this.getContentPane().add(new <B>HiddenButtonPanel</B>());</PRE>
</TD>
</TR>
</TABLE>

<P>Next, just for fun, we build a pyramid of nested <B>JButton</B> objects
so that we can observe their appearance under the different <I>L&amp;F</I>
implementations and set a tool tip on the top button..
<P>Following this, we set the size of the GUI and make it visible.
<P>Then we add an anonymous inner-class WindowListener to terminate the
program when the user closes the <B>JFrame</B> object.
<P>And that ends the constructor for the controlling class and also ends
the controlling class definition.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; <B>JButton</B> a = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> b = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> c = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> d = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> e = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> f = new <B>JButton</B>("Top");
&nbsp;&nbsp;&nbsp; f.<B>setToolTipText</B>("Nested <B>JButton</B> objects");
&nbsp;&nbsp;&nbsp; this.getContentPane().add(a);
&nbsp;&nbsp;&nbsp; a.add(b);
&nbsp;&nbsp;&nbsp; b.add(c);
&nbsp;&nbsp;&nbsp; c.add(d);
&nbsp;&nbsp;&nbsp; d.add(e);
&nbsp;&nbsp;&nbsp; e.add(f);

&nbsp;&nbsp;&nbsp; //Set size and display the GUI&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; this.<B>setSize</B>(400,280);
&nbsp;&nbsp;&nbsp; this.<B>setVisible</B>(true);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Create an inner class WindowAdapter to terminate the
&nbsp;&nbsp;&nbsp; // program when the <B>JFrame</B> is closed.
&nbsp;&nbsp;&nbsp; this.addWindowListener(new WindowAdapter() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});//end WindowListener
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor&nbsp;&nbsp;
}//end class Swing09</PRE>
</TD>
</TR>
</TABLE>

<P>That brings us to the definition of the class that is used to instantiate
a panel containing the two Hidden Buttons.
<P>We begin by instantiating three different objects of type <B>ImageIcon</B>.&nbsp;
The <B>ImageIcon</B> class implements the <B>Icon</B> interface, so these
objects can be used anywhere an object of type <B>Icon</B> is required.
<P>In our case, we will need to provide a reference to an object of type
<B>Icon</B>
in three different statements associated with each of our Hidden Buttons.&nbsp;
We will discuss those statements later.
<P>There are several different constructors that can be used to instantiate
an object of type <B>ImageIcon</B>.&nbsp; We are using a version of the
constructor that requires a <B>String</B> specifying the name of the file
containing the image.
<P>This fragment also declares reference variables for our two Hidden Button
objects.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>class <B>HiddenButtonPanel</B> extends <B>JPanel</B>{

&nbsp; <B>ImageIcon</B> normalIcon = new <B>ImageIcon</B>("bulb3.gif");
&nbsp; <B>ImageIcon</B> rolloverIcon = new <B>ImageIcon</B>("bulb2.gif");
&nbsp; <B>ImageIcon</B> pressedIcon = new <B>ImageIcon</B>("bulb1.gif");

&nbsp; <B>JToggleButton</B> myJToggleButton;
&nbsp; <B>JButton</B> myJButton;</PRE>
</TD>
</TR>
</TABLE>

<P>That brings us to the constructor for our <B>HiddenButtonPanel</B> class.
There is a lot of new material contained in this constructor.
<P>This constructor instantiates two different Hidden Buttons;
<UL>
<LI>
one is a <B>JButton</B> object and</LI>

<LI>
the other is a <B>JToggleButton</B> object.</LI>
</UL>
Other than their type, the code to instantiate and prepare them for use
is identical.&nbsp; Therefore, this fragment will deal only with the <B>JButton</B>
object.&nbsp; You can find the code for the <B>JToggleButton</B> object
in the complete listing of the program that follows later.
<P>We begin by instantiating a <B>JButton</B> object using a constructor
that allows us to specify a reference to an <B>Icon</B> image object that
will appear on the button.&nbsp; The ability to put images on a button
is new to Swing.&nbsp; This capability does not exist in the AWT.&nbsp;
In this case, we specify one of the <B>ImageIcon</B> objects instantiated
earlier (<B>normalIcon</B>).
<P>Next, we invoke the <B>setRolloverIcon</B>() method to specify an image
that will automatically appear on the button when we touch the button with
the mouse pointer.&nbsp; Again, we provide a reference to one of the <B>ImageIcon</B>
objects instantiated earlier (<B>rolloverIcon</B>),.
<P>After this, we invoke the <B>setPressedIcon</B>() method to specify
an image that will automatically appear on the button while it is pressed,
passing one of our <B>ImageIcon</B> objects as a parameter (<B>pressedIcon</B>).
<P>These are all new capabilities in Swing that do not exist in the AWT.
<P>Finally, as the last action in this fragment, we invoke the <B>setRolloverEnabled</B>()
method on the button to "enable the rollover effects."
<P>As mentioned earlier, I was unable to find any explanatory information
in the documentation for Swing 1.0.1 regarding the "rollover effects.".&nbsp;
Everything here was inferred from the very cryptic statements in the API
documentation and an examination of the example programs that came with
the Swing download.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp; <B>HiddenButtonPanel</B>(){//constructor

&nbsp;&nbsp;&nbsp; myJButton = new <B>JButton</B>("<B>JButton</B>", normalIcon);
&nbsp;&nbsp;&nbsp; myJButton.<B>setRolloverIcon</B>(rolloverIcon);
&nbsp;&nbsp;&nbsp; myJButton.<B>setPressedIcon</B>(pressedIcon);
&nbsp;&nbsp;&nbsp; myJButton.<B>setRolloverEnabled</B>(true);</PRE>
</TD>
</TR>
</TABLE>

<P>Tool Tips are amazingly easy to create with Swing.&nbsp; The first statement
in the next fragment is all that is required to associate a tool tip with
an object.
<P>After setting the text for the tool tip on the button by invoking the
<B>setToolTipText</B>()
method, we cause the borders on the button to be invisible by invoking
<B>setBorderPainted</B>()
and passing <I>false</I> as a parameter.
<P>Until this is changed, the borders on the button will not be painted,
and the button really won't be recognizable as a button.
<P>We wrap up this fragment by adding the <B>JButton</B> object to the
panel.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; myJButton.<B>setToolTipText</B>("This is a <B>JButton</B>");
&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp; this.<B>add</B>(myJButton);</PRE>
</TD>
</TR>
</TABLE>

<P>We will wrap up this discussion with the code fragment that causes the
button to appear when you touch it with the mouse pointer and causes it
to disappear when you move the mouse pointer away.
<P>This is a simple anonymous inner-class mouse listener that responds
when the mouse enters and leaves the boundary of the button.&nbsp; Except
for the fact that it invokes the <B>setBorderPainted</B>() method with
either <I>true</I> or <I>false</I> to expose the borders of the button
or make them invisible, there is nothing new here.&nbsp; You should be
completely familiar with this approach to processing mouse events.
<P>Note that in this program, we processed mouse events to cause the borders
on the button to be either visible or invisible.
<P>It is also <U>very important to note</U> that we weren't required to
provide any special event handling to cause the icon on the button to change
when the mouse pointer entered and exited the boundary of the button, and
to change again when the button was pressed.&nbsp; That behavior is automatic
once you properly invoke the <B>setRolloverIcon</B>(), <B>setPressedIcon</B>(),
and <B>setRolloverEnabled</B>() methods discussed earlier.
<P>In a way, I hate to see this because it tends to break the structured
nature of the API.&nbsp; Normally it is necessary for us to provide event
handlers to deal with these kinds of&nbsp; events, but in this case, the
event handling is being provided automatically.&nbsp; If much of this sort
of thing creeps into the API, it could lead to&nbsp; confusion as to when
it is and when it is not necessary to provide event handling.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>&nbsp;&nbsp;&nbsp; myJButton.addMouseListener(new MouseAdapter(){

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void <B>mouseEntered(MouseEvent</B> mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseEntered

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void <B>mouseExited(MouseEvent</B> mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseExited()

&nbsp;&nbsp;&nbsp; });//end inner-class definition</PRE>
</TD>
</TR>
</TABLE>

<P>.
<BR>&nbsp;
<CENTER>
<H3>
<A NAME="Program Listing"></A><FONT COLOR="#FF0000">Program Listing</FONT></H3></CENTER>
This section contains a complete listing of the program. A listing of the
source code for the utility program named <B>PlafPanel02</B> is provided
in the next section.
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>/*File Swing09 Copyright 1998, R.G.Baldwin
The primary purpose of this program is to demonstrate
"Hidden Buttons".&nbsp; These are buttons which don't look
like buttons until you point to them with the mouse but
which "come alive" when you point to them.&nbsp; By coming
alive, they take on the appearance of a button according
to the current look and feel.&nbsp; This behavior is&nbsp;
implemented using the new border capability of Swing.
Also, the image icon on the button changes to a different
image when you point to the button with the mouse. This
illustrates the new image icon capability of Swing.

The program illustrates the appearance of Hidden Buttons&nbsp;
under different look and feel implementations.

The program also illustrates the use of tooltips.

And just for fun, the program also illustrates that every
Swing component is a container that can contain other
components.&nbsp; This is done by building a pyramid of nested
<B>JButton</B> objects where each contains the objects above it.
It is interesting to observe the different appearance
of this pyramid under different L&amp;F implementations.

This program requires that several icon sized gif files
be placed in the directory that contains the class
files. The names of the gif files must be bulb1, bulb2,
and bulb3.

These gif files are used to illustrate the different states
of image icons.

When the program starts, two Hidden Buttons and a pyramid
of buttons are displayed in a <B>JFrame</B>.&nbsp;&nbsp;

In addition, a separate <B>JFrame</B> is displayed containing
buttons that can be used to select any of the different L&amp;F
implementations currently installed on the system. When&nbsp;
you select a L&amp;F implementation on this <B>JFrame</B>, it is&nbsp;
applied to all of the components on both <B>JFrame</B> objects.

One of the Hidden Buttons is a <B>JButton</B>.&nbsp; The other is a
<B>JToggleButton</B>.&nbsp; They are identified by the text on the
button as well as the tool tip that appears when you
pause with the mouse pointing at one of the buttons.

The buttons don't do anything when you click them because
no action listeners were registered on them.

Note that the <B>JToggleButton</B> doesn't respond to the&nbsp;
rolloverIcon when it is in the pressed state.&nbsp; It displays
the normalIcon instead.

Tested using JDK 1.1.6 and Swing 1.0.1 under Windows 95

**********************************************************/

import java.awt.*;
import java.awt.event.*;
import com.sun.java.swing.*;

// Subclass <B>JFrame</B> for the GUI
public class Swing09 extends <B>JFrame</B> {//controlling class

&nbsp; public static void main(String args[]) {
&nbsp;&nbsp;&nbsp; //Instantiate an object of this type
&nbsp;&nbsp;&nbsp; Swing09 <B>demoFrame</B> = new Swing09();
&nbsp;&nbsp;&nbsp; //Instantiate and link a PlafPanel to it
&nbsp;&nbsp;&nbsp; <B>PlafPanel02</B> plafPanel = new <B>PlafPanel02</B>(<B>demoFrame</B>);
&nbsp; }//end <B>main()
</B>&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; Swing09() {//constructor
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1998, RG Baldwin");
&nbsp;&nbsp;&nbsp; this.getContentPane().setLayout(new FlowLayout());
&nbsp;&nbsp;&nbsp; this.getContentPane().add(new JLabel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Hidden Button Demo, Copyright 1998, R.G.Baldwin"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Instantiate and add the panel containing the hidden
&nbsp;&nbsp;&nbsp; // buttons.
&nbsp;&nbsp;&nbsp; this.getContentPane().add(new <B>HiddenButtonPanel</B>());
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Just for fun, build a pyramid of nested <B>JButton</B>&nbsp;
&nbsp;&nbsp;&nbsp; // objects and observe their appearance under the&nbsp;
&nbsp;&nbsp;&nbsp; // different L&amp;F implementations.
&nbsp;&nbsp;&nbsp; <B>JButton</B> a = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> b = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> c = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> d = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> e = new <B>JButton</B>();
&nbsp;&nbsp;&nbsp; <B>JButton</B> f = new <B>JButton</B>("Top");
&nbsp;&nbsp;&nbsp; f.<B>setToolTipText</B>("Nested <B>JButton</B> objects");
&nbsp;&nbsp;&nbsp; this.getContentPane().add(a);
&nbsp;&nbsp;&nbsp; a.add(b);
&nbsp;&nbsp;&nbsp; b.add(c);
&nbsp;&nbsp;&nbsp; c.add(d);
&nbsp;&nbsp;&nbsp; d.add(e);
&nbsp;&nbsp;&nbsp; e.add(f);

&nbsp;&nbsp;&nbsp; //Set size and display the GUI&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; this.setSize(400,280);
&nbsp;&nbsp;&nbsp; this.setVisible(true);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Create an inner class WindowAdapter to terminate the
&nbsp;&nbsp;&nbsp; // program when the <B>JFrame</B> is closed.
&nbsp;&nbsp;&nbsp; this.addWindowListener(new WindowAdapter() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(WindowEvent e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});//end WindowListener
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;
}//end class Swing09
//=======================================================//

//This class is used to instantiate a panel containing
// two Hidden Buttons.
class <B>HiddenButtonPanel</B> extends <B>JPanel</B>{
&nbsp; //Create new image icons using gif files.&nbsp; You will need
&nbsp; // to provide icon sized gif files with names that match
&nbsp; // the file names in the following statements to be able
&nbsp; // to run this program.&nbsp; These images will appear on the
&nbsp; // buttons in their different states. <B>ImageIcon
</B>&nbsp; // implements the <B>Icon</B> interface so it can be used&nbsp;
&nbsp; // wherever an <B>Icon</B> is required (such as instantiation
&nbsp; // of a <B>JButton</B> with an <B>Icon</B>).
&nbsp; <B>ImageIcon</B> normalIcon = new <B>ImageIcon</B>("bulb3.gif");
&nbsp; <B>ImageIcon</B> rolloverIcon = new <B>ImageIcon</B>("bulb2.gif");
&nbsp; <B>ImageIcon</B> pressedIcon = new <B>ImageIcon</B>("bulb1.gif");

&nbsp; //Declare references to two buttons of two different
&nbsp; // types.
&nbsp; <B>JToggleButton</B> myJToggleButton;
&nbsp; <B>JButton</B> myJButton;
&nbsp;&nbsp;
&nbsp; <B>HiddenButtonPanel</B>(){//constructor
&nbsp;&nbsp;&nbsp; //Create and prep the <B>JButton</B> object
&nbsp;&nbsp;&nbsp; //Instantiate a <B>JButton</B> object with a caption and
&nbsp;&nbsp;&nbsp; // an icon.
&nbsp;&nbsp;&nbsp; myJButton = new <B>JButton</B>("<B>JButton</B>", normalIcon);
&nbsp;&nbsp;&nbsp; //Establish icon to be displayed during mouse rollover
&nbsp;&nbsp;&nbsp; myJButton.<B>setRolloverIcon</B>(rolloverIcon);
&nbsp;&nbsp;&nbsp; //Establish icon to be displayed when button is pressed
&nbsp;&nbsp;&nbsp; myJButton.<B>setPressedIcon</B>(pressedIcon);

&nbsp;&nbsp;&nbsp; //Enable the Swing rollover effects.
&nbsp;&nbsp;&nbsp; myJButton.<B>setRolloverEnabled</B>(true);
&nbsp;&nbsp;&nbsp; //Set text for the tool tip for the button.
&nbsp;&nbsp;&nbsp; myJButton.<B>setToolTipText</B>("This is a <B>JButton</B>");
&nbsp;&nbsp;&nbsp; //Hide the border on the button
&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp; //Add the button to the panel
&nbsp;&nbsp;&nbsp; this.add(myJButton);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Inner class listener to display and hide borders
&nbsp;&nbsp;&nbsp; // on the button when the mouse enters and exits.
&nbsp;&nbsp;&nbsp; myJButton.addMouseListener(new MouseAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void mouseEntered(MouseEvent mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display border on the button
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseEntered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void mouseExited(MouseEvent mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Hide the border on the button
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseExited()
&nbsp;&nbsp;&nbsp; });//end inner-class definition

&nbsp;&nbsp;&nbsp; //Create and prep the <B>JToggleButton</B> object&nbsp; .&nbsp; See
&nbsp;&nbsp;&nbsp; // explanatory comments in the code for the <B>JButton
</B>&nbsp;&nbsp;&nbsp; //above.
&nbsp;&nbsp;&nbsp; myJToggleButton = new <B>JToggleButton</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<B>JToggleButton</B>", normalIcon);
&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setRolloverIcon</B>(rolloverIcon);
&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setPressedIcon</B>(pressedIcon);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setRolloverEnabled</B>(true);
&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setToolTipText</B>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "This is a <B>JToggleButton</B>");
&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp; this.add(myJToggleButton);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Inner class listener to respond to rollover
&nbsp;&nbsp;&nbsp; myJToggleButton.addMouseListener(new MouseAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void mouseEntered(MouseEvent mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setBorderPainted</B>(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseEntered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void mouseExited(MouseEvent mouseEvent){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myJToggleButton.<B>setBorderPainted</B>(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end mouseExited()
&nbsp;&nbsp;&nbsp; });//end inner-class definition&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor&nbsp;&nbsp;
}//end class <B>HiddenButtonPanel
</B>//=======================================================//</PRE>
</TD>
</TR>
</TABLE>
.
<BR>&nbsp;
<CENTER>
<H2>
<A NAME="Program Listing for PlafPanel02"></A><FONT COLOR="#FF0000">Program
Listing for PlafPanel02</FONT></H2></CENTER>
This section contains a complete listing for the utility program named
PlafPanel02 that was used to implement the <I>PL&amp;F</I> capability in
this program.
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER BGCOLOR="#FFFF99" >
<TR>
<TD>
<PRE>/*File PlafPanel02 Copyright 1998, R.G.Baldwin
This is a revision to PlafPanel01.&nbsp; This version is&nbsp;
designed to stand alone inside its own JFrame object.
To use this program, simply instantiate an object of
this type and pass a reference to the JFrame under test
as a parameter.

The purpose of this class is to construct an object that
can easily be associated with a GUI to test the GUI
for all of the Look and Feel implementations installed&nbsp;
with the current JDK.

To associate this object with a GUI under test, pass
a reference to the JFrame containing the GUI as a
parameter when this object is constructed.

This class creates a JFrame. The JFrame contains one&nbsp;
JButton for each L&amp;F implementation in the currently&nbsp;
installed JDK.&nbsp; Clicking each JButton will cause the L&amp;F
of the GUI to change to the L&amp;F represented by that&nbsp;
JButton.

The name of the L&amp;F is displayed on the JButton.
&nbsp;&nbsp;
The key statements in selecting and then implementing
the new L&amp;F are:
&nbsp;&nbsp;
UIManager.setLookAndFeel(plafClassName);&nbsp;&nbsp;
&nbsp;&nbsp;
SwingUtilities.updateComponentTreeUI(thisPlafPanel);
SwingUtilities.updateComponentTreeUI(testGui);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
These statements are discussed further in the comments
in the program.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tested using JDK 1.1.6 and Swing 1.0.1 under Win95.
**********************************************************/

import java.awt.event.*;
import java.awt.*;
import com.sun.java.swing.*;
import java.util.*;

public class PlafPanel02 extends JFrame {
&nbsp; /*
&nbsp; The following is an unusual reference variable type that
&nbsp; is used to refer to an array of L&amp;F information.&nbsp; As of
&nbsp; Swing 1.0.1, the document that should explain this type
&nbsp; is missing from the download documentation file.
&nbsp;&nbsp;
&nbsp; The best available information seems to be the following
&nbsp; statement that was extracted from the description of the
&nbsp; method named getInstalledLookAndFeels() that returns an&nbsp;
&nbsp; array object of this type (a minor typo was corrected
&nbsp; by the author in this quotation):

&nbsp; "Return an array of objects that provide some&nbsp;
&nbsp; information about the LookAndFeel implementations
&nbsp; that have been installed with this java development kit.
&nbsp; The LookAndFeelInfo objects can be used by an&nbsp;
&nbsp; application to construct a menu of look and feel options
&nbsp; for the user or to set the look and feel at start up
&nbsp; time."
&nbsp; */
&nbsp; UIManager.LookAndFeelInfo[] plafInfoArray;
&nbsp; //-----------------------------------------------------//
&nbsp; JFrame testGui;//save a reference to the test GUI here
&nbsp; PlafPanel02 thisPlafPanel = this;//ref to this object
&nbsp;&nbsp;
&nbsp; public PlafPanel02(JFrame testGui) {//constructor
&nbsp;&nbsp;&nbsp; this.testGui = testGui;//save ref to test GUI
&nbsp;&nbsp;&nbsp; this.getContentPane().add(new JLabel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PL&amp;F Selection Panel, Copyright 1998, RGBaldwin"));
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get the list of L&amp;Fs installed with the current JDK
&nbsp;&nbsp;&nbsp; //See note above regarding this method.
&nbsp;&nbsp;&nbsp; plafInfoArray = UIManager.getInstalledLookAndFeels();
&nbsp;
&nbsp;&nbsp;&nbsp; //Create a vector of references to JButton objects&nbsp;
&nbsp;&nbsp;&nbsp; // with one element in the vector for each L&amp;F
&nbsp;&nbsp;&nbsp; // implementation in the current JDK.&nbsp;
&nbsp;&nbsp;&nbsp; Vector theButtons = new Vector(plafInfoArray.length);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create one JButton object for each L&amp;F implementation
&nbsp;&nbsp;&nbsp; // and put its reference in the Vector.
&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; plafInfoArray.length; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theButtons.addElement(new JButton());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get the name of the class for each specific L&amp;F
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // implementation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String theClassName =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plafInfoArray[cnt].getClassName();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Extract a short name for each specific L&amp;F&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // implementation and use it to label the JButton&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // corresponding to that L&amp;F. The short name appears
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // following the last period in the String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // representation of the class name for the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // L&amp;F implementation. Note the requirement to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // downcast the reference extracted from the Vector.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String label = theClassName.substring(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassName.lastIndexOf(".")+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)theButtons.elementAt(cnt)).setText(label);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Add an action listener to each JButton that will
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cause the L&amp;F to change to the one represented by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that JButton whenever the JButton is clicked. Note
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that because the references to the buttons are
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stored in a Vector, it is necessary to downcast
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // them from Object to JButton.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((JButton)theButtons.elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addActionListener(new MyActionListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theClassName));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Add each JButton to the JFrame.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getContentPane().add((JButton)theButtons.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elementAt(cnt));
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; this.getContentPane().setLayout(new FlowLayout());
&nbsp;&nbsp;&nbsp; this.setTitle("Copyright 1998, R.G.Baldwin");
&nbsp;&nbsp;&nbsp; this.setBounds(30,300,350,150);
&nbsp;&nbsp;&nbsp; this.setVisible(true);
&nbsp; }//end constructor
&nbsp; //=====================================================//
&nbsp;&nbsp;
&nbsp; //Inner class for action listeners
&nbsp; class MyActionListener implements ActionListener{
&nbsp;&nbsp;&nbsp; String plafClassName;//save name of plaf class here

&nbsp;&nbsp;&nbsp; //Constructor
&nbsp;&nbsp;&nbsp; MyActionListener(String plafClassName){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save the incoming parameter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.plafClassName = plafClassName;
&nbsp;&nbsp;&nbsp; }//end constructor
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; public void actionPerformed(ActionEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the current default L&amp;F to that passed in as
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a parameter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIManager.setLookAndFeel(plafClassName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(Exception ex){System.out.println(ex);}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now implement the current default L&amp;F to make it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // take effect. The description of the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // updateComponentTreeUI() method as extracted from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the documentation is as follows:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //"A simple minded look and feel change: ask each&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // node in the tree to updateUI(), i.e. to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initialize its UI property with the current look
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and feel."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the L&amp;F for this PlafPanel object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SwingUtilities.updateComponentTreeUI(thisPlafPanel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the L&amp;F for the test GUI object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SwingUtilities.updateComponentTreeUI(testGui);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }//end actionPerformed()
&nbsp; }//end class MyActionListener
&nbsp;&nbsp;
&nbsp; //main method for stand-alone testing
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; new PlafPanel02(new JFrame());
&nbsp; }//end main()
}//end class PlafPanel02
//=======================================================//</PRE>
</TD>
</TR>
</TABLE>
&nbsp;.
<BR>-end-
<!--end-->
</BODY>
</HTML>
