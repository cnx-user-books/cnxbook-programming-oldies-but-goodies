<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
  <body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>2D Fourier Transforms using Java, Part 2</h2>
    <i>Examine the code for a Java class that can be used to perform forward and 
inverse 2D Fourier transforms on 3D surfaces in the space domain.&nbsp; Learn 
how the 2D Fourier transform behaves for a variety of different sample surfaces in 
the space domain.</i><p><b>Published:</b>&nbsp; August 9, 2005<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes #  1491</p>
     
<ul>
    <li> <a href="#Preface">Preface</a></li>
   <li><a href="#General_Discussion">General Discussion</a></li>
	<li><a href="#Preview">Preview</a></li>
     <li> <a href="#A_Sample_Program">Sample Programs</a></li>
     <li> <a href="#Run_the_Program">Run the Program</a></li>
     <li> <a href="#Summary">Summary</a></li>
	<li> <a href="#Whats Next">What's Next?</a></li>
     <li> <a href="#Complete_Program_Listing">Complete Program Listing</a></li>
       
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface"></a>Preface</h2>
   </center>
  <p>This is the second part of a two-part lesson.&nbsp; The first part published 
	earlier was entitled 
	<a href="http://www.developer.com/java/other/article.php/3519441">2D Fourier transforms using Java</a>.&nbsp; In 
	this lesson, I will teach you how to perform two-dimensional <i>(2D)</i> 
	Fourier transforms using Java.&nbsp; I will</p>
<ul>
	<li>Explain the conceptual and computational aspects of 2D Fourier 
	transforms</li>
	<li>Explain the relationship between the <i>space domain</i> and the <i>
	<a href="http://scienceworld.wolfram.com/physics/Wavenumber.html">wavenumber</a></i> 
	domain</li>
	<li>Provide sufficient background information that you will be able to 
	appreciate the importance of the 2D Fourier transform</li>
	<li>Provide Java software to perform 2D Fourier transforms</li>
	<li>Provide Java software to test and exercise that capability</li>
</ul>
<p><font color="#ff0000"><b>Two separate programs</b></font></p>
<p>I will present and explain two separate programs.&nbsp; One program consists of a 
single class named <b>ImgMod30</b>.&nbsp; The purpose of this class is to satisfy the 
computational requirements for forward and inverse 2D Fourier transforms.&nbsp; This 
class also provides a method for rearranging the spectral data into a more 
useful format for plotting.&nbsp; The second program named <b>ImgMod31</b> will be 
used to test the 2D Fourier transform class, and also to illustrate the use of 
2D Fourier transforms for some well known sample surfaces.</p>
<p>A third class named <b>ImgMod29</b> will be used to display various 3D 
surfaces resulting from the application of the 2D Fourier transform.&nbsp; I 
explained this class in an earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a>.</p>
<p><font color="#ff0000"><b>Using the class named ImgMod30</b></font></p>
<p>The 2D Fourier transform class couldn't be easier to use.&nbsp; To perform a 
forward transform execute a statement similar to the following:</p>
<pre>ImgMod30.<b>xform2D</b>(spatialData,realSpect,
                 imagSpect,amplitudeSpect);</pre>
<p>The first parameter in the above statement is a reference to an array object 
containing the data to be transformed.&nbsp; The other three parameters refer to 
array objects that will be populated with the results of the transform.</p>
<p>To perform an inverse transform execute a statement similar to the following:</p>
<pre>ImgMod30.<b>inverseXform2D</b>(realSpect,imagSpect,
                        recoveredSpatialData);</pre>
<p>The first two parameters in the above statement refer to array objects 
containing the complex spectral data to be transformed.&nbsp; The third parameter 
refers to an array that will be populated with the results of the inverse 
transform.</p>
<p>To rearrange the spectral data for plotting, execute a statement similar to 
the following where the parameter refers to an array object containing the 
spectral data to be rearranged.</p>
<pre>double[][] <b>shiftedRealSpect</b> = 
                 ImgMod30.shiftOrigin(realSpect);</pre>
<p><b><font color="#ff0000">Digital signal processing (DSP)</font></b></p>
<p>This lesson will cover some technically difficult material in the general 
area of <i>Digital Signal Processing,</i> or <i>DSP</i> for short.&nbsp; As usual, 
the better prepared you are, the more likely you are to understand the 
material.&nbsp; For example, it would be well for you to already understand the 
one-dimensional Fourier transform before tackling the 2D Fourier transform.&nbsp; If 
you don't already have that knowledge, you can learn about one-dimensional 
Fourier transforms by studying the following <a name="lessons">lessons</a>:</p>
<ul>
	<li><a href="http://www.developer.com/java/other/article.php/3374611">1478 
	Fun with Java, How and Why Spectral Analysis Works</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3380031">1482 
	Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the 
	FFT Algorithm </a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3392871">1483 
	Spectrum Analysis using Java, Frequency Resolution versus Data Length </a>
	</li>
	<li><a href="http://www.developer.com/java/other/article.php/3411041">1484 
	Spectrum Analysis using Java, Complex Spectrum and Phase Angle</a></li>
	<li><a href="http://www.developer.com/java/other/article.php/3436341">1485 
	Spectrum Analysis using Java, Forward and Inverse Transforms, Filtering in 
	the Frequency Domain</a> </li>
	<li><a href="http://www.developer.com/java/other/article.php/3457251">1486 
	Fun with Java, Understanding the Fast Fourier Transform (FFT) Algorithm</a></li>
</ul>
<p>In addition, I strongly recommend that you study 
<a href="http://www.developer.com/java/other/article.php/3519441">Part 1</a> of this lesson 
before embarking on this part.&nbsp; You might also enjoy studying my other 
lessons on <a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a> as well.</p>
<p><font color="#ff0000"><b>Will use in subsequent lessons</b></font></p>
<p>The 2D Fourier transform has many uses.&nbsp; I will use the 2D Fourier transform 
in several future lessons involving such diverse topics as:</p>
<ul>
	<li>Processing image pixels in the wavenumber domain</li>
	<li>Advanced steganography <i>(hiding messages in images)</i></li>
	<li>Hiding watermarks and trademarks in images</li>
</ul>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a separate 
browser window.&nbsp; That will make it easier for you to scroll back and forth among 
the different figures and listings while you are reading about them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive collection 
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, as of 
the date of this writing, Gamelan doesn't maintain a consolidated index of my 
Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; You 
will find a consolidated index at <a href="http://www.dickbaldwin.com">
www.DickBaldwin.com</a><font color="#000000">.</font></p>
<h2 align="center"><a name="General_Discussion">General Discussion</a></h2>
<p><font color="#ff0000"><b>The space domain</b></font></p>
<p>In Part 1 of this lesson, I extended the concept of the Fourier transform 
from the time domain into the <i>space domain.&nbsp; </i>I pointed out that while the 
time domain is one-dimensional, the space domain is thee-dimensional.&nbsp; 
However, in order to keep the complexity of this lesson in check, we will assume 
that space is only two-dimensional.&nbsp; This will serve us well later for such 
tasks as image processing.</p>
<blockquote>
	<p><i>(Three-dimensional Fourier transforms are beyond the scope of this 
	lesson.&nbsp; I will write a lesson on using Fourier transforms in 
	three-dimensional space later if I have the time.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A purely real space domain</b></font></p>
<p>Although the space domain can be <i>(and often is)</i> complex, many 
interesting problems, <i>(such as photographic image processing)</i> can be 
dealt with under the assumption that the space domain is purely real.&nbsp; We 
will make that assumption in this lesson.&nbsp; This assumption will allow us to 
simplify our computations when performing the 2D Fourier transform to transform 
our data from the space domain into the wavenumber domain.</p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p>I will present and explain two complete Java programs in this lesson.&nbsp; 
The first program is a single class named <b>ImgMod30</b>, which provides the 
capability to perform forward and inverse Fourier transforms on 
three-dimensional surfaces.&nbsp; In addition, the class provides a method that 
can be used to reformat the wavenumber spectrum to make it more suitable for 
display.</p>
<p>The second program is named <b>ImgMod31</b>.&nbsp; This is an executable 
program whose purpose is to exercise and to test the <b>ImgMod30</b> class using 
several examples for which the results should already be known.</p>
<h2 align="center"><a name="A_Sample_Program">Sample Programs</a></h2>
<p><font color="#FF0000"><b>The class named ImgMod30</b></font></p>
<p>This class provides 2D Fourier transform capability that can be used for image 
processing and other purposes.&nbsp; The class provides three static methods: </p>
<ul>
	<li><b>xform2D</b>: Performs a forward 2D Fourier transform on a purely real surface 
	described by a 2D array of double values in the space domain to produce a 
	spectrum in the wavenumber domain.&nbsp; The method returns the real part, 
	the imaginary part, and the amplitude spectrum, each in its own 2D array of 
	double values.</li>
	<li><b>inverseXform2D</b>: Performs an inverse 2D Fourier transform from the 
	wavenumber domain into the space domain using the real and imaginary parts 
	of the wavenumber spectrum as input.&nbsp; Returns the surface in the space 
	domain as a 2D array of double values.&nbsp; Assumes that the real and 
	imaginary parts in the wavenumber domain are consistent with a purely real 
	surface in the space domain, and does not return an imaginary 
	surface for the space domain</li>
	<li><b>shiftOrigin</b>: The wavenumber spectrum produced by <b>xform2D</b> has its 
	origin in the upper left corner with the Nyquist folding wave numbers near 
	the center.&nbsp; This is not a very suitable format for visual analysis.&nbsp; 
	This method rearranges the data to place the origin at the center with the 
	Nyquist folding wave numbers along the edges.</li>
</ul>
<p>The class was tested using J2SE 5.0 and WinXP.&nbsp; The class uses the <i>
static import</i> capability that was introduced in J2SE 5.0.&nbsp; Therefore, 
it should not compile using earlier versions of the compiler.</p>
<p><font color="#FF0000"><b>The xform2D method</b></font></p>
<p>The beginning of the class and the beginning of the static method named 
<b>xform2D</b> is shown in Listing 1.</p>
<p>This method computes a forward 2D Fourier transform from the space domain 
into the wavenumber domain.&nbsp; The number of points produced for the 
wavenumber domain matches the number of points received for the space domain in 
both dimensions.&nbsp; Note that the input data must be purely real.&nbsp; In 
other words, the program assumes that there are no imaginary values in the space 
domain.&nbsp; Therefore, this is not a general purpose 2D complex-to-complex 
transform.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod30{
  static void xform2D(double[][] inputData,
                      double[][] realOut,
                      double[][] imagOut,
                      double[][] amplitudeOut){

    int height = inputData.length;
    int width = inputData[0].length;
    
    System.out.println("height = " + height);
    System.out.println("width = " + width);<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Parameters</b></font></p>
<p>The first parameter is a reference to a 2D <b>double </b>array object containing the data 
to be transformed.&nbsp; The remaining three parameters are references to 2D <b>
double</b> array objects of the same size that will be populated with the 
following transform results:</p>
<ul>
	<li>The real part</li>
	<li>The imaginary part</li>
	<li>The amplitude <i>(square root of sum of squares of the real and imaginary 
	parts)</i></li>
</ul>
<p>Listing 1 also determines and displays the dimensions of the incoming 2D 
array of data to be transformed.</p>
<p>I won't bore you with the details as to how and why the 2D Fourier transform 
does what it does.&nbsp; Neither will I bore you with the details of the code 
that implements the 2D Fourier transform.&nbsp; If you understand the material 
that I have <a href="#lessons">previously published</a> on Fourier transforms in 
one dimension, this code and these concepts should be a straightforward 
extension from one dimension to two dimensions.</p>
<p><font color="#FF0000"><b>The remainder of the xform2D method</b></font></p>
<p>The remainder of the xform2D method is shown in Listing 2.&nbsp; Note that it was necessary to sacrifice indentation 
in order to force these very long equations to be compatible with this narrow publication format and still be somewhat readable.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Two outer loops iterate on output data.
    for(int yWave = 0;yWave &lt; height;yWave++){
      for(int xWave = 0;xWave &lt; width;xWave++){
        //Two inner loops iterate on input data.
        for(int ySpace = 0;ySpace &lt; height;
                                       ySpace++){
          for(int xSpace = 0;xSpace &lt; width;
                                       xSpace++){
//Compute real, imag, and ampltude. 
realOut[yWave][xWave] += 
 (inputData[ySpace][xSpace]*cos(2*PI*((1.0*
 xWave*xSpace/width)+(1.0*yWave*ySpace/height))))
 /sqrt(width*height);
 
imagOut[yWave][xWave ] -= 
 (inputData[ySpace][xSpace]*sin(2*PI*((1.0*xWave*
  xSpace/width) + (1.0*yWave*ySpace/height))))
  /sqrt(width*height);
  
amplitudeOut[yWave][xWave] =
 sqrt(
  realOut[yWave][xWave] * realOut[yWave][xWave] +
  imagOut[yWave][xWave] * imagOut[yWave][xWave]);
          }//end xSpace loop
        }//end ySpace loop
      }//end xWave loop
    }//end yWave loop
  }//end xform2D method<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>
<font color="#FF0000"><b>The inverseXform2D method</b></font></p>
<p>
The <b>inverseXform2d</b> method is shown in its entirety in Listing 3.&nbsp; 
This method computes an inverse 2D Fourier transform from the wavenumber domain 
into the space domain.&nbsp; The number of points produced for the space domain 
matches the number of points received for the wavenumber domain in both 
dimensions.</p>
<p>
This method assumes that the inverse transform will produce purely real values 
in the space domain.&nbsp; Therefore, in the interest of computational 
efficiency, the method does not compute the imaginary output values.&nbsp; 
Therefore, this is not a general purpose 2D complex-to-complex transform.&nbsp; 
For correct results, the input complex data must match that obtained by 
performing a forward transform on purely real data in the space domain.</p>
<p>
Once again it was necessary to sacrifice indentation to force this very long equation to be compatible with this narrow publication format and still be readable.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  static void inverseXform2D(double[][] real,
                             double[][] imag,
                             double[][] dataOut){

    int height = real.length;
    int width = real[0].length;
    
    System.out.println("height = " + height);
    System.out.println("width = " + width);

    //Two outer loops iterate on output data.
    for(int ySpace = 0;ySpace &lt; height;ySpace++){
      for(int xSpace = 0;xSpace &lt; width;
                                       xSpace++){
        //Two inner loops iterate on input data.
        for(int yWave = 0;yWave &lt; height;
                                        yWave++){

          for(int xWave = 0;xWave &lt; width;
                                        xWave++){
//Compute real output data. 
dataOut[ySpace][xSpace] += 
 (real[yWave][xWave]*cos(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))) - 
 imag[yWave][xWave]*sin(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))))
 /sqrt(width*height);
          }//end xWave loop
        }//end yWave loop
      }//end xSpace loop
    }//end ySpace loop
  }//end inverseXform2D method<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Parameters</b></font></p>
<p>This method requires three parameters.&nbsp; The first two parameters are 
references to 2D arrays containing the real and imaginary parts of the 
complex wavenumber spectrum that is to be transformed into a surface in the 
space domain.</p>
<p>The third parameter is a reference to a 2D array of the same size that will 
be populated with the transform results.</p>
<p><font color="#FF0000"><b>The shiftOrigin method</b></font></p>
<p>This method deserves some 
explanation.&nbsp; The reason that this method is needed is illustrated by 
Figure 1.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491x.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491y.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 1</p>
<p><font color="#FF0000"><b>Two views of the same wavenumber spectrum</b></font></p>
<p>Both of the images in Figure 1 represent the same wavenumber spectrum, but 
they are plotted against different coordinate systems.&nbsp; </p>
<p><font color="#FF0000"><b>How the wavenumber spectrum is actually computed</b></font></p>
<p>The top image shows how the wavenumber spectrum is actually computed.</p>
<p>The wavenumber spectrum is computed covering an area of wavenumber space with 
the 0,0 origin in the upper left corner.&nbsp; The computation extends to twice 
the Nyquist folding wave number along each axis.</p>
<p><font color="#FF0000"><b>Computationally sound but not visually pleasing</b></font></p>
<p>While this format is computationally sound, it isn't what most of us are 
accustomed to seeing in plots wavenumber space.&nbsp; Rather, we are accustomed 
to seeing wavenumber spectra plotted with the 0,0 origin at the center.</p>
<p><font color="#FF0000"><b>The wavenumber spectrum is periodic</b></font></p>
<p>Knowing that the area of wavenumber space shown in the top image of Figure 1 
covers one complete period of a periodic surface, the <b>shiftOrigin</b> method 
rearranges the results <i>(for display purposes only)</i> to that shown in the 
bottom image in Figure 1.&nbsp; The origin is at the center in the bottom image 
of Figure 1.&nbsp; The edges of the lower image in Figure 1 are the Nyquist 
folding wave numbers.</p>
<p><font color="#FF0000"><b>The shiftOrigin method code</b></font></p>
<p>The <b>shiftOrigin</b> method is shown in its entirety in Listing 4.&nbsp; 
Although this method is rather long, it is also completely straightforward.&nbsp; 
Therefore, it shouldn't require a further explanation.&nbsp; You may be able to 
develop a much shorter algorithm for accomplishing the same task.</p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  //Method to shift the wavenumber origin and
  // place it at the center for a more visually
  // pleasing display.  Must be applied
  // separately to the real part, the imaginary
  // part, and the amplitude spectrum for a
  // wavenumber spectrum.
  static double[][] shiftOrigin(double[][] data){
    int numberOfRows = data.length;
    int numberOfCols = data[0].length;
    int newRows;
    int newCols;
    
    double[][] output = 
          new double[numberOfRows][numberOfCols];
          
    //Must treat the data differently when the
    // dimension is odd than when it is even.
    
    if(numberOfRows%2 != 0){//odd
      newRows = numberOfRows + 
                            (numberOfRows + 1)/2;
    }else{//even
      newRows = numberOfRows + numberOfRows/2;
    }//end else
    
    if(numberOfCols%2 != 0){//odd
      newCols = numberOfCols +
                            (numberOfCols + 1)/2;
    }else{//even
      newCols = numberOfCols + numberOfCols/2;
    }//end else
    
    //Create a temporary working array.
    double[][] temp = 
                    new double[newRows][newCols];
                    
    //Copy input data into the working array.
    for(int row = 0;row &lt; numberOfRows;row++){
      for(int col = 0;col &lt; numberOfCols;col++){
        temp[row][col] = data[row][col];
      }//col loop
    }//row loop
    
    //Do the horizontal shift first
    if(numberOfCols%2 != 0){//shift for odd

      //Slide leftmost (numberOfCols+1)/2 columns
      // to the right by numberOfCols columns
      for(int row = 0;row &lt; numberOfRows;row++){
        for(int col = 0;
                 col &lt; (numberOfCols+1)/2;col++){
          temp[row][col + numberOfCols] = 
                                  temp[row][col];
        }//col loop
      }//row loop

      //Now slide everything back to the left by
      // (numberOfCols+1)/2 columns
      for(int row = 0;row &lt; numberOfRows;row++){
        for(int col = 0;
                       col &lt; numberOfCols;col++){
          temp[row][col] = 
             temp[row][col+(numberOfCols + 1)/2];
        }//col loop
      }//row loop
      
    }else{//shift for even
      //Slide leftmost (numberOfCols/2) columns
      // to the right by numberOfCols columns.
      for(int row = 0;row &lt; numberOfRows;row++){
        for(int col = 0;
                     col &lt; numberOfCols/2;col++){
          temp[row][col + numberOfCols] = 
                                  temp[row][col];
        }//col loop
      }//row loop
      
      //Now slide everything back to the left by
      // numberOfCols/2 columns
      for(int row = 0;row &lt; numberOfRows;row++){
        for(int col = 0;
                       col &lt; numberOfCols;col++){
          temp[row][col] = 
                 temp[row][col + numberOfCols/2];
        }//col loop
      }//row loop
    }//end else

    //Now do the vertical shift
    if(numberOfRows%2 != 0){//shift for odd
      //Slide topmost (numberOfRows+1)/2 rows
      // down by numberOfRows rows.
      for(int col = 0;col &lt; numberOfCols;col++){
        for(int row = 0;
                 row &lt; (numberOfRows+1)/2;row++){
          temp[row + numberOfRows][col] = 
                                  temp[row][col];
        }//row loop
      }//col loop

      //Now slide everything back up by
      // (numberOfRows+1)/2 rows.
      for(int col = 0;col &lt; numberOfCols;col++){
        for(int row = 0;
                       row &lt; numberOfRows;row++){
          temp[row][col] = 
             temp[row+(numberOfRows + 1)/2][col];
        }//row loop
      }//col loop
      
    }else{//shift for even
      //Slide topmost (numberOfRows/2) rows down
      // by numberOfRows rows
      for(int col = 0;col &lt; numberOfCols;col++){
        for(int row = 0;
                     row &lt; numberOfRows/2;row++){
          temp[row + numberOfRows][col] = 
                                  temp[row][col];
        }//row loop
      }//col loop
      
      //Now slide everything back up by
      // numberOfRows/2 rows.
      for(int col = 0;col &lt; numberOfCols;col++){
        for(int row = 0;
                       row &lt; numberOfRows;row++){
          temp[row][col] = 
                 temp[row + numberOfRows/2][col];
        }//row loop
      }//col loop
    }//end else
    
    //Shifting of the origin is complete.  Copy
    // the rearranged data from temp to output
    // array.
    for(int row = 0;row &lt; numberOfRows;row++){
      for(int col = 0;col &lt; numberOfCols;col++){
        output[row][col] = temp[row][col];
      }//col loop
    }//row loop

    return output;
  }//end shiftOrigin method

}//end class ImgMod30<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>End of the ImgMod30 class</b></font></p>
<p>Listing 4 also signals the end of the class definition for the class named <b>
ImgMod30</b>.</p>
<p><font color="#FF0000"><b>The program named ImgMod31</b></font></p>
<p>The purpose of this program is to exercise and to test the 2D Fourier 
transform 
methods and the axis shifting method provided by the class named <b>ImgMod30</b>.</p>
<p><font color="#FF0000"><b>Command line parameters</b></font></p>
<p>The <b>main</b> method in this class reads two command line parameters and 
uses them to select:</p>
<ul>
	<li>A specific case involving a particular 3D input surface in the space 
	domain.</li>
	<li>A specific display format.</li>
</ul>
<p><font color="#FF0000"><b>Forward and inverse Fourier transforms</b></font></p>
<p>The program performs a 2D Fourier transform on that surface followed by an 
inverse 2D Fourier transform.&nbsp; Six different plots are produced in this 
process showing different aspects of the transform and the inverse transform.</p>
<p><font color="#FF0000"><b>Fourteen cases</b></font></p>
<p>There are 14 different cases built into the program with case numbers ranging from 0 to 
13 inclusive.&nbsp; Each of the cases is designed such that the results of the 
analysis should be known in advance by a person familiar with 2D Fourier analysis 
and the wavenumber domain. Thus, these cases can be used to confirm that the 
transform code was properly written.</p>
<p>The cases are also designed to illustrate the impact of various space domain 
characteristics on the wavenumber spectrum.&nbsp; This information will be 
useful later when analyzing the results of performing 2D transforms on 
photographic images.</p>
<p><font color="#FF0000"><b>A stack of output images</b></font></p>
<p>Each time the program is run, it produces a stack of six output images in the 
upper left corner of the screen.&nbsp; A brief description of each of the output 
images is provided in the following list.&nbsp; The top-to-bottom order of the 
stack is:</p>
<ol>
	<li>Space domain output of inverse Fourier transform.&nbsp; Compare 
	with original input in 6 below.</li>
	<li>Amplitude spectrum in wavenumber domain with shifted origin.&nbsp; 
	Compare with 5 below.</li>
	<li>Imaginary wavenumber spectrum with shifted origin.</li>
	<li>Real wavenumber spectrum with shifted origin.</li>
	<li>Amplitude spectrum in wavenumber domain without shifted 
	origin.&nbsp; Compare with 2 above.</li>
	<li>Space domain input data.&nbsp; Compare with 1 above.</li>
</ol>
<p>To view the images near the bottom of the stack, you must physically move 
those on top to get them out of the way.</p>
<p><font color="#FF0000"><b>Numeric output</b></font>&nbsp;
</p>
<p>In addition, the program produces some numeric output on the command line 
screen that may be useful in confirming the validity of the forward and inverse 
transformation processes.&nbsp; 
Figure 2 shows an example of the numeric output.<br>
</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>height = 41
width = 41
height = 41
width = 41

2.0                  1.9999999999999916
0.5000000000000002   0.49999999999999845
0.49999999999999956  0.4999999999999923
1.7071067811865475   1.7071067811865526
0.2071067811865478   0.20710678118654233
0.20710678118654713  0.20710678118655435
1.0                  1.0000000000000064
-0.4999999999999997 -0.49999999999999484
-0.5000000000000003 -0.4999999999999965<br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<blockquote>
	<p><i>(Note that I manually 
inserted some spaces line breaks in Figure 2 to cause the numeric values to line up in 
columns so as to be more readable.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The size of the surfaces</b></font></p>
<p>The first two lines of numeric output in Figure 2 show the size of the spatial surface for the 
forward transform.&nbsp; The second two lines show the size of the 
wavenumber surface for the inverse transform.</p>
<p><font color="#FF0000"><b>The quality of the transformation process</b></font></p>
<p>The remaining nine lines 
indicate something about the quality of the forward and inverse transforms in terms of 
the ability of the inverse transform to replicate the original spatial surface.&nbsp; These lines also 
indicate something about the correctness of the overall scaling 
from original input to final output.</p>
<p><font color="#FF0000"><b>Matching pairs of values</b></font></p>
<p>Each of the last nine lines contains a pair of values.&nbsp; 
The first value is a sample from the original spatial surface.&nbsp; The second value is 
a sample from the corresponding location on the spatial surface produced by performing an inverse transform on the 
wavenumber spectrum.&nbsp; The two values in each pair of values should match.&nbsp; 
If they match, this indicates the probability of a valid result.</p>
<blockquote>
	<p><i>(Note 
however that this is a very small sampling of the values that make up the 
original and replicated spatial data and problems could arise in areas that are 
not included in this small sample.)</i></p>
</blockquote>
<p>The match is very good in the example 
shown above.&nbsp; This example is from Case #12.</p>
<p><font color="#FF0000"><b>How to use the program named ImgMod31</b></font></p>
<p>Usage information for the program is shown in Figure 3.</p>
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      Usage:
<br>
		<b>java ImgMod31 CaseNumber DisplayType</b><p><b>CaseNumber</b> ranges from 0 to 13 inclusive.</p>
		<p><b>DisplayType</b> 
		ranges from 0 to 2 inclusive.</p>
		<p>If a case number is not provided, case 2 will be
run by default.</p>
		<p>If a display type is not 
provided, display type 1 will be used by default.
<br>
      </p>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>A description of each 
case is provided by the comments in this program.&nbsp; In addition, each case 
will be discussed in detail in this lesson.</p>
<p>See <b>ImgMod29</b> in the earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a> for a 
definition of <b>DisplayType</b>.</p>
<p>You can 
terminate the program by clicking on the close button on any of the display 
frames produced by the program.</p>
<p><font color="#FF0000"><b>Let's see some code</b></font></p>
<p>The beginning of the class and the beginning of the <b>main</b> method is 
shown in Listing 5.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>class ImgMod31{
  
  public static void main(String[] args){
    int switchCase = 2;//default
    int displayType = 1;//default
    if(args.length == 1){
      switchCase = Integer.parseInt(args[0]);
    }else if(args.length == 2){
      switchCase = Integer.parseInt(args[0]);
      displayType = Integer.parseInt(args[1]);
    }else{
      System.out.println("Usage: java ImgMod31 " 
                     + "CaseNumber DisplayType");
      System.out.println(
           "CaseNumber from 0 to 13 inclusive.");
      System.out.println(
           "DisplayType from 0 to 2 inclusive.");
      System.out.println("Running case " 
                  + switchCase + " by default.");
      System.out.println("Running DisplayType "
                 + displayType + " by default.");
    }//end else<br><br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 5 gets the input parameters and uses them to set the case 
and the display format.&nbsp; A default case and a default display format are 
used if this information is not provided by the user.</p>
<p><font color="#FF0000"><b>Create and save the test surface</b></font></p>
<p>Listing 6 invokes the method named <b>getSpatialData</b> to create a 
test surface that matches the specified case.&nbsp; This surface will be used for testing the transformation process.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    int rows = 41;
    int cols = 41;

    double[][] spatialData = 
            <b>getSpatialData</b>(switchCase,rows,cols);<br><br><b><font face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>I will discuss the method named <b>getSpatialData</b> in detail later.&nbsp; 
For now, just assume that the 2D array object referred to by <b>spatialData</b> 
contains the test surface when this method returns.</p>
<p><font color="#FF0000"><b>Display the test surface</b></font></p>
<p>Listing 7 instantiates an object of the class named <b>ImgMod29</b> to display the test surface in the display format indicated by the value of <b>
displayType</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    new ImgMod29(spatialData,3,false,
                                    displayType);<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The value of <b>false </b>in the third parameter indicates that the axes 
should not be displayed.</p>
<blockquote>
	<p><i>(See the lesson entitled </i>
	<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a><i> for an 
	explanation of the second parameter.&nbsp; Basically, this parameter is used 
	to control the overall size of the plot.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>An example test surface plot</b></font></p>
<p>The upper left image in Figure 4 is an example of the output produced by the 
code in Listing 7 for a <b>displayType</b> value of 0<b>.</b></p>
<blockquote>
	<p><i>(Figure 4 shows the grayscale format.&nbsp; See the lesson entitled 
	</i><a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a><i> for an explanation of the three 
	available display formats.)</i></p>
</blockquote>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491a1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491a2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491a3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491a4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491a5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491a6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 4</p>
<p>Figure 4 shows the results for a test surface <b>switchCase</b> value of 2.&nbsp; I will discuss 
the particulars of this case in detail later.</p>
<p><font color="#FF0000"><b>Perform the forward Fourier transform</b></font></p>
<p>Listing 8 performs the forward Fourier transform to transform the test 
surface into the wavenumber domain.&nbsp; </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    double[][] realSpect = //Real part
                          new double[rows][cols];
    double[][] imagSpect = //Imaginary part
                          new double[rows][cols];
    double[][] amplitudeSpect = //Amplitude
                          new double[rows][cols];

    ImgMod30.<b>xform2D</b>(spatialData,realSpect,
                       imagSpect,amplitudeSpect);<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Prepare array objects to receive the transform 
results</b></font></p>
<p>Listing 8 begins by preparing some array objects to receive the transform 
results.&nbsp; The forward transform receives an incoming surface array and 
returns the real and imaginary parts of the complex wavenumber spectrum along with 
the amplitude spectrum by populating three array objects passed as parameters to 
the method.</p>
<p><font color="#FF0000"><b>Perform the forward transform</b></font></p>
<p>Then Listing 8 invokes the static <b>xform2D</b> method of the <b>ImgMod30</b> 
class to perform the forward transform, returning the results by way of the 
parameters to the method.</p>
<p><font color="#FF0000"><b>Display unshifted amplitude spectrum</b></font></p>
<p>The upper right image in Figure 4 is an example of the type of display 
produced by the code in Listing 9.&nbsp; This is a plot of the amplitude 
spectrum without the wavenumber origin being shifted to place it at the center.</p>
<blockquote>
	<p><i>(The wavenumber origin is in the upper left corner of the upper right 
	image in Figure 4.)</i></p>
</blockquote>
<p>This image also shows the result of passing <b>true</b> as the third parameter 
causing the red axes to be plotted on top of the spectral data.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    new ImgMod29(amplitudeSpect,3,true,
                                    displayType);<br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Need to shift the origin for display</b></font></p>
<p>The upper right image in Figure 4 is in a format that is not particularly 
good for viewing.&nbsp; In particular, the origin is at the upper left corner.&nbsp; 
The horizontal Nyquist folding wavenumber is near the horizontal center of the 
plot.&nbsp; The vertical Nyquist folding wave number is near the vertical center 
of the plot.&nbsp; It is much easier for most people to understand the plot when 
the wavenumber origin is shifted to the center of the plot with the Nyquist 
folding wave numbers at the edges of the plot.</p>
<p>The method named <b>shiftOrigin</b> can be used to rearrange the data and shift the origin to the center of the plot.</p>
<p><font color="#FF0000"><b>Shift the origin and display the results</b></font></p>
<p>Listing 10 shifts the origin to the center of the plot and displays:</p>
<ul>
	<li>The real part of the shifted spectrum</li>
	<li>The imaginary part of the shifted spectrum</li>
	<li>The amplitude of the shifted spectrum</li>
</ul>
<p>The axes are displayed in all three cases.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    double[][] shiftedRealSpect = 
                 ImgMod30.shiftOrigin(realSpect);
    new ImgMod29(shiftedRealSpect,3,true,
                                    displayType);
    
    double[][] shiftedImagSpect = 
                 ImgMod30.shiftOrigin(imagSpect);
    new ImgMod29(shiftedImagSpect,3,true,
                                    displayType);
    
    double[][] shiftedAmplitudeSpect = 
            ImgMod30.shiftOrigin(amplitudeSpect);
    new ImgMod29(shiftedAmplitudeSpect,3,true,
                                    displayType);<br><br><b><font face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Example displays</b></font></p>
<p>Examples of the displays produced by the code in Listing 10 are shown in 
Figure 4.&nbsp; The real part of the shifted wavenumber spectrum is shown in the image 
in the top center of Figure 4.&nbsp; The imaginary part of the shifted wavenumber 
spectrum is shown in the bottom center of Figure 4.&nbsp; The shifted amplitude 
spectrum is shown in the bottom right image in Figure 4.&nbsp; The origin has 
been shifted to the center in all three cases.</p>
<blockquote>
	<p><i>(It would probably be constructive for you to compare the two 
	rightmost images in Figure 4 in order to appreciate the result of shifting 
	the origin to the center.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Perform an inverse transform</b></font></p>
<p>Listing 11 performs an inverse Fourier transform to transform the complex 
wavenumber surface into a real surface in the space domain.&nbsp; Ideally, the 
result should exactly match the space domain surface that was transformed into 
the wavenumber domain in Listing 8.&nbsp; However, because of small arithmetic 
errors that accumulate in the forward and inverse transform computations, it is 
unusual for an exact match to be achieved.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    double[][] recoveredSpatialData = 
                          new double[rows][cols];

    ImgMod30.inverseXform2D(realSpect,imagSpect,
                           recoveredSpatialData);
                           
<b><font face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Prepare an array object to store the results</b></font></p>
<p>Listing 11 begins by preparing an array object to store the results of the 
inverse transformation process.</p>
<p><font color="#FF0000"><b>Invoke the inverseXform2D method</b></font></p>
<p>Then Listing 11 invokes the <b>inverseXform2D</b> method to transform the 
complex wavenumber spectrum into a real space function.&nbsp; The <b>
inverseXform2D</b> method requires the real and imaginary parts of the complex 
wavenumber spectrum as input parameters.</p>
<blockquote>
	<p><i>(Note that these are the original real and imaginary parts of the 
	complex wavenumber spectrum.&nbsp; They are not the versions for which the 
	origin has been shifted for display purposes.)</i></p>
</blockquote>
<p>The <b>inverseXform2D</b> method also receives an incoming array object in 
which to store the real result of the transformation process.</p>
<p><font color="#FF0000"><b>Display the result of the inverse transform</b></font></p>
<p>Finally, Listing 12 displays the result of the inverse transformation process as a 
surface in the space domain.&nbsp; This surface should compare favorably with 
the original surface that was transformed into the wavenumber domain in Listing 
8&nbsp; </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    new ImgMod29(recoveredSpatialData,3,false,
                                    displayType);<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The output produced by Listing 12 is shown in the lower left image in Figure 
4.&nbsp; Compare this with the input surface shown in the upper left image in 
Figure 4.&nbsp; As you can see, they do compare favorably.&nbsp; In fact, they 
appear to be identical in this grayscale plotting format.&nbsp; We will see 
later that when a more sensitive plotting format is used, small differences in 
the two may become apparent.</p>
<p><font color="#FF0000"><b>Display some numeric results</b></font></p>
<p>As discussed earlier, the code in Listing 13 samples and displays a few 
corresponding points on the original surface and the surface produced by the 
inverse transformation process.&nbsp; The results can be used to evaluate the 
overall quality of the process as well as the correctness of the overall 
scaling.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int row = 0;row &lt; 3;row++){
      for(int col = 0;col &lt; 3;col++){
        System.out.println(
          spatialData[row][col] + " " + 
           recoveredSpatialData[row][col] + " ");
      }//col
    }//row
  }//end main<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Each line of output text contains two values, and ideally the two values 
should be exactly the same.&nbsp; Realistically, because of small computational 
errors in the transform and inverse transform process, it is unlikely that the 
two values will be exactly the same except in computationally trivial cases.&nbsp; 
Unless the two values are very close, however, something probably went wrong in 
the transformation process and the results should not be trusted.</p>
<p>Listing 13 also signals the end of the <b>main</b> method.</p>
<p><font color="#FF0000"><b>What we know so far ...</b></font></p>
<p>Now we know how to use the <b>ImgMod30</b> class and the <b>ImgMod29</b> 
class to:</p>
<ul>
	<li>Transform a purely real 3D surface from the space domain into the 
	wavenumber domain</li>
	<li>Transform a complex wavenumber spectrum into a purely real surface in 
	the space domain</li>
	<li>Shift the origin of the real, imaginary, and amplitude wavenumber 
	spectral parts to convert the data into a format that is more suitable for 
	plotting</li>
	<li>Plot 3D surfaces in both domains</li>
</ul>
<p>It is time to for us to take a look at the method named <b>getSpatialData</b> 
that can be used to create any of fourteen standard surfaces in the space 
domain.</p>
<p><font color="#FF0000"><b>The getSpatialData method</b></font></p>
<p>This method constructs and returns a specific 3D surface in a 2D array of 
type <b>double</b>.&nbsp; The surface is identified by the value of an incoming 
parameter named <b>switchCase</b>.&nbsp; There are 14 possible cases.&nbsp; The 
allowable values for <b>switchCase</b> range from 0 through 13 inclusive.</p>
<p>The other two input parameters specify the size of the surface that will be 
produced in units of 
rows and columns.</p>
<p><font color="#FF0000"><b>The code for the getSpatialData method</b></font></p>
<p>The <b>getSpatialData</b> method begins in Listing 14.&nbsp; </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  private static double[][] getSpatialData(
               int switchCase,int rows,int cols){
    
    double[][] spatialData = 
                          new double[rows][cols];
    
    switch(<b>switchCase</b>){<br><br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 14 begins by creating a 2D array object of type <b>double</b> in 
which to store the surface.</p>
<p>Then Listing 14 shows the beginning of a<b> switch</b> statement that will be 
used to select the code to create a surface that matches the value of the 
incoming parameter named<b> switchCase</b>.<b>&nbsp; </b></p>
<p><font color="#FF0000"><b>For switchCase = 0</b></font></p>
<p>Listing 15 shows the code that is executed for a value of <b>switchCase</b> 
equal to 0.&nbsp; </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case 0: 
        spatialData[0][0] = 1;
      break;<br><br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This case places a single non-zero point at the origin in the space domain.&nbsp; 
The origin is at the upper left corner.&nbsp; The surface produced by this case 
is shown in the leftmost image in Figure 5, and the non-zero value can be seen 
as the small white square in the upper left corner.&nbsp; In signal processing terminology, 
this point can be viewed as an impulse in space.&nbsp; It is well known that 
such an impulse produces a flat spectrum in wavenumber space.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491b1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491b2.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 5</p>
<p><font color="#FF0000"><b>The output surface</b></font></p>
<p>The rightmost image in Figure 5 shows the result of:</p>
<ul>
	<li>Performing a forward Fourier transform on the surface in the leftmost 
	image</li>
	<li>Performing an inverse Fourier transform on the complex wavenumber spectrum 
	produced by the forward transform.</li>
</ul>
<p>You can see the impulse as the small white square in the upper left corner of 
both images.</p>
<p><font color="#FF0000"><b>The wavenumber spectrum is flat</b></font></p>
<p>Because the wavenumber spectrum is flat, plots of the spectrum are completely 
featureless.&nbsp; Therefore, I did not include them in Figure 5.</p>
<p><font color="#FF0000"><b>A very small error</b></font></p>
<p>The numeric output shows that the final output surface matches the input 
surface to within an error that is less than about one part in ten to the fourteenth power.&nbsp; 
The program produces the expected results for this test case.</p>
<p>If you were to go back to the equations in Listing 2 and Listing 3 and work 
this case out by hand, you would soon discover that the computational 
requirements are almost trivial.&nbsp; Most of the computation involves doing 
arithmetic using values of 1 and 0.&nbsp; Thus, there isn't a lot of opportunity 
for computational errors in this case.</p>
<p><font color="#FF0000"><b>For switchCase = 1</b></font></p>
<p>Now we are going to a case that is more 
significant from a computational viewpoint.&nbsp; The input surface in this case will consist of a single 
impulse that is not located at the origin in the space domain.&nbsp; Rather, it 
is displaced from the origin.</p>
<p>The wavenumber amplitude spectrum of a single impulse in the space domain 
should be flat regardless of the location of the impulse in the space domain.&nbsp; 
However, the real and imaginary parts of the wavenumber spectrum are flat only 
when the impulse is located at the origin in space.&nbsp; This case does not 
satisfy that requirement.</p>
<p>Regardless of the fact that the real and imaginary parts are not flat, the 
square root of the sum of the squares of the real and imaginary parts <i>(the 
amplitude)</i> should be the same for every point in wavenumber space for this 
case.&nbsp; Thus, 
the real and imaginary parts are related in a very special way.</p>
<p><font color="#FF0000"><b>The code for switchCase = 1</b></font></p>
<p>The code that is executed when<b> switchCase</b> equals 1 is shown in Listing 
16.<b>&nbsp; </b> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case 1:
        spatialData[2][2] = 1;
      break;<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This case places a single impulse close to but not at the origin in space.&nbsp; 
This produces a flat amplitude spectrum in wavenumber space just like in case 
0.&nbsp; However, the real and imaginary parts of the spectrum are 
different from case 0.&nbsp; They are not flat.&nbsp; The computations are probably 
more subject to errors in this case than for case 0.</p>
<p><font color="#FF0000"><b>The visual output</b></font></p>
<p>Figure 6 shows the six output images produced by the program for a <b>
switchCase</b> value of 1.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491c1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491c2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491c3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491c4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491c5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491c6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 6</p>
<p><font color="#FF0000"><b>The input and output surfaces match visually</b></font></p>
<p>The input and output surfaces showing the single impulse are in the two 
leftmost images in Figure 6.&nbsp; From a visual viewpoint, the output at the 
bottom appears to be an exact match for the input at the top.</p>
<p><font color="#FF0000"><b>The real and imaginary parts</b></font></p>
<p>The real and imaginary parts of the wavenumber spectrum are shown in the two 
center images.&nbsp; The real part is at the top and the imaginary part is at 
the bottom.</p>
<p>For a single impulse in the space domain, we would expect each of these 
surfaces to be a 3D sinusoidal wave <i>(similar to a piece of corrugated sheet 
metal).</i>&nbsp; That appears to be what we are seeing, with almost two full 
cycles of the sinusoidal wave between the origin and the bottom right corner of 
the image.</p>
<blockquote>
	<p><i>(The distance between the peaks in the sinusoidal wave in wavenumber 
	space is inversely 
	proportional to the distance of the impulse from the origin in space.&nbsp; 
	Hence, as the impulse approaches the origin in space, the peaks in 
	wavenumber space become further and further apart.&nbsp; When the impulse is 
	located at the origin in space, the distance between the peaks in wavenumber 
	space becomes infinite, leading to flat real and imaginary parts.)</i></p>
</blockquote>
<p><font color="#FF0000"><b><a name="Symmetry">Symmetry</a></b></font></p>
<p>We know that the real part of a wavenumber spectrum resulting from the 
Fourier transform of a real space function is symmetric about the origin.&nbsp; 
We also know that the imaginary part is asymmetric about the origin.&nbsp; </p>
<p>The symmetry/asymmetry requirements appear to be satisfied by this case.&nbsp; 
The color bands in the real part at the top are symmetric on either side of the 
origin.</p>
<p>The imaginary part is asymmetric about the origin <i>(the centers of the 
red/white and the blue/black bands appear to be equidistant from and on opposite sides of 
the origin).</i></p>
<p><font color="#FF0000"><b>The amplitude spectrum is ugly</b></font></p>
<p>The amplitude spectrum is shown in the two rightmost images in Figure 6.&nbsp; 
The unshifted amplitude spectrum is shown at the top.&nbsp; The amplitude 
spectrum with the origin shifted to the center is shown at the bottom.</p>
<p>The ugliness of these two plots is an <a name="artifact">artifact</a> of the 3D plotting scheme 
implemented by the class named <b>ImgMod29</b>.&nbsp; In order to maximize the 
use of the available dynamic range in the plot, each surface that is plotted is 
normalized such that:</p>
<ul>
	<li>The highest elevation is colored white</li>
	<li>The lowest elevation is colored black</li>
	<li>Elevations between the highest and lowest values are colored according 
	to the calibration scale below the image</li>
</ul>
<p>This normalization is applied even when the distance between the highest and 
lowest elevation is very small.&nbsp; As a result of computational errors, the 
amplitude spectrum is not perfectly flat.&nbsp; Rather there are very small 
variations from one point to the next.&nbsp; As a result, the colors used to 
plot the surface switch among the full range of available colors even for 
tiny deviations from perfect flatness.</p>
<p><font color="#FF0000"><b>A very small error</b></font></p>
<p>The total error for this case is very small.&nbsp; The numeric output shows 
that the final output surface matches the input surface to within an error that 
is less than about one part in ten to the thirteenth power.&nbsp; The program produces the expected results 
for this test case.</p>
<p><font color="#FF0000"><b>For switchCase = 2</b></font></p>
<p>Now we are going to take a look at another case for which we know in advance 
generally what the outcome should be.&nbsp; This will allow us to compare the 
outcome with our expectations to confirm proper operation of the program.</p>
<p><font color="#FF0000"><b>A box on the diagonal in space</b></font></p>
<p>This case places a box that is one unit tall on the diagonal near the origin in the space domain as 
shown in the upper left image in Figure 7.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491d1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491d2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491d3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491d4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491d5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491d6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 7</p>
<p><font color="#FF0000"><b>What do we know?</b></font></p>
<p>On the basis of prior experience, we know that the amplitude spectrum of this surface along the horizontal and 
vertical axes of the wavenumber spectrum should have a rectified sin(x)/x shape
<i>(all negative values are converted to positive values).</i>&nbsp; We know 
that the peak in this amplitude spectrum should appear at the origin in 
wavenumber space, and that the width of the peak should be inversely 
proportional to the size of the box.</p>
<p><font color="#FF0000"><b>The code for switchCase = 2</b></font></p>
<p>The code that constructs the space domain surface for this case is shown in 
Listing 17.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case 2:
        spatialData[3][3] = 1;
        spatialData[3][4] = 1;
        spatialData[3][5] = 1;
        spatialData[4][3] = 1;
        spatialData[4][4] = 1;    
        spatialData[4][5] = 1;
        spatialData[5][3] = 1;
        spatialData[5][4] = 1;    
        spatialData[5][5] = 1;
      break;<br><br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This code is completely straightforward.&nbsp; It sets the value of each of 
nine adjacent points on the surface to a value of 1, while the values of all other points 
on the surface remain at zero.&nbsp; The arrangement of those nine points forms 
a square whose sides are parallel to the horizontal and vertical axes.</p>
<p><font color="#FF0000"><b>The real and imaginary parts of the spectrum</b></font></p>
<p>There isn't a lot that I can tell you about what to expect regarding the real 
and imaginary parts of this spectrum, other than that they should exhibit the 
same <a href="#Symmetry">symmetry</a> and asymmetry conditions that I described earlier for the real and 
imaginary parts in general.&nbsp; These requirements appear to be satisfied by 
the real part at the top center of Figure 7 and the imaginary part at the 
bottom center of Figure 7.</p>
<p>Otherwise, the shape of the real and imaginary wavenumber spectra will depend 
on the location of the box in space and the size and orientation of the box.</p>
<p><font color="#FF0000"><b>A different plotting color scheme</b></font></p>
<p>Note that the plotting color scheme that I used for Figure 7 is different 
from any of the plots previously shown in this lesson.&nbsp; <br>
This color scheme is what I refer to as the <i>Color Contour</i> scheme in the 
lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a>.</p>
<p>This scheme quantizes the range from the lowest to the highest elevation into 
23 levels, coloring the lowest elevation black, the highest elevation white, and 
assigning very specific colors to the 21 levels in between.&nbsp; The colors and the levels that they represent are shown in the calibration scales under the 
plots in Figure 7.&nbsp; The lowest elevation is on the left end of the 
calibration scale.&nbsp; The highest elevation is on the right end of the 
calibration scale.</p>
<p><font color="#FF0000"><b>The amplitude spectrum</b></font></p>
<p>As before, the wavenumber amplitude spectrum with the origin in the upper 
left corner is shown in the upper right image in Figure 7.&nbsp; The amplitude 
spectrum with the origin shifted to the center is shown in the lower right image 
in Figure 7.</p>
<p>If you were to use the calibration scale to convert the colors along the 
horizontal and vertical axes in the lower right image into numeric values, you 
would find that they approximate a rectified sin(x)/x shape as expected.</p>
<p><font color="#FF0000"><b>The output surface</b></font></p>
<p>The output surface produced by performing an inverse Fourier transform on the 
complex wavenumber spectrum is shown in the lower left image in Figure 7.&nbsp; 
This surface appears to match the input surface shown in the upper left image in 
Figure 7.</p>
<p><font color="#FF0000"><b>The overall results</b></font></p>
<p>The numeric output for this case isn't very useful because none of the 
samples for which numeric data is provided fall within the square.&nbsp; 
However, because the real and imaginary parts exhibit the correct 
<a href="#Symmetry">symmetry</a>, the 
shape of the amplitude spectrum is generally what we expect, and the output from 
the inverse Fourier transform appears to match the original input causes us to 
conclude that the program is working properly in this case.</p>
<p><font color="#FF0000"><b>For switchCase = 3</b></font></p>
<p>This case places a raised box at the top near the origin in the space domain, 
but the box is not on the diagonal as it was in case 2.</p>
<blockquote>
	<p><i>(See the upper left image in Figure 8 for the new location of the 
	box.)</i></p>
</blockquote>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491e1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491e2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491e3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491e4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491e5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491e6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 8</p>
<p><font color="#FF0000"><b>Amplitude spectrum should not change</b></font></p>
<p>As long as the size and the orientation of the box doesn't change, the 
wavenumber amplitude spectrum should be the same as case 2 regardless of the location of 
the box in space.&nbsp; Since the size and orientation of this box is the same 
as in case 2, the amplitude spectrum for this case should be the same as for 
case 2.</p>
<p><font color="#FF0000"><b>The real and imaginary parts of the spectrum may 
change</b></font></p>
<p>However, the real and imaginary parts <i>(or the phase)</i> change as the 
location of the box changes relative to the origin in space.</p>
<p><font color="#FF0000"><b>A hypothetical example</b></font></p>
<p>The purpose of this case is to illustrate a hypothetical example.&nbsp; If two different photographic 
images contain a picture of the same object in the same size and the same 
orientation in space, that object will contribute the same values to the amplitude 
spectrum of both images regardless of where the object is located in the 
different images.</p>
<p>For example, assume that a photographic image includes a picture of a vase.&nbsp; 
Assume that the original image is cropped twice along two different borders 
producing two new images.&nbsp; 
Assume that both of the new images contain the picture of the vase, but in 
different locations.&nbsp; That vase will contribute the same values to the 
amplitude spectra of the two images regardless of the location of the vase in 
each of the images.&nbsp; This knowledge will be useful to us in future lessons 
when we begin using 2D Fourier transforms to process photographic images.</p>
<p><font color="#FF0000"><b>Amplitude spectrum is the same</b></font></p>
<p>If you compare Figure 8 with Figure 7, you will see that the amplitude 
spectrum is the same for both surfaces despite the fact that the box is in a 
different location in each of the two surfaces.&nbsp; However, the real and imaginary 
parts of the spectrum in Figure 8 are considerably different from the real 
and imaginary parts of the spectrum in Figure 7.</p>
<p>The code that was used to create the surface for this case is 
straightforward.&nbsp; You can view that code in Listing 22 near the end of the 
lesson.</p>
<p><font color="#FF0000"><b>For switchCase = 4</b></font></p>
<p>This case draws a short line containing eight points along the diagonal from 
upper left to lower right in the space domain.&nbsp; You can view this surface 
in the upper left image in Figure 9.&nbsp; You can view the code that generated 
this surface in Listing 22 
near the end of the lesson.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491f1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491f2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491f3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491f4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491f5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491f6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 9</p>
<p><font color="#FF0000"><b>Another example of sin(x)/x</b></font></p>
<p>On the basis of prior experience, we would expect the wavenumber amplitude spectrum, <i>(when viewed along any 
line in wavenumber space parallel to the line in space),</i> to have a 
rectified sin(x)/x shape.&nbsp; We would expect the peak of that shape to be 
centered on the origin in wavenumber space.&nbsp; We would expect the width of 
the peak in wavenumber space to be inversely proportional to the length of the 
line in space.</p>
<p>We would expect the amplitude spectrum when viewed along any line in 
wavenumber space perpendicular to the line in space to have a constant value.</p>
<p><font color="#FF0000"><b>Our expectations are borne out</b></font></p>
<p>The shape of the amplitude spectrum shown in the lower right image in Figure 
9 agrees with our expectations.&nbsp; Although not shown here, if we were to make the line of points 
longer, the width of the peak in the rectified sin(x)/x would become narrower.&nbsp; 
If we were to make the line of points shorter, the peak would become wider, as 
we will demonstrate in case 5.</p>
<p>Our expectations regarding <a href="#Symmetry">symmetry</a> and asymmetry for the real and imaginary 
parts shown in the center images of Figure 9 are borne out.&nbsp; The real part is at 
the top center and the imaginary part is at the bottom center.</p>
<p>The output from the inverse Fourier transform shown in the bottom left of 
Figure 9 matches the original space domain surface in the top left of Figure 9.</p>
<p><font color="#FF0000"><b>For switchCase = 5</b></font></p>
<p>This case draws a short line consisting of only four points perpendicular to the diagonal from upper left to lower right.&nbsp; 
This line of points is perpendicular to the direction of the line of points in 
case 4.</p>
<p>You can view the surface for this case in the upper left image of Figure 10.&nbsp; 
You can view the code that generated this surface in Listing 22 near the end of 
the lesson.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491g1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491g2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491g3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491g4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491g5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491g6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 10</p>
<p><font color="#FF0000"><b>Rotated by ninety degrees</b></font></p>
<p>If you compare Figure 10 with Figure 9, you will see that the spectral result is 
rotated ninety degrees relative to that shown for case 4 where the line was along the diagonal.&nbsp; 
In other words, rotating the line of points by ninety degrees also rotated the 
structure in the wavenumber spectrum by ninety degrees.</p>
<p><font color="#FF0000"><b>A wider peak</b></font></p>
<p>In addition, the line of points for case 5 is shorter than the line of points 
for case 4 resulting in a wider peak in the rectified sin(x)/x shape for case 5.</p>
<p><font color="#FF0000"><b>The real and imaginary parts</b></font></p>
<p>While the real and imaginary parts of the spectrum shown in the center of 
Figure 10 are considerably different from anything that we have seen prior to 
this, they still satisfy the <a href="#Symmetry">symmetry</a> and asymmetry conditions that we expect 
for the real and imaginary parts.</p>
<p><font color="#FF0000"><b>The final output matches the input</b></font></p>
<p>The output from the inverse Fourier transform in the bottom left image in 
Figure 10 matches the input surface in the top left image in Figure 10.</p>
<p>All of this matches our expectations for this case.</p>
<p><font color="#FF0000"><b>For switchCase = 6</b></font></p>
<p>This case is considerably more complicated than the previous cases.&nbsp; You 
can view the surface for this case in the upper left image in Figure 11.&nbsp; 
You can view the code that generated this surface in Listing 22 near the end of 
the lesson.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491h1.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491h2.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491h3.jpg" width="132" height="169"></td>
	</tr>
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491h4.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491h5.jpg" width="132" height="169"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491h6.jpg" width="132" height="169"></td>
	</tr>

</table>

</div>

<p align="center">Figure 11</p>
<p><font color="#FF0000"><b>Many weighted lines of points</b></font></p>
<p>This case draws horizontal lines, vertical lines, and lines on both 
diagonals.&nbsp; Each individual point on each line is given a value of either 
+1 or -1.&nbsp; The weights of the individual points are adjusted so that the 
sum of all the weights is 0.&nbsp; The weight at the point where the lines 
intersect is also 0.</p>
<p><font color="#FF0000"><b>Black is -1, white is +1</b></font></p>
<p>The small black squares in the upper left image in Figure 11 represent points 
with a weight of -1.&nbsp; The small white squares represent points with a 
weight of +1.&nbsp; The green background color represents a value of 0.</p>
<p><font color="#FF0000"><b>Symmetries on four different axes</b></font></p>
<p>The wavenumber amplitude spectrum is shown in the bottom right image in 
Figure 11.&nbsp; As you can see from that image, performing a 2D Fourier 
transform 
on this surface produces a wavenumber amplitude spectrum that is symmetrical 
along lines drawn at 0, 45, 90, and 135 degrees to the horizontal.&nbsp; There 
is a line of symmetry in the amplitude spectrum for every line of points on the 
space domain surface.</p>
<p><font color="#FF0000"><b>Must be zero at the wavenumber origin</b></font></p>
<p>Because the sum of all the points is 0, the value of the wavenumber 
spectrum at the origin must also be zero.&nbsp; This is indicated by the black square 
at the origin in the lower right image.</p>
<p><font color="#FF0000"><b>Peaks at the folding wave numbers</b></font></p>
<p>This amplitude spectrum has major peaks at the folding wave number on each of 
the 45-degree axes.&nbsp; In addition, there are minor peaks at various other 
points in the spectrum.</p>
<p><font color="#FF0000"><b>The real and imaginary parts</b></font></p>
<p>As expected, the real and imaginary parts of the spectrum, shown in the 
center of Figure 11 exhibit the required <a href="#Symmetry">symmetry</a> and asymmetry that I discussed 
earlier.</p>
<p><font color="#FF0000"><b>The final output</b></font></p>
<p>The output produced by performing an inverse Fourier transform on the complex 
wavenumber spectrum is shown in the lower left image in Figure 11.&nbsp; This 
image matches the input surface shown in the top left image in Figure 11.</p>
<p><font color="#FF0000"><b>For switchCase = 7</b></font></p>
<p>Now we are going to make a major change in direction.&nbsp; All of the 
surfaces from cases 0 through 6 consisted of a few individual points located 
in specific geometries in the space domain.&nbsp; All of the remaining points on 
the surface had a value of zero.&nbsp; This resulted in continuous <i>(but 
sampled)</i> surfaces in 
the wavenumber domain.</p>
<p>Now we are going to generate continuous <i>(but sampled) </i>surfaces in the space domain.&nbsp; We will generate these surfaces as 
sinusoidal surfaces <i>(similar to a sheet of corrugated sheet metal)</i> or the 
sums of sinusoidal surfaces.</p>
<p>Performing Fourier transforms on these surfaces will 
produce amplitude spectra consisting of a few non-zero points in wavenumber 
space with the remaining points in the spectrum having values near zero.</p>
<p><font color="#FF0000"><b>Need to change the surface plotting scale</b></font></p>
<p>In order to make these amplitude spectra easier to view, I have modified the 
program to cause the square representing each point in the amplitude 
spectrum to be five pixels on each side instead of three pixels on each side.&nbsp; 
To keep the overall size of the images under control, I reduced the width and 
the height of the surfaces from 41 points to 23 points.</p>
<p><font color="#FF0000"><b>Display fewer results</b></font></p>
<p>I suspect that you have seen all the real parts, imaginary parts, and 
unshifted amplitude spectra that you want to see.&nbsp; Therefore, at this 
point, I will begin displaying only the input surface, the amplitude spectrum, 
and the output surface that results from performing an inverse Fourier transform 
on the complex spectrum.</p>
<p><font color="#FF0000"><b>A zero frequency sine wave</b></font></p>
<p>The first example in this category is shown in Figure 12.&nbsp; The input 
surface for this example is a sinusoidal wave with a frequency of zero.&nbsp; This 
results in a perfectly flat surface in the space domain as shown in the leftmost image in 
Figure 12.&nbsp; 
This surface is perfectly flat and featureless.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491i1.jpg" width="124" height="172"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491i2.jpg" width="124" height="172"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491i3.jpg" width="124" height="172"></td>
	</tr>

</table>

</div>

<p align="center">Figure 12</p>
<p><font color="#FF0000"><b>The code for this case</b></font></p>
<p>The code that was used to generate this surface is shown in Listing 18.&nbsp; 
For the case of a sinusoidal wave with zero frequency, every point on the surface has 
a value of 1.0.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case 7:
        for(int row = 0; row &lt; rows; row++){
          for(int col = 0; col &lt; cols; col++){
            spatialData[row][col] = 1.0;
          }//end inner loop
        }//end outer loop
      break;<br><br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>A single point at the origin</b></font></p>
<p>As shown by the center image in Figure 12, the Fourier transform of this 
surface produces a single point at the origin in wavenumber space.&nbsp; This is 
exactly what we would expect.</p>
<p><font color="#FF0000"><b>The inverse transform output is ugly</b></font></p>
<p>The result of performing an inverse Fourier transform on the complex spectrum 
is shown in the rightmost image in Figure 12.&nbsp; As was the case earlier in 
Figure 6, the ugliness of this plot is an artifact of the 3D plotting scheme 
implemented by the class named <b>ImgMod29</b>.&nbsp; The <a href="#artifact">
explanation</a> that I gave there applies here also.</p>
<p><font color="#ff0000"><b>A very small error</b></font></p>
<p>Once again, the total error is very small.&nbsp; The numeric output shows that the 
final output surface matches the input surface to within an error that is less 
than about one part in ten to the thirteenth power.&nbsp; Thus, the program produces 
the expected results for this test case.</p>
<p><font color="#FF0000"><b>For switchCase = 8</b></font></p>
<p>This case draws a sinusoidal surface along the horizontal axis with one sample per cycle.</p>
<blockquote>
	<p><i>(This 
surface is under sampled by a factor of two under the commonly held belief that 
there should be at least two samples per cycle of the highest frequency 
component in the surface.)</i></p>
</blockquote>
<p>Thus, it is impossible to distinguish this 
surface from a surface consisting of a sinusoid with a frequency of zero.</p>
<p>The code that was used to produce this surface is shown in Listing 19.&nbsp; 
This code is typical of the code that I will be using to produce the remaining 
surfaces in this lesson.&nbsp; This code is straightforward and shouldn't 
require further explanation.&nbsp; </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      case 8:
        for(int row = 0; row &lt; rows; row++){
          for(int col = 0; col &lt; cols; col++){
            spatialData[row][col] = 
                                 cos(2*PI*col/1);
          }//end inner loop
        }//end outer loop
      break;<br><br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The graphic output</b></font></p>
<p>The Fourier transform of this surface produces a single peak at the origin in 
the wavenumber spectrum just like in Figure 12.&nbsp; I didn't provide a display of the graphic output 
for this case because it looks just like the graphic output shown for the zero 
frequency sinusoid in Figure 12.</p>
<p><font color="#FF0000"><b>For switchCase = 9</b></font></p>
<p>This case draws a sinusoidal surface along the horizontal axis with two 
samples per cycle as shown in the leftmost image in Figure 13.&nbsp; This is the 
Nyquist folding wavenumber.</p>
<p><font color="#FF0000"><b>The wavenumber spectrum</b></font></p>
<p>The center image in Figure 13 shows the wavenumber amplitude spectrum for 
this surface.&nbsp; The wavenumber spectrum has white peak values at the 
positive and negative folding wave numbers.&nbsp; The colors in between these 
two peaks are green, blue, and gray indicating very low values.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491j1.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491j2.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491j3.jpg" width="124" height="173"></td>
	</tr>

</table>

</div>

<p align="center">Figure 13</p>
<p><font color="#FF0000"><b>The inverse Fourier transform output</b></font></p>
<p>The output from the inverse Fourier transform performed on the complex 
wavenumber spectrum for this case is shown in the rightmost image in Figure 13.&nbsp; 
The output is a good match for the input.</p>
<p>You can view the code that was used to create this surface in Listing 22 near 
the end of the lesson.</p>
<p><font color="#FF0000"><b>For switchCase = 10</b></font></p>
<p>This case draws a sinusoidal surface along the vertical axis with two samples 
per cycle.&nbsp; Again, this is the Nyquist folding wave number but the sinusoid 
appears along the vertical axis instead of appearing along the horizontal axis.&nbsp; 
If you run this case and view the results, you will see that it replicates the 
results from case 9 except that everything is rotated by ninety degrees in both 
the space domain and the wavenumber domain.</p>
<p><font color="#FF0000"><b>For switchCase = 11</b></font></p>
<p>This case draws a sinusoidal surface along the horizontal axis with eight 
samples per cycle as shown in the leftmost image of Figure 14.&nbsp; </p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491k1.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491k2.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491k3.jpg" width="124" height="173"></td>
	</tr>

</table>

</div>

<p align="center">Figure 14</p>
<p><font color="#FF0000"><b>The wavenumber spectrum</b></font></p>
<p>Performing a forward Fourier transform on this surface produces symmetrical 
peaks on the horizontal axis on either side of the wavenumber origin.&nbsp; The 
two peaks are indicated by the small white and red squares on the horizontal 
axis in the center image in Figure 14.&nbsp; </p>
<blockquote>
	<p><i>(Recall that for the plotting format used in Figure 14, the color 
	white is reserved for the single point with the highest elevation.&nbsp; The 
	difference in an elevation colored white and an elevation colored red for 
	this plotting format might be 
	as small as one part in ten to the fourteenth or fifteenth power.&nbsp; As a practical 
	matter, <a name="red_and_white">red and white</a> indicate the same elevation for this plotting format.)</i></p>
</blockquote>
<p>For a sinusoidal surface with eight samples per cycle, we would expect the 
peaks to occur in the wavenumber spectrum about one-fourth of the distance from the origin 
to the folding wavenumber.&nbsp; Figure 14 
meets that expectation.</p>
<p>The peaks are surrounded on both sides by blue and aqua colors, indicating 
very low values.</p>
<p><font color="#FF0000"><b>The inverse Fourier transform output</b></font></p>
<p>The output from the inverse Fourier transformed performed on the complex 
spectrum is shown in the rightmost image in Figure 14.&nbsp; This output 
compares very favorably with the input surface shown in the leftmost image.&nbsp; 
The difference between the two is that the input has white vertical bands whereas 
the output has red vertical bands <i>(with a single white spot).</i>&nbsp; The 
above <a href="#red_and_white">explanation</a> of white versus red applies here also.</p>
<p>You can view the code that created this surface in Listing 22 near the end of 
the lesson.</p>
<p><font color="#FF0000"><b>For switchCase = 12</b></font>&nbsp; </p>
<p>This case draws a sinusoidal surface on the horizontal axis with three 
samples per cycle plus a sinusoidal surface on the vertical axis with eight 
samples per cycle as shown by the leftmost image in Figure 15.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491m1.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491m2.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491m3.jpg" width="124" height="173"></td>
	</tr>

</table>

</div>

<p align="center">Figure 15</p>
<p><font color="#FF0000"><b>The wavenumber spectrum</b></font></p>
<p>Performing a forward Fourier transform produces symmetrical peaks on the 
horizontal and vertical axes on all four sides of the wave number origin.&nbsp; 
These peaks are indicated by the red and white squares in the center image in 
Figure 15.</p>
<blockquote>
	<p><i>(See the earlier discussion regarding the difference in elevation 
	indicated by <a href="#red_and_white">red and white</a> for this plotting format.)</i></p>
</blockquote>
<p>The peaks on the vertical axis should be about one-fourth of the way between 
the origin and the folding wavenumber.&nbsp; This appears to be the case.&nbsp; The peaks 
on the horizontal axis should be about two-thirds of the way between the origin 
and the folding wavenumber, which they also appear to be.</p>
<p><font color="#FF0000"><b>Inverse Fourier transform output</b></font></p>
<p>The output produced by performing an inverse Fourier transform on the complex 
spectrum is shown in the rightmost image in Figure 15.&nbsp; Taking the 
<a href="#red_and_white">red 
versus white</a> issue into account, this output compares favorably with the input 
surface shown in the leftmost image in Figure 15.</p>
<p>You can view the code that created this surface in Listing 22 near the end of 
the lesson.</p>
<p><font color="#FF0000"><b>For switchCase = 13</b></font></p>
<p>This case draws a sinusoidal surface at an angle of approximately 45 degrees 
relative to the horizontal as shown in the leftmost image in Figure 16.&nbsp; 
This sinusoid has approximately eight samples per cycle.</p>
<div align="center">
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<p align="center">
		<img border="0" src="java1491n1.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491n2.jpg" width="124" height="173"></td>
		<td>
		<p align="center">
		<img border="0" src="java1491n3.jpg" width="124" height="173"></td>
	</tr>

</table>

</div>

<p align="center">Figure 16</p>
<p><font color="#FF0000"><b>The wavenumber spectrum</b></font></p>
<p>Performing a forward Fourier transform on this surface produces a pair of 
peaks in the wavenumber spectrum that are symmetrical about the origin at 
approximately 45 degrees relative to the horizontal axis.&nbsp; These peaks are 
indicated by the red and white squares in the center image in Figure 16.</p>
<p><font color="#FF0000"><b>The inverse Fourier transform output</b></font></p>
<p>The output produced by performing an inverse Fourier transform on the complex 
wavenumber spectrum is shown in the rightmost image in Figure 16.&nbsp; This 
output compares favorably with the input surface shown in the leftmost image in 
Figure 16.</p>
<p>You can view the code that created this surface in Listing 22 near the end of 
the lesson.</p>
<p><font color="#FF0000"><b>The end of the getSpatialData method</b></font></p>
<p>Listing 20 shows the end of the method named <b>getSpatialData</b> and the 
end of the class named <b>ImgMod31</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      default:
        System.out.println("Case must be " +
                  "between 0 and 13 inclusive.");
        System.out.println(
                         "Terminating program.");
        System.exit(0);
    }//end  switch statement
    
    return spatialData;
  }//end getSpatialData
}//end class ImgMod31<br><br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>A default case is provided in the <b>switch</b> statement to deal with the 
possibility that the user may specify a case that is not included in the 
allowable limits of 0 through 13 inclusive.</p>
<p>The method ends by returning a reference to the array object containing the 
3D surface that was created by the selected case in the <b>switch</b> 
statement.</p>
<h2 align="center"><a name="Run_the_Program">Run the Program</a></h2><p>I 
encourage you to copy, compile, and run the programs that you will find in 
Listing 21 and Listing 22 near the end of the lesson.</p>
<blockquote>
	<p><i>(You will also need to go to the lesson entitled </i>
	<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D Surfaces 
using Java</a><i> and get a copy of the source code for the program named 
	ImgMod29.) </i></p>
</blockquote>
<p>Modify the programs and experiment with 
them in order to learn as much as you can about 2D Fourier transforms.</p>
<p>Create some different test cases and work with them until you understand why 
they produce the results that they do.</p><center>    
<h2> <a name="Summary"></a>Summary</h2></center>I began Part 1 of this lesson by explaining how the 
space domain and the wavenumber domain in two-dimensional analysis are analogous 
to the time domain and the frequency domain in one-dimensional analysis.<p>Then 
I introduced you to some practical examples showing how 2D Fourier transforms 
and wavenumber spectra can be useful in solving engineering problems involving 
antenna arrays.</p>
<p>In Part 2, I provided and explained a class that can be used to perform 
forward and inverse 2D Fourier transforms, and can also be used to shift the 
wavenumber origin from the upper left to the center for a more pleasing plot of 
the wavenumber spectral data.</p>
<p>Finally, I provided and explained a program that is used to:</p>
<ul>
	<li>Test the forward and inverse 2D Fourier transforms to confirm that the 
	code is correct and that the transformations behave as they should</li>
	<li>Produce wavenumber spectra for simple surfaces to help the student gain 
	a feel for the relationships that exist between the space domain and the 
	wavenumber domain</li>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2><p>
I will explain general purpose 2D convolution and will explain and demonstrate 
the relationships that exist between 2D Fourier transforms and 2D convolution in 
the next lesson in this series.</p>
<h2 align="center"><a name="Complete_Program_Listing">Complete Program Listings</a></h2><p>
Complete listings of the 
classes presented in this lesson are provided in Listing 21 and Listing 22 
below.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
<tbody><tr><td><pre>
/*File ImgMod30.java.java
Copyright 2005, R.G.Baldwin

The purpose of this program is to provide 2D
Fourier Transform capability to be used for image
processing and other purposes.&nbsp; The class
provides three static methods:

xform2D: Performs a forward 2D Fourier transform
 on a surface described by a 2D array of double
&nbsp;values in the space domain to produce a spectrum
 in the wavenumber domain.&nbsp; The method returns
 the real part, the imaginary part, and the
 amplitude spectrum, each in its own 2D array of
 double values.

inverseXform2D:&nbsp; Performs an inverse 2D Fourier
 transform from the wavenumber domain into the
 space domain using the real and imaginary parts
 of the wavenumber spectrum as input.&nbsp; Returns
 the surface in the space domain in a 2D array of
 double values.

shiftOrigin:&nbsp; The wavenumber spectrum produced
 by xform2D has its origin in the upper left
 corner with the Nyquist folding wave numbers
 near the center.&nbsp; This is not a very suitable
 format for visual analysis.&nbsp; This method
 rearranges the data to place the origin at the
 center with the Nyquist folding wave numbers
 along the edges.

Tested using J2SE 5.0 and WinXP
************************************************/
import static java.lang.Math.*;

class ImgMod30{
&nbsp;
&nbsp; //This method computes a forward 2D Fourier
&nbsp; // transform from the space domain into the
&nbsp; // wavenumber domain.&nbsp; The number of points
&nbsp; // produced for the wavenumber domain matches
&nbsp; // the number of points received for the space
&nbsp; // domain in both dimensions.&nbsp; Note that the
&nbsp; // input data must be purely real.&nbsp; In other
&nbsp; // words, the program assumes that there are
&nbsp; // no imaginary values in the space domain.
&nbsp; // Therefore, it is not a general purpose 2D
&nbsp; // complex-to-complex transform.
&nbsp; static void xform2D(double[][] inputData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] realOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imagOut,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] amplitudeOut){

&nbsp;&nbsp;&nbsp; int height = inputData.length;
&nbsp;&nbsp;&nbsp; int width = inputData[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("height = " + height);
&nbsp;&nbsp;&nbsp; System.out.println("width = " + width);

&nbsp;&nbsp;&nbsp; //Two outer loops iterate on output data.
&nbsp;&nbsp;&nbsp; for(int yWave = 0;yWave &lt; height;yWave++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xWave = 0;xWave &lt; width;xWave++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Two inner loops iterate on input data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ySpace = 0;ySpace &lt; height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ySpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xSpace = 0;xSpace &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xSpace++){
//Compute real, imag, and ampltude. Note that it
// was necessary to sacrifice indentation to
// force&nbsp; these very long equations to be
// compatible with this narrow publication format
// and still be somewhat readable.
realOut[yWave][xWave] +=
&nbsp;(inputData[ySpace][xSpace]*cos(2*PI*((1.0*
 xWave*xSpace/width)+(1.0*yWave*ySpace/height))))
 /sqrt(width*height);

imagOut[yWave][xWave ] -=
&nbsp;(inputData[ySpace][xSpace]*sin(2*PI*((1.0*xWave*
&nbsp; xSpace/width) + (1.0*yWave*ySpace/height))))
&nbsp; /sqrt(width*height);
&nbsp;
amplitudeOut[yWave][xWave] =
 sqrt(
&nbsp; realOut[yWave][xWave] * realOut[yWave][xWave] +
&nbsp; imagOut[yWave][xWave] * imagOut[yWave][xWave]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xSpace loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end ySpace loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xWave loop
&nbsp;&nbsp;&nbsp; }//end yWave loop
&nbsp; }//end xform2D method
&nbsp; //-------------------------------------------//
&nbsp;&nbsp;&nbsp;
&nbsp; //This method computes an inverse 2D Fourier
&nbsp; // transform from the wavenumber domain into
&nbsp; // the space domain.&nbsp; The number of points
&nbsp; // produced for the space domain matches
&nbsp; // the number of points received for the wave-
&nbsp; // number domain in both dimensions.&nbsp; Note that
&nbsp; // this method assumes that the inverse
&nbsp; // transform will produce purely real values in
&nbsp; // the space domain.&nbsp; Therefore, in the
&nbsp; // interest of computational efficiency, it
&nbsp; // does not compute the imaginary output
&nbsp; // values.&nbsp; Therefore, it is not a general
&nbsp; // purpose 2D complex-to-complex transform. For
&nbsp; // correct results, the input complex data must
&nbsp; // match that obtained by performing a forward
&nbsp; // transform on purely real data in the space
&nbsp; // domain.

&nbsp; static void inverseXform2D(double[][] real,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] imag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[][] dataOut){

&nbsp;&nbsp;&nbsp; int height = real.length;
&nbsp;&nbsp;&nbsp; int width = real[0].length;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("height = " + height);
&nbsp;&nbsp;&nbsp; System.out.println("width = " + width);

&nbsp;&nbsp;&nbsp; //Two outer loops iterate on output data.
&nbsp;&nbsp;&nbsp; for(int ySpace = 0;ySpace &lt; height;ySpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xSpace = 0;xSpace &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xSpace++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Two inner loops iterate on input data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int yWave = 0;yWave &lt; height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yWave++){

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int xWave = 0;xWave &lt; width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xWave++){
//Compute real output data. Note that it was
// necessary to sacrifice indentation to force
// this very long equation to be compatible with
// this narrow publication format and still be
// somewhat readable.
dataOut[ySpace][xSpace] +=
&nbsp;(real[yWave][xWave]*cos(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))) -
&nbsp;imag[yWave][xWave]*sin(2*PI*((1.0 * xSpace*
 xWave/width) + (1.0*ySpace*yWave/height))))
 /sqrt(width*height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xWave loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end yWave loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end xSpace loop
&nbsp;&nbsp;&nbsp; }//end ySpace loop
&nbsp; }//end inverseXform2D method
&nbsp; //-------------------------------------------//
&nbsp;
&nbsp; //Method to shift the wavenumber origin and
&nbsp; // place it at the center for a more visually
&nbsp; // pleasing display.&nbsp; Must be applied
&nbsp; // separately to the real part, the imaginary
&nbsp; // part, and the amplitude spectrum for a wave-
&nbsp; // number spectrum.
&nbsp; static double[][] shiftOrigin(double[][] data){
&nbsp;&nbsp;&nbsp; int numberOfRows = data.length;
&nbsp;&nbsp;&nbsp; int numberOfCols = data[0].length;
&nbsp;&nbsp;&nbsp; int newRows;
&nbsp;&nbsp;&nbsp; int newCols;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] output =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[numberOfRows][numberOfCols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Must treat the data differently when the
&nbsp;&nbsp;&nbsp; // dimension is odd than when it is even.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(numberOfRows%2 != 0){//odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRows = numberOfRows +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numberOfRows + 1)/2;
&nbsp;&nbsp;&nbsp; }else{//even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRows = numberOfRows + numberOfRows/2;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(numberOfCols%2 != 0){//odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newCols = numberOfCols +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (numberOfCols + 1)/2;
&nbsp;&nbsp;&nbsp; }else{//even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newCols = numberOfCols + numberOfCols/2;
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create a temporary working array.
&nbsp;&nbsp;&nbsp; double[][] temp =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[newRows][newCols];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Copy input data into the working array.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] = data[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Do the horizontal shift first
&nbsp;&nbsp;&nbsp; if(numberOfCols%2 != 0){//shift for odd

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide leftmost (numberOfCols+1)/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the right by numberOfCols columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; (numberOfCols+1)/2;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back to the left by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (numberOfCols+1)/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col+(numberOfCols + 1)/2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else{//shift for even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide leftmost (numberOfCols/2) columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the right by numberOfCols columns.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols/2;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back to the left by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // numberOfCols/2 columns
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col + numberOfCols/2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp; }//end else

&nbsp;&nbsp;&nbsp; //Now do the vertical shift
&nbsp;&nbsp;&nbsp; if(numberOfRows%2 != 0){//shift for odd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide topmost (numberOfRows+1)/2 rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // down by numberOfRows rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; (numberOfRows+1)/2;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back up by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (numberOfRows+1)/2 rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row+(numberOfRows + 1)/2][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }else{//shift for even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Slide topmost (numberOfRows/2) rows down
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by numberOfRows rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows/2;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now slide everything back up by
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // numberOfRows/2 rows.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[row + numberOfRows/2][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//row loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Shifting of the origin is complete.&nbsp; Copy
&nbsp;&nbsp;&nbsp; // the rearranged data from temp to output
&nbsp;&nbsp;&nbsp; // array.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; numberOfRows;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; numberOfCols;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[row][col] = temp[row][col];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col loop
&nbsp;&nbsp;&nbsp; }//row loop

&nbsp;&nbsp;&nbsp; return output;
&nbsp; }//end shiftOrigin method

}//end class ImgMod30

<b>Listing 21</b></pre></td></tr></tbody></table>
<p>&nbsp;</p>

<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
<tbody><tr><td><pre>
/*File ImgMod31.java.java
Copyright 2005, R.G.Baldwin

The purpose of this program is to exercise and
test the 2D Fourier Transform methods and the
axis shifting method provided by the class named
ImgMod30.

The main method in this class reads a command-
line parameter and uses it to select a specific
case involving a particular kind of input data
in the space domain.&nbsp; The program then performs
a 2D Fourier transform on that data followed by
an inverse 2D Fourier transform.

There are 14 cases built into the program with
case numbers ranging from 0 to 13 inclusive.
Each of the cases is designed such that the
results should be known in advance by a person
familiar with 2D Fourier analysis and the wave-
number domain.&nbsp; The cases are also designed to
illustrate the impact of various space-domain
characteristics on the wavenumber spectrum.
This information will be useful later when
analyzing the results of performing 2D
transforms on photographic images and other
images as well.

Each time the program is run, it produces a stack
of six output images in the upper left corner of
the screen.&nbsp; The type of each image is listed
below.&nbsp; This list is in top-to-bottom order.&nbsp; To
view the images further down in the stack, you
must&nbsp; physically move those on top to get them
out of the way.

The top-to-bottom order of the output images is
as follows:

1. Space-domain output of inverse Fourier
transform.&nbsp; Compare with original input in 6
below.
2. Amplitude spectrum in wavenumber domain with
shifted origin.&nbsp; Compare with 5 below.
3. Imaginary wavenumber spectrum with shifted
origin.
4. Real wavenumber spectrum with shifted
origin.
5. Amplitude spectrum in wavenumber domain
without shifted origin.&nbsp; Compare with 2 above.
6. Space-domain input data.&nbsp; Compare with 1
above.

In addition, the program produces some numeric
output on the command-line screen that may be
useful in confirming the validity of the inverse
transform.&nbsp; The following is an example:

height = 41
width = 41
height = 41
width = 41
2.0 1.9999999999999916
0.5000000000000002 0.49999999999999845
0.49999999999999956 0.4999999999999923
1.7071067811865475 1.7071067811865526
0.2071067811865478 0.20710678118654233
0.20710678118654713 0.20710678118655435
1.0 1.0000000000000064
-0.4999999999999997 -0.49999999999999484
-0.5000000000000003 -0.4999999999999965

The first two lines above indicate the size of
the spatial surface for the forward transform.
The second two lines indicate the size of the
wavenumber surface for the inverse transform.

The remaining nine lines indicate something
about the quality of the inverse transform in
terms of its ability to replicate the original
spatial surface.&nbsp; These lines also indicate
something about the correctness or lack thereof
of the overall scaling from original input to
final output.&nbsp; Each line contains a pair of
values.&nbsp; The first value is from the original
spatial surface.&nbsp; The second value is from the
spatial surface produced by performing an inverse
transform on the wavenumber spectrum.&nbsp; The two
values in each pair of values should match.&nbsp; If
they match, this indicates the probability of a
valid result.&nbsp; Note however that this is
a very small sampling of the values that make
up the original and replicated spatial data and
problems could arise in areas that are not
included in this small sample.&nbsp; The match is very
good in the example shown above.&nbsp; This example
is from Case #12.

Usage: java ImgMod31 CaseNumber DisplayType
CaseNumber from 0 to 13 inclusive.

If a case number is not provided, Case #2 will be
run by default.&nbsp; If a display type is not
provided, display type 1 will be used by default.

A description of each case is provided by the
comments in this program.

See ImgMod29 for a definition of DisplayType,
which can have a value of 0, 1, or 2.

You can terminate the program by clicking on the
close button on any of the display frames
produced by the program.

Tested using J2SE 5.0 and WinXP
************************************************/
import static java.lang.Math.*;

class ImgMod31{
&nbsp;
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Get input parameters to select the case to
&nbsp;&nbsp;&nbsp; // be run and the displayType.&nbsp; See ImgMod29
&nbsp;&nbsp;&nbsp; // for a description of displayType.&nbsp; Use
&nbsp;&nbsp;&nbsp; // default case and displayType if the user
&nbsp;&nbsp;&nbsp; // fails to provide that information.
&nbsp;&nbsp;&nbsp; // If the user provides a non-numeric input
&nbsp;&nbsp;&nbsp; // parameter, an exception will be thrown.
&nbsp;&nbsp;&nbsp; int switchCase = 2;//default
&nbsp;&nbsp;&nbsp; int displayType = 1;//default
&nbsp;&nbsp;&nbsp; if(args.length == 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switchCase = Integer.parseInt(args[0]);
&nbsp;&nbsp;&nbsp; }else if(args.length == 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switchCase = Integer.parseInt(args[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType = Integer.parseInt(args[1]);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Usage: java ImgMod31 "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "CaseNumber DisplayType");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CaseNumber from 0 to 13 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DisplayType from 0 to 2 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Running case "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + switchCase + " by default.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Running DisplayType "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + displayType + " by default.");
&nbsp;&nbsp;&nbsp; }//end else
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create the array of test data.
&nbsp;&nbsp;&nbsp; int rows = 41;
&nbsp;&nbsp;&nbsp; int cols = 41;

&nbsp;&nbsp;&nbsp; //Get a test surface in the space domain.
&nbsp;&nbsp;&nbsp; double[][] spatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpatialData(switchCase,rows,cols);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the spatial data.&nbsp; Don't display
&nbsp;&nbsp;&nbsp; // the axes.
&nbsp;&nbsp;&nbsp; new ImgMod29(spatialData,3,false,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);

&nbsp;&nbsp;&nbsp; //Perform the forward transform from the
&nbsp;&nbsp;&nbsp; // space domain into the wavenumber domain.
&nbsp;&nbsp;&nbsp; // First prepare some array objects to
&nbsp;&nbsp;&nbsp; // store the results.
&nbsp;&nbsp;&nbsp; double[][] realSpect = //Real part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; double[][] imagSpect = //Imaginary part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; double[][] amplitudeSpect = //Amplitude
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; //Now perform the transform
&nbsp;&nbsp;&nbsp; ImgMod30.xform2D(spatialData,realSpect,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagSpect,amplitudeSpect);
&nbsp;
&nbsp;&nbsp;&nbsp; //Display the raw amplitude spectrum without
&nbsp;&nbsp;&nbsp; // shifting the origin first.&nbsp; Display the
&nbsp;&nbsp;&nbsp; // axes.
&nbsp;&nbsp;&nbsp; new ImgMod29(amplitudeSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);

&nbsp;&nbsp;&nbsp; //At this point, the wavenumber spectrum is
&nbsp;&nbsp;&nbsp; // not in a format that is good for viewing.
&nbsp;&nbsp;&nbsp; // In particular, the origin is at the upper
&nbsp;&nbsp;&nbsp; // left corner.&nbsp; The horizontal Nyquist
&nbsp;&nbsp;&nbsp; // folding&nbsp; wavenumber is near the
&nbsp;&nbsp;&nbsp; // horizontal center of the plot.&nbsp; The
&nbsp;&nbsp;&nbsp; // vertical Nyquist folding wave number is
&nbsp;&nbsp;&nbsp; // near the vertical center of the plot.&nbsp; It
&nbsp;&nbsp;&nbsp; // is much easier for most people to
&nbsp;&nbsp;&nbsp; // understand what is going on when the
&nbsp;&nbsp;&nbsp; // wavenumber origin is shifted to the
&nbsp;&nbsp;&nbsp; // center of the plot with the Nyquist
&nbsp;&nbsp;&nbsp; // folding wave numbers at the edges of the
&nbsp;&nbsp;&nbsp; // plot.&nbsp; The method named shiftOrigin can be
&nbsp;&nbsp;&nbsp; // used to rearrange the data and to shift
&nbsp;&nbsp;&nbsp; // the orgin in that manner.

&nbsp;&nbsp;&nbsp; //Shift the origin and display the real part
&nbsp;&nbsp;&nbsp; // of the spectrum, the imaginary part of the
&nbsp;&nbsp;&nbsp; // spectrum, and the amplitude of the
&nbsp;&nbsp;&nbsp; // spectrum.&nbsp; Display the axes in all three
&nbsp;&nbsp;&nbsp; // cases.
&nbsp;&nbsp;&nbsp; double[][] shiftedRealSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(realSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedRealSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] shiftedImagSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(imagSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedImagSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double[][] shiftedAmplitudeSpect =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImgMod30.shiftOrigin(amplitudeSpect);
&nbsp;&nbsp;&nbsp; new ImgMod29(shiftedAmplitudeSpect,3,true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now test the inverse transform by
&nbsp;&nbsp;&nbsp; // performing an inverse transform on the
&nbsp;&nbsp;&nbsp; // real and imaginary parts produced earlier
&nbsp;&nbsp;&nbsp; // by the forward transform.
&nbsp;&nbsp;&nbsp; //Begin by preparing an array object to store
&nbsp;&nbsp;&nbsp; // the results.
&nbsp;&nbsp;&nbsp; double[][] recoveredSpatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp; //Now perform the inverse transform.
&nbsp;&nbsp;&nbsp; ImgMod30.inverseXform2D(realSpect,imagSpect,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recoveredSpatialData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the output from the inverse
&nbsp;&nbsp;&nbsp; // transform.&nbsp; It should compare favorably
&nbsp;&nbsp;&nbsp; // with the original spatial surface.
&nbsp;&nbsp;&nbsp; new ImgMod29(recoveredSpatialData,3,false,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displayType);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the following code to confirm correct
&nbsp;&nbsp;&nbsp; // scaling. If the scaling is correct, the
&nbsp;&nbsp;&nbsp; // two values in each pair of values should
&nbsp;&nbsp;&nbsp; // match.&nbsp; Note that this is a very small
&nbsp;&nbsp;&nbsp; // subset of the total set of values that
&nbsp;&nbsp;&nbsp; // make up the original and recovered
&nbsp;&nbsp;&nbsp; // spatial data.
&nbsp;&nbsp;&nbsp; for(int row = 0;row &lt; 3;row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0;col &lt; 3;col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] + " " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recoveredSpatialData[row][col] + " ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//col
&nbsp;&nbsp;&nbsp; }//row
&nbsp; }//end main
&nbsp; //===========================================//
&nbsp;
&nbsp; //This method constructs and returns a 3D
&nbsp; // surface in a 2D array of type double
&nbsp; // according to the identification of a
&nbsp; // specific case received as an input
&nbsp; // parameter.&nbsp; There are 14 possible cases.&nbsp; A
&nbsp; // description of each case is provided in the
&nbsp; // comments.&nbsp; The other two input parameters
&nbsp; // specify the size of the surface in units of
&nbsp; // rows and columns.
&nbsp; private static double[][] getSpatialData(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int switchCase,int rows,int cols){
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Create an array to hold the data.&nbsp; All
&nbsp;&nbsp;&nbsp; // elements are initialized to a value of
&nbsp;&nbsp;&nbsp; // zero.
&nbsp;&nbsp;&nbsp; double[][] spatialData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new double[rows][cols];
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use a switch statement to select and
&nbsp;&nbsp;&nbsp; // create a specified case.
&nbsp;&nbsp;&nbsp; switch(switchCase){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a single non-zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point at the origin in the space
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // domain.&nbsp; The origin is at the upper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // left corner.&nbsp; In signal processing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // terminology, this point can be viewed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as an impulse in space.&nbsp; This produces
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a flat spectrum in wavenumber space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a single non-zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point near but not at the origin in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.&nbsp; This produces a flat spectrum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in wavenumber space as in case 0.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // However, the real and imaginary parts
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the transform are different from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // case 0 and the result is subject to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // arithmetic accuracy issues.&nbsp; The
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plotted flat spectrum doesn't look
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // very good because the color switches
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // back and forth between three values
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that are very close to together.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is the result of the display program
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // normalizing the surface values based
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the maximum and minimum values,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which in this case are very close
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // together.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a box on the diagonal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // near the origin. This produces a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sin(x)/x shape to the spectrum with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // its peak at the origin in wavenumber
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = 1;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][4] = 1;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case places a box at the top near
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the origin.&nbsp; This produces the same
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // amplitude spectrum as case 2. However,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the real and imaginary parts, (or the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // phase) is different from case 2 due to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the difference in location of the box
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to the origin in space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a short line along the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // diagonal from upper left to lower
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // right. This results in a spectrum with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a sin(x)/x shape along that axis and a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constant along the axis that is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perpendicular to that axis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][6] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[7][7] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a short line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perpendicular to the diagonal from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // upper left to lower right.&nbsp; The
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectral result is shifted 90 degrees
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to that shown for case 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // where the line was along the diagonal.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In addition, the line is shorter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resulting in wider lobes in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws horizontal lines,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // vertical lines, and lines on both
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // diagonals.&nbsp; The weights of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // individual points is such that the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // average of all the weights is 0.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The weight at the point where the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lines intersect is also 0.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produces a spectrum that is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical across the axes at 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 45, and 90 degrees.&nbsp; The value of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the spectrum at the origin is zero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with major peaks at the folding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wavenumbers on the 45-degree axes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In addition, there are minor peaks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at various other points as well.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][0] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][2] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][4] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][6] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][0] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][1] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][2] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][4] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][5] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][6] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][0] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][1] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][2] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][4] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][5] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][6] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[0][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[1][3] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[2][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[3][3] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[4][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[5][3] = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[6][3] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a zero-frequency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sinusoid (DC) on the surface with an
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // infinite number of samples per cycle.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This causes a single peak to appear in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the spectrum at the wavenumber
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin.&nbsp; This origin is the upper left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // corner for the raw spectrum, and is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at the center cross hairs after the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin has been shifted to the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // center for better viewing.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 8:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // along the horizontal axis with one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sample per cycle. This function is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // under-sampled by a factor of 2.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This produces a single peak in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum at the wave number origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The result is the same as if the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sinusoidal surface had zero frequency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as in case 7..
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 9:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 2 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle.&nbsp; This is the Nyquist folding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wave number.&nbsp; This causes a single
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // peak to appear in the spectrum at the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // negative folding wave number on the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // horizontal axis.&nbsp; A peak would also
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // appear at the positive folding wave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number if it were visible, but it is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // one unit outside the boundary of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // plot.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 10:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the vertical axis with 2 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle.&nbsp; Again, this is the Nyquist
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // folding wave number but the sinusoid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // appears along a different axis.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // causes a single peak to appear in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // spectrum at the negative folding wave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number on the vertical axis.&nbsp; A peak
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // would also appear at the positive
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // folding wave number if it were
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // visible, but it is one unit outside
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the boundary of the plot.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*row/2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 11:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 8 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle. You might think of this surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // as resembling a sheet of corrugated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // roofing material.&nbsp; This produces
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical peaks on the horizontal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // axis on either side of the wave-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*col/8);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 12:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis with 3 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle plus a sinusoidal surface on the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // vertical axis with 8 samples per
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cycle. This produces symmetrical peaks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // on the horizontal and vertical axes on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all four sides of the wave number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // origin.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2*PI*row/8) + cos(2*PI*col/3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 13:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This case draws a sinusoidal surface at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // an angle of approximately 45 degrees
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // relative to the horizontal.&nbsp; This
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produces a pair of peaks in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wavenumber spectrum that are
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // symmetrical about the origin at
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // approximately 45 degrees relative to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the horizontal axis.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double phase = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int row = 0; row &lt; rows; row++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int col = 0; col &lt; cols; col++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spatialData[row][col] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos(2.0*PI*col/8 - phase);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end inner loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Increase phase for next row
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phase += .8;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end outer loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Case must be " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "between 0 and 13 inclusive.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Terminating program.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);
&nbsp;&nbsp;&nbsp; }//end&nbsp; switch statement
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return spatialData;
&nbsp; }//end getSpatialData
}//end class ImgMod31

<b>Listing 22</b></pre></td></tr></tbody></table><p>&nbsp;</p>
</p>

     
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4><a name="About_the_author">About the author</a></h4><b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> 
is a college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.
</i>
<p><i>Richard has participated in numerous consulting projects and he frequently 
provides onsite training at the high-tech companies located in and around 
Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine. </i></p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics. </i></p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems. </i></p>
<p><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a> 
</p>
<p><b>Keywords</b><br>
Java space time wavenumber frequency domain two-dimensional one-dimensional 
forward inverse 2D 3D Fourier transform spectra antenna array complex spectral 
DSP surface Nyquist folding periodic </p>
<p>-end-<i> </i></p>
</body>
</html>
