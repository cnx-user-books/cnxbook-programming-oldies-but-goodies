<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#dd0000" vlink="#0000ff" alink="#ff0000" lang="EN-US">
<p></p>
<h2>Java JAXP and XSL Transformations (XSLT), Getting Started</h2>
<p><i>Baldwin provides a brief review of XSL Transformations, shows you
how to create and use an identity Transformer object to display a DOM
tree on the screen and write it into an output XML file, and how to
write exception handlers that provide meaningful information in the
event of parser errors and exceptions.</i><br>
</p>
<p><b>Published:</b>&nbsp; November 18, 2003<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 2202</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#General%20Background%20Information">General
Background Information on XSLT</a></li>
  <li> <a href="#Preview">Preview</a></li>
  <li> <a href="#Discussion%20and%20Sample%20Programs">Discussion and
Sample Code</a></li>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listings</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p><font color="#ff0000"><b>What is JAXP?</b></font><br>
</p>
<p>As the name implies, the Java API for XML Processing (JAXP) is an
API designed
to help you write programs for processing XML documents.&nbsp; JAXP is
very important for many reasons, not the least of which is the
fact that it is a critical part of the Java Web Services Developer Pack
(Java WSDP).</p>
<p>This is the second lesson in a series designed to initially help you
understand how to use JAXP,
and to eventually help you understand how to use the Java WSDP.</p>
<p>The first lesson was entitled <a
 href="http://www.developer.com/java/other/article.php/3099751">Java
API for XML Processing (JAXP), Getting Started</a>.<br>
</p>
<p><font color="#ff0000"><b>What is XML?</b></font></p>
XML is an acronym for the&nbsp;e<b>X</b>tensible <b>M</b>arkup <b>L</b>anguage.&nbsp;
I will not attempt to teach XML in this series of
tutorial lessons.&nbsp; Rather, I will assume that you already
understand
XML, and I will teach you how to use JAXP to write programs for
creating and processing XML documents.<br>
<br>
I have published numerous tutorial lessons on XML at <a
 href="http://softwaredev.earthweb.com/java">Gamelan.com</a>&nbsp;and <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a></font>.&nbsp;
You may find it useful to refer to those lessons.&nbsp; In addition, I
provided
a review of the salient aspects of XML in the first lesson in this
series.&nbsp; From time to time, I will also provide background
information regarding XML in the lessons in this series.&nbsp; For
example, I will provide background information on XSL and XSL
Transformations (XSLT) later in this document under <a
 href="#General%20Background%20Information">General Background
Information on XSLT</a>.<br>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back and forth among the different listings and figures while
you are reading about them. </p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes
they are difficult to locate there.&nbsp; You will find a consolidated
index at <font color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font>
</p>
<h2 align="center"><font color="#000000"> <a
 name="General Background Information">General Background Information
on XSLT</a></font></h2>
<p><b><font color="#ff0000">Rendering XML documents</font></b> </p>
<p>As of this writing, to my knowledge, Microsoft IE is the only
widely-used web browser that has the ability to do a good job of
rendering XML documents. &nbsp;IE can render XML documents using either
Cascading Style Sheets (CSS) or XSL.&nbsp; Thus, IE provides a good
vehicle for testing XSLT files that you intend to use with JAXP. </p>
<center> </center>
<b><font color="#ff0000">What is the W3C?</font></b>
<p><font color="#000000">For purposes of this lesson, the W3C is a
governing body that has published many important documents on XSL and
XSLT, two of which will be referenced later in this document.</font> </p>
<center> </center>
<font color="#ff0000"><b>What is XSL?</b></font><br>
<br>
XSL is an acronym for <i>Extensible Stylesheet Language</i>.
<p>According to the <a href="http://www.w3.org/TR/xsl/">W3C</a>, XSL
is
a language for expressing stylesheets. It consists of two parts:<br>
</p>
<ol>
  <li>A language for transforming XML documents, and</li>
  <li>An XML vocabulary for specifying formatting semantics. </li>
</ol>
<p>Again, according to the W3C, <br>
</p>
<blockquote><i>"An XSL stylesheet specifies the presentation of a class
of XML documents by describing how an instance of the class is
transformed into an XML document that uses the formatting vocabulary."</i></blockquote>
<p><b><font color="#ff0000">Separating content from presentation</font></b>
</p>
<p>As you are probably aware by now, one of the primary virtues of XML
is the ability to separate content from presentation. </p>
<p>In other words, an XML document contains structured information, but
does not provide any hints as to how that information should be
rendered for the benefit of a consumer. </p>
<font color="#ff0000"><b>What is XSLT?</b></font><br>
<br>
XSLT is an acronym for <i>XSL Transformations</i>.
<p>According to the <a href="http://www.w3.org/TR/xslt">W3C</a>,&nbsp;<br>
</p>
<blockquote><i>"This specification defines the syntax and semantics of
XSLT, which is a language for transforming XML documents into other XML
documents. </i>
  <p><i>XSLT is designed for use as part of XSL, which is a stylesheet
language for XML. In addition to XSLT, XSL <br>
includes an XML vocabulary for specifying formatting. XSL specifies
the styling of an XML document by using XSLT to describe how the
document
is transformed into another XML document that uses the formatting
vocabulary. </i></p>
  <p><i>XSLT is also designed to be used independently of XSL. However,
XSLT is not intended as a completely general-purpose XML transformation
language. Rather it is designed primarily for the kinds of
transformations that are needed when XSLT is used as part of XSL."</i><br>
  </p>
</blockquote>
<p><b><font color="#ff0000">Transforming XML to other formats</font></b>
</p>
<p>Because an HTML document can be represented as an XML document, XSLT
can be used to transform XML documents into HTML documents.&nbsp; This
makes it possible to render the information contained in an XML
document using a common HTML Web browser.&nbsp; Thus, one useful way to
view the contents of an XML document is to transform it into an HTML
document and view it using a standard Web browser. </p>
<p><b><font color="#ff0000">Where does the transformation take place?</font></b>
</p>
<p>When transforming information from an XML document for rendering on
an HTML browser, the transformation can take place anywhere between the
XML document and the browser. </p>
<p><b><font color="#ff0000">Transforming on the server</font></b> </p>
<p>For example, an XSLT engine could be written in Java and run as a
servlet, or it could be written as a JavaBeans component and accessed
from a <i>scriptlet</i> in a JavaServer page (JSP). </p>
<p><b><font color="#ff0000">Transforming at the browser</font></b> </p>
<p>Or, the transformation could be performed at the browser.&nbsp; For
example, Microsoft IE can be used for this purpose. </p>
<h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p><font color="#ff0000"><b></b></font></p>
<p><font color="#ff0000"><b>A tree structure in memory</b></font><br>
</p>
<p>As you learned in the previous lesson, a DOM parser can be used to
create a tree structure in memory that represents an XML
document.&nbsp; In Java, that tree structure is encapsulated in an
object of the interface type <b>Document</b>.&nbsp; <b>Document</b>
and its superinterface <b>Node</b> declare numerous methods.&nbsp; As
is always the case, classes that implement <b>Document</b> must
provide concrete definitions of those methods.<br>
</p>
<p><font color="#ff0000"><b>Many operations are possible</b></font><br>
</p>
<p>Thus, given an object of type <b>Document</b>, there are many
methods that
can be invoked on the object to perform a variety of operations.&nbsp;
For example, it is possible to move nodes from one location in the tree
to another location in the tree, thus rearranging the structure of the
XML document represented by the <b>Document</b> object.&nbsp; It is
also possible to delete nodes, and to insert new nodes.&nbsp; As you
saw in the sample program in the previous lesson, it is also possible
to
recursively traverse the tree, extracting information about the nodes
along
the way.<br>
</p>
<p><font color="#ff0000"><b>I showed you ...</b></font><br>
</p>
<p></p>
<p>In the previous lesson, I showed you how to:<br>
</p>
<ul>
  <li>Use JAXP, DOM, and an input XML file to create a <b>Document </b>object
that represents the XML file.</li>
  <li>Recursively traverse the DOM tree, gathering information about
each node in the tree along the way.</li>
  <li>Use the information about the nodes to create a new XML file that
represents the <b>Document </b>object.</li>
</ul>
The unmodified <b>Document</b> object represented the original XML
file in the previous lesson.&nbsp; The DOM tree was not modified in
that example.&nbsp; The final XML file represented the unmodified <b>Document</b>
object, which represented the original XML file.&nbsp; Therefore, the
final XML file was functionally equivalent to the original XML file.<br>
<br>
<font color="#ff0000"><b>Something of an overkill</b></font><br>
<p>The things that you learned in the previous lesson about traversing
the tree structure and gathering information about each node in the
tree will serve you well in the future.&nbsp; However, if all you need
to do is to write an output XML file that represents a DOM tree, there
is an easier way to do that using XSLT.&nbsp; That is the primary topic
of this lesson.<br>
</p>
For simplicity, I elected not to show you how to write exception
handlers that produce meaningful output in the event of parser errors
in the previous lesson.&nbsp; I will also cover that topic in this
lesson.
<p><font color="#ff0000"><b>Nothing fancy intended</b></font><br>
</p>
<p>The sample program that I will explain in this lesson is not
intended to do anything fancy.&nbsp; It is intended simply to introduce
you to the
use of XSLT to transform DOM objects in Java programs.<br>
</p>
<center>
<h2> <a name="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2>
</center>
The sample program consists of a single class named <b>Xslt01</b>.
&nbsp;For purposes of illustration, the program operates on two XML
files. &nbsp;One of the XML files is named <b>Xslt01.xml</b>.&nbsp;
The other XML file is named <b>Xslt01bad.xml</b>.&nbsp; The first XML
file is well formed, and is used to illustrate the behavior of the
program in the absence of parser errors.&nbsp; The second XML file is
not well formed, and is used to illustrate the behavior of the program
in the face of parser errors.<br>
<blockquote><i>(You could, of course, use the program to operate on
other XML files of your own design.)</i><br>
</blockquote>
As is often the case, I will discuss the program code in
fragments.&nbsp; Complete listings of all three files are shown in
Listings 9, 10, and 11 near the end of the lesson.<br>
<br>
<font color="#ff0000"><b>The XML file named Xslt01.xml</b></font><br>
<br>
I will begin my discussion with the XML file named <b>Xslt01.xml</b>.
&nbsp; A complete listing of this file is shown in Listing 10 near the
end of the lesson.&nbsp; This is a relatively simple XML file.&nbsp;
Assuming that you understood the material in the previous lesson, there
should be no surprises in the file named <b>Xslt01.xml</b>.&nbsp; This
file will be used to test the program for the case where there are no
parser errors.<br>
<br>
<font color="#ff0000"><b>The XML file named Xslt01bad.xml</b></font><br>
<br>
A complete listing of the file named <b>Xslt01bad.xml</b> is shown in
Listing 11 near the end of the lesson.&nbsp; This file is not well
formed. &nbsp;It is missing a right angle bracket at the end of line 6,
resulting in a bad end tag for the element named <b>line</b>.&nbsp;
Again, assuming that you understood the material in the previous
lesson, there should be no surprises in the file named <b>Xslt01bad.xml</b>.&nbsp;
This file will be used to test the program for the case where there are
parser errors.<br>
<br>
<font color="#ff0000"><b>The class named Xslt01</b></font><br>
<br>
The entire program in contained in a class named <b>Xslt01</b>.
&nbsp;A complete listing of the program is shown in Listing 9 near the
end of the lesson.<br>
<br>
<font color="#ff0000"><b>Behavior of the program</b></font><br>
<br>
This program is a modification of the program named <b>Dom02</b> that
was discussed in the previous lesson.&nbsp; The program was modified to
use
an identity XSL <b>Transformer </b>object to format an output XML
file in
place of a call to <b>Dom02Writer</b>, as was the case in the previous
program.&nbsp;
This modification resulted in a much simpler and probably more reliable
program.<br>
<br>
The program was also modified to display the output XML on the Standard
Output Device <i>(typically the screen)</i> as well as to provide
meaningful output in the event of a parsing error.<br>
<br>
This program shows you how to:<br>
<ul>
  <li>Create a <b>Document </b>object using JAXP, DOM, and an input
XML file.</li>
  <li>Create an identity XSL <b>Transformer </b>object.</li>
  <li>Use the identity <b>Transformer </b>object to display the XML
represented by the <b>Document </b>object on the Standard Output
Device.</li>
  <li>Use the identity <b>Transformer </b>object to write the XML
represented by the <b>Document </b>object into an output file.</li>
  <li>Provide meaningful output in the case of a parser error.</li>
</ul>
<font color="#ff0000"><b>Operation of the program</b></font><br>
<br>
The program requires two command-line arguments.&nbsp; The input XML
file name is provided by the user as the first command-line
argument.&nbsp;
The output XML file name is provided by the user as the second
command-line
argument.<br>
<br>
<font color="#ff0000"><b>Get a DOM parser object</b></font><br>
<br>
The program begins by instantiating a DOM parser object of type <b>DocumentBuilder</b>
based on JAXP.&nbsp; The parser is configured as a non-validating
parser.<br>
<br>
<font color="#ff0000"><b>Create a DOM tree as a Document object</b></font><br>
<br>
The program uses the <b>parse</b> method of the parser object to parse
an XML file specified on the command line.&nbsp; The parse method
returns an object of type <b>Document </b>that represents the parsed
XML file.<br>
<br>
<font color="#ff0000"><b>Get an identity Transformer object</b></font><br>
<br>
Then the program gets a <b>TransformerFactory </b>object and uses
that object to get an identity <b>Transformer </b>object capable of
performing a copy of a <i>source </i>to a <i>result.</i><br>
<br>
<font color="#ff0000"><b>Get a Source object</b></font><br>
<br>
Following this, the program uses the <b>Document </b>object to get a <b>DOMSource
</b>object that implements the <b>Source</b> interface, and acts as a
holder for a transformation source tree in the form of a DOM tree.<br>
<br>
<font color="#ff0000"><b>Get a Result object</b></font><br>
<br>
Then the program gets a <b>StreamResult </b>object that implements
the <b>Result</b> interface, and points to the standard output
device.&nbsp; This object acts as a holder for a transformation result.<br>
<br>
<font color="#ff0000"><b>Transform the DOM tree</b></font><br>
<br>
Having gone through the preparation steps, the program uses the <b>Transformer
</b>object, the <b>DOMSource </b>object, and the <b>StreamResult </b>object
to transform the DOM tree to text and display it on the standard output
device <i>(the screen).</i><br>
<br>
Having transformed the <b>Document</b> on the screen, the program gets
another <b>StreamResult </b>object that points to an output
file.&nbsp;
Then it transforms the DOM tree to XML text, and writes it into the
output
file.<br>
<br>
<font color="#ff0000"><b>Handle errors and exceptions</b></font><br>
<br>
The program catches and handles a variety of different types of errors
and exceptions and provides meaningful output in the event of parser
errors. &nbsp;An XML document that is not well formed is used to
illustrate the ability
to display meaningful information in the event of a parser error.<br>
<br>
<font color="#ff0000"><b>Miscellaneous comments about the program</b></font><br>
<br>
The program was tested using SDK 1.4.2 and WinXP with two different XML
files.&nbsp; The XML file named <b>Xslt01.xml</b> is well formed, and
is shown in Listing 10 near the end of the lesson.<br>
<br>
The XML file named <b>Xslt01bad.xml</b> is not well formed and is
shown in Listing 11 near the end of the lesson.&nbsp; This file was
purposely corrupted, and is missing a right angle bracket in the
closing tag of a <b>line
</b>element.&nbsp; This file is used to test for parser errors.&nbsp; I
will show you the output produced by this file later in the lesson
under
the discussion of the catch block for exceptions of type <b>SAXParseException</b>.<br>
<br>
<font color="#ff0000"><b>Let's see some code</b></font><br>
<br>
The program named <b>Xslt01 </b>begins in Listing 1, which shows the
beginning of the class definition and the beginning of the <b>main</b>
method.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class <b>Xslt01</b>{<br><br>  public static void <b>main</b>(String argv[]){<br>    if (argv.length != 2){<br>      System.err.println(<br>        "usage: java Xslt01 fileIn fileOut");<br>      System.exit(0);<br>    }//end if<br><br><b><font
 face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The code in Listing 1 simply checks to confirm that the user has
entered the correct number of command-line arguments, and aborts if the
user has failed to enter the correct number.<br>
<font color="#ff0000"><b><br>
Steps for creating a Document object</b></font><br>
<br>
As you will recall from the previous lesson, three steps
are required to create a <b>Document</b> object:<br>
<ol>
  <li>Create a <b>DocumentBuilderFactory </b>object</li>
  <li>Use the&nbsp;<b>DocumentBuilderFactory </b>object to create a <b>DocumentBuilder
    </b>object</li>
  <li>Use the <b>parse</b> method of the <b>DocumentBuilder </b>object
to create a <b>Document</b> object</li>
</ol>
These three steps are illustrated by the three statements in Listing
2.&nbsp;
<i>(We will probably see these three statements in many different
programs
in this series of lessons.)</i><br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    try{<br>      DocumentBuilderFactory docBuildFactory =<br>            DocumentBuilderFactory.<b>newInstance</b>();<br><br>      DocumentBuilder parser =<br>            docBuildFactory.<b>newDocumentBuilder</b>();<br><br>      Document document = parser.<b>parse</b>(<br>                              new File(argv[0]));<br><br><b><font
 face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The DocumentBuilderFactory Class</b></font><br>
<br>
Reviewing some of what you learned in the previous lesson, the <b>DocumentBuilderFactory
</b>class<br>
<blockquote><i>"Defines a factory API that enables applications to
obtain a parser that produces DOM object trees from XML documents."</i><br>
</blockquote>
The <b>DocumentBuilderFactory </b>class extends <b>Object</b>, and
defines about fifteen methods, one of which is a static method
named <b>newInstance</b>.&nbsp; The <b>newInstance</b> method is used
to create an object of the <b>DocumentBuilderFactory</b> class <i>(as
shown in Listing 2).</i><br>
<br>
The class also defines the <b>newDocumentBuilder</b> instance method,
which is used to create objects of the <b>DocumentBuilder</b> class <i>(also
shown in Listing 2).</i><font color="#ff0000"><b><br>
<br>
The DocumentBuilder Class</b></font><br>
<br>
The <b>DocumentBuilder</b> class<br>
<blockquote><i>"Defines the API to obtain DOM Document instances from
an
XML document.</i><i>"</i><br>
</blockquote>
This class also extends <b>Object</b>, and defines about
ten methods, which include several overloaded versions of the <b>parse</b>
method.&nbsp; When the <b>parse</b> method is invoked and passed an
input source containing XML, the method returns a <b>Document</b>
object <i>(DOM tree)</i> that represents the XML.<br>
<blockquote><i>(In Listing 2, the <b>parse</b> method is passed a
reference to a <b>File</b> object that represents the input XML file.)</i><br>
</blockquote>
<font color="#ff0000"><b>The Document interface</b></font><br>
<br>
<b>Document</b> is an interface in the <b>org.w3c.dom</b> package,
which extends the <b>Node</b> interface belonging to the same
package.&nbsp; When we invoke the <b>parse</b> method, it returns a
reference to an object instantiated from a class that implements the <b>Document</b>
interface.<br>
<blockquote><i>(The reference is returned as type <b>Document</b>, not
as the name of the class from which the object was actually
instantiated.</i><i> &nbsp; Because <b>Document </b>extends <b>Node</b>,
that object could also be treated as type <b>Node </b>when
appropriate.)</i><br>
</blockquote>
According to Sun:<br>
<blockquote><i>"The Document interface represents the entire HTML or
XML
document. Conceptually, it is the root of the document tree, and
provides
the primary access to the document's data."</i><br>
</blockquote>
<font color="#ff0000"><b>Steps for creating a Transformer object</b></font><br>
<br>
This information is new to this lesson.&nbsp; The following two steps
are required to create an identity <b>Transformer</b> object.
<ol>
  <li>Create a <b>TransformerFactory </b>object by invoking the
static <b>newInstance </b>method of the <b>TransformerFactory </b>class.</li>
  <li>Invoke the <b>newTransformer</b> method on the <b>TransformerFactory</b>
object.</li>
</ol>
These two steps are illustrated by the code in Listing 3.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      //Get a TransformerFactory object<br>      TransformerFactory xformFactory =<br>                TransformerFactory.<b>newInstance</b>();<br>      //Get an XSL Transformer object<br>      Transformer transformer =<br>                   xformFactory.<b>newTransformer</b>();<br><br><b><font
 face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The TransformerFactory class</b></font><br>
<br>
A TransformerFactory instance can be used to create <b>Transformer </b>and
<b>Templates </b>objects.<br>
<blockquote><i>(This lesson does not discuss <b>Templates</b>
objects.&nbsp;
That is a topic for a future lesson.)</i><br>
</blockquote>
In a programming style that should by now be familiar, this class
provides a static method named <b>newInstance</b>.&nbsp; Invocation of
the <b>newInstance</b> method returns a reference to a new instance of
<b>TransformerFactory</b>.<br>
<br>
<font color="#ff0000"><b>The newTransformer method</b></font><br>
<br>
A <b>TransformerFactory </b>object provides two overloaded versions
of the <b>newTransformer</b> method.&nbsp; Invocation of the version
of <b>newTransformer</b> that takes no parameters <i>(on an instance
of <b>TransformerFactory)</b></i> returns a reference to a new <b>Transformer</b>
object that performs a
copy of a <i>source </i>to a <i>result</i>.&nbsp; Some authors refer
to
this as the <i>identity</i> transform.<br>
<br>
The code in Listing 3 produces such a <b>Transformer</b> object, and
saves the object's reference in a variable named <b>transformer</b>.<br>
<br>
<font color="#ff0000"><font color="#000000">The other overloaded
version of the <b>newTransformer</b> method takes a parameter that
represents an XSL
stylesheet, and returns a <b>Transformer </b>object that implements
the instructions
in the stylesheet.&nbsp; I will show you how to use that version is a
future
lesson.</font></font><br>
<br>
<font color="#ff0000"><b>The Transformer class</b></font><br>
<br>
Here is some of what Sun has to say about an object of the <b>Transformer</b>
class:<br>
<blockquote><i>"An instance of this abstract class can transform a
source tree into a result tree. </i><br>
  <br>
  <i>An instance of this class can be obtained with the
TransformerFactory.newTransformer method. This instance may then be
used to process XML from a variety of
sources and write the transformation output to a variety of sinks."</i><br>
</blockquote>
<font color="#ff0000"><b>The transform method</b></font><br>
<br>
The <b>transform</b> method of the <b>Transformer</b> class is
partially described in Figure 1.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>public abstract void transform(<br>                           Source xmlSource,<br>                           Result outputTarget)<br>                    throws TransformerException<br><br>Process the source tree to the output result. <br><br>Parameters:<br>xmlSource - The input for the source tree.<br>outputTarget - The output target.<br></pre>
      <pre><b>Figure 1</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
As you can see, this method requires two parameters:<br>
<ol>
  <li>A reference to an object of type <b>Source</b></li>
  <li>A reference to an object of type <b>Result</b></li>
</ol>
The method processes the <b>Source</b> to produce the <b>Result</b>.<br>
<br>
<font color="#ff0000"><b>The Source interface</b></font><br>
<br>
<b>Source</b> is an interface, not a class.&nbsp; Sun has this to say
about the <b>Source </b>interface:<br>
<blockquote><i>"An object that implements this interface contains the
information needed to act as source input (XML source or transformation
instructions)."</i><br>
</blockquote>
<blockquote><i>(Note that the reference to transformation instructions
in the above quotation is a reference to the input parameter to the
second overloaded version of the <b>newTransformer</b> method
discussed earlier.&nbsp; Again, I will show you how to use this version
in a future lesson.)</i><br>
</blockquote>
In this program, I will create and use an object of the <b>DOMSource</b>
class as the source for the transformation.&nbsp; <i>(The <b>DOMSource
</b>class implements the <b>Source </b>interface.)</i><br>
<br>
<b><font color="#ff0000">The DOMSource class</font></b><br>
<br>
Here is what Sun has to say about an object of the <b>DOMSource</b>
class:<br>
<blockquote><i>"Acts as a holder for a transformation Source tree in
the
form of a Document Object Model (DOM) tree."</i><br>
</blockquote>
<font color="#ff0000"><b>The Result interface</b></font><br>
<br>
Sun has this to say about the <b>Result </b>interface:<br>
<blockquote><i>"An object that implements this interface contains the
information needed to build a transformation result tree.</i><i>"</i><br>
</blockquote>
<i></i>In this program, I will transform the <b>DOMSource</b> object
into two different <b>Result</b> objects:<br>
<ul>
  <li>A <b>StreamResult </b>object that points to the Standard Output
Device <i>(typically the screen).</i></li>
  <li>A <b>StreamResult </b>object that points to the output file.</li>
</ul>
<font color="#ff0000"><b>The StreamResult class</b></font><br>
<br>
Sun has this to say about the <b>StreamResult</b> class:<br>
<blockquote><i>"Acts as an holder for a transformation result, which
may be
XML, plain Text, HTML, or some other form of markup."</i><br>
</blockquote>
<font color="#ff0000"><b>Get a DOMSource object</b></font><br>
<br>
Listing 4 shows the code that gets a <b>DOMSource</b> object, which
represents the <b>Document</b> object.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      DOMSource source = new DOMSource(document);<br><br><b><font
 face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The <b>DOMSource</b> class provides several different overloaded
constructors, one of which requires a single incoming parameter of type
<b>Node</b>.&nbsp;
Recall that the variable <b>document</b> contains a reference to an
object
that implements the <b>Document</b> interface, which is a subinterface
of
the <b>Node</b> interface.&nbsp; Thus, <b>document</b> satisfies the
parameter type requirement for the constructor shown in Listing 4.<br>
<br>
The <b>DOMSource</b> object produced in Listing 4 will later be
transformed into two different <b>Result</b> objects.<br>
<br>
<font color="#ff0000"><b>Get a StreamResult object</b></font><br>
<br>
The statement in Listing 5 gets a <b>StreamResult</b> object that
points to the Standard Output Device.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      StreamResult scrResult =<br>                    new StreamResult(System.out);<br><br><b><font
 face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The <b>StreamResult</b> class provides several overloaded
constructors, one of which requires an incoming parameter of type <b>OutputStream</b>.&nbsp;
<b>System.out</b> contains a reference to an object of type <b>PrintStream</b>,
which is a subclass of <b>OutputStream</b>.&nbsp; Therefore, <b>System.out</b>
satisfies the parameter type requirement for one of the overloaded
constructors
of <b>StreamResult</b>.<br>
<br>
<font color="#ff0000"><b>Transform the DOMSource to text on the screen</b></font><br>
<br>
The statement in Listing 6 invokes the <b>transform</b> method of the
<b>Transformer</b> class to transform the <b>DOMSource</b> object to
text
on the screen.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      transformer.<b>transform</b>(source, scrResult);<br><br><b><font
 face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
The two parameters to the <b>transform</b> method shown in Listing 6
satisfy the parameter type requirements <i>(<b>Source</b> and <b>Result</b>)</i>
shown earlier in Figure 1.<br>
<br>
Because the <b>DOMSource</b> object represents the <b>Document</b>
object, the code in Listing 6 transforms the <b>Document</b> object to
the screen. &nbsp; Since the <b>Document</b> object represents the
original XML file, this effectively transforms the contents of the
original XML file to the screen.<br>
<br>
<font color="#ff0000"><b>The screen output</b></font><br>
<br>
The statement shown in Listing 6 produced the screen output shown in
Figure 2.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br></pre>
      <pre><b>Figure 2</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
If you compare Figure 2 with the input XML file shown in Listing 10
near the end of the lesson, you will see that it matches in all
respects but one.&nbsp;
The one line that doesn't match is the XML declaration in the first
line
of Figure 2 and Listing 10.<br>
<br>
<font color="#ff0000"><b>The XML declaration</b></font><br>
<br>
The XML declaration is really not part of the XML data.&nbsp; Rather,
the XML declaration provides information to the processor being used to
process the XML data.&nbsp; I don't believe that the XML declaration
becomes a part of the DOM tree structure.<br>
<blockquote><i>(Recall that in the previous lesson, I used a separate
statement to write the XML declaration into the output file before
beginning the process of writing data in the output file based on data
in the DOM tree.)</i><br>
</blockquote>
The <b>encoding </b>attribute in the XML declaration shown in Figure
2
is optional.&nbsp; I elected not to include it in the original XML
file.&nbsp;
The author of the <b>transform</b> method of the <b>Transformer</b>
class
elected to include it in the transformed output.&nbsp; That is why it
appears
in Figure 2 and does not appear in Listing 10.<br>
<br>
<font color="#ff0000"><b>Write an output XML file</b></font><br>
<br>
The three statements in Listing 7 perform the following three actions
in order:<br>
<ol>
  <li>Get an output stream for the output XML file.</li>
  <li>Get a <b>StreamResult</b> object that points to the output file.</li>
  <li>Transform the <b>DOMSource</b> object to text in the output file.</li>
</ol>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      PrintWriter outStream = new PrintWriter(<br>                  new FileOutputStream(argv[1]));<br><br>      StreamResult fileResult =<br>                     new StreamResult(outStream);<br><br>      transformer.transform(source, fileResult);<br>    }//end try block<br><br><b><font
 face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<font color="#ff0000"><b>The output file</b></font><br>
<br>
Figure 3 shows the contents of the output file produced by Listing 7.<br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br></pre>
      <pre><b>Figure 3</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
As you might have surmised, the contents of the output file shown in
Figure 3 match the screen output shown in Figure 2.&nbsp; Also, with
the exception of the optional <b>encoding</b> attribute in the XML
declaration, the contents of the output file match the contents of the
original XML file shown in Listing 10.<br>
<br>
<font color="#ff0000"><b>End of the try block</b></font><br>
<br>
Listing 7 also signals the end of the <b>try</b> block and the end of
the code required to apply an identity XSL Transformation to a <b>Document</b>
object.<br>
<br>
Now you know how to use an identity transform to either display the XML
data encapsulated in a <b>Document</b> object, or to cause that XML
data
to be written into a new XML file.<br>
<br>
The remainder of this lesson deals with errors and exceptions, with
particular emphasis on providing meaningful output in the event of a
parser error.<br>
<br>
<font color="#ff0000"><b>Potential errors and exceptions</b></font><br>
<br>
If we scan back through the code, we can identify the following
expressions related to XML processing that have the potential of
throwing errors and exceptions <i>(I will omit I/O exceptions from
this discussion).</i>&nbsp;
A review of the Sun documentation reveals that these expressions can
throw the errors and exceptions shown.
<ul>
  <li>parser.parse(new File(argv[0]) throws <b>SAXException</b> if any
parse errors occur.</li>
  <li>docBuildFactory.newDocumentBuilder() throws <b>ParserConfigurationException
    </b>if a DocumentBuilder cannot be created which satisfies the
configuration requested.</li>
  <li>xformFactory.newTransformer() throws <b>TransformerConfigurationException</b>
- May throw this during the parse when it is constructing the Templates
object and fails.</li>
  <li>transformer.transform(source, scrResult) throws <b>TransformerException</b>
if an unrecoverable error occurs during the course of the
transformation.</li>
  <li> transformer.transform(source, fileResult) throws <b>TransformerException</b>
if an unrecoverable error occurs during the course of the
transformation.</li>
  <li>TransformerFactory.newInstance() throws <b>TransformerFactoryConfigurationError</b>
if the implementation is not available or cannot be instantiated.</li>
  <li>DocumentBuilderFactory.newInstance() throws <b>FactoryConfigurationError</b>
if the implementation is not available or cannot be instantiated.&nbsp;</li>
</ul>
<font color="#ff0000"><b>Handling errors and exceptions</b></font><br>
<br>
The remaining code in the program provides specific catch blocks for
some, but not all of the exceptions and errors listed above.<br>
<blockquote><i>(A general <b>Exception</b> catch block is provided to
handle those errors and exceptions for which specific catch blocks are
not provided.)</i><br>
</blockquote>
<font color="#ff0000"><b>The SAXException class</b></font><br>
<br>
The classes of primary interest in this lesson are the <b>SAXException</b>
class and a subclass of that class named <b>SAXParseException</b>.&nbsp;
Here is part of what Sun has to say about the <b>SAXException</b>
class <i>(boldface added by this author for emphasis):</i><br>
<blockquote><i>"Encapsulate a general SAX error or warning. ... </i><i>This
class can contain basic error or warning information from either the
XML parser or the application: a parser writer or application writer
can subclass it to provide additional functionality. SAX handlers may
throw this exception or any exception subclassed from it.</i><br>
  <br>
  <i>If the application needs to pass through other types of
exceptions, it must wrap those exceptions in a SAXException or an
exception derived from a SAXException.</i><br>
  <br>
  <i><b>If the parser or application needs to include information about
a specific location in an XML document, it should use the
SAXParseException subclass.</b>"</i><br>
</blockquote>
<font color="#ff0000"><b>The SAXParseException class</b></font><br>
<br>
The&nbsp;<b>SAXParseException</b> class is a subclass of <b>SAXException</b>.
&nbsp;An object of&nbsp;<b>SAXParseException</b> can<br>
<blockquote><i>"Encapsulate an XML parse error or warning. ... </i><i>This
exception will <b>include information for locating the error in the
original XML document</b>.</i><i>"</i><br>
</blockquote>
The list that I showed you earlier indicated that the <b>parse</b>
method of the <b>DocumentBuilder </b>class throws <b>SAXException</b>.&nbsp;
That means that it can also throw any exception that is a subclass of <b>SAXException</b>.
&nbsp; As it turns out, the <b>parse</b> method actually throws a <b>SAXParseException</b>,
for at least some of the possible parsing error types.<br>
<br>
<font color="#ff0000"><b>The SAXParseException handler</b></font><br>
<br>
Listing 8 shows the entire catch block for handling an exception of
type <b>SAXParseException</b>.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    catch(SAXParseException saxEx){<br>      System.err.println("\nSAXParseException");<br><br>      System.err.println("Public ID: " +<br>                            saxEx.<b>getPublicId</b>());<br>      System.err.println("System ID: " +<br>                            saxEx.<b>getSystemId</b>());<br>      System.err.println("Line: " +<br>                          saxEx.<b>getLineNumber</b>());<br>      System.err.println("Column:" +<br>                        saxEx.<b>getColumnNumber</b>());<br>      System.err.println(saxEx.<b>getMessage</b>());<br><br>      Exception ex = saxEx;<br>      if(saxEx.getException() != null){<br>        ex = saxEx.getException();<br>        System.err.println(ex.getMessage());}<br>    }//end catch<br><br><b><font
 face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
Of particular interest is the invocation of the five <i>get</i>
methods on the exception object for the purpose of getting and
displaying information about the exception.<br>
<br>
Listing 11 contains an XML file named <b>Xsl01bad.xml</b> for which a
right angle bracket was purposely omitted from the end tag on the sixth
line of text.&nbsp; This caused the XML document to not be well formed
because
the <b>line</b> element on the sixth line is malformed.<br>
<br>
<font color="#ff0000"><b>The screen output</b></font><br>
<br>
When this program was used to process the corrupt file named <b>Xsl01bad.xml</b>,
the code in Listing 8 produced the output shown in Figure 4.&nbsp; <i>(Note
that I manually inserted a line break to force some of the output to
fit in this narrow publication format.)</i><br>
&nbsp;
<table border="1" cols="1" width="400" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre>SAXParseException<br>Public ID: null<br>System ID: file:C:/jnk/Xslt01bad.xml<br>Line: 7<br>Column:-1<br>Next character must be "&gt;" terminating <br>element "line".<br></pre>
      <pre><b>Figure 4</b></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
You should be able to correlate each line of output in Figure 4 with
the statements in Listing 8.<br>
<br>
The -1 reported for the column number in Figure 4 indicates that the
column number was <i>"not available"</i> to the method named <b>getColumnNumber</b>.
&nbsp;The reported line number value of 7 is also one line beyond the
actual line where the error occurs in the XML document.<br>
<blockquote><i>(My interpretation of this situation is that the parser
considered the error to be before the first character in line 7 instead
of at the end of line 6.&nbsp; The error because apparent to the parser
when it encountered the left angle bracket for a new start tag without
the previous end tag having been properly terminated with a right angle
bracket.)</i><br>
</blockquote>
<font color="#ff0000"><b>Parsing with Internet Explorer</b></font><br>
<br>
For comparison purposes, Figure 5 shows the result of attempting to
parse the same corrupt XML file using Internet Explorer.<br>
<br>
<div align="center"><img src="java2202a.gif" alt="Fig 5 Parsing with IE"
 width="443" height="360"> <br>
<br>
Figure 5 Parsing error as per Internet Explorer<br>
</div>
<br>
As you can see, the IE parser considered the error to be at the
beginning of line 7 instead of at the end of line 6.&nbsp; However, it
was able to provide a column number.&nbsp; <i>(It also provides a nice
graphic display showing the location of the error.)</i><br>
<br>
<font color="#ff0000"><b>Wrapped exceptions</b></font><br>
<br>
As indicated in the earlier quotations from Sun, objects of the classes
<b>SAXException</b> and <b>SAXParseException</b> can wrap other
exceptions. &nbsp; The mechanism for getting and displaying the wrapped
exception, if any, is shown by the invocation of the <b>getException</b>
method on the <b>SAXParseException</b>
object in Listing 8.&nbsp; According to Sun, the <b>getException</b>
method,
which is inherited from <b>SAXException</b>, <i>"returns the embedded
exception,
if any."</i>&nbsp; The embedded exception is returned as type <b>Exception</b>.<br>
<br>
The screen output in Figure 4 indicates that there was no embedded
exception in this sample case.<br>
<br>
<font color="#ff0000"><b>The remaining exception handlers</b></font><br>
<br>
You can view the remaining exception handlers in Listing 9 near the end
of the lesson.&nbsp; There is nothing unusual about any of them.&nbsp;
Therefore, I won't discuss them in detail.<br>
<center>
<h2><a name="Run the program"></a>Run the Program</h2>
</center>
<p>I encourage you to copy the code and XML data from Listings 9, 10,
and 11 into your text editor.&nbsp; Compile the program and execute
it.&nbsp; Experiment with it, making changes, and observing the results
of your
changes.</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this second lesson on Java JAXP, I began by providing a brief
review of XSL and XSL Transformations (XSLT).<br>
</p>
<p>Then I showed you how to create an identity <b>Transformer</b>
object, and how to use that object to:<br>
</p>
<ul>
  <li>Display a DOM tree structure on the screen in XML format.</li>
  <li>Write the contents of a DOM tree structure into an output XML
file.</li>
</ul>
<p></p>
<p>Following that, I showed you how to write exception handlers that
provide meaningful information in the event of errors and exceptions,
with particular emphasis on parser errors and exceptions.<br>
</p>
<p></p>
<ul>
</ul>
<ul>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>In the next lesson, I will show you how to write a program to
display a DOM tree on the screen in a format that is much easier to
interpret than raw XML code.
</p>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listings</h2>
</center>
Complete listings of the Java class and the XML documents discussed in
this lesson are shown in Listings 9, 10, and 11 below.
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Xslt01.java<br>Copyright 2003 R.G.Baldwin<br><br>This is a modification of the program named<br>Dom02.java that was discussed in an earlier<br>lesson.  The program was modified to use an<br>identity XSLT transform to format the output XML<br>file in place of a call to Dom02Writer.  This<br>results in a much simpler program.<br><br>The program was also modified to display the<br>output XML on the Standard Output Device.<br><br>The program was also modified to provide<br>meaningful output in the event of an error.<br><br>This program shows you how to:<br><br>1. Create a Document object using JAXP, DOM, and<br>   an input XML file.<br>2. Create an identity XSL Transformer object.<br>3. Use the identity XSL Transformer object to<br>   display the XML represented by the Document<br>   object on the Standard Output Device.<br>3. Use the identity XSL Transformer object to<br>   write the XML represented by the Document<br>   object into an output file.<br><br>The input XML file name is provided by the user<br>as the first command-line argument.  The output<br>XML file name is provided by the user as the<br>second command-line argument.<br><br>The program instantiates a DOM parser object<br>based on JAXP.  The parser is configured in the<br>default non-validating configuration.<br><br>The program uses the parse() method of the parser<br>object to parse an XML file specified on the<br>command line.  The parse method returns an object<br>of type Document that represents the parsed XML<br>file.<br><br>Then the program gets a TransformerFactory object<br>and uses that object to get a default identity<br>Transformer object capable of performing a copy<br>of the source to the result.<br><br>Then the program uses the Document object to get<br>a DOMSource object that acts as a holder for a<br>transformation Source tree in the form of a<br>Document Object Model (DOM) tree.<br><br>Then the program gets a StreamResult object that<br>points to the standard output device.  This<br>object acts as a holder for a transformation<br>result.<br><br>Then the program uses the Transformer object,<br>the DOMSource object, and the StreamResult object<br>to transform the DOM tree to text and display it<br>on the standard output device.<br><br>Then the program gets another StreamResult object<br>that points to an output file, transforms the<br>DOM tree to text, and writes it into the output<br>file.<br><br>The program catches a variety of different types<br>of errors and exceptions and provides meaningful<br>output in the event of an error or exception.<br><br>Tested using SDK 1.4.2 and WinXP with two<br>differentan XML files.  The XML file named<br>Xslt01.xml is well formed, and reads as follows:<br><br>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br>The XML file named Xslt01bad.xml is not well<br>formed and reads as follows:<br><br>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;!--Following line missing &gt; --&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br>This file is purposely missing a right angle<br>bracket in the closing tag of a line element,<br>and is used to test for parser errors.<br><br>When processing the well formed XML file, the<br>program produces the following text on the<br>Standard Output Device:<br><br>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br>When processing the well formed XML file, the<br>program produces an output XML file that reads<br>as follows:<br><br>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br>When processing the bad XML file, the program<br>aborts with the following error message on the<br>standard error device:<br><br>SAXParseException<br>Public ID: null<br>System ID: file:C:/jnk/Xslt01bad.xml<br>Line: 7<br>Column:-1<br>Next character must be "&gt;" terminating<br>element "line".<br><br>Note that I manually inserted line breaks into<br>the error message above to force it to fit into<br>this narrow publication format.<br><br>************************************************/<br><br>import javax.xml.parsers.DocumentBuilderFactory;<br>import javax.xml.parsers.DocumentBuilder;<br>import org.w3c.dom.Document;<br><br>import<br>     javax.xml.parsers.FactoryConfigurationError;<br>import<br>  javax.xml.parsers.ParserConfigurationException;<br><br>import org.xml.sax.SAXException;<br>import org.xml.sax.SAXParseException;<br><br>import javax.xml.transform.Transformer;<br>import javax.xml.transform.TransformerFactory;<br>import javax.xml.transform.TransformerException;<br>import javax.xml.transform.<br>               TransformerConfigurationException;<br><br>import javax.xml.transform.dom.DOMSource;<br>import javax.xml.transform.stream.StreamResult;<br><br>import java.io.File;<br>import java.io.PrintWriter;<br>import java.io.FileOutputStream;<br><br><br>public class Xslt01 {<br><br>  public static void main(String argv[]){<br>    if (argv.length != 2){<br>      System.err.println(<br>        "usage: java Xslt01 fileIn fileOut");<br>      System.exit(0);<br>    }//end if<br><br>    try{<br>      //Get a factory object for DocumentBuilder<br>      // objects with default configuration.<br>      DocumentBuilderFactory docBuildFactory =<br>            DocumentBuilderFactory.newInstance();<br><br>      //Get a DocumentBuilder (parser) object<br>      DocumentBuilder parser =<br>            docBuildFactory.newDocumentBuilder();<br><br>      //Parse the XML input file to create a<br>      // Document object that represents the<br>      // input XML file.<br>      Document document = parser.parse(<br>                              new File(argv[0]));<br><br>      //Get a TransformerFactory object<br>      TransformerFactory xformFactory =<br>                TransformerFactory.newInstance();<br>      //Get an XSL Transformer object<br>      Transformer transformer =<br>                   xformFactory.newTransformer();<br>      //Get a DOMSource object that represents<br>      // the Document object<br>      DOMSource source = new DOMSource(document);<br><br>      //Get a StreamResult object that points to<br>      // the screen.  Then transform the DOM<br>      // sending XML to the screen.<br>      StreamResult scrResult =<br>                    new StreamResult(System.out);<br>      transformer.transform(source, scrResult);<br><br>      //Get an output stream for the output XML<br>      // file.<br>      PrintWriter outStream = new PrintWriter(<br>                  new FileOutputStream(argv[1]));<br><br>      //Get a StreamResult object that points to<br>      // the output file.  Then transform the DOM<br>      // sending XML to to the file<br>      StreamResult fileResult =<br>                     new StreamResult(outStream);<br>      transformer.transform(source, fileResult);<br>    }//end try block<br><br><br>    catch(SAXParseException saxEx){<br>      System.err.println("\nSAXParseException");<br>      System.err.println("Public ID: " +<br>                            saxEx.getPublicId());<br>      System.err.println("System ID: " +<br>                            saxEx.getSystemId());<br>      System.err.println("Line: " +<br>                          saxEx.getLineNumber());<br>      System.err.println("Column:" +<br>                        saxEx.getColumnNumber());<br>      System.err.println(saxEx.getMessage());<br><br>      Exception ex = saxEx;<br>      if(saxEx.getException() != null){<br>        ex = saxEx.getException();<br>        System.err.println(ex.getMessage());}<br>    }//end catch<br><br>    catch(SAXException saxEx){<br>      //This catch block may not be reachable.<br>      System.err.println("\nParser Error");<br>      System.err.println(saxEx.getMessage());<br><br>      Exception ex = saxEx;<br>      if(saxEx.getException() != null){<br>        ex = saxEx.getException();<br>        System.err.println(ex.getMessage());}<br>    }//end catch<br><br>    catch(ParserConfigurationException parConEx){<br>      System.err.println(<br>                        "\nParser Config Error");<br>      System.err.println(parConEx.getMessage());<br>    }//end catch<br><br>    catch(TransformerConfigurationException<br>                                     transConEx){<br>      System.err.println(<br>                   "\nTransformer Config Error");<br>      System.err.println(<br>                        transConEx.getMessage());<br><br>      Throwable ex = transConEx;<br>      if(transConEx.getException() != null){<br>        ex = transConEx.getException();<br>        System.err.println(ex.getMessage());}<br>    }//end catch<br><br>    catch(TransformerException transEx){<br>      System.err.println(<br>                       "\nTransformation error");<br>      System.err.println(transEx.getMessage());<br><br>      Throwable ex = transEx;<br>      if(transEx.getException() != null){<br>        ex = transEx.getException();<br>        System.err.println(ex.getMessage());}<br>    }//end catch}<br><br>    catch(Exception e){<br>      e.printStackTrace(System.err);<br>    }//end catch<br><br>  }// end main()<br>}// class Xslt01<br><br><b><font
 face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
A listing of the file named <b>Xslt01.xml</b> is provided in Listing
10 below.<br>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line&gt;<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
A listing of the file named <b>Xslt01bad.xml</b> is provided in
Listing 11 below.&nbsp; Note the missing right angle bracket at the end
of line 6.<br>
<p> </p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>&lt;?xml version="1.0"?&gt;<br>&lt;bookOfPoems&gt;<br>  &lt;poem PoemNumber="1" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are red,&lt;/line&gt;<br>    &lt;!--Following line missing &gt; --&gt;<br>    &lt;line&gt;Violets are blue.&lt;/line<br>    &lt;line&gt;Sugar is sweet,&lt;/line&gt;<br>    &lt;line&gt;and so are you.&lt;/line&gt;<br>  &lt;/poem&gt;<br>  &lt;?processor ProcInstr="Dummy"?&gt;<br>  &lt;!--Comment--&gt;<br>  &lt;poem PoemNumber="2" DumAtr="dum val"&gt;<br>    &lt;line&gt;Roses are pink,&lt;/line&gt;<br>    &lt;line&gt;Dandelions are yellow,&lt;/line&gt;<br>    &lt;line&gt;If you like Java,&lt;/line&gt;<br>    &lt;line&gt;You are a good fellow.&lt;/line&gt;<br>  &lt;/poem&gt;<br>&lt;/bookOfPoems&gt;<br><br><b><font
 face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p> </p>
<hr width="100%" size="2">
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or
in
part in any form or medium without express written permission from
Richard
Baldwin is prohibited. </p>
<h4> <a name="About the author"></a>About the author</h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java, C#,
and XML. In addition to the many platform and/or language independent
benefits of Java and C# applications, he believes that a combination of
Java, C#, and XML will become the primary driving force in the delivery
of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects, and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's
Programming <a href="http://www.dickbaldwin.com/">Tutorials</a>, which
has gained a worldwide following among experienced and aspiring
programmers. He has also published articles in JavaPro magazine.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University
and has many years of experience in the application of computer
technology to real-world problems.</i> </p>
<p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p>-end- <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
