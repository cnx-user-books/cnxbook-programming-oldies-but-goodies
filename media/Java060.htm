<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Access Control and Inheritance in Java by Richard G. Baldwin </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MSOFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!doctype html public "-//w3c//dtd html 4.0 transitional//en"><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Core Java Classes, Input and Output Streams<!--endTitle--></H2>
<P>Java Programming, Lesson # 60, Revised 10/11/98. </P>
<P><!-toc file=Java060a.htm words=Preface-><A HREF="#Preface">Preface</A> <BR>
<!--endtoc--><!-toc file=Java060b.htm words=Introduction-><A HREF="#Introduction">Introduction</A> <BR>
<!--endtoc--><!-toc file=Java060c.htm words=Getting Started with I/O Streams-><A HREF="#GettingStartedwithIOStreams">Getting Started with I/O Streams</A> <BR>
<!--endtoc--><!-toc file=Java060d.htm words=Hierarchy Diagrams for I/O Streams-><A HREF="#HierarchyDiagramsforIOStreams">Hierarchy Diagrams for I/O Streams</A> <BR>
<!--endtoc--><!-toc file=Java060e.htm words=Filtered Streams-><A HREF="#FilteredStreams">Filtered Streams</A> <BR>
<!--endtoc--><!-toc file=Java060f.htm words=Miscellaneous Classes-><A HREF="#MiscellaneousClasses">Miscellaneous Classes</A> <BR>
<!--endtoc--><!-toc file=Java060g.htm words=Interfaces-><A HREF="#Interfaces">Interfaces</A> <BR>
<!--endtoc--><!-toc file=Java060h.htm words=Reading and Writing Files using Streams-><A HREF="#ReadingandWritingFilesusingStreams">Reading and Writing Files using Streams</A> <BR>
<!--endtoc--><!-toc file=Java060i.htm words=Implementing Pipes using Streams-><A HREF="#ImplementingPipesusingStreams">Implementing Pipes using Streams</A> <BR>
<!--endtoc--><!-toc file=Java060j.htm words=Using Filtered Streams-><A HREF="#UsingFilteredStreams">Using Filtered Streams</A> <BR>
<!--endtoc--><!-toc file=Java060k.htm words=Reading and Writing Memory Buffers using Streams-><A HREF="#ReadingandWritingMemoryBuffersusing">Reading and Writing Memory Buffers using Streams</A> <BR>
<!--endtoc--><!-toc file=Java060l.htm words=Creating Your Own Filtered Stream Classes-><A HREF="#CreatingYourOwnFilteredStream">Creating Your Own Filtered Stream Classes</A> <BR>
<!--endtoc--><!-toc file=Java060m.htm words=Reading and Writing Random Access Files-><A HREF="#ReadingandWritingRandomAccessFiles">Reading and Writing Random Access Files</A> <BR>
<!--endtoc--><!-toc file=Java060n.htm words=Reader and Writer Classes-><A HREF="#ReaderandWriterClasses">Reader and Writer Classes</A> <BR>
<!--endtoc--><!-toc file=Java060o.htm words=Review-><A HREF="#Review">Review</A></P>
<P><!--endtoc--></P>
<!-next=Java060a.htm><!-first=Java060.htm->
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Intermediate Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson. </P>
<P>As of 1/9/98 the programs named files02.java and stream02.java still use deprecated APIs from JDK 1.0.2. However, the programs named SampProg151 and SampProg152 in the Review section at the end of the lesson show how to rewrite these two programs and eliminate the use of deprecated APIs. </P>
<P>The Java 1.1 class library provides <U>two</U> different types of I/O classes -- <U>byte-oriented</U> and <U>character-oriented</U>. </P>
<P>The two types of streams are organized into two separate class hierarchies, one consisting of the <U>byte-oriented</U> stream classes, and the other consisting of <U>character-oriented</U> stream classes. The classes within the two hierarchies have the same names, <U>except for their suffix</U>. </P>
<P>The byte-oriented stream classes end in either <I>InputStream</I> or <I>OutputStream</I>, while the character-oriented stream classes end in either <I>Reader</I> or <I>Writer</I>. </P>
<P>The two hierarchies are functionally almost identical, and they contain most of the same subclass specializations. </P>
<P>Most of the programs in this lesson use <I>InputStream</I> or <I>OutputStream</I>. However, the two program mentioned above that illustrate how to eliminate deprecated APIs use the <I>Reader</I> and <I>Writer</I> classes for character-oriented data. Also, a good reference for learning more about this topic is the article entitled <U>Use the two "R"s of Java 1.1 -- Readers and Writers</U> - JavaWorld - November 1997. </P>
<P>In September of 1998, a new section was added near the end of this lesson that deals with the new <B>Reader</B> and <B>Writer</B> classes.&nbsp; It contains one sample program that shows how to convert the sample program named <B>files02.java</B> into a character-stream program using <B>Reader</B> and <B>Writer</B> classes. </P>
<P>A good reference for learning more about this topic is the article entitled <U>Use the two "R"s of Java 1.1 -- Readers and Writers</U> - JavaWorld - November 1997. </P>
<P>Several new classes were added to JDK 1.1 that deal with I/O of entire objects. The names of the classes usually contain the word Object. Some of these classes are discussed in a subsequent lesson on object serialization. </P>
<P><!-prev=Java060.htm-><!-next=Java060b.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Introduction"></A>Introduction</H2>
</FONT><P>According to <U>The Java Tutorial</U> by Mary Campione and Kathy Walrath, http://java.sun.com/books/Series/Tutorial/java/io/index.html <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>"A stream is a flowing sequence of characters."</TD>
</TR>
</TABLE>

<P>Usually the task is to move data from memory to an external device or vice versa, but not necessarily. Streams can also be used to move data from one part of memory to another part of memory just as well. </P>
<P>It has been said that through the use of streams, it is the <U>responsibility of the computer</U> to move bytes from one place to another <U>without regard for the meaning</U> associated with those bytes. </P>
<P>It is the <U>responsibility of the programmer</U> to <U>assign meaning</U> to the bytes. </P>
<P>For example, a group of 32 bytes could represent 32 pieces of graphic data, or 8 integer values; the stream I/O system <U>doesn't</U> usually <U>know</U> and <U>doesn't care</U>. </P>
<U><P>Only</U> the <U>programmer</U> and the <U>user know and care</U> what the 32 bytes are meant to represent. </P>
<P>In other words, a stream is usually considered to be an <U>abstraction</U> for the capability to move bytes from a <U>source to a sink</U>. </P>
<P>We have previously seen examples of moving bytes from the <U>keyboard</U> (standard input device) to the computer's <U>memory</U>, and have seen examples of moving bytes from the computer's <U>memory</U> to the <U>screen</U> (standard output device). </P>
<P>We have also touched on the need to move bytes between <U>disk files</U> and the computer's <U>memory</U>. </P>
<P>In a later lesson, we will look at the requirement for and the techniques available to move bytes between the <U>memory</U> and a <U>network</U>. </P>
<U><P>All of these examples involve the use of streams</U>. </P>
<P>The package named <B><I>java.io</I> </B>contains a set of input and output stream classes that can be used to read and write data. </P>
<P>The <B><I>InputStream</I> </B>class and <B><I>OutputStream</I> </B>class are <I>abstract </I>superclasses that define the behavior for <U>sequential</U> input and output streams in Java. </P>
<P>The <B><I>java.io</B></I> package also provides <U>specialized</U> InputStream and OutputStream subclasses that are used for specialized types of input and output. </P>
<P>We will examine each of the classes, discuss how to <U>use</U> them, and how to <U>subclass</U> them for your own purposes. </P>
<P><!-prev=Java060a.htm-><!-next=Java060c.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="GettingStartedwithIOStreams"></A>Getting Started with I/O Streams</H2>
</FONT><P><A HREF="#TheOutputStreamClass">The Output Stream Class</A> <BR>
<A HREF="#ThePrintStreamClass">The PrintStream Class</A> <BR>
<A HREF="#ReferenceMaterial">Reference Material</A> <BR>
<A HREF="#StandardInput">Standard Input</A></P>
<P>You are already familiar with the use of standard input, standard output, and standard error as provided by the System class. </P>
<P>For example, we have been using the following code fragments since the beginning of the Introductory course: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<P><TT>System.out.println("my output string");</TT> </P>
<TT><PRE>While (System.in.read() != -1) ...</PRE></TT></TD>
</TR>
</TABLE>

<P>According to <U>The Java Tutorial</U>: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><B>System.out</B> refers to an output stream managed by the <B>System </B>class that implements the <U>standard output system</U>.</TD>
</TR>
</TABLE>

<B><P>System.out</B> is an instance (an object) of the <B>PrintStream </B>class defined in the <I>java.io</I> package. The <B>PrintStream</B> class is a subclass of <B>OutputStream</B>. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="TheOutputStreamClass"></A>The OutputStream Class</H3>
</FONT><P>According to <U>Java in a Nutshell</U> by David Flanagan, the <B>OutputStream</B> class is an abstract class which is the <I>superclass </I>of all output streams. It defines the <U>basic output methods</U> that all output streams provide. The following methods are defined in the <B>OutputStream</B> class. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><B><TT>close()</B> - Closes the stream.&nbsp;</TT> <BR>
<B><TT>flush()</B> - Flushes the stream.&nbsp;</TT> <BR>
<B><TT>write(int)</B> - Writes a byte.&nbsp;</TT> <BR>
<B><TT>write(byte[])</B> - Writes an array of bytes.&nbsp;</TT> <BR>
<B><TT>write(byte[], int, int)</B> - Writes a sub array of bytes.</TT></TD>
</TR>
</TABLE>

<P>. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ThePrintStreamClass"></A>The PrintStream Class</H3>
</FONT><P>The Java specification, which is available on-line at JavaSoft, http://java.sun.com/ provides the following description for the PrintStream class: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A <B>PrintStream </B>adds functionality to another output stream -- namely, the ability to print representations of various data values conveniently.&nbsp; </P>
<P>Two other features are provided as well. Unlike other output streams, a <B>PrintStream </B>never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested by the checkError method.&nbsp; </P>
<P>Optionally, a <B>PrintStream </B>can be created so as to "autoflush"; this means that after an array of bytes is written, or after a single byte equal to '\n' is written, the flush method is automatically invoked.</TD>
</TR>
</TABLE>

<P>The following methods are included in the list of methods available to objects of the <B>PrintStream </B>class of which the <B>out</B> object in the <B>System</B> class is an instance. </P>
<U><P>These are the methods of the <B>System.out</B> stream object</U>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><B>checkError()</B> - Flushes the print stream and returns whether or not there was&nbsp; <BR>
an error on the output stream.&nbsp; <BR>
<B>close()</B> - Closes the stream.&nbsp; <BR>
<B>flush()</B> - Flushes the stream.&nbsp; </P>
<B><P>print(</B><I>various argument types</I><B>)</B> - Prints the argument.&nbsp; </P>
<B><P>println(</B><I>various argument types</I><B>)</B> - Prints the argument.&nbsp; <BR>
<B>println(String) <I>Prints a string followed by a newline.&nbsp;</B></I> </P>
<B><P>write(int)</B> - Writes a byte.&nbsp; <BR>
<B>write(byte[], int, int)</B> - Writes a sub array of bytes.</TD>
</TR>
</TABLE>

<P>The <B>println(String)</B> method which we have used extensively in example programs in previous lessons is highlighted in <B>boldface </B>above. There are many other available methods as well. </P>
<P>Recall that when we first used <B>System.out.println(String)</B>, we explained that we were invoking the <B>println()</B><TT> </TT>method of the <B>out </B>object which is a <I>class variable</I> of the <B>System </B>class. </P>
<P>Since the <B>out </B>object is of type <B>PrintStream</B>, all of the methods listed above are available to the <B>out </B>object. </P>
<P>Because it is a class variable, we can access it and its methods <U>without</U> first <U>instantiating an object</U> of the <B>System </B>class. </P>
<U><P>Java in a Nutshell</U> indicates that the <B>PrintStream </B>class extends a class known as <B>FilterOutputStream</B>. We will deal with filtering later in this lesson. </P>
<P>Note that the <B>System</B> class is not part of <I>java.io</I>. Rather, it is part of <I>java.lang</I>. </P>
<P>The hierarchy relative to the object named <B>out</B> is <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">

<UL>
<LI><B>Object </B>is the class from which all other classes are derived&nbsp; </LI>

<UL>
<B><LI>OutputStream </B>is a subclass of <I>Object</I>.&nbsp; </LI>

<UL>
<B><LI>FilterOutputStream </B>is a subclass of <I>OutputStream.</I>&nbsp; </LI>

<UL>
<B><LI>PrintStream </B>is a subclass of <I>FilterOutputStream</I>.&nbsp; </LI>

<UL>
<B><LI>System </B>contains a <I>class variable </I>named <B>out </B>of type <I>PrintStream</I>.&nbsp; </UL>
</UL>
</UL>
</UL>
</UL>
</TD>
</TR>
</TABLE>

<U><P>All </U>classes in Java are subclasses of <B>Object </B>at some level. Each level of inheritance between the class named <B>Object </B>and the <I>class variable</I> named <B>out </B>adds methods and variables. The object named <B>out </B>contains all the methods and variables contributed by all of its ancestors. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ReferenceMaterial"></A>Reference Material</H3>
</FONT><P>Part of the difficulty of programming in Java is establishing and understanding class hierarchies as described above. <U>Java in a Nutshell</U> is an excellent reference in this regard. Another excellent reference is the Windows-compatible help file published by Bill Bercik at (site no longer valid). </P>
<P>The <U>Java language Specification</U>, the <U>API Specification</U>, and a lot of other useful information is also available at <B>Sun's JavaSoft</B> page http://java.sun.com/ in other formats. </P>
<P>You should avail yourself of one or more of these sources plus other good sources that you identify if you plan to program successfully in Java. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="StandardInput"></A>Standard Input</H3>
</FONT><P>Now let's examine the following commonly-used code fragment with an eye toward the hierarchy. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>While (System.in.read() != -1) ...</PRE></TT></TD>
</TR>
</TABLE>

<P>Here, we are invoking the <B>read()</B> method of the object referred to by <B>in </B>which is a class variable of the <B>System </B>class. The <B>System </B>class has three class variables: </P>

<UL>
<B><I><LI>err </B></I>which is of type <B>PrintStream</B> </LI>
<B><I><LI>out </B></I>which is also of type <B>PrintStream</B> </LI>
<B><I><LI>in </B></I>which is of type <B>InputStream</B> </LI></UL>

<P>As seen in an earlier lesson, the <B>System </B>class also has about a dozen class methods which can be invoked without a requirement to instantiate an object of the class. </P>
<P>The <B>InputStream</B> class (of which the object referenced by <B>in</B> is an instance) is a subclass of the <B>Object</B> class and has considerably fewer methods than the <B>PrintStream</B> class (of which the object referenced by <B>out </B>is an instance). </P>
<P>The <B>InputStream</B> contains three overloaded public versions of <B>read()</B>; the one shown above and two which deal with arrays of type <B>byte</B>. All three throw <B>IOException</B>. </P>
<P>Peter Norton's <U>Guide to Java Programming</U> indicates that the form of <B>read()</B> which takes no arguments attempts to read and return a single byte from the input stream, <U>cast as an integer</U>. If there is nothing more to be read, it returns a -1. The fact that the byte is returned <U>cast as an integer</U> needs to be taken into account when using this method. </P>
<P>The following description of the <B>read()</B> method which takes no parameters comes from JavaSoft's Java Language specification (emphasis added by this author). <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>The general contract of read is that it <U>reads one byte</U> from the input stream. The byte is returned as an <U>integer </U>in the range 0 to 255 (0x00-0xff). If no byte is available because the stream is at end of file, <U>the value -1 is returned</U>.&nbsp; </P>
<P>This method blocks until input data is available, end of file is detected, or an exception is thrown.&nbsp; </P>
<P>If the byte cannot be read for any reason other than end of file, an IOException is thrown. In particular, an IOException is thrown if the input stream has been closed</TD>
</TR>
</TABLE>

<P>Similar material regarding the other overloaded versions of the <B>read()</B> method is also available in the <U>Java Language Specification</U>. </P>
<P>The hierarchy for the object <B>in</B> is (approximately) <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">

<UL>
<LI><B>Object </B>is the class from which all other classes are derived&nbsp; </LI>

<UL>
<B><LI>InputStream </B>is an abstract subclass of the class <I>Object</I>&nbsp; </LI>

<UL>
<B><LI>in </B>is a <I>class </I>variable of type <I>InputStream</I>&nbsp; </UL>
</UL>
</UL>
</TD>
</TR>
</TABLE>

<P>While we know that it is not possible to instantiate objects of abstract classes (such as <B>InputStream</B>), this structure suggests that it is possible to define <I>class</I> variables (such as <B>in)</B> which reference abstract classes, which in turn causes the <I>class</I> methods of the abstract class to become available by way of the <I>class</I> variable. </P>
<P>According to <U>Java in a Nutshell</U>, <B>InputStream </B>is the superclass of all input streams and it defines the basic input methods that all input stream classes provide. <BR>
&nbsp; <BR>
&nbsp; </P>
<P><!-prev=Java060b.htm-><!-next=Java060d.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="HierarchyDiagramsforIOStreams"></A>Hierarchy Diagrams for I/O Streams</H2>
</FONT><P><A HREF="#FileInputStream">FileInputStream</A> <BR>
<A HREF="#FileOutputStream">FileOutputStream</A> <BR>
<A HREF="#PipedInputStream">PipedInputStream</A> <BR>
<A HREF="#PipedOutputStream">PipedOutputStream</A> <BR>
<A HREF="#ByteArrayInputStream">ByteArrayInputStream</A> <BR>
<A HREF="#ByteArrayOutputStream">ByteArrayOutputStream</A> <BR>
<A HREF="#SequenceInputStream">SequenceInputStream</A> <BR>
<A HREF="#StringBufferInputStream">StringBufferInputStream</A></P>
<P>Most of the other classes in the <I>java.io</I> package derive from two classes: <B>InputStream </B>and <B>OutputStream</B> (also see the comment in the <B>Preface</B> section regarding <I>readers</I> and <I>writers</I>) </P>
<P>The <B>InputStream </B>class defines methods for </P>

<UL>
<LI>reading bytes or arrays of bytes </LI>
<LI>marking locations in the stream </LI>
<LI>skipping bytes of input </LI>
<LI>finding out the number of bytes available for reading </LI>
<LI>resetting the current position within the stream. </LI></UL>

<B><P>OutputStream </B>defines methods for writing bytes or arrays of bytes to the stream. </P>
<P>Input and output streams are automatically opened when you instantiate an object of the proper type. Several example programs will be provided later which show the opening of input and output streams. </P>
<P>You can close an input stream or an output stream by using the <B>close()</B> method. Otherwise, it will be closed when the stream object is garbage collected. </P>
<P>Recall that objects become eligible for garbage collection when they are no longer referenced by an object reference variable but there is generally no guarantee that garbage collection will occur before the program terminates. </P>
<P>Both <B>InputStream </B>and <B>OutputStream </B>have several subclasses that implement specific input and output functions. </P>
<P>The hierarchy structure for <B>InputStream </B>is shown in the first of the following two diagrams. </P>
<P>The hierarchy structure for <B>OutputStream </B>is shown in the second diagram. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>Object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FilterInputStream (abstract)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LineNumberInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PushbackInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByteArrayInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SequenceInputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBufferInputStream</PRE></TD>
</TR>
</TABLE>

<P>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>Object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedOutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FilterOutputStream (abstract)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedOutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByteArrayOutputStream</PRE></TD>
</TR>
</TABLE>

<P>A non-exhaustive description of some of the classes in the above diagram follows. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="FileInputStream"></A>FileInputStream</H3>
</FONT><P>This is a subclass of <B>InputStream </B>that reads data from a file specified by name or by a <B>File </B>or <B>FileDescriptor </B>object. While it is possible to read data using objects of this class, it is more common to use an object of type <B>DataInputStream </B>which is a type of <B>FilterInputStream </B>that allows you to read lines of text and Java primitive data types in a portable way. </P>
<P>You can create a <B>DataInputStream </B>by specifying the InputStream that is to be filtered in the call to the constructor. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="FileOutputStream"></A>FileOutputStream</H3>
</FONT><P>This is a subclass of <B>OutputStream </B>that writes data to a file specified by name or by a <B>File </B>or <B>FileDescriptor </B>object. This is a low-level class. You would typically use a <B>DataOutputStream </B>or <B>PrintOutputStream </B>to filter output to a <B>FileOutputStream</B>. <B>DataOutputStream </B>is a subclass of <B>FilterOutputStream </B>that allows you to write Java primitive data types in a portable way. </P>
<P>You can create a <B>DataOutputStream </B>by specifying the <B>OutputStream </B>that is to be filtered in the call to the constructor. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="PipedInputStream"></A>PipedInputStream</H3>
</FONT><P>This class is an <B>InputStream </B>that implements one-half of a <B><I>pipe</B></I>, and is useful for <U>communication between threads</U>. A <B>PipedInputStream </B>must be connected to a <B>PipedOutputStream </B>object, which may be specified when the <B>PipedInputStream </B>is created, or with the <B>connect() </B>method. </P>
<P>Data read from a <B>PipedInputStream </B>object is received from the <B>PipedOutputStream </B>to which it is connected. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="PipedOutputStream"></A>PipedOutputStream</H3>
</FONT><P>Implements the other half of a <B><TT>pipe </B></TT>(see <B>PipedInputStream </B>above). Similar connection requirement apply. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ByteArrayInputStream"></A>ByteArrayInputStream</H3>
</FONT><P>An object of this class provides input data from a specified array of byte values. This is useful when you want to read data in memory as if it were coming from a file, pipe, or socket. (Similar to a <B>StringBufferInputStream</B>.) </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="ByteArrayOutputStream"></A>ByteArrayOutputStream</H3>
</FONT><P>Data that is written is stored in an internal byte array which <U>grows as necessary</U>, and can be retrieved using <B>toByteArray()</B> or <B>toString()</B>. </P>
<P>The <B>reset()</B> method discards any data currently stored in the array and begins storing data from the beginning. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="SequenceInputStream"></A>SequenceInputStream</H3>
</FONT><P>Provides a way to concatenate the data from two or more input streams. Provides an interface to a sequence of <B>InputStream </B>objects. Data is read from the streams in the order in which the streams are specified. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="StringBufferInputStream"></A>StringBufferInputStream</H3>
</FONT><P>Data comes from the characters of a specified <B>String </B>object. Useful to read data from memory as if it were coming from a file, a pipe, or a socket. (Similar to <B>ByteArrayInputStream</B>.) </P>
<P><!-prev=Java060c.htm-><!-next=Java060e.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="FilteredStreams"></A>Filtered Streams</H2>
</FONT><P><A HREF="#DataInputStream">DataInputStream</A> <BR>
<A HREF="#BufferedInputStream">BufferedInputStream</A> <BR>
<A HREF="#LineNumberInputStream">LineNumberInputStream</A> <BR>
<A HREF="#PushbackInputStream">PushbackInputStream</A> <BR>
<A HREF="#BufferedOutputStream">BufferedOutputStream</A> <BR>
<A HREF="#PrintStream">PrintStream</A> <BR>
<A HREF="#DataOutputStream">DataOutputStream</A></P>
<P>The following classes derive from <B>FilterInputStream </B>and <B>FilterOutputStream </B>which are both abstract classes. These classes define the interface for filtered streams which process data as it's being read or written. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="DataInputStream"></A>DataInputStream</H3>
</FONT><P>Allows you to read lines of text and Java primitive data types in a portable way. Possibly the most commonly used class for file input. A <B>DataInputStream</B> object provides facilities for reading bytes from an input source and interpreting specific character sequences as representing data of diverse types. Many methods for translating from byte sequences to data types are described in the Java Language Specification. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="BufferedInputStream"></A>BufferedInputStream</H3>
</FONT><P>Provides input data buffering which increases efficiency by reading in large amounts of data and storing them in an internal buffer. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="LineNumberInputStream"></A>LineNumberInputStream</H3>
</FONT><P>Keeps track of the number of lines of data that have been read. The <B>getLineNumber()</B> method returns the current line number. The <B>setLineNumber()</B> method sets the line number of the current line and subsequent lines are numbered starting from that number. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="PushbackInputStream"></A>PushbackInputStream</H3>
</FONT><P>Implements a one-byte pushback buffer. The <B>unread()</B> method "pushes" one character back into the stream, which will be the first one read by the next call to a <B>read()</B> method. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="BufferedOutputStream"></A>BufferedOutputStream</H3>
</FONT><P>Provides output data buffering which increases efficiency by storing values to be written in a buffer and actually writing them out when the buffer fills or when the <B>flush()</B> method is called. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="PrintStream"></A>PrintStream</H3>
</FONT><P>A <B>PrintStream </B>adds functionality to another output stream -- namely, the ability to print representations of various data values conveniently. More detailed information regarding this class was provided earlier in this lesson. </P>
<P>Note that according to <U>Java in a Nutshell</U>, this method <U>does not handle Unicode</U> data. The class discards the top 8 bits of all 16-bit Unicode characters. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="DataOutputStream"></A>DataOutputStream</H3>
</FONT><P>Provides facilities for converting data of diverse types into character sequences of specific formats that are then sent to some output stream. </P>
<P><!-prev=Java060d.htm-><!-next=Java060f.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="MiscellaneousClasses"></A>Miscellaneous Classes</H2>
</FONT><P><A HREF="#File">File</A> <BR>
<A HREF="#FileDescriptor">FileDescriptor</A> <BR>
<A HREF="#RandomAccessFile">RandomAccessFile</A> <BR>
<A HREF="#StreamTokenizer">StreamTokenizer</A></P>
<P>The <B>java.io</B> package contains other classes in addition to the stream classes. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="File"></A>File</H3>
</FONT><P>Provides a platform-independent definition of file and directory names. Also provides methods useful for performing a number of utility operations on files. For example, you can create a <B>File </B>object for a file on the native file system and then query the object for information about that file (such as its full pathname). </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="FileDescriptor"></A>FileDescriptor</H3>
</FONT><P>Platform independent representation of a low-level handle to an open file or an open socket. According to the <U>Java Language Specification</U> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A FileDescriptor is an opaque representation of a connection to an actual file in a file system, or to a network socket, or to another source or sink of bytes. The main practical use for a file descriptor is to create a <B>FileInputStream </B>or <B>FileOutputStream </B>to contain it.</TD>
</TR>
</TABLE>

<P>. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="RandomAccessFile"></A>RandomAccessFile</H3>
</FONT><P>Allows reading and writing of arbitrary bytes, text, and primitive Java data types from or to any specified location in a file. Not a subclass of <B>InputStream </B>or <B>OtputStream</B>. Rather <B>RandomAccessFile</B> is an entirely independent method for reading and writing data from and to files. A large number of methods are provided. </P>
<P>You may have noticed that unlike other languages, thus far, we have not made mention of an ability to append data to an existing file. In order to append data to an existing file in Java, you must treat it as a random access file. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="StreamTokenizer"></A>StreamTokenizer</H3>
</FONT><P>Performs lexical analysis of a specified input stream and breaks the contents of a stream into tokens. </P>
<P><!-prev=Java060e.htm-><!-next=Java060g.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Interfaces"></A>Interfaces</H2>
</FONT><P><A HREF="#DataInput">DataInput</A> <BR>
<A HREF="#DataOutput">DataOutput</A> <BR>
<A HREF="#FilenameFilter">FilenameFilter</A></P>
<P>The java.io package defines three interfaces which are implemented by a variety of classes. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="DataInput"></A>DataInput</H3>
</FONT><P>Declares the methods required for streams that can read character data or Java primitive data types in a machine-independent format. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="DataOutput"></A>DataOutput</H3>
</FONT><P>Declares the methods required for streams that can write character data or Java primitive data types in a machine-independent format. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="FilenameFilter"></A>FilenameFilter</H3>
</FONT><P>Declares the <B>accept()</B> method that must be implemented by any object that filters filenames (selects a subset of filenames from a list of filenames). </P>
<P><!-prev=Java060f.htm-><!-next=Java060h.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ReadingandWritingFilesusingStreams"></A>Reading and Writing Files using Streams</H2>
</FONT><P>To perform file I/O in Java, you must instantiate a stream object of the appropriate type and link it to a device. </P>
<P>As you can see from the following program, writing and reading sequential files in Java is fairly straightforward. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File files01.java Copyright 1997, R.G.Baldwin
This application illustrates writing and then reading a&nbsp;
file one byte at a time.

The instantiation of a file stream object is illustrated&nbsp;
using two different approaches:
1.&nbsp; Using a literal string containing the name of the file.
2.&nbsp; Using an object of type File containing the name of&nbsp;
the file.

Also illustrates use of the methods of the File class to
inquire about the properties of the file:&nbsp; absolute path&nbsp;
and length.

The output from the program is:

<B>Start the program and write a file
Get info on, read, and print the file
Path is C:\BALDWIN\Java\SampProg\Java\junk.txt
Length 4
Dick
End of program
</B>**********************************************************/

import java.io.*;

class files01{
&nbsp; public static void <B>main</B>(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp; //Instantiate and initialize an output file stream&nbsp;
&nbsp;&nbsp;&nbsp; // object using a string containing the name of the&nbsp;
&nbsp;&nbsp;&nbsp; // file.
&nbsp;&nbsp;&nbsp; FileOutputStream outFile =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>new FileOutputStream("junk.txt")</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Write four bytes to the file and close it
&nbsp;&nbsp;&nbsp;<B> outFile.write('D')</B>;
&nbsp;&nbsp;&nbsp; outFile.write('i');
&nbsp;&nbsp;&nbsp; outFile.write('c');
&nbsp;&nbsp;&nbsp; outFile.write('k');
&nbsp;&nbsp;&nbsp; outFile.close();
&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Get info on, read, and print the file");
&nbsp;&nbsp;
&nbsp; //Instantiate an object of type file containing the name
&nbsp; // of the file.
&nbsp; File junkFile = <B>new File("junk.txt")</B>;
&nbsp;&nbsp;
&nbsp; //Use the File object to get info about the file
&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Path is " + junkFile.<B>getAbsolutePath()</B>);
&nbsp; System.out.println("Length " + junkFile.<B>length()</B> );
&nbsp;&nbsp;
&nbsp; //Now read and print the data in the file
&nbsp; try{
&nbsp;&nbsp;&nbsp; //Instantiate and initialize the stream object using&nbsp;
&nbsp;&nbsp;&nbsp; // the File object.
&nbsp;&nbsp;&nbsp; FileInputStream inFile = <B>new FileInputStream(junkFile)</B>;
&nbsp;&nbsp;&nbsp; int data;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Read and print until eof indicated by -1.&nbsp; read()&nbsp;
&nbsp;&nbsp;&nbsp; // method returns integer.&nbsp; Must cast as char to print.
&nbsp;&nbsp;&nbsp; // Otherwise, the numeric value of the byte is&nbsp;
&nbsp;&nbsp;&nbsp; // displayed.
&nbsp;&nbsp;&nbsp; while( <B>(data = inFile.read()) != -1</B>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)data);
&nbsp;&nbsp;&nbsp; inFile.<B>close()</B>;
&nbsp; }catch(IOException e){}
&nbsp; System.out.println(); //new line
&nbsp; System.out.println("End of program");
&nbsp; }// end main

}//end class files01 definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060g.htm-><!-next=Java060i.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ImplementingPipesusingStreams"></A>Implementing Pipes using Streams</H2>
</FONT><P>Pipes may be used to cause the output of one thread in a program to feed into the input of another thread. The input and output components of a pipe are implemented by <B>PipedInputStream </B>and <B>PipedOutputStream</B>. </P>
<P>The following application instantiates and runs two threads. One of the threads places integer data into a <B>PipedOutputStream </B>object which is connected to a <B>PipedInputStream</B> object. The other thread receives its input from the <B>PipedInputStream</B> object. </P>
<P>The thread which generates the integers implements a random time delay between the output of successive integers to allow the other thread an opportunity to gain control of the system. Otherwise, depending on the platform being used, the first thread might hog the system until it completes its task. (Some implementations of the JVM provide for time-slicing between threads of equal priority while other implementations do not.) </P>
<P>The thread which receives the integers terminates when it receives a -1 from the input object indicating end of file. Note that the end of file is <U>generated automatically</U> by the system when the thread that generates the integers completes its task. </P>
<P>A main function is used to instantiate the stream objects, instantiate the thread objects, and start the threads running. </P>
<P>There are a couple of interesting things to note about this program. First, it implements an operation very similar to the <I>producer/consumer</I> program in an earlier lesson on interrupts, but in a much simpler way. </P>
<P>Second, even though all three threads have <I>finalizer</I> methods that announce that the thread is being finalized (immediately prior to garbage collection) there is no finalizer message produced by the main thread. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File pipe01.java Copyright 1997, R.G.Baldwin
This Java application illustrates the piping of the output
from one thread to the input of another thread.

The SenderThread sends the integers 0, 1, 2, and 3 with&nbsp;
pauses in between.&nbsp; The ReceiverThread receives and sums&nbsp;
the integers.

The actual sequence of data in the output depends on the&nbsp;
values obtained from the random number generator used to&nbsp;
produce pauses.&nbsp;&nbsp;

Tested using JDK 1.1.3 under Win95.

For one particular run, the output was as&nbsp;
follows:

<B>Starting SenderThread
Sending 0
Starting ReceiverThread
Received 0
Sum = 0
Sending 1
Received 1
Sum = 1
Sending 2
Sending 3
Received 2
Sum = 3
Received 3
Sum = 6
SenderThread done
ReceiverThread done, sum = 6
Finalizing sender thread
Finalizing receiver thread
</B>**********************************************************/
import java.io.*;

class <B>SenderThread extends Thread</B>{
&nbsp; //Piped output stream obj init by constructor
&nbsp; PipedOutputStream <B>pos</B>;&nbsp;

&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Constructor
&nbsp; public SenderThread(PipedOutputStream <B>posIn</B>){
&nbsp;&nbsp;&nbsp; pos = posIn; //save piped output stream object
&nbsp; }//end SenderThread constructor
&nbsp; //-----------------------------------------------------//

&nbsp; public void <B>run()</B>{ //this method runs as a thread
&nbsp;&nbsp;&nbsp; System.out.println("Starting SenderThread");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; 4; i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //write a byte to the piped output stream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>pos.write(i)</B>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Sending " + i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{//sleep for awhile
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep((int)(Math.random() * 1000));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(InterruptedException e){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("SenderThread done");
&nbsp; }//end run() method
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public void <B>finalize()</B>{
&nbsp;&nbsp;&nbsp; System.out.println("Finalizing sender thread");
&nbsp; }//end finalize
&nbsp; //-----------------------------------------------------//

}//end SenderThread class definition
//=======================================================//


class <B>ReceiverThread extends Thread</B>{
&nbsp; //piped input stream obj init by constructor
&nbsp; PipedInputStream inputStream;&nbsp;
&nbsp; int sum = 0, inData = 0; //working variables
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Constructor
&nbsp; public ReceiverThread(PipedInputStream <B>inStream</B>){
&nbsp;&nbsp;&nbsp; //save piped input stream object
&nbsp;&nbsp;&nbsp; <B>inputStream = inStream</B>;&nbsp;
&nbsp; }//end ReceiverThread constructor
&nbsp; //-----------------------------------------------------//

&nbsp; public void <B>run()</B>{ //this method runs as a thread
&nbsp;&nbsp;&nbsp; System.out.println("Starting ReceiverThread");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read the first byte as an integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData = <B>inputStream.read()</B>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Received " + inData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (inData != -1){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read until integer -1 signals no more data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += inData; //accumulate the sum
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Sum = " + sum);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read next byte as an integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>inData = inputStream.read()</B>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Received " + inData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ReceiverThread done, sum = " + sum);
&nbsp; }//end run() method
&nbsp;&nbsp;
&nbsp; public void <B>finalize()</B>{
&nbsp;&nbsp;&nbsp; System.out.println("Finalizing receiver thread");
&nbsp; }//end finalize
&nbsp; //-----------------------------------------------------//

}//end ReceiverThread class definition
//=======================================================//

class pipe01{ //controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; System.runFinalizersOnExit(true);
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a PipedInputStream object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedInputStream <B>inStr = new PipedInputStream()</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a PipedOutputStream object and connect&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // it to the existing PipedInputStream object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedOutputStream pos =<B> new PipedOutputStream(inStr)</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate two thread objects
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SenderThread T1 = new SenderThread(pos );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReceiverThread T2 = new ReceiverThread(inStr );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //And start the threads running&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T2.start();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}&nbsp;&nbsp;
&nbsp; }//end main()
&nbsp; //-----------------------------------------------------//

&nbsp; public void <B>finalize()</B>{
&nbsp;&nbsp;&nbsp; System.out.println("Finalizing main thread");
&nbsp; }//end finalize
&nbsp; //-----------------------------------------------------//
}//end pipe01 class definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060h.htm-><!-next=Java060j.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="UsingFilteredStreams"></A>Using Filtered Streams</H2>
</FONT><P>We are going to take a look at filtered streams at this point because that information will be useful later. </P>
<P>The filtered stream classes make it possible for you to apply I/O filtering to data being processed by an object of an unfiltered stream class. For example, you could create a custom filter object to read a file and convert all the characters to upper case. </P>
<P>Filtered stream classes are subclasses of the abstract classes named <B>FilterInputStream </B>and <B>FilterOutputStream</B>. </P>
<P>There are several standard filtered streams available, and you can create your own. Those which are in the standard <B>java.io</B> package are: </P>

<UL>
<LI>DataInputStream and DataOutputStream </LI>
<LI>BufferedInputStream and BufferedOutputStream </LI>
<LI>LineNumberInputStream </LI>
<LI>PushbackInputStream </LI>
<LI>PrintStream </LI></UL>

<P>The characteristics of each of these classes were discussed earlier. </P>
<P>To use a filtered stream class, you must <U>associate</U> an object of the filtered stream class with an object of the unfiltered stream class that will handle your I/O. <U>You do this by instantiating an object of the filtered class by passing an object of the unfiltered class to the constructor for the filtered class.</U> </P>
<P>You can instantiate the object of the unfiltered class beforehand, or you can simply call the constructor for the unfiltered class as a parameter to the constructor for the filtered class (create it as an anonymous object). </P>
<P>Having done this, you then have access to all the methods of the filtered class to use in your I/O efforts. </P>
<P>The following sample application is a rewrite of the previous application named <B>files01.java</B>. In the previous application, it was necessary to perform I/O one byte at a time. In this rewrite, The <B>DataInputStream </B>and <B>DataOutputStream </B>classes are associated with the <B>FileInputStream </B>and <B>FileOutputStream </B>classes. This makes it possible to use the methods of <B>DataInputStream </B>and <B>DataOutputStream </B>to control the I/O process. </P>
<P>This in turn makes it possible to perform the I/O <U>one string at a time</U> rather than <U>one byte at a time</U>. Numerous other methods are also available to perform the I/O in different ways. </P>
<P>Note that this program uses deprecated methods. The program named <B>SampProg151 </B>in the Review section at the end of the lesson shows how to replicate this program with no deprecated methods. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File files02.java Copyright 1997, R.G.Baldwin
This application is a modification of the application named
files01.&nbsp; The purpose is to illustrate the use of filtered
I/O classes to write and then read a file, one string at a
time.

Objects of types DataOutputStream and DataInputStream are&nbsp;
instantiated using objects of types FileOutputStream and
FileInputStream as parameters to the constructor.&nbsp; This&nbsp;
makes all of the methods for objects of types&nbsp;
DataOutputStream and DataInputStream available to write&nbsp;
and read the file.

The program was tested using JDK 1.1.3 under Win95.

The output from the program is:

<B>Start the program and write a file
Get info about, read, and print the file
Path is C:\BALDWIN\Java\SampProg\Java\junk.txt
Length 13
Dick
Baldwin
End of program
</B>**********************************************************/

import java.io.*;

class files02{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a FileOutputStream object as a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor. This makes it&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to write to the file using the methods
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the DataOutputStream class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut =&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt"))</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write two strings to the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Dick\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Baldwin\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Get info about, read, and print the file");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Instantiate an object of type file containing the&nbsp;
&nbsp;&nbsp;&nbsp; // name of the file.&nbsp; Same as app named files01.java.
&nbsp;&nbsp;&nbsp; File junkFile = <B>new File("junk.txt")</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the File object to get info about the file.&nbsp;
&nbsp;&nbsp;&nbsp; // Same as files01.java.
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Path is " + junkFile.<B>getAbsolutePath</B>());
&nbsp;&nbsp;&nbsp; System.out.println("Length " + junkFile.<B>length</B>() );
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now read and print the data in the file
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a DataInputStream object on the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FileInputStream object which uses the File object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // named junkFile to open the stream and link to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<B>Note </B>that the compiler reports readLine() as a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // deprecated method and suggests using methods&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the reader class instead.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataInputStream(new FileInputStream(junkFile)</B>);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data; //temp holding area
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and print strings until eof is indicated by&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // null.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (data = inData.readLine()) != null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class files02 definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060i.htm-><!-next=Java060k.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ReadingandWritingMemoryBuffersusing"></A>Reading and Writing Memory Buffers using Streams</H2>
</FONT><P>The unfiltered classes <B>ByteArrayInputStream </B>and <B>StringBufferInputStream </B>make it possible for you to read data from memory buffer areas as though you were reading from an external device. </P>
<B><P>ByteArrayOutputStream </B>can be used to write data into a memory buffer as though it were an external device. </P>
<B><P>ByteArrayInputStream </B>and <B>ByteArrayOutputStream </B>will allow you to read and write 8-bit data. When you create these streams, you specify an existing byte array and then use the <B>read()</B> and <B>write()</B> methods to read from or write data to the array in memory. </P>
<B><P>StringBufferInputStream </B>allows you to to read data from a <B>String</B> object. When you create a <B>StringBufferInputStream </B>object, you specify an existing <B>String </B>object as the source of the data and then use the <B>read()</B> methods to read from that object. </P>
<P>The following program illustrates the use of a <B>StringBufferInputStream</B> object to read the contents of a <B>String</B> object. Note that even though this class is named <B>StringBufferInputStream</B>, it is <U>not</U> designed to read the contents of objects of type <B>StringBuffer</B>. </P>
<P>Note that the following program uses deprecated code. The program named <B>SampProg152.java</B> in the <B>Review</B> section shows how to replicate this program without using any deprecated code. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File stream02.java
This application illustrates the use of a&nbsp;
StringBufferInputStream object to read the contents of an
object of type String.

Note that even though this class is called&nbsp;
StringBufferInputStream it does not read the contents of
objects of type StringBuffer.&nbsp; Rather, the data source&nbsp;
must be an object of type String.

The output from the program is:

<B>Start the program and create a String object.
Create stream object of type StringBufferInputStream.
Read and display the contents of the String object.
This is an object of type String.
End of program
</B>**********************************************************/
import java.io.*;
&nbsp;&nbsp;
class stream02{//controlling class
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and create a String object.");
&nbsp;&nbsp;&nbsp; String myString = "This is an object of type String.";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Create stream object of type " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "StringBufferInputStream.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //<B>Note that StringBufferInputStream is deprecated</B>.&nbsp; The
&nbsp;&nbsp;&nbsp; // documentation recommends using the StringReader
&nbsp;&nbsp;&nbsp; // class instead.
&nbsp;&nbsp;&nbsp; StringBufferInputStream myStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>new StringBufferInputStream(myString)</B>;

&nbsp;&nbsp;&nbsp; System.out.println("Read and display the contents " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "of the String object.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; myString.length(); cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)myStream.<B>read()</B>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("\nEnd of program");
&nbsp; }// end main
}//end class stream02 definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060j.htm-><!-next=Java060l.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="CreatingYourOwnFilteredStream"></A>Creating Your Own Filtered Stream Classes</H2>
</FONT><P>The steps for creating your own filtered stream classes include the following: </P>

<UL>
<LI>Create a subclass of <B>FilterInputStream </B>and <B>FilterOutputStream</B>. </LI>
<LI>Possibly override the <B>read()</B> and <B>write()</B> methods, or alternatively provide new <B>read()</B> and <B>write()</B> methods (whose argument lists don't match any existing methods having the same name) which will accomplish your purpose. </LI>
<LI>Override any other methods that you might need. </LI></UL>

<P>The following application provides custom filtered input and output classes which make it possible to write objects of a specific type to a disk file and read them back. </P>
<P>A custom version of a <B>write </B>method is provided which decomposes the object into a series of bytes and writes those bytes to the file. </P>
<P>A custom version of a <B>read </B>method is provided which reads bytes from the file and reconstructs an object. </P>
<P>The user of the classes simply writes and reads objects and doesn't need to be concerned about the details of how the data is being handled. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File stream01.java Copyright 1997, R.G.Baldwin
This application illustrates the creation of custom filter
classes to filter I/O.&nbsp; The classes can write objects of
type MyData to a disk file and read them back.

This application extends FilterOutputStream and&nbsp;
FilterInputStream to implement the new filter classes.

The new filter output class named MyFilterOutputClass&nbsp;
contains a method named MyWrite()

The MyWrite method accepts an input object of type MyData,
&nbsp; converts it to a stream of bytes and writes them onto
&nbsp; the disk using the write(int b) method of&nbsp;
&nbsp; FileOutputStream

The general contract for write is that one byte is written
&nbsp; to the output stream. The byte to be written is the&nbsp;
&nbsp; eight low-order bits of the argument b which is an&nbsp;
&nbsp; integer. The 24 high-order bits of the integer b are&nbsp;
&nbsp; ignored.&nbsp;&nbsp;

The individual bytes for the int data member named intData
&nbsp; are selected and passed to the write() method by&nbsp;
&nbsp; shifting bits to the right 3 times, 8 bits per shift

This class does not override the write() method.&nbsp; Rather,
&nbsp; it provides a new MyWrite() method which makes use of&nbsp;
&nbsp; one form of the existing write() method.

The program was tested using JDK 1.1.3 under Win95.

The output from the program is:

<B>Start the program and write an object to file
Read the object from the file and display it
The file contains X 123456789
End of program
</B>**********************************************************/
import java.io.*;

class <B>MyData</B>{//data structure used for testing
&nbsp; public char charData;
&nbsp; public int intData;

&nbsp; public MyData(){}//default constructor
&nbsp;&nbsp;
&nbsp; //parameterized constructor
&nbsp; public MyData(char inChar, int inIntData){
&nbsp;&nbsp;&nbsp; charData = inChar;
&nbsp; intData = inIntData;
&nbsp; }//end constructor
}//end class MyData definition
//=======================================================//

//This is a custom filter class for writing objects of
// type MyData into a file.
class <B>MyFilterOutputClass extends FilterOutputStream</B>{

&nbsp; MyFilterOutputClass(FileOutputStream out) //constructor
&nbsp; { super(out);} //pass the output object up the line
&nbsp;&nbsp;
&nbsp; //This is the <B>new write method</B> for objects
&nbsp; void <B>MyWrite</B>(MyData obj){
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //write the character data member to the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(obj.charData);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now use bit shifting to decompose the integer&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data member into bytes and write them to the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( (int) obj.intData  8*cnt);
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp; }//end write(MyData obj)
}//end MyFilterOutputClass definition
//=======================================================//

//This is a custom filter class for reading bytes from
// a file and constructing them into objects of type&nbsp;
// MyData.
class <B>MyFilterInputClass extends FilterInputStream</B>{
&nbsp; MyFilterInputClass(FileInputStream in) //constructor
&nbsp; { super(in);} //pass the output object up the line

&nbsp; //The following method reads bytes from a file and&nbsp;
&nbsp; // constructs an object of type MyData.&nbsp; The object is
&nbsp; // returned to the calling method.
&nbsp; MyData <B>MyRead</B>(){
&nbsp;&nbsp;&nbsp; MyData obj = new MyData();
&nbsp;&nbsp;&nbsp; try{//read char data member from the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.charData = <B>(char)read()</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now read bytes from the file and construct&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the integer data member
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.intData = obj.intData |&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( <B>(char)read()</B>&lt;&lt; 8*cnt); //next 8 bits
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; return obj; //return the constructed object
&nbsp; }//end MyRead()
}//end MyFilterOutputClass definition
//=======================================================//
&nbsp;&nbsp;
class stream01{//controlling class
&nbsp; public static void <B>main</B>(String[] args){
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write an object to file");

&nbsp;&nbsp;&nbsp; //Instantiate new type filter out obj linked to&nbsp;
&nbsp;&nbsp;&nbsp; // FileOutputStream
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFilterOutputClass fileOut =&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyFilterOutputClass(&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt")</B> );
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Construct an object of type MyData
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyData myObject = new MyData('X',123456789);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use new type filter method to write the object&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileOut.MyWrite(myObject);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileOut.close()</B>;
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Read the object from the file and display it");
&nbsp;&nbsp;&nbsp; //Instantiate new type filter inp obj linked to&nbsp;
&nbsp;&nbsp;&nbsp; // FileInputStream
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFilterInputClass fileIn =&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyFilterInputClass(&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileInputStream("junk.txt") </B>);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use new filter method to read object from file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyData inData =<B> fileIn.MyRead()</B>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>fileIn.close()</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the contents of the object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("The file contains " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.charData + " " + inData.intData);
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class stream01 definition</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060k.htm-><!-next=Java060m.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ReadingandWritingRandomAccessFiles"></A>Reading and Writing Random Access Files</H2>
</FONT><P><A HREF="#UsingRandomAccessFiles">Using Random Access Files</A> <BR>
<A HREF="#RandomAccessFilesandFilters">Random Access Files and Filters</A> <BR>
<A HREF="#ASampleProgram">A Sample Program</A></P>
<P>The previous discussions have been concerned with sequential input/output. That is, input and output where the bytes are transferred as a sequential stream of bytes. This is a particularly appropriate form of I/O for communication with other computers via the network, etc. </P>
<P>However, when working with disk files, it is often desirable to be able to treat the data in the file as an an "array" of bytes and to be able to access those bytes anywhere within the array. This can be accomplished using the <I>random</I> access capabilities afforded by Java </P>
<P>Note that unlike other languages, the classes that we have been studying do not allow for appending data to the end of a file. In order to append data to the end of a file in Java, you must treat that file as a random access file. </P>
<P>Random access of file data in Java is supported by the <B>RandomAccessFile</B> class. <BR>
&nbsp; </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="UsingRandomAccessFiles"></A>Using Random Access Files</H3>
</FONT><P>The <B>RandomAccessFile</B> class can be used both for <U>reading and writing</U>. It implements the <B>DataInput </B>and <B>DataOutput </B>interfaces. </P>
<P>As with the sequential <B>FileInputStream</B> and <B>FileOutputStream</B> classes, you specify a file to be opened by name when you instantiate an object of class <B>RandomAccessFile. </B>You can specify the file name either by a l<U>iteral string</U> or by passing a <B>File</B> object which you have previously instantiated. </P>
<P>Unlike with the sequential classes, when you instantiate an object of <B>RandomAccessFile</B>, you must indicate whether you will <U>just be reading</U> the file, or <U>also writing</U> to it. You must be able to read a file before you can write to it. </P>
<P>The syntax for instantiating a <B>RandomAccessFile </B>object is as follows: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>new RandomAccessFile(<I>name</I>, <I>mode</I>)</PRE></TT></TD>
</TR>
</TABLE>

<P>As mentioned earlier, the <I>name </I>can be specified using either a literal string or an object of type <B>File</B>. The <I>mode</I> is a literal string which can be either of two possibilities: </P>

<UL>
<LI>"r" means open for reading only </LI>
<LI>"rw" means open for both reading and writing </LI></UL>

<P>Once the file is opened you can use the various forms of the <B>read___()</B> and <B>write___()</B> methods to read and write the data in the file. </P>
<P>Simply being able to use the <B>read </B>and <B>write </B>methods to read or write the data in the file wouldn't be very interesting except for the availability of some additional methods. In particular, as in other languages which support random file I/O, <B>RandomAccessFile </B>supports the notion of a <I>file pointer</I>. </P>
<P>The <I>file pointer</I> points to the current location in the file. It points to the beginning of the file (value of 0) when the object is first instantiated. When you use the normal <B>read</B> and <B>write</B> methods, the value of the pointer is adjusted by the number of bytes actually read or written. </P>
<P>In addition, there are three methods available to explicitly manipulate the f<I>ile pointer</I>: </P>

<UL>
<B><LI>skipBytes()</B> Moves the file pointer forward the specified number of bytes. </LI>
<B><LI>seek()</B> Positions the file pointer <U>just before</U> the specified byte. </LI>
<B><LI>getFilePointer()</B> Returns the current byte location of the file pointer. </LI></UL>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="RandomAccessFilesandFilters"></A>Random Access Files and Filters</H3>
</FONT><P>As with sequential file I/O, we often want to be able to apply filtering to the data when we read and write a file on a random basis. Because <B>RandomAccessFile</B> doesn't inherit from the <B>InputStream</B> or <B>OutputStream</B> classes, you can't apply the same filters to objects of <B>RandomAccessFile</B> that you apply to the sequential streams. </P>
<P>However, because <B>RandomAccessFile </B>implements the <B>DataInput </B>and <B>DataOutput </B>interfaces, you can create a filter that works for either <B>DataInput </B>or <B>DataOutput </B>and it will work on those sequential access files that implement <B>DataInput</B> or <B>DataOutput</B> as well as any <B>RandomAccessFile</B>. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ASampleProgram"></A>A Sample Program</H2>
</FONT><P>The following sample program illustrates the use of the <B>RandomAccessFile</B> class to read and write bytes interior to a file. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File files03.java Copyright 1997, R.G.Baldwin
This application is a modification of the application&nbsp;
named files02.&nbsp; The purpose is to illustrate the use of&nbsp;
the RandomFileAccess class to read and write data interior&nbsp;
to the file.

Tested using JDK 1.1.3 under Win95

The output from the program is:

<B>Start the program and write a file
Now open and read the file in random access mode
Display the entire file as characters.
Dick
Baldwin
Now display four bytes interior to the file.
Bald
Now write four bytes interior to the file.
Now display the entire file again.
Note that four bytes have been overwritten.
Dick
WXYZwin

End of program
</B>**********************************************************/

import java.io.*;

class files03{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a FileOutputStream object as a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor. This makes it&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to write to the file using the methods
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the DataOutputStream class.&nbsp; This is a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sequential stream operation and NOT a random&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access operation.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut = <B>new DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt")</B>);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write two strings to the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Dick\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Baldwin\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; //Instantiate an object of type file containing the&nbsp;
&nbsp;&nbsp;&nbsp; // name of the file to illustrate the use of File&nbsp;
&nbsp;&nbsp;&nbsp; // objects in instantiating an object later of type&nbsp;
&nbsp;&nbsp;&nbsp; // RandomAccessFile
&nbsp;&nbsp;&nbsp; File junkFile = new File("junk.txt");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now open and read the file in random access mode");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a RandomAccesSfile object for reading&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and writing using the File object named junkFile
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to open and link to the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessFile inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B> new RandomAccessFile(junkFile,"rw"</B>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Display the entire file as characters.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that the file pointer is initially at the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // beginning of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (temp = inData.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)temp);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now display four bytes interior to the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get current location of the file pointer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>long filePointer = inData.getFilePointer()</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the file pointer to a location interior to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>inData.seek(filePointer-8)</B>;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now read and display four bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print( (char)inData.read() );
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nNow write four bytes interior to the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filePointer = <B>inData.getFilePointer()</B>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.<B>seek(filePointer-4)</B>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.write('W'+cnt);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now display the entire file again.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Note that four bytes have been overwritten.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that it is necessary to reposition the file&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pointer to the beginning of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.<B>seek(0)</B>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (temp = inData.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)temp);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("\nEnd of program");
&nbsp; }// end main
}//end class files03 definition</PRE></TD>
</TR>
</TABLE>

<P>. </P>
<P><!-prev=Java060l.htm-><!-next=Java060n.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ReaderandWriterClasses"></A>Reader and Writer Classes</H2>
</FONT><P>The <B>Reader</B> and <B>Writer</B> classes were added to JDK 1.1 to support internationalization.&nbsp; Briefly, the stream I/O capability that was supported prior to that release didn't support the use of 16-bit Unicode characters.&nbsp; Rather, only the bottom 8 bits were handled by the streams. </P>
<P>The <B>Reader</B> and <B>Writer</B> classes make it possible to work with character streams rather than byte streams.&nbsp; To a large extent, these character-stream classes mirror the byte stream classes, so if you know how to use one, it isn't too difficult to figure out how to use the other.&nbsp; The web is full of discussions regarding the pros and cons of this situation, so I won't discuss it further at this point.&nbsp; Rather, I am simply going to provide a sample program that will show you how to upgrade the previous program named <B>files02.java</B> to cause it to use character streams instead of byte streams. </P>
<P>To understand the differences, you should compare the code in this program with the code in <B>files02.java</B>. </P>
<P>Some of the code in the original program had nothing to do with the difference between byte streams and character streams, so that code was omitted from this version. </P>
<P>A listing of the program follows.&nbsp; I have highlighted the new and important parts of this version in boldface to make it easier for you to compare this version with the original version. </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><TT>/* File files04.java Copyright 1998, R.G.Baldwin
This program is an upgrade to the program named
files02.&nbsp; The purpose is to convert the original program
that used byte streams for input and output to one that
uses unicode character streams for input and output.

To understand the differences, you should compare the
code in this program with the code in files02.java.

Some of the code in the original program had nothing to
do with the difference between byte streams and character
streams, so that code was omitted from this version.

The output from the program is:

<B>Start the program and write a file
Read and print the file
Dick
Baldwin
End of program


</B>The program was tested using JDK 1.1.6 under Win95.
**********************************************************/

import java.io.*;

class files04{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Open an output character stream using the Writer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // classes.
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintWriter dataOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new PrintWriter(new FileWriter("junk.txt"),true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.println("Dick");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.println("Baldwin");
</B>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.close();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Read and print the file");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Open an input character stream using the Reader
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // classes.
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader("junk.txt"));

</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data; //temp holding area
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (data = inData.readLine()) != null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class files04 definition</PRE></TT></TD>
</TR>
</TABLE>

<P>Hopefully, this sample program will provide you with enough information to be able to convert your thinking and your programs from byte streams to character streams. </P>
<P><!-prev=Java060m.htm-><!-next=Java060o.htm><!-first=Java060.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="Review"></A>Review</H2>
</FONT><P>Q - Usually the task of a <B>stream</B> is to move data from memory to an external device or vice versa, but streams can also be used to move data from one part of memory to another part of memory just as well: True or False. If false, explain why. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Write a Java application that illustrates writing and then reading a file one byte at a time. Instantiate your file stream objects using a literal string containing the name of the file. The output from the program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Start the program and write a file</TT> <BR>
<TT>Read, and display the file</TT> <BR>
<TT>Dick</TT> <BR>
<TT>End of program</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See the program below:</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg110.java from lesson 60
Copyright 1997, R.G. Baldwin
Without viewing the solution which follows, write a Java
application that illustrates writing and then reading a&nbsp;
file one byte at a time.

=========================================================//
*/
import java.io.*;

class SampProg110{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize an output file stream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a literal string containing the name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStream outFile = new FileOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "junk.txt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write four bytes in the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('D');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('i');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('c');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('k');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Read, and display the file");&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now read and print the data in the file
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream inFile = new FileInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "junk.txt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and print until eof indicated by -1.&nbsp; read()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // method returns integer.&nbsp; Must cast as char to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // print. Otherwise, the numeric value of the byte&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is displayed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (data = inFile.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFile.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println();//new line
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class SampProg110 definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that illustrates writing and then reading a file one byte at a time. Store the uppercase characters A, B, C, D, and E in the file. Display the numeric unicode values of the characters. Instantiate your file stream object using an object of type File. Also use the object of type File to obtain and display two properties of the file: absolute path and length The output from the program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Start the program and write a file</TT> <BR>
<TT>Get info about, read, and print the file</TT> <BR>
<TT>Path is C:\BALDWIN\Cis2103K\Fall97\SampProg\junk.txt</TT> <BR>
<TT>Length 5</TT> <BR>
<TT>65 66 67 68 69&nbsp;</TT> <BR>
<TT>End of program</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See the program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg111.java from lesson 60
Copyright 1997, R.G.Baldwin
Without viewing the solution that follows, write a Java
application that illustrates writing and then reading a&nbsp;
file one byte at a time.

=========================================================//
*/

import java.io.*;

class SampProg111{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; //Instantiate an object of type File
&nbsp;&nbsp;&nbsp; File fileObj = new File("junk.txt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize the stream object&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // using the File object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStream outFile =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream(fileObj);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write five bytes to the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('A');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('B');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('C');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('D');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.write('E');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFile.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Get info about, read, and print the file");&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the File object to get info about the file
&nbsp;&nbsp;&nbsp; System.out.println("Path is "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + fileObj.getAbsolutePath());
&nbsp;&nbsp;&nbsp; System.out.println("Length " + fileObj.length() );
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now read and print the data in the file
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize the stream object&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // using the File object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream inFile =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileInputStream(fileObj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int data;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and print until eof indicated by -1.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read() method returns integer.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (data = inFile.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(data + " ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFile.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println(); //new line
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class SampProg111 definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that illustrates the piping of the output from one thread to the input of another thread. The SenderThread sends the message "Dick Baldwin". The ReceiverThread receives and displays the message. </P>
<P>The output from your program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Starting ReceiverThread&nbsp;</TT> <BR>
<TT>Starting SenderThread&nbsp;</TT> <BR>
<TT>Received: Dick Baldwin&nbsp;</TT> <BR>
<TT>ReceiverThread done&nbsp;</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg112.java from lesson 60
Copyright 1997, R.G.Baldwin

Without viewing the following solution, write a Java
application that illustrates the piping of the output from&nbsp;
one thread to the input of another thread.
=========================================================//
*/
import java.io.*;

class SenderThread extends Thread{
&nbsp; PipedOutputStream pos; //ref to piped output stream obj
&nbsp; String msgToSend = "Dick Baldwin";

&nbsp; public SenderThread(PipedOutputStream posIn){
&nbsp;&nbsp;&nbsp; pos = posIn; //save ref to piped output stream object
&nbsp; }//end SenderThread constructor

&nbsp; public void run(){ //override run method
&nbsp;&nbsp;&nbsp; System.out.println("Starting SenderThread");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; msgToSend.length(); i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //write a character to the piped output stream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.write(msgToSend.charAt(i));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; //SenderThread has finished its task here
&nbsp; }//end run() method
}//end SenderThread class definition

class ReceiverThread extends Thread{
&nbsp; //ref to piped input stream obj
&nbsp; PipedInputStream inputStr;&nbsp;
&nbsp; int inData = 0; //working variable
&nbsp;&nbsp;
&nbsp; public ReceiverThread(PipedInputStream inStr){
&nbsp;&nbsp;&nbsp; inputStr = inStr; //save ref to piped input stream obj
&nbsp; }//end ReceiverThread constructor

&nbsp; public void run(){ //override run method
&nbsp;&nbsp;&nbsp; System.out.println("Starting ReceiverThread");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read the first character as an integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData = inputStr.read();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print("Received: " + (char)inData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read until integer -1 signals no more data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (inData != -1){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //read next char as an integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData = inputStr.read();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)inData);//display it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println();//new line
&nbsp;&nbsp;&nbsp; System.out.println("ReceiverThread done");
&nbsp; }//end run() method
}//end ReceiverThread class definition


class SampProg112{ //controlling class
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a PipedInputStream object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedInputStream inStr = new PipedInputStream();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a PipedOutputStream object and connect&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // it to the existing PipedInputStream object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PipedOutputStream pos = new PipedOutputStream(inStr);
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate two thread objects
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SenderThread T1 = new SenderThread(pos );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReceiverThread T2 = new ReceiverThread(inStr );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //And start the threads running&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T2.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1.start();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}&nbsp;&nbsp;
&nbsp; }//end main()
}//end SampProg112 class definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that writes a double, a long, and a character to a file and then reads the file and displays the data. </P>
<P>The output from the program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Start the program and write a file&nbsp;</TT><FONT FACE="Courier"> <BR>
</FONT><TT>Read, and print the file&nbsp;</TT><FONT FACE="Courier"> <BR>
</FONT><TT>Double: 3.14159&nbsp;</TT><FONT FACE="Courier"> <BR>
</FONT><TT>Long: 1234&nbsp;</TT><FONT FACE="Courier"> <BR>
</FONT><TT>Character: X&nbsp;</TT><FONT FACE="Courier"> <BR>
</FONT><TT>End of program</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg113.java from lesson 60
Copyright 1997, R.G.Baldwin

Without viewing the solution that follows, write a Java
application that writes a double, a long, and a character
to a file and then reads the file and displays the data.
=========================================================//
*/

import java.io.*;

class SampProg113{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a FileOutputStream object as a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor. This makes it&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to write to the file using the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // methods of the DataOutputStream class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt"));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write a double, a long, and a character to the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeDouble(3.14159);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeLong(1234);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeChar('X');
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println("Read, and print the file");&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now read and print the data in the file
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a DataInputStream object on the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FileInputStream object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileInputStream("junk.txt"));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and print a double, a long, and a character
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Double: " + inData.readDouble());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Long: " + inData.readLong());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Character: " + inData.readChar());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class SampProg113 definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that writes a double, a long, and a character to an array of bytes in memory, and then reads the three data elements from the byte array and displays their values. </P>
<P>The output from the program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Write formatted data to a ByteArrayOutputStream object&nbsp;</TT> <BR>
<TT>Read and display formatted data from the byte array&nbsp;</TT> <BR>
<TT>Double: 3.14159&nbsp;</TT> <BR>
<TT>Long: 1234&nbsp;</TT> <BR>
<TT>Character: X&nbsp;</TT> <BR>
<TT>End of program&nbsp;</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See the program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=504>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File SampProg114.java from lesson 60
Copyright 1997, R.G.Baldwin

This application illustrates the use of&nbsp;
ByteArrayOutputStream and ByteArrayInputStream in&nbsp;
conjunction with filtered I/O classes to write and then
read formatted data of specific mixed types into an array
of bytes in memory.

An object of type DataOutputStream is instantiated using
an object of type ByteArrayOutputStream as a parameter to
the constructor.&nbsp; This makes all of the methods for objects
of type DataOutputStream available to write formatted data
into the memory represented by the ByteArrayOutputStream&nbsp;
object.

A double, a long, and a character are written to the&nbsp;
ByteArrayOutputStream object.

Then, an ordinary byte array is extracted from the
ByteArrayOutputStream object which contains the bytes
representing the double, the long, and the character.

This byte array is passed to a ByteArrayInputStream
constructor creating an object that is passed in turn to
a DataInputStream object.&nbsp; This makes all of the methods
for objects of type DataInputStream available to read data
from the memory represented by the ByteArrayInputStream
object.

The double, long, and character data are read and&nbsp;
displayed.

The output from the program should be similar to the&nbsp;
following:
&nbsp;&nbsp;
Write formatted data to a ByteArrayOutputStream object
Read and display formatted data from the byte array
Double: 3.14159
Long: 1234
Character: X
End of program
===========================================================
*/

import java.io.*;

class SampProg114{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Write formatted data to a "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "ByteArrayOutputStream object");
&nbsp;&nbsp;&nbsp; //Instantiate the ByteArrayOutputStream object
&nbsp;&nbsp;&nbsp; ByteArrayOutputStream myByteArrayOutputStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ByteArrayOutputStream();
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using the ByteArrayOutputStream object as a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor. This makes it&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to write to the ByteArrayOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using the methods of the DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataOutputStream(myByteArrayOutputStream);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write a double, a long, and a character to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the ByteArrayOutputStream object&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeDouble(3.14159);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeLong(1234);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeChar('X');
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Extract an ordinary byte array from the&nbsp;
&nbsp;&nbsp;&nbsp; // ByteArrayOutputStream object to use below.
&nbsp;&nbsp;&nbsp; byte[] myByteArray =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myByteArrayOutputStream.toByteArray();

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp; "Read and display formatted data from the byte array");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a DataInputStream object on a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ByteArrayInputStream object linked to the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ordinary byte array.&nbsp; This makes it possible to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use the methods of the DataInputStream class to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read formatted data from the byte array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ByteArrayInputStream(myByteArray));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and display a double, a long, and a character
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the byte array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Double: " + inData.readDouble());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Long: " + inData.readLong());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Character: " + inData.readChar());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class SampProg114 definition</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that instantiates an object of a user-defined type containing a single String data member, writes the object to a file as a stream of bytes, reads the stream of bytes from the file and reconstructs the object, and then displays the String data member. </P>
<P>The output from this program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Start the program and write an object to file&nbsp;</TT> <BR>
<TT>Read the object from the file and display it&nbsp;</TT> <BR>
<TT>The file contains First String&nbsp;</TT> <BR>
<TT>End of program&nbsp;</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg115.java from lesson 60

Copyright 1997, R.G.Baldwin

This application illustrates the creation of custom filter
classes to filter I/O.&nbsp; The two custom filter classes can&nbsp;
write objects of type MyData to a disk file and read them&nbsp;
back.

This application extends FilterOutputStream and&nbsp;
FilterInputStream to implement the new filter classes.

The new filter output class named MyFilterOutputClass&nbsp;
contains a method named MyWrite()

The MyWrite method accepts an input object of type MyData,
converts it to a stream of bytes and writes them onto the
disk.

The output from this program should be similar to the
following:
&nbsp;&nbsp;
Start the program and write an object to file
Read the object from the file and display it
The file contains First String
End of program&nbsp;&nbsp;
===========================================================
*/
import java.io.*;

class MyData{//data structure used for testing
&nbsp; public String firstString = "First String";
}//end class MyData definition
//=========================================================

//This is a custom filter class for writing objects of
// type MyData into a file.
class MyFilterOutputClass extends FilterOutputStream{
&nbsp; MyFilterOutputClass(FileOutputStream out) //constructor
&nbsp; { super(out);} //invoke superclass constructor
&nbsp;&nbsp;
&nbsp; //This is the new write method for objects
&nbsp; void MyWrite(MyData obj){
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //write the string as a byte array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(obj.firstString.getBytes());
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp; }//end write(MyData obj)
}//end MyFilterOutputClass definition
//=========================================================

//This is a custom filter class for reading bytes from
// a file and constructing them into an object&nbsp;
// of type MyData.
class MyFilterInputClass extends FilterInputStream{
&nbsp; MyFilterInputClass(FileInputStream in) //constructor
&nbsp; { super(in);} //invoke superclass constructor

&nbsp; //This is the new read method for objects. This method&nbsp;
&nbsp; // reads bytes from a file and constructs an object of&nbsp;
&nbsp; // type MyData.&nbsp; The object is returned to the calling&nbsp;
&nbsp; // function.
&nbsp; MyData MyRead(){
&nbsp;&nbsp;&nbsp; MyData obj = new MyData();//construct empty object
&nbsp;&nbsp;&nbsp; //Try to populate it by reading bytes and converting
&nbsp;&nbsp;&nbsp; // them into a string.
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] tempByteArray = new byte[40];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in.read(tempByteArray);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.firstString = new String(tempByteArray);
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; return obj; //return the constructed object
&nbsp; }//end MyRead()
}//end MyFilterOutputClass definition
//=========================================================
&nbsp;
class SampProg115{//controlling class
&nbsp; public static void main(String[] args){//main method
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write an object to file");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Instantiate new type filtered output obj linked to&nbsp;
&nbsp;&nbsp;&nbsp; // FileOutputStream
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFilterOutputClass fileOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyFilterOutputClass(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt") );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Construct an object of type MyData
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyData myObject = new MyData();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use new type filter method to write the object&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileOut.MyWrite(myObject);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileOut.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Read the object from the file and display it");
&nbsp;&nbsp;&nbsp; //Instantiate new type filter input obj linked&nbsp;
&nbsp;&nbsp;&nbsp; // to FileInputStream
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFilterInputClass fileIn =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyFilterInputClass(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileInputStream("junk.txt") );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Use new filter method to read object from file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyData inData = fileIn.MyRead();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileIn.close();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Display the contents of the object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("The file contains "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + inData.firstString);
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }// end main
}//end class SampProg115 definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that modifies four bytes interior to a file, displaying the contents of the file before and after the modification. </P>
<P>The output from the program should be similar to the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P><TT>Start the program and write a file in sequential mode&nbsp;</TT> <BR>
<TT>Now open and read the file in random access mode&nbsp;</TT> <BR>
<TT>Display the entire file as characters.&nbsp;</TT> <BR>
<TT>First String&nbsp;</TT> <BR>
<TT>Second String&nbsp;</TT> <BR>
<TT>Now display four bytes interior to the file.&nbsp;</TT> <BR>
<TT>nd S&nbsp;</TT> <BR>
<TT>Now write four bytes interior to the file.&nbsp;</TT> <BR>
<TT>Now display the entire file again.&nbsp;</TT> <BR>
<TT>Note that four bytes have been overwritten.&nbsp;</TT> <BR>
<TT>First String&nbsp;</TT> <BR>
<TT>SecoABCDtring</TT></TD>
</TR>
</TABLE>

<FONT SIZE=2 COLOR="#0000ff"><P>A - See the program below.</FONT> <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT FACE="Courier" COLOR="#0000ff">/* File SampProg116.java from lesson 60
Copyright 1997, R.G.Baldwin

First write a file containing two strings in sequential
mode and close the file.

Then open and display all the bytes in the file in random
access mode.

Then display four bytes interior to the file.

The modify the same four bytes interior to the file and&nbsp;
display them again.

The output from the program should be similar to the
following:

Start the program and write a file in sequential mode
Now open and read the file in random access mode
Display the entire file as characters.
First String
Second String
Now display four bytes interior to the file.
nd S
Now write four bytes interior to the file.
Now display the entire file again.
Note that four bytes have been overwritten.
First String
SecoABCDtring

End of program
===========================================================
*/

import java.io.*;

class SampProg116{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file in "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "sequential mode");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a FileOutputStream object as a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt"));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write two strings to the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("First String\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Second String\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now open and read the file in random access mode");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a RandomAccesSfile object for reading&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and writing and link it to the file that was
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // created above.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessFile inData =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new RandomAccessFile("junk.txt","rw");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Display the entire file as characters.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that the file pointer is initially at the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // beginning of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (temp = inData.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)temp);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now display four bytes interior to the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get current location of the file pointer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long filePointer = inData.getFilePointer();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the file pointer to a location interior&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.seek(filePointer - 10);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now read and display four bytes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print( (char)inData.read() );
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nNow write four bytes interior to the file.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filePointer = inData.getFilePointer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.seek(filePointer - 4);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 4; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.write('A'+cnt);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Now display the entire file again.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Note that four bytes have been overwritten.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that it is necessary to reposition the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // file pointer to the beginning of the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.seek(0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (temp = inData.read()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)temp);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("\nEnd of program");
&nbsp; }// end main
}//end class SampProg116 definition</PRE></FONT></TD>
</TR>
</TABLE>

<P>Q - Write a Java program that meets the following specifications. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File SampProg151.java Copyright 1997, R.G.Baldwin
From lesson 60.

Without viewing the solution that follows, write a Java
application that replicates the program named files02.java
but doesn't use deprecated methods.

This application is a modification of the application named
files01.&nbsp; The purpose is to illustrate the use of filtered
I/O classes to write and then read a file, one string at a
time.

The program was tested using JDK 1.1.3 under Win95.

The output from the program is:

Start the program and write a file
Get info about, read, and print the file
Path is C:\BALDWIN\Java\SampProg\Java\junk.txt
Length 13
Dick
Baldwin
End of program
**********************************************************/

import java.io.*;

class SampProg151{
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and write a file");
&nbsp;&nbsp;&nbsp; try{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate and initialize a DataOutputStream&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object using a FileOutputStream object as a&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter to the constructor. This makes it&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible to write to the file using the methods
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the DataOutputStream class.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataOutputStream dataOut =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileOutputStream("junk.txt"));
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Write two strings to the file and close it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Dick\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.writeBytes("Baldwin\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataOut.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}

&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Get info about, read, and print the file");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Instantiate an object of type file containing the&nbsp;
&nbsp;&nbsp;&nbsp; // name of the file.&nbsp; Same as app named files01.java.
&nbsp;&nbsp;&nbsp; File junkFile = new File("junk.txt");
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Use the File object to get info about the file.&nbsp;
&nbsp;&nbsp;&nbsp; // Same as files01.java.
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Path is " + junkFile.getAbsolutePath());
&nbsp;&nbsp;&nbsp; System.out.println("Length " + junkFile.length() );
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Now read and print the data in the file
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Instantiate a BufferedReader object on the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FileReader object which uses the File object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // named junkFile to open the stream and link to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*The following note was extracted from the JDK 1.1.3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; documentation:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note: readLine() is deprecated. This method does not
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properly convert bytes to characters. As of&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JDK 1.1, the preferred way to read lines of text is&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; via the BufferedReader.readLine() method. Programs&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that use the DataInputStream class to read lines can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be converted to use the BufferedReader class by&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replacing code of the form
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream d = new DataInputStream(in);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader d
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = new BufferedReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new InputStreamReader(in));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader inData =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BufferedReader(new FileReader(junkFile));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String data; //temp holding area
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Read and print strings until eof is indicated by&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // null.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (data = inData.readLine()) != null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inData.close();
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("End of program");
&nbsp; }// end main
}//end class SampProg151 definition</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java application that meets the following specifications. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/* File SampProg152.java Copyright 1998, R.G.Baldwin
From lesson 60

Without viewing the solution that follows, write a Java
application that replicates the program named Stream02.java
but that does not use deprecated methods.

This application illustrates the use of a StringReader&nbsp;
object to read the contents of an object of type String.

The output from the program is:

Start the program and create a String object.
Create stream object of type StringReader.
Read and display the contents of the String object.
This is an object of type String.
End of program
**********************************************************/
import java.io.*;
&nbsp;&nbsp;
class SampProg152{//controlling class
&nbsp; public static void main(String[] args)
&nbsp; {
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start the program and create a String object.");
&nbsp;&nbsp;&nbsp; String myString = "This is an object of type String.";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Create stream object of type " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "StringReader.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Note that StringBufferInputStream is deprecated.&nbsp; The
&nbsp;&nbsp;&nbsp; // documentation recommends using the StringReader
&nbsp;&nbsp;&nbsp; // class instead.
&nbsp;&nbsp;&nbsp; StringReader myStream =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new StringReader(myString);

&nbsp;&nbsp;&nbsp; System.out.println("Read and display the contents " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "of the String object.");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; myString.length(); cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)myStream.read());
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("\nEnd of program");
&nbsp; }// end main
}//end class SampProg152 definition</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a Java program that meets the following specifications. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg155.java Copyright 1998, R.G.Baldwin
From lesson 60

Without viewing the solution that follows, write a Java
application that uses the new "reader" classes to read
lines of text from the keyboard and display the text
on the screen.&nbsp; A line of text is terminated by pressing
the Enter key.

Continue reading and displaying lines until the user
enters "quit".

The program was tested using JDK 1.1.3 running under Win95.
**********************************************************/

import java.io.*;
//=======================================================//

public class SampProg155 {
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter lines of text and they will be echoed");
&nbsp;&nbsp;&nbsp; System.out.println("Enter the word quit to quit.");
&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputStreamReader is =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new InputStreamReader(System.in);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader br = new BufferedReader(is);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = br.readLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(s.compareTo("quit") == 0)break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end while
&nbsp;&nbsp;&nbsp; }catch(IOException e){}
&nbsp;&nbsp;&nbsp; System.out.println("Program terminated");
&nbsp; }//end main
}//end class SampProg155
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P>Q - Write a program that meets the following specifications. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=498>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File SampProg156.java
Copyright (c) Peter van der Linden,&nbsp; May 5 1997.

Without viewing the solution that follows, write a Java
application that can read strings and all of the
primitive Java types from the keyboard.

This program was tested using JDK 1.1.3 under Win95.
I found it to experience intermittent problems when
used with JDK 1.1.3 under Win95.&nbsp; I am assuming that
these intermittent problems will disappear when used
with a later version of the JDK. - rgb.

**********************************************************/
import java.util.*;
import java.io.*;
//=======================================================//

class SampProg156{
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; EasyIn easy = new EasyIn();

&nbsp;&nbsp;&nbsp; String myString;
&nbsp;&nbsp;&nbsp; int myInt;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter a string");
&nbsp;&nbsp;&nbsp; myString = easy.readString();
&nbsp;&nbsp;&nbsp; System.out.println("Echo: " + myString);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Enter an int");
&nbsp;&nbsp;&nbsp; myInt = easy.readInt();
&nbsp;&nbsp;&nbsp; System.out.println("Echo: " + myInt);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.out.println("Terminating program");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end main
}//end class SampProg156
//=======================================================//

// Simple input from the keyboard for all primitive types.
// Copyright (c) Peter van der Linden,&nbsp; May 5 1997.
// Feel free to use this in your programs, as long as this
// comment stays intact.
//
// This is not thread safe, not high performance, and&nbsp;
// doesn't tell EOF.
// It's intended for low-volume easy keyboard input.
// An example of use is:
//&nbsp;&nbsp;&nbsp;&nbsp; EasyIn easy = new EasyIn();
//&nbsp;&nbsp;&nbsp;&nbsp; int i = easy.readInt();&nbsp;&nbsp;&nbsp;
// reads an int from System.in
// See Just Java and Beyond, Third Edition by Peter
// van der Linden


class EasyIn {&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; static InputStreamReader is =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new InputStreamReader( System.in );
&nbsp; static BufferedReader br = new BufferedReader( is );
&nbsp; StringTokenizer st;

&nbsp; StringTokenizer getToken() throws IOException {
&nbsp;&nbsp;&nbsp; String s = br.readLine();
&nbsp;&nbsp;&nbsp; return new StringTokenizer(s);
&nbsp; }//end getToken()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; boolean readBoolean() {
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Boolean(st.nextToken()).booleanValue();
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readBoolean");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readBoolean()

&nbsp; byte readByte(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Byte.parseByte(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readByte");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readByte()

&nbsp; short readShort(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Short.parseShort(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readShort");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readShort()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int readInt(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Integer.parseInt(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("IO Exception in EasyIn.readInt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readInt()

&nbsp; long readLong(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Long.parseLong(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readFloat");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0L;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readLong()

&nbsp; float readFloat() {
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Float(st.nextToken()).floatValue();
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readFloat");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0.0F;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readFloat()

&nbsp; double readDouble() {
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Double(st.nextToken()).doubleValue();
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readDouble");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0.0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readDouble()

&nbsp; char readChar() {
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = br.readLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s.charAt(0);
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readChar");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readChar()

&nbsp; String readString() {
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return br.readLine();
&nbsp;&nbsp;&nbsp; }catch (IOException ioe) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "IO Exception in EasyIn.readString");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "";
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end readString
}//end class definition
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P><!-prev=Java060n.htm-><!-first=Java060.htm-></P>
<P>-end-<!--end--> </P></BODY>
</HTML>
