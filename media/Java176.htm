<html><head>
   <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
   <meta name="generator" content="mozilla/4.04 [en] (win95; i) [netscape]">
   <meta name="author" content="richard g. baldwin">
   <title>... in Java by Richard G Baldwin</title></head><body><!--start-->

<center><h3><b><i>Richard G Baldwin (512) 223-4758, <a href="mailto:baldwin@austin.cc.tx.us">baldwin@austin.cc.tx.us</a>,
<a href="http://www2.austin.cc.tx.us/baldwin/">http://www2.austin.cc.tx.us/baldwin/</a></i></b></h3></center>

<center><h2><b><!--title-->JDK 1.1, Lightweight Components, A Lightweight 3D Button Class<!--endtitle--></b></h2></center>
Java Programming, Lecture Notes # 176, Revised 02/24/98.
<ul><li><a href="#preface">Preface</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#lightweight components, a discussion">Lightweight Components,
A Discussion</a></li>

<ul><li><a href="#the lightweight ui framework">The Lightweight UI Framework</a></li></ul>

<li><a href="#the lightweight button class">The Lightweight Button Class</a></li>

<ul><li><a href="#interesting code fragments">Interesting Code Fragments</a></li>

<li><a href="#program listing">Program Listing</a></li></ul></ul>

<hr align=left width="100%"><center><h2><a name="preface"></a><b><font color="#ff0000">Preface</font></b></h2></center>
Students in Prof. Baldwin's <b>Advanced Java Programming</b> classes at
ACC are responsible for knowing and understanding all of the material in
this lesson.

<p>JDK 1.1 was formally released on February 18, 1997. This lesson was
originally written as lesson number 98 on March 23, 1997 using the software
and documentation in the JDK 1.1 download package. However, it was later
decided that the placement of lightweight component material at that location
in the sequence of lessons was premature and that it should be deferred
until a variety of other topics had been covered. In December of 1997,
the original material was expanded considerably, rewritten as lesson number
176, and placed in the lesson sequence following graphics, components,
layout managers, etc.
<center><h2><a name="introduction"></a><font color="#ff0000">Introduction</font></h2></center>
In a previous lesson on event handling, you learned how to create and service
program-generated events under JDK 1.1. That knowledge is critical to the
handling of events in lightweight components, because lightweight components
require the generation and servicing of events under program control. If
you don't remember that material, you should go back and review it.

<p>Following a general discussion on lightweight components, this lesson
develops and discusses a class for a lightweight version of a 3D button
that generally mimics the behavior of a standard heavyweight button. No
code is provided in this lesson to exercise the lightweight button class.
Rather, a subsequent lesson provides several different programs that can
be used to exercise the lightweight button under different layout managers.
<center><h2><a name="lightweight components, a discussion"></a><font color="#ff0000">Lightweight
Components, A Discussion</font></h2></center><font color="#000000">The ability to create lightweight components was
added as a new feature of JDK 1.1. This capability was added to deal with
some problems under JDK 1.0</font>

<p><font color="#000000">Specifically, creating new components in JDK 1.0
required subclassing <b>Canvas </b>or <b>Panel</b>. This placed each new
component in its own opaque window based on the native components of the
platform. Because native windows are opaque, they can't be used to implement
transparent regions.</font>

<p><font color="#000000">Also, native windows are handled differently across
different platforms so the view of a user interface may differ from one
platform to the next.</font>

<p><font color="#000000">The ability to implement lightweight components
in JDK 1.1 is referred to as the <b>Lightweight User Interface (UI) Framework</b>.</font><center><h3><a name="the lightweight ui framework"></a><font color="#ff0000">The Lightweight
UI Framework</font></h3></center><font color="#000000">The <i>Lightweight UI Framework</i> makes it possible
to extend the <b>java.awt.Component</b> class and the <b>java.awt.Container</b>
class. This in turn makes it possible to create components that are <u>not
associated</u> with native opaque windows or other native widgets.</font>

<p><font color="#000000">These lightweight components mesh into the different
AWT models allowing you to do layout, paint, handle events, etc., with
no additional APIs required.</font>

<p><font color="#000000">Lightweight components can have transparent areas.
This is accomplished by simply not rendering those areas needing transparency
in the overridden <b>paint()</b> method. Also, it appears that in many
cases, lightweight components are more responsive to mouse actions than
their native counterparts.</font>

<p><font color="#000000">The lightweight component requires <u>no native
data-structures or peer classes</u>. There is no native code required to
process lightweight components. Thus, the handling of lightweight components
is <u>completely implemented in java code</u>. This should lead to consistency
across platforms.</font>

<p><font color="#000000">Note the following except from the JDK 1.1 documentation:</font><br>&nbsp;
<table border bgcolor="#80ffff" ><tr><td><font color="#000000">"We are using this framework in an upcoming version
of the toolkit (beyond 1.1) to implement pure-java versions of the base
UI controls (Button, List, etc.) which implement a common look-and-feel
across the platforms (and don't use the native peers)."</font></td></tr></table><font color="#000000">In this quotation, JavaSoft is apparently referring
to the <b>Swing</b> component of their <i>Java Foundation Classes.</i>
The <b>Swing</b> component is available in pre-beta form for downloading
and evaluation as of December of 1997. If you haven't evaluated <b>Swing</b>
yet, you should do so. You will find that it contains a large number of
extremely useful widgets, all implemented as lightweight components.</font>

<p><font color="#000000">In addition to the use of lightweight components
that will be provided by JavaSoft (and doubtless many other companies and
individuals as well), you can also design and create your own lightweight
components.</font>

<p><font color="#000000">You can mix lightweight components with the existing
heavyweight components. For example, lightweight components can be made
children of heavyweight containers or heavyweight components can be made
children of lightweight containers</font>

<p><font color="#000000">Heavyweight and lightweight components can be
mixed within containers. Note however, that the heavyweight component will
<u>always</u> be "on top" if it overlaps a lightweight component.</font>

<p><font color="#000000">Additional useful information regarding the rationale,
advantages, disadvantages, and cautions regarding lightweight components
can be found in the JDK 1.1 documentation package.</font>

<p><font color="#000000">With that as an introduction, let's move on to
our own lightweight button class.</font><center><h2><a name="the lightweight button class"></a><font color="#ff0000">The Lightweight
Button Class</font></h2></center>
This lightweight button class is designed to be compiled and run under
JDK 1.1 or later version. The purpose of the class is to illustrate the
creation of lightweight components.

<p>There are two major aspects to the creation and use of lightweight components:
<ul><li>
Making the components <i>live and work</i> within the system.</li>

<li>
Making the components <i>look and feel</i> the way that you want them to
look and feel.</li></ul>
The first aspect has to do with the <u>non-graphical</u> characteristics
of the component. In fact, the component could be a completely non-visual
component (such as a timer component, for example). Here we are concerned
with issues such as inheritance, event handling, etc. This gets us into
the realm of the types of objects discussed in an earlier lesson on "Program-Generated
Events."

<p>The second aspect primarily has to do with the visual (graphics) aspects
of the component. In this lesson, we will develop a lightweight 3D button
that behaves much as you would expect a heavyweight button to behave in
many applications. Before using this lightweight button design, however,
you should stop and ask yourself if any additional features need to be
added to make it compatible with a user's normal expectations of a button
(for example, it is not designed to respond to MOUSE_ENTERED and MOUSE_EXITED
events).

<p>In this lesson, we will proceed somewhat differently from our approach
in many of the previous lessons. In particular, we will develop and discuss
a class which implements our lightweight button. Then we will develop several
other applications which exercise the lightweight button using different
layout managers. However, we will defer the development of those applications
to subsequent lessons. Thus, this lesson will concentrate solely on the
lightweight button class.

<p>In an earlier lesson, we listed three essential ingredients of a class
that you may use to create your own components. That lesson dealt only
with non-visual components. Since this lesson deals with a visual component,
we will add a fourth essential ingredient having to do with rendering the
component on the screen. An abbreviated version of the list of essential
ingredients (with the fourth ingredient added) is repeated below for convenient
reference.
<ul><li><i>An instance variable</i> that is a reference to a list of registered
<b>Listener </b>objects. This lightweight component is designed to register
<b>Listener </b>objects of type <b>ActionListener</b>.</li>

<li><i>A method</i> for creating and maintaining the list mentioned above.</li>

<li><i>A method</i> which invokes the appropriate method of the <b>Listener
</b>class on the list of registered <b>Listener </b>objects.</li>

<li>
An overridden <b>paint()</b> method to render the component on the screen
at runtime.</li></ul>
This class is used to instantiate a 3D lightweight button object that behaves
much like a heavyweight <b>Button </b>object but is much more responsive
than a heavyweight button under JDK 1.1.3 and Win95 on a 133 mhz Pentium
processor.

<p>The color of the lightweight button is based on the background color
of its container, but is one shade brighter than the color of the background
when it appears to protrude out of the screen.

<p>Normally, the lightweight button appears to protrude slightly out of
the screen with highlights on the left and top edges and shadows on the
bottom and right edges. Note that the highlighting only works if the background
color does not contain RGB components with values at or near 255. This
is because the <b>brighter()</b> method is invoked on the background color
to provide the highlights. If the background color contains RGB components
at the high end of their limit, the <b>brighter()</b> method has no effect
(the colors cannot be made any brighter).

<p>When you click the lightweight button with the mouse, it appears to
retreat into the screen and then pops back out. As with a heavyweight button,
this causes it to <u>gain the focus</u>.

<p>When the lightweight button appears to retreat into the screen, its
color changes to match that of the background with heavy shadows on the
left and top and a faint outline on the bottom and right.

<p>Whenever the lightweight button has the focus, its text is rendered
in <b><i>bold italics</i></b>. This simulates the halo that appears around
the text on a a heavyweight button when it has the focus under Win95. When
it doesn't have focus, the text label is rendered as <b>plain</b> text.

<p>When you click the lightweight button with the mouse, it generates an
<b>Action</b> event. Also, if you press the space bar when the lightweight
button has the focus, it generates an <b>Action </b>event.

<p>This class was tested using JDK 1.1.3 under Win95.
<center><h3><a name="interesting code fragments"></a><font color="#ff0000">Interesting
Code Fragments</font></h3></center>
The first interesting code fragment is the first line in the class definition
which is provided here as a reminder that one way to create a lightweight
component is to extend the <b>Component</b> class.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>class LWButton01 <b>extends Component</b> {</pre></td></tr></table>
Early in the class definition we declare several instance variables that
are used throughout the class. For example, we maintain two different versions
of the label for the button: <b>rawLabel</b> and <b>label</b>. The first
is the label specified by the user to be displayed on the lightweight button.
The second is the same text string with two space characters concatenated
onto each end which is what is actually rendered onto the lightweight button.
The space characters are used to separate the ends of the text label from
the ends of the button.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; String <b>rawLabel</b>;
&nbsp; String <b>label</b>;
&nbsp; boolean <b>pressed </b>= false;&nbsp;
&nbsp; boolean <b>gotFocus </b>= false;
&nbsp; ActionListener <b>actionListener</b>;</pre></td></tr></table>
An instance variable named <b>pressed</b> is used by the overridden <b>paint()</b>
method to determine if the lightweight button has been <i>pressed</i> or
has been released.

<p>Similarly, an instance variable named <b>gotFocus</b> is true whenever
the lightweight button has the focus and is used to cause the text on the
button to be rendered in <b><i>bold italics</i></b> as a visual indication
of <i>focus</i>.

<p>The instance variable named <b>actionListener</b> is a reference to
a list of registered listener objects. This was the first of the essential
ingredients provided in the earlier list of essential ingredients. The
use of this instance variable will be explained in more detail later.

<p>Moving along to the next code fragment, as is the case with the heavyweight
<b>button</b> class, you can instantiate a lightweight button of this class
either
<ul><li>
by providing the label as a parameter, or</li>

<li>
by providing no parameter at all.</li></ul>
Thus, there are two overloaded versions of the constructor. The first,
which takes no parameters, simply invokes the second passing an empty string
as a parameter.

<p>As mentioned earlier, two different versions of the <b>String</b> label
are maintained. One is the raw label passed in as a parameter. The other
is the same text but with two spaces appended on each end. This second
version is actually rendered onto the lightweight button, providing space
between the ends of the label and the ends of the button.

<p>The two overloaded versions of the constructor are shown below.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; //Constructor for an LWButton with no label.
&nbsp; public <b>LWButton01</b>() {
&nbsp;&nbsp;&nbsp; //Invoke the parameterized constructor with an&nbsp;
&nbsp;&nbsp;&nbsp; // empty string
&nbsp;&nbsp;&nbsp; this("");
&nbsp; }//end constructor

&nbsp; //Constructor for an LWButton with a label.
&nbsp; public <b>LWButton01</b>(String rawLabel) {
&nbsp;&nbsp;&nbsp; this.rawLabel = rawLabel;
&nbsp;&nbsp;&nbsp; //Add spaces on either end and save it that way
&nbsp;&nbsp;&nbsp; this.label = "&nbsp; " + rawLabel + "&nbsp; ";
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <b>enableEvents</b>(AWTEvent.MOUSE_EVENT_MASK |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AWTEvent.FOCUS_EVENT_MASK |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AWTEvent.KEY_EVENT_MASK);
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//</pre></td></tr></table>
A very significant aspect of the second overloaded version of the constructor
is the invocation of the method named <b>enableEvents()</b>.

<p>You may remember that there are <u>two different ways</u> to service
events in the JDK 1.1 event model. The most common way is based on event
sources and event listeners, and we have provided many examples that operate
according to that approach.

<p>The second approach does not use listener objects, but rather uses a
pair of methods consisting of <b>enableEvents()</b> and <b>process...Event()</b>
where the <b>...</b> indicates the name of an event type.

<p>The operation using these two methods is relatively simple. If the method
named <b>enableEvents()</b> is invoked in the constructor for a class with
a specific event type being specified as a parameter, then whenever an
event of that type occurs on an object of that class, a corresponding method
named <b>process...Event()</b> will be invoked where the <b>...</b> matches
the type of event specified in the call to <b>enableEvents()</b>.

<p>Event types are specified in the parameter list of <b>enableEvents()</b>
by passing one or more <b>OR'ed</b> symbolic constants (which are defined
in the <b>AWTEvent</b> class) as parameters. The invocation of <b>enableEvents()</b>
in the constructor for this class (shown above) causes the methods <b>processMouseEvent()</b>,
<b>processFocusEvent()</b>, or <b>processKeyEvent()</b> to be invoked whenever
an event of one of those types occurs on an object of this class. These
three methods are overridden in this class to provide the desired behavior
for each type of event.

<p>Now let's move on to the next interesting code fragment.

<p>The second item in the list of essential ingredients provided earlier
was a method for creating and maintaining a list of registered listener
objects. In this case, our lightweight button will multicast <b>Action</b>
events, and therefore we must create and maintain a list of <b>listener</b>
objects registered to be notified of such events.

<p>We could create and maintain this list using some of the data structures
classes such as the <b>Vector</b> class. However, there is a standard class
named <b>AWTEventMulticaster</b> that is provided to help us in this regard.
The <b>AWTEventMulticaster</b> class not only assists us by creating and
maintaining the list, it is also used to notify all registered listeners
whenever an event occurs. Therefore, it is a very useful class that can
save us a lot of programming effort.

<p>The Java Beans <i>design patterns</i> for the registration of listener
objects are a pair of methods named <b>add...Listener()</b> and <b>remove...Listener()</b>
where the <b>...</b> indicates the type of events being registered. Therefore,
our class needs a pair of methods having these names which we provide as
<b>addActionListener()</b> and <b>removeActionListener()</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>addActionListener</b>(ActionListener listener) {
&nbsp;&nbsp;&nbsp; actionListener = <b>AWTEventMulticaster</b>.<b>add</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actionListener, listener);
&nbsp; }//end addActionListener()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>removeActionListener</b>(ActionListener listener){
&nbsp;&nbsp;&nbsp;&nbsp; actionListener = <b>AWTEventMulticaster</b>.<b>remove</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actionListener, listener);
&nbsp; }//end removeActionListener</pre></td></tr></table>
We use the <b>AWTEventMulticaster</b> class to create and maintain our
list by invoking the <i>static </i><b>add </b>and <b>remove </b>methods
of that class as shown above.

<p>Note that in both cases, our method receives an object of type <b>ActionListener</b>
(an object of a class that implements the <b>ActionListener</b> interface).
We simply pass that object along to the <b>add</b> or <b>remove</b> method
of the <b>AWTEventMulticaster</b> class. These methods return a reference
to the list which we then assign to our instance variable named <b>actionListener</b>.
Later we will use this reference variable (with help from the <b>AWTEventMulticaster</b>
class) to notify all of the registered listener objects that an <b>Action
</b>event has occurred on the lightweight button.

<p>Now let's turn our attention to the next code fragment.

<p>The standard operation for a heavyweight button is to respond to the
space bar as though it were the left mouse button when the heavyweight
button has the focus. The next code fragment is intended to simulate that
behavior on the lightweight button. While we do simulate that behavior,
we <u>do not duplicate it exactly</u>. The heavyweight button appears to
be immune to the fact that holding the space bar down generates a repeated
string of space characters. Our lightweight button is not immune. Holding
the space bar down generates a series of events. We would have to add more
logic (or interpret the key event differently) to cause it to ignore the
additional space characters and duplicate the behavior of the heavyweight
button.

<p>This will be the first in a series of three methods of the <b>process...Event()</b>
variety. This particular method is designed to process <b>key </b>events.
Recall from the above discussion that this method is <u>automatically invoked</u>
whenever a <b>key </b>event occurs on a lightweight button while it has
the <b>focus</b>. If this isn't clear, you should go back to an earlier
page and review it again, or perhaps go back and review an earlier lesson
on the subject.

<p><u>An extremely important rule</u> when invoking any of the <b>process...Event()</b>
methods is that you <u>must</u> execute the statement <b>super.process...Event()</b>
at the end of your method. The possibility of forgetting to do this, with
the attendant possibility of unpredictable results at runtime, is probably
one of the reasons that the JavaSoft documentation advises you to exercise
caution when using this approach to event handling.
<br>&nbsp;
<table border bgcolor="#00ffff" ><tr><td>For an explanation of this rule and a sample program, see the following
reference in the JavaSoft JDK 1.1.3 documentation (your path may begin
in a different directory):&nbsp;

<p>file:///C|/java_jdk/java/docs/guide/awt/designspec/events.html

<p>Also see lesson 102 which contains an excerpt from that JavaSoft document
as well as a sample program from JavaSoft showing an unconditional call
to <b>super.processFocusEvent(e)</b> at the end of an overridden method
named <b>processFocusEvent(FocusEvent e)</b>. Be aware that not all books
show this as an unconditional call.</td></tr></table>
The logic in this method is pretty straightforward. When the method is
invoked, it receives an object of type <b>KeyEvent</b>. It examines this
object to determine if the keyboard character is the <i>space </i>character,
and if not, returns without doing anything other than invoking the same
method on its superclass.

<p>If the character is a <i>space</i>, then the code distinguishes between
<b>KEY_PRESSED</b> and <b>KEY_RELEASED</b>.

<p>On <b>KEY_PRESSED</b>, a call is made to the <b>processMouseEvent()</b>
method, passing <b>MOUSE_PRESSED</b> as a parameter.

<p>On <b>KEY_RELEASED</b>, a call is made to the <b>processMouseEvent()</b>
method passing <b>MOUSE_RELEASED</b> as a parameter.

<p>In effect, the method converts these two key events to a pair of corresponding
mouse events and dispatches them as mouse events.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>processKeyEvent</b>(KeyEvent e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if((e.getID() == KeyEvent.<b>KEY_PRESSED</b>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (e.getKeyChar() == ' '))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>processMouseEvent</b>(new MouseEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,MouseEvent.<b>MOUSE_PRESSED</b>,0,0,0,0,0,false));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if((e.getID() == KeyEvent.<b>KEY_RELEASED</b>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (e.getKeyChar() == ' '))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>processMouseEvent</b>(new MouseEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,MouseEvent.<b>MOUSE_RELEASED</b>,0,0,0,0,0,false));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <b>super.processKeyEvent(e)</b>;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end processKeyEvent()&nbsp;&nbsp;</pre></td></tr></table>
Now let's consider the next code fragment which consists of the second
in a series of methods of the <b>process...Event()</b> variety.

<p>Later we will see that when a <b>MOUSE_RELEASED</b> event occurs on
our lightweight button, the lightweight button <u>requests the focus</u>.
Assuming that the request is successful, this will cause a <b>FOCUS_GAINED
</b>event to occur on the lightweight button.

<p>Similarly, when the lightweight button has the focus and it moves to
another component for any reason, a <b>FOCUS_LOST</b> event will occur
on the lightweight button.

<p>Knowing whether or not the lightweight button has the focus is important
in two respects. First, the button will respond to key events when it has
the focus.

<p>Second, in order to provide visual feedback regarding focus to the user,
the manner in which the lightweight button is rendered should be different
when it has, and when it does not have the focus.

<p>The overridden <b>paint()</b> method for this lightweight button renders
the text label on the button in <b><i>bold italics</i></b> when it has
the focus, and renders it <b>plain</b> otherwise. Thus a lightweight button
without a label wouldn't have any indication of focus. This is the type
of thing that I was referring to earlier when I cautioned against using
this lightweight button class for serious programming without considering
the need for additional or different functionality.

<p>The code in the following method traps <b>focus</b> events and sets
an instance variable named <b>gotFocus</b> to <b>true </b>when the lightweight
button gains the focus and sets it to <b>false </b>when the button loses
the focus. This instance variable is used by code elsewhere in the program
to render the text on the lightweight button accordingly.

<p>After setting the <b>gotFocus</b> flag to true or false, this method
causes the lightweight button to be repainted so that the change in the
style of the text will become immediately apparent to the user. According
to the documentation for JDK 1.1.3, the call to the <b>invalidate()</b>
method marks the lightweight button and all its parents as needing to be
laid out before repainting the screen.

<p>Again, this method is invoked automatically whenever a focus event occurs
on the lightweight button.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>processFocusEvent</b>(FocusEvent e) {
&nbsp;&nbsp;&nbsp; if(e.getID() == FocusEvent.<b>FOCUS_GAINED</b>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gotFocus = <b>true</b>; //set the gotFocus flag
&nbsp;&nbsp;&nbsp; if(e.getID() == FocusEvent.<b>FOCUS_LOST</b>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gotFocus = <b>false</b>; //clear the gotFocus flag
&nbsp;&nbsp;&nbsp; this.<b>invalidate</b>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; this.<b>repaint</b>();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <b>super.processFocusEvent(e)</b>;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end processFocusEvent()</pre></td></tr></table>
The next code fragment is the third in the series of <b>process...Event()</b>
methods that are automatically invoked whenever an event of the matching
type occurs on a lightweight button. This method has three primary purposes:
<ul><li>
Cause the appearance of the lightweight button to be modified when the
user clicks on it to provide the 3D visual feedback to the user.</li>

<li>
Invoke the <b>actionPerformed()</b> method on all the listener objects
registered to receive notification of action events on the button.</li>

<li>
Cause the lightweight button to gain the focus and to provide a visual
indication of focus.</li></ul>
The second item brings us to another topic that we have discussed in earlier
lessons, but which we will review here for convenience. As mentioned above,
the <b>add()</b> and <b>remove()</b> methods of the <b>AWTEventMulticaster</b>
class can be used to create and maintain the list of registered listener
objects.

<p>The <b>AWTEventMulticaster</b> class provides another very important
service -- listener notification.

<p>Recall that the <b>add()</b> and <b>remove()</b> methods of <b>AWTEventMulticaster</b>
return a reference to an object of type <b>ActionListener</b> (which is
really a reference to a list of <b>ActionListener</b> objects). We assigned
that reference to an instance variable named <b>actionListener</b>.

<p>This is the great news: all we have to do to invoke the <b>actionPerformed()</b>
method on <u>every listener object</u> in the list is to <u>invoke it once</u>
on the reference to the list (invoke the method on our instance variable
named <b>actionListener</b>). The code in the <b>AWTEventMulticaster</b>
class will then take responsibility for invoking the method on every object
in the list.

<p>Now back to the code fragment. Early in this discussion, you were introduced
to an instance variable named <b>pressed</b>. All that this method really
has to do to cause the appearance of the lightweight button object to be
modified appropriately is to <u>set this instance variable</u> to either
<b>true </b>or <b>false</b>.

<p>The code in the overridden <b>paint()</b> method (that we discuss later)
will test the state of the <b>pressed</b> instance variable and do the
rest. When <b>pressed</b> is true, the button is rendered as though it
has been <u>pressed into the screen</u>. Otherwise, it is rendered as though
it <u>protrudes out from the screen</u>.

<p>This method is automatically invoked whenever a mouse event occurs on
the lightweight button (which includes an event created and dispatched
by the <b>key</b> processor discussed earlier).

<p>The method cracks open the incoming object to determine what kind of
mouse event occurred. All event types other than <b>MOUSE_PRESSED</b> and
<b>MOUSE_RELEASED</b> are ignored.

<p>When the event type is <b>MOUSE_PRESSED</b>, the method sets the <b>pressed</b>
instance variable and calls <b>repaint()</b> to cause the lightweight button
to be rendered in its new image.

<p>When the type is <b>MOUSE_RELEASED</b>, three things are done:
<ul><li>
Invoke the <b>actionPerformed()</b> method on the reference to the list
of registered listeners.</li>

<li>
Set the <b>pressed</b> flag to false and force a repaint.</li>

<li>
Request <b>focus </b>for the lightweight button.</li></ul>
As you can see from the code below, when the <b>actionPerformed()</b> method
is invoked, it is necessary to instantiate and pass an object of type <b>ActionEvent</b>
which encapsulates the source object for the event (<b>this</b>), the type
of event (<b>ACTION_PERFORMED</b>), and any string object that you want
to pass to the method that will be processing the event (this string is
referred to in the documentation as the <i>command name</i>).
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public void <b>processMouseEvent</b>(MouseEvent e) {
&nbsp;&nbsp;&nbsp; switch(e.<b>getID</b>()) {//what kind of mouse event?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MouseEvent.<b>MOUSE_PRESSED</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pressed = <b>true</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.<b>invalidate</b>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.<b>repaint</b>();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MouseEvent.<b>MOUSE_RELEASED</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if an ActionListener is registered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(actionListener != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>actionListener.actionPerformed(new ActionEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, ActionEvent.ACTION_PERFORMED, label))</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on actionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pressed == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>pressed </b>= <b>false</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.<b>requestFocus()</b>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.invalidate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.<b>repaint</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on pressed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; }//end switch

<b>&nbsp;&nbsp;&nbsp; super.processMouseEvent(e);
</b>&nbsp; }//end processMouseEvent()</pre></td></tr></table>
After we invoke the <b>actionPerformed()</b> method appropriately, we set
the <b>pressed</b> flag to <i>false</i>, request the <b>focus</b>, and
force a <b>repaint</b>.

<p>We end the method with the mandatory call to the superclass version
of the same method.

<p>Getting on to the next code fragment, there are two properties of a
component that are used by the various layout managers in laying out the
components in a GUI: <b>preferredSize</b> and <b>minimumSize</b>.

<p>These are read-only properties, so they don't have a <b>set</b> method.
However, a component normally has a <b>get</b> method for each of these
properties. The next code fragment provides the <b>get</b> methods for
the <b>preferredSize </b>and <b>minimumSize </b>for our lightweight button.

<p>In this case, the <b>preferred </b>size is based on the size required
to accommodate the text in the label for the button. Here we use the version
of the label that has two spaces appended on each end to provide space
between the ends of the label and the ends of the button. We add ten pixels
to the height of the label to establish the preferred height of the lightweight
button.

<p>If you don't understand the use of the <b>FontMetrics</b> class (as
seen below) to obtain size information for the label, you can find a discussion
of font metrics in an earlier lesson.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public Dimension <b>getPreferredSize</b>() {
&nbsp;&nbsp;&nbsp; if(getFont() != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = <b>getFontMetrics</b>(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Dimension(fm.stringWidth(label),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fm.getHeight() + 10);
&nbsp;&nbsp;&nbsp; } else return new Dimension(10, 10);//no font
&nbsp; }//end getPreferredSize()
&nbsp;&nbsp;
&nbsp; //Override the <b>getMinimumSize</b>() method and specify
&nbsp; // an arbitrary minimum size for the LWButton.
&nbsp; public Dimension getMinimumSize() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Dimension(10, 10);
&nbsp; }//end getMinimumSize()</pre></td></tr></table>
Since I didn't have any rational basis for establishing a minimum size
for the lightweight button, I arbitrarily set the minimum size to a square,
ten pixels on each side. At this point, I'm not certain what conditions
would cause this information to be used by a layout manager.

<p>Regarding the next code fragment, some but not all of the standard heavyweight
components have a property named <b>label</b>. When the property exists,
it is normally a read/write property with both <b>set</b> and <b>get</b>
methods included in the class definition. Our lightweight button has such
a property and its state is stored in the two instance variables named
<b>rawLabel</b> and <b>label</b> discussed earlier. Again, the difference
is that two space characters are appended to each end of the <b>rawLabel</b>
to produce the <b>label</b>. The value of <b>label</b> is actually used
to render the lightweight button and the space characters provide space
between the ends of the text and the ends of the button.

<p>Whenever the <b>getLabel()</b> method is invoked on the lightweight
button, the value of <b>rawLabel</b> is returned.

<p>Whenever the <b>setLabel()</b> method is invoked on the button, the
incoming value is stored in <b>rawLabel</b>, the modified version of the
incoming value is stored in <b>label</b>, and <b>repaint()</b> is called
to force the lightweight button to be rendered on the screen with the new
label. The code is pretty straightforward.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp; public String <b>getLabel</b>() {//gets the label
&nbsp;&nbsp;&nbsp; return <b>rawLabel</b>;
&nbsp; }//end getLabel()
&nbsp;&nbsp;
&nbsp; public void <b>setLabel</b>(String rawLabel) {
&nbsp;&nbsp;&nbsp; this.<b>rawLabel </b>= rawLabel; //save the raw label
&nbsp;&nbsp;&nbsp; //Add spaces to each end of the rawLabel to make it
&nbsp;&nbsp;&nbsp; // easier to center the label in the LWButton.
&nbsp;&nbsp;&nbsp; this.<b>label </b>= "&nbsp; " + rawLabel + "&nbsp; ";
&nbsp;&nbsp;&nbsp; this.<b>invalidate</b>();
&nbsp;&nbsp;&nbsp; this.<b>repaint</b>();
&nbsp; }//end setLabel()</pre></td></tr></table>
And that brings us to the overridden <b>paint()</b> method which is where
all of the visual rendering takes place. The <b>paint()</b> method examines
the values of instance variables established by code in other parts of
the class and uses those values to make decisions about how to render the
lightweight button.

<p>In particular, the instance variable named <b>pressed</b> is used to
decide whether the lightweight button should be rendered <u>protruding
from the screen</u>, or <u>pressed into the screen</u>.

<p>The instance variable named <b>gotFocus</b> is used to decide whether
to render the text label <b>plain</b> or in <b><i>bold italics</i></b>
to indicate that the lightweight button has the focus.

<p>The 3D effect is achieved by rendering edges to be either darker or
brighter to give the illusion of shadows or highlights. The actual mechanism
for doing this by drawing offset rectangles was developed and explained
in an earlier lesson that discussed various graphics techniques, and won't
be discussed in any detail in this lesson. You are referred to the earlier
lesson if you don't remember how those techniques are used.

<p>Another trick that is used to give the illusion that the button has
actually been pressed into the screen is to cause the text label to shift
slightly down and to the right when the button is pressed (or up and to
the left when the button pops back out). This trick along with a corresponding
change in shadow position does a pretty good job of delivering the desired
optical illusion.

<p>In this version, the color of the lightweight button is tied to the
color of the background of the container. When protruding from the screen,
the color of the button is a brighter version of the background color suggesting
that it receives more light because it protrudes. The left and top edges
are highlighted with an even brighter version of the same color to suggest
a light source that is up and to the left. The bottom and right edges are
darkened using a darker version of the background color to give the illusion
of shadows.

<p>When the button is pushed into the screen, the color is changed to the
color of the background to suggest that it no longer catches more light
than the background. In addition, shadows are produced on the left and
top edges to give the illusion that it has been physically pushed into
the screen. A faint dark outline of the bottom and right edges is provided
in this state so that the button can be distinguished from the background.

<p>Despite the specification of <b>preferred </b>and <b>minimum </b>size
for the lightweight button discussed earlier, the actual size on the screen
is determined by the layout manager in use. The layout manager may or may
not honor one, the other, or both of the dimensions of the <b>preferred</b>
size. Therefore, it is necessary to determine the actual size before rendering
the button and not rely on the <b>preferredSize</b> to tell us the size
to render.

<p>Now getting back to the code, this method is so large that it will be
broken into separate code fragments. The first interesting fragment is
used to cause the text label to be rendered differently depending on whether
or not the lightweight button has the focus. If the <b>gotFocus</b> flag
is <b>true</b>, the text is rendered in <b><i>bold italics</i></b>. Otherwise,
it is rendered <b>plain</b>.

<p>Although fairly complicated looking, this code is a straightforward
application of font-manipulation techniques that we learned in previous
lessons. Recall that all drawing is actually performed on the <i>graphics
context</i> that is passed as a parameter to the <b>paint()</b> method.
In this code, the name of the graphics context is <b>g</b>.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; if(<b>gotFocus</b>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setFont</b>(new Font(getFont().getName(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Font.<b>BOLD </b>| Font.<b>ITALIC</b>,getFont().getSize()));
&nbsp;&nbsp;&nbsp; else g.<b>setFont</b>(new Font(getFont().getName(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Font.<b>PLAIN</b>,getFont().getSize()));</pre></td></tr></table>
The remaining code in the overridden <b>paint()</b> method is divided into
two categories based on whether the <b>pressed</b> flag is <b>true </b>or
<b>false</b>.

<p>We will begin by examining a series of statements that are executed
when the <b>pressed</b> flag is true.

<p>The first few statements that we see in the following code fragment
manipulate the drawing color, fill a rectangle with color, and manipulate
the placement of rectangles on the drawing surface to give the illusion
of shadows. We manipulate the placement by specifying the coordinates of
the upper left-hand corner of the rectangle in the first two parameters.

<p>Recall that when we use rectangles in this way, two sides of the rectangle
are actually off the drawing surface and the other two sides are on the
drawing surface. Thus, each time we draw a rectangle, we are actually drawing
a pair of orthoganal lines in the desired position. We could accomplish
the same thing by drawing lines instead of rectangles, but more code would
be required. We use rectangles simply for convenience because we get two
lines for every statement.

<p>The comments in this code pretty well describe what is going on.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; if(<b>pressed</b>){ //if the pressed flag is true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(getBackground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>fillRect</b>(//fill rectangle with background color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw shadows three shades darker than background
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().<b>darker</b>().<b>darker</b>().<b>darker</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that three offset rectangles are drawn to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produce a shadow effect on the <b>left </b>and <b>top </b>of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rectangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,1,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,2,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now draw a <b>faint </b>outline on the <b>bottom </b>and <b>right </b>of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rectangle.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(getBackground().<b>darker</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,-1,this.getSize().width,this.getSize().height);</pre></td></tr></table>
The next interesting code fragment in the <b>pressed</b> state uses <b>FontMetrics</b>
to display the text label in the center of the lightweight button. Again,
we have covered everything seen here in earlier lessons. You need to understand
how this is being done, so if you have forgotten, you should go back and
review the earlier lessons.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = <b>getFontMetrics</b>(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(getForeground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawString</b>(label,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getSize</b>().width/2 - fm.<b>stringWidth</b>(label)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getSize</b>().height/2 + fm.<b>getAscent</b>()/2);</pre></td></tr></table>
That concludes the code fragments for the case where the <b>pressed</b>
flag is true and the lightweight button appears to have been pressed into
the screen.

<p>Now we will examine the case where the <b>pressed</b> flag is false
and the lightweight button appears to be protruding from the screen.

<p>Again, we begin by setting drawing colors, drawing filled rectangles,
and drawing offset rectangles to give the illusion of highlights and shadows.
As before, the comments pretty well explain what is going on.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp; else{//<b>not pressed
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the <b>protruding </b>LWButton object one shade
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>brighter </b>than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(getBackground().<b>brighter</b>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>fillRect</b>(//and fill a rectangle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the color for the <b>shadows </b>three shades <b>darker
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().<b>darker().darker().darker()</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw two offset rectangles to create <b>shadows </b>on&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the <b>right </b>and <b>bottom</b>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,-1,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2,-2,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<b>Highlight </b>the <b>left </b>and <b>top </b>two shades <b>brighter&nbsp;
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the background, one shade <b>brighter </b>than the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // color of the LWButton itself which is one shade
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // brighter than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().brighter().brighter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawRect</b>(//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);</pre></td></tr></table>
And that brings us to the final step which is to display the text label
on the protruding button at a position that is displaced up and to the
left by two pixels relative to the position of the text when the button
is <b>pressed</b>. This change in position as the button switches from
depressed to protruding enhances the illusion that the button is actually
moving.

<p>The code shown below is the same as you saw earlier except for the offset
of two pixels in the negative direction highlighted in boldface at the
right-end of two lines below.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now place the text in the LWButton object shifted
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by two pixels up and to the left.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = <b>getFontMetrics</b>(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>setColor</b>(getForeground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.<b>drawString</b>(label,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width/2 - fm.<b>stringWidth</b>(label)/2 <b>- 2</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height/2 + fm.<b>getAscent</b>()/2 <b>- 2</b>);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end overridden paint() method</pre></td></tr></table>
That concludes the discussion of interesting code fragments for the lightweight
button class.

<p>So what do we have at this point? We have a new class from which we
can instantiate lightweight button objects and add them to containers for
the construction of graphical user interfaces. To see how these lightweight
buttons behave, we will need to devise some applications to exercise them.

<p>We will defer demonstrations of the use of our lightweight buttons until
we devise some test applications in lessons following this one.
<center><h3><a name="program listing"></a><font color="#ff0000">Program Listing</font></h3></center>
A complete listing of the lightweight button class with extensive comments
follows.
<br>&nbsp;
<table border bgcolor="#ffff80" ><tr><td><pre>/* File LWButton01.java Copyright 1997, R.G.Baldwin

This class is used to instantiate a 3D lightweight button
object that behaves quite a bit like a heavyweight Button
object but is much more responsive than a heavyweight
button under JDK 1.1.3 and Win95 on a 133 mhz Pentium
processor.

The color of the button is based on the background color&nbsp;
of its container, but is one shade brighter than the color
of the background.&nbsp;

Normally, it appears to protrude slightly out of the&nbsp;
screen with highlights on the left and top edges and&nbsp;
shadows on the bottom and right edges.&nbsp; Note that the
highlighting only works if the background color does not
contain components with values of 255.

When you click the button with the mouse, it appears to&nbsp;
retreat into the screen and then pops back out.&nbsp; As with
a heavyweight button, this causes it to gain the focus.

When it appears to retreat into the screen, its color&nbsp;
changes to match that of the background with heavy shadows
on the left and top and a faint outline on the bottom and
right.

The visual indication of focus is that the text on the
button is rendered in bold italics.

When you click the button, it generates an action event.

When the button has the focus and you press the space
bar, it generates an action event.

This class was tested using JDK 1.1.3 under Win95.
*/
//=======================================================//
import java.awt.*;
import java.awt.event.*;
//=======================================================//
class LWButton01 extends Component {
&nbsp; //Save the raw label provided by the user here to make
&nbsp; // it available to the getLabel() method.
&nbsp; String rawLabel;
&nbsp; //The following instance variable contains the raw
&nbsp; // label with two spaces appended to each end to make
&nbsp; // it easier to use for sizing the LWButton.
&nbsp; String label;
&nbsp; // The following instance variable is set to true if&nbsp;
&nbsp; // the LWButton is pressed and not released.
&nbsp; boolean pressed = false;&nbsp;
&nbsp; //The following instance variable is set to true when&nbsp;
&nbsp; // the LWButton has focus
&nbsp; boolean gotFocus = false;
&nbsp; //The following instance variable refers to a list of&nbsp;
&nbsp; // registered ActionListener objects.
&nbsp; ActionListener actionListener;
&nbsp;&nbsp;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Constructor for an LWButton with no label.
&nbsp; public LWButton01() {
&nbsp;&nbsp;&nbsp; //Invoke the parameterized constructor with an&nbsp;
&nbsp;&nbsp;&nbsp; // empty string
&nbsp;&nbsp;&nbsp; this("");
&nbsp; }//end constructor

&nbsp; //Constructor for an LWButton with a label.
&nbsp; public LWButton01(String rawLabel) {
&nbsp;&nbsp;&nbsp; this.rawLabel = rawLabel;
&nbsp;&nbsp;&nbsp; //Add spaces on either end and save it that way
&nbsp;&nbsp;&nbsp; this.label = "&nbsp; " + rawLabel + "&nbsp; ";
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Invoke the enableEvents() method so that the
&nbsp;&nbsp;&nbsp; // processMouseEvent(), processFocusEvent(), and
&nbsp;&nbsp;&nbsp; // processKeyEvent() methods will be automatically
&nbsp;&nbsp;&nbsp; // invoked whenever an event of the corresponding
&nbsp;&nbsp;&nbsp; // type occurs on the LWButton.&nbsp; Note that this is
&nbsp;&nbsp;&nbsp; // an alternative approach to the source/listener
&nbsp;&nbsp;&nbsp; // event model.
&nbsp;&nbsp;&nbsp; enableEvents(AWTEvent.MOUSE_EVENT_MASK |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AWTEvent.FOCUS_EVENT_MASK |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AWTEvent.KEY_EVENT_MASK);
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //The following method uses the AWTEventMulticaster&nbsp;
&nbsp; // class to construct a list of ActionListener objects&nbsp;
&nbsp; // that are registered on the LWButton object
&nbsp; public void addActionListener(ActionListener listener) {
&nbsp;&nbsp;&nbsp; actionListener = AWTEventMulticaster.add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actionListener, listener);
&nbsp; }//end addActionListener()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //The following method removes ActionListener objects&nbsp;
&nbsp; // from the list described above
&nbsp; public void removeActionListener(ActionListener listener){
&nbsp;&nbsp;&nbsp;&nbsp; actionListener = AWTEventMulticaster.remove(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actionListener, listener);
&nbsp; }//end removeActionListener

&nbsp; /*-----------------------------------------------------//
&nbsp; This method is used to cause the LWButton to behave as
&nbsp; if a mouse event occurred on it whenever it has the
&nbsp; focus and the space bar is pressed and then released.
&nbsp; Holding the space bar down generates repetitive&nbsp;
&nbsp; events due to the repeat feature of the keyboard (this
&nbsp; would need to be disabled in a real program).
&nbsp;&nbsp;
&nbsp; This method is automatically called whenever a key&nbsp;
&nbsp;&nbsp;&nbsp; event occurs on the LWButton and the method&nbsp;
&nbsp;&nbsp;&nbsp; enableEvents(AWTEvent.KEY_EVENT_MASK) has been&nbsp;
&nbsp;&nbsp;&nbsp; previously invoked on the LWButton.&nbsp; */&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void processKeyEvent(KeyEvent e) {
&nbsp;&nbsp;&nbsp; //Generate mousePressed() event when the space bar&nbsp;
&nbsp;&nbsp;&nbsp; // is pressed by invoking the processMouseEvent()
&nbsp;&nbsp;&nbsp; // method and passing an event object that&nbsp;
&nbsp;&nbsp;&nbsp; // impersonates a mouse pressed event.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if((e.getID() == KeyEvent.KEY_PRESSED)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (e.getKeyChar() == ' '))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processMouseEvent(new MouseEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,MouseEvent.MOUSE_PRESSED,0,0,0,0,0,false));

&nbsp;&nbsp;&nbsp; //Generate mouseReleased() event when the space bar&nbsp;
&nbsp;&nbsp;&nbsp; // is released by invoking the processMouseEvent()
&nbsp;&nbsp;&nbsp; // method and passing an event object that&nbsp;
&nbsp;&nbsp;&nbsp; // impersonates a mouse released event.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if((e.getID() == KeyEvent.KEY_RELEASED)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (e.getKeyChar() == ' '))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processMouseEvent(new MouseEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,MouseEvent.MOUSE_RELEASED,0,0,0,0,0,false));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //The following statement is always needed when an
&nbsp;&nbsp;&nbsp; // overridden version of processKeyEvent() is used.
&nbsp;&nbsp;&nbsp; super.processKeyEvent(e);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end processKeyEvent()&nbsp;&nbsp;

&nbsp; /*-----------------------------------------------------//
&nbsp; This method in invoked when a focus event occurs on the
&nbsp;&nbsp;&nbsp; LWButton.&nbsp; This happens when the requestFocus() method
&nbsp;&nbsp;&nbsp; is called inside the mouseReleased() event handler for
&nbsp;&nbsp;&nbsp; the LWButton.&nbsp; This sets or clears the gotFocus flag&nbsp;
&nbsp;&nbsp;&nbsp; that is used to cause the text renderer to modify the
&nbsp;&nbsp;&nbsp; text to indicate that the LWButton has the focus.
&nbsp;&nbsp;&nbsp; When the LWButton has the focus, the text is rendered
&nbsp;&nbsp;&nbsp; in bold italics.
&nbsp;&nbsp;
&nbsp; This method is automatically called whenever a focus&nbsp;
&nbsp;&nbsp;&nbsp; event occurs on the LWButton and the method&nbsp;
&nbsp;&nbsp;&nbsp; enableEvents(AWTEvent.FOCUS_EVENT_MASK) has been&nbsp;
&nbsp;&nbsp;&nbsp; previously invoked on the LWButton.&nbsp; */&nbsp;&nbsp;

&nbsp; public void processFocusEvent(FocusEvent e) {
&nbsp;&nbsp;&nbsp; if(e.getID() == FocusEvent.FOCUS_GAINED)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gotFocus = true; //set the gotFocus flag
&nbsp;&nbsp;&nbsp; if(e.getID() == FocusEvent.FOCUS_LOST)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gotFocus = false; //clear the gotFocus flag
&nbsp;&nbsp;&nbsp; this.invalidate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; this.repaint();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //The following statement is always needed when an
&nbsp;&nbsp;&nbsp; // overridden version of processFocusEvent() is used.
&nbsp;&nbsp;&nbsp; super.processFocusEvent(e);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end processFocusEvent()

&nbsp; /*-----------------------------------------------------//
&nbsp; The&nbsp; purpose of this method is twofold:
&nbsp;&nbsp; 1.&nbsp; Modify the appearance of the LWButton object when
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the user clicks on it.
&nbsp;&nbsp; 2.&nbsp; Invoke the actionPerformed() method in the Listener&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object that is registered to listen to this&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LWButton object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; This method is automatically called whenever a mouse&nbsp;
&nbsp;&nbsp;&nbsp; event occurs on the LWButton and the method&nbsp;
&nbsp;&nbsp;&nbsp; enableEvents(AWTEvent.MOUSE_EVENT_MASK) has been&nbsp;
&nbsp;&nbsp;&nbsp; previously invoked on the LWButton.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; public void processMouseEvent(MouseEvent e) {
&nbsp;&nbsp;&nbsp; switch(e.getID()) {//what kind of mouse event?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MouseEvent.MOUSE_PRESSED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //When the mouse is pressed on the LWButton object,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the "pressed" state of the object to true&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and force it to be repainted to change its&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // appearance. When pressed is true, the button is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rendered as though it has been pressed into the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // screen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pressed = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.invalidate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.repaint();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MouseEvent.MOUSE_RELEASED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //When the mouse is released on the LWButton object:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1. Invoke the actionPerformed() method in the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Listener objects that are registered to&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; listen to the LWButton object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2. Confirm that the "pressed" state is true and&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; if so, set it to false and force the object&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; to be repainted to change its appearance.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; When pressed is false, the button is rendered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; so as to appear to protrude out of the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; screen.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3. Request the focus for the LWButton object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if an ActionListener is registered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(actionListener != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke the actionPerformed() method on the list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of listener objects registered on the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // LWButton object.&nbsp; Instantiate and pass an
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ActionEvent object as a parameter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actionListener.actionPerformed(new ActionEvent(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, ActionEvent.ACTION_PERFORMED, label));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on actionListener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pressed == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pressed = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.requestFocus();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.invalidate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if on pressed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; }//end switch

&nbsp;&nbsp;&nbsp; //The following statement is always needed when an
&nbsp;&nbsp;&nbsp; // overridden version of processMouseEvent() is used.
&nbsp;&nbsp;&nbsp; super.processMouseEvent(e);
&nbsp; }//end processMouseEvent()
&nbsp;&nbsp;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //The following two methods provide the preferred size&nbsp;
&nbsp; // and the minimum size of the LWButton to be used by&nbsp;
&nbsp; // the layout managers.&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp; //Override the getPreferredSize() method.&nbsp; Base the
&nbsp; // preferred size on the size of the text in the
&nbsp; // LWButton object.&nbsp; Recall that two spaces have been
&nbsp; // appended to each end of the text in the LWButton.
&nbsp; public Dimension getPreferredSize() {
&nbsp;&nbsp;&nbsp; if(getFont() != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = getFontMetrics(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Dimension(fm.stringWidth(label),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fm.getHeight() + 10);
&nbsp;&nbsp;&nbsp; } else return new Dimension(10, 10);//no font
&nbsp; }//end getPreferredSize()
&nbsp;&nbsp;
&nbsp; //Override the getMinimumSize() method and specify
&nbsp; // an arbitrary minimum size for the LWButton.
&nbsp; public Dimension getMinimumSize() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Dimension(10, 10);
&nbsp; }//end getMinimumSize()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //The following two methods are available to get and set
&nbsp; // the label of an LWButton object.
&nbsp; public String getLabel() {//gets the label
&nbsp;&nbsp;&nbsp; return rawLabel;
&nbsp; }//end getLabel()
&nbsp;&nbsp;
&nbsp; public void setLabel(String rawLabel) {//sets the label
&nbsp;&nbsp;&nbsp; this.rawLabel = rawLabel; //save the raw label
&nbsp;&nbsp;&nbsp; //Add spaces to each end of the rawLabel to make it
&nbsp;&nbsp;&nbsp; // easier to center the label in the LWButton.
&nbsp;&nbsp;&nbsp; this.label = "&nbsp; " + rawLabel + "&nbsp; ";
&nbsp;&nbsp;&nbsp; this.invalidate();
&nbsp;&nbsp;&nbsp; this.repaint();
&nbsp; }//end setLabel()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //The following overridden paint() method paints the&nbsp;
&nbsp; // LWButton&nbsp; The appearance of the LWButton depends on
&nbsp; // the pressed and gotFocus flags.&nbsp; When pressed is true,
&nbsp; // the LWButton is rendered to appear that it has been
&nbsp; // pressed into the screen.&nbsp; When it is false, the
&nbsp; // LWButton is rendered to appear that it is protruding
&nbsp; // from the screen.&nbsp; When gotFocus is true, the
&nbsp; // text is rendered in bold italics as the visual&nbsp;
&nbsp; // indication that the LWButton has the focus.&nbsp; When
&nbsp; // gotFocus is false, the text is rendered plain.
&nbsp;&nbsp;
&nbsp; //Note also that the position of the text also depends
&nbsp; // on the pressed flag.&nbsp; When pressed is false, the text
&nbsp; // is rendered slightly up and to the left of its
&nbsp; // pressed position.&nbsp; This enhances the illusion that
&nbsp; // the button is being pressed into the screen.
&nbsp;&nbsp;
&nbsp; //The color of the LWButton object is tied to the
&nbsp; // background color.&nbsp; When protruding, the button is&nbsp;
&nbsp; // rendered one shade brighter than the background.&nbsp;&nbsp;
&nbsp; // When pressed, the LWButton is rendered the same color
&nbsp; // as the background.

&nbsp; //The actual size of the LWButton object is determined&nbsp;
&nbsp; // by the layout manager which may or may not honor the
&nbsp; // preferred and minimum size specifications.
&nbsp;&nbsp;
&nbsp; public void paint(Graphics g) {//paints the LWButton
&nbsp;&nbsp;&nbsp; //If LWButton has the focus, display the text in
&nbsp;&nbsp;&nbsp; // bold italics.&nbsp; Otherwise display plain.
&nbsp;&nbsp;&nbsp; if(gotFocus)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setFont(new Font(getFont().getName(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Font.BOLD | Font.ITALIC,getFont().getSize()));
&nbsp;&nbsp;&nbsp; else g.setFont(new Font(getFont().getName(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Font.PLAIN,getFont().getSize()));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(pressed){ //if the pressed flag is true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(getBackground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.fillRect(//fill rectangle with background color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw shadows three shades darker than background
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().darker().darker().darker());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Note that three offset rectangles are drawn to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // produce a shadow effect on the left and top of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rectangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,1,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,2,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now draw a faint outline on the bottom and right of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rectangle.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(getBackground().darker());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,-1,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now center the text in the LWButton object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = getFontMetrics(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(getForeground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(label,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width/2 - fm.stringWidth(label)/2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height/2 + fm.getAscent()/2);
&nbsp;&nbsp;&nbsp; }//end if(pressed)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; else{//not pressed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Make the protruding LWButton object one shade
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // brighter than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(getBackground().brighter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.fillRect(//and fill a rectangle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Set the color for the shadows three shades darker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().darker().darker().darker());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Draw two offset rectangles to create shadows on&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the right and bottom.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,-1,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2,-2,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Highlight the left and top two shades brighter&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the background, one shade brighter than the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // color of the LWButton itself which is one shade
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // brighter than the background.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBackground().brighter().brighter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,this.getSize().width,this.getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now place the text in the LWButton object shifted
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by two pixels up and to the left.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontMetrics fm = getFontMetrics(getFont());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(getForeground());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(label,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width/2 - fm.stringWidth(label)/2 - 2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height/2 + fm.getAscent()/2 - 2);
&nbsp;&nbsp;&nbsp; }//end else
&nbsp; }//end overridden paint() method
&nbsp; //-----------------------------------------------------//
}//end class LWButton01
//=======================================================//</pre></td></tr></table>
-end-<!--end--></body></html>