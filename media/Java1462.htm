<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">

<h2>
Fun with Java: Sprite Animation, Part 7</h2>
<i>Baldwin completes his sprite-animation program.&nbsp; Along the way,
he explains the methods of the Sprite class, including the following features:&nbsp;
establishing the initial position of the sprite, determining the location
of the sprite, determining the speed and direction of the sprite, updating
the sprite's position, implementing some randomness in the sprite's motion,
bouncing off the walls, drawing the sprite, and detecting collisions with
other sprites.</i>
<p><b>Published:</b>&nbsp; November 18, 2001
<br><b>By <a href="#About the author">Richard G. Baldwin</a></b>
<p>Java Programming, Lecture Notes # 1462
<ul >
<li>
<a href="#Preface">Preface</a></li>

<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Programs</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#What's next">What's Next</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<b><font color="#FF0000">Why the intro?</font></b>
<p>If you are one of those orderly people who start reading a book at the
beginning and reads through to the end, you are probably wondering why
I keep repeating this long introduction.&nbsp; The truth is that this introduction
isn't meant for you.&nbsp; Rather, it is meant for those people who start
reading in the middle.
<p>That said, this is one of the lessons in a miniseries that will concentrate
on having fun while programming in Java.
<p><b><font color="#FF0000">Fun programming</font></b>
<p>This miniseries will include a variety of Java programming topics that
fall in the category of <i>fun programming</i>.&nbsp; This particular lesson
is the seventh in of a group of lessons that will teach you how to write
animation programs in Java.&nbsp; The first lesson in the group was entitled
<a href="Java1450.htm">Fun
with Java: Sprite Animation, Part 1</a>.&nbsp; <i>(Here is your opportunity
to go back and start reading at the beginning.)</i> The previous lesson
was entitled <a href="Java1460.htm">Fun with Java: Sprite Animation, Part
6</a>.
<p>This is the final lesson in the group dedicated to sprite animation.&nbsp;
The next lesson in this group will be dedicated to a combination of sprite
and frame animation.
<p><b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different figures and listings while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at
<a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Baldwin's
Java Programming Tutorials</a><font color="#000000">.</font>
<center>
<h2>
<a NAME="Preview"></a><font color="#000000">Preview</font></h2></center>
<b><font color="#FF0000">Writing animation programs</font></b>
<p><font color="#000000">This is one of a group of lessons that will teach
you how to write animation programs in Java.&nbsp; These lessons will teach
you how to write sprite animation, frame animation, and a combination of
the two.</font>
<p><b><font color="#FF0000">Spherical sea creatures</font></b>
<p><font color="#000000">The first program, being discussed in this lesson,
will show you how to use sprite animation to cause a group of colored spherical
sea creatures to swim around in a fish tank.&nbsp; A screen shot of the
output produced by this program is shown in Figure 1.</font>
<center>
<p><img SRC="java1462a.gif" height=212 width=301>
<p><font color="#000000">Figure 1.&nbsp; Animated spherical sea creatures
in a fish tank.</font></center>

<p><b><font color="#FF0000">Changing color</font></b>
<p><font color="#000000">Many sea creatures have the ability to change
their color in very impressive ways.&nbsp; The second program that I will
discuss in subsequent lessons will simulate that process using a combination
of sprite and frame animation.</font>
<p><b><font color="#FF0000">Sea worms</font></b>
<p><font color="#000000">The third program, also to be discussed in a subsequent
lesson, will use a combination of sprite animation, frame animation, and
some other techniques to cause a group of multi-colored sea worms to slither
around in the fish tank.&nbsp; In addition to slithering, the sea worms
will also change the color of different parts of their body, much like
real sea creatures.</font>
<p><font color="#000000">A screen shot of the output from the third program
is shown in Figure 2.</font>
<center>
<p><img SRC="java1462b.gif" height=212 width=301>
<p><font color="#000000">Figure 2.&nbsp; Animated sea worms in a fish tank.</font></center>

<p>Figure 3 shows the GIF image files that you will need to run these three
programs.
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFFFF" >
<tr>
<td>
<center><pre><img SRC="java1462c.gif" height=211 width=300></pre></center>

<center><pre><img SRC="java1462d.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1462e.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1462f.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1462g.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1462h.gif" height=10 width=10>&nbsp;&nbsp;&nbsp;<img SRC="java1462i.gif" height=10 width=10></pre></center>
</td>
</tr>
</table></center>

<center>
<p>Figure 3.&nbsp; GIF image files that you will need.</center>

<p><b><font color="#FF0000">Getting the GIF files</font></b>
<p>You should be able to capture the images by right-clicking on them individually,
and then saving them into files on your local disk.&nbsp; Having done that,
you will need to rename the files to match the names that are hard-coded
into the programs.
<p>In the previous lesson, I explained the behavior of all of the methods
in the <b>SpriteManager</b> class.
<p>There is only one more class to cover before my discussion of this animation
program is complete:&nbsp; <b>Sprite</b>.
<p><b><font color="#FF0000">Preview</font></b>
<p>I will explain the methods of the <b>Sprite</b> class in this lesson.&nbsp;
This will include an explanation of the following features:
<ul>
<li>
Establishing the initial position for the sprite</li>

<li>
Determining the location of the sprite</li>

<li>
Determining the speed and direction of the sprite</li>

<li>
Updating the sprite's location</li>

<li>
Implementing some randomness in the sprite's motion</li>

<li>
Bouncing off the wall</li>

<li>
Drawing the sprite</li>

<li>
Detecting collisions with other sprites</li>
</ul>

<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Program</font></h2></center>
<b><font color="#FF0000">Several lessons required</font></b>
<p>This program is so long that several lessons will be required to discuss
it fully.&nbsp; Rather than to make you wait until I complete all of those
lessons to get your hands on the program, I have provided a copy of the
entire program in Listing 12 near the end of the lesson.&nbsp; That way,
you can copy it into a source file on your local disk, compile it, run
it, and start seeing the results.
<p><b><font color="#FF0000">The Sprite class</font></b>
<p>The <b>Sprite</b> class is the workhorse of this program <i>(perhaps
I should have used seahorse images for the sprites instead of simple balls)</i>.
<p><b><font color="#FF0000">Objects of the Sprite class</font></b>
<p>Each of the sprites swimming around in the fish tank is an object of
the class named <b>Sprite</b>.&nbsp; As is the typical objective in object-oriented
programming, a sprite knows how to take care of itself.
<p><b><font color="#FF0000">Get out of my space</font></b>
<p>For example, an object of the <b>Sprite </b>class knows how to tell
other objects about the space that it occupies in the fish tank.
<p><b><font color="#FF0000">Get out of my way</font></b>
<p>It knows how to tell other objects about its motion vector, which determines
the speed and direction of its motion.
<p><b><font color="#FF0000">I'm outta here</font></b>
<p>It knows how to use its motion vector in conjunction with a random number
generator to incrementally advance its position to the next location in
its movement through the water.&nbsp; In so doing, it knows how to protect
itself from excessive speed.
<p><b><font color="#FF0000">Oops, I hit the wall</font></b>
<p>It knows what to do if it runs into one of the walls of the fish tank.&nbsp;
Basically, it bounces off the wall much like a pool ball bounces off the
cushions on a pool table.&nbsp; When this happens, it modifies its motion
vector accordingly.
<p><b><font color="#FF0000">This is what I look like</font></b>
<p>When requested to do so, it knows how to draw itself onto a graphics
context that it receives along with the request.
<p><b><font color="#FF0000">Pardon me!</font></b>
<p>Finally, when requested to do so, it can determine if it has collided
with another sprite whose reference it receives along with the request.
<p><b><font color="#FF0000">A key class</font></b>
<p>This is a very key class insofar as this program is concerned.&nbsp;
The behavior of the methods in this class determines the overall behavior
of the animation process.
<p><b><font color="#FF0000">Two more animation programs</font></b>
<p>As indicated in the preface section above, I plan to discuss at least
two more animation programs in this series on animation programs.
<p><b><font color="#FF0000">Sprites with different behavior</font></b>
<p>The behavior of the sprites will be significantly different in each
of the three programs.&nbsp; For example, the second program combines sprite
and frame animation to produce animated sea creatures that change their
color as they swim through the water.
<p>The third program combines sprite animation, frame animation, and some
other techniques to convert the spherical sea creatures into sea worms
that slither through the water and change their colors in the process.
<p><b><font color="#FF0000">Heavy code reuse</font></b>
<p>When developing the two additional programs, I will make very heavy
use of the code that I have developed for this program.&nbsp; Most of the
changes that I will make will be made to the <b>Sprite</b> class.&nbsp;
Very few changes will be required outside the <b>Sprite</b> class in the
development of the other two programs.
<p><b><font color="#FF0000">Discuss in fragments</font></b>
<p>As usual, I will discuss the program in fragments.
<p>The definition for the <b>Sprite</b> class begins in Listing 1.&nbsp;
Listing 1 shows the declaration of several instance variables and the signature
for the constructor.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>class <b>Sprite</b> {
&nbsp; private Component component;
&nbsp; private Image image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;

&nbsp; public <b>Sprite</b>(Component component,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Descriptive variable names</font></b>
<p>The names of the instance variables are generally descriptive of their
use, so you can probably surmise in general what they are used for.&nbsp;
We will learn in detail what each is used for as we examine the code.
<p><b><font color="#FF0000">Constructor parameters</font></b>
<p>The constructor for the <b>Sprite</b> class takes four parameters.
<p><b><font color="#FF0000">First parameter is a Component</font></b>
<p>The first parameter is a reference to a <b>Component</b> object.&nbsp;
In fact, it is assumed to be a reference to the <b>Frame</b> object in
which this animation is execution.
<p>The first parameter is used to determine the size of the <b>Frame</b>.&nbsp;
It is also used as a required <b>ImageObserver</b> in some of the methods
in the class.&nbsp; <i>(I discussed image observers in an earlier lesson
in this series.)</i>
<p><b><font color="#FF0000">Second parameter is an Image</font></b>
<p>The second parameter is a reference to an object of type <b>Image</b>.&nbsp;
The <b>Image</b> is used to provide a visual manifestation for the sprite.
<i>(In a later program, this parameter will be replaced by an array of
Image objects where each element in the array represents one frame in a
frame-animation sequence.)</i>
<p><b><font color="#FF0000">Initial position</font></b>
<p>The third parameter is the initial position of the sprite.
<p><b><font color="#FF0000">A motion vector</font></b>
<p>The fourth parameter is a motion vector, which determines the initial
speed and direction of motion for a new <b>Sprite</b> object.
<p><b><font color="#FF0000">A pseudorandom number generator</font></b>
<p>The code in Listing 2 instantiates an object of the class <b>Random</b>
from which pseudorandom numbers can be extracted later in the program.&nbsp;
The reference to this object is stored in one of the instance variables
listed above.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p>You have seen the use of the <b>Random</b> class in other areas of this
program.&nbsp; The thing that is interesting about this <b>Random</b> object
is the manner in which it is seeded.
<p><b><font color="#FF0000">A different seed is required</font></b>
<p>Previous uses of the <b>Random</b> class used a seed based on the time
in milliseconds that the object is instantiated.&nbsp; However, that is
not a suitable approach here, because it is possible to instantiate a large
number of <b>Sprite</b> objects within a single millisecond.&nbsp; If the
time in milliseconds were used as the seed in this case, many <b>Sprite</b>
objects would contain <b>Random</b> objects that produce the same sequence
of pseudorandom numbers.&nbsp; Then, the numbers wouldn't really be random,
at least not between <b>Sprite</b> objects.
<p><b><font color="#FF0000">Seed with initial position</font></b>
<p>Therefore, in this case, the <b>Random</b> object was seeded with the
initial position of the sprite.&nbsp; <i>(Recall that code discussed in
an earlier lesson went to great lengths to make certain that the initial
position of each new sprite is different from the current position of any
existing sprite.)</i>
<p><b><font color="#FF0000">The constructor body</font></b>
<p>The code shown in Listing 3 is the beginning of the body of the constructor.&nbsp;
The purpose of this code is simply to set the initial values for some of
the instance variables in the new object.&nbsp; This code is reasonably
straightforward, and doesn't deserve much in the way of discussion.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The size of the Frame</font></b>
<p>Recall that this animation runs inside a <b>Frame</b> object.&nbsp;
The <b>size</b> property of a <b>Frame</b> object is represented by the
<i>outer</i>
dimensions of the <b>Frame</b>.&nbsp; This includes the width of the banner
at the top and the borders on three sides.
<p><b><font color="#FF0000">Save the usable graphics area</font></b>
<p>The purpose of the code in Listing 4 is to determine and save the usable
graphics area inside the banner and the borders.
<p>Although rather ugly, this code is straightforward.&nbsp; Perhaps the
only thing worth mentioning in this code is the use of the <b>getInsets</b>
method of the
<b>Container</b> class to determine the size of the banner
at the top and the borders on the three sides.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>getInsets</b>().top;
&nbsp;&nbsp;&nbsp; int bottomBorder =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p>Once the inset values are obtained, simple arithmetic is used to combine
them with the size information for the <b>Frame</b> to produce a <b>Rectangle</b>
object that describes the usable graphics area inside the borders and the
banner.&nbsp; This is the rectangle that is used later to cause the sprites
to bounce off the inside edges of the borders and the banner.
<p><b><font color="#FF0000">Typical setter and getter methods</font></b>
<p>The methods in Listing 5 are typical property setter and getter methods.&nbsp;
There is nothing about these methods that deserves any discussion.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public Rectangle <b>getSpaceOccupied</b>(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; void <b>setSpaceOccupied</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>setSpaceOccupied</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point <b>getMotionVector</b>(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>setMotionVector</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void <b>setBounds</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">The updatePosition method</font></b>
<p>That brings us to one of the most important methods in the <b>Sprite</b>
class:&nbsp; <b>updatePosition</b>.
<p>This method is invoked by the <b>SpriteManager</b> object on each <b>Sprite</b>
object each time the animation process needs to be updated.
<p><b><font color="#FF0000">The motion vector</font></b>
<p>Each <b>Sprite</b> object has an instance variable named <b>motionVector</b>
that contains an x-component and a y-component.&nbsp; The values of these
two components determine the direction and distance that a sprite will
move during each incremental change in position.
<p><b><font color="#FF0000">The motion vector can change</font></b>
<p>If the values of these two components don't change, a sprite will continue
in the same direction at the same speed forever.&nbsp; However, there are
three ways that the value of one or both of the components can change:
<ol>
<li>
By running into the inside edge of the border or banner on the <b>Frame</b></li>

<li>
By colliding with another sprite</li>

<li>
By adding a random value</li>
</ol>
<b><font color="#FF0000">Colliding with the edge</font></b>
<p>For the first case, the change in component values is handled by code
inside the <b>updatePosition</b> method that detects collision with the
edge and takes appropriate action.
<p><b><font color="#FF0000">Colliding with another sprite</font></b>
<p>For the second case, the change in component values is handled by a
method in the <b>SpriteManager</b> class that deals with collisions between
sprites.
<p><b><font color="#FF0000">A random change in speed and direction</font></b>
<p>For the third case, the change in component values is handled by code
inside the <b>updatePosition</b> method.&nbsp; This code is designed to
insert a small amount of random behavior into the motion of the sprites.
<p><b><font color="#FF0000">Finally, the updatePosition method code</font></b>
<p>Listing 6 shows the beginning of the <b>updatePosition</b> method.&nbsp;
Listing 6 also shows the declaration and initialization of a local variable
describing the current position of the sprite.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void <b>updatePosition</b>(){
&nbsp;&nbsp;&nbsp; Point <b>position</b> = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Insert random behavior</font></b>
<p>The code in Listing 7 purposely inserts some random behavior into the
motion of the sprite by occasionally making a small random change to the
component values of the motion vector.
<p><b><font color="#FF0000">One change in ten</font></b>
<p>The code is structured to make such a random change about once in every
ten incremental moves of the sprite.&nbsp; This is accomplished by generating
a random number modulo 10 each time the sprite is instructed to update
its position.&nbsp; On those occasions that the random number modulo 10
equals 0, a random change is made to both components of the motion vector
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.&nbsp; This&nbsp;
&nbsp;&nbsp;&nbsp; // puts a cap on the maximum speed
&nbsp;&nbsp;&nbsp; // for a sprite.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point <b>randomOffset</b> =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Random change, -3 to 3 units</font></b>
<p>On those occasions that the random number modulo 10 equals 0, the code
inside the <b>if</b> statement in Listing 7 is executed.&nbsp; This code
generates a <b>randomOffset</b> of type <b>Point</b>, whose component values
fall between -3 and +3.
<p>The values of the components in the <b>randomOffset</b> are then added
to the components of the motion vector to cause a random change in speed
and direction.
<p><b><font color="#FF0000">Limit the speed to seven units per update</font></b>
<p>However, there is a problem with this.&nbsp; Up to this point in the
code, it is possible that a series of cumulative adjustments can be made
in the same direction, resulting in large incremental steps during each
position update.&nbsp; This manifests itself as a sea creature that swims
very fast.
<p>In order to prevent this, after the adjustment to the motion vector
is made, tests are performed to determine if the absolute value of either
component exceeds a value of 7.&nbsp; If so, an additional adjustment is
made by either adding or subtracting the value 7.&nbsp; This has the effect
of limiting the speed of any sprite to no more than 7 units per update
on either axis.
<p><b><font color="#FF0000">Experimental values</font></b>
<p>You might wonder how I arrived at the values of 3 and 7 in the above
code.&nbsp; I arrived at those values simply by experimenting with different
values and choosing values that produced a pleasing animation.&nbsp; You,
of course, can change the values to either speed the sprites up, or slow
them down.
<p><b><font color="#FF0000">Move the sprite</font></b>
<p>Just in case you may have lost your place, we are still inside the <b>updatePositon</b>
method.
<p>The single statement in Listing 8 uses the <b>translate</b> method of
the <b>Point</b> class to effect the actual movement of the sprite.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; position.<b>translate</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p>This code adds the components of the motion vector to the corresponding
component of the sprite's current position.
<p><b><font color="#FF0000">Bounce off the walls</font></b>
<p>When a sprite moves, it may collide with the inside edge of the banner
or one of the borders.
<p>The really long and ugly code in listing 9 causes the sprite to bounce
whenever it collides with the inside edge of the banner or one of the borders
<i>(identified
by the bounds computed earlier).</i>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector = new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if ((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x + spaceOccupied.width)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(bounceRequired)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector);
&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()

<b><font face="Courier New,Courier">Listing 9</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Reverse direction along one axis</font></b>
<p>This code is long and ugly, but basically straightforward.&nbsp; Tests
are performed to determine if the new sprite position collides with the
edges defined by <b>bounds</b>.&nbsp; If so, depending on which edge is
involved in the collision, the appropriate motion vector component is modified
to send the sprite off in the opposite direction.
<p>For example, if the sprite is moving toward the top of the screen <i>(negative
Y direction)</i> and collides with the inside edge of the banner, the sign
on the y-component of the motion vector will be changed to positive so
that the sprite will move down the screen on the next call to <b>positionUpdate</b>.
<p><b><font color="#FF0000">The drawSpriteImage method</font></b>
<p>The <b>drawSpriteImage</b> method shown in Listing 10 gives a <b>Sprite</b>
object the ability to draw itself on a graphics context received as an
incoming parameter.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public void <b>drawSpriteImage</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.<b>drawImage</b>(image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>

<p>This method uses the <b>drawImage</b> method of the <b>Graphics</b>
class to accomplish the drawing <i>(I have discussed this method in previous
lessons).</i>
<p>The first parameter to the <b>drawImage</b> method specifies the <b>Image</b>
object that will be drawn.&nbsp; The second and third parameters specify
the location within the graphics context where it will be drawn.&nbsp;
Finally, the fourth parameter is a reference to the <b>Frame</b> on which
the image is being drawn, which serves an <b>ImageObserver</b>.
<p>In this program, the <b>drawSpriteImage</b> method is invoked on each
<b>Sprite</b>
object from within the <b>drawScene</b> method of the <b>SpriteManager</b>
object.
<p><b><font color="#FF0000">The testCollision method</font></b>
<p>The <b>testCollision</b> method shown in Listing 11 determines if the
space occupied by this <b>Sprite</b> object intersects the space occupied
by another sprite received as an incoming parameter.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>&nbsp; public boolean <b>testCollision</b>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; //Check for collision with&nbsp;
&nbsp;&nbsp;&nbsp; // another sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>

<p><b><font color="#FF0000">Return true for collision</font></b>
<p>If there is an intersection between the spaces occupied by the two sprites,
this method returns true.&nbsp; Otherwise, it returns false.
<p>In this program, the <b>testCollision</b> method on the <b>Sprite</b>
object is called by the <b>testForCollision</b> method of the <b>SpriteManager</b>
object when it is in the process of determining if the latest move by all
of the sprites resulted in any collisions.
<center>
<h2>
<a NAME="Summary"></a>Summary</h2></center>
In this lesson, I have explained all of the methods in the <b>Sprite</b>
class.
<p>In this and the previous six lessons, I have explained the following
aspects of this animation program.
<p><b><font color="#FF0000">The director and the stage</font></b>
<p>The controlling class extends the <b>Frame</b> class and implements
the <b>Runnable </b>interface.&nbsp; Thus, an object of the controlling
class is used to provide the visual manifestation of the program as a visual
<b>Frame</b>
object.
<p>An object of the controlling class is also suitable for using as an
animation thread, which controls the overall behavior of the animation
process.&nbsp; In other words, an object of the controlling class acts
both as the director of the play, and the stage upon which the play is
performed.
<p><b><font color="#FF0000">Instantiate Image objects</font></b>
<p>The <b>main</b> method of the controlling class instantiates an object
of the controlling class, thus causing the constructor for the controlling
class to be executed.
<p>The constructor for the controlling class causes seven <b>Image</b>
objects to be created.&nbsp; Each <b>Image</b> object is based on the pixel
contents of a GIF file.
<p><b><font color="#FF0000">The background scenery</font></b>
<p>One of the <b>Image</b> objects is used to produce the background scenery
against which the animation is played out.
<p><b><font color="#FF0000">Six colored spheres</font></b>
<p>The other six <b>Image</b> objects are used to provide the visual manifestation
of the sprites.&nbsp; Each <b>Image</b> object provides the visual manifestation
for more than one sprite.&nbsp; Therefore, some of the sprites look alike<i>
(twins in some cases and triplets in others).</i>
<p><b><font color="#FF0000">Set the Frame size</font></b>
<p>After the <b>Image</b> objects have been created, the size of the <b>Image</b>
object used for the background scenery is used by the constructor to set
the size of the <b>Frame</b>.&nbsp; Then the <b>Frame</b> is made visible.
<p><b><font color="#FF0000">Run the animation thread</font></b>
<p>Finally, the constructor creates the animation thread and starts it
running.&nbsp; From this point forward, the <b>run</b> method of the controlling
class controls the animation behavior of the program.
<p><b><font color="#FF0000">Needed, one sprite manager</font></b>
<p>The <b>run</b> method begins by creating and populating a <b>SpriteManager</b>
object.&nbsp; An object of the <b>SpriteManager </b>class is capable of
managing a collection of sprites, causing them to update their positions
on demand, and dealing with collisions between the sprites.
<p><b><font color="#FF0000">Fifteen Sprite objects</font></b>
<p>The <b>SpriteManager</b> object is populated with fifteen separate <b>Sprite</b>
objects.&nbsp; Each sprite has a visual manifestation based on one of the
six <b>Image</b> objects.&nbsp; Each sprite object also has:
<ul>
<li>
An <i>initial position</i> based on a random number</li>

<li>
A <i>motion vector<b> </b></i>whose components are also based on random
numbers</li>
</ul>
The purpose of the initial position should be intuitive.&nbsp; The motion
vector is used to determine the next position of the sprite when the sprite
is told by the <b>SpriteManager</b> to change its position.
<p><b><font color="#FF0000">Twelve updates per second</font></b>
<p>Then the <b>run</b> method enters an infinite loop, iterating approximately
twelve times per second.&nbsp; At the beginning of each iteration, the
<b>SpriteManager</b>
is told to update the positions of all of the sprites in its collection.&nbsp;
It does so, dealing with collisions in the process.
<p>The <b>run</b> method sends a message to the operating system asking
it to repaint the <b>Frame</b> object on the screen.
<p><b><font color="#FF0000">An overridden update method</font></b>
<p>When the operating system honors the request to <b>repaint</b>, it invokes
the <b>upDate</b> method on the <b>Frame</b> object, <i>(which normally
does some initialization and then invokes the paint method).</i>
<p>The <b>update</b> method is overridden in this program to cause the
new scene to be drawn in its entirety, showing each of the sprites in its
new position superimposed upon the background image.
<p><b><font color="#FF0000">The paint method is not invoked</font></b>
<p>Note that in this case, the <b>update</b> method does not invoke the
<b>paint</b>
method, because there is nothing for the <b>paint</b> method to do.
<p><b><font color="#FF0000">An offscreen drawing context</font></b>
<p>When drawing the scene, the <b>update</b> method first draws the scene
on an offscreen graphics context, and then causes the scene to be transferred
from that context to the screen context.&nbsp; This is done to improve
the animation quality of the program.
<p><b><font color="#FF0000">The end result</font></b>
<p>The end result is a set of fifteen spherical sea creatures <i>(sprites)</i>
swimming around in a fish tank against a background captured from a photograph
that I took while on a recent trip to the aquarium in Monterey, CA.
<p><b><font color="#FF0000">What about some jellyfish?</font></b>
<p>However, any GIF file of appropriate size could be used for the background.&nbsp;
Also, any GIF files of appropriate size could be used for the sprites.
<p><i>(I just remembered that I also have some photos of jellyfish that
would make good sprites in this context, but I'm not going to go back and
rewrite all of this just to substitute the jellyfish for the spherical
sea creatures.)</i>
<center>
<h2>
<a NAME="What's next"></a>What's Next?</h2></center>
In the next lesson in this series, I will expand the program to incorporate
both sprite animation and frame animation.
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is provided in <font color="#000000">Listing
12</font>.
<br>&nbsp;
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate01.java
Copyright 2001, R.G.Baldwin

This program displays several animated
colored spherical creatures swimming&nbsp;
around in an aquarium.&nbsp; Each creature&nbsp;
maintains generally the same course
with until it collides with another&nbsp;
creature or with a wall.&nbsp; However,&nbsp;
each creature has the ability to&nbsp;
occasionally make random changes in&nbsp;
its course.

**************************************/
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class Animate01 extends Frame&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements Runnable {
&nbsp; private Image offScreenImage;
&nbsp; private Image backGroundImage;
&nbsp; private Image[] gifImages =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Image[6];
&nbsp; //offscreen graphics context
&nbsp; private Graphics&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx;
&nbsp; private Thread animationThread;
&nbsp; private MediaTracker mediaTracker;
&nbsp; private SpriteManager spriteManager;
&nbsp; //Animation display rate, 12fps
&nbsp; private int animationDelay = 83;
&nbsp; private Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(System.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentTimeMillis());
&nbsp;&nbsp;
&nbsp; public static void main(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] args){
&nbsp;&nbsp;&nbsp; new Animate01();
&nbsp; }//end main
&nbsp; //---------------------------------//

&nbsp; Animate01() {//constructor
&nbsp;&nbsp;&nbsp; // Load and track the images
&nbsp;&nbsp;&nbsp; mediaTracker =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MediaTracker(this);
&nbsp;&nbsp;&nbsp; //Get and track the background&nbsp;
&nbsp;&nbsp;&nbsp; // image
&nbsp;&nbsp;&nbsp; backGroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("background02.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage, 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Get and track 6 images to use&nbsp;
&nbsp;&nbsp;&nbsp; // for sprites
&nbsp;&nbsp;&nbsp; gifImages[0] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("redball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0], 0);
&nbsp;&nbsp;&nbsp; gifImages[1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("greenball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[1], 0);
&nbsp;&nbsp;&nbsp; gifImages[2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("blueball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[2], 0);
&nbsp;&nbsp;&nbsp; gifImages[3] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("yellowball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[3], 0);
&nbsp;&nbsp;&nbsp; gifImages[4] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("purpleball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[4], 0);
&nbsp;&nbsp;&nbsp; gifImages[5] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toolkit.getDefaultToolkit().
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImage("orangeball.gif");
&nbsp;&nbsp;&nbsp; mediaTracker.addImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[5], 0);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Block and wait for all images to&nbsp;
&nbsp;&nbsp;&nbsp; // be loaded
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mediaTracker.waitForID(0);
&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Base the Frame size on the size&nbsp;
&nbsp;&nbsp;&nbsp; // of the background image.
&nbsp;&nbsp;&nbsp; //These getter methods return -1 if
&nbsp;&nbsp;&nbsp; // the size is not yet known.
&nbsp;&nbsp;&nbsp; //Insets will be used later to&nbsp;
&nbsp;&nbsp;&nbsp; // limit the graphics area to the&nbsp;
&nbsp;&nbsp;&nbsp; // client area of the Frame.
&nbsp;&nbsp;&nbsp; int width =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getWidth(this);
&nbsp;&nbsp;&nbsp; int height =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backGroundImage.getHeight(this);

&nbsp;&nbsp;&nbsp; //While not likely, it may be&nbsp;
&nbsp;&nbsp;&nbsp; // possible that the size isn't
&nbsp;&nbsp;&nbsp; // known yet.&nbsp; Do the following&nbsp;
&nbsp;&nbsp;&nbsp; // just in case.
&nbsp;&nbsp;&nbsp; //Wait until size is known
&nbsp;&nbsp;&nbsp; while(width == -1 || height == -1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Waiting for image");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWidth(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = backGroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this);
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Display the frame
&nbsp;&nbsp;&nbsp; setSize(width,height);
&nbsp;&nbsp;&nbsp; setVisible(true);
&nbsp;&nbsp;&nbsp; setTitle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Copyright 2001, R.G.Baldwin");

&nbsp;&nbsp;&nbsp; //Create and start animation thread
&nbsp;&nbsp;&nbsp; animationThread = new Thread(this);
&nbsp;&nbsp;&nbsp; animationThread.start();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Anonymous inner class window&nbsp;
&nbsp;&nbsp;&nbsp; // listener to terminate the&nbsp;
&nbsp;&nbsp;&nbsp; // program.
&nbsp;&nbsp;&nbsp; this.addWindowListener(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new WindowAdapter(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void windowClosing(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowEvent e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);}});
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public void run() {
&nbsp;&nbsp;&nbsp; //Create and add sprites to the&nbsp;
&nbsp;&nbsp;&nbsp; // sprite manager
&nbsp;&nbsp;&nbsp; spriteManager = new SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this, backGroundImage));
&nbsp;&nbsp;&nbsp; //Create 15 sprites from 6 gif&nbsp;
&nbsp;&nbsp;&nbsp; // files.
&nbsp;&nbsp;&nbsp; for (int cnt = 0; cnt &lt; 15; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position = spriteManager.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getEmptyPosition(new Dimension(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].getWidth(this),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[0].
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight(this)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.addSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeSprite(position, cnt % 6));
&nbsp;&nbsp;&nbsp; }//end for loop

&nbsp;&nbsp;&nbsp; //Loop, sleep, and update sprite&nbsp;
&nbsp;&nbsp;&nbsp; // positions once each 83&nbsp;
&nbsp;&nbsp;&nbsp; // milliseconds
&nbsp;&nbsp;&nbsp; long time =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis();
&nbsp;&nbsp;&nbsp; while (true) {//infinite loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteManager.update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time += animationDelay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0,time -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end catch
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp; }//end run method
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private Sprite makeSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position, int imageIndex) {
&nbsp;&nbsp;&nbsp; return new Sprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gifImages[imageIndex],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 5));
&nbsp; }//end makeSprite()
&nbsp; //---------------------------------//

&nbsp; //Overridden graphics update method&nbsp;
&nbsp; // on the Frame
&nbsp; public void update(Graphics g) {
&nbsp;&nbsp;&nbsp; //Create the offscreen graphics&nbsp;
&nbsp;&nbsp;&nbsp; // context
&nbsp;&nbsp;&nbsp; if (offScreenGraphicsCtx == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createImage(getSize().width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage.getGraphics();
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // Draw the sprites offscreen
&nbsp;&nbsp;&nbsp; spriteManager.drawScene(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenGraphicsCtx);

&nbsp;&nbsp;&nbsp; // Draw the scene onto the screen
&nbsp;&nbsp;&nbsp; if(offScreenImage != null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offScreenImage, 0, 0, this);
&nbsp;&nbsp;&nbsp; }//end if
&nbsp; }//end overridden update method
&nbsp; //---------------------------------//

&nbsp; //Overridden paint method on the&nbsp;
&nbsp; // Frame
&nbsp; public void paint(Graphics g) {
&nbsp;&nbsp;&nbsp; //Nothing required here.&nbsp; All&nbsp;
&nbsp;&nbsp;&nbsp; // drawing is done in the update&nbsp;
&nbsp;&nbsp;&nbsp; // method above.
&nbsp; }//end overridden paint method
&nbsp;&nbsp;&nbsp;&nbsp;
}//end class Animate01
//===================================//

class BackgroundImage{
&nbsp; private Image image;
&nbsp; private Component component;
&nbsp; private Dimension size;

&nbsp; public BackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Component component,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image) {
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; size = component.getSize();
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end construtor
&nbsp;&nbsp;
&nbsp; public Dimension getSize(){
&nbsp;&nbsp;&nbsp; return size;
&nbsp; }//end getSize()

&nbsp; public Image getImage(){
&nbsp;&nbsp;&nbsp; return image;
&nbsp; }//end getImage()

&nbsp; public void setImage(Image image){
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp; }//end setImage()

&nbsp; public void drawBackgroundImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g) {
&nbsp;&nbsp;&nbsp; g.drawImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image, 0, 0, component);
&nbsp; }//end drawBackgroundImage()
}//end class BackgroundImage
//===========================

class SpriteManager extends Vector {
&nbsp; private BackgroundImage&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;

&nbsp; public SpriteManager(
&nbsp;&nbsp;&nbsp;&nbsp; BackgroundImage backgroundImage) {
&nbsp;&nbsp;&nbsp; this.backgroundImage =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage;
&nbsp; }//end constructor
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getEmptyPosition(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension spriteSize){
&nbsp;&nbsp;&nbsp; Rectangle trialSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Rectangle(0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spriteSize.height);
&nbsp;&nbsp;&nbsp; Random rand =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Random(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.currentTimeMillis());
&nbsp;&nbsp;&nbsp; boolean empty = false;
&nbsp;&nbsp;&nbsp; int numTries = 0;

&nbsp;&nbsp;&nbsp; // Search for an empty position
&nbsp;&nbsp;&nbsp; while (!empty &amp;&amp; numTries++ &lt; 100){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a trial position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(rand.nextInt() %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSize().height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Iterate through existing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprites, checking if position&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean collision = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle testSpaceOccupied =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getSpaceOccupied();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trialSpaceOccupied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSpaceOccupied)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collision = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty = !collision;
&nbsp;&nbsp;&nbsp; }//end while loop
&nbsp;&nbsp;&nbsp; return new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.x,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trialSpaceOccupied.y);
&nbsp; }//end getEmptyPosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void update() {
&nbsp;&nbsp;&nbsp; Sprite sprite;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Iterate through sprite list
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update a sprite's position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite.updatePosition();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Test for collision. Positive&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // result indicates a collision
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hitIndex =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testForCollision(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitIndex >= 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //a collision has occurred
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceOffSprite(cnt,hitIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end update
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private int testForCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite) {
&nbsp;&nbsp;&nbsp; //Check for collision with other&nbsp;
&nbsp;&nbsp;&nbsp; // sprites
&nbsp;&nbsp;&nbsp; Sprite&nbsp; sprite;
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite = (Sprite)elementAt(cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sprite == testSprite)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //don't check self
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Invoke testCollision method&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of Sprite class to perform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual test.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (testSprite.testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprite))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Return index of colliding&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sprite
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cnt;
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp;&nbsp;&nbsp; return -1;//No collision detected
&nbsp; }//end testForCollision()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; private void bounceOffSprite(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oneHitIndex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int otherHitIndex){
&nbsp;&nbsp;&nbsp; //Swap motion vectors for&nbsp;
&nbsp;&nbsp;&nbsp; // bounce algorithm
&nbsp;&nbsp;&nbsp; Sprite oneSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(oneHitIndex);
&nbsp;&nbsp;&nbsp; Sprite otherSprite =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Sprite)elementAt(otherHitIndex);
&nbsp;&nbsp;&nbsp; Point swap =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oneSprite.getMotionVector();
&nbsp;&nbsp;&nbsp; oneSprite.setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherSprite.getMotionVector());
&nbsp;&nbsp;&nbsp; otherSprite.setMotionVector(swap);
&nbsp; }//end bounceOffSprite()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawScene(Graphics g){
&nbsp;&nbsp;&nbsp; //Draw the background and erase&nbsp;
&nbsp;&nbsp;&nbsp; // sprites from graphics area
&nbsp;&nbsp;&nbsp; //Disable the following statement&nbsp;
&nbsp;&nbsp;&nbsp; // for an interesting effect.
&nbsp;&nbsp;&nbsp; backgroundImage.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBackgroundImage(g);

&nbsp;&nbsp;&nbsp; //Iterate through sprites, drawing
&nbsp;&nbsp;&nbsp; // each sprite
&nbsp;&nbsp;&nbsp; for (int cnt = 0;cnt &lt; size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Sprite)elementAt(cnt)).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawSpriteImage(g);
&nbsp; }//end drawScene()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void addSprite(Sprite sprite){
&nbsp;&nbsp;&nbsp; add(sprite);
&nbsp; }//end addSprite()
&nbsp;&nbsp;
}//end class SpriteManager
//===================================//

class Sprite {
&nbsp; private Component component;
&nbsp; private Image image;
&nbsp; private Rectangle spaceOccupied;
&nbsp; private Point motionVector;
&nbsp; private Rectangle bounds;
&nbsp; private Random rand;&nbsp;

&nbsp; public Sprite(Component component,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){

&nbsp;&nbsp;&nbsp; //Seed a random number generator&nbsp;
&nbsp;&nbsp;&nbsp; // for this sprite with the sprite
&nbsp;&nbsp;&nbsp; // position.
&nbsp;&nbsp;&nbsp; rand = new Random(position.x);
&nbsp;&nbsp;&nbsp; this.component = component;
&nbsp;&nbsp;&nbsp; this.image = image;
&nbsp;&nbsp;&nbsp; setSpaceOccupied(new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getWidth(component),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image.getHeight(component)));
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp;&nbsp;&nbsp; //Compute edges of usable graphics
&nbsp;&nbsp;&nbsp; // area in the Frame.
&nbsp;&nbsp;&nbsp; int topBanner = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().top;
&nbsp;&nbsp;&nbsp; int bottomBorder =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().bottom;
&nbsp;&nbsp;&nbsp; int leftBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().left;
&nbsp;&nbsp;&nbsp; int rightBorder = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Container)component).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInsets().right;
&nbsp;&nbsp;&nbsp; bounds = new Rectangle(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + leftBorder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 + topBanner,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (leftBorder + rightBorder),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.getSize().height -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (topBanner + bottomBorder));
&nbsp; }//end constructor
&nbsp; //---------------------------------//

&nbsp; public Rectangle getSpaceOccupied(){
&nbsp;&nbsp;&nbsp; return spaceOccupied;
&nbsp; }//end getSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle spaceOccupied){
&nbsp;&nbsp;&nbsp; this.spaceOccupied = spaceOccupied;
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setSpaceOccupied(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point position){
&nbsp;&nbsp;&nbsp; spaceOccupied.setLocation(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x, position.y);
&nbsp; }//setSpaceOccupied()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public Point getMotionVector(){
&nbsp;&nbsp;&nbsp; return motionVector;
&nbsp; }//end getMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point motionVector){
&nbsp;&nbsp;&nbsp; this.motionVector = motionVector;
&nbsp; }//end setMotionVector()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void setBounds(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rectangle bounds){
&nbsp;&nbsp;&nbsp; this.bounds = bounds;
&nbsp; }//end setBounds()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void updatePosition() {
&nbsp;&nbsp;&nbsp; Point position = new Point(
&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x, spaceOccupied.y);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Insert random behavior.&nbsp; During&nbsp;
&nbsp;&nbsp;&nbsp; // each update, a sprite has about
&nbsp;&nbsp;&nbsp; // one chance in 10 of making a&nbsp;
&nbsp;&nbsp;&nbsp; // random change to its&nbsp;
&nbsp;&nbsp;&nbsp; // motionVector.&nbsp; When a change&nbsp;
&nbsp;&nbsp;&nbsp; // occurs, the motionVector
&nbsp;&nbsp;&nbsp; // coordinate values are forced to
&nbsp;&nbsp;&nbsp; // fall between -7 and 7.&nbsp; This&nbsp;
&nbsp;&nbsp;&nbsp; // puts a cap on the maximum speed
&nbsp;&nbsp;&nbsp; // for a sprite.
&nbsp;&nbsp;&nbsp; if(rand.nextInt() % 10 == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point randomOffset =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Point(rand.nextInt() % 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand.nextInt() % 3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += randomOffset.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.x &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x += 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += randomOffset.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y >= 7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y -= 7;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(motionVector.y &lt;= -7)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y += 7;
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Move the sprite on the screen
&nbsp;&nbsp;&nbsp; position.translate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x, motionVector.y);

&nbsp;&nbsp;&nbsp; //Bounce off the walls
&nbsp;&nbsp;&nbsp; boolean bounceRequired = false;
&nbsp;&nbsp;&nbsp; Point tempMotionVector = new Point(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motionVector.y);
&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; //Handle walls in x-dimension
&nbsp;&nbsp;&nbsp; if (position.x &lt; bounds.x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }else if ((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x + spaceOccupied.width)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.x + bounds.width)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x = bounds.x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.width -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //reverse direction in x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.x =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.x;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Handle walls in y-dimension
&nbsp;&nbsp;&nbsp; if (position.y &lt; bounds.y){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }else if ((position.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; > (bounds.y + bounds.height)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounceRequired = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y = bounds.y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.height -&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector.y =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tempMotionVector.y;
&nbsp;&nbsp;&nbsp; }//end else if
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if(bounceRequired)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //save new motionVector
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setMotionVector(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMotionVector);
&nbsp;&nbsp;&nbsp; //update spaceOccupied
&nbsp;&nbsp;&nbsp; setSpaceOccupied(position);
&nbsp; }//end updatePosition()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public void drawSpriteImage(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Graphics g){
&nbsp;&nbsp;&nbsp; g.drawImage(image,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.x,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spaceOccupied.y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component);
&nbsp; }//end drawSpriteImage()
&nbsp; //---------------------------------//
&nbsp;&nbsp;
&nbsp; public boolean testCollision(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprite testSprite){
&nbsp;&nbsp;&nbsp; //Check for collision with&nbsp;
&nbsp;&nbsp;&nbsp; // another sprite
&nbsp;&nbsp;&nbsp; if (testSprite != this){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spaceOccupied.intersects(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testSprite.getSpaceOccupied());
&nbsp;&nbsp;&nbsp; }//end if
&nbsp;&nbsp;&nbsp; return false;
&nbsp; }//end testCollision
}//end Sprite class
//===================================//

<b><font face="Courier New,Courier">Listing 12</font></b></pre>
</td>
</tr>
</table>

<p>
<hr size=3 width="100%" align=center>
<p>Copyright 2001, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited.
<h4>
<a NAME="About the author"></a>About the author</h4>
<b><a href="mailto:baldwin.richard@iname.com">Richard Baldwin</a></b><i>
is a college professor (at Austin Community College in Austin, TX) and
private consultant whose primary focus is a combination of Java and XML.
In addition to the many platform-independent benefits of Java applications,
he believes that a combination of Java and XML will become the primary
driving force in the delivery of structured information on the Web.</i>
<p><i>Richard has participated in numerous consulting projects involving
Java, XML, or a combination of the two.&nbsp; He frequently provides onsite
Java and/or XML training at the high-tech companies located in and around
Austin, Texas.&nbsp; He is the author of Baldwin's Java Programming <a href="http://www.geocities.com/Athens/7077/scoop/onjava.html">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring Java
programmers. He has also published articles on Java Programming in Java
Pro magazine.</i>
<p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i>
<p><i><a href="mailto:baldwin.richard@iname.com">baldwin.richard@iname.com</a></i>
<p>-end-
</body>
</html>
