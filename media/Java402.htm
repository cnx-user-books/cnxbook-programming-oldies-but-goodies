<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Processing Image Pixels using Java, Creating a Spotlight</h2>
    <i>Baldwin shows you how to control the brightness of pixels in an image.&nbsp; 
As an example, he shows you how to create a spotlight that lights up the center 
of an image leaving the outer edges dark.</i><p><b>Published:</b>&nbsp; October 
19, 2004<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 402</p>
     
<ul>
  <li><a href="#Preface">Preface</a></li>
	<li><a href="#Background_Information">Background Information</a></li>
  <li><a href="#Preview">Preview</a></li>
  <li><a href="#Discussion_and_Sample_Code">Discussion and Sample Code</a><li><a href="#Run_the_Programs">Run the Program</a></li>
  <li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next</a></li>
  <li><a href="#Complete_Program_Listings">Complete Program Listing</a> </li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface">Preface</a></h2>
   </center>
<p><font color="#FF0000"><b>Second in a series</b></font></p>
<p>This lesson is the second lesson in a series that will teach you how to 
use Java to create special effects with images by directly manipulating the 
pixels in the images.</p>
<p>The first lesson in the series was entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; Because this lesson 
builds upon that earlier lesson, you will need to understand the code in the 
previous lesson before the code in this lesson will make much sense.</p>
<p><font color="#FF0000"><b>Not a lesson on JAI</b></font></p>
<p>If you arrived at this lesson while searching for instructions on how to use 
the Java Advanced Imaging <i>(JAI)</i> API, you are at the wrong place.&nbsp; 
While you are certainly welcome to be 
here, that is not the purpose of the lessons in this series.&nbsp; The purpose of 
this series is to teach you how to implement many of 
the algorithms that are commonly used to create special effects with images by 
working directly with the pixels.</p>
<p><font color="#FF0000"><b>A framework or driver program</b></font></p>
<p>The previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> provided and explained a program named <b>
ImgMod02</b> that makes it easy to:</p>
<ul>
	<li>Manipulate and modify the pixels that belong to an image</li>
	<li>Display the modified image along with the original image for easy 
	comparison in a <i>before</i> and <i>after</i> sense <i>(see Figure 1)</i></li>
</ul>
<p>The program named <b>ImgMod02</b> is designed to be used as a framework or driver that controls 
the execution of a second program.&nbsp; The second program actually processes the pixels.</p>
<p>By 
using <b>ImgMod02</b> as a driver, you can concentrate on writing and executing 
image-processing algorithms without 
having to worry about many of the details such as reading image files, 
displaying images, etc.</p>
<p>The program that I will explain in this lesson runs under the control of <b>ImgMod02</b>.&nbsp; 
You will need to go to the lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> and get copies of the program 
named <b>ImgMod02</b> and the interface named <b>ImgIntfc02</b> in order to run the program that I will provide in this 
lesson.</p>
<p><font color="#FF0000"><b>An image-processing program</b></font></p>
<p>The earlier lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> also provided and explained a very simple 
image-processing program.&nbsp; That program was designed to introduce you to the concept of 
modifying an image by directly 
modifying the pixels that belong to the image.&nbsp; I will provide and explain 
a more substantive image-processing program in this lesson.</p>
<p>The image-processing program that I will explain in this lesson 
will show you how to create a spotlight that lights up the center of an image 
while leaving the outer edges dark.</p>
<p>Future lessons will show you how to create a number of other special effects 
by directly modifying the pixels belonging to an image.&nbsp; </p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them.</p>
 
<p><font color="#FF0000"><b>Creating a spotlight in an image</b></font></p>
<p>Figure 1 shows an example of the output produced by the program that I will 
explain in this lesson.&nbsp; The special effect illustrated by Figure 1 begins with a picture of a 
starfish taken in a well-illuminated aquarium and converts it to what looks like a 
picture taken by a SCUBA diver deep underwater.</p>
<table border="1" cols="1" bgcolor="#00FFFF">
<tbody>
<tr>
<td>                     
<pre>
<img border="0" src="java402a.gif" width="334" height="714">
</pre>
<b>Figure 1&nbsp; Highlighting an area in an image.</b>

</td>
</tr>
</tbody>                                
</table></p>
<p>In Figure 1, as in all of the graphic output produced by the driver program 
named <b>ImgMod02</b>, the 
original image is shown at the top and the modified image is shown at the 
bottom.</p>
<p>The image-processing program illustrated by Figure 1 allows the user to 
interactively control the degree to which the light is concentrated in the 
center of the picture.&nbsp; Depending on user input, the illumination can range from 
being concentrated in a very small area in the center of the image to being spread throughout 
the image.</p>
<p><font color="#FF0000"><b>Theoretical basis and practical implementation</b></font></p>
<p>While discussing the lessons in this series, I will provide some of the theoretical basis for 
special-effects algorithms.&nbsp; In addition, I will show you how to implement those algorithms in Java.</p>
<h2 align="center"><a name="Background_Information">Background Information</a></h2>
<p>The previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a> provided a great deal of background 
information as to how images are constructed, stored, transported, and rendered in Java
<i>(and in most modern computer systems for that matter).</i></p>
<p>The lesson introduced and explained the concept of a pixel.&nbsp; In 
addition, the lesson provided a brief discussion of image files, and indicated 
that the program named <b>ImgMod02</b> is compatible with <i><b>gif</b></i> files,
<i><b>jpg</b></i> 
files, and possibly some other file formats as well.</p>
<p>The previous lesson also explained that the lessons in this series are not 
concerned about file formats.&nbsp; Rather, the lessons are concerned with what 
to do with the pixels once they have been extracted from the file.</p>
<p><font color="#FF0000"><b>A three-dimensional array of pixel data as type int</b></font></p>
<p>The driver program named <b>ImgMod02</b>:</p>
<ul>
	<li>Extracts the pixels from an image file</li>
	<li>Converts the pixel data to type <b>int</b></li>
	<li>Stores the pixel data in a three-dimensional array of type <b>int</b> that is 
	well suited for processing</li>
	<li>Passes the three-dimensional array object's reference to an 
	image-processing program</li>
	<li>Receives back a reference to a three-dimensional array object containing 
	modified pixel data</li>
	<li>Displays the original image and the modified image in a stacked display 
	as shown in Figure 1</li>
	<li>Makes it possible for the user to provide new input data to the 
	image-processing program, invoke the image-processing program again, and 
	create a new display showing the newly-modified image along with the 
	original image.</li>
</ul>
<p>The manner in which that is accomplished was explained in the previous 
lesson.</p>
<p><font color="#FF0000"><b>Will concentrate on the three-dimensional array of 
type int</b></font></p>
<p>This lesson and future lessons in this series will concentrate on writing 
image-processing programs that implement a variety of image-processing 
algorithms.&nbsp; As a result, these lessons will concentrate on receiving and modifying 
the contents of the three-dimensional array containing pixel data as type <b>int</b>.&nbsp; The image-processing programs will receive raw pixel data in the form of a three-dimensional array, 
and will return modified pixel data in the form of a three-dimensional array.</p>
<p><font color="#FF0000"><b>A grid of colored pixels</b></font></p>
<p>Each three-dimensional array object represents one image consisting of a 
grid of colored pixels.&nbsp; The pixels in the grid are arranged in rows 
and columns when they are rendered.&nbsp; One of the dimensions of the array represents rows.&nbsp; 
A second dimension represents columns.&nbsp; The third dimension represents the color <i>(and transparency)</i> of 
the pixels.</p>
<p><font color="#FF0000"><b>A quick review of fundamentals</b></font></p>
<p>A pixel in a modern computer image is 
represented by four <b><i>unsigned</i></b> 8-bit bytes of data.&nbsp; Three of those four bytes 
represent the colors <i>red, green, </i>and <i>blue.</i>&nbsp; The fourth byte, often referred 
to as the<i> alpha</i> byte,<i> </i>represents <i>transparency.</i></p>
<p><font color="#FF0000"><b>Mixing the primary colors red, green, and blue</b></font></p>
<p>Specific colors are created by mixing different amount of red, green, and 
blue.&nbsp; That is to say, when the program needs to cause the color orange to 
be displayed on the screen, it mixes together the correct amounts of red, green, 
and blue to produce orange.</p>
<p>The amounts of each of the three primary colors that are added are specified by the values stored in the three color 
values for the pixel.</p>
<p><font color="#FF0000"><b>The range of a color</b></font></p>
<p>Each unsigned eight-bit color byte can contain 256 different values ranging from 0 to 255 
inclusive.&nbsp; For example, if the value of the red byte is 0, no red color is added into the mix to produce the overall color for that 
pixel.&nbsp; If the value of the red byte is 255, the maximum possible amount of 
red is added into the mix.&nbsp; The 
amount of red that is added is proportional to the value of the red byte in the range 
from 0 to 255.&nbsp; The 
same is true for blue and green as well.</p>
<p><font color="#FF0000"><b>Black and white pixels</b></font></p>
<p>If all three of the color pixels have a value of 0, the overall color of that pixel 
is black.&nbsp; If all three of the color pixels have a value of 255, the 
overall color 
of that pixel is white.&nbsp; If all three of the pixels have the same value 
somewhere between 0 and 255, the overall color of that pixel is some shade of gray.</p>
<p><font color="#FF0000"><b>The bottom line on color</b></font></p>
<p>The overall color of each individual pixel is 
determined by the values stored in the three color bytes for that pixel.&nbsp; 
If you change any of those values, you will change the overall color of the pixel 
accordingly.</p>
<p><font color="#FF0000"><b>What about transparency?</b></font></p>
<p>The issue of transparency is somewhat more difficult to explain.&nbsp; I explained this 
concept using an analogy in the previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; I won't 
repeat that analogy here.&nbsp; Rather, I will simply refer you back to the 
earlier lesson.</p>
<p>The bottom line on transparency is as follows.&nbsp; 
The alpha byte also has 256 possible values ranging from 0 to 255.&nbsp; If the 
value is zero, the pixel is completely transparent regardless of the values of 
the three color bytes.</p>
<p>If the value is 255, the pixel is completely opaque with 
the color of the pixel being determined exclusively by the values stored in the 
three color bytes.</p>
<p>If the value of the alpha byte is somewhere between 0 
and 255, the pixel is partially transparent.&nbsp; The overall color of that 
pixel depends on the color that was previously established for that location 
plus the individual values of the three color bytes.</p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p><font color="#FF0000"><b>Two programs and one interface</b></font></p>
<p>The program that I will discuss in this lesson actually involves 
two programs and one interface.&nbsp; One of the programs is the program named
<b>ImgMod02</b> that I provided and explained in the previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; The interface is named <b>ImgIntfc02</b>.&nbsp; I also provided and 
explained that interface in the previous lesson.&nbsp; I will refer you 
back to that lesson for access to that material.</p>
<p>In this lesson, I will present and explain a new Java program named <b>
ImgMod11</b>.&nbsp; This program, when run under control of the program named <b>
ImgMod02</b>, will produce an output similar to the pair of images shown in 
Figure 1.</p>
<blockquote>
	<p><i>(The results will be different if you use a different image 
	file or provide a different user input value.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The program named <b>ImgMod11</b>, <i>(and all 
image-processing programs that are capable of being driven by <b>ImgMod02</b>),</i> 
must implement the interface named <b>ImgIntfc02</b>.&nbsp; That interface 
declares a single method named <b>processImg</b>, which must be defined by all 
implementing classes.</p>
<p>When the user runs the program named <b>ImgMod02</b>, that program 
instantiates an object of the image-processing program class and invokes the <b>
processImg</b> method on that object.</p>
<p>A three-dimensional array containing the pixel data 
for the image is passed to the method.&nbsp; The <b>processImg</b> method returns a 
three-dimensional array containing the pixel data for a modified version of the 
original image.</p>
<p><font color="#FF0000"><b>A <i>before</i> and <i>after</i> display</b></font></p>
<p>When the <b>processImg</b> method returns, the driver program causes the 
original image and the modified image to be displayed in a frame 
with the original image above the modified image <i>(see Figures 1 for 
an example of the display format).</i></p>
<p><font color="#FF0000"><b>Usage information for ImgMod02 and ImgMod11</b></font></p>
<p>To use the program named <b>ImgMod02</b> to drive the program named ImgMod11, enter the following at the 
command line: </p>
<b><pre>java ImgMod02 ImgMod11 ImagePathAndFileName</pre></b> </p>
<p><font color="#FF0000"><b>Image file must be provided by the user</b></font></p>
<p>The user must provide the image file. It can be a <i><b>gif</b></i> file or a 
<i><b>jpg</b></i> file.&nbsp; 
Other file types may also be compatible as well.&nbsp; The image file doesn't 
have to be in the current directory if a path to the file is specified on the 
command line.&nbsp; If the program is unable to load the image file within ten 
seconds, it will abort with an error message. </p>
<blockquote>
	<p><i>(You should be able to right-click on the image 
	in Figure 2 and download and save the image locally.&nbsp; Then you should be able to replicate the output produced in 
	Figure 1.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Image display format</b></font></p>
<p>When the program is started, the original image and the processed image are 
displayed in a frame with the original image above the processed image.</p>
<p>A
<b>Replot</b> button appears at the bottom of the frame. If the user clicks the
<b>Replot</b> button, the <b>processImg</b> method is rerun, the image is 
reprocessed, and the new version of the processed image replaces the old version 
in the display. </p>
<p><font color="#FF0000"><b>Input to the image-processing program</b></font></p>
<p>The image-processing program named <b>ImgMod11</b> provides a GUI for data input.&nbsp; 
This makes it possible for the user to modify the behavior of the 
image-processing method each time it is run.</p>
<h2 align="center"><a name="Discussion_and_Sample_Code">Discussion and Sample 
Code</a></h2>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>As mentioned earlier, the image-processing program must implement the interface named <b>
ImgIntfc02</b>.&nbsp; A listing of that interface was provided in the previous 
lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>.&nbsp; That interface declares a single method with the following 
signature:</p><b><pre>
int[][][] processImg(int[][][] threeDPix, 
                     int imgRows, 
                     int imgCols);</pre></b></p>
<p>The first parameter is a reference to an incoming three-dimensional array of pixel data stored as 
type <b>int</b>.&nbsp; The second and third parameters specify the number of rows 
and columns of pixels in the image. </p>
<p><font color="#FF0000"><b>It's best to make and modify a copy</b></font></p>
<p>The image-processing class must define the method named <b>processImg</b> 
with the signature given above.&nbsp; The <b>processImg</b> method receives a 
three-dimensional array containing pixel data for the original image.&nbsp; 
Normally the method should make a copy of the incoming 
array and modify the copy rather than modifying the original.&nbsp; Then the 
method should return a reference to the modified copy of the three-dimensional pixel array.</p>
<p><font color="#FF0000"><b>Be careful of the range of values</b></font></p>
<p>The <b>processImg</b> method is free to modify 
the values of the pixels in any manner whatsoever before returning the 
modified array.&nbsp; Note however that native pixel data consists of four 
<i>unsigned</i> bytes, whereas the <b>processImg </b>method works with pixel 
values of the <i>signed </i>type <b>int</b>.</p>
<p>If the modification of the pixel data produces negative 
values or positive value greater than 255, this should be dealt with before 
returning the modified pixel data.&nbsp; Otherwise, the returned values will 
simply be truncated to eight bits before display, and the result of displaying 
those truncated bits may not be as expected.</p>
<blockquote>
	<p><i>(It is possible, however, to create some interesting visual effects by 
	taking advantage of such truncation.&nbsp; You might want to play around 
	with this.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Dealing with out-of-range values</b></font></p>
<p>There are at least two ways to deal with out-of-range values.&nbsp; One way is to 
simply clip all negative values at zero and to clip all values greater than 255 
at 255. </p>
<p>The other way is to map the values from the most negative to the most 
positive into the range from 0 to 255.&nbsp; With this approach, all 
the pixel values would be modified the same way such that the minimum value 
contained in all the pixel color values would be 0 and the maximum value would 
be 255.</p>
<p>There are many possible variations on the latter approach.&nbsp; There is no one approach that is<i> 
the right </i>approach for all situations.</p>
<p><font color="#FF0000"><b>Instantiate an image-processing object</b></font></p>
<p>The program named <b>ImgMod02</b> reaches a point where it has captured the 
pixel data from the original image in a three-dimensional array of type <b>int</b> 
suitable for processing.&nbsp; Then it invokes the <b>newInstance</b> method of the 
class named <b>Class</b>, as shown in Listing 1, to instantiate an object of the 
image-processing class.</p>
<blockquote>
	<p><i>(At this point, the name of the image-processing class is stored as a
	<b>String</b> in the variable named <b>theProcessingClass</b>.&nbsp; The <b>
	String</b> was either received as a command-line parameter, or was specified 
	as a default value.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        try{
          imageProcessingObject = 
            (ImgIntfc02)Class.forName(
               theProcessingClass).newInstance();

<b>Listing 1</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>The use of the class named Class</b></font></p>
<p>If you are unfamiliar with this approach to the instantiation of objects, you 
can learn about it in the earlier lesson entitled
<a href="http://www.dickbaldwin.com/java/Java044.htm">More on Inheritance</a>.&nbsp; 
You will also find examples of the use of this approach in the lesson entitled
<a href="http://www.developer.com/java/article.php/10922_1382101_1">The Essence 
of OOP using Java, Array Objects, Part 3</a>, as well as in numerous other 
lessons on my <a href="http://www.dickbaldwin.com/">website</a>.</p>
<p>As explained in the previous lesson entitled 
<a href="http://www.developer.com/java/other/article.php/3403921">Processing 
Image Pixels using Java, Getting Started</a>, this approach does not support the use of parameterized 
constructors.</p>
<p><font color="#FF0000"><b>Fire an ActionEvent</b></font></p>
<p>At this point, the program named <b>ImgMod02</b>:</p>
<ul>
	<li>Has the pixel data in the correct format</li>
	<li>Has an 
image-processing object that will process those pixels and will return an array 
containing modified pixel values&nbsp; </li>
</ul>
<p>All that the <b>ImgMod02</b> program needs to do is to invoke the <b>
processImg</b> method on the image-processing object passing the pixel data and 
other appropriate information as parameters.</p>
<p>The <b>ImgMod02</b> program executes the statement in Listing 2 to invoke the
<b>processImg</b> method on the image-processing object.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          Toolkit.getDefaultToolkit().
                getSystemEventQueue().postEvent(
                  new ActionEvent(
                    replotButton,
                    ActionEvent.ACTION_PERFORMED,
                    "Replot"));

<b>Listing 2</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Post a counterfeit ActionEvent to the system event 
queue</b></font></p>
<p>Listing 2 posts a counterfeit <b>ActionEvent</b> to the system event queue 
and attributes the event to the <b>Replot</b> button.&nbsp; The result is 
exactly the same as if the user had clicked the <b>Replot</b> button shown in 
Figure 1.</p>
<p>In 
either case, the <b>actionPerformed</b> method is invoked on an <b>
ActionListener</b> object that is registered on the <b>Replot</b> button.&nbsp; 
The code in the <b>actionPerformed</b> method invokes the <b>processImg</b> 
method on the image-processing object.</p>
<blockquote>
	<p><i>(If you are unfamiliar with the use of the system event queue, you can 
	learn about it in the earlier lesson entitled <font color="#000000">
	<a href="http://www.dickbaldwin.com/java/Java104.htm">Posting Synthetic 
	Events to the System Event Queue</a>.</font>)</i></p>
</blockquote>
<p>The three-dimensional array of pixel data is passed to the <b>processImg</b> 
method.&nbsp; The <b>processImg</b> method returns a three-dimensional array of 
modified pixel data, which is displayed as an image below the original image as 
shown in Figure 1.</p>
<p><font color="#FF0000"><b>The program named ImgMod11</b></font></p>
<p>This program is designed to be driven by the program named <b>ImgMod02</b>.&nbsp; 
Enter the following on the command line to run this program:&nbsp; </p>
<p>
<pre><b>java ImgMod02 ImgMod11 ImagePathAndFileName</b></pre>
<font color="#FF0000"><b>Purpose of the program</b></font></p>
<p>This program illustrates control of the light intensity in the image.&nbsp; The effect is as though a spotlight is shining on 
the object in the center of the image.&nbsp; The center of the image is 
illuminated while 
the outer edges of the image are dark, as shown in Figure 1.&nbsp; </p>
<p><font color="#FF0000"><b>User input</b></font></p>
<p>A small GUI with a text field allows the user to control the radius of the illuminated area. At 
startup, the text field contains a default value of 0. To change the radius of the 
illuminated area, 
type a positive integer value into the text field and press the <b>Replot</b> button at the 
bottom of the image. The larger the integer value, the smaller will be the 
radius of the illuminated area. </p>
<blockquote>
	<p><i>(The bottom image in Figure 1 resulted from a user input value of 1 in 
	the text field.)</i></p>
</blockquote>
<p>For values of around 10 and above, the illuminated area 
will be reduced to approximately the size of a single pixel.&nbsp; </p>
<p><font color="#FF0000"><b>Transparent areas</b></font></p>
<p>Note that the 
pixel modification in this program has no impact on transparent pixels.&nbsp; If you 
don't see what you expect to see when you run the program, it may be because your image contains large 
transparent areas.</p>
<p>The program was tested using J2SE SDK 1.4.2 and WinXP.</p>
<p><font color="#FF0000"><b>Will discuss in fragments</b></font> </p>
<p>I will break the program down into fragments for discussion.&nbsp; A 
complete listing of the program is provided in Listing 14 near the end of the 
lesson.</p>
<p>The class definition begins in Listing 3.&nbsp; Note that this class 
implements <b>ImgIntfc02</b>.&nbsp; This is a requirement to make this class 
compatible with the driver program named <b>ImgMod02</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
class ImgMod11 extends Frame
                           implements ImgIntfc02{

  int loops;//User input to control lighting
  String inputData;//Obtained via the TextField
  TextField input;//User input field

  ImgMod11(){//constructor
    //Create a user input frame.
    setLayout(new FlowLayout());

    Label instructions = new Label(
                      "Type an int and replot.");
    add(instructions);

    input = new TextField("0",5);
    add(input);

    setTitle("Copyright 2004, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor

<b>Listing 3</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The class also extends <b>Frame</b>.&nbsp; This is because an object of the 
class serves as a GUI containing a <b>TextField</b> that allows for user 
input.</p>
<p>Listing 3 shows three instance variables and the constructor.&nbsp; The 
instance variables will be discussed later in conjunction with the discussion of 
the code that uses them.</p>
<p><font color="#FF0000"><b>The constructor</b></font></p>
<p>The constructor displays a small <b>Frame</b> on the screen 
with a single <b>TextField</b> object. The purpose of the text field is to allow 
the user to enter a value that controls the radius of the illuminated area.</p>
<p>In operation, the user types a value into the text field and then clicks the
<b>Replot</b> button on the main image display frame.</p>
<blockquote>
	<p><i>(The user is not 
required to press the <b>Enter</b> key after typing the new value, but it 
doesn't do any harm to do so.)</i></p>
</blockquote>
<p>The code in Listing 3 is straightforward and shouldn't require further 
explanation.</p>
<p><font color="#FF0000"><b>The processImg method</b></font></p>
<p>The class defines the <b>processImg</b> method that is declared in the 
interface named <b>ImgIntfc02</b>.</p>
<p>The <b>processImg</b> method receives a three-dimensional array 
containing alpha, red, green, and blue pixel values for an image.&nbsp; The 
values are received as type <b>int</b> <i>(not type byte).</i></p>
<p>The <b>processImg</b> method begins in Listing 4.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
  public int[][][] <b>processImg</b>(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    //Make a working copy of the 3D array to
    // avoid making permanent changes to the
    // image data.
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

<b>Listing 4</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>A working copy of the array</b></font></p>
<p>The <b>processImg</b> method begins by making a working copy of the incoming 
three-dimensional array in order to avoid having to make changes to the original 
array of pixel data.</p>
<p>Then the method displays the width and height of the image in pixels as 
information to the user.</p>
<p><font color="#FF0000"><b>Get user input</b></font></p>
<p>Listing 5 gets the <b>String</b> value currently in the <b>TextField</b> and 
converts that <b>String</b> to a value of type <b>int</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    loops = Integer.parseInt(input.getText());

<b>Listing 5</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The first time that the <b>processImg</b> method is called, it get the value 
0 that was put into the <b>TextField</b> through initialization when the <b>
TextField</b> object was instantiated.&nbsp; After that, the value retrieved 
will be the value typed into the <b>TextField</b> by the user.</p>
<p>Note that there is no requirement for the user to press the <b>Enter</b> key 
after typing a new value into the <b>TextField</b>.&nbsp; However, pressing the
<b>Enter</b> key won't do any harm.</p>
<p>Also note that the code in Listing 5 will throw an exception if the contents 
of the <b>TextField</b> cannot be converted to a value of type <b>int</b>.</p>
<p><font color="#FF0000"><b>Calculate the center point</b></font></p>
<p>The code in Listing 6 calculates the coordinate value of the pixel at the center 
of the image.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    int centerWidth = imgCols/2;
    int centerHeight = imgRows/2;

<b>Listing 6</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>This is the point that will be the center of the illuminated area in the 
modified image.</p>
<p><font color="#FF0000"><b>Get the distance from a corner</b></font></p>
<p>Listing 7 calculates the distance from a corner to the center pixel in the 
image.&nbsp; This will be used as a base for calculating the relative distance 
from any pixel to the center.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    double maxDistance = Math.sqrt(
                      centerWidth*centerWidth +
                      centerHeight*centerHeight);

<b>Listing 7</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The distance from the corner is calculated by calculating the length of the 
hypotenuse of a right triangle formed by the distances from the center to the 
side and to the top of the image.</p>
<p><font color="#FF0000"><b>Control pixel intensity</b></font></p>
<p>The effect that you see in Figure 1 is achieved by decreasing the intensity of every pixel 
in the image except for the pixel at the center.</p>
<p>For the initial value of 0 in the<b> TextField</b>, the intensity of each pixel decreases 
linearly with the distance of the pixel from the center.</p>
<p>When the user 
types a non-zero positive integer value into the <b>TextField</b> and presses the
<b>Replot</b> button, the intensity of each pixel decreases more rapidly with the 
distance of the pixel from the center.&nbsp; </p>
<blockquote>
	<p><i>(For example, for a value 
of 1 in the <b>TextField</b>, the intensity decreases as the square of the 
distance of the pixel from the center.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>A pair of nested for loops</b></font></p>
<p>Listing 8 shows the beginning of a pair of nested <b>for</b> loops that are 
used to modify the intensity of each pixel on the basis of the 
location of the pixel in the image.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){

        double horiz = centerWidth - col;
        double vert = centerHeight - row;

<b>Listing 8</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p><font color="#FF0000"><b>Get components of displacement vector</b></font></p>
<p>Listing 8 also contains the code to calculate the horizontal and vertical 
components of a displacement vector that extends from a pixel to the center 
of the image.</p>
<p><font color="#FF0000"><b>Get length of displacement vector</b></font></p>
<p>Listing 9 calculates the absolute value of the length of the displacement 
vector as the length of the hypotenuse of a right triangle formed by the 
horizontal and vertical components of the displacement vector.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        double distance = Math.sqrt(horiz*horiz
                                    + vert*vert);

<b>Listing 9</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>The absolute value of the displacement vector is the scalar distance from the 
pixel to the center of the image.</p>
<p><font color="#FF0000"><b>Calculate the scale factor</b></font></p>
<p>Listing 10 shows the beginning of an <b>if</b> statement that is executed 
only if the distance to the pixel from the center is greater than zero.</p>
<blockquote>
	<p><i>(The body of the <b>if</b> statement will be executed for all 
	pixels other than the single pixel at the center of the image.&nbsp; 
	Therefore, the intensity of the center pixel should never change, no matter 
	what positive value is entered into the <b>TextField</b>, provided that 
	value can be converted to a positive <b>int</b> value.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        if((int)distance > 0){
          double scale =
                      1.0 - distance/maxDistance;

<b>Listing 10</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 10 calculates a scale factor that is used later to scale each of the 
three color values belonging to an individual pixel.</p>
<p>For small distances, 
the scale factor is very close to unity.&nbsp; For a distance equal to the 
distance from a corner to the center, the scale factor is zero.&nbsp; Thus, the 
intensity of the pixels near the center will be nearly as great as the intensity 
of the same pixels in the original image.&nbsp; The intensity of pixels in the 
corners will be reduced to zero.</p>
<p><font color="#FF0000"><b>Modify the scale factor based on user input</b></font></p>
<p>The <b>for</b> loop in Listing 11 modifies the scale factor based on the 
contents of the <b>TextField</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          for(int cnt = 0;cnt < loops;cnt++){
            scale = scale*scale;
          }//end for loop

<b>Listing 11</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>For the initial default value of 0 in the <b>TextField</b>, the 
body of the <b>for</b> loop is not executed.&nbsp; Thus, the value of the 
scale factor isn't modified for this case.&nbsp; The scale factor decreases 
linearly with the distance of the pixel from the center.</p>
<p>For a value of 1 in the <b>TextField</b>, the value of the scale factor 
decreases as the square of the distance of the pixel from the center.&nbsp; For 
a value of 2, the scale factor decreases as the cube of the distance, etc.</p>
<p><font color="#FF0000"><b>Apply the scale factor to each pixel</b></font></p>
<p>Still inside the pair of nested <b>for</b> loops that began in Listing 8, the 
code in Listing 12 multiplies the red, green, and blue values of the pixel by 
the scale factor.</p>
<blockquote>
	<p><i>(No change is made to the alpha or transparency value.)</i></p>
</blockquote>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
          temp3D[row][col][1] =
              (int)(scale * temp3D[row][col][1]);
          temp3D[row][col][2] =
              (int)(scale * temp3D[row][col][2]);
          temp3D[row][col][3] =
              (int)(scale * temp3D[row][col][3]);

<b>Listing 12</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>As discussed earlier, the color values of the pixels at the corners are 
reduced to zero.&nbsp; When all three pixels have a value of zero, the overall 
color of the pixel 
will be black.&nbsp; Similarly, each of the color values for a pixel between 
the corners and the center are reduced by the same scale factor.&nbsp; This 
causes the portion of the image attributable to those pixels to appear to be more poorly illuminated.</p>
<p><font color="#FF0000"><b>Return modified pixel data</b></font></p>
<p>Listing 13 signals the end of the <b>if</b> statement that began in Listing 
10.&nbsp; Listing 13 also signals the end of the nested <b>for</b> loops that 
began in Listing 8.</p>
<p>Listing 13 returns a reference to the three-dimensional array object that 
contains the modified pixel data.&nbsp; This is the data that will be displayed 
by the program named <b>ImgMod02</b>.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
        }//end if
      }//end for loop on col
    }//end for loop on row

    <b>return temp3D;</b>
  }//end processImg

}//end class ImgMod11

<b>Listing 13</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
<p>Listing 13 also signals the end of the <b>ImgMod11</b> class and the end of 
the program.</p>
<p><font color="#FF0000"><b>That's all there is to it</b></font></p>
<p>Once you have the program named <b>ImgMod02</b> to handle all 
of the hard work, all that's required to create and test a new image-processing 
algorithm is to define a new class that:</p>
<ul>
	<li>Makes a copy of an incoming three-dimensional array of pixel data 
	representing an image.</li>
	<li>Modifies the pixel values in the copy according to some algorithm of your 
	own design.</li>
	<li>Returns a reference to the modified three-dimensional array of pixel 
	data for display.</li>
</ul>
<p><font color="#FF0000"><b>Some cautions</b></font></p>
<p>A couple of cautions are in order.&nbsp; One caution is to beware of 
transparency.&nbsp; You should make certain 
that you don't end up with a modified array in which all the alpha values are 
zero.</p>
<blockquote>
	<p><i>(Recall that the elements in a new array of type <b>int</b> are 
	automatically initialized to zero, so this is an easy mistake to make.)</i></p>
</blockquote>
<p>If you do, then your modified image will be completely transparent 
regardless of what you do to the color values for the pixels.&nbsp; As a 
result, the display will simply show the yellow background color for the frame.</p>
<p><font color="#FF0000"><b>Value ranges</b></font></p>
<p>Another caution has to do with the range of alpha and color values associated 
with the pixels.&nbsp; None of the values should be negative, and none of the 
values should exceed +255.&nbsp; If your values don't comply with these limits, the 
display will probably not be what you expect to see.</p>
<p>Prior to display, each of the 
four pixel values of type <b>int</b> will be converted to eight bits by simply discarding all but 
the least significant eight bits in each <b>int</b> element in the 
three-dimensional array.&nbsp; This is not the same as clipping the 
values at 0 and 255, and will probably lead to unexpected results.</p>
<h2 align="center"><a name="Run_the_Programs">Run the Program</a></h2>
<p>I encourage you to copy, compile, and run the program provided in this lesson.&nbsp; 
Experiment with it, making changes and observing the results of your changes.</p>
<p><font color="#FF0000"><b>Variable transparency</b></font>&nbsp; </p>
<p>If you were to modify the alpha value along with the color values, the pixels 
would become more transparent as they become darker.&nbsp; This produces an 
interesting effect.</p>
<p><font color="#FF0000"><b>Investigation by individual color</b></font></p>
<p>The code in Listing 14 contains some statements <i>(disabled by comments)</i> 
that you can use to turn colors off and on.&nbsp; This allows you to 
see the effect of the algorithm on any combination of the three colors.&nbsp; 
Thus, you can see the impact of applying the algorithm to each individual color 
among red, green, and blue.</p>
<p><font color="#FF0000"><b>Moving the center of the illuminated area</b></font></p>
<p>Another interesting programming exercise would be to allow the user to enter 
two values in the GUI with one value controlling the radius of the illuminated 
area, and the other value controlling the center of the illuminated area.</p>
<p>An even more interesting exercise would be to make it possible for the user 
to control the center of the illuminated area by moving the mouse around in the 
top image in Figure 1.&nbsp; There are at least two ways to do this.</p>
<p>The easier of the two ways would be to cause the center of the illuminated 
area to move to a new location each time the user clicks on that location in the 
top image.</p>
<p>A more difficult approach would be to cause the center to the illuminated 
area to track the location of the mouse pointer in the top image without a 
requirement for the user to press a mouse button.</p>
<blockquote>
	<p><i>(This would probably require more raw compute power than my old computer 
can muster, particularly for a large image.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Have fun and learn</b></font></p>
<p>Above all, have fun and learn as much as you can about modifying image pixels 
using Java.</p>
<p><font color="#FF0000"><b>A test image</b></font></p>
<p>You should be able to right-click on the image in Figure 2 and download and 
save it locally.&nbsp; Then you should be able to 
replicate the output produced in Figure 1.</p>
<p align="center"><img border="0" src="java402b.gif" width="324" height="330"></p>
<p align="center">Figure 2&nbsp; Raw image for Figure 1</p>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>I showed you how to control the brightness of pixels in an image.&nbsp; As an 
example, I showed you how to create a spotlight that lights up the center of an 
image while leaving the outer edges dark.</p>
<p>I will have more to say about controlling brightness in the next lesson in 
this series where I explain how to control both brightness and contrast. </p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>Future lessons will show you how to write image-processing programs that 
implement many common special effects as well as a few that aren't so common.&nbsp; 
This will include programs to do the following:</p>
<ul>
	<li>Control contrast and brightness by modifying the distribution of the 
	color values.</li>
	<li>Blur all or part of an image.</li>
	<li>Deal with the effects of noise in an image.</li>
	<li>Sharpen all or part of an image.</li>
	<li>Perform edge detection on an image.</li>
	<li>Apply color filtering to an image.</li>
	<li>Apply color inversion to an image.</li>
	<li>Morph one image into another image.</li>
	<li>Rotate an image.</li>
	<li>Change the size of an image.</li>
	<li>Other special effects that I may dream up or discover while doing the 
	background research for the lessons in this series.</li>
</ul>
<h2 align="center"><a name="Complete_Program_Listings">Complete Program Listing</a></h2><p>
A complete listing of the program discussed in this lesson is provided in 
Listing 14.</p>
<p><font color="#FF0000"><b>A disclaimer</b></font></p>
<p>The programs that I will provide and explain in this series of lessons are 
not intended to be used for high-volume production work.&nbsp; Numerous 
integrated image-processing programs are available for that purpose.&nbsp; In 
addition, the Java Advanced Imaging API <i>(JAI)</i> has a number of special effects built in if you prefer to write 
your own production image-processing programs using Java.</p>
<p>The programs that I will provide in this series are intended to 
make it easier for you to develop and experiment with image-processing algorithms and 
to gain a better understanding of how they work, and why they do what they do.</p>
<table border="1" cols="1" width="400" bgcolor="#FFFF00">
<tbody>
<tr>
<td>                     
<pre>
/*File ImgMod11.java.java
Copyright 2004, R.G.Baldwin

This program is designed to be driven by the
program named ImgMod02.java.

Enter the following on the command line to run
this program:

java ImgMod02 ImgMod11 FileName

This program illustrates an image special effect
involving the control of light intensity in the
image.  The effect is as though a spotlight is
shining on the object in the center of the image.
The center of the image is well lit while the
outer edges of the image are dark.

A small GUI with a text field is provided to
allow the user to control the radius of the
lighted area.  At startup, the text field
contains a 0.  To change the radius of the
lighted area, type an integer value into the
text field and press the Replot button at the
bottom of the image.  The larger the integer
value, the smaller will be the radius of the
lighted area.  For values of around 10 and
above, the lighted area will be reduced to
approximately the size of a single pixel.

Note that the pixel modification in this program
has no impact on transparent pixels.  If you
don't see what you expect, it may be because your
image contains large transparent areas.

Tested using SDK 1.4.2 and WinXP
************************************************/
import java.awt.*;

class ImgMod11 extends Frame
                           implements ImgIntfc02{

  int loops;//User input to control lighting
  String inputData;//Obtained via the TextField
  TextField input;//User input field

  ImgMod11(){//constructor
    //Create a user input frame.
    setLayout(new FlowLayout());

    Label instructions = new Label(
                      "Type an int and replot.");
    add(instructions);

    input = new TextField("0",5);
    add(input);

    setTitle("Copyright 2004, Baldwin");
    setBounds(400,0,200,100);
    setVisible(true);
  }//end constructor
  //-------------------------------------------//

  //This method must be defined to implement
  // the interface named ImgIntfc02.
  public int[][][] processImg(
                             int[][][] threeDPix,
                             int imgRows,
                             int imgCols){

    //Make a working copy of the 3D array to
    // avoid making permanent changes to the
    // image data.
    int[][][] temp3D =
                    new int[imgRows][imgCols][4];
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        temp3D[row][col][0] =
                          threeDPix[row][col][0];
        temp3D[row][col][1] =
                          threeDPix[row][col][1];
        temp3D[row][col][2] =
                          threeDPix[row][col][2];
        temp3D[row][col][3] =
                          threeDPix[row][col][3];
      }//end inner loop
    }//end outer loop

    System.out.println("Width = " + imgCols);
    System.out.println("Height = " + imgRows);

    //Get the user input from the text field.
    // First time through, the input value is the
    // value set into the text field when it was
    // instantiated.  After that, the input value
    // is the value typed by the user.
    loops = Integer.parseInt(input.getText());

    //Calculate the center point of the image
    int centerWidth = imgCols/2;
    int centerHeight = imgRows/2;

    //Calculate the distance from a corner to the
    // center point of the image.  This will be
    // used as a base for calculating the
    // relative distance from any pixel to the
    // center.
    double maxDistance = Math.sqrt(
                      centerWidth*centerWidth +
                      centerHeight*centerHeight);

    //Decrease the intensity of every pixel
    // except the one in the center of the image.
    // Initially the intensity will decrease
    // linearly with the distance of a pixel from
    // the center pixel.  The user can modify
    // this through input at the text field
    // later.

    //Use a nested loop to operate on each pixel.
    for(int row = 0;row < imgRows;row++){
      for(int col = 0;col < imgCols;col++){
        //Get the horizontal and vertical
        // distances from the center as the two
        // sides of a right triangle.
        double horiz = centerWidth - col;
        double vert = centerHeight - row;

        //Get the distance to the center as the
        // hypotenuse of a right triangle.
        double distance = Math.sqrt(horiz*horiz
                                    + vert*vert);
        if((int)distance > 0){
          //Calculate the scale factor to apply
          // to the three color values for the
          // pixel in order to control the
          // intensity.
          double scale =
                      1.0 - distance/maxDistance;

          //Adjust the light intensity based on
          // user input.  For a user input value
          // of 0 (the default at startup), the
          // intensity decreases linearly with
          // the distance from the center.  For a
          // user input value of 1, the intensity
          // decreases as the square of the
          // distance.  For an input value of 2,
          // the intensity decreases as the cube
          // of the distance, etc.
          for(int cnt = 0;cnt < loops;cnt++){
            scale = scale*scale;
          }//end for loop

          //Multiply each of the three color
          // values by the scale factor.  Don't
          // make any changes to the alpha value.
          temp3D[row][col][1] =
              (int)(scale * temp3D[row][col][1]);
          temp3D[row][col][2] =
              (int)(scale * temp3D[row][col][2]);
          temp3D[row][col][3] =
              (int)(scale * temp3D[row][col][3]);
/*
          //As an interesting experiment, you can
          // filter out two colors by enabling
          // these two statements and setting the
          // value of the third dimension to 1,
          // 2, or 3.  As written here, green and
          // blue will be eliminated leaving only
          // red.
          temp3D[row][col][2] = 0;
          temp3D[row][col][3] = 0;
*/
        }//end if
      }//end for loop on col
    }//end for loop on row

    return temp3D;
  }//end processImg
  //-------------------------------------------//

}//end class ImgMod11

<b>Listing 14</b>
</pre>
</td>
</tr>
</tbody>                                
</table></p>
     
<hr size="3" width="100%" align="center">    
<p>Copyright 2004, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. </p>
     
<h4> <a name="About_the_author">About the author</a></h4><b>
<a href="mailto:baldwin@dickbaldwin.com">Richard Baldwin</a></b><i>
  is a college professor (at Austin Community College in Austin, TX) and
private  consultant whose primary focus is a combination of Java, C#, and
XML. In addition to the many platform and/or language independent benefits
of Java and C# applications, he believes that a combination of Java, C#,
and XML will become the primary driving force in the delivery of structured
information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects, and he frequently 
 provides onsite training at the high-tech companies located in and around 
 Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a
 href="http://www.dickbaldwin.com">Tutorials</a>,
  which has gained a worldwide following among experienced and aspiring programmers.
  He has also published articles in JavaPro magazine.</i> </p>
     
<p><i>In addition to his programming expertise, Richard has many years of 
 practical experience in Digital Signal Processing (DSP).&nbsp; His first
 job after he earned his Bachelor's degree was doing DSP in the Seismic Research 
 Department of Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; 
 In the following years, he applied his programming and DSP expertise to other
 interesting areas including sonar and underwater acoustics.</i> </p>
     
<p><i>Richard holds an MSEE degree from Southern Methodist University and
  has many years of experience in the application of computer technology
to  real-world problems.</i> </p>
     
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
  </p>
     
<p>-end- </p>
   </body>
</html>
