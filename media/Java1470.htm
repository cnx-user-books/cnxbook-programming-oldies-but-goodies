<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
   <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#DD0000" vlink="#0000FF" alink="#FF0000" lang="EN-US">
<h2>
Fun with Java: Frame Animation</h2>
<i>Baldwin teaches you how to do frame animation.&nbsp; Equally important, he 
also teaches you about event-driven programming, multi-threaded programming, ordinary 
inner classes, anonymous inner classes, exception handling, and image icons.</i><p><b>Published:</b>&nbsp; 
February 4, 2003<br><b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
<p>Java Programming Notes # 1470<ul >
<li>
<a href="#Preface">Preface</a></li>
<li>
<a href="#Preview">Preview</a></li>

<li>
<a href="#Discussion and Sample Programs">Discussion and Sample Code</a></li>

<li>
<a href="#Run the program">Run the Program</a></li>

<li>
<a href="#Summary">Summary</a></li>

<li>
<a href="#Complete Program Listings">Complete Program Listing</a></li>
</ul>

<hr size=3 width="100%" align=center>
<center>
<h2>
<a NAME="Preface"></a>Preface</h2></center>
<p>
Computer programming doesn't have to be a gut-wrenching, high-pressure activity.&nbsp; 
Programming can also be fun.&nbsp; For me, programs that provide sensory 
feedback, such as animation and sound, are particularly enjoyable.&nbsp;  </p>
<p>
My 
previous series on animation, which began with the lesson entitled
<a href="http://www.developer.com/java/article.php/893471">Fun with Java: Sprite 
Animation, Part 1</a>, taught you how to combine sprite animation and frame animation.</p>
<p>
My current series of lessons, beginning with the lesson entitled 
<a href="http://www.developer.com/java/other/article.php/1565671">Java Sound, An 
Introduction</a>, will teach you how to program using the Java Sound API.</p>
<p>
<font color="#FF0000"><b>A somewhat simpler approach</b></font></p>
<p>
Sometimes, the combination of sprite animation and frame animation is overkill, 
and frame animation is all that you need.&nbsp; Frame animation is generally the simpler of the two.</p>
<p>
<font color="#FF0000"><b>Page-flip animation</b></font></p>
<p>
When I was a young boy, one of my friends had a book that had a small image at 
the lower right-hand corner of every right-hand page.&nbsp; By grasping the 
pages between the thumb and forefinger, and flipping through the pages rapidly, 
it was possible to animate the images to create a  movie.&nbsp; I later learned 
how to do the same things by drawing stick men in the right-hand margin of every 
right-hand page in the telephone book.&nbsp; Then by flipping through the pages very quickly, 
I could cause the stick men to dance, turn flips, run back and forth, etc.</p>
<p>
Little did I know as a youngster that someday I would be doing essentially the 
same thing, <i>(and also teaching others how to do it)</i> using a computer.</p>
<blockquote>
<p>
<i>(In fact, 
at that point in my life, I had never heard of a computer, nor had anyone that I 
knew).</i></p>
</blockquote>
<p>
<b><font color="#FF0000">Viewing tip</font></b>
<p>You may find it useful to open another copy of this lesson in a separate
browser window.&nbsp; That will make it easier for you to scroll back and
forth among the different listings and figures while you are reading about
them.
<p><b><font color="#FF0000">Supplementary material</font></b>
<p>I recommend that you also study the other lessons in my extensive collection
of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a consolidated
index of my Java tutorial lessons, and sometimes they are difficult to
locate there.&nbsp; You will find a consolidated index at <font color="#000000">
<a href="http://www.DickBaldwin.com">www.DickBaldwin.com</a>.</font>
  <h2 align="center"><font color="#000000"><a name="Preview">Preview</a></font></h2>
<p>
In this lesson, I will teach you how to do 
frame animation, independent of sprite animation.&nbsp; Equally important, I will 
also use this opportunity to teach you 
 
about:</p>
<ul>
  <li>Image icons</li>
  <li>Event-driven programming</li>
  <li>Multi-threaded programming</li>
  <li>Ordinary inner classes</li>
  <li>Anonymous inner classes</li>
  <li>Exception handling</li>
</ul>
<p>
<font color="#FF0000"><b>Not trivial topics</b></font></p>
<p>
None of the topics in the above list are trivial topics.&nbsp; In fact, with the 
exception of image icons and exception handling, these topics constitute a large part of what I 
teach in my college-level Intermediate Java Programming class.</p>
<blockquote>
<p>
<i>(I cover exception handling in the introductory OOP course, and cover Image 
Icons in one of the advanced courses.)</i></p>
</blockquote>
<p>
Of course, I cover each of those topics in much more 
depth in the classroom than I will be able to do in this single  lesson.&nbsp; 
Therefore, as we go along, I will refer you to more detailed tutorial lessons on 
some of the topics as 
background material.</p>
<center>
<h2>
<a NAME="Discussion and Sample Programs"></a><font color="#000000">Discussion
and Sample Code</font></h2></center>
<p><font color="#FF0000"><b>Will discuss a sample program</b></font><p>
As is my usual practice, I will provide this instruction by discussing a sample 
program.&nbsp; Although this program is rather short and compact, it is by no 
means simple.&nbsp; In fact, it incorporates some of the most subtle and 
abstract concepts of Java programming, including:<ul>
  <li>Event-driven programming</li>
  <li>Multi-threaded programming</li>
  <li>Ordinary inner classes</li>
  <li>Anonymous inner classes</li>
</ul>
<p>
<font color="#FF0000"><b>Will discuss in fragments</b></font><p>
Also, as is my usual practice, I will discuss the program in fragments.&nbsp; <i>
(A 
complete listing of the program is shown in Listing 15 near the end of the 
lesson.)</i><p>
This program, named <b>Animate04</b>, illustrates frame animation.&nbsp; When you 
compile and run the program, the graphical user interface <i>(GUI)</i> shown in 
Figure 1 appears on the screen.<p align="center">
<img border="0" src="java1470d.gif" width="251" height="201"><p align="center">
Figure 1 Program GUI<p>
Each time the user points to the GUI with the mouse pointer, the stick man 
starts dancing and continues dancing until the mouse pointer exits the GUI.&nbsp; 
<i>(The program was tested using Sun's SDK version 1.4.1 under Win2000.)</i><p>
<font color="#FF0000"><b>What is the animation process involved?</b></font><p>
The animation process is essentially the same as the one I described above involving the 
telephone book.&nbsp; In this program, three images of the stick 
man are stored in the program.&nbsp; When the mouse pointer is inside the GUI, 
the program displays a series of images by cycling through the three images of 
the stick man.&nbsp; This creates the illusion that the stick man is moving.<blockquote>
  <p>
<i>(You could improve the quality of the animation 
considerably by creating additional image files showing intermediate positions 
for the stick man and causing the program to cycle through those images as well.)</i></blockquote>
<p>
<font color="#FF0000"><b>The class definitions</b></font><p>
This program consists of a single top-level outer class and two inner classes.&nbsp; 
Listing 1 shows the beginning of the top-level class, which is also the controlling 
class <i>(because it defines the <b>main</b> method).</i><br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>public class <b>Animate04</b> extends JFrame{
  Thread <b>animate</b>;

  ImageIcon <b>images</b>[] = {//An array of images
  	new ImageIcon("java1470a.gif"),
    new ImageIcon("java1470b.gif"),
    new ImageIcon("java1470c.gif")};

  JLabel <b>label</b> = new JLabel(images[0]);

<b><font face="Courier New,Courier">Listing 1</font></b></pre>
</td>
</tr>
</table>

<p>Three instance variables are declared in Listing 1, with two of those 
instance variables being initialized when they are declared.</p>
 
<p><font color="#FF0000"><b>The instance variable named <i>animate</i></b></font></p>
 
<p>The first instance variable, named <b>animate</b>, is used later to store a 
reference to a <b>Thread </b>object.&nbsp; The<b> Thread</b> object is used to 
produce the animation.&nbsp; <i>(I will discuss the class from which this object 
is instantiated later.)</i></p>
 
<p><font color="#FF0000"><b>The instance variable named <i>images</i></b></font></p>
 
<p>The second instance variable, named <b>images</b>, is a reference to a 
three-element array object of type <b>ImageIcon</b>.&nbsp; This array object is 
initialized to contain references to three<b> ImageIcon</b> objects.&nbsp; The 
three <b>ImageIcon</b> objects are created, and the references to those objects 
are stored in the array when it is declared.</p>
 
<blockquote>
 
<p><i>(In Java, the elements of a new array object can be initialized by 
including a list of comma-separated expressions inside a matching pair of curly 
braces.&nbsp; Each expression corresponds to one element in the array.&nbsp; The 
size of the array is determined by the number of expressions.&nbsp; The contents 
of each array element are determined by evaluating the corresponding expression.&nbsp; 
Each expression must evaluate to a value that is assignment-compatible with the 
declared type of the array elements, which in this case is <b>ImageIcon</b>.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>The ImageIcon class</b></font></p>
 
<p>Here is part of what Sun has to say about the <b>ImageIcon</b> class.</p>
 
<blockquote>

<p><i>&quot;An implementation of the <b>Icon</b> interface that paints Icons from 
Images. Images that are created from a URL or filename are preloaded using <b>
MediaTracker</b> to monitor the loaded state of the image.&quot;</i></p>
 
</blockquote>

<p>Thus, the <b>ImageIcon</b> class implements the <b>Icon</b> interface.&nbsp; 
The class provides 
a large number of overloaded constructors.</p>
 
<p><font color="#FF0000"><b>The Icon interface</b></font></p>
 
<p>Here is part of what Sun has to say about the <b>Icon</b> interface:</p>
 
<blockquote>

<p><i>&quot;A small fixed size picture, typically used to decorate components.&quot;</i></p>
 
</blockquote>

<p>In this program, the objects of the interface type <b>Icon</b> <i>(objects<b> </b>
of the class <b>ImageIcon</b>)</i> will be used to decorate a <b>JLabel</b> component.</p>
 
<p><font color="#FF0000"><b>ImageIcon constructors</b></font></p>
 
<p>The  overloaded constructors of the <b>ImageIcon</b> class have the 
ability to create <b>ImageIcon</b> objects from a variety of sources.&nbsp; The 
overloaded version that I used in this program creates <b>ImageIcon</b> objects 
from  gif files, as indicated by the code in Listing 1.</p>
 
<blockquote>
 
<p><i>(Each of the ImageIcon objects created in Listing 1 is based on a 
different gif file.&nbsp; These gif files contain images of the stick man in 
different positions.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>The MediaTracker class</b></font></p>
 
<p>In some situations, particularly when the file containing the image is large, 
or is not stored locally, the actions of a <b>MediaTracker</b> object can be 
important <i>(that is not the case in this program).</i>&nbsp; Here is part of 
what Sun has to say about the <b>MediaTracker</b> class.</p>
 
<blockquote>

<p><i>&quot;The <b>MediaTracker</b> class is a utility class to track the status of a 
number of media objects. Media objects could include audio clips as well as 
images, though currently only images are supported.&quot;</i></p>
 
</blockquote>

<p><font color="#FF0000"><b>Purpose of a MediaTracker object</b></font></p>
 
<p>Basically, the purpose of a <b>MediaTracker</b> object is to notify the 
program of the loading state of an image <i>(media object).</i>&nbsp; This can 
be important in  situations where the amount of time required to load the 
image is significant.&nbsp; That is not the case in this program because:</p>
 
<ul>
  <li>The images are small.</li>
  <li>The images are loaded from the local hard drive.</li>
  <li>The images are loaded and converted to <b>ImageIcon</b> objects when the 
  object of the controlling class is created.&nbsp; <i>(The images are probably 
  fully loaded before the user has time to pick up the mouse.)</i></li>
</ul>

<p>Therefore, I didn't need to use a <b>MediaTracker</b> object to track the 
load status of the images in this program.</p>
 
<p><font color="#FF0000"><b>The instance variable named <i>label</i></b></font></p>
 
<p>Referring back to Listing 1, the instance variable named <b>label</b> is a reference to a <b>JLabel</b> object, which is 
initially decorated with one 
of the <b>ImageIcon</b> objects discussed above.</p>
 
<blockquote>
 
<p> <i>(The JLabel object is 
initially decorated with the <b>ImageIcon</b> object whose reference is stored 
at index 0 in the array.&nbsp; Later on, the value of the <b>
Icon</b> property of the label changes with time to produce the animation.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>The JLabel class</b></font></p>
 
<p>Here is part of what Sun has to say about the <b>JLabel</b> class:</p>
 
<blockquote>

<p><i>&quot;A JLabel object can display either text, an image, or both. You can 
specify where in the label's display area the label's contents are aligned ...&quot;</i></p>
 
</blockquote>

<p>In this program, the JLabel object displays only an image.&nbsp; It does not 
display text.</p>
 
<p><font color="#FF0000"><b>JLabel constructors</b></font></p>
 
<p>The <b>JLabel</b> class provides several overloaded constructors, which allow 
you to specify the text, the image, and the alignment of the two when the object 
is constructed.</p>
 
<p>When the <b>JLabel</b> is intended to display an image, the incoming parameter to the 
constructor must be a reference to an object of the interface type <b>Icon</b>.&nbsp; 
This requirement is satisfied by the code in Listing 1, because the <b>ImageIcon</b> 
class implements the <b>Icon</b> interface.</p>
 
<p><font color="#FF0000"><b>The setIcon method of the JLabel class</b></font></p>
 
<p>The <b>JLabel</b> class also provides a method named <b>setIcon</b>, which 
requires an incoming parameter of the interface type <b>Icon</b>.&nbsp; This 
method makes it possible to change the image being displayed by the label at 
runtime.&nbsp; This method will be used to cycle through images of the stick man 
to produce the animation in this program.</p>
 
<p><font color="#FF0000"><b>The constructor for Animate04</b></font></p>
 
<p>The constructor for the <b>Animate04</b> class begins in Listing 2.</p>
 
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public <b>Animate04</b>(){//constructor

    getContentPane().add(label);

<b><font face="Courier New,Courier">Listing 2</font></b></pre>
</td>
</tr>
</table>

<p>As you saw earlier in Listing 1, the <b>Animate04</b> class extends the <b>JFrame
</b>class.&nbsp; The code in Listing 2 places the <b>JLabel</b> object on the <i>
content pane</i> of the <b>JFrame</b> object.</p>
 
<p><font color="#FF0000"><b>The getContentPane method</b></font></p>
 
<p>The <b>getContentPane</b> method returns a reference to the content pane.&nbsp; 
In case you are unfamiliar with the content pane, I discuss it extensively in my 
tutorial lesson entitled
<a href="http://home.att.net/~baldwin.rg/Intermediate/Java087.htm">Swing, 
Understanding getContentPane() and other JFrame Layers</a>.</p>
 
<p>To make a long story short, a <b>JFrame</b> object provides several thousand 
transparent layers on which you can place components, <i>(such as <b>JLabel</b> objects, <b>
JButton</b> objects, etc.).</i>&nbsp; Each component is located horizontally 
and vertically by specifying the <b>x</b> and <b>y</b> coordinate position for 
the upper left-hand corner of the component.&nbsp; <i>(A layout manager may 
automatically perform that task for you.)</i></p>
 
<p>In a three dimensional sense, the <i>z-order</i> or depth coordinate value of 
each components can be controlled by specifying the 
number of the layer on which you want to place each component.&nbsp; This causes 
some components to appear to be <i>in front of</i> other components.</p>
 
<p><font color="#FF0000"><b>What is the content pane?</b></font></p>
 
<p>The <i>content pane</i> is the default layer on which you place components if 
you don't need to control the z-order placement.&nbsp; All components placed on 
the content pane are at the same level in the z-order.</p>
 
<p>In this program, we are placing only one component, <i>(a <b>JLabel</b> 
object),</i> in the <b>JFrame</b>.&nbsp; Therefore, we aren't concerned about 
z-order among components, and we simply place that component on the content pane
<i>(default layer)</i> as shown in Listing 2.</p>
 
<p><font color="#FF0000"><b>An anonymous listener class</b></font></p>
 
<p>The code in Listing 3 creates  an anonymous <b>MouseListener</b> object from 
an anonymous class and registers it to listen for mouse events on the content pane.&nbsp; 
The purpose is to detect when the mouse enters and exits the area of the 
content pane so that the animation can be started and stopped on that basis. </p>
 
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    getContentPane().<b>addMouseListener</b>(
      new <b>MouseAdapter</b>(){
        public void <b>mouseEntered</b>(MouseEvent e){
          <i>//Body code deleted for brevity</i>
        }//end mouseEntered

        public void <b>mouseExited</b>(MouseEvent e){
          <i>//Body code deleted for brevity</i>
        }//end MouseExited
      }//end new MouseAdapter
    );//end addMouseListener()

<b><font face="Courier New,Courier">Listing 3</font></b></pre>
</td>
</tr>
</table>

<p>The code in Listing 3 is some of the most cryptic code in all of Java.&nbsp; 
Just in case you aren't already familiar with anonymous classes, I 
will take some time to explain the code in Listing 3.</p>
 
<p><font color="#FF0000"><b>The JavaBeans event model</b></font></p>
 
<p>The code in Listing 3, plus what I am about to explain to you, is based on the
<i>JavaBeans</i> event model <i>(previously called the Delegation Event Model).</i></p>
 
<blockquote>
 
<p><i>(My series of tutorial lessons, beginning with
<a href="http://home.att.net/~baldwin.rg/Intermediate/Java080.htm">Event 
Handling in JDK 1.1, A First Look, Delegation Event Model</a>, discuss 
event-driven programming in detail.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>Making a long story short</b></font></p>
 
<p>Once again, to make a long story short, the JavaBeans event model depends on 
sources and listeners.&nbsp; In this program, the content pane of the <b>JFrame</b> 
object will act as a source for mouse events.&nbsp; The anonymous <b>
MouseListener</b> object 
registered on the content pane in Listing 3 will listen for, and handle those 
events when they occur.</p>
 
<p><font color="#FF0000"><b>What is a MouseListener object?</b></font></p>
 
<p>To be a mouse listener, an object must be instantiated from a class that 
implements the <b>MouseListener</b> interface.&nbsp; The <b>MouseListener</b> 
interface declares the following five methods:</p>
 
<ul>
  <li>mouseClicked</li>
  <li>mouseEntered</li>
  <li>mouseExited</li>
  <li>mousePressed</li>
  <li>mouseReleased</li>
</ul>

<p>As you probably already know, any class that implements an interface must provide a concrete definition for 
each method declared in the interface.&nbsp; Thus, any class that implements the
<b>MouseListener</b> interface must provide a concrete definition for each of the five 
methods listed above.</p>
 
<p><font color="#FF0000"><b>A convenience class named MouseAdapter</b></font></p>
 
<p>The Java API provides a convenience class named <b>MouseAdapter</b>, 
which implements the <b>MouseListener</b> interface.&nbsp; This class defines 
concrete <i>(but empty)</i> versions of the five methods declared in the 
interface.&nbsp; A programmer needing to define a class from which <b>
MouseListener</b> objects can be instantiated has two choices:</p>
 
<ul>
  <li>Implement the <b>MouseListener</b> interface and define all five methods.</li>
  <li>Extend the <b>MouseAdapter</b> class and override only the methods of 
  interest.</li>
</ul>

<p>I elected the second option in this program.&nbsp; Furthermore, I elected to do it in a 
very common, but very cryptic way.</p>
 
<p><font color="#FF0000"><b>Overrides mouseEntered and mouseExited methods</b></font></p>
 
<p>To begin with, the code in Listing 3 overrides the <b>mouseEntered</b> and <b>
mouseExited</b> methods, and ignores the other three methods.</p>
 
<p><font color="#FF0000"><b>The MouseListener registration method</b></font></p>
 
<p>The <b>addMouseListener</b> method in Listing 3 is used to <i>register</i> a
<b>MouseListener</b> object on a source of mouse events.&nbsp; In this case, the 
source is the content pane.</p>
 
<blockquote>
 
<p><i>(Once a <b>MouseListener</b> object is registered on a source of mouse 
events, the listener object will be notified each time a mouse event occurs on 
the source object.&nbsp; The notification methodology is to invoke the specific 
method, chosen from the five methods listed above, corresponding to the kind of 
mouse event that occurred.&nbsp; The behavior of the method will determine the 
response to the event.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>The parameter required for registration</b></font></p>
 
<p>The <b>addMouseListener</b> registration method requires an incoming parameter of type <b>
MouseListener</b>, which is a reference to a <b>MouseListener</b> object.&nbsp; 
This parameter is created in Listing 3 by instantiating an anonymous object 
inside 
the parenthesis of the call to the <b>addMouseListener</b> method.</p>
 
<p><font color="#FF0000"><b>What is an anonymous object?</b></font></p>
 
<p>It is very common in Java to instantiate a new anonymous object inside the 
parenthesis of a method call.</p>
 
<blockquote>
 
<p><i>(An anonymous object is an object whose reference is not assigned to a 
named reference variable.&nbsp; Hence, it has no name and is &quot;anonymous.&quot;)</i></p>
 
</blockquote>
 
<p>For example, the following statement instantiates a new anonymous object of 
the <b>Date</b> class and passes that object's reference to the <b>println</b> 
method.&nbsp; This will cause the current date and time to be displayed on the 
standard output:</p>
 
<p><b>System.out.println(new Date());</b></p>
 
<p><font color="#FF0000"><b>Not an ordinary anonymous object</b></font></p>
 
<p>However, the anonymous object instantiated in Listing 3 is not an ordinary anonymous object.&nbsp; An ordinary 
anonymous object would be instantiated using an expression of the form</p>
 
<p><b>new MouseListenerClass()</b></p>
 
<p>where <b>MouseListenerClass</b> is the name of a class that implements the <b>
MouseListener</b> interface.</p>
 
<p><font color="#FF0000"><b>A non-existent MouseListener class</b></font></p>
 
<p>In the code in Listing 3, the anonymous object is instantiated from a non-existent <b>
MouseListener</b> class.&nbsp; In other words, the class definition does not 
exist outside of the code in Listing 3.</p>
 
<p>The <b>MouseListener</b> object is instantiated anonymously in Listing 3.&nbsp; 
Furthermore, the class from which the object is instantiated is also defined anonymously within the 
parentheses that make up the call to the <b>addMouseListener</b> method.</p>
 
<p><b><font color="#FF0000">A verbal interpretation</font></b></p>
 
<p>You can verbally interpret the first two lines of code in Listing 3 as follows:</p>
 
<blockquote>

<p><i>Register, on the content pane, a <b>MouseListener</b> object, instantiated 
from a previously undefined class, which has no name, but which extends the 
class named <b>MouseAdapter</b>.</i></p>
 
</blockquote>

<p><font color="#FF0000"><b>Overridden interface methods</b></font></p>
 
<p>Beginning with the third line in Listing 3, the next several lines in Listing 
3 override the <b>mouseEntered</b> and <b>
mouseExited</b> methods declared in the <b>MouseListener</b> interface and 
defined in the <b>MouseAdapter</b> class.</p>
 
<blockquote>

<p><i>(Note that the body code for each of the overridden methods in Listing 3 was deleted for brevity.&nbsp; I wanted 
to be able to explain the structure first without getting bogged down in 
detailed body code.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>Only one semicolon</b></font></p>
 
<p>If you examine the code in Listing 3 carefully, you will see that it contains 
only one semicolon.&nbsp; Therefore, everything in Listing 3 is part of a single 
statement.&nbsp; The final two lines in Listing 3 provide the curly brace, 
parenthesis, and semicolon required to complete the statement.</p>
 
<p><font color="#FF0000"><b>An anonymous listener object of an anonymous class</b></font></p>
 
<p>Once the code in Listing 3 has been executed, a new anonymous object has been 
instantiated from an anonymous inner class.&nbsp; The new object has been registered on the 
content pane at that point.&nbsp;  </p>
 
<p>The anonymous class is a class that implements the <b>
MouseListener</b> interface.&nbsp; Whenever a mouse event occurs on the content 
pane, the appropriate method in the anonymous listener object will be invoked to handle 
the event.</p>
 
<p><b><font color="#FF0000">Expanding Listing 3</font></b></p>
 
<p>Now I am going to provide two listings that expand on the omitted details 
from Listing 3.&nbsp; Listing 4 shows the complete <b>mouseEntered</b> method 
from Listing 3, with the body code restored.&nbsp; Similarly Listing 5, <i>(to 
be discussed later),</i> shows the complete <b>mouseExited</b> method from Listing 
3 with the body code restored.</p>
 
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>        public void <b>mouseEntered</b>(MouseEvent e){
          animate = new <b>Animate</b>();
          animate.<b>start</b>();
        }//end mouseEntered

<b><font face="Courier New,Courier">Listing 4</font></b></pre>
</td>
</tr>
</table>

<p><font color="#FF0000"><b>The mouseEntered method</b></font></p>
 
<p>After the <b>MouseListener</b> object is registered on the content pane, the
<b>mouseEntered</b> method shown in Listing 4 will be invoked each time the mouse 
pointer enters the area of the screen occupied by the content pane.</p>
 
<p>The behavior of the <b>mouseEntered</b> method is:</p>
 
<ul>
  <li>Instantiate a new object of the <b>Animate</b> class.</li>
  <li>Invoke the <b>start</b> method on that object.</li>
</ul>

<p><font color="#FF0000"><b>The Animate class is a Thread class</b></font></p>
 
<p>The <b>Animate</b> class, which I will discuss in detail later, extends the <b>Thread</b> class, and defines the <b>
run</b> method.&nbsp; Here is part of what Sun has to say in the documentation 
for the <b>Thread</b> 
class:</p>
 
<blockquote>

<p><i>&quot;A <b>thread</b> is a thread of execution in a program. The Java Virtual 
Machine allows an application to have multiple threads of execution running 
concurrently.&quot;</i></p>
 
</blockquote>

<p><font color="#FF0000"><b>The start method</b></font></p>
 
<p>Here is part of what Sun has to say about the <b>start</b> method of the <b>
Thread</b> class:</p>
 
<blockquote>

<p><i>&quot;Causes this thread to begin execution; the Java Virtual Machine calls the
<b>run</b> method of this thread. </i></p>
 
  <p><i>The result is that two threads are running concurrently: the current 
  thread (which returns from the call to the <b>start</b> method) and the other 
  thread (which executes its <b>run</b> method).&quot;</i></p>
</blockquote>

<p>Thus, when the <b>start</b> method is invoked on an object instantiated from the<b> 
Animate </b>class, the <b>run</b> method belonging to that object is executed in 
a separate <i>thread,</i> running concurrently with the thread that handles 
events.&nbsp; This makes it possible to produce the animation and continue to 
monitor for events at the same time.</p>
 
<p><font color="#FF0000"><b>The run method</b></font></p>
 
<p>Later, when we examine the <b>run</b> method of the <b>Animate</b> class, we 
will see that it causes the three images discussed earlier to be repetitively 
displayed in 
succession.&nbsp; That is what produces the illusion that the stick man is 
dancing.&nbsp; That is also what I refer to as frame animation.</p>
 
<p><font color="#FF0000"><b>The mouseExited method</b></font></p>
 
<p>The <b>mouseEntered</b> method shown in Listing 4 is invoked when the mouse 
pointer enters the area of the screen occupied by the content pane.&nbsp; This 
causes animation of the stick man to begin.</p>
 
<p>The<b> mouseExited</b> method shown in Listing 5 is invoked when the mouse 
pointer leaves the area of the screen occupied by the content pane.&nbsp; This 
causes the animation of the stick man to stop.</p>
 
<p><font color="#FF0000"><b>Stopping the animation</b></font></p>
 
<p>The process of stopping the animation is a little more complicated than the 
process of starting the animation.&nbsp; This is evidenced by the code in 
Listing 5, which shows the full body of the <b>mouseExited</b> method from 
Listing 3.</p>
 
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>        public void <b>mouseExited</b>(MouseEvent e){
    
          animate.<b>interrupt</b>();

          while(animate.<b>isAlive</b>()){}//loop;

          animate = null;

          label.<b>setIcon</b>(images[0]);
          <b>label.r</b>epaint();
        }//end MouseExited

<b><font face="Courier New,Courier">Listing 5</font></b></pre>
</td>
</tr>
</table>

<p>Basically, here is what happens as a result of invoking the <b>mouseExited</b> 
method:</p>
 
<ul>
  <li>Interrupt the animation thread to terminate the animation.</li>
  <li>Loop for a few cycles while the animation thread finishes everything that 
  it needs to do and dies a natural death.</li>
  <li>Hand the animation object over to the garbage collector.</li>
  <li>Restore the default image to the label so that it will always be the same 
  when not being animated.</li>
</ul>

<p><font color="#FF0000"><b>The interrupt method</b></font></p>
 
<p>The result of invoking the <b>interrupt</b> method on a <b>Thread</b> object 
depends on the current state of the <b>Thread</b> object.&nbsp; As you will see 
when we examine the code in the <b>run</b> method of the <b>Thread</b> object, 
we are concerned with the Thread object being in one of two possible states:</p>
 
<ul>
  <li>The thread is sleeping.</li>
  <li>The thread is not sleeping, but rather is involved in selecting a new icon 
  and causing it to be painted on the screen.</li>
</ul>
 
<p><font color="#FF0000"><b>Interrupting the Thread object</b></font></p>
 
<p>The <b>Thread</b> object cycles between these two states in order to:</p>
 
<ul>
  <li>Display a new stick man image.</li>
  <li>Delay for an appropriate amount of time so that the new image will 
  register in the brain of the viewer.&nbsp; If the delay is too short, the 
  image won't be seen by the viewer and the animation will just be a blur.&nbsp; 
  If the delay is too long, the animation will appear to be jerky.</li>
</ul>
 
<p>If the <b>interrupt</b> method is invoked on the <b>Thread</b> object while 
it is 
sleeping, an <b>InterruptedException</b> will be thrown.&nbsp; We will stop the 
animation when the animation is thrown.</p>
 
<p>If the <b>interrupt</b> method is invoked on the <b>Thread</b> object while 
it is selecting a new icon and causing it to be painted on the screen, the <i>
interrupt</i> status for the <b>Thread</b> object will be set to true.&nbsp; We will test this status 
in the <b>run</b> method before 
causing the <b>Thread</b> object to go to sleep.&nbsp; If the status is true at 
that point in time, we will purposely throw an <b>
InterruptedException</b>.&nbsp; Again, we will stop the animation when the 
exception is thrown.&nbsp; However, in this case, a few extra machine cycles may 
occur before the exception is thrown.</p>
 
<p><font color="#FF0000"><b>The isAlive method</b></font></p>
 
<p>Shortly after the <b>InterruptedException</b> is thrown, the thread's <b>run</b> 
method will terminate normally, and the thread will die a natural death.&nbsp; 
Because this doesn't happen instantly, the code in Listing 5 loops until the <b>
isAlive</b> method returns false.&nbsp; This ensures that no further action is 
taken on the <b>Thread</b> object while it is still alive.</p>
 
<blockquote>
 
<p><i>(I always get a little nervous about writing a loop in an event handler 
for fear that it may take too long to terminate.&nbsp; However, I decided to 
take a chance in this case, and it seems to work OK under Win2000.&nbsp; 
However, a more sophisticated approach may be required on other operating 
systems, particularly those that don't provide automatic time slicing to prevent 
the event-handling thread from hogging the CPU.)</i></p>
 
</blockquote>
 
<p><font color="#FF0000"><b>Eligible for garbage collection</b></font></p>
 
<p>Continuing with the code in Listing 5, once the thread is no longer alive, a <i>null</i> value is assigned to the 
reference variable that refers to the <b>Thread</b> object.&nbsp; This causes 
the object to become eligible for garbage collection.</p>
 
<p><font color="#FF0000"><b>The setIcon method</b></font></p>
 
<p>As mentioned earlier, the <b>setIcon</b> method can be used to define the icon a component will 
display.&nbsp; The code in Listing 5 causes the icon that will be displayed to 
be the 
same icon that is displayed when the program starts.&nbsp; Thus, the same icon 
is displayed whenever the stick man is not being animated.</p>
 
<p><font color="#FF0000"><b>The repaint method</b></font></p>
 
<p>The purpose of the <b>repaint</b> method is to cause the screen area occupied 
by a component to be repainted as soon as possible.&nbsp; In this case, that 
causes the label with the new icon to appear on the screen.</p>
 
<p>Invoking the<b> repaint </b>method on a <b>JLabel</b> component sends a request to 
the operating system to invoke the component's <b>paint</b> method to repaint 
the component.&nbsp; Since I didn't override the <b>paint</b> method for the <b>
JLabel</b> object<b>, </b>the default version of the <b>paint</b> method for the 
label is actually invoked.</p>
 
<p><font color="#FF0000"><b>Not a blocking method</b></font></p>
 
<p>The <b>repaint</b> method is not a blocking method.&nbsp; This will become 
important  later when we discuss the animation thread.&nbsp; Rather, the <b>
repaint</b> method sends the <i>repaint</i> request to the operating system and returns 
immediately.&nbsp; In other words, control does not necessarily stay within the <b>repaint</b> 
method until the component has been repainted.</p>
 
<p><font color="#FF0000"><b>The operating system may not honor all repaint 
requests</b></font></p>
 
<p>In point of fact, the operating system is not required to honor all repaint 
requests.&nbsp; For example, if a series of repaint requests for the same 
component are made in short succession, the operating system has the option to 
ignore all the intermediate repaint requests and honor only the final request in 
the series.&nbsp; This could happen if the time interval between repaint 
requests is less than the time required to perform the repaint operation on the 
screen.</p>
 
<p><font color="#FF0000"><b>The mouseExited method terminates</b></font></p>
 
<p>Once the repaint request is made, the <b>mouseExited</b> method shown in 
Listing 5 terminates.</p>
 
<blockquote>
 
<p><i>(The actual repainting of the screen may not have been accomplished by 
that point in time.&nbsp; It may actually occur later.)</i></p>
 
</blockquote>
 
<p>The virtual machine is then free to honor the next 
event in the system event queue.</p>
 
<p><font color="#FF0000"><b>Still in the constructor</b></font></p>
 
<p>Recall that we are still discussing the code in the constructor.&nbsp; The 
final four statements in the constructor are shown in Listing 6.&nbsp; With the possible 
exception of the first statement in Listing 6, the final four statements in the 
constructor should be self-explanatory based on the names of the methods 
involved.</p>
 
<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    setDefaultCloseOperation(EXIT_ON_CLOSE);    
    setTitle("Copyright 2003, R.G.Baldwin");
    setSize(250,200);
    setVisible(true);

  }//end constructor

<b><font face="Courier New,Courier">Listing 6</font></b></pre>
</td>
</tr>
</table>

<p><font color="#FF0000"><b>The setDefaultCloseOperation method</b></font></p>
 
<p>The <b>setDefaultCloseOperation</b> method specifies the action to be taken 
when the user clicks  the <i>close</i> button on the frame.</p>
 
<blockquote>
 
<p> <i>(On a Windows 
system,  this is the button with the X in the upper right corner of 
the <b>JFrame</b> object as shown in Figure 1).</i></p>
 
</blockquote>
 
<p>Several optional actions can be specified.&nbsp; When the value EXIT_ON_CLOSE 
is passed as a parameter to the method, this specifies that the program should 
terminate when the user clicks the close button.</p>
 
<p><font color="#FF0000"><b>The ordinary inner class</b></font></p>
 
<p>
At this point, I am going to temporarily skip the <b>main</b> method and discuss 
the ordinary inner class named <b>Animate</b>.&nbsp; First, however, a few 
comments are in order regarding the use of inner classes.<p>
<font color="#FF0000"><b>Why use inner classes?</b></font><p>
The primary benefit of using inner classes has to do with accessibility of 
instance variables and instance methods.&nbsp; Basically, the code in an inner 
class has direct access to all the instance variables and all the instance 
methods of all outer enclosing classes.&nbsp; In some cases, this can eliminate 
a great deal of parameter passing that is required when all classes are defined 
as top-level classes.<p>
For example, the code in the anonymous inner class discussed above directly 
accesses the instance variable named <b>animate</b>.&nbsp; The code also 
accesses the instance variable named <b>images</b>, and the instance variable 
named <b>label</b>.<p>
These are all instance variables of the outer enclosing class.&nbsp; If the 
event handling code had been placed in a top-level class instead, it would have 
been 
necessary to pass copies of those instance variables to the constructor for 
the top-level class and to save those copies for use within the <b>
mouseEntered</b> and <b>mouseExited</b> methods of that class.&nbsp; Thus, it is often much 
more convenient to define a class an either an ordinary inner class or an 
anonymous inner class.<p>
<font color="#FF0000"><b>What happens at compile time?</b></font><p>
Every class that is defined in a Java program results in a compiled file with an 
extension of <i>class</i> regardless of whether it is a top-level class, an 
ordinary inner class, or an anonymous inner class.&nbsp; For example, when 
compiled, this program produces the following three files:<ul>
  <li>Animate04$1.class</li>
  <li>Animate04$Animate.class</li>
  <li>Animate04.class</li>
  </ul>
 
<p>
The first file in the above list results from compiling the anonymous inner 
class discussed above.&nbsp; Obviously, the class file does have a name, which is 
automatically assigned by the virtual machine.&nbsp; However, that name is never 
used explicitly by the programmer.&nbsp; Hence the class is called an anonymous 
inner class.<p>
Even though the anonymous class, in this case, is defined inside the 
constructor for the outer controlling class, it is actually compiled right along 
with the other classes that make up the program.&nbsp; In other words, the 
compilation of this class has nothing to do with the invocation of the 
constructor at runtime.<p>
The second file in the above list results from compiling the ordinary inner 
class that we will discuss next.&nbsp; The third file in the above list results 
from compiling the controlling class for this program.<p>
<font color="#FF0000"><b>The inner class named Animate</b></font><p>
An ordinary inner class is an inner class because its definition resides inside 
the definition of another class.&nbsp; However, it doesn't reside within the 
argument list of a method call, as is the case for an anonymous inner class. 
 
<p>
The purpose of this inner class is to provide the animation action for the 
program.&nbsp; The class definition begins in Listing 7.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  class <b>Animate</b> extends <b>Thread</b>{

<b><font face="Courier New,Courier">Listing 7</font></b></pre>
</td>
</tr>
</table>

<p><font color="#FF0000"><b>A class that extends the Thread class</b></font></p>
 
<p>You will recall that the purpose of the <b>Animate</b> class is to behave as 
a thread, executing concurrently with other threads in the program.&nbsp; You 
can learn more about threads by reviewing my tutorial lesson entitled
<a href="http://home.att.net/~baldwin.dick/Intro/Java058.htm">Threads of Control</a>.</p>
 
<p><font color="#FF0000"><b>Two approaches to multi-threaded programming</b></font></p>
 
<p>Briefly, there are two different ways that you can define a class from which 
you can instantiate thread objects:</p>
 
  <ul>
    <li>Implement the <b>Runnable</b> interface</li>
    <li>Extend the convenience class named <b>Thread</b>, which in turn 
    implements <b>Runnable</b></li>
  </ul>

<p>Even though the second approach is sometimes more convenient than the first, 
because Java doesn't support multiple inheritance, it isn't always possible for 
your class to extend the <b>Thread</b> class.&nbsp; However, it is always 
possible for your class to implement the <b>Runnable</b> interface.</p>
 
<p>As you can see in Listing 7, I elected to define a new class named <b>Animate</b>, 
which extends the <b>Thread</b> class.</p>
 
<p><font color="#FF0000"><b>Defining the run method</b></font></p>
 
<p>Regardless of which approach you take, your new class must provide a concrete 
definition for the method named <b>run</b>, which is declared in the <b>Runnable</b> 
interface.</p>
 
<p>Here is what Sun has to say about the <b>run</b> method:</p>
 
  <blockquote>

<p><i>&quot;When an object implementing interface <b>Runnable</b> is used to create a 
thread, starting the thread causes the object's <b>run</b> method to be called 
in that separately executing thread. </i></p>
 
    <p><i>The general contract of the method <b>run</b> is that it may take any 
    action whatsoever.&quot;</i></p>
  </blockquote>

<p><font color="#FF0000"><b>Somewhat analogous to the main method</b></font></p>
 
<p>I like to think of the <b>run</b> method of a thread as being somewhat 
analogous to the <b>main</b> method of an application.&nbsp; When you execute a 
Java application, its <b>main</b> method is always executed.&nbsp; When you 
invoke the<b> start</b> method on a <b>Runnable</b> object,<b> </b>its <b>run</b> 
method is always executed.</p>
 
  <blockquote>

<p><i>(The <b>start</b> method was invoked on an object of the <b>Animate</b> 
class in the <b>mouseEntered</b> method shown in Listing 4.)</i></p>
 
  </blockquote>

<p>As mentioned earlier, when the <b>run</b> method of a thread terminates, the 
thread is deemed to no longer be alive.&nbsp; <i>(I made use of that fact in the
<b>mouseExited</b> method discussed in Listing 5 earlier.)</i></p>
 
<p>When the <b>
main</b> method no longer has anything to do, and there are no  live 
<i>non-daemon</i> threads, the application will terminate.&nbsp; <i>(I'm not going to 
get into a discussion of daemon threads here.&nbsp; See 
<a href="http://home.att.net/~baldwin.dick/Intro/Java058.htm">Threads of Control</a> 
for a detailed discussion.)</i></p>
 
<p><font color="#FF0000"><b>The run method of the Animate class</b></font></p>
 
<p>
The <b>run</b> method of the <b>Animate</b> class contains two blocks of code:<ul>
    <li>A <b>try</b> block</li>
    <li>A <b>catch</b> block</li>
    </ul>
 
<p>
The try block is shown in Listing 8.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    public void <b>run</b>(){//begin run method
      try{
        while(true){
          display(1,500);
          display(0,500);
          display(2,500);
          display(0,500);
        }//end while loop
      }//end try block
<b><font face="Courier New,Courier">Listing 8</font></b></pre>
</td>
</tr>
</table>

<p><font color="#FF0000"><b>The try block</b></font></p>
 
<p>The code in the <b>try</b> block consists of an infinite loop.&nbsp; This 
loop continues to loop and invoke the method named <b>display</b> several times 
during each iteration until the <b>display</b> method throws an exception.</p>
 
<p><font color="#FF0000"><b>Display the stick man</b></font></p>
 
<p>The <b>display</b> method, <i>(which we will examine shortly),</i> causes 
different images of the stick man to be displayed, depending on the value of the 
first parameter passed to the method.</p>
 
<p>Briefly, the two 
parameters to the <b>display</b> method specify which image to display, and how 
long to display that image.</p>
 
<blockquote>
 
<p> <i>(The first parameter is an index into the 
array containing the <b>ImageIcon</b> objects from Listing 1, and the second parameter is the 
display time in milliseconds.)</i></p>
 
</blockquote>
 
<p>This is the code that actually produces the animation.&nbsp; The four 
successive invocations of <b>display</b> cause four views of the stick man to 
be displayed.&nbsp; Then another iteration begins and the same four views appear 
again.</p>
 
    <blockquote>

<p><i>(If you need a more complex animation algorithm possibly involving more 
 
images and varying display times, this is where you would provide a 
suitable algorithm for that purpose.)</i></p>
 
    </blockquote>

<p><font color="#FF0000"><b>An InterruptedException may be thrown</b></font></p>
 
<p>This animation process continues until the <b>display</b> method throws an 
exception.</p>
 
    <blockquote>

<p><i>(It is expected that an <b>InterruptedException</b> will be thrown when 
the <b>mouseExited</b> method invokes the <b>interrupt</b> method on the <b>
Animate</b> thread object.)</i></p>
 
    </blockquote>

<p>As is always the case, when an exception is thrown, execution of the code 
terminates and the virtual machine begins searching for a <b>catch</b> block 
whose type is compatible with the type of exception thrown.&nbsp; If such a 
match is found, control is transferred to that block, and the code in the catch block is executed.</p>
 
<p><font color="#FF0000"><b>The catch block</b></font></p>
 
<p>The <b>catch</b> block, which constitutes the second block of code in the <b>
run</b> method, begins in Listing 9.</p>
 
    <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      <b>catch</b>(Exception ex){
        if(ex instanceof InterruptedException){
          //Do nothing. This exception is
          // expected on mouseExited.
        }//end if

<b><font face="Courier New,Courier">Listing 9</font></b></pre>
</td>
</tr>
</table>

<p>This catch block is compatible with exceptions of type <b>Exception</b>, or 
any subclass of <b>Exception</b>.&nbsp; This includes <b>InterruptedException</b> 
and most other exceptions as well.</p>
 
<p><font color="#FF0000"><b>If an InterruptedException has occurred ...</b></font></p>
 
<p>The code in the <b>catch</b> block  uses the <b>instanceof</b> operator 
to determine if the exception is of type <b>InterruptedException</b>.&nbsp; If 
so, no further action is taken.&nbsp; By the time control reaches the <b>catch</b> 
block as a result of an <b>InterruptedException</b>, animation has  been terminated, which is the desired result of 
invoking the <b>interrupt</b> method in the <b>mouseExited</b> method.&nbsp; 
Therefore, no further action is required on the part of the thread object.</p>
 
<p><font color="#FF0000"><b>Some other type of exception</b></font></p>
 
<p>On the other hand, if the exception is of some  type other than <b>
InterruptedException</b>, this is an 
unexpected exception.&nbsp; In this case, the code in Listing 10 prints an error 
message and terminates the program.</p>
 
    <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>        else{//Unexpected exception occurred.
          System.out.println(ex);
          System.exit(1);//terminate program
        }//end else
      }//end catch
    }//end run

<b><font face="Courier New,Courier">Listing 10</font></b></pre>
</td>
</tr>
</table>

<p>And that is the end of the <b>run</b> method.</p>
 
<p><font color="#FF0000"><b>The display method</b></font></p>
 
<p>Recall that we are still discussing the code in the <b>Animate</b> class, from which <b>
Thread</b> objects are instantiated to perform the actual animation of the stick 
man.</p>
 
<p>The <b>display</b> method begins is listing 11.&nbsp; Before getting into the 
details of the code, however, consider the following overview.&nbsp; When the <b>
display</b> method is invoked, it causes a specified image to be displayed.&nbsp; 
Then the thread goes to sleep for a 
prescribed period of time.</p>
 
<p>If the thread is interrupted <i>(by code in the <b>mouseExited</b> 
method)</i> while the <b>display</b> method is displaying the image, the code in 
the <b>display</b> method throws an <b>InterruptedException</b> and terminates.</p>
 
<p>If the thread wakes up prior to being interrupted, 
it returns normally and animation continues.</p>
 
<p>If the thread goes to sleep and is 
interrupted before it wakes up, it automatically throws an <b>InterruptedException</b>, 
causing the <b>display</b> method to terminate.</p>
 
<p><font color="#FF0000"><b>Transfer of control</b></font></p>
 
<p>In any case that an exception is thrown while control is within the <b>
display</b> method, animation is terminated, and control 
is transferred to the <b>catch</b> block that begins in Listing 9.</p>
 
<p><font color="#FF0000"><b>The code in the display method</b></font></p>
 
<p>The beginning of the <b>display</b> method is shown in Listing 11.</p>
 
    <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>    void <b>display</b>(int image,int delay) 
                    throws InterruptedException{
      //Select and display an image.
      label.<b>setIcon</b>(images[image]);
      label.<b>repaint</b>();

<b><font face="Courier New,Courier">Listing 11</font></b></pre>
</td>
</tr>
</table>

<p>The <b>display</b> 
method receives two incoming parameters of type <b>int</b>.&nbsp; The first 
parameter is an index into the array containing the <b>ImageIcon</b> objects.&nbsp; 
The second parameter is the number of milliseconds to sleep after displaying the 
image specified by the first parameter.</p>
 
<p>The two statements in Listing 11 set and display an image.&nbsp; This code is 
identical to the code discussed earlier in Listing 5.&nbsp; Therefore, I won't discuss it further here.</p>
 
<p><font color="#FF0000"><b>Checking the interrupt status</b></font></p>
 
<p>If control reaches this point, and the <b>interrupt</b> method has been 
invoked on this <b>Thread</b> object since its instantiation <i>(meaning that 
the <b>mouseExited</b> method has been invoked)</i> the <b> <i>interrupt</i></b> status 
of the thread will have been set to true.</p>
 
<p>The code in Listing 12 invokes the <b>interrupted</b> method to check the <i>
interrupt</i> status of the thread.&nbsp; This code purposely throws an <b>InterruptedException</b> if 
the <b> <i>interrupt</i></b> status is <b>true</b>.</p>
 
    <table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      if(Thread.currentThread().<b>interrupted</b>())
        throw(new InterruptedException());

<b><font face="Courier New,Courier">Listing 12</font></b></pre>
</td>
</tr>
</table>

<p>This will immediately terminate the <b>display</b> method and transfer control to the <b>catch</b> block that 
begins in Listing 9.</p>
 
<p><font color="#FF0000"><b>Go to sleep</b></font></p>
 
<p>
If the <b> <i>interrupt</i></b> status of the thread is <b>false</b>, the code in Listing 13 
causes the <b>Thread</b> object to go to sleep for the prescribed number of 
milliseconds.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>      //Delay specified number of msec.
      //Terminate animation automatically if
      // interrupted while asleep.
      Thread.currentThread().sleep(delay);
    }//end display method

<b><font face="Courier New,Courier">Listing 13</font></b></pre>
</td>
</tr>
</table>

<p>This will cause the current image to be displayed until the thread 
wakes up and returns normally, or until the thread is interrupted by the code in 
the <b>mouseExited</b> method.</p>
 
<p><font color="#FF0000"><b>Behavior when asleep</b></font></p>
 
<p>If the thread is not interrupted while it is asleep, it will wake up after the 
prescribed number of milliseconds and return normally to the code in Listing 8.</p>
 
<p>If the thread is interrupted while it is asleep, it will wake up immediately, 
throw an <b>InterruptedException</b>, and transfer control to the <b>catch</b> 
block that begins is Listing 9.&nbsp; As mentioned earlier, this will stop the 
animation, which is the desired result of invoking the <b>interrupt</b> method 
within the <b>mouseExited</b> method.</p>
 
<p><font color="#FF0000"><b>End of the Animate class definition</b></font></p>
 
<p>With the exception of one more curly brace, that ends the definition of the 
inner class named <b>Animate</b>.&nbsp; <i>(I won't waste your time by showing 
you that curly brace.&nbsp; You can view it in Listing 15 near the end of the 
lesson.)</i></p>
 
<p>
<font color="#FF0000"><b>The main method</b></font><p>
Finally, the <b>main</b> method for this program is shown in Listing 14.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>  public static void main(String[] args){
    <b>new Animate04();</b>
  }//end main

<b><font face="Courier New,Courier">Listing 14</font></b></pre>
</td>
</tr>
</table>

<p>All that the<b> main</b> method<b> </b>does is invoke the constructor to instantiate a new object of the 
controlling class named <b>Animate04</b>.</p>
 
<p><font color="#FF0000"><b>Let's recap</b></font></p>
 
<p>To recap, here is what happens when the constructor for the
<font color="#FF0000"><b>Animate04</b></font> class is invoked and the 
object is instantiated:</p>
 
    <ul>
      <li>The <b>JLabel</b> object, which was initialized to display the default 
      image, is added to the <i>content pane </i>of the <b>JFrame</b> object.</li>
      <li>An object of the anonymous class <i>(stored in the class file named 
      Animate04$1.class)</i> is instantiated and registered as a mouse listener 
      on the content pane of the <b>JFrame</b> object.&nbsp; This object 
      contains specified behavior for the <b>mouseEntered</b> and <b>mouseExited</b> 
      methods.&nbsp; The other three methods declared in the <b>MouseListener</b> 
      interface are defined with empty bodies.&nbsp; Thus, if invoked, these 
      three methods will return immediately without performing any action.</li>
      <li>Property values are established for the following properties:&nbsp; <i>
      defaultCloseOperation</i>, <i>title</i>, and <i>size</i>.</li>
      <li>The <i>visible</i> property is set to true, which causes the <b>JFrame</b> 
      object, and the <b>JLabel</b> object that it contains to appear on the 
      screen.</li>
    </ul>

<p><font color="#FF0000"><b>A quiescent state</b></font></p>
 
<p>At this point, the program enters a quiescent state, waiting for the user to 
cause an event of some type.&nbsp; There are dozens of different types of event 
that the user can cause to occur.&nbsp; However, only two of those event types will be 
processed by the program.&nbsp; All the rest will be ignored.</p>
 
<blockquote>

<p><i>(Actually, only one event type, <b>MouseEvent</b>, will be processed.&nbsp; 
The animation behavior of the program is based on two sub-categories of the <b>
MouseEvent</b> type.&nbsp; To avoid unnecessary complexity, I will refer to them 
simply as two events.)</i></p>
 
</blockquote>

<p><font color="#FF0000"><b>Two events that will be processed</b></font></p>
 
<p>The two events that will be processed by the program are two sub-categories 
of the event type <b>MouseEvent</b>:</p>
 
    <ul>
      <li><b>mouseEntered</b> - occurs when the mouse pointer enters the area 
      of the screen occupied by the <i>content pane</i> of the <b>JFrame</b> 
      object.</li>
      <li><b>mouseExited</b> - occurs when the mouse pointer exits the area of 
      the screen occupied by the <i>content pane</i> of the <b>JFrame</b> 
      object.</li>
    </ul>

<p><font color="#FF0000"><b>The mouseEntered event</b></font></p>
 
<p>A <b>mouseEntered</b> event causes an object to be instantiated from the <b>
Thread</b> class named <b>Animate</b>.&nbsp; Once the object is instantiated, 
the <b>run</b> method of the <b>Thread</b> object is started.&nbsp; The <b>run</b> 
method runs continuously, causing the stick man to be animated, until the <b>
Thread</b> object is interrupted.</p>
 
<p><font color="#FF0000"><b>The mouseExited event</b></font></p>
 
<p>A <b>mouseExited</b> event causes the <b>interrupt</b> method to be invoked 
on the <b>Thread</b> object.&nbsp; This  causes the<b> run</b> method of the<b> Thread</b> object 
to terminate, which in turn causes the animation of the stick man to stop.</p>
 
<p>This also causes the <b>Thread </b>object to die a natural death.&nbsp; 
Once the <b>Thread</b> object is no longer alive, the <b>mouseExited</b> method 
makes the <b>Thread</b> object eligible for garbage collection, and displays the 
default image on the label on the <b>JFrame</b> object.</p>
 
<center>
<h2>
<a NAME="Run the program"></a>Run the Program</h2></center>
<p>
      At this point, you may find it interesting to compile and run the <b>Animate04
      </b>program shown in 
      Listing 15 near the end of the lesson.&nbsp; Because I tested the program 
      using SDK version 1.4.1, I recommend that you compile and run it using that 
      version or a later version of the SDK.<p>
      You should be able to copy and paste the program into your editor.&nbsp; 
      Then store it in a file named <b>Animate04.java</b>.<p>
      <font color="#FF0000"><b>The stick-man images</b></font><p>
      In order to compile and run the program, you will also need to download the three image 
      files shown below.&nbsp; You should be able to download them individually 
      by right-clicking on them and  saving them on your local disk.<p align="center">
      <img border="0" src="java1470a.gif" width="104" height="125">&nbsp;
      <img border="0" src="java1470b.gif" width="104" height="125">&nbsp;
      <img border="0" src="java1470c.gif" width="104" height="125"><p>
      Save them under the following file names in the same directory containing 
      your source code file and compiled files:<ul>
  <li>java1470a.gif</li>
  <li>java1470b.gif</li>
  <li>java1470c.gif</li>
  </ul>
<h2 align="center"><a name="Summary">Summary</a></h2>
<p>In this lesson, I taught you how to do frame animation.&nbsp; Equally important, 
I also taught you about event-driven programming, multi-threaded programming, ordinary 
inner classes, anonymous inner classes, exception handling, and image icons.</p>
<center>
<h2>
<a NAME="Complete Program Listings"></a>Complete Program Listing</h2></center>
A complete listing of the program is shown in Listing 11.<br>
&nbsp;<table BORDER COLS=1 WIDTH="400" BGCOLOR="#FFFF00" >
<tr>
<td>
<pre>/*File Animate04.java
Revised 01/07/03

Illustrates frame animation.  Stick figure
dances when user point to the image with the
mouse.  Stick figure stops dancing when mouse 
pointer exits the image.

Also illustrates:
  Event-driven programming
  Multi-threaded programming
  Ordinary inner classes
  Anonymous inner classes
  Image icons

Tested using SDK 1.4.1 under Win 2000.
************************************************/
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class Animate04 extends JFrame{
  Thread animate;//Store ref to animation thread
  ImageIcon images[] = {//An array of images
  	new ImageIcon("java1470a.gif"),
    new ImageIcon("java1470b.gif"),
    new ImageIcon("java1470c.gif")};
  JLabel label = new JLabel(images[0]);

  //-------------------------------------------//
  public Animate04(){//constructor

    getContentPane().add(label);
    
    //Use an anonymous inner class to register a
    // mouse listener
    getContentPane().addMouseListener(
      new MouseAdapter(){
        public void mouseEntered(MouseEvent e){
          //Get a new animation thread and start
          // the animation on it.
          animate = new Animate();
          animate.start();
        }//end mouseEntered

        public void mouseExited(MouseEvent e){
          //Terminate the animation.    
          animate.interrupt();
          //Let the thread die a natural death.
          // Then make it eligible for garbage
          // collection.
          while (animate.isAlive()){}//loop;
          animate = null;
          //Restore default image.
          label.setIcon(images[0]);
          label.repaint();
        }//end MouseExited
      }//end new MouseAdapter
    );//end addMouseListener()
    //End definition of anonymous inner class

    setDefaultCloseOperation(EXIT_ON_CLOSE);    
    setTitle("Copyright 2003, R.G.Baldwin");
    setSize(250,200);
    setVisible(true);

  }//end constructor
  //-------------------------------------------//

  public static void main(String[] args){
    new Animate04();
  }//end main
  //-------------------------------------------//

  //Ordinary inner class to animate the image
  class Animate extends Thread{

    public void run(){//begin run method
      try{
      	//The following code will continue to
      	// loop until the animation thread is
      	// interrupted by the mouseExited
      	// method.
        while(true){
          //Display several images in succession.
          display(1,500);
          display(0,500);
          display(2,500);
          display(0,500);
        }//end while loop
      }catch(Exception ex){
        if(ex instanceof InterruptedException){
          //Do nothing. This exception is
          // expected on mouseExited.
        }else{//Unexpected exception occurred.
          System.out.println(ex);
          System.exit(1);//terminate program
        }//end else
      }//end catch
    }//end run
    //-----------------------------------------//
    
    //This method displays an image and sleeps
    // for a prescribed period of time.  It
    // terminates and throws an
    // InterruptedException when interrupted
    // by the mouseExited method.
    void display(int image,int delay) 
                    throws InterruptedException{
      //Select and display an image.
      label.setIcon(images[image]);
      label.repaint();
      //Check interrupt status.  If interrupted
      // while not asleep, force animation to
      // terminate.
      if(Thread.currentThread().interrupted())
        throw(new InterruptedException());
      //Delay specified number of msec.
      //Terminate animation automatically if
      // interrupted while asleep.
      Thread.currentThread().sleep(delay);
    }//end display method
    //-----------------------------------------//
  }//end inner class named Animate

}//end class Animate04

<b><font face="Courier New,Courier">Listing 15</font></b></pre>
</td>
</tr>
</table>
<p>
   <p>
   <hr size=3 width="100%" align=center>
<p>Copyright 2003, Richard G. Baldwin.&nbsp; Reproduction in whole or in
part in any form or medium without express written permission from Richard
Baldwin is prohibited. <h4>
<a NAME="About the author"></a>About the author</h4>
<i><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a> is a college professor (at Austin Community College in Austin, TX) and private consultant whose primary focus is a combination of Java, C#, and XML. In addition to the many platform and/or language independent benefits of Java and C# applications, he believes that a combination of Java, C#, and XML will become the primary driving force in the delivery of structured information on the Web.</i><br><p><i>Richard has participated in numerous consulting projects and he
frequently provides onsite training at the high-tech companies located
in and around Austin, Texas.&nbsp; He is the author of Baldwin's Programming <a href="http://www.DickBaldwin.com">Tutorials</a>,
which has gained a worldwide following among experienced and aspiring programmers.
He has also published articles in JavaPro magazine.</i> <p><i>Richard holds an MSEE degree from Southern Methodist University and
has many years of experience in the application of computer technology
to real-world problems.</i> <p><i><a href="mailto:Baldwin@DickBaldwin.com">Baldwin@DickBaldwin.com</a></i> <p>-end- </body></html>