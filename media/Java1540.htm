<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>... in Java by Richard G Baldwin</title>
</head>
<body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
<h2>Understanding Lighting in the Java 3D API</h2>
<i>Baldwin teaches you about, and shows you examples of many of the important 
features of scene 
illumination in the Java 3D API.&nbsp; He also provides you 
with the source code for a complete Java 3D lighting simulator program that you can 
use to experiment with light in the Java 3D API.</i><p><b>Published:</b>&nbsp; 
July 25, 2006<br>
<b>By <a href="mailto:Baldwin@DickBaldwin.com">Richard G. Baldwin</a></b>
</p>
<p>Java Programming Notes # 1540</p>
<ul>
  <li> <a href="#Preface">Preface</a></li>
  <li> <a href="#Technical_Information">Technical Discussion</a></li>
	<ul><li> <a href="#The_Program_">The Program</a></li>
		<li><a href="#Number_of_Facets">The Number of Facets</a></li>
		<li><a href="#Shading_Model">The Shading Model</a></li>
		<li><a href="#The_Small_Spheres">The Small Spheres</a></li>
		<li><a href="#Emissive_Color">Emissive Color</a></li>
		<li><a href="#Ambient_Color_and_the_AmbientLight_Class">Ambient 
		Reflection 
		and the AmbientLight Class</a></li>
		<li>
		<a href="#Combinations_of_Light_Source_and_Surface_Reflection_Properties">
		More Combinations of Light Source and Surface Reflection Properties</a></li>
		<li><a href="#Diffuse_Color_and_the_DirectionalLight_Class">Diffuse 
		Reflection 
		and the DirectionalLight Class</a> </li>
		<li><a href="#The_Shininess_Property">The Shininess Property</a></li>
		<li><a href="#Specular_Color_and_the_DirectionalLight_Class">Specular 
		Reflection 
		and the DirectionalLight Class</a></li>
		<li><a href="#Shadows">Shadows</a></li>
		<li><a href="#Diffuse_Reflection_and_the_PointLight_Class">Diffuse 
		Reflection and the PointLight Class</a></li>
		<li><a href="#Specular_Reflection_and_the_PointLight_Class">Specular 
		Reflection and the PointLight Class</a></li>
		<li><a href="#Diffuse_Reflection_and_the_SpotLight_Class">Diffuse 
		Reflection and the SpotLight Class</a></li>
		<li><a href="#Specular_Reflection_and_the_SpotLight_Class">Specular 
		Reflection and the PointLight Class</a></li>
		</ul>
  <li> <a href="#Run%20the%20program">Run the Program</a></li>
  <li> <a href="#Summary">Summary</a></li>
  <li> <a href="#Whats%20Next">What's Next?</a></li>
	<li> <a href="#References">References</a></li>
  <li> <a href="#Complete%20Program%20Listings">Complete Program
Listing</a></li>
</ul>
<hr size="3" width="100%" align="center">
<center>
<h2> <a name="Preface"></a>Preface</h2>
</center>
<p> This is the first part of a multi-part lesson designed to help you understand the use of lighting and illumination in 3D scenes produced using the Java 3D 
API.</p>
<p> <font color="#FF0000"><b>Optical illusions</b></font></p>
<p> Creating scenes that appear to be three-dimensional on a flat two-dimensional screen is all 
about creating optical illusions.&nbsp; There are many important aspects to 
creating these optical illusions in 3D 
programming, not the least of which is lighting and illumination.</p>
<p> <font color="#FF0000"><b>A 3D simulator program</b></font></p>
<p> In this lesson, I will teach you about, and show examples of many of the important 
features of scene 
illumination in the Java 3D API.&nbsp; I will also provide the source code for a complete Java 3D lighting simulator program that you can compile and run to experiment 
with light in the Java 3D API.&nbsp; I will explain how that program works in 
subsequent parts of this multi-part lesson.</p>
<p> <b><font color="#ff0000">Viewing tip</font></b> </p>
<p>You may find it useful to open another copy of this lesson in a
separate browser window.&nbsp; That will make it easier for you to
scroll back
and forth among the different figures, tables, and listings while you are
reading
about them.</p>
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
<p>I recommend that you also study the other lessons in my extensive
collection of online Java tutorials.&nbsp; You will find those lessons
published
at <a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp;
However, as of the date of this writing, Gamelan doesn't maintain a
consolidated index of my Java tutorial lessons, and sometimes they are
difficult to locate there.&nbsp; You will find a consolidated index at <font
 color="#000000"> <a href="http://www.dickbaldwin.com/">www.DickBaldwin.com</a>.</font></p>
<h2 align="center"><a name="Technical_Information">Technical<font color="#000000"> 
Discussion</font></a></h2>
<h3><a name="The_Program_">The Program </a></h3>
<p>The program that I will present in this lesson can be used to experiment with most 
of the lighting and illumination features of the Java 3D API either individually 
or in combination.</p>
<p>In order to compile and run this program, you will need to download and install the 
Java 3D API.&nbsp; As of the date of this writing, it was available at:
<a href="http://java.sun.com/products/java-media/3D/">
http://java.sun.com/products/java-media/3D/</a>.&nbsp; The online documentation 
was available at: <a href="http://download.java.net/media/java3d/javadoc/1.4.0/">
http://download.java.net/media/java3d/javadoc/1.4.0/</a>.</p>
<p>In addition, you will need to download and install either
<a href="http://www.microsoft.com/windows/directx/default.mspx">Microsoft 
DirectX</a> or <a href="http://www.opengl.org/">OpenGL</a>.</p>
<p><font color="#FF0000"><b>Our perception of 3D visual objects</b></font></p>
<p>From time to time, I will make references to Chapter 6 of a document 
published by Dennis J. Bouvier at the following URL.&nbsp;
<a href="http://java.sun.com/developer/onlineTraining/java3d/">
http://java.sun.com/developer/onlineTraining/java3d/</a>.&nbsp; 
For example, here is a quotation from Bouvier:</p>
<blockquote>
	<p><i>&quot;In the real world, the colors we perceive are a combination of the 
	physical properties of the object, the characteristics of the light sources, 
	the objects' relative positions to light sources, and the angle from which 
	the object is viewed.&nbsp; Java 3D uses a lighting model to approximate the 
	physics of the real world.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>The mathematical 3D model</b></font></p>
<p>According to Bouvier, Section E.2 of the
<a href="http://java.sun.com/products/java-media/3D/forDevelopers/j3dguide/j3dTOC.doc.html">
Java 3D API Specification</a> presents the mathematical equations of the Java 3D 
lighting model.&nbsp; Still quoting Bouvier, </p>
<blockquote>
	<p><i>&quot;The lighting model equation depends on three vectors: the surface 
	normal (N), the light direction (L), and the direction to the viewer's eye 
	(E) in addition to the Material properties of the object and the light 
	characteristics.&quot;</i></p>
</blockquote>
<p>This program makes it easy for the user to vary the surface normal <i>
(indirectly)</i>, the light direction, and the Material properties of the 
object.&nbsp; The program does not make it easy for the user to modify the 
direction to the viewer's eye.&nbsp; However, the primary experimental object is 
a large sphere which, because of its curvature, inherently results in a wide 
range of directions from the object's surface to the user's eye.</p>
<p><font color="#FF0000"><b>Light sources</b></font></p>
<p>Returning to <a name="Bouvier_light">Bouvier</a>, </p>
<blockquote>
	<p><i>&quot;The lighting model incorporates three kinds of real world lighting 
	reflections: ambient, diffuse, and specular.&nbsp; Ambient reflection 
	results from ambient light, constant low level light, in a scene.&nbsp; 
	Diffuse reflection is the normal reflection of a light source from a visual 
	object.&nbsp; Specular reflections are the highlight reflections of a light 
	source from an object, which occur in certain situations.&quot;</i></p>
</blockquote>
<p>This program makes it easy for the user to experiment with all three types of 
sources, plus another form of illumination referred to as emissive color.</p>
<p><font color="#FF0000"><b>Two user interfaces</b></font></p>
<p>This program produces two user interfaces.&nbsp; One interface is the display 
of a 3D scene containing five spheres as shown in 
<a name="Figure_1" href="#Figure_1">Figure 1</a>.</p>






<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a1a.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_1">Figure 1</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<blockquote>
	<p><i>(Note that the importation of the image into this HTML document introduced 
	some visual artifacts that were not present in the original image produced 
	by the program.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The four small spheres</b></font></p>
<p>Four of the spheres are small with fixed reflective surface properties and a 
fixed number of facets.&nbsp; When illuminated with white light, or colored 
light corresponding to the color of the sphere, these spheres appear 
as white, red, green, and blue as shown in <a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>The larger fifth sphere</b></font></p>
<p>The fifth sphere is larger.&nbsp; Almost everything 
about this sphere <i>(other than its size and location)</i> can be modified by the user 
through the second user interface shown in <a name="Figure_2"><a href="#Figure_2">Figure 2</a></a>.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a1b.jpg" width="474" height="719"><br></pre>
      <pre><b><a href="#Figure_2">Figure 2</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The slider section</b></font></p>
<p>The user interface in <a href="#Figure_2">Figure 2</a> consists of three main sections.&nbsp; The 
section at the top contains three sliders that are used to adjust the values of 
selected scene properties.&nbsp; The values indicated by the sliders are tied 
directly to the display shown in <a href="#Figure_1">Figure 1</a>, and the display changes in real time 
as each slider is adjusted to indicate different values.</p>
<p><font color="#FF0000"><b>A grid of radio buttons and text fields</b></font></p>
<p>The large middle portion of the interface contains a grid of radio buttons 
and text fields.&nbsp; The radio buttons are used to select the scene properties 
that will be modified by adjusting the sliders at the top of the user interface.</p>
<p>When a radio button is selected, the label above each slider changes to 
appropriately reflect the value of the scene property currently assigned to the 
slider.&nbsp; In addition, the values displayed in the text fields to the right 
of the selected radio button display the values indicated by the sliders, and 
the column headers for the text fields change to appropriately reflect the 
values of the scene properties currently associated with the selected sliders.</p>
<p><font color="#FF0000"><b>Shading and size</b></font></p>
<p>The four radio buttons at the bottom of the user interface are used to select 
between:</p>
<ul>
	<li>Gouraud and flat shading</li>
	<li>Large display and small display</li>
</ul>
<p><a href="#Figure_1">Figure 1</a> was produced as a large display using Gouraud shading.&nbsp; You 
will see examples of both types of shading as well as large and small displays 
later in this lesson.</p>
<p><font color="#FF0000"><b>More than 50 scene property values</b></font></p>
<p>The user can vary the surface reflective properties of the large sphere and 
can also modify various properties of the lights shown in <a href="#Figure_1">Figure 1</a>.</p>
<p>The user interface in <a href="#Figure_2">Figure 2</a> provides more than 50 scene property values that can be 
modified by the user to change the reflective properties of the large sphere and the 
various properties of the lights.&nbsp; The ability for the user to modify the 
reflective surface properties of the large sphere makes it possible for the user to view 
the effects of those modifications in conjunction with varying light 
conditions.</p>
<p><font color="#FF0000"><b>Surface properties of the large sphere</b></font></p>
<p>The user can control almost all aspects of the following 
surface properties of the large sphere:</p>
<ul>
	<li>The number of <i>facets</i> on the surface of the sphere.</li>
	<li>The type of shading: 
	<a href="http://en.wikipedia.org/wiki/Gouraud_shading">Gouraud</a> shading versus
	<a href="http://en.wikipedia.org/wiki/Flat_shading">Flat</a> shading.</li>
	<li>The <i>shininess</i> of the sphere.</li>
	<li>The <i>emissive</i> color and intensity of the sphere.</li>
	<li>The <i>ambient</i> 
color and intensity of the sphere.</li>
	<li>The <i>diffuse</i> color and intensity of the sphere.</li>
	<li>The <i>specular</i> color and intensity of the sphere.</li>
</ul>
<p><font color="#FF0000"><b>Five independent light sources</b></font></p>
<p>In addition, the 
user has control over the following five lights along with the properties shown:</p>
<ul>
	<li>One <b>AmbientLight</b> object <i>(color and intensity)</i>.</li>
	<li>Two independent <b>DirectionalLight</b> objects <i>(color, intensity, 
	and direction)</i>.</li>
	<li>One <b>PointLight</b> object <i>(color, intensity, location, and 
	attenuation)</i>.</li>
	<li>One <b>SpotLight</b> object <i>(color, intensity, direction, location, 
	attenuation, spreading angle, and concentration)</i>.</li>
</ul>
<p><font color="#FF0000"><b>An almost infinite number of combinations</b></font></p>
<p>Given the many properties of the five light sources and the many reflective 
properties of the spheres, the lights can be combined with the spheres to 
illuminate the scene in an almost infinite number of ways.</p>
<p>For example, having specified the various 
surface properties of the large sphere, the user can vary the properties of the lights 
and observe the manner in which the lights interact with the five spheres to 
illuminate the scene.</p>
<p><font color="#FF0000"><b>Real-time control</b></font></p>
<p>The properties of the large sphere and the lights are 
varied by selecting a radio button <i>(see <a href="#Figure_2">Figure 2</a>)</i> that corresponds to the property 
of interest and then 
adjusting the three sliders at the top of <a href="#Figure_2">Figure 2</a>.&nbsp; The display of the scene changes 
in real time as the user adjusts the 
sliders, making it possible to easily view the effects of fixing all of the properties 
but one and then varying that property across a range of values by moving a 
slider.</p>
<p><font color="#FF0000"><b>Large or small display</b></font></p>
<p>The user 
interface shown in <a href="#Figure_2">Figure 2</a> also makes it possible for the user to select between a large and a 
small display.&nbsp; This was done mainly to support my publishing effort as I 
import the images into this tutorial lesson.&nbsp; Figure 
1 shows the large display.&nbsp; You will see examples of the small display 
later.</p>
<p><font color="#FF0000"><b>Testing</b></font></p>
<p>This program was tested using J2SE 5.0, the 
Java 3D API version 1.4.0, WinXP and
<a href="http://www.microsoft.com/windows/directx/default.mspx">Microsoft 
DirectX</a>.&nbsp; Note that it is also possible to use
<a href="http://www.opengl.org/">OpenGL</a> instead of DirectX, but I haven't 
tried it.</p>
<h3><a name="Number_of_Facets">The Number of Facets</a></h3>
<p>Normally we would like to think that the silhouette of a sphere is a perfect 
circle.&nbsp; In the ideal case, that would be true.&nbsp; However, 3D computer 
graphics do not often reflect the ideal case.</p>
<p><font color="#FF0000"><b>How to draw a circle</b></font></p>
<p>When you were in elementary school, you probably learned how to use a compass 
to draw a circle.&nbsp; If you did it correctly, the circles were nice and 
smooth.&nbsp; Unfortunately, however, there are no compasses inside computers.&nbsp; Typically 
when we draw a circle with a computer, we 
compute the values that represent the circle at a set of regularly spaced points around the 
circumference of the circle and then connect those points with straight line 
segments.&nbsp; 
The closer the points are spaced, the better will be the representation of the 
circle.</p>
<p><font color="#FF0000"><b>How to draw a sphere</b></font></p>
<p>Similarly, when we draw a sphere with a computer, we 
typically compute the values representing the surface of the sphere at a set of regularly spaced points on the surface 
of the sphere and then connect those points with straight line segments.&nbsp; Those lines 
form the edges of flat polygons and it is this structure built from flat polygons 
that constitutes our representation of the sphere.&nbsp; Just as in the case of the 
circle, the closer together the points are on the surface of the sphere, the better 
will be our representation of the sphere.</p>
<p>The result is that our computer generated sphere will have facets much like the 
facets on a diamond.</p>
<p><font color="#FF0000"><b>Divisions in the Sphere constructor</b></font></p>
<p>One of the overloaded constructors for the <b>Sphere</b> class in the Java 3D 
API has a parameter that Sun refers to as <b>divisions</b>.&nbsp; This parameter 
seems to specify the number of flat polygons that would be encountered in making 
one trip around the equator of the sphere.&nbsp; This is illustrated by the top 
two images in <a name="Figure_3"><a href="#Figure_3">Figure 3</a></a>. </p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1c.jpg" width="233" height="233"></td>
		<td>
		<img border="0" src="java1540a1d.jpg" width="233" height="233"></td>
	</tr>
		<tr>
		<td>
		<img border="0" src="java1540a1e.jpg" width="233" height="233"></td>
		<td>
		<img border="0" src="java1540a1f.jpg" width="233" height="233"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_3">Figure 3</a></b></pre></td>
	</tr>
</table>
<p><font color="#FF0000"><b>Silhouettes of a sphere</b></font></p>
<p>The upper-left image in <a href="#Figure_3">Figure 3</a> shows the silhouette of a <b>Sphere</b> object 
constructed with a value of 4 for divisions.&nbsp; Granted it doesn't look much 
like a sphere.&nbsp; It looks like a square instead.&nbsp; However, that is what 
you get if you draw a circle by using straight line segments to connect only 
four points on the circumference of a circle.</p>
<p>The silhouette in the upper right of <a href="#Figure_3">Figure 3</a> looks more like what we would 
expect to see for a sphere.&nbsp; This is what you get when you use straight 
line segments to connect eight equally spaced points on the circumference of the circle.&nbsp; 
It should be apparent that if I continue to increase the number of points on the 
circumference of the circle, the result will look more and more like a circle.</p>
<p><font color="#FF0000"><b>The <i>Facets</i> radio button</b></font></p>
<p>Returning now to <a href="#Figure_2">Figure 2</a>, the top radio button is labeled <b>Facets</b>.&nbsp; The text box immediately to the 
right of the radio button contains the value 50.0.&nbsp; That is the value that 
was used to draw the large sphere in <a href="#Figure_1">Figure 1</a>.&nbsp; In other words, during a trip 
around the equator of the large sphere in <a href="#Figure_1">Figure 1</a>, you would encounter 50 
flat 
spots.&nbsp; The two top images in <a href="#Figure_3">Figure 3</a> were produced with values of 4 and 8 
respectively for the number of facets.</p>
<p><font color="#FF0000"><b>How to adjust the number of facets</b></font></p>
<p>To adjust the number of facets, you first select the <b>Facets</b> radio button.&nbsp; 
This causes the label above the top slider to read:</p>
<p><pre><b>Facets on Surface of Large Sphere</b></pre></p>
<p>You then move the slider to indicate the number of facets that you want 
your sphere to have, reading the output in the text field to the right of the 
radio button.&nbsp; The scale on the slider ranges from 0 to 100.&nbsp; 
However, if you attempt to specify a value less than 4 with the slider, the 
number of facets is clamped to 4.</p>
<p><font color="#FF0000"><b>An example display that shows the facets</b></font></p>
<p>Now consider the bottom two images in <a href="#Figure_3">Figure 3</a>.&nbsp; These are the same two 
spheres shown as silhouettes in the top two images.&nbsp; However, the spheres 
in the bottom two images were not rendered as silhouettes.&nbsp; Rather, they 
were rendered in a three-dimensional form instead.</p>
<p><font color="#FF0000"><b>Vertices and polygons</b></font></p>
<p>Hopefully you can see some of the regularly-spaced points on the surface of 
the spheres <i>(commonly referred to as vertices)</i> as well as the connecting 
straight lines and the planar polygons that are formed by the vertices and the 
lines that connect them.&nbsp; It is these planar polygons that I refer to as 
facets.&nbsp; </p>
<p>Note, however, that even though the lower right sphere in <a href="#Figure_3">Figure 3</a> was 
created with a <b>Facet </b>value of 8, the sphere actually has more than eight 
actual facets.&nbsp; When creating a sphere, the value that is specified for <b>
Facets</b> in <a href="#Figure_2">Figure 2</a> is the number of planar polygons that you would encounter 
in one trip around the equator of the sphere.</p>
<blockquote>
	<p><i>(Once again, I see some visual artifacts in the images in <a href="#Figure_3">Figure 3</a> that were 
	caused by importing them into this HTML document.&nbsp; I don't know if you 
	will see them or not.&nbsp; However, they aren't in the original images so 
	if you compile and run the program, you should not see them.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>How to use the program</b></font></p>
<p>Now you basically know how to use the program.&nbsp; To 
specify the number of facets for the large sphere in <a href="#Figure_1">Figure 1</a>, select the 
radio button labeled <b>Facets</b> and then use the top slider to specify the number 
of facets that occur during one trip around the equator of the sphere.&nbsp; 
This same procedure is used to adjust all of the scene properties except that 
many of the scene properties have three property values instead of only one 
property value.</p>
<h3><a name="Shading_Model">The Shading Model</a></h3>
<p>Now that you know about the planar polygons <i>(facets)</i> that comprise the 
surface of the sphere, the next thing that you need to learn about is the 
shading model.&nbsp; In a nutshell, 
the shading model is used to determine the colors that will appear at the 
different points on each facet.</p>
<p><font color="#FF0000"><b>Two techniques for shading</b></font></p>
<p>Java 3D gives you two choices for determining those 
colors:</p>
<ul>
	<li><a href="http://en.wikipedia.org/wiki/Gouraud_shading">Gouraud</a> 
	shading</li>
	<li><a href="http://en.wikipedia.org/wiki/Flat_shading">Flat</a> shading</li>
</ul>
<p>I'm not going to attempt to explain the technical details of these two 
shading techniques.&nbsp; Rather, I will simply suggest that you click on the two 
links provided in the above list to read what <a href="http://wikipedia.org/">
Wikipedia</a> has to say about them.&nbsp; If you feel that you need more 
information on the topic after you read those explanations, go to
<a href="http://www.google.com/">Google</a> and search for the keywords.&nbsp; 
I'm confident that you will find more material on the topic than you will have the 
time to read.</p>
<p><font color="#FF0000"><b>Example of Gouraud and Flat shading</b></font></p>
<p>What I am going to do, however, is to show you an extreme example of the 
difference between the two shading techniques and show you how to select one or 
the other when you are running the program.</p>
<p>The image on the left in <a href="#Figure_4">Figure 4</a> was produced using <i>Gouraud</i> shading.&nbsp; 
The image on the right was produced by applying <i>Flat</i> shading to the same 3D 
<a name="Figure_4">sphere</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1g.jpg" width="233" height="233"></td>
		<td>
		<img border="0" src="java1540a1h.jpg" width="233" height="233"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_4">Figure 4</a></b></pre></td>
	</tr>
</table>
<blockquote>
	<p><i>(Note that I made some minor color adjustments to the rightmost image in <a href="#Figure_4">Figure 4</a> to cause the two dark brown polygons with the Flat shading 
	to be distinguishable from the black background.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Another example</b></font></p>
<p>I confess that I chose the example in <a href="#Figure_4">Figure 4</a> specifically to emphasize the 
difference between Gouraud and Flat shading.&nbsp; However, that is not the case 
for <a name="Figure_5"><a href="#Figure_5">Figure 5</a></a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1i.jpg" width="233" height="233"></td>
		<td>
		<img border="0" src="java1540a1j.jpg" width="233" height="233"></td>
	</tr>
	<tr>
	<td colspan="2" >
<pre><b><a href="#Figure_5">Figure 5</a></b></pre></td>
	</tr>
</table>
<p><a href="#Figure_5">Figure 5</a> shows two renderings of the same large sphere.&nbsp; This is simply a red 
sphere with a <b>Facets</b> value of 50 being illuminated by a directional-light 
source located somewhere above my right shoulder and aimed directly at the center of 
the large sphere.&nbsp; The image on the left was rendered using Gouraud shading and 
the image on the right was rendered using Flat shading.&nbsp; Even with this 
relatively large number of facets, the Flat shading approach causes the facets 
to be very visible on the large sphere.</p>

<p>
<p><font color="#FF0000"><b>Not a high quality shading technique</b></font></p>
<p>As you can see, Flat shading is probably not what you would want to use for 
high quality 3D representations of visual objects.&nbsp; However, depending on 
your hardware, it may be much faster to compute Flat shading than Gouraud 
shading, so you may need to use it on some objects for improved speed if speed 
is an issue in your 3D applications.</p>
<p><font color="#FF0000"><b>Switching between the two shading techniques</b></font></p>
<p>Once you have established the scene properties and your scene is visible in 
the format of <a href="#Figure_1">Figure 1</a>, all you need to do to switch between Gouraud 
shading and Flat shading with this program is to select the appropriate radio button at the bottom of the control panel 
shown in <a href="#Figure_2">Figure 2</a>.&nbsp; In a subsequent installment of 
this lesson, I will teach you how to write the Java code to switch between the 
two types of shading.</p>

<h3><a name="The_Small_Spheres">The Small Spheres</a></h3>
<p><a name="Figure_6"><a href="#Figure_6">Figure 6</a></a> gives us another look at the four small spheres.</p>

<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a1k.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_6">Figure 6</a></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Calibration spheres</b></font></p>
<p>I placed these spheres in the scene to serve a calibration function.&nbsp; 
Each sphere has fixed surface reflection properties <i>(except that they do 
switch between Gouraud shading and Flat shading in accordance with the selected 
shading button)</i>.&nbsp; 
As I add new light sources to the scene for the purpose of 
illuminating the large sphere shown in <a href="#Figure_1">Figure 1</a>, I can check to see how 
the small spheres are being illuminated by those same light sources.&nbsp; The 
results should be very predictable.</p>
<p><font color="#FF0000"><b><a name="Locations_of_the_spheres">Locations of the 
spheres</a></b></font></p>
<p>The large sphere in <a href="#Figure_1">Figure 1</a> is centered at the origin in the 
three-dimensional space having coordinates of x, y, and z.&nbsp; The x-axis is 
the horizontal axis with positive values to the right.&nbsp; The y-axis is the 
vertical axis with positive values going up the screen.&nbsp; The z-axis is 
perpendicular to the screen with positive values coming out of the screen toward 
the viewer.</p>
<p>The location coordinates for the four small spheres are given in
<a href="#Table_1">Table 1</a> later in this lesson.&nbsp; The red and blue spheres in <a href="#Figure_6">Figure 6</a> 
each have their centers on the z-plane.&nbsp; In 
other words, their z coordinate value is 0.0.&nbsp; A line drawn through their 
centers would lie on the z-plane and would go through the origin of the z-plane.&nbsp; 
However, as you can see, their x and y coordinates are not zero.&nbsp; Rather, 
the line connecting their centers would be at an angle of 45-degrees relative to 
the x-axis.</p>
<p>The locations of the white and green spheres is such that they lie on a tilted 
plane that goes through the origin and also goes through the line connecting the 
centers of the red and blue spheres.&nbsp; The white sphere is closest to the 
viewer <i>(positive z-coordinate value)</i> while the green sphere is further away from the viewer
<i>(negative z-coordinate value)</i>.&nbsp; If you were 
to view the four small spheres from a vantage point perpendicular to that plane, they would lie on 
the four corners of a square inscribed on that plane.</p>
<p><font color="#FF0000"><b>Location and nature of the light source</b></font></p>
<p>While the surface reflection properties and the locations of the four small 
spheres are fixed, the locations of light sources that can be used to illuminate 
them are not fixed.</p>
<p>The light source that is illuminating the four spheres in <a href="#Figure_6">Figure 6</a> is an 
invisible omnidirectional source of white light located at the origin in the 
three-dimensional space.&nbsp; This places the light source in the middle of the 
four spheres.&nbsp; As you can see, the appropriate portion of each of the 
spheres is illuminated for an omnidirectional-light source at that location.</p>
<p>I'm unaware of any source of light in the physical world that behaves this 
way.&nbsp; The light source itself is invisible, but the impact of that light 
source on the spheres is visible.</p>
<p><font color="#FF0000"><b><a name="A_heat_analogy">A heat analogy</a></b></font></p>
<p>This is sort of like having an omnidirectional source of <i>heat</i> 
at the origin that causes the spheres to glow in their own distinctive colors 
when they become warm.&nbsp; <i>(It would probably be possible to build a system 
in the physical world that behaves in this fashion.)</i></p>
<p>For the record, this light source is an object of the <b>PointLight</b> 
class, which I will discuss in more detail later.</p>
<p><font color="#FF0000"><b>The scene properties</b></font></p>
<p>The scene properties for the four small spheres are shown in
<a name="Table_1" href="#Table_1">Table 1</a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      &nbsp;</td>
      <td>
      <p align="center"><b>White</b></td>
      <td>
      <p align="center"><b>Red</b></td>
      <td>
      <p align="center"><b>Green</b></td>
      <td>
      <p align="center"><b>Blue</b></td>
    </tr>
    <tr>
      <td>
      <b>Facets</b></td>
      <td>
      50</td>
      <td>
      50</td>
      <td>
      50</td>
      <td>
      50</td>
    </tr>
    <tr>
      <td>
      <b>Shininess</b></td>
      <td>
      128</td>
      <td>
      128</td>
      <td>
      128</td>
      <td>
      128</td>
    </tr>
    <tr>
      <td>
      <b>Emissive Color</b></td>
      <td>
      0.1, 0.1, 0.1</td>
      <td>
      0.1, 0.1, 0.1</td>
      <td>
      0.1, 0.1, 0.1</td>
      <td>
      0.1, 0.1, 0.1</td>
    </tr>
    <tr>
      <td>
      <b>Ambient Color</b></td>
      <td>
      1.0, 1.0, 1.0</td>
      <td>
      1.0, 0.0, 0.0</td>
      <td>
      0.0, 1.0, 0.0</td>
      <td>
      0.0, 0.0, 1.0</td>
    </tr>
    <tr>
      <td>
      <b>Diffuse Color</b></td>
      <td>
      1.0, 1.0, 1.0</td>
      <td>
      1.0, 0.0, 0.0</td>
      <td>
      0.0, 1.0, 0.0</td>
      <td>
      0.0, 0.0, 1.0</td>
    </tr>
    <tr>
      <td>
      <b>Specular Color</b></td>
      <td>
      1.0, 1.0, 1.0</td>
      <td>
      1.0, 1.0, 1.0</td>
      <td>
      1.0, 1.0, 1.0</td>
      <td>
      1.0, 1.0, 1.0</td>
    </tr>
    <tr>
      <td>
      <b>Coordinates</b></td>
      <td>
      -0.5, -0.5, 0.5</td>
      <td>
      -0.5, 0.5, 0.0</td>
      <td>
      0.5, 0.5, -0.5</td>
      <td>
      0.5, -0.5, -0.0</td>
    </tr>
    <tr>
      <td colspan="5" >
      <b><a href="#Table_1">Table 1</a></b></td>

    </tr>
  </tbody>
</table>

</p>
<p>The column headers identify each of the spheres according to the dominant 
colors of the spheres in <a href="#Figure_6">Figure 6</a>.&nbsp; The row headers identify each of the 
scene properties in the same order as <a href="#Figure_2">Figure 2</a> with the addition of the location 
coordinates of the spheres in the bottom row.</p>
<p><font color="#FF0000"><b>Color information</b></font></p>
<p>For the rows that contain color <i>(surface reflection)</i> information, the 
three values in each cell correspond to the values for red, green, and blue 
respectively.</p>
<blockquote>
	<p><i>(In Java 3D, color values are given in the range from 0.0 to 1.0 as 
	opposed to the possibly more familiar 8-bit integer range from 0 to 255.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The White sphere</b></font></p>
<p>For example, the information in the <i>Diffuse Color</i> cell for the <i>
White</i> sphere indicates that this sphere will reflect <i>red</i>, <i>green</i>, 
and <i>blue</i> light from a diffuse light source equally well.</p>
<ul>
	<li>red = 1.0</li>
	<li>green = 1.0</li>
	<li>blue = 1.0</li>
</ul>
<p>Therefore, when this sphere is illuminated by a diffuse source of white 
light, it will appear to be white or gray depending on the intensity of the 
light.</p>
<p><font color="#FF0000"><b>The Red sphere</b></font></p>
<p>On the other hand, the information in the <i>Diffuse Color</i> cell for the
<i>Red</i> sphere indicates that it will reflect <i>red</i> light very well, but 
won't reflect <i>green</i> or <i>blue</i> light at all.</p>
<ul>
	<li>red = 1.0</li>
	<li>green = 0.0</li>
	<li>blue = 0.0</li>
</ul>
<p>Therefore, when this sphere is illuminated by a diffuse source of white 
light, it will appear to be some shade of red depending on the intensity of the 
light.&nbsp; The same is true if it is illuminated by a diffuse source of red 
light.</p>
<p><font color="#FF0000"><b>Location coordinate information</b></font></p>
<p>For the bottom row containing location coordinate information, the values in 
each cell correspond to the x, y, and z coordinates values respectively.&nbsp; 
These coordinates specify the locations of the four small spheres that I 
attempted to describe verbally <a href="#Locations_of_the_spheres">earlier</a>.</p>
<p><font color="#FF0000"><b>Similarities and differences between the small 
spheres</b></font></p>
<p>Much of the information in <a href="#Table_1">Table 1</a> will mean more to 
you as we proceed through an explanation of the various scene properties.&nbsp; 
For now, suffice it to say that many of the values are the same among the four 
spheres.&nbsp; The major differences between the small spheres are the ambient color, 
the diffuse color, and the location coordinates.&nbsp; The emissive color and 
the specular color of all four spheres are the same, as are the number of facets 
and the shininess.</p>
<h3><a name="Emissive_Color">Emissive Color</a></h3><p>That brings us to the 
scene property that is probably the easiest to deal with:&nbsp; <i>Emissive 
Color</i>.</p>
<p>Here is part of what
<a href="http://www.devmaster.net/wiki/Software_Rasterization_School,_Part_5:_Lighting">
Wikipedia</a> has to say about emissive light <i>(not necessarily with respect 
to the Java 3D API)</i>:</p>
<blockquote>
	<p><i>&quot;The materials also specify &quot;emissive light&quot; for the polygons. The 
	emissive light is light that the polygon itself emits (for example your 
	monitor). In case the polygon is emissively lit you can think of it as a 
	visible light source, which is NOT emitting light to the surrounding 
	objects!</i>&quot;</p>
</blockquote>
<p>Here is some of what
<a href="http://java.sun.com/developer/onlineTraining/java3d/j3d_tutorial_ch6.pdf">
Bouvier</a> has to say about emissive color, specifically with regard to the 
Java 3D API:</p>
<blockquote>
	<p><i>&quot;The Material object allows the specification of an emissive color. 
	This can be used to create the effect of a<br>
	glow-in-the-dark object. Having an emissive color does not make the visual 
	object a light source; <a name="it_will_not">it will not</a><br>
	illuminate other visual objects.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>A stand-alone scene property</b></font></p>
<p>The emissive color scene property is easy to deal with because, unlike many 
of the other scene properties, it stands completely on its own and doesn't 
require interaction with other scene properties.&nbsp; As described above, a 
visual object can emit its own light.&nbsp; This is controlled by the emissive 
color scene property shown in <a href="#Figure_2">Figure 2</a>.&nbsp; When a visual object emits its 
own light, it does not illuminate adjacent objects.</p>
<p><font color="#FF0000"><b>Unlike the physical world</b></font></p>
<p>Once again, I am unaware of any source of light in the physical world that 
behaves in this manner.&nbsp; Most illuminated objects that I am aware of will 
cause adjacent objects to also become illuminated to some extent.</p>
<p><font color="#FF0000"><b>Color and intensity is variable</b></font></p>
<p>In any event, given that restriction, the emissive color scene property can 
be used to cause an object to be illuminated in any color at any of the 
allowable intensity levels.&nbsp; This is shown in <a href="#Figure_7">Figure 7</a> where the large 
sphere is illuminated with four different colors and intensity levels by 
emitting its own <a name="Figure_7">light</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1m.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1n.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a1o.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1p.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_7">Figure 7</a></b></pre></td></tr></table>
<p><font color="#FF0000"><b>Small spheres are not illuminated by the large 
sphere</b></font></p>
<p>Note that the small spheres in the scene in <a href="#Figure_7">Figure 7</a> are not illuminated by 
the light being emitted by the large sphere.&nbsp; However, if you look very 
carefully, you may be able to see that each of the small spheres also emits a 
small amount of light on its own.&nbsp; This is indicated by the values in the 
Emissive Color row of <a href="#Table_1">Table 1</a>.</p>
<p><font color="#FF0000"><b>No shading, Gouraud or otherwise</b></font></p><p>
Also note that even though the visual objects in <a href="#Figure_7">Figure 7</a> are spheres, there is 
no shading to create an optical illusion causing them to look like spheres.&nbsp; 
Rather, they look more like colored disks.&nbsp; Visual objects that are 
illuminated by emitting their own light are not shaded in the Java 3D API.&nbsp; 
Rather, the entire surface of the object is illuminated uniformly.</p>
<p><font color="#FF0000"><b>How to use emissive light</b></font></p>
<p>To illuminate the large sphere by causing it to emit its own light, select 
the Emissive Color radio button in <a href="#Figure_2">Figure 2</a>.&nbsp; Then adjust the three sliders 
to cause the color mix and the intensity of the illumination to be what you 
need.</p>
<p>The color values that you specify by adjusting the sliders will be displayed 
in the three text fields next to the radio button in real time as you adjust the 
sliders.&nbsp; Also, the color and intensity of the large sphere in the display 
will change in real time as you adjust the sliders.</p><h3><a name="Ambient_Color_and_the_AmbientLight_Class">
Ambient Reflection and the 
AmbientLight Class</a></h3><p>Things are about to get a little more complicated.&nbsp; Up to 
now, just about everything that we have done has been 
done on a standalone basis.&nbsp; However, from this point forward, you will 
have to think in terms of the reaction of a surface having specified reflection 
properties to a light source having its own set of light-radiation properties.</p>
<p><font color="#FF0000"><b>Light sources and reflections</b></font></p>
<p>We saw <a href="#Bouvier_light">earlier</a> what Bouvier has to say about the 
three kinds of real-world lighting reflections, and the simulation of those 
three kinds of reflections in the lighting model of the Java 3D API:</p>
<ul>
	<li>Ambient reflections</li>
	<li>Diffuse reflections</li>
	<li>Specular reflections</li>
</ul>
<p>At this point, we are interested in ambient reflections only.&nbsp; 
We will take up diffuse and specular reflections later in the lesson.</p>
<p><font color="#FF0000"><b>A link between ambient color and ambient light </b>
</font></p>
<p><a href="#Figure_2">Figure 2</a> contains the following two radio buttons, which 
are the main topic of this portion of the lesson:</p>
<ul>
	<li>Ambient Color</li>
	<li>AmbientLight</li>
</ul>
<p>The <i>Ambient Color</i> radio button makes it possible for you to control a 
set of surface reflection properties that will cause the large sphere to react only to light 
radiated 
from an object constructed from the <b>AmbientLight</b> class.</p>
<p>The <i>AmbientLight</i> radio button makes it possible for you to control a 
set of properties belonging to an object constructed from the <b>AmbientLight</b> 
class.</p>
<p><font color="#FF0000"><b>What is ambient light?</b></font></p>
<p>In the Java 3D API, ambient light is light that arrives uniformly from all 
directions.&nbsp; All visual objects in a scene that is illuminated by ambient 
light will be uniformly illuminated according to their surface reflection 
properties for ambient light.</p>
<p><font color="#FF0000"><b>A real-world example</b></font></p>
<p>As a real-world example, a sphere illuminated by ambient light is similar to what you would 
experience if you were to hang a basketball from a clothes line in an open field 
on a very cloudy day.&nbsp; To a large extent, the basketball would be uniformly 
illuminated over its entire surface <i>(although the top may be a little 
brighter than the bottom)</i>.</p>
<p>Although the sun would have been the original <i>(highly directional)</i> 
source of the light, that light would have been so heavily filtered, scattered, 
and reflected by the cloud layer, the ground, and the other physical objects in the 
region that the light would appear to come from all directions 
uniformly.&nbsp; As a result, there would be no shadows and the entire 
surface of the basketball would be <i>almost</i> uniformly illuminated.&nbsp; Light 
sources constructed from the <b>AmbientLight</b> class in the Java 3D API 
simulate this kind of light with the illumination being completely uniform over 
the surface of illuminated objects.</p>
<p><b><font color="#FF0000">How does ambient color <i>(reflection)</i></font></b>
<b><font color="#FF0000">fit into this picture?</font></b></p>
<p>Ambient surface reflection properties and light radiated from <b>AmbientLight</b> 
objects are uniquely tied together.&nbsp; Both must exist with non-zero states 
for either to have an impact on the scene.&nbsp; If there is no ambient light 
illuminating the scene, changing the <b>AmbientLight</b> surface 
reflection properties of a visual object will have no impact on the scene.&nbsp; Conversely, if 
there are no visual objects in the scene having non-zero values for the ambient 
surface reflection properties, even high intensity ambient light 
sources will have no impact on the scene.</p>
<p><font color="#FF0000"><b>Examples of ambient light</b></font></p>
<p>Four examples of the interaction between ambient surface reflection 
properties and an ambient light source are shown in <a name="Figure_8"><a href="#Figure_8">Figure 8</a></a>.</p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1q.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1r.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a1s.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1t.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_8">Figure 8</a></b></pre></td></tr></table><p><font color="#FF0000"><b>The 
ambient light source</b></font></p>
<p>For all four images shown in <a href="#Figure_8">Figure 8</a>, the color and intensity properties of 
the ambient light source <a name="colored_light">were</a>:</p>
<ul>
	<li>red = 0.50</li>
	<li>green = 0.75</li>
	<li>blue = 1.00</li>
</ul>
<p>This is colored light.&nbsp; It is not <i>white light</i> because there are 
different intensity levels from each of the primary colors.</p>
<p><font color="#FF0000"><b>The large sphere is not initially visible</b></font></p>
<p>The large sphere is not visible in the upper-left image in <a href="#Figure_8">Figure 8</a>.&nbsp; 
This is because all three ambient reflection properties were set to 0 for 
the large sphere for this image.&nbsp; However, the four small spheres are visible.&nbsp; This 
is because each of the small spheres has non-zero values for its ambient reflection properties as shown in the <i>Ambient Color</i> row of <a href="#Table_1">Table 1</a>.</p>
<p><font color="#FF0000"><b>Reflection color properties react to light 
source colors</b></font></p>
<p>In order for a visual object to be visible when subjected to any light source 
in the Java 3D API, the reflection color properties of the object must contain 
color components that are also contained in the light.&nbsp; For example, a 
visual object having only red reflection properties subjected to a light source 
having only green or blue color components will appear to be black.</p>
<p>When there is a color match between a color component in the surface 
reflection properties and a color component in the light source, the numeric 
values of the matching color components are used to determine the intensity 
of that color component in the resulting overall color of the visual object.</p>
<p><font color="#FF0000"><b>Ambient reflection properties react to ambient light 
source</b></font></p>
<p>The <b>AmbientLight</b> <a href="#colored_light">color values</a> for the light source combined with the 
ambient reflection <a href="#Table_1">properties</a> for each of the small spheres resulted in 
the colors shown for the small spheres in each of the images in <a href="#Figure_8">Figure 8</a>.</p>
<p>For example, the small sphere in the lower left of each image doesn't appear 
to be white as was the case in <a href="#Figure_1">Figure 1</a>.&nbsp; Rather, even though the 
ambient reflection properties of this sphere contain the maximum possible values for 
red, green, and blue, <i>(and the sphere would appear to be white when subjected 
to white light)</i> in this case it was subjected to <a href="#colored_light">
colored light</a> and therefore appears to be more blue than white.</p>
<p><font color="#FF0000"><b>Add a red reflection property to the large sphere</b></font></p>
<p>The red ambient reflection property value for the large sphere was increased 
from 0.0 to 1.0 for the upper-right image in <a href="#Figure_8">Figure 8</a>.&nbsp; This caused the large 
sphere to become visible with a somewhat subdued red color.</p>
<blockquote>
	<p><i>(Even though the value of the red reflection property for the large 
	sphere was increased to its maximum possible value, the contribution of 
	<a href="#colored_light">red 
	light</a> in the source was only at half its maximum value, resulting in a red 
	color with subdued intensity.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Add some green and blue reflection capability</b></font></p>
<p>For the lower-left image in <a href="#Figure_8">Figure 8</a>, the green ambient reflection property 
value for the large sphere was increased from 0.0 to 0.75 producing the olive 
drab color shown.</p>
<p>For the lower-right image, the blue ambient reflection property value for the 
large sphere was increased from 0.0 to 0.5, producing the gray color shown.</p>
<p><font color="#FF0000"><b>Reversed property value order</b></font></p>
<p>After increasing the ambient reflection property values for the large sphere 
as described above, 
the value order of the ambient reflection property values for the large sphere 
was exactly the reverse of the value order of the ambient color property 
values for the light source as shown below:</p>
<ul>
	<li>Sphere:&nbsp; red = 1.0, green = 0.75, blue = 0.5</li>
	<li>Source:&nbsp; red = 0.5, green = 0.75, blue = 1.0</li>
</ul>
<p>This resulted in the large sphere appearing to be colored gray in the 
lower-right image of <a href="#Figure_8">Figure 8</a>.&nbsp; The 
color gray suggests that the color property values from the light source were 
combined with the color property values from the large sphere in such a way as 
to produce nearly equal contributions of each of the primary colors in the final color.&nbsp; 
So far, I have been unable to find the
<a href="http://java.sun.com/products/java-media/3D/forDevelopers/j3dguide/j3dTOC.doc.html">
specifications</a> as to how color values in the reflection properties are 
combined with color values in the light source.&nbsp; However, I suspect that 
they are simply multiplied together.&nbsp; If so, that would result in a final 
overall color for the large sphere with the following color component values:</p>
<p>red = 0.5, green = 0.56, blue = 0.5</p>
<p>As suggested above, these color component values are nearly equal, which 
would result in a gray color.</p>
<p>This further demonstrates that the color of a visual object depends on a 
combination of the reflective color properties of the object and the radiated 
color properties of the light source.</p>
<p><font color="#FF0000"><b>No shading</b></font></p>
<p>Another important aspect of ambient light is also illustrated by <a href="#Figure_8">Figure 8</a>.&nbsp; 
In particular, there is no shading with ambient light.&nbsp; This is because the 
ambient light is assumed to originate uniformly from all directions 
simultaneously so that the entire surface of the visual object is assumed to be 
uniformly illuminated.</p>
<p><font color="#FF0000"><b>Doesn't contribute to the 3D optical illusion</b></font></p>
<p>Because of the lack of shading, neither emissive color nor ambient color 
contribute very much to the optical illusion that is required to cause images 
displayed on a two-dimensional screen to appear to be three dimensional.&nbsp; 
For that, we need some form of directional light, and that is where we are going 
next.</p>
<h3><a name="Combinations_of_Light_Source_and_Surface_Reflection_Properties">
More Combinations of Light Source and Surface Reflection Properties</a></h3>
<p>Referring back to <a href="#Figure_2">Figure 2</a>, we have two more kinds of reflective properties 
to consider:</p>
<ul>
	<li>Diffuse Color</li>
	<li>Specular Color</li>
</ul>
<p>We also have three more kinds of light sources to consider.</p>
<ul>
	<li>DirectionalLight <i>(parallel rays)</i></li>
	<li>PointLight <i>(omnidirectional rays)</i></li>
	<li>SpotLight <i>(cone-shaped rays )</i></li>
</ul>
<p>In addition, we have a <i>shininess</i> property that I have been ignoring up 
to this point.</p>
<p><font color="#FF0000"><b>All possible combinations</b></font></p>
<p>Any of the three kinds of light sources in the above list will react with either of the two kinds of 
reflective properties in the above list.&nbsp; Furthermore, the <i>shininess</i> property comes into play any 
time specular reflection is involved.&nbsp; This gives us six combinations of 
sources and properties that we need to understand.&nbsp; We also need to 
understand how and when shininess impacts the results and to understand the 
existence or lack of shadows.&nbsp; This leaves us with the 
following major topics to cover in the remainder of this installment of the lesson:</p>
	<ul>
		<li>Diffuse Reflection and the DirectionalLight Class </li>
		<li>The Shininess Property</li>
		<li>Specular Reflection and the DirectionalLight Class</li>
		<li>Shadows</li>
		<li>Diffuse Reflection and the PointLight Class</li>
		<li>Specular Reflection and the PointLight Class</li>
		<li>Diffuse Reflection and the SpotLight Class</li>
		<li>Specular Reflection and the PointLight Class</li></ul>
<h3><a name="Diffuse_Color_and_the_DirectionalLight_Class">Diffuse Reflection and the 
DirectionalLight Class</a></h3>
<p><font color="#FF0000"><b>What is diffuse reflection?</b></font></p>
<p>Here is part of what
<a href="http://en.wikipedia.org/wiki/Diffuse_reflection">Wikipedia</a> has to 
say about diffuse reflection:</p>
<blockquote>
	<p><i>&quot;<b>Diffuse reflection</b> is the
	reflection of <a title="Light" href="http://en.wikipedia.org/wiki/Light">
	light</a> from an uneven or granular surface such that an incident ray is 
	seemingly reflected at a number of angles. It is the complement to
	<a title="Specular reflection" href="http://en.wikipedia.org/wiki/Specular_reflection">
	specular reflection</a>. If a surface is completely nonspecular, the 
	reflected light will be evenly spread over the
	<a title="Sphere" href="http://en.wikipedia.org/wiki/Sphere">hemisphere</a> 
	surrounding the surface (2<a title="Pi" href="http://en.wikipedia.org/wiki/Pi">&#960;</a>
	<a title="Steradian" href="http://en.wikipedia.org/wiki/Steradian">
	steradians</a>).</i></p>
	<p><i>The most familiar example of the distinction between specular and 
	diffuse reflection would be
	matte and <a title="Glossy" href="http://en.wikipedia.org/wiki/Glossy">
	glossy</a> <a title="Paint" href="http://en.wikipedia.org/wiki/Paint">paints</a> 
	as used in home painting. Matte paints have a higher proportion of diffuse 
	reflection, while gloss paints have a greater part of specular reflection.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>What is a directional-light source?</b></font></p>
<p>Bouvier has this to say about light radiated from a <b>DirectionalLight</b> 
object in Java 3D:</p>
<blockquote>
	<p><i>&quot;A DirectionalLight source approximates very distant light sources 
	such as the sun. Unlike AmbientLight sources, DirectionalLight sources 
	provide light shining in one direction only.&nbsp; For objects lit with a 
	DirectionalLight source, the Light vector is constant. ... Since all light 
	vectors from a DirectionalLight source are parallel, the light does not 
	attenuate.&nbsp; In other words, the intensity of a DirectionalLight source 
	does not vary by the distance between the visual object and the 
	DirectionalLight source.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Assumptions regarding a DirectionalLight source</b></font></p>
<p>I will paraphrase much of what I have learned about the <b>DirectionalLight</b> 
class.&nbsp; An object of the class is intended to simulate 
light sources that satisfy the following assumptions:</p>
<ul>
	<li>The light source is assumed to be very far away, such as the sun for 
	example.</li>
	<li>All the light rays travel in parallel paths in the same direction.</li>
	<li>The light wave has a flat wavefront that is at least as wide as the 
	scene that is being illuminated by the directional-light source.</li>
	<li>There is no attenuation of light energy regardless of the distance to 
	the light source.</li>
</ul>
<p><font color="#FF0000"><b>Cannot directly control the actual location of a 
directional-light source</b></font></p>
<p>As with the other kinds of light sources, you can control the relative 
intensity of each of the color components radiated by a directional-light 
source.</p>
<p>However, unlike point-light and spotlight sources, you cannot control 
the actual location of the directional-light source.&nbsp; The location of 
the light source is assumed to be somewhere far outside the 3D space enclosed by 
the scene.</p>
<p><font color="#FF0000"><b>Can control the direction to the directional-light 
source</b></font></p>
<p>However, you can control the direction of the light being radiated by the 
directional-light source.&nbsp; Since all light radiated by a directional-light source is parallel, this means that you can also control 
the direction to the directional-light source.</p>
<p><font color="#FF0000"><b>Controlling the direction of the light</b></font></p>
<p>To control the direction of the light being radiated from a directional-light source, you define a 3D
<a href="http://mathworld.wolfram.com/Vector.html">vector</a> with its <i>
<a href="http://mathworld.wolfram.com/Vector.html">tail</a></i> at the origin in 
the 3D space.&nbsp; You define the vector by providing the coordinates of the <i>
<a href="http://mathworld.wolfram.com/Vector.html">head</a></i> of the vector.&nbsp; 
The direction of the light is then assumed to be parallel to the direction of 
that vector.&nbsp; To change the direction of the light, you change one or more 
coordinate values that specify the location of the head of the vector.</p>
<p><font color="#FF0000"><b>A lever analogy</b></font></p>
<p>In effect, the source is located on the end of a very long lever that goes 
through and pivots at the origin in 3D space.&nbsp; The direction of the light 
is parallel to the long dimension of the lever.</p>
<p>Your vector can be thought of as representing a very short segment of that 
lever 
as it emerges from 
the origin on the opposite side of the origin from the directional-light source.&nbsp; You can 
rotate your vector in 3D space by changing the coordinates of the head of the 
vector.&nbsp; This has the effect of causing the other 
end of the lever to rotate in the reverse direction in 3D space.&nbsp; This, in 
turn causes the location of the 
source on the end of the lever to move.</p>
<p>You can think of this as a 3D lever with 
the length on one side of the fulcrum <i>(pivot point)</i> being much longer than the length on the 
other side of the fulcrum.&nbsp; When one end goes down, the other end must go 
up, and vice versa.</p>
<p><font color="#FF0000"><b>Behind, up, and to the right</b></font></p>
<p>For example, if you want to cause the directional-light source to be up to the right and 
behind the viewer, you cause the vector to point down to the left and into the 
screen.&nbsp; This can be accomplished by using the following coordinate 
values for the head of the vector:</p>
<ul>
	<li>x = -1.0</li>
	<li>y = -1.0</li>
	<li>z = -1.0</li>
</ul>
<p>These are the vector coordinates that were used along with a 
directional-light source to illuminate the scene in <a href="#Figure_1">Figure 1</a>.</p>
<p><font color="#FF0000"><b>The light source is never visible</b></font></p>
<p>As was the case in <a href="#Figure_6">Figure 6</a> where the light source was located between the 
small spheres, the light source itself is never visible in Java 
3D.&nbsp; Rather, light sources in Java 3D appear to radiate invisible light that somehow 
gets magically converted into visible light by the visual objects on which the 
invisible light impinges.&nbsp; <i>(See my earlier example in the section entitled
<a href="#A_heat_analogy">A heat analogy</a>.)</i></p>
<p>For example, if you want to create an image of a table lamp illuminating a 
scene, you can put a <b>PointLight</b> object at the location of the lamp to 
illuminate the scene, but you then need to make certain that the lamp itself is 
illuminated.&nbsp; You might consider causing the lamp to have emissive color so 
that it will illuminate itself.</p>
<p><font color="#FF0000"><b>The view from space</b></font></p>
<p>The large sphere in the upper-left image in <a href="#Figure_9">Figure 9</a> shows what 
an astronaut might see as her capsule in a stationary orbit above the Earth 
emerges from the dark side of the <a name="Figure_9">Earth</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a1u.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1v.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a1w.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a1x.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_9">Figure 9</a></b></pre></td></tr></table>
<p>This occurs as the Earth <i>(and the capsule)</i> rotates causing the sun to 
emerge from behind the earth.&nbsp; <i>(The four small spheres 
represent space stations that are also in stationary orbits above the Earth.)</i></p>

<p><font color="#FF0000"><b>The sun 
is behind the Earth</b></font></p>
<p>In this image, the directional-light source <i>(the sun)</i> is behind the 
large sphere <i>(the Earth)</i> and is far outside the scene to the lower left.&nbsp; 
The direction of the light is roughly toward 
the astronaut's right shoulder.&nbsp; The coordinates of the direction vector 
for this image are:</p>
<ul>
	<li>x = 1.5</li>
	<li>y = 1.5</li>
	<li>z = 1.5</li>
</ul>
<p><font color="#FF0000"><b>The Earth continues to rotate</b></font></p>
<p>As the Earth continues to rotate, the sun continues to swing around the Earth 
as shown in the upper-right image in 
<a href="#Figure_9">Figure 9</a>.&nbsp; This exposes a much greater portion of the Earth to sunlight.&nbsp; 
In this case, the light direction is parallel to the z-plane shining from the 
lower left towards the upper right.</p>
<p>The coordinates of the direction vector for this case are:</p>
<ul>
	<li>x = 1.5</li>
	<li>y = 1.5</li>
	<li>z = 0.0</li>
</ul>
<p><font color="#FF0000"><b>The sun is behind the astronaut</b></font></p>
<p>In the lower-left image in <a href="#Figure_9">Figure 9</a>, the sun has swung further around 
the Earth to the point that the astronaut is directly between the sun and the 
Earth and is facing the Earth.&nbsp; In other words, the astronaut is facing the 
Earth with the sun directly behind her back.&nbsp; The light direction is 
perpendicular to the z-plane going into the screen.&nbsp; For this case, the 
coordinates of the direction vector are:</p>
<ul>
	<li>x = 0.0</li>
	<li>y = 0.0</li>
	<li>z = -1.5</li>
</ul>
<p><font color="#FF0000"><b>Off into the sunset</b></font></p>
<p>In the lower right of <a href="#Figure_9">Figure 9</a>, the sun has progressed exactly half way 
around the Earth relative to the upper-right image.&nbsp; In a short while, the 
sun will go behind the Earth again.&nbsp; In 
this case, the light direction is once again parallel to the z-plane shining 
from the upper right towards the lower left.&nbsp; The coordinates for the direction 
vector for this case are:</p>
<ul>
	<li>x = -1.5</li>
	<li>y = -1.5</li>
	<li>z = 0.0</li>
</ul>
<h3><a name="The_Shininess_Property">The Shininess Property</a></h3>
<p>I will introduce this topic by quoting Bouvier:</p>
<blockquote>
	<p><i>&quot;The <b>Material</b> object specifies ambient, diffuse, specular, and 
	emissive colors and a shininess value.&nbsp; Each of the first three colors 
	is used in the lighting model to calculate the corresponding reflection. 
	... The shininess value is only used in calculating specular reflections. 
	... The shininess value controls the spread range of viewing angle for which 
	a specular reflection can be seen.&nbsp; <a name="Higher_shininess_values">Higher shininess values</a> result in 
	smaller specular reflections.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Specifying the shininess property value</b></font></p>
<p>The value for the shininess property is specified in this program by selecting the <b>
Shininess</b> radio button in <a href="#Figure_2">Figure 2</a> and adjusting the top slider.&nbsp; When 
you select the radio button, the label above the top slider changes to read <i>
&quot;Shininess of Surface of Large Sphere.&quot;</i>&nbsp; The adjustment range for the 
slider is set to show 0 as the minimum and 128 as the maximum.</p>
<p><font color="#FF0000"><b>The setShininess method</b></font></p>
<p>Here is some of what Sun has to say about the <b>setShininess</b> method of 
the <b>Material</b> class:</p>
<blockquote>
	<p><i>&quot;Sets this material's shininess. This specifies a material specular 
	scattering exponent, or shininess. It takes a floating point number in the 
	range [1.0, 128.0] with 1.0 being not shiny and 128.0 being very shiny. 
	Values outside this range are clamped.&quot;</i></p>
</blockquote>
<p>Therefore, if you adjust the slider to a value between 0 and 1, the value 
will be automatically clamped at 1.0 when the <b>setShininess</b> method is 
called to set the shininess property value.</p>
<p>I will discuss the shininess property in more detail in the next section.</p>
<h3><a name="Specular_Color_and_the_DirectionalLight_Class">Specular Reflection and 
the DirectionalLight Class</a></h3>
<p><font color="#FF0000"><b>What is specular reflection?</b></font></p>
<p>One good way to understand specular reflection is to contrast it with diffuse 
reflection.&nbsp; Here is part of what
<a href="http://en.wikipedia.org/wiki/Specular_reflection">Wikipedia</a> has to 
say on the topic:</p>
<blockquote>
	<p><i>&quot;<b>Specular reflection</b> is the perfect,
	<a title="Mirror" href="http://en.wikipedia.org/wiki/Mirror">mirror</a>-like
	<a title="Reflection (physics)" href="http://en.wikipedia.org/wiki/Reflection_(physics%2529">
	reflection</a> of light (or sometimes other kinds of
	<a title="Wave" href="http://en.wikipedia.org/wiki/Wave">wave</a>) from a 
	surface, in which light from a single incoming direction is reflected into a 
	single outgoing direction. Such behaviour is described by the <b>law of 
	reflection</b>, which states that the direction of outgoing reflected light 
	and the direction of incoming light make the same angle with respect to the
	<a title="Surface normal" href="http://en.wikipedia.org/wiki/Surface_normal">
	surface normal</a>; this is commonly stated as </i><span class="texhtml"><i>
	&#952;</i><sub><i>i</i></sub><i> = &#952;</i><sub><i>r</i></sub></span><i>.</i></p>
	<p><i>This is in contrast to
	<a title="Diffuse reflection" href="http://en.wikipedia.org/wiki/Diffuse_reflection">
	diffuse reflection</a>, where incoming light is reflected in a broad range 
	of directions. The most familiar example of the distinction between specular 
	and diffuse reflection would be
	matte and <a title="Glossy" href="http://en.wikipedia.org/wiki/Glossy">
	glossy</a> <a title="Paint" href="http://en.wikipedia.org/wiki/Paint">paints</a>. 
	While both exhibit a combination of specular and diffuse reflection, matte 
	paints have a higher proportion of diffuse reflection and glossy paints have 
	a greater proportion of specular reflection. Very highly polished surfaces, 
	such as high quality mirrors, can exhibit almost perfect specular 
	reflection.&quot;</i></p>
</blockquote>
<p><font color="#FF0000"><b>Examples of specular reflection</b></font></p>
<p>Excellent examples of specular reflection are exhibited by the white spots on 
the red, green, and blue spheres in <a href="#Figure_1">Figure 1</a>.&nbsp; Those same spheres also 
exhibit specular reflection in <a href="#Figure_3">Figure 3</a>, <a href="#Figure_6">Figure 6</a>, and <a href="#Figure_9">Figure 9</a>.&nbsp; Because 
of the shading involved, even the white sphere in <a href="#Figure_6">Figure 6</a> exhibits specular 
reflection.</p>
<p><font color="#FF0000"><b>Shininess and specular color property values</b></font></p>
<p><a href="#Table_1">Table 1</a> shows the shininess and specular property values that are 
hard-coded into the program for the small spheres.&nbsp; The value of 128 for 
shininess specifies that the size of the specular reflection is to be as small 
as possible.&nbsp; The color values for specular color specify that the specular 
reflection will be white for all four of the small spheres, regardless of their 
diffuse color or ambient color.</p>
<p><font color="#FF0000"><b>Specular reflections on the large sphere</b></font></p>
<p><a href="#Figure_10">Figure 10</a> shows the result of varying the shininess property value on the 
large <a name="Figure_10">sphere</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a2a.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2b.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a2c.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2d.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_10">Figure 10</a></b></pre></td></tr></table><p><font color="#FF0000"><b>The 
scene property values</b></font></p>
<p>The important scene property 
values for the large sphere for the images shown in <a href="#Figure_10">Figure 10</a> are provided in 
<a name="Table_2"><a href="#Table_2">Table 2</a></a>.</p>
<p>
<table border="1" cols="1" width="306" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="159">
      <p align="center"><b>Property</b></td>
      <td width="131">
      <p align="center"><b>Property Value</b></td></tr>
    <tr>
      <td width="159">
      Facets</td>
      <td width="131">
      100</td></tr>
    <tr>
      <td width="159">
      Shininess</td>
      <td width="131">
      16, 32, 64, 128</td></tr>
    <tr>
      <td width="159">
      Diffuse Color</td>
      <td width="131">
      1.0, 0.0, 0.0</td></tr>
    <tr>
      <td width="159">
      Specular Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      Directional Light Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      Directional Light Vector</td>
      <td width="131">
      -1.0, -1.0, -1.0</td></tr>
    <tr>
      <td colspan="2" >
      <b><a href="#Table_2">Table 2</a></b></td>
    </tr>
</tr></tbody></table></p><p>As you can see from <a href="#Table_2">Table 2</a>, the large sphere is 
very smooth with a value of 100 for Facets.&nbsp; The diffuse color is red and 
the specular color is white.&nbsp; The scene is illuminated by white 
directional-light source with the direction of the light being toward the screen, down, and to the 
left.</p>
<p><font color="#FF0000"><b>Varying values for the shininess property</b></font></p>
<p>The upper-left image has a shininess property value of 16.&nbsp; Starting with 
the upper-left image and going from left to right, top to bottom, the value of the 
shininess property is doubled for each image.&nbsp; This results in the maximum 
possible shininess value of 128 for the lower-right image.</p>
<p>As described <a href="#Higher_shininess_values">earlier</a>, the size of the 
specular reflection decreases as the value of the shininess property value 
increases.</p>
<h3><a name="Shadows">Shadows</a></h3>
<p>One of the characteristics of the Java 3D API that detracts somewhat from the realism 
of 3D scenes is that visual objects don't cast shadows.&nbsp; This is 
illustrated by the scene in <a name="Figure_11"><a href="#Figure_11">Figure 11</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2k.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_11">Figure 11</a></b></pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>The scene properties</b></font></p>
<p>The important scene properties for <a href="#Figure_11">Figure 11</a> are shown in <a name="Table_3"><a href="#Table_3">Table 3</a></a>.</p>
<p>
<table border="1" cols="1" width="306" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="159">
      <p align="center"><b>Property</b></td>
      <td width="131">
      <p align="center"><b>Property Value</b></td></tr>
    <tr>
      <td width="159">
      Facets</td>
      <td width="131">
      100</td></tr>
    <tr>
      <td width="159">
      Shininess</td>
      <td width="131">
      64.0</td></tr>
    <tr>
      <td width="159">
      Diffuse Color</td>
      <td width="131">
      0.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      Directional Light Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td>
	</tr>
    <tr>
      <td width="159">
      Directional Light Vector</td>
      <td width="131">
      -0.5, -0.5, 0.0</td></tr>
    <tr>
      <td colspan="2" >
      <b><a href="#Table_3">Table 3</a></b></td>
    </tr>
</tr></tbody></table></p><p><font color="#FF0000"><b>Illumination of the scene</b></font></p>
<p>The scene in <a href="#Figure_11">Figure 11</a> is illuminated exclusively by a directional-light 
source located far away, down, and to the right.&nbsp; The vector for the 
directional-light source is focused on the center of the red sphere.</p>
<p><font color="#FF0000"><b>There should be some shadows</b></font></p>
<p>The light source is in the same plane as, and is in alignment with the 
large sphere and the small red and blue spheres.&nbsp; The location and 
direction of the light source is such that the small blue sphere should cast a 
shadow on the large sphere, and the large sphere should completely block out any 
light from reaching the small red sphere.&nbsp; As you can see, that doesn't 
happen.</p>
<p><font color="#FF0000"><b>Opaque and transparent at the same time</b></font></p>
<p>Visual objects in Java 3D behave as if they are both transparent and opaque.&nbsp; 
They are opaque because incident light from a light source will cause them to be 
illuminated according to their diffuse and/or specular color properties.&nbsp; 
They are transparent because the light goes right through them without being 
attenuated and illuminates other visual objects that are located behind them.</p>
<h3><a name="Diffuse_Reflection_and_the_PointLight_Class">Diffuse Reflection and the PointLight Class</a></h3>
<p>In my discussion of the <b>DirectionalLight</b> class, I explained that an 
object of the <b>DirectionalLight</b> class is intended to simulate 
light sources that satisfy the following assumptions:</p>
<ul>
	<li>The light source is assumed to be very far away, such as the sun for 
	example.</li>
	<li>All the light rays travel in parallel paths in the same direction.</li>
	<li>The light wave has a flat wavefront that is at least as wide as the 
	scene that is being illuminated by the directional-light source.</li>
	<li>There is no attenuation of light energy regardless of the distance to 
	the light source.</li>
</ul>
<p><font color="#FF0000"><b>Must be far far away</b></font></p>
<p>It is the first assumption in the above list that causes the remaining three 
assumptions to be reasonably valid.&nbsp; Except for the sun, very few light 
sources behave according to the assumptions listed above <i>(and as I will 
explain later, even the sun doesn't satisfy these assumptions to the letter)</i>.</p>
<p><font color="#FF0000"><b>Most light rays are not parallel</b></font></p>
<p>For example, except for lasers, the light rays that are radiated by most light 
sources do not travel in parallel paths.&nbsp; Therefore, most light sources 
will not satisfy the second assumption in the above list.</p>
<p><font color="#FF0000"><b>No flat and wide wavefront</b></font></p>
<p>Although the light radiated by high-quality 
lasers does come very close to traveling in parallel paths, the beam of light 
produced by a laser is usually 
very narrow.</p>
<p>The wavefront from a laser is probably very close to being flat, 
but normally the beam isn't wide enough to illuminate an entire scene.&nbsp; 
Therefore, most lasers won't satisfy the third assumption in the above list.</p>
<p>Rather, a 
laser is more akin to a <b>SpotLight</b> object than a <b>DirectionalLight</b> 
object.&nbsp; <i>(I will discuss the use of the <b>SpotLight</b> class later in 
this lesson.)</i></p>
<p><font color="#FF0000"><b>Attenuation of light energy does occur</b></font></p>
<p>For most light sources, the light energy is attenuated with distance from the 
source.&nbsp; I will explain the reasons later.</p>
<p><font color="#FF0000"><b>Even the sun doesn't satisfy the assumptions</b></font></p>
<p>The light rays from the sun do not travel in parallel paths.&nbsp; Rather, 
they shoot out in all directions, some in the direction of the Earth and some in 
other directions.</p>
<p>The light waves 
from the sun do not have a flat wavefront.&nbsp; In general, light waves from 
the sun probably have a spherical wavefront.</p>
<p>There is attenuation of light 
energy as you get further and further away from the sun.&nbsp; If you could 
travel to Pluto and look back at the sun, it would probably appear to be very dim.&nbsp;
<i>(See the recent programming on Pluto on the
<a href="http://dsc.discovery.com/">Discovery Channel</a>.)</i></p>
<p><font color="#FF0000"><b>Reasonable approximations</b></font></p>
<p>However, because the sun is so far away, the curvature of the wavefront 
across a distance equivalent to the width a Java 3D scene is very small.&nbsp; 
Therefore, the wavefront can be assumed to be flat.</p>
<p>While there is 
attenuation of the light energy from the sun across the vastness of space, the 
attenuation across the distances involved in a Java 3D scene is so small as to be negligible.&nbsp; Therefore, it is reasonable to assume 
that there is no attenuation of sunlight across a scene.</p>
<p>Because of the enormous distance from the sun to the earth, the angle between 
the light rays at the two outer edges of a Java 3D scene is extremely small.&nbsp; 
Therefore, it is reasonable to assume that the light rays travel in parallel, although this is 
clearly not the case.</p>
<p><font color="#FF0000"><b>A more realistic light source</b></font></p>
<p>The <b>PointLight</b> class is intended to provide a more realistic simulation of 
typical man-made light sources.&nbsp; The energy from an omnidirectional-light 
source radiates uniformly in all directions in 3D space.&nbsp; You can think of the 
light waves that are 
radiated from an omnidirectional-light source as approximating a series of spherical wave 
fronts.&nbsp; <i>(This is similar to 
the two-dimensional circular wave fronts that radiate from the impact point of a 
pebble that is tossed into a pond.)</i>&nbsp; As the spherical wavefront 
moves further and further from the source, the sphere grows larger and the area of the spherical wavefront 
increases.</p>
<p><font color="#FF0000"><b>Conservation of energy</b></font></p>
<p>A finite amount of light energy is encapsulated in the wavefront.&nbsp; As 
the wavefront moves further and further from the source and the total area of 
the wavefront increases, the amount of energy per unit area of the wavefront 
decreases.&nbsp;&nbsp; Eventually the amount of energy in an area the size of the 
capture area of your eyeball becomes negligible and you can no longer see the distant light.</p>
<p><font color="#FF0000"><b>Telescopes</b></font></p>
<p>To compensate for this spreading effect of light energy as the distance to 
the source increases, astronomers use mirrors with very large areas to capture light waves 
from distant stars <i>(our sun is a star)</i>.&nbsp; These mirrors are shaped so 
as to capture the light energy over a very large area and to reflect and focus 
that light energy into a very small area.&nbsp; That small area is where you put 
your eyeball, <i>(or possibly your camera lens)</i> to view or record the image made up of the 
light that is captured by the large mirror.&nbsp; Thus, telescopes with large 
mirrors tend to be more sensitive to light from distant stars than telescopes 
with small mirrors.&nbsp; They are definitely more sensitive than the naked eye.</p>
<blockquote>
	<p><i>(Although you may not be aware of it, you are probably already 
	familiar with this concept.&nbsp; The large devices commonly referred to as 
	satellite dishes perform the same function except that they are used to 
	capture radio waves instead of light waves.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Location of a PointLight object</b></font></p>
<p>An object of the <b>PointLight</b> class can be placed anywhere in your 3D 
universe either inside or outside of the scene being illuminated.&nbsp; 
Remember, however, that if you place it inside the 
scene, it will not be visible.&nbsp; However, the impact that it has on the 
visual objects in the scene will be visible.</p>
<p><font color="#FF0000"><b>Color, intensity, and attenuation</b></font></p>
<p>As usual, you can specify the color and intensity properties of a light 
source based on a <b>PointLight</b> object.&nbsp; In addition, you can specify 
an attenuation factor made up of three values that simulate the spreading 
effect of light energy discussed above.</p>
<p><font color="#FF0000"><b>What does Sun have to say?</b></font></p>
<p>Here is some of what Sun has to say about an object of the <b>PointLight</b> 
class.</p>
<blockquote>
	<p><i>&quot;The PointLight object specifies an attenuated light source at a fixed 
	point in space that radiates light equally in all directions away from the 
	light source. PointLight has the same attributes as a Light node, with the 
	addition of location and attenuation parameters. ... A point light contributes to diffuse and specular reflections but it does not 
contribute to ambient reflections.&quot;</i> </p>
</blockquote>
<p><font color="#FF0000"><b>Brightness decreases with distance from the source</b></font></p>
<p>The energy from a <b>PointLight</b> object is attenuated by 
multiplying the intensity of the light by the attenuation factor. Two of the three values that make up the attenuation factor cause the 
brightness produced by a <b>PointLight</b> object to decrease as distance from 
the light source increases.</p>
<p><font color="#FF0000"><b>Composition of the attenuation factor</b></font></p>
<p>The three values that make up a <b>PointLight</b> object's attenuation factor are:</p>
<ul>
	<li>Constant attenuation</li>
	<li>Linear attenuation</li>
	<li>Quadratic attenuation</li>
</ul>
<p><font color="#FF0000"><b>Formulation of the attenuation factor</b></font></p>
<p>According to Sun, the brightness of a <b>PointLight</b> object is attenuated by the 
reciprocal of the sum of:</p>
<ul>
	<li>The constant attenuation factor, C.</li>
	<li>The Linear attenuation factor L multiplied by the distance, D, between 
	the light and the vertex being illuminated.</li>
	<li>The quadratic attenuation factor Q multiplied by the square of the 
	distance, D, between the light and the vertex being illuminated, </li>
</ul>
<p>Stated in equation form, this results in a <a name="scale_factor">scale factor</a>, S, being applied to 
the light intensity produced by the <b>PointLight</b> object where:</p>
<p><pre><b>S = 1/(C + L*D + Q*D*D)</b></pre></p>
<p><font color="#FF0000"><b>Default values</b></font></p>
<p>By default, this program causes the constant attenuation value to be1.0 and the 
other two attenuation values to be 0.0.&nbsp; This results in no attenuation in 
the default case.</p>
<p><font color="#FF0000"><b>Allowable attenuation value ranges</b></font></p>
<p>Because of 
the reciprocal used in the formulation of the attenuation factor, a constant attenuation value less than 1.0 
would result in a gain in light intensity rather than a loss of light 
intensity.&nbsp; This is completely at odds with reality.&nbsp; Therefore, this program does 
not allow constant attenuation factors less than 1.0.&nbsp; The program also doesn't 
allow constant attenuation factors greater than 2.0.&nbsp; The other two 
attenuation values are allowed to range from 0 to 0.2.</p>
<p><font color="#FF0000"><b>Select the radio buttons and adjust the sliders</b></font></p>
<p>As is the usual procedure with this program, you specify the point-light color, location, and attenuation 
values by selecting the appropriate radio buttons in <a href="#Figure_2">Figure 2</a> and then adjusting 
the sliders to specify the values.</p>
<p><font color="#FF0000"><b>The sun and four planets</b></font></p>
<p><a href="#Figure_12">Figure 12</a> shows a 3D scene of a beautiful golden sun providing daylight 
illumination for four orbiting <a name="Figure_12">planets</a>.</p>
<p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2i.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_12">Figure 12</a></b></pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>There's something wrong with this picture</b></font></p>
<p>However, there is&nbsp;something with <a href="#Figure_12">Figure 12</a>.&nbsp; Can you tell what it 
is?</p>
<p>The problem with <a href="#Figure_12">Figure 12</a> is that the sun depicted by the large sphere isn't 
really providing daylight illumination for the four planets.&nbsp; After the sun 
burns itself out and becomes a large black cinder, the four planets are still 
bathed in daylight as shown in <a name="Figure_13"><a href="#Figure_13">Figure 13</a></a>.</p><p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2j.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_13">Figure 13</a></b></pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>The sun is a facade</b></font></p>
<p>Although <a href="#Figure_12">Figure 12</a> looks fairly realistic, the sun is merely a facade.&nbsp; That's why it doesn't matter to the planets that is has been 
eliminated from <a href="#Figure_13">Figure 13</a>.</p>
<p>The large sphere in <a href="#Figure_12">Figure 12</a> is self-illuminated by the emissive color 
values shown in <a name="Table_4"><a href="#Table_4">Table 4</a></a> and the four planets are illuminated by a point-light 
source.</p>
<p>
<table border="1" cols="1" width="306" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="159">
      <p align="center"><b>Property</b></td>
      <td width="131">
      <p align="center"><b>Property Value</b></td></tr>
    <tr>
      <td width="159">
      Facets</td>
      <td width="131">
      100</td></tr>
    <tr>
      <td width="159">
      Shininess</td>
      <td width="131">
      64.0</td></tr>
    <tr>
      <td width="159">
      Emissive Color</td>
      <td width="131">
      1.0, 1.0, 0.5</td></tr>
    <tr>
      <td width="159">
      PointLight Color</td>
      <td width="131">
      1.0, 1.0, 0.5</td></tr>
    <tr>
      <td width="159">
      PointLight Location</td>
      <td width="131">
      0.0, 0.0, 0.0</td></tr>
    <tr>
      <td width="159">
      PointLight Attenuation</td>
      <td width="131">
      1.0, 0.0, 0.0</td></tr>
    <tr>
      <td colspan="2" >
      <b><a href="#Table_4">Table 4</a></b></td>
    </tr>
</tr></tbody></table></p><p><font color="#FF0000"><b>Emissive color is not a 
light source</b></font></p>
<p>As you will recall from an <a href="#it_will_not">earlier</a> section, a visual object that is 
self-illuminated by emissive color does not function as a light source.&nbsp; It 
cannot illuminate other visual objects nearby.</p>
<p>The four planets in <a href="#Figure_12">Figure 12</a> and <a href="#Figure_13">Figure 13</a> are illuminated by a <b>
PointLight</b> object having the color, location, and attenuation values shown 
in <a href="#Table_4">Table 4</a>.</p>
<p><font color="#FF0000"><b>Location of the point-light source</b></font></p>
<p>Both the large sphere and the point-light source are located at the 
origin in the 3D space in <a href="#Figure_12">Figure 12</a>.&nbsp; In other words, the point-light 
source is located at the center <i>(inside)</i> of the large sphere, causing it 
to be in the correct location to illuminate the four planets that orbit the 
large sphere.</p>
<p><font color="#FF0000"><b>Why wasn't the large sphere illuminated by the 
PointLight source?</b></font></p>
<p>By now, you may be wondering why the inclusion of a point-light source 
inside the large sphere doesn't illuminate it from the inside out.&nbsp; If so, 
that is an excellent question.&nbsp; Unfortunately, the answer to the question, 
which involves the direction of the normal vectors, is too complicated to answer 
in this lesson.&nbsp; Perhaps I will provide an answer in some future 
lesson.&nbsp; In the meantime, I will simply have to leave that question as an exercise 
for the student.</p>
<p><font color="#FF0000"><b>Matching colors</b></font></p>
<p>In addition to the fact that the sun and the point-light source are 
co-located in <a href="#Figure_12">Figure 12</a>, the color of the point-light source is the same 
as the color of the large sphere, causing its color to properly illuminate the 
white planet and the white specular reflections on all four planets.</p>
<p><font color="#FF0000"><b>Attenuation of a point-light source</b></font></p><p>
As I explained earlier, a point-light source has an attenuation property 
that involves three values.&nbsp; The <a href="#scale_factor">formulation</a> of 
the attenuation behavior of a point-light source is such that one of those 
values causes the light intensity to be inversely proportional to the distance 
to the light source, and the other value causes the light intensity to be 
inversely proportional to the square of the distance to the light source.</p>
<blockquote>
	<p><i>(The third value can be used to cause the light intensity to decrease 
	independently of the distance to the light source.)</i></p>
</blockquote>
<p>The effects of the two attenuation values that deal with distance are 
illustrated in <a name="Figure_14"><a href="#Figure_14">Figure 14</a></a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a2e.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2f.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a2g.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2h.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_14">Figure 14</a></b></pre></td></tr></table><p><font color="#FF0000"><b>The 
scene properties</b></font></p>
<p>The important scene properties for <a href="#Figure_14">Figure 14</a> are shown in <a name="Table_5"><a href="#Table_5">Table 5</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="162">
      <p align="center"><b>Property</b></td>
      <td width="80" align="center">
      <p align="center"><b>Case 1</b></td>
      <td width="80" align="center">
      <b>Case 2</b></td>
      <td width="80" align="center">
      <b>Case 3</b></td>
      <td width="80" align="center">
      <b>Case 4</b></td></tr>
    <tr>
      <td width="162">
      Facets</td>
      <td width="80">
      100</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      Shininess</td>
      <td width="80">
      128</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
		Same as 1</td>
      <td width="80">
		Same as 1</td></tr>
    <tr>
      <td width="162">
      Diffuse Color</td>
      <td width="80">
      1.0, 1.0, 0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      Specular Color</td>
      <td width="80">
      1.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      PointLight Color</td>
      <td width="80">
      1.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      PointLight Location</td>
      <td width="80">
      3.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      PointLight Constant Attenuation</td>
      <td width="80">
      1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      PointLight Linear Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      0.2</td>
      <td width="80">
      0.0</td>
      <td width="80">
      0.2</td></tr>
    <tr>
      <td width="162">
      PointLight Quadratic Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      0.0</td>
      <td width="80">
      0.2</td>
      <td width="80">
      0.2</td></tr>

    <tr>
      <td colspan="5" >
      <b><a href="#Table_5">Table 5</a></b></td>
    </tr>
</tr></tbody></table></p><p>The four cases identified by the column headers in 
<a href="#Table_5">Table 5</a> correspond to the four images in <a href="#Figure_14">Figure 14</a>, going left to right, top to 
bottom.</p>
<p><font color="#FF0000"><b>Several scene properties are the same</b></font></p>
<p>The top seven properties in <a href="#Table_5">Table 5</a> are the same for all four cases.&nbsp; 
Only the attenuation values that impact the light intensity as a function of the 
distance to the source vary among the four cases.</p>
<p><font color="#FF0000"><b>Location of the point-light source</b></font></p>
<p>The location of the point-light source is to the right, up, and in 
front of the centers of all five spheres.&nbsp; That direction is evident from 
the portion of each of the spheres that is illuminated.</p>
<p><font color="#FF0000"><b>Different attenuation for each image</b></font></p>
<p>There is no attenuation of the light intensity as a function of the distance 
to the light source for the image in the upper-left corner of <a href="#Figure_14">Figure 14</a>.</p>
<p>The light intensity for the upper-right image is inversely proportional to 
the distance from each vertex being illuminated to the light source.&nbsp; As 
you can see, the upper-right image is dimmer than the upper-left image due to 
this attenuation.</p>
<p>The light intensity for the lower-left image is inversely proportional to the
<i>square</i> of the distance from each vertex to the light source.&nbsp; As you 
can also see, it is somewhat dimmer than the upper-right image.</p>
<p>Finally, the light intensity in the lower-right image is attenuated by both 
the distance to and the square of the distance to the light source.&nbsp; This 
image is dimmer than all the others.</p>
<p><font color="#FF0000"><b>Light intensity varies across the scene</b></font></p>
<p>Although it may not be apparent, <i>(due mainly to the lack of a reference 
for comparison)</i>, with the exception of the upper-left image, the light 
intensity decreases going diagonally from right to left and downward across the 
scenes in <a href="#Figure_14">Figure 14</a>.&nbsp; This is because of differences in the distance from 
each of the vertices to the light source, and the attenuation of the light 
intensity as a function of distance to the light source.</p>
<p><font color="#FF0000"><b>A better example</b></font></p>
<p>The attenuation of light intensity as a function of distance to the light 
source is probably better illustrated by <a href="#Figure_15">Figure 15</a>, which can be compared to a 
similar scene in <a href="#Figure_11">Figure 11</a> where there is no attenuation of light intensity as a 
function of <a name="Figure_15">distance</a>.</p><p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2m.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_15">Figure 15</a></b></pre></td></tr></tbody></table></p><p>The important 
scene properties for <a href="#Figure_15">Figure 15</a> are shown in <a name="Table_6"><a href="#Table_6">Table 6</a></a>.</p>
<p>
<table border="1" cols="1" width="306" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="159">
      <p align="center"><b>Property</b></td>
      <td width="131">
      <p align="center"><b>Property Value</b></td></tr>
    <tr>
      <td width="159">
      Facets</td>
      <td width="131">
      100</td></tr>
    <tr>
      <td width="159">
      Shininess</td>
      <td width="131">
      64.0</td></tr>
    <tr>
      <td width="159">
      Diffuse Color</td>
      <td width="131">
      0.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      PointLight Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td>
	</tr>
	<tr>
      <td width="159">
      PointLight Location</td>
      <td width="131">
      2.0, -2.0, 0.0</td>
	</tr>
    <tr>
      <td width="159">
      PointLight Attenuation</td>
      <td width="131">
      1.0, 0.0, 0.05</td></tr>
    <tr>
      <td colspan="2" >
      <b><a href="#Table_6">Table 6</a></b></td>
    </tr>
</tr></tbody></table></p>
<p><font color="#FF0000"><b>The direction of the light source</b></font></p>
<p>The direction from the light source to the center of the large sphere is the 
same in <a href="#Figure_11">Figure 11</a> and <a href="#Figure_15">Figure 15</a>.&nbsp; However, <a href="#Figure_11">Figure 11</a> is illuminated by a 
directional-light source where there is no attenuation in light intensity 
across the scene.&nbsp; <a href="#Figure_15">Figure 15</a> is illuminated by a point-light source 
where there is attenuation in light intensity across the scene.</p>
<p><font color="#FF0000"><b>The location of the point-light source</b></font></p>
<p>The point-light source in <a href="#Figure_15">Figure 15</a> is located on a line that goes 
through the centers of the large sphere and the small red and blue spheres.&nbsp; 
It is located a little to the right and down from the small blue sphere.</p>
<p><font color="#FF0000"><b>The small blue sphere</b></font></p>
<p>The small blue sphere is closest to the light source in both <a href="#Figure_11">Figure 11</a> and 
<a href="#Figure_15">Figure 15</a>.&nbsp; The light intensity for the small blue sphere was adjusted to 
be approximately 
the same for both cases.</p>
<p><font color="#FF0000"><b>Light intensity for the other four spheres</b></font></p>
<p>The light intensity for the small red sphere, which is the greatest distance 
from the light source, is noticeably lower in <a href="#Figure_15">Figure 15</a> than in <a href="#Figure_11">Figure 11</a>.&nbsp; 
The light intensity for the other three spheres is also lower in <a href="#Figure_15">Figure 15</a> than 
in <a href="#Figure_11">Figure 11</a>.</p>
<p><font color="#FF0000"><b>Direction from the white and green spheres</b></font></p>
<p>Because of the closeness of the light source to the spheres in <a href="#Figure_15">Figure 15</a>, the 
direction from the white and green spheres to the light source is considerably 
different from the direction of the other three spheres to the light source.</p>
<p>If you look carefully, you can see that the area of illumination on the white 
sphere in <a href="#Figure_15">Figure 15</a> is rotated relative to the area of illumination on the white 
sphere in <a href="#Figure_11">Figure 11</a> to take this difference in direction into account.&nbsp; The 
same is true for the green spheres in the two figures, but because the green 
spheres are smaller and further away than the white spheres, the effect isn't 
quite as pronounced.</p>
<h3><a name="Specular_Reflection_and_the_PointLight_Class">Specular Reflection and the PointLight Class</a></h3>
<p>The scene in <a href="#Figure_16">Figure 16</a> is the same as the scene in <a href="#Figure_15">Figure 15</a> except that I 
added white specular reflection capability to the large sphere in 
<a name="Figure_16"><a href="#Figure_16">Figure 16</a></a>.</p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2n.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_16">Figure 16</a></b></pre></td></tr></tbody></table></p><p>In my opinion, 
the inclusion of specular reflection definitely causes the scene to look more 
realistic.&nbsp; However, I sometimes get the feeling that the specular 
reflections don't always properly reflect the angles involved.</p>
<p><a name="Table_7"><a href="#Table_7">Table 7</a></a> provides the important scene properties for <a href="#Figure_16">Figure 16</a></p>
<p>
<table border="1" cols="1" width="306" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="159">
      <p align="center"><b>Property</b></td>
      <td width="131">
      <p align="center"><b>Property Value</b></td></tr>
    <tr>
      <td width="159">
      Facets</td>
      <td width="131">
      100</td></tr>
    <tr>
      <td width="159">
      Shininess</td>
      <td width="131">
      64.0</td></tr>
    <tr>
      <td width="159">
      Specular Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      Diffuse Color</td>
      <td width="131">
      0.0, 1.0, 1.0</td></tr>
    <tr>
      <td width="159">
      PointLight Color</td>
      <td width="131">
      1.0, 1.0, 1.0</td>
	</tr>
	<tr>
      <td width="159">
      PointLight Location</td>
      <td width="131">
      2.0, -2.0, 0.0</td>
	</tr>
    <tr>
      <td width="159">
      PointLight Attenuation</td>
      <td width="131">
      1.0, 0.0, 0.05</td></tr>
    <tr>
      <td colspan="2" >
      <b><a href="#Table_7">Table 7</a></b></td>
    </tr>
</tr></tbody></table></p>
<p>Specular reflection behaves pretty much the same regardless of whether the 
light source is a directional-light source, a point-light source, or 
a spotlight source.</p>
<h3><a name="Diffuse_Reflection_and_the_SpotLight_Class">Diffuse Reflection and the SpotLight Class</a></h3>
<p><font color="#FF0000"><b>What is a SpotLight object?</b></font></p>
<p>A <b>SpotLight</b> object is like a <b>PointLight</b> object on 
steroids.&nbsp; As with a point-light source, you can specify the color, 
location, and attenuation factors for a spotlight source.&nbsp; In 
addition, instead of being omnidirectional, a spotlight provides a narrow 
beam of illumination.&nbsp; You can specify three additional properties for a 
spotlight source, which are used to control the narrow beam.&nbsp; </p>
<p><font color="#FF0000"><b>What does Sun have to say?</b></font></p>
<p>According 
to Sun:</p>
<blockquote>
	<p><i>&quot;The <b>SpotLight</b> object specifies an attenuated light source at a 
	fixed point in space that radiates light in a specified direction from the 
	light source. A <b>SpotLight</b> has the same attributes as a <b>PointLight</b> 
	node, with the addition of the following:</i></p>
	<ul>
		<li><i><b>Direction</b> - The axis of the cone of light. The default 
		direction is (0.0, 0.0, -1.0). The spot light direction is significant 
		only when the spread angle is not PI radians (which it is by default).
		</i></li>
		<li><i><b>Spread angle</b> - The angle in radians between the direction 
		axis and a ray along the edge of the cone. Note that the angle of the 
		cone at the apex is then twice this value. The range of values is 
		[0.0,PI/2] radians, with a special value of PI radians. Values lower 
		than 0 are clamped to 0 and values over PI/2 are clamped to PI. The 
		default spread angle is PI radians. </i></li>
		<li><i><b>Concentration</b> - Specifies how quickly the light intensity 
		attenuates as a function of the angle of radiation as measured from the 
		direction of radiation. The light's intensity is highest at the center 
		of the cone and is attenuated toward the edges of the cone by the cosine 
		of the angle between the direction of the light and the direction from 
		the light to the object being lit, raised to the power of the spot 
		concentration exponent. The higher the concentration value, the more 
		focused the light source. The range of values is [0.0,128.0]. The 
		default concentration is 0.0, which provides uniform light 
		distribution.&quot;</i></li>
	</ul>
</blockquote>
<p><font color="#FF0000"><b>Creating a spotlight source</b></font></p>
<p>You create a spotlight source for this program by selecting among the 
five radio buttons beginning with <b>SpotLt Color</b> in <a href="#Figure_2">Figure 2</a>.&nbsp; You use the first three 
of the five radio buttons to specify the 
color, location, and attenuation of the spotlight source <i>(just like a point-light source)</i>.&nbsp; You use the button labeled <b>SpotLt Vector</b> 
to specify the direction of the spotlight.&nbsp; You use the button labeled <b>
SpotLt SprCon</b> to specify the <i>spread angle</i> and the <i>concentration</i>.</p>
<p><font color="#FF0000"><b>A spotlight example for progressively wider spread 
angles</b></font></p>
<p><a href="#Figure_17">Figure 17</a> shows a series of four scenes that illustrate the use of a white 
spotlight source to illuminate a large sphere for progressively wider spread 
angles on the <a name="Figure_17">spotlight</a>.</p>

<p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td>
		<img border="0" src="java1540a2o.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2p.jpg" width="233" height="233"></td></tr><tr>
		<td>
		<img border="0" src="java1540a2q.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2r.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_17">Figure 17</a></b></pre></td></tr></table><p><font color="#FF0000"><b>The 
scene properties</b></font></p>
<p>The important scene properties 
for <a href="#Figure_17">Figure 17</a> are shown in <a name="Table_8"><a href="#Table_8">Table 8</a></a>.</p>
<p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="162">
      <p align="center"><b>Property</b></td>
      <td width="80" align="center">
      <p align="center"><b>Case 1</b></td>
      <td width="80" align="center">
      <b>Case 2</b></td>
      <td width="80" align="center">
      <b>Case 3</b></td>
      <td width="80" align="center">
      <b>Case 4</b></td></tr>
    <tr>
      <td width="162">
      Facets</td>
      <td width="80">
      100</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      Emissive Color</td>
      <td width="80">
      0.2, 0.0, 0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
		Same as 1</td>
      <td width="80">
		Same as 1</td></tr>
    <tr>
      <td width="162">
      Diffuse Color</td>
      <td width="80">
      1.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Color</td>
      <td width="80">
      1.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Location</td>
      <td width="80">
      0.0, 0.0, 4.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Constant Attenuation</td>
      <td width="80">
      1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Linear Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Quadratic Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td width="162">
      SpotLight Vector</td>
      <td width="80">
      0.4, 0.5,&nbsp; -10.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td width="162">
      SpotLight Spread Angle</td>
      <td width="80">
      0.04</td>
      <td width="80">
      0.06</td>
      <td width="80">
      0.08</td>
      <td width="80">
      0.10</td></tr>

    <tr>
      <td width="162">
      SpotLight Concentration</td>
      <td width="80">
      0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td colspan="5" >
      <b><a href="#Table_8">Table 8</a></b></td>
    </tr>
</tr></tbody></table></p>
<p><font color="#FF0000"><b>The color of the sphere</b></font></p>
<p>The diffuse color for the large sphere is white.&nbsp; The sphere was 
also given a small amount of red emissive color to cause the portion of the sphere 
not illuminated by the spotlight to be visible <i>(instead of being black)</i>.</p>
<p><font color="#FF0000"><b>The spread angle</b></font></p>
<p>The allowable range for the spread angle in this program is from 0 to 0.1 
radians.&nbsp; The spread angle for this series of four scenes ranges from 0.04 
radians in the upper-left image to 0.1 radians in the lower-right image.</p>
<p>As you can see, for the two larger spread angles 
in the bottom images of <a href="#Figure_17">Figure 17</a>, 
the spotlight not only illuminated part of the large sphere, it also spilled 
over and illuminated 
part of the small green sphere as well.</p>
<p><font color="#FF0000"><b>Not a smooth outline</b></font></p>
<p>Ideally, we would like to see a smooth outline for the area illuminated by a 
spotlight source.&nbsp; Unfortunately, the outline is not smooth.&nbsp; Rather, 
the facets on the surface of the sphere cause the outline to be ragged.</p>
<p><font color="#FF0000"><b>The concentration property value</b></font></p>
<p>The value for the concentration property was 0.0 for all four scenes in 
<a href="#Figure_17">Figure 17</a>, resulting in uniform light intensity across the entire spread angle.&nbsp; 
Note, however that even though the light intensity is uniform across the 
illuminated area, Gouraud shading comes into play and the rendered color of the 
illuminated area is not uniform.</p>
<p><font color="#FF0000"><b>A spotlight example for progressively higher 
concentration values</b></font></p>
<p><a href="#Figure_18">Figure 18</a> shows a series of four scenes that illustrate the use of a white 
spotlight source to illuminate the large sphere using the maximum spread angle and 
progressively larger values of the <a name="Figure_18">concentration property</a>.</p>
<table border="1" bgcolor="#ccffff">
	<tr>
		<td><img border="0" src="java1540a2s.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2t.jpg" width="233" height="233"></td></tr><tr>
		<td><img border="0" src="java1540a2u.jpg" width="233" height="233"></td><td>
		<img border="0" src="java1540a2v.jpg" width="233" height="233"></td></tr><tr>
	<td colspan="2" >
<pre><b><a href="#Figure_18">Figure 18</a></b></pre></td></tr></table>
<blockquote>
	<p><i>(The illuminated area is smaller in <a href="#Figure_18">Figure 18</a> than in <a href="#Figure_17">Figure 17</a> 
	because the spotlight location was closer to the sphere in <a href="#Figure_18">Figure 18</a>.&nbsp; 
	As a result, the diameter of the cone of light was smaller at the point 
	where it intersected the surface of the sphere in <a href="#Figure_18">Figure 18</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The 
scene properties</b></font></p>
<p>The important scene properties 
for <a href="#Figure_18">Figure 18</a> are shown in <a name="Table_9"><a href="#Table_9">Table 9</a></a>.</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="162">
      <p align="center"><b>Property</b></td>
      <td width="80" align="center">
      <p align="center"><b>Case 1</b></td>
      <td width="80" align="center">
      <b>Case 2</b></td>
      <td width="80" align="center">
      <b>Case 3</b></td>
      <td width="80" align="center">
      <b>Case 4</b></td></tr>
    <tr>
      <td width="162">
      Facets</td>
      <td width="80">
      100</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      Emissive Color</td>
      <td width="80">
      0.2, 0.0, 0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
		Same as 1</td>
      <td width="80">
		Same as 1</td></tr>
    <tr>
      <td width="162">
      Diffuse Color</td>
      <td width="80">
      1.0, 1.0, 0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Color</td>
      <td width="80">
      1.0, 1.0, 1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Location</td>
      <td width="80">
      0.0, 0.0, 2.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Constant Attenuation</td>
      <td width="80">
      1.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Linear Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>
    <tr>
      <td width="162">
      SpotLight Quadratic Attenuation</td>
      <td width="80">
      0.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td width="162">
      SpotLight Vector</td>
      <td width="80">
      0.0, 0.0,&nbsp; -10.0</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td width="162">
      SpotLight Spread Angle</td>
      <td width="80">
      0.1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td>
      <td width="80">
      Same as 1</td></tr>

    <tr>
      <td width="162">
      SpotLight Concentration</td>
      <td width="80">
      0.0</td>
      <td width="80">
      42.0</td>
      <td width="80">
      85.0</td>
      <td width="80">
      128.0</td></tr>

    <tr>
      <td colspan="5" >
      <b><a href="#Table_9">Table 9</a></b></td>
    </tr>
</tr></tbody></table></p>
<p><font color="#FF0000"><b>Pointing directly at the center of the sphere</b></font></p>
<p>In <a href="#Figure_17">Figure 17</a> discussed earlier, the spotlight was used to illuminate a portion of the surface 
of the large sphere that was off to the right and up relative to the location of 
the spotlight.&nbsp; However, in <a href="#Figure_18">Figure 18</a>, the location of the spotlight was 
directly in front of the large sphere, and the spotlight was pointed at the center 
of the sphere.&nbsp; As a result, the outline of the illumination area was 
symmetrical on both the x and y axes, and was generally concentric with the outline of the sphere.</p>
<blockquote>
	<p><i>(As mentioned earlier, the actual shape of the illumination area for a 
	spotlight is heavily influenced by the facets on the surface of the sphere.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The concentration values</b></font></p>
<p>The allowable range of concentration values for this program is 0.0 to 
128.0.</p>
<p>The concentration value was 0.0 for the image shown in the upper left corner 
of <a href="#Figure_18">Figure 18</a>.&nbsp; Thus, the light intensity for this image was uniform across 
the spread angle of the spotlight.&nbsp; Furthermore, the illumination area was 
a sufficiently small percentage of the area of the sphere that there was very 
little effect from Gouraud shading.</p>
<p>The concentration values were increased in three equal steps in order from left to 
right, top to bottom.&nbsp; This resulted in a concentration value of 
128.0 for the image in the lower-right corner of <a href="#Figure_18">Figure 18</a>.</p>
<p>As you can see, the outer edge of the illuminated area became slightly darker 
with each increase in the concentration value.&nbsp; However, the effect was 
not as pronounced as I might have hoped for.</p>
<h3><a name="Specular_Reflection_and_the_SpotLight_Class">Specular Reflection and the 
SpotLight Class</a></h3>
<p><a href="#Figure_19">Figure 19</a> shows a scene that uses a spotlight with maximum spread angle and 
maximum concentration to illuminate part of a large red sphere and part of the 
small green sphere that you have seen in numerous previous <a name="Figure_19">scenes</a>.</p><p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2w.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_19">Figure 19</a></b></pre></td></tr></tbody></table></p><p>
<font color="#FF0000"><b>The scene properties</b></font></p>
<p>The important screen properties for <a href="#Figure_19">Figure 19</a> are shown in <a name="Table_10"><a href="#Table_10">Table 10</a></a>.</p>
<table border="1" cols="1" width="299" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td width="158">
      <p align="center"><b>Property</b></td>
      <td width="125" align="center">
      <p align="center"><b>Property Value</b></td>
      </tr>
    <tr>
      <td width="158">
      Facets</td>
      <td width="125">
      100</td>
      </tr>
    <tr>
      <td width="158">
      Shininess</td>
      <td width="125">
      128.0</td>
      </tr>
    <tr>
      <td width="158">
      Emissive Color</td>
      <td width="125">
      0.3, 0.0, 0.0</td>
      </tr>
    <tr>
      <td width="158">
      Diffuse Color</td>
      <td width="125">
      1.0, 0.0, 0.0</td>
      </tr>
    <tr>
      <td width="158">
      Specular Color</td>
      <td width="125">
      1.0, 1.0, 1.0</td>
      </tr>
    <tr>
      <td width="158">
      SpotLight Color</td>
      <td width="125">
      1.0, 1.0, 1.0</td>
      </tr>
    <tr>
      <td width="158">
      SpotLight Location</td>
      <td width="125">
      0.2, 0.0, 4.0</td>
      </tr>
    <tr>
      <td width="158">
      SpotLight Constant Attenuation</td>
      <td width="125">
      1.0</td>
      </tr>
    <tr>
      <td width="158">
      SpotLight Linear Attenuation</td>
      <td width="125">
      0.0</td>
      </tr>
    <tr>
      <td width="158">
      SpotLight Quadratic Attenuation</td>
      <td width="125">
      0.0</td>
      </tr>

    <tr>
      <td width="158">
      SpotLight Vector</td>
      <td width="125">
      0.0, 0.5,&nbsp; -10.0</td>
      </tr>

    <tr>
      <td width="158">
      SpotLight Spread Angle</td>
      <td width="125">
      0.1</td>
      </tr>

    <tr>
      <td width="158">
      SpotLight Concentration</td>
      <td width="125">
      128.0</td>
      </tr>

    <tr>
      <td colspan="2" >
      <b><a href="#Table_10">Table 10</a></b></td>
    </tr>
</tr></tbody></table></p>
<p>Both the green sphere and the red sphere have a white specular color.&nbsp; 
As you can see, the white spotlight produces a white specular reflection on both 
spheres.</p>
<p><font color="#FF0000"><b>Changing the concentration value</b></font></p>
<p>The green sphere is at the outer edge of the spread angle for the spotlight.&nbsp; 
Thus, the illumination of the green sphere in <a href="#Figure_19">Figure 19</a> is strongly influenced 
by the high concentration property value.</p>
<p><a href="#Figure_20">Figure 20</a> shows the results of 
rerunning this case with the concentration property value <a name="Figure_20">set to 0.0</a>.</p><p>
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <pre><img border="0" src="java1540a2x.jpg" width="473" height="473"><br></pre>
      <pre><b><a href="#Figure_20">Figure 20</a></b></pre></td></tr></tbody></table></p><p>As 
you can see, the illumination of the green sphere is noticeably brighter in 
<a href="#Figure_20">Figure 20</a> as compared to <a href="#Figure_19">Figure 19</a> when the concentration value has been 
modified to produce uniform light intensity across the entire spread angle.</p>
<center>
<h2><a name="Run the program"></a>Run the Program</h2></center><p>I encourage you to copy the code from 
<a href="#Listing_1">Listing 1</a> into your text editor, compile it, and execute it.&nbsp; Use the graphical 
user interface to experiment with the many features of Java 3D lighting to 
improve your understanding of those features.</p>
<p>Experiment with the code, making changes, and observing the results of your 
changes.&nbsp; For example, you might want to consider replacing one or more of 
the spheres with other 3D shapes such as cones or cubes to see what impact those 
changes have on the 3D scene lighting.</p>
<p>In order to compile and run this program, you must download and install the 
Java 3D API.&nbsp; As of the date of this writing, it was available at:
<a href="http://java.sun.com/products/java-media/3D/">
http://java.sun.com/products/java-media/3D/</a>.&nbsp; The online documentation was 
available at: <a href="http://download.java.net/media/java3d/javadoc/1.4.0/">
http://download.java.net/media/java3d/javadoc/1.4.0/</a>.</p>
<p>In addition, you must download and install either 
<a href="http://www.microsoft.com/windows/directx/default.mspx">Microsoft 
DirectX</a> 
or <a href="http://www.opengl.org/">OpenGL</a>.</p><h2 align="center"><a name="Summary">Summary</a></h2><p>
In this lesson, I taught you about, and showed you examples of many of 
the important features of scene illumination in the Java 3D API.&nbsp; I also 
provided the source code for a complete Java 3D lighting simulator that 
you can compile and run to experiment with light in the Java 3D API.</p><ul>
</ul>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2><p>I will explain 
how the Java 3D lighting simulator program works in subsequent parts of this 
multi-part lesson.</p><h2 align="center"><a name="References">References</a></h2><p>
Several important references related to the <span lang="en-us"></span>rendering of 3D light are listed 
below:</p>
<ul>
	<li>Java 3D API download site:&nbsp;
	<a href="http://java.sun.com/products/java-media/3D/">http://java.sun.com/products/java-media/3D/</a>. 
	</li>
	<li>Java 3D API online documentation site:&nbsp;&nbsp;
	<a href="http://download.java.net/media/java3d/javadoc/1.4.0/">http://download.java.net/media/java3d/javadoc/1.4.0/</a>.</li>
	<li>Java 3D API document published by Dennis J. Bouvier:&nbsp;
	<a href="http://java.sun.com/developer/onlineTraining/java3d/j3d_tutorial_ch6.pdf">http://java.sun.com/developer/onlineTraining/java3d/j3d_tutorial_ch6.pdf</a>&nbsp;  
	</li>
	<li>The
	<a href="http://java.sun.com/products/java-media/3D/forDevelopers/j3dguide/j3dTOC.doc.html">Java 3D API Specification</a>.</li>
	<li><a href="http://www.microsoft.com/windows/directx/default.mspx">Microsoft 
DirectX</a></li>
	<li><a href="http://www.opengl.org/">OpenGL</a></li>
	<li>Wikipedia
	<a href="http://www.devmaster.net/wiki/Software_Rasterization_School,_Part_5:_Lighting">Software Rasterization School, Part 5: Lighting</a></li>
</ul>
<center>
<h2> <a name="Complete Program Listings"></a>Complete Program Listing</h2></center>
<p>A complete listing of the program discussed in this lesson is provided in
<a name="Listing_1" href="#Listing_1">Listing 1</a>.
&nbsp;
</p>
<table border="1" cols="1" width="482" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File Lighting3D04.java
Copyright 2006, R.G.Baldwin

This Java 3D lighting simulator program can be used to 
exercise most of the lighting and illumination features of
the Java 3D API either individually or in combination with
one another.

In order to compile and run this program, you must download
and install the Java 3D API. As of the date of this 
writing, it was available at:
http://java.sun.com/products/java-media/3D/

The online documentation was available at:
http://download.java.net/media/java3d/javadoc/1.4.0/

You must also have either Microsoft DirectX or OpenGL 
installed on your computer.
See http://www.microsoft.com/windows/directx/default.mspx
or http://www.opengl.org/

The comments in the body of the program contain numerous 
references to Chapter 6 of a document published by 
Dennis J. Bouvier at the following URL.

http://java.sun.com/developer/onlineTraining/java3d/
j3d_tutorial_ch6.pdf

In most cases, the references are cited by page or section
number.

Here is an example of the type of material provided by
Bouvier:  "In the real world, the colors we perceive are a 
combination of the physical properties of the object, the
characteristics of the light sources, the objects' relative
positions to light sources, and the angle from which the 
object is viewed. Java 3D uses a lighting model to 
approximate the physics of the real world."

According to Bouvier, Section E.2 of The Java 3D API
Specification presents the mathematical equations of the 
Java 3D lighting model.  As of the date of this writing, 
the specification can be found at:
http://java.sun.com/products/java-media/3D/forDevelopers/
j3dguide/j3dTOC.doc.html

Still quoting Bouvier, "The lighting model equation depends
on three vectors: the surface normal (N), the light 
direction (L), and the direction to the viewer's eye (E) in
addition to the Material properties of the object and the
light characteristics."

This program makes it easy for the user to vary the surface
normal (indirectly), the light direction, and the Material 
properties of the object.  The program does not make it 
possible for the user to easily modify the direction to the
viewer's eye.  However, the primary experimental object is
a large sphere which, because of its curvature, inherently
results in a wide range of directions from the object to
the user's eye.

Back to Bouvier, "The lighting model incorporates three 
kinds of real world lighting reflections: ambient, diffuse,
and specular. Ambient reflection results from AmbientLight,
constant low level light, in a scene. Diffuse reflection is
the normal reflection of a light source from a visual 
object. Specular reflections are the highlight reflections 
of a light source from an object, which occur in certain 
situations."

This program produces two user interfaces.  One interface
is the display of a 3D scene containing five spheres.
Four of the spheres are small with fixed reflective
surface properties and a fixed number of facets.  When
illuminated with either white light or light having a color
that matches the reflective color of the sphere, these 
small spheres appear as white, red, green, and blue.

The fifth sphere is larger, and almost everything about
this sphere other than its size and location can be 
modified by the user through the second user interface.
This makes it possible for the user to view the effects of
those modifications in conjunction with varying light 
conditions.  For example, the user can control almost all 
aspects of the following characteristics of the large 
sphere:

The number of facets on the surface of the sphere.
The shininess of the sphere.
The emissive color and intensity.
The ambient color and intensity.
The diffuse color and intensity.
The specular color and intensity.
The type of shading: gouraud shading or flat shading.

In addition, the user has control over the following lights
and their characteristics of color, intensity, direction, 
location, attenuation, spreading, and concentration as 
applicable:

One AmbientLight object.
Two independent DirectionalLight objects.
One PointLight object.
One SpotLight object.

For example, having specified the various properties of
the large sphere, the user can vary the properties of the
lights and observe the manner in which the lights interract
with the five spheres to illuminate the scene.

The properties of the large sphere and the lights are
varied by selecting a radio button that corresponds
to the property and then adjusting three sliders.  The 
display of the scene changes as the user adjusts the 
sliders, making it possible to easily view the effects of
fixing all properties but one and then varying that 
property across a range of values.

The second user interface also makes it possible for the
user to select between a large and a small display.  This
was done primarily to support my publishing efforts when
I publish a tutorial lesson explaining this program.

Tested using J2SE 5.0, the Java 3D API v1.4.0, WinXP,
and the version of DirectX published by Microsoft in 
April, 2006.  The program was not tested with OpenGL.
**********************************************************/
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.geometry.Sphere;
import com.sun.j3d.utils.geometry.Primitive;

import javax.media.j3d.BranchGroup;
import javax.media.j3d.ColoringAttributes;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Material;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.AmbientLight;
import javax.media.j3d.DirectionalLight;
import javax.media.j3d.PointLight;
import javax.media.j3d.SpotLight;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.Locale;

import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Color3f;
import javax.vecmath.Vector3f;

import java.awt.Frame;
import java.awt.Panel;
import java.awt.Label;
import java.awt.Dimension;
import java.awt.TextField;
import java.awt.BorderLayout;
import java.awt.GraphicsConfiguration;
import java.awt.GridLayout;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.Timer;
import javax.swing.JSlider;
import javax.swing.JRadioButton;
import javax.swing.ButtonGroup;

import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;

public class Lighting3D04 extends Frame 
                                 implements ActionListener{
  
  //The scene is rendered periodically on the basis of
  // timer events.  The following flag is used to avoid
  // rendering the scene when it hasn't changed since the
  // last time it was rendered.
  boolean sceneHasChanged = true;
  
  static Timer timer;//Used to update the scene image.
  ControlPanel controlPanel;
  SliderPanel sliderPanel;
  
  JSlider topSlider;
  JSlider middleSlider;
  JSlider bottomSlider;
  
  Label topSliderLabel = new Label("",Label.CENTER);
  Label middleSliderLabel = new Label("",Label.CENTER);
  Label bottomSliderLabel = new Label("",Label.CENTER);
  
  Label column1;//Column headers
  Label column2;
  Label column3;
  
  Dimension largeDisplaySize = new Dimension(472,472);
  Dimension smallDisplaySize = new Dimension(232,232);
  
  //Ref to the main graphic display.
  Lighting3D04 displayObject;
  
  //Default value at startup and max value
  int facets = 100;
  float shininess = 64.0f;//Default value at startup
  
  //Default shading is Gouraud.  Alternate is SHADE_FLAT.
  // Modified when user selects a shading button.
  int shading = ColoringAttributes.SHADE_GOURAUD;
  
  //The following constant specifies the number of radio
  // buttons on the control panel.  This is also the number
  // of items whose values can be adjusted by the user.
  final int numRadioButtons = 19;

  //The following array contains the parameter values used
  // to specify the scene.  The rows in the array
  // correspond to the following items:
  // 0 Facets - Used to construct sphere0.  This is the
  //   number of flats encountered in one pass around the
  //   equator of the sphere.
  // 1 Shininess - A property of the Material that
  //   comprises the surface of sphere0.
  // 2 Emissive color - The color of the light emitted by
  //   sphere0 in the absence of a light source.
  // 3 Ambient color - The color of the surface of sphere0
  //   in the presence of AmbientLight.
  // 4 Diffuse color - The color of the surface of sphere0
  //   resulting from being illuminated with
  //   DirectionalLight, PointLight, or SpotLight.
  // 5 Specular color - The color of the highlights on the
  //   surface of sphere0 when illuminated with
  //   DirectionalLight, PointLight, or SpotLight.
  // 6 AmbientLight - The color and intensity of
  //   non-directional AmbientLight.  Interacts only with
  //   ambient color described above.
  // 7 DirectionalLight 1 - The color and intensity of a
  //   DirectionalLight.
  // 8 DirectionalLight 1 vector - A vector that specifies
  //   the direction.
  // 9 DirectionalLight 2 - The color and intensity of a
  //   second DirectionalLight.
  //10 DirectionalLight 2 vector - A vector that specifies
  //   the direction
  //11 PointLight - The color and intensity of a
  //   PointLight.
  //12 PointLight location - The location of the
  //   PointLight.
  //13 PointLight attenuation - Attenuation values for the
  //   PointLight.
  //14 SpotLight - The color and intensity of a SpotLight.
  //15 SpotLight location - The location of the SpotLight.
  //16 SpotLight attenuation - Attenuation values for the
  //   SpotLight
  //17 SpotLight vector - A vector that specifies the
  //   direction
  //18 SpotLight spreading and concentration factors.
  
  float[][] data = new float[numRadioButtons][3];
  
  //An array containing references to a group of radio
  // buttons.
  JRadioButton[] radioButtonArray = 
                         new JRadioButton[numRadioButtons];
  
  //References to objects that are peculiar to the Java 3D
  // API.
  BranchGroup scene;
  SimpleUniverse universe;
  //-----------------------------------------------------//
  
  public static void main(String[] args){
    new Lighting3D04();
    //Start the timer that will cause the display to be
    // updated periodically.
    timer.start();
  }//end main
  //-----------------------------------------------------//
  public Lighting3D04(){//constructor
    //The controller contains the sliderPanel, the 
    // controlPanel, and the buttonPanel.
    Frame controller = 
                  new Frame("Copyright 2006, R.G.Baldwin");
    controller.setBounds(473,0,472,718);
    
    controller.addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    
    //The controlPanel contains radio buttons and text
    // fields in the CENTER of the controller.
    controlPanel = new ControlPanel();
    controller.add(controlPanel,BorderLayout.CENTER);
    
    //The sliderPanel contains sliders in the NORTH of the
    // controller
    sliderPanel = new SliderPanel();
    controller.add(sliderPanel,BorderLayout.NORTH);
    
    //The buttonPanel contains radio buttons in the SOUTH
    // of the controller.
    ButtonPanel buttonPanel = new ButtonPanel();
    controller.add(buttonPanel,BorderLayout.SOUTH);
    
    controller.setVisible(true);
    
    //Create the timer that will be used to periodically
    // update the display.
    timer = new Timer(200,this);   
    
    //Construct the 3D display
    GraphicsConfiguration config = 
                SimpleUniverse.getPreferredConfiguration();
    Canvas3D canvas = new Canvas3D(config);
    add("Center", canvas);

    //Create a scene and attach it to the virtual universe
    scene = createSceneGraph();
    universe = new SimpleUniverse(canvas);
    universe.getViewingPlatform().
                              setNominalViewingTransform();
    universe.addBranchGraph(scene);
    
    setSize(largeDisplaySize);//default to large display
    setTitle("Copyright 2006, R.G.Baldwin");
    setVisible(true);
    
    //Save a reference to the display object so that other
    // methods can access it.
    displayObject = this;

    addWindowListener(
      new WindowAdapter(){
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }//end windowClosing
      }//end new WindowAdapter
    );//end addWindowListener
    
  }//end constructor
  //-----------------------------------------------------//
  
  //This method is called to create the scene.
  public BranchGroup createSceneGraph(){
    // Create the root of the branch graph
    BranchGroup objRoot = new BranchGroup();
    
    //Create sphere0
    //See http://java.sun.com/developer/onlineTraining/
    // java3d/j3d_tutorial_ch6.pdf, page 6-21 re Material
    Material sphere0Surface = new Material();
    //The shininess value is only used in calculating
    // specular reflections.  The shininess value controls
    // the spread range of viewing angle for which a
    // specular reflection can be seen.  Higher shininess
    // values result in smaller specular reflections. See
    // page 6-23
    sphere0Surface.setShininess(data[1][0]);
    sphere0Surface.setEmissiveColor(
                         data[2][0],data[2][1],data[2][2]);
    sphere0Surface.setAmbientColor(
                         data[3][0],data[3][1],data[3][2]);
    sphere0Surface.setDiffuseColor(
                         data[4][0],data[4][1],data[4][2]);

    //When a surface is sufficiently smooth, it acts like a
    // mirror reflecting the light without changing the
    // color of the light. Consequently, the specular color
    // of an object is normally white.  See page 6-22.
    sphere0Surface.setSpecularColor(
                         data[5][0],data[5][1],data[5][2]);

    Appearance appearance0 = new Appearance();
    appearance0.setMaterial(sphere0Surface);

    //Specify SHADE_GOURAUD or SHADE_FLAT shading.
    ColoringAttributes coloringAttributes = 
                                  new ColoringAttributes();
    coloringAttributes.setShadeModel(shading);
    appearance0.setColoringAttributes(coloringAttributes);
    
    //Construct the large sphere.  See page 6-4 and
    // page 6-24 re NORMALS.
    Sphere sphere0 = new Sphere(0.48f,
                                Primitive.GENERATE_NORMALS,
                                (int)(data[0][0]),
                                appearance0);
    
    //Now construct four small spheres with fixed surface
    // properties and a fixed number of facets.  Shading
    // depends on the value stored in coloringAttributes
    // that was constructed above.
    
    //Construct a small white calibration sphere located
    // down to the left and closer than the main sphere.
    Material sphere1Surface = new Material();
    sphere1Surface.setShininess(128.0f);
    sphere1Surface.setEmissiveColor(0.1f,0.1f,0.1f);
    sphere1Surface.setAmbientColor(1.0f,1.0f,1.0f);
    sphere1Surface.setDiffuseColor(1.0f,1.0f,1.0f);
    sphere1Surface.setSpecularColor(1.0f,1.0f,1.0f);
    Appearance appearance1 = new Appearance();
    appearance1.setMaterial(sphere1Surface);
    appearance1.setColoringAttributes(coloringAttributes);
    Sphere sphere1 = new Sphere(0.10f,
                                Primitive.GENERATE_NORMALS,
                                50,
                                appearance1);
    Transform3D position1 = new Transform3D();      
    position1.setTranslation(
                           new Vector3f(-0.5f,-0.5f,0.5f));
    TransformGroup objTrans1 = new TransformGroup();
    objTrans1.setCapability(
                     TransformGroup.ALLOW_TRANSFORM_WRITE);
    objTrans1.setTransform(position1);
    objTrans1.addChild(sphere1);
    
    
    //Construct a small red sphere located up to the left
    // and in the same z-plane as the large sphere.
    Material sphere2Surface = new Material();
    sphere2Surface.setShininess(128.0f);
    sphere2Surface.setEmissiveColor(0.1f,0.1f,0.1f);
    sphere2Surface.setAmbientColor(1.0f,0.0f,0.0f);
    sphere2Surface.setDiffuseColor(1.0f,0.0f,0.0f);
    sphere2Surface.setSpecularColor(1.0f,1.0f,1.0f);
    Appearance appearance2 = new Appearance();
    appearance2.setMaterial(sphere2Surface);
    appearance2.setColoringAttributes(coloringAttributes);
    Sphere sphere2 = new Sphere(0.10f,
                                Primitive.GENERATE_NORMALS,
                                50,
                                appearance2);
    Transform3D position2 = new Transform3D();      
    position2.setTranslation(
                            new Vector3f(-0.5f,0.5f,0.0f));
    TransformGroup objTrans2 = new TransformGroup();
    objTrans2.setCapability(
                     TransformGroup.ALLOW_TRANSFORM_WRITE);
    objTrans2.setTransform(position2);
    objTrans2.addChild(sphere2);      
    
    //Construct a small green sphere located up to the
    // right and behind the large sphere.
    Material sphere3Surface = new Material();
    sphere3Surface.setShininess(128.0f);
    sphere3Surface.setEmissiveColor(0.1f,0.1f,0.1f);
    sphere3Surface.setAmbientColor(0.0f,1.0f,0.0f);
    sphere3Surface.setDiffuseColor(0.0f,1.0f,0.0f);
    sphere3Surface.setSpecularColor(1.0f,1.0f,1.0f);
    Appearance appearance3 = new Appearance();
    appearance3.setMaterial(sphere3Surface);
    appearance3.setColoringAttributes(coloringAttributes);
    Sphere sphere3 = new Sphere(0.10f,
                                Primitive.GENERATE_NORMALS,
                                50,
                                appearance3);
    Transform3D position3 = new Transform3D();      
    position3.setTranslation(
                            new Vector3f(0.5f,0.5f,-0.5f));
    TransformGroup objTrans3 = new TransformGroup();
    objTrans3.setCapability(
                     TransformGroup.ALLOW_TRANSFORM_WRITE);
    objTrans3.setTransform(position3);
    objTrans3.addChild(sphere3);      
    
    //Constructa small blue sphere located down to the
    // right and in the same z-plane as the large sphere.
    Material sphere4Surface = new Material();
    sphere4Surface.setShininess(128.0f);
    sphere4Surface.setEmissiveColor(0.1f,0.1f,0.1f);
    sphere4Surface.setAmbientColor(0.0f,0.0f,1.0f);
    sphere4Surface.setDiffuseColor(0.0f,0.0f,1.0f);
    sphere4Surface.setSpecularColor(1.0f,1.0f,1.0f);
    Appearance appearance4 = new Appearance();
    appearance4.setMaterial(sphere4Surface);
    appearance4.setColoringAttributes(coloringAttributes);
    Sphere sphere4 = new Sphere(0.10f,
                                Primitive.GENERATE_NORMALS,
                                50,
                                appearance4);
    Transform3D position4 = new Transform3D();      
    position4.setTranslation(
                           new Vector3f(0.5f,-0.5f,-0.0f));
    TransformGroup objTrans4 = new TransformGroup();
    objTrans4.setCapability(
                     TransformGroup.ALLOW_TRANSFORM_WRITE);
    objTrans4.setTransform(position4);
    objTrans4.addChild(sphere4);
    

    //See page 6-3 and page 6-25 re BoundingSphere.
    BoundingSphere boundingSphere = 
         new BoundingSphere(new Point3d(0.0,0.0,0.0), 1.0);
    
    //Now add the lights to the scene.  See page 6-11
    // and page 6-13.  DirectionalLights only participate
    // in diffuse and specular reflection portions of the
    // lighting model. For diffuse and specular
    // reflections, the geometry is a factor (unlike
    // ambient reflections). Varying the direction of the
    // light source will change the shading of visual
    // objects. Only diffuse and specular Material
    // properties are used in calculating the diffuse and
    // specular reflections. Section 6-4 presents Material
    // properties of visual objects in more detail.
    
    //Add an AmbientLight.  Requires an ambient reflection
    // component on a surface to be visible.
    Color3f light0Color = 
             new Color3f(data[6][0],data[6][1],data[6][2]);
    AmbientLight light0 = 
                        new AmbientLight(true,light0Color);
    light0.setInfluencingBounds(boundingSphere);
    
    //Add a DirectionalLight.
    Color3f light1Color = 
             new Color3f(data[7][0],data[7][1],data[7][2]);
    Vector3f light1Direction = 
            new Vector3f(data[8][0],data[8][1],data[8][2]);
    DirectionalLight light1 = 
        new DirectionalLight(light1Color, light1Direction);
    light1.setInfluencingBounds(boundingSphere);
    
    //Add another DirectionalLight
    Color3f light2Color = 
             new Color3f(data[9][0],data[9][1],data[9][2]);
    Vector3f light2Direction = 
         new Vector3f(data[10][0],data[10][1],data[10][2]);
    DirectionalLight light2 = 
        new DirectionalLight(light2Color, light2Direction);
    light2.setInfluencingBounds(boundingSphere);
   
    //Add a PointLight.  See pages 6-13 and 6-14.  Like a
    // DirectionalLight, a PointLight only participates
    // in diffuse and specular reflection portions of the
    // lighting model. For diffuse and specular
    // reflections, the geometry is a factor. Varying the
    // location of a PointLight object will change the
    // shading of visual objects in a scene.
    
    Color3f light3Color = 
          new Color3f(data[11][0],data[11][1],data[11][2]);
    Point3f light3Position = 
          new Point3f(data[12][0],data[12][1],data[12][2]);
    Point3f light3Attenuation = 
          new Point3f(data[13][0],data[13][1],data[13][2]);
    PointLight light3 = new PointLight(light3Color,
                                       light3Position,
                                       light3Attenuation);
    light3.setInfluencingBounds(boundingSphere);

    //Add a SpotLight
    Color3f light4Color = 
          new Color3f(data[14][0],data[14][1],data[14][2]);
    Point3f light4Position = 
          new Point3f(data[15][0],data[15][1],data[15][2]);
    Point3f light4Attenuation = 
          new Point3f(data[16][0],data[16][1],data[16][2]);
    Vector3f light4Direction = 
         new Vector3f(data[17][0],data[17][1],data[17][2]);
    float light4Spread = data[18][0];
    float light4Concentration = data[18][1];
    SpotLight light4 = new SpotLight(light4Color,
                                     light4Position,
                                     light4Attenuation,
                                     light4Direction,
                                     light4Spread,
                                     light4Concentration);
    light4.setInfluencingBounds(boundingSphere);    
    
    //Now add all of the spheres and the lights to the
    // scene.    
    objRoot.addChild(sphere0);    
    objRoot.addChild(objTrans1);
    objRoot.addChild(objTrans2);
    objRoot.addChild(objTrans3);
    objRoot.addChild(objTrans4);
    
    objRoot.addChild(light0);
    objRoot.addChild(light1);
    objRoot.addChild(light2);
    objRoot.addChild(light3);
    objRoot.addChild(light4);
    
    //The following statement makes it possible for the
    // event handler on the timer to remove the current
    // scene and to replace it with a new scene constructed
    // using different parameters.
    objRoot.setCapability(BranchGroup.ALLOW_DETACH);
    
    return objRoot;
    
  }//end createSceneGraph
  //-----------------------------------------------------//

  //This ActionListener services the timer events.  Each
  // time it is notified, it checks to see if the scene
  // has changed since the previous call.  If the scene has
  // changed, it removes the current scene and creates a
  // new one using new parameter values.  If the scene
  // hasn't changed, it does not create a new scene.
  public void actionPerformed(ActionEvent e){
    if(sceneHasChanged){
      //Set the flag to false to avoid rendering it on the
      // next timer event unless it has changed in the
      // meantime.
      sceneHasChanged = false;
      //Go ahead and render the scene because it has
      // changed since the last time that it was rendered.
      Locale locale = universe.getLocale();
      locale.removeBranchGraph(scene);
      scene = createSceneGraph();
      locale.addBranchGraph(scene);
    }//end if
  }//end actionPerformed
  //-----------------------------------------------------//
  
  //An object of this inner class is placed in the SOUTH
  // location of the controller.  It provides radio buttons
  // for selection of the type of shading, Gouraud or Flat.
  // It also provides radio buttons for selection of the
  // display size, large or small.
  class ButtonPanel extends Panel{
    ButtonPanel(){//constructor
      setLayout(new GridLayout(0,2));
      JRadioButton gouraudButton = 
                  new JRadioButton("Gouraud Shading",true);
      JRadioButton flatButton = 
                          new JRadioButton("Flat Shading");
      ButtonGroup shadingGroup = new ButtonGroup();
      shadingGroup.add(gouraudButton);    
      shadingGroup.add(flatButton);
      
      //Register action listeners on the buttons to provide
      // the appropriate behavior when they are selected.
      gouraudButton.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            shading = ColoringAttributes.SHADE_GOURAUD;
            //Cause the scene to be rendered on the next
            // timer event.
            sceneHasChanged = true;
          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener
      
      flatButton.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            shading = ColoringAttributes.SHADE_FLAT;
            //Cause the scene to be rendered on the next
            // timer event.
            sceneHasChanged = true;
          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener
      

      JRadioButton largeDisplay = 
                    new JRadioButton("Large Display",true);
      JRadioButton smallDisplay = 
                         new JRadioButton("Small Display");
      ButtonGroup displaySizeGroup = new ButtonGroup();
      displaySizeGroup.add(largeDisplay);
      displaySizeGroup.add(smallDisplay);
      
      //Register action listeners on the buttons to provide
      // the appropriate behavior when they are selected.
      largeDisplay.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            displayObject.setSize(largeDisplaySize);
            //Cause the scene to be rendered on the next
            // timer event.
            sceneHasChanged = true;
          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener
      
      smallDisplay.addActionListener(
        new ActionListener(){
          public void actionPerformed(ActionEvent e){
            displayObject.setSize(smallDisplaySize);
            //Cause the scene to be rendered on the next
            // timer event.
            sceneHasChanged = true;
          }//end actionPerformed
        }//end new ActionListener
      );//end addActionListener
      
      //Populate the grid from left to right, top to
      // bottom to arrange the radio buttons in the panel.
      add(gouraudButton);
      add(largeDisplay);
      add(flatButton);
      add(smallDisplay);
    }//end constructor
    
  }//end class ButtonPanel
  //-----------------------------------------------------//
  
  //An object of this inner class is located in the CENTER
  // of the main controller.  It provides radio buttons
  // along with text fields for selection of the scene
  // parameters to be changed and to display the current
  // or changed values of those parameters.
  class ControlPanel extends Panel 
                                 implements ActionListener{

    //The text fields used to display the scene property
    // values are arranged in a grid having three columns
    // and numRadioButtons rows.  Each of the following
    // arrays contains references to the text field
    // objects in one column, beginning with the left-most
    // column.
    TextField[] textFieldCol1 = 
                            new TextField[numRadioButtons];
    TextField[] textFieldCol2 = 
                            new TextField[numRadioButtons];
    TextField[] textFieldCol3 = 
                            new TextField[numRadioButtons];
    //---------------------------------------------------//
    
    //This method is called whenever the user moves an
    // enabled slider.  The incoming parameters specify
    // the slider that was moved and the new value of the
    // slider.
    void sliderChangeNotification(int slider,int value){
      //Determine which radio button was selected when the
      // slider was moved.  The new value of the slider
      // must be associated with the property specified by
      // that radio button.
      int button = getSelectedButton();
      
      //The following logic uses the radio button
      // identification along with the slider
      // identification to take the appropriate action for
      // a given combination of button and slider.
      if((button == 0)&&(slider == 0)){//facets
        if(value &lt; 4)value = 4;//clamp at 4
        //Display the new slider value in the text field.
        textFieldCol1[button].setText("" + value);
        //Record the new slider value in the data array.
        data[button][0] = value;

      }else if((button == 1)&&(slider == 0)){//shininess
        textFieldCol1[button].setText("" + (float)(value));
        data[button][0] = (float)(value);
      
      //The following buttons generally correspond to scene
      // parameters that involve location coordinates, 
      // such as directional vectors or the location of a
      // PointLight.  The scale factors used in this logic
      // support coordinate values from -10.0 to +10.0 in
      // steps of 0.1.
      }else if(((button == 8)&&(slider == 0)) ||
               ((button == 10)&&(slider == 0))||
               ((button == 12)&&(slider == 0))||
               ((button == 15)&&(slider == 0))||
               ((button == 17)&&(slider == 0))){
        textFieldCol1[button].setText(
                                 "" + (float)(value/10.0));
        data[button][0] = (float)(value/10.0);
      }else if(((button == 8)&&(slider == 1)) ||
               ((button == 10)&&(slider == 1))||
               ((button == 12)&&(slider == 1))||
               ((button == 15)&&(slider == 1))||
               ((button == 17)&&(slider == 1))){
        textFieldCol2[button].setText(
                                 "" + (float)(value/10.0));
        data[button][1] = (float)(value/10.0);
      }else if(((button == 8)&&(slider == 2)) ||
               ((button == 10)&&(slider == 2))||
               ((button == 12)&&(slider == 2))||
               ((button == 15)&&(slider == 2))||
               ((button == 17)&&(slider == 2))){
        textFieldCol3[button].setText(
                                 "" + (float)(value/10.0));
        data[button][2] = (float)(value/10.0);
        
      //The following buttons correspond to attenuation
      // values for PointLight and SpotLight.  The constant
      // attenuation value is allowed to vary from 1.0 to
      // 2.0 in steps of 0.1.  The other two attenuation
      // values are allowed to vary from 0.0 to 0.2 in
      // steps of 0.01.
      }else if(((button == 13)&&(slider == 0))||
               ((button == 16)&&(slider == 0))){
        textFieldCol1[button].setText(
                                 "" + (float)(value/10.0));
        data[button][0] = (float)(value/10.0);
      }else if(((button == 13)&&(slider == 1))||
               ((button == 16)&&(slider == 1))){
        textFieldCol2[button].setText(
                                "" + (float)(value/100.0));
        data[button][1] = (float)(value/100.0);
      }else if(((button == 13)&&(slider == 2))||
               ((button == 16)&&(slider == 2))){
        textFieldCol3[button].setText(
                                "" + (float)(value/100.0));
        data[button][2] = (float)(value/100.0);
        
      //The following button corresponds to SpotLight
      // spread angle and SpotLight concentration.  Spread
      // angle is allowed to vary from 0.0 to 0.1 radian in
      // steps of 0.01 radian.  Concentration varies from
      // 0 to 128 in integer steps of 1.
      }else if((button == 18)&&(slider == 0)){
        //SpotLight spread angle
        textFieldCol1[button].setText(
                                "" + (float)(value/100.0));
        data[button][0] = (float)(value/100.0);
      }else if((button == 18)&&(slider == 1)){
        //SpotLight concentration
        textFieldCol2[button].setText(
                                      "" + (float)(value));
        data[button][1] = (float)(value);
        
      //Process all remaining buttons alike.  Buttons
      // 2,3,4,5,6,7,9,11, and 14 correspond to scene 
      // properties requiring values for the colors red,
      // green, and blue.  These values are allowed to
      // vary from 0.0 to 1.0 in steps of 0.01.
      }else if(slider%3 == 0){
        textFieldCol1[button].setText(
                                "" + (float)(value/100.0));
        data[button][0] = (float)(value/100.0);
      }else if(slider%3 == 1){
        textFieldCol2[button].setText(
                                "" + (float)(value/100.0));
        data[button][1] = (float)(value/100.0);
      }else{
        textFieldCol3[button].setText(
                                "" + (float)(value/100.0));
        data[button][2] = (float)(value/100.0);
      }//end else

      //Cause the scene to be rendered on the next timer
      // event.
      sceneHasChanged = true;
    }//end sliderChangeNotification
    //---------------------------------------------------//
   
    //This action listener is registered on the large group
    // of radio buttons.  When a radio button is selected,
    // this action listener causes the appropriate action
    // to be taken.
    public void actionPerformed(ActionEvent e){
      int theButton = getSelectedButton();
      
      //Need to save and restore these values because
      // they get corrupted when the slider parameters are
      // changed.
      float buttonData0 = data[theButton][0];
      float buttonData1 = data[theButton][1];
      float buttonData2 = data[theButton][2];
      
      //This button corresponds to the number of facets on
      // the surface of the large sphere.  This is allowed
      // to range from 4 to 100.  Spheres with fewer than 4
      // facets don't make much sense so they are not
      // allowed
      if(theButton == 0){//facets
        //Set the range on the slider for facets.
        topSlider.setMinimum(0);
        topSlider.setMaximum(facets);
        //Restore the data value saved above.
        data[theButton][0] = buttonData0;
        //Cause the slider to be positioned at the current
        // data value.
        topSlider.setValue((int)(data[theButton][0]));
        //Set the labels above the sliders.
        topSliderLabel.setText(
                      "Facets on Surface of Large Sphere");
        middleSliderLabel.setText("Disabled");
        bottomSliderLabel.setText("Disabled");
        //Enable and disable sliders as needed.
        topSlider.setEnabled(true);
        middleSlider.setEnabled(false);
        bottomSlider.setEnabled(false);
        //Remove tick marks from disabled sliders.        
        middleSlider.setMinimum(0);
        middleSlider.setMaximum(0);
        bottomSlider.setMinimum(0);
        bottomSlider.setMaximum(0);
        //Set the column headers to match the selected
        // radio button.
        column1.setText("Facets");
        column2.setText("Not Used");
        column3.setText("Not Used");
        
      //This button corresponds to shininess.  It is
      // allowed to range from 0 to 128 integer.
      }else if(theButton == 1){
        topSlider.setMinimum(0);
        topSlider.setMaximum(128);
        data[theButton][0] = buttonData0;//restore
        topSlider.setValue((int)(data[theButton][0]));
        topSliderLabel.setText(
                   "Shininess of Surface of Large Sphere");
        middleSliderLabel.setText("Disabled");
        bottomSliderLabel.setText("Disabled");
        topSlider.setEnabled(true);
        middleSlider.setEnabled(false);
        bottomSlider.setEnabled(false);
        middleSlider.setMinimum(0);
        middleSlider.setMaximum(0);
        bottomSlider.setMinimum(0);
        bottomSlider.setMaximum(0);
        column1.setText("Shininess");
        column2.setText("Not Used");
        column3.setText("Not Used");
        
      //These buttons correspond to scene properties
      // involving color values for red, green, and blue.
      }else if((theButton == 2) || 
               (theButton == 3) || 
               (theButton == 4) || 
               (theButton == 5) || 
               (theButton == 6) || 
               (theButton == 7) || 
               (theButton == 9) || 
               (theButton == 11) ||
               (theButton == 14)){
        topSlider.setEnabled(true);
        middleSlider.setEnabled(true);
        bottomSlider.setEnabled(true);                
        topSlider.setMinimum(0);
        topSlider.setMaximum(100);
        middleSlider.setMinimum(0);
        middleSlider.setMaximum(100);
        bottomSlider.setMinimum(0);
        bottomSlider.setMaximum(100);
        data[theButton][0] = buttonData0;//restore
        data[theButton][1] = buttonData1;//restore
        data[theButton][2] = buttonData2;//restore
        topSlider.setValue((int)(100*data[theButton][0]));
        middleSlider.setValue(
                            (int)(100*data[theButton][1]));
        bottomSlider.setValue(
                            (int)(100*data[theButton][2]));
        topSliderLabel.setText(
                              "Red Color Component * 100");
        middleSliderLabel.setText(
                            "Green Color Component * 100");
        bottomSliderLabel.setText(
                             "Blue Color Component * 100");
        column1.setText("Red Color");
        column2.setText("Green Color");
        column3.setText("Blue Color");
        
      //These buttons correspond to scene properties
      // involving location coordinate values.
      }else if((theButton == 8) || 
               (theButton == 10)||
               (theButton == 12)||
               (theButton == 15)||
               (theButton == 17)){
        topSlider.setEnabled(true);
        middleSlider.setEnabled(true);
        bottomSlider.setEnabled(true);                
        topSlider.setMinimum(-100);
        topSlider.setMaximum(100);
        middleSlider.setMinimum(-100);
        middleSlider.setMaximum(100);
        bottomSlider.setMinimum(-100);
        bottomSlider.setMaximum(100);
        data[theButton][0] = buttonData0;//restore
        data[theButton][1] = buttonData1;//restore
        data[theButton][2] = buttonData2;//restore
        topSlider.setValue((int)(10*data[theButton][0]));
        middleSlider.setValue(
                             (int)(10*data[theButton][1]));
        bottomSlider.setValue(
                             (int)(10*data[theButton][2]));
        topSliderLabel.setText("X-Coordinate * 10");
        middleSliderLabel.setText("Y-Coordinate * 10");
        bottomSliderLabel.setText("Z-Coordinate * 10");
        column1.setText("X-Coordinate");
        column2.setText("Y-Coordinate");
        column3.setText("Z-Coordinate");

      //These buttons correspond to attenuation values for
      // PointLight and SpotLight objects.
      }else if((theButton == 13) ||
               (theButton == 16)){
        topSlider.setEnabled(true);
        middleSlider.setEnabled(true);
        bottomSlider.setEnabled(true);                
        topSlider.setMinimum(10);
        topSlider.setMaximum(20);
        middleSlider.setMinimum(0);
        middleSlider.setMaximum(20);
        bottomSlider.setMinimum(0);
        bottomSlider.setMaximum(20);
        data[theButton][0] = buttonData0;//restore
        data[theButton][1] = buttonData1;//restore
        data[theButton][2] = buttonData2;//restore
        
        //This constant attenuation value ends up being
        // used in the denominator of an attenuation
        // calculation.  If it is less than 1.0, it results
        // in a gain instead of an attenuation.  This
        // doesn't make sense, so it is clamped at 1.0 to
        // avoid having a gain and also to avoid division
        // by 0.
        if(data[theButton][0] &lt; 1.0f){
          data[theButton][0] = 1.0f;
        }//end if
        
        topSlider.setValue((int)(10*data[theButton][0]));
        middleSlider.setValue(
                            (int)(100*data[theButton][1]));
        bottomSlider.setValue(
                            (int)(100*data[theButton][2]));
        topSliderLabel.setText(
                              "Constant Attenuation * 10");
        middleSliderLabel.setText(
                               "Linear Attenuation * 100");
        bottomSliderLabel.setText(
                            "Quadratic Attenuation * 100");
        column1.setText("ConstantAttenuation");
        column2.setText("LinearAttenuation");
        column3.setText("QuadraticAttenuation");

      //This button corresponds to SpotLight spread antle
      // and concentration.
      }else if(theButton == 18){
        topSlider.setEnabled(true);
        middleSlider.setEnabled(true);
        bottomSlider.setEnabled(false);                
        topSlider.setMinimum(0);
        topSlider.setMaximum(10);
        middleSlider.setMinimum(0);
        middleSlider.setMaximum(128);
        bottomSlider.setMinimum(0);
        bottomSlider.setMaximum(0);
        data[theButton][0] = buttonData0;//restore
        data[theButton][1] = buttonData1;//restore
        data[theButton][2] = buttonData2;//restore        
        topSlider.setValue((int)(100*data[theButton][0]));
        middleSlider.setValue((int)(data[theButton][1]));
        topSliderLabel.setText(
                "SpotLight Spread Angle in Radians * 100");
        middleSliderLabel.setText(
                                "SpotLight Concentration");
        bottomSliderLabel.setText("Disabled");
        column1.setText("SpotLight Spread");
        column2.setText("SpotLight Concen.");
        column3.setText("Not Used");
        textFieldCol3[18].setText("Not Used");
      }//end else
      
      //Cause the scene to be rendered on the next timer
      // event.
      sceneHasChanged = true;
      
    }//end actionPerformed
    //---------------------------------------------------//
    
    //This method scans the group of main radio buttons to
    // determine which one has been selected.
    int getSelectedButton(){
      for(int cnt = 0;cnt &lt; numRadioButtons;cnt++){
        if(radioButtonArray[cnt].isSelected()){
          return cnt;
        }//end if
      }//end for loop
      return 0;//Make the compiler happy
    }//end getSelectedButton
    //---------------------------------------------------//

    ControlPanel(){//constructor

      //Initialize some special data values
      data[0][0] = facets/2;
      //Constant attenuation for PointLight
      data[13][0] = 1.0f;
      //Constant attenuation for SpotLight
      data[16][0] = 1.0f;

      data[1][0] = shininess;
      //Force sphere0 to be visible at startup with a red
      // reflective color and a red directional light
      // shining toward the origin of the z-plane from
      // above the user's right shoulder.
      data[4][0] = 1.0f;//Diffuse color red
      data[7][0] = 1.0f;//Diffuse light red
      data[8][0] = -1.0f;//DirectionalLight 1 vector
      data[8][1] = -1.0f;//DirectionalLight 1 vector
      data[8][2] = -1.0f;//DirectionalLight 1 vector
      
      setLayout(new GridLayout(0,4));
      //Add column headers.  Note that these are the
      // column headers that appear at startup.  They will
      // change later as the user selects different radio
      // buttons.  When the user selects a radio button,
      // the headers change to match the context of the
      // selected button.
      Label column0 = new Label("Item",Label.CENTER);
      add(column0);
      column1 = new Label("Num or X or Red",Label.CENTER);
      add(column1);
      column2 = new Label(
                         "Num or Y or Green",Label.CENTER);
      add(column2);
      column3 = new Label("Num or Z or Blue",Label.CENTER);
      add(column3);
      
      ButtonGroup buttonGroup = new ButtonGroup();
      
      //Create radio buttons and text fields.  Disable all
      // of the text fields to prevent user input.  They
      // are used for display only.  User input is
      // accomplished using the sliders.  Text fields are
      // initialized to default values when constructed.
      for(int cnt = 0;cnt &lt; numRadioButtons;cnt++){
        //Note that the labels on the radio buttons will be
        // modified later to more accurately describe the
        // scene property associated with each radio
        // button.
        radioButtonArray[cnt] = new JRadioButton("OK");
        //Register an action listener to adjust the slider
        // when a radio button is selected.
        radioButtonArray[cnt].addActionListener(this);
        buttonGroup.add(radioButtonArray[cnt]);
        //Now the text fields.
        textFieldCol1[cnt] = new TextField(
                                        "" + data[cnt][0]);
        textFieldCol1[cnt].setEnabled(false);
        textFieldCol2[cnt] = new TextField(
                                        "" + data[cnt][1]);
        textFieldCol2[cnt].setEnabled(false);
        textFieldCol3[cnt] = new TextField(
                                        "" + data[cnt][2]);
        textFieldCol3[cnt].setEnabled(false);
      }//end for loop
    
      //Go back and modify some initial values
      textFieldCol2[0].setText("Not Used");
      textFieldCol3[0].setText("Not Used");      
      textFieldCol2[1].setText("Not Used");
      textFieldCol3[1].setText("Not Used");
      textFieldCol3[18].setText("Not Used");

      //Label the radio buttons
      radioButtonArray[0].setText("Facets");
      radioButtonArray[1].setText("Shininess");
      radioButtonArray[2].setText("Emissive Color");
      radioButtonArray[3].setText("Ambient Color");
      radioButtonArray[4].setText("Diffuse Color");
      radioButtonArray[5].setText("Specular Color");
      radioButtonArray[6].setText("AmbientLight");
      radioButtonArray[7].setText("DirctnlLight 1");
      radioButtonArray[8].setText("DirctnlVector 1");
      radioButtonArray[9].setText("DirctnlLight 2");
      radioButtonArray[10].setText("DirctnlVector 2");
      radioButtonArray[11].setText("PointLightColor");
      radioButtonArray[12].setText("PointLight Loc");
      radioButtonArray[13].setText("PointLight Atten");
      radioButtonArray[14].setText("SpotLt Color");
      radioButtonArray[15].setText("SpotLt Loc");
      radioButtonArray[16].setText("SpotLt Atten");
      radioButtonArray[17].setText("SpotLt Vector");
      radioButtonArray[18].setText("SpotLt SprCon");
      
      //Populate the control panel
      for(int cnt = 0;cnt &lt; numRadioButtons;cnt++){
        add(radioButtonArray[cnt]);
        add(textFieldCol1[cnt]);
        add(textFieldCol2[cnt]);
        add(textFieldCol3[cnt]);
      }//end for loop

    }//end constructor

  }//end inner class ControlPanel
  //-----------------------------------------------------//
  
  //An object of this inner class is located in the NORTH
  // of the main controller.  It provides the sliders
  // by which the user modifies the scene parameters.
  class SliderPanel extends Panel{
  
    SliderPanel(){//constructor
      setLayout(new GridLayout(0,1));
      
      Label titleLabel = new Label(
             "JAVA 3D ILLUMINATION AND LIGHTING SIMULATOR",
                                             Label.CENTER);
      add(titleLabel);

      //Construct the top slider.
      add(topSliderLabel);
      topSlider = new JSlider(0,0,0);
      //Note that the following tick mark specifications
      // are used throughout.
      topSlider.setMajorTickSpacing(10);
      topSlider.setMinorTickSpacing(1);
      topSlider.setPaintTicks(true);
      topSlider.setPaintLabels(true);
      topSlider.setSnapToTicks(true);
      //Create the text that appears at startup.
      topSliderLabel.setText(
                "Select a Radio Button to Enable Sliders");
      topSlider.setEnabled(false);

      //Register a listener object that will be notified
      // whenever the slider position is changed while it
      // it is enabled.
      topSlider.addChangeListener(
        new ChangeListener(){
          public void stateChanged(ChangeEvent e){
            JSlider source = (JSlider)e.getSource();
            controlPanel.sliderChangeNotification(
                                      0,source.getValue());
          }//end stateChanged
        }//end new ChangeListener
      );//end addChangeListener
      
      //Add the slider to the display.
      add(topSlider);
      
      //Construct the middle slider.
      add(middleSliderLabel);
      middleSlider = new JSlider(0,0,0);
      middleSlider.setMajorTickSpacing(10);
      middleSlider.setMinorTickSpacing(1);
      middleSlider.setPaintTicks(true);
      middleSlider.setPaintLabels(true);
      middleSlider.setSnapToTicks(true);
      middleSliderLabel.setText("Disabled");
      middleSlider.setEnabled(false);

      middleSlider.addChangeListener(
        new ChangeListener(){
          public void stateChanged(ChangeEvent e){
            JSlider source = (JSlider)e.getSource();
            controlPanel.sliderChangeNotification(
                                      1,source.getValue());
          }//end stateChanged
        }//end new ChangeListener
      );//end addChangeListener
      
      add(middleSlider);
      
      //Construct the bottom slider.
      add(bottomSliderLabel);
      bottomSlider = new JSlider(0,0,0);
      bottomSlider.setMajorTickSpacing(10);
      bottomSlider.setMinorTickSpacing(1);
      bottomSlider.setPaintTicks(true);
      bottomSlider.setPaintLabels(true);
      bottomSlider.setSnapToTicks(true);
      bottomSliderLabel.setText("Disabled");
      bottomSlider.setEnabled(false);

      bottomSlider.addChangeListener(
        new ChangeListener(){
          public void stateChanged(ChangeEvent e){
            JSlider source = (JSlider)e.getSource();
            controlPanel.sliderChangeNotification(
                                      2,source.getValue());
          }//end stateChanged
        }//end new ChangeListener
      );//end addChangeListener
      
      add(bottomSlider);

    }//end constructor
  }//end inner class SliderPanel
  //-----------------------------------------------------//
}//end class Lighting3D04
<br><br><b><font face="Courier New,Courier"><a href="#Listing_1">Listing 1</a></font></b></pre></td></tr></tbody></table><p> </p>
<p>&nbsp;</p><p> </p>
<hr align="center" size="3" width="100%">
<p>Copyright 2006, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4>About the author</h4><b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
java 3D facet shading sphere emissive color ambient reflection surface 
reflection diffuse shininess specular shadow specular Gouraud</p>
<p>-end- </p>
<p>&nbsp;</p>
<p> <br>
&nbsp; </p>
<br>
<br>
<br>
<br>
</body>
</html>
