<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Getting Started in Java by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Object-Oriented Programming<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 4, Revised 07/25/01. </P>
<P>
<!-toc file=Java004a.htm words=Preface-><A HREF="#preface">Preface</A><BR><!--endtoc-->
<!-toc file=Java004b.htm words=Introduction-><A HREF="#introduction">Introduction</A><BR><!--endtoc-->
<!-toc file=Java004c.htm words=An Introductory Description of OOP-><A HREF="#an initial description of oop">An Introductory Description of OOP</A><BR><!--endtoc-->
<!-toc file=Java004d.htm words=Encapsulation-><A HREF="#encapsulation in general">Encapsulation</A><BR><!--endtoc-->
<!-toc file=Java004e.htm words=Inheritance-><A HREF="#inheritance">Inheritance</A><BR><!--endtoc-->
<!-toc file=Java004f.htm words=Polymorphism-><A HREF="#polymorphism in general">Polymorphism</A><BR><!--endtoc-->
<!-toc file=Java004g.htm words=Exception Handling-><A HREF="#exception handling">Exception Handling</A><BR><!--endtoc-->
<!-toc file=Java004h.htm words=Intro to Object-Oriented Design-><A HREF="#object-oriented design guidelines">Intro to Object-Oriented Design</A><BR><!--endtoc-->
<!-toc file=Java004i.htm words=OOD/OOP Versus Traditional Techniques-><A HREF="#ood/oop versus traditional techniques">OOD/OOP Versus Traditional Techniques</A><BR><!--endtoc-->
<!-toc file=Java004j.htm words=Minimum Knowledge Requirements for OOD/OOP-><A HREF="#minimum knowledge requirements for ood/oop">Minimum Knowledge Requirements for OOD/OOP</A><BR><!--endtoc-->
<!-toc file=Java004k.htm words=Program Specification-><A HREF="#program specification:">Program Specification</A><BR><!--endtoc-->
<!-toc file=Java004l.htm words=Conclusions Regarding Minimal Knowledge-><A HREF="#conclusions regarding minimal knowledge">Conclusions Regarding Minimal Knowledge</A><BR><!--endtoc-->
<!-toc file=Java004m.htm words=Analysis and Design Results, Summary-><A HREF="#analysis and design results, summary:">Analysis and Design Results, Summary</A><BR><!--endtoc-->
<!-toc file=Java004n.htm words=Discussion-><A HREF="#discussion">Discussion</A><BR><!--endtoc-->
<!-toc file=Java004o.htm words=Interesting Code Fragments for Thermostat Program-><A HREF="#interesting code fragments for thermostat program">Interesting Code Fragments for Thermostat Program</A><BR><!--endtoc-->
<!-toc file=Java004p.htm words=Program Listing for Thermostat Program-><A HREF="#program listing for thermostat program">Program Listing for Thermostat Program</A><BR><!--endtoc-->
<!-toc file=Java004q.htm words=Noun/Verb Analysis and Design-><A HREF="#noun/verb analysis and design">Noun/Verb Analysis and Design</A><BR><!--endtoc-->
<!-toc file=Java004r.htm words=Review-><A HREF="#review questions for lesson 4">Review</A><!--endtoc-->
</P>

<!-next=Java004a.htm><!-first=Java004.htm->
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>By the end of the course, students in Prof. Baldwin's <B><U>Introductory Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this lesson (except that they are not responsible for detailed information that is specific to C++). </P>
<P>The detailed material on C++ is provided as supplementary material for the benefit of persons already familiar with C++ who are making the transition into Java. </P>
<P>This lesson is designed primarily as a reading assignment. It is not likely that Prof. Baldwin will spend any class time discussing the material in this lesson. However, he will respond to specific questions from students regarding the material in this lesson. </P>
<P>This lesson is intended to be general in nature. Therefore, no effort has been expended to keep it in compliance with any particular version of the Java JDK. </P>
<P>This lesson is a compilation of ideas and examples (a few of which are my own) from a variety of authors. Let me apologize in advance to those authors whose ideas I may have included without giving specific credit. If you, as an author, see one of your original ideas here without proper credit being given, please notify me by E-mail and I will be pleased to footnote the document to give you credit for that specific idea (or remove your idea from the document if that is your preference). </P>

<P><!-prev=Java004.htm-><!-next=Java004b.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><P>This lesson concentrates on Object-Oriented Programming (OOP). The lesson is intended to be independent of any specific language. As a practical matter, it is necessary to use some language for illustration purposes, and rather than to conjure up some artificial language, examples in this lesson are provided using either the Java or the C++ programming language. </P>
<P>Some languages such as C do not readily support OOP. Other languages such as C++ support OOP, but don't require you to use the object-oriented features of the language. </P>
<P>Still other languages such as Java require you to program using OOP techniques. In particular, it is not possible to write a program in Java without taking an object-oriented approach. You may do a good job, or you may do a poor job, but you must program using objects in Java. </P>
<P>Since C++ does not enforce a requirement to write object-oriented programs, it is possible to learn to use major aspects of the C++ language without ever learning to use the object-oriented features. In that case, the major challenge is simply learning to use the rudiments of the language. </P>
<P>On the other hand, the real challenge in becoming a Java programmer is not simply to learn the language. Even though the language contains some very sophisticated features such as multi-threading, it is not a complex language and is not particularly difficult to learn. Persons capable of programming in Pascal or C should be able to master the core aspects of the language with a modest effort. </P>
<P>The real challenge in becoming a Java programmer lies in two areas: </P>

<UL>
<LI>Learning to productively utilize the large set of class libraries containing dozens of classes and hundreds of methods which are provided as part of the Java Development Kit to supplement the language. </LI>
<LI>Learning to design and program in the object-oriented paradigm.</LI></UL>

<P>The first of these challenges can be met on a gradual basis. In other words, it is not necessary to know the entire class library to produce useful Java programs. </P>
<P>The second challenge cannot be met on a gradual basis. It is not possible to create even the simplest Java program without programming in the object-oriented paradigm. </P>
<P>The technical prerequisite for this lesson is the ability to successfully write programs in Pascal or some other suitable modern structured programming or scripting language. It is assumed that students in this lesson are <B>not </B>familiar with OOP. </P>
<P>This lesson provides a discussion of OOP from both a theoretical and a practical viewpoint. In other words, </P>

<UL>
<LI>what is OOP, </LI>
<LI>why is it important, and</LI></UL>

<P>This lesson also provides a <U>very brief</U> introduction to object-oriented design (OOD) and introduces a methodology for performing the first pass of an object-oriented design. However, this lesson will not endeavor to teach OOD to any significant depth. OOD is a very complex topic that is reserved for other lessons. </P>
<P>Finally, this lesson attempts to determine the minimum skill set that would be required of a beginning programmer before that programmer would have the ability to design and implement a program using object-oriented techniques. </P>

<P><!-prev=Java004a.htm-><!-next=Java004c.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="an_initial_description_of_oop"></A>An Introductory Description of OOP</H2>
</FONT><P>An introductory description of OOP can be based on the following guideline: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>The solution to the problem should resemble the problem, and observers of the solution should be able to recognize the problem without necessarily knowing about it in advance.</TD>
</TR>
</TABLE>

<P>A good example of this guideline from the computing world is the use of OOP to develop a <B>stack </B>class from which stack objects can be instantiated. If a stack is implemented as a <B>class</B>, instantiated as an <B>object</B>, and <U>documented</U> appropriately, programmers familiar with stacks, queues, and other similar data structures will recognize it as a stack without other prior knowledge. </P>
<P>Many "application frameworks" are written according to the OOP paradigm. Important among these is the Borland ObjectWindows Library (OWL) which can be used to simplify the development of the Graphical User Interface (GUI) portions of Windows programs. This package and other similar application frameworks use C++ class libraries to encapsulate the interface and implementation of the operating platform's applications programing interface (API). While the use of the OWL does not make it easy to develop GUI programs, the use of the OWL does greatly reduce the complexity of such development. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="an_object_oriented_world"></A>An Object-Oriented World</H3>
</FONT><P>We are object-oriented creatures living in an object-oriented world. We tend to think in object-oriented ways. </P>
<P>For example, when planning a motor trip, we usually think first about the best way to get from point A to point B without being too concerned about how to get through the traffic in each of the cities along the way. </P>
<P>Once we are satisfied that we have the overall route mapped out appropriately, we may go back and begin thinking about the details, such as how to avoid five-oclock traffic in a particular city, where is the best place to stop for the night, is there some particular restaurant that we want to visit, and if so, how can we arrange the timing so as to arrive there at dinner time, etc. This is object-oriented thinking. </P>
<P>Previous approaches to programming (pre-OOP) tend to separate the data from the methods used to manipulate that data, or at least don't strongly encourage them to be considered in concert. </P>
<P>The world and its applications are not organized into values and procedures separate from one another. People who solve problems in other crafts do not perceive the world that way. They deal with their problem domains by concentrating on the objects and letting the characteristics of those objects determine the procedures to apply to them. </P>
<P>To build a house, fix a flat tire, or repair a carburetor, you first think about the object and its purpose and behavior. Then you select your tools and procedures. <U>The solution fits the problem</U>. </P>
<P>Any object-oriented language must support three very important concepts: </P>

<UL>
<LI>encapsulation, </LI>
<LI>inheritance, </LI>
<LI>polymorphism.</LI></UL>

<P>We use these three concepts extensively as we attempt to model the real-world problems that we are trying to solve with our object-oriented programs. </P>

<P><!-prev=Java004b.htm-><!-next=Java004d.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H4>Encapsulation Example</H4>
</FONT><P>Consider the steering mechanism of a car as real-world an example of <B>encapsulation. </B>During the past eighty years or so, the steering mechanism has evolved into an <I>object </I>in the OOP sense. In particular, most of us know how to use the steering mechanism of an automobile without having any idea whatsoever how it is implemented. All most of us care about is the <I>interface </I>which we refer to as a steering wheel. We know that if we turn the steering wheel clockwise, the automobile will turn to the right, and if we turn it counterclockwise, the car will turn to the left. </P>
<P>Most of us don't know, and don't really care, how the steering mechanism is actually implemented "under the hood." In fact, there are probably a number of different implementations for various brands and models of automobiles. Regardless of the brand and model, however, the human interface is pretty much the same. Clockwise turns to the right, counterclockwise turns to the left. </P>
<P>To appreciate the importance of this standard interface, attach a short rental trailer to your car and try backing it into your driveway. Turning the steering wheel counterclockwise causes the trailer to turn to the right and clockwise causes the trailer to turn to the left; just the <U>opposite</U> from the above. Most of us aren't accustomed to this interface and have some difficulty using it, at least initially. It is probably safe to suggest that the human factors aspect of the interface to the steering mechanism in your car wasn't designed for backing up with a trailer attached. (The trick to adapting the interface is to put you hand on the bottom of the steering wheel instead of the top.) </P>
<P>In any event, as in the steering mechanism for a car, a common approach in OOP is to "hide the implementation" and "expose the interface" through <I>encapsulation.</P>

<P><!-prev=Java004c.htm-><!-next=Java004e.htm><!-first=Java004.htm-></P>
</I><FONT COLOR="#ff0000"><H4>Inheritance Example</H4>
</FONT><P>Another important aspect of OOP is <I>inheritance</I>. Let's form an analogy with the teenager who is building a hotrod. That teenager doesn't normally start with a large chunk of steel and carve an engine out of it. Rather, the teenager will usually start with an existing engine and make improvements on it. In OOP lingo, that teenager <I>extends</I> the existing engine, <I>derives </I>from the existing engine, <I>inherits </I>from the existing engine, or <I>subclasses </I>the existing engine. </P>
<P>Just like in "souping up" an engine for a hotrod, a very common practice in OOP is to create new improved objects using new definitions that <I>extend</I> existing definitions. In fact, one of the major arguments in favor of OOP is that it provides a formal mechanism which encourages the reuse of existing programming elements. One of the mottos of OOP is: reuse, don't reinvent. </P>

<P><!-prev=Java004d.htm-><!-next=Java004f.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H4>Polymorphism Example</H4>
</FONT><P>A third important aspect of OOP is <I>polymorphism</I>. This is a greek word meaning something like <I>one name, many forms</I>. This is a little more difficult to explain in non-programming terminology. However, we will stretch our imagination a little and say that polymorphism is somewhat akin to the automatic transmission in your car. In my Honda, for example, the automatic transmission has four different <I>methods </I>or <I>functions</I> known collectively as <I>Drive</I> (in addition to the functions of <I>Reverse</I>, <I>Park</I>, and <I>Neutral</I>). </P>
<P>As an operator of the automobile, I simply select <I>Drive</I> (meaning go forward). Depending on various conditions at <I>runtime</I>, the automatic transmission system decides <U>which version</U> of the <I>Drive</I> function to use in every specific situation. The specific version of the function that is used is based on the current conditions. This is somewhat analogous to what we will later refer to as <I>runtime polymorphism</I>. </P>
<P>I also believe it is true that my Honda has only one <I>method</I> which we refer to as <I>Reverse</I>. Once I select <I>Reverse</I>, that one method gets used. There is no automatic selection among multiple <I>reverse </I>methods. Therefore, my Honda exhibits polymorphic behavior when going in the forward direction, but exhibits non-polymorphic behavior when going backwards. </P>
<FONT COLOR="#ff0000"><H4>Summary</H4>
</FONT><P>The world is object-oriented, and the object-oriented programming paradigm attempts to express computer programs in ways that model how people perceive the world. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="object_oriented_programming"></A>Object-Oriented Programming Vocabulary</H3>
</FONT><P>OOP involves a whole new vocabulary (or jargon) which is different from or supplemental to the vocabulary of procedural programming. </P>
<P>For example the object-oriented programmer defines an <I>abstract data type</I> by <I>encapsulating </I>its <I>implementation </I>and its <I>interface </I>into a <I>class</I>. </P>
<P>One or more <I>instances </I>of the class can then be <I>instantiated</I>. </P>
<P>An <I>instance </I>of a class is known as an <I>object</I>. </P>
<P>Every <I>object </I>has <I>state </I>and <I>behavior </I>where the <I>state </I>is determined by the current values stored in the <I>instance variables</I> and the <I>behavior </I>is determined by the <I>instance methods</I> of the class from which the <I>object </I>was <I>instantiated</I>. </P>
<I><P>Inherited abstract data types </I>are <I>derived classes</I> or <I>subclasses </I>of <I>base classes</I> or <I>superclasses</I>. We <I>extend</I> <I>superclasses </I>to create <I>subclasses</I>. </P>
<P>Within the program the programmer <I>instantiates objects</I> (creates <I>instances </I>of <I>classes</I>) and sends <I>messages </I>to the <I>objects </I>by invoking the class's <I>methods </I>(or <I>member functions</I>). </P>
<P>If a program is "object oriented", it uses <B>encapsulation</B>, <B>inheritance</B>, and <B>polymorphism</B>. It defines <I>abstract data types</I>, <I>encapsulates </I>those abstract data types into <I>classes</I>, <I>instantiates objects</I>, and <I>sends messages</I> to the <I>objects</I>. </P>
<P>To make things even more confusing, almost every item or action used in the OOP jargon has evolved to be described by several different terms. For example, we can cause an object to <I>change its state</I> by <I>sending it a message</I>, <I>invoking its methods</I>, or <I>calling its member functions</I>. The term being used often depends on the author who wrote the specific book that you happen to be reading at the time. </P>
<P>Hopefully most of this terminology will become clear as we pursue this lesson. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="the_characteristics_of_an_object_oriente"></A>The Overall Characteristics of an Object-Oriented Program</H3>
</FONT><P>An object-oriented program has three <I>explicit </I>characteristics and one <I>implicit </I>characteristic. The three explicit characteristics are <B>encapsulation</B>, <B>inheritance</B>, and <B>polymorphism</B>. The implicit characteristic is <B>abstraction</B>. </P>
<P>The implicit characteristic of <B>abstraction </B>is used to <U>specify</U> new <I>abstract data types </I>(ADT). </P>
<B><P>Encapsulation </B>is used to gather an ADT's <I>data representation</I> and its <I>behavior</I> into one encapsulated entity (to convert from the abstract to the concrete). You might think of this as being similar to converting an idea for an invention into a set of blueprints from which it can be built, or converting a set of written specifications for a widget to a set of drawings that can be used by the machine shop to build the widget. </P>
<P>Automotive engineers encapsulated the specifications for the steering mechanism of my car into an object where they <I>exposed the interface</I> (steering wheel) and <I>hid the implementation </I>(levers, bolts, etc.). In all likelihood, the steering mechanism object contains a number of other more-specialized <I>embedded objects</I>, each of which has <I>state</I> and <I>behavior</I> and has <I>interface</I> and <I>implementation</I>. The interfaces to those embedded objects aren't exposed to me, but they are exposed to the other parts of the steering mechanism that use them. </P>
<B><P>Inheritance </B>is used to derive a new data type from an existing one. (reuse, don't reinvent.) </P>
<P>The teenager building the hotrod doesn't reinvent the engine, rather he <I>extended </I>an existing engine to produce a new type of engine that will run faster. </P>
<B><P>Polymorphism </B>is used to customize the behavior of an instance of a type (an object) based on existing conditions. </P>
<P>The automatic transmission in my car <I>modifies its behavior</I> at <I>runtime </I>on the basis of existing conditions. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="an_object"></A>What is An Object</H3>
</FONT><P>Before getting into a detailed discussion of <B>encapsulation</B>, <B>inheritance</B>, and <B>polymorphism</B>, let's consider some basic questions. </P>

<UL>
<LI>What are the objects in OOP? </LI>
<LI>What should be the objects in the design of an object-oriented program? </LI>
<LI>What is it about OOP that sets it apart from and possibly makes it better than traditional procedural programming?</LI></UL>

<P>This lesson will concentrate primarily on the first and third questions, and will provide a very brief introduction to object-oriented design near the end. </P>
<P>Simply stated, and taking a <U>very liberal view:</U><BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>An object is an <B>instance </B>of a data <B>type</B>.</TD>
</TR>
</TABLE>

<P>The following C++ code fragment declares two objects. The first object is an instance of a simple integer variable named <B>ndays</B>. (Some authors would not agree that an instance of an integer is actually an object, but this author is taking a very liberal view at this point for purposes of illustration.) </P>
<P>The second object is an instance of an abstract data type where the object is named <B>cdt </B>and the abstract data type is named <B>Date</B>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>void f()
{
&nbsp; ...
  int ndays; //an instance of an int
  //an instance of abstract data type identified as Date
  Date cdt; 
&nbsp; ...&nbsp;
}</PRE></TD>
</TR>
</TABLE>

<P>You probably already know, or can surmise, where the integer data type comes from. It is a type which, along with <B>float, long, double</B>, etc., is intrinsic to C, C++, and Java. In other words, it is one of the <I>primitive </I>types of the language. </P>
<P>It is assumed that you don't know about the abstract data type named <B>Date</B>. During this lesson, you will learn, in concept at least, how to define new data types and how to create instances of them (objects). </P>
<P>So, what are the objects? Again, taking a <U>very liberal view</U>, objects are the variables that you declare using either data types which are <I>intrinsic </I>to the programming language, or <I>new data types</I> that you invent. </P>
<P>Many authors would not use the term <I>object </I>for variables of the primitive or intrinsic types, but would reserve the term <I>object </I>for variables of newly-defined types which are <U>not</U> intrinsic to the language. This author <U>generally agrees</U> with that philosophy. Usually in this lesson, when we use the word <I>object</I>, we will be referring to a variable of a type which is <U>not intrinsic to the language</U>. The intrinsic types have been included up to this point simply for illustration, in an attempt to bridge the gap and remove some of the mystery from the subject. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="abstraction"></A>Abstraction</H2>
</FONT><P>The <I>implicit characteristic</I> of an object-oriented program is <B>Abstraction</B>. Abstraction is the specification of an abstract data type, which includes a specification of the type's <I>data representation</I> and <I>behavior</I>. In particular, </P>

<UL>
<LI>what kind of data can be stored in an entity of the new type, and </LI>
<LI>what are all the ways that that data can be manipulated.</LI></UL>

<P>For our purposes, an abstract data type is a new type (not intrinsic to the language). It is not one of the primitive data types that are built into the programming language (such as int, long, float, etc.). </P>
<P>The distinction in the previous paragraph is very important. The data representation and behavior of the intrinsic or primitive types is already known to the compiler and cannot be modified by the programmer. </P>
<P>The representation and behavior of an abstract type is not known to the compiler until it is specified by the programmer and presented to the compiler in an appropriate manner. </P>
<P>How do we present the specification of an abstract type to the compiler? Java and C++ programmers define the <I>data representation</I> and the <I>behavior </I>of a new type (present the specification to the compiler) using the keyword <B>class </B>(C++ programmers can also use the keywords <B>struct</B> and <B>union</B>). </P>
<P>In other words, in Java and C++, the keyword <B>class </B>is used to convert the specification of a new type into something that the compiler can work with; a <I>set of plans</I> as it were. </P>
<P>Other languages may use different mechanisms to present the specification of the abstract type to the compiler. </P>
<P>Once the new type is defined, one or more objects of that type can be brought into being (instantiated, caused to occupy memory). </P>
<P>Once instantiated, the object is said to have <I>state </I>and <I>behavior</I>. The <I>state </I>of an object is determined by the current values of its data (instance variables) and the <I>behavior </I>of an object is determined by its methods (member functions or instance methods). </P>
<P>For example, again taking some liberties, if we view a GUI button as an object, it is fairly easy to visualize state and behavior. </P>
<P>A GUI button can usually manifest any of a number of different states: size, position, depressed image, not depressed image, caption, etc. Each of these states is determined by data stored in the <I>instance variables</I> of the <I>button object</I> at any given point in time. (The combination of one or more <I>instance variables</I> that determine a particular <I>state</I> are often referred to as a <I>property</I> of the object.) </P>
<P>Similarly, it is not too difficult to visualize the behavior of a GUI button. When you click it with the mouse, that usually causes some specific action to take place. </P>
<P>In fact, if you dig deeply enough into GUI programming tools, you will probably find that there is a class of button of which each individual button is an instance (object). </P>
<P>Each individual button object has <I>instance variables</I>, the values of which define the <I>state </I>of the button at any given time. </P>
<P>Every instance of the button class has certain fundamental behavior (respond to a click event, respond to a mouse dragover, etc.) which can be used to trigger some higher level action. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="sample_class_definition_in_java"></A>Sample Class Definition</H2>
</FONT><P>We have probably reached the point in this discussion where we should provide a real example so that you can cast some of these concepts into the real world. </P>
<P>The boldface portion of the following Java program creates an abstract data type by expressing its data representation and behavior using the <B>class </B>keyword. The compiler knows nothing about this new data type (at least not until it is defined by the programmer). In case you are interested, this Java program displays the date 4/8/37 as a string on the console screen. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>import java.util.*;

<B>//define a new type using keyword class
class MyDateClass { 
  int month, day, year; // instance variables of the class

  //instance method to store data
  void setDate(int mo, int da, int yr)&nbsp;
    {
    month = mo;
    day = da;
    year = yr;
  }//end method setDate()

  String getDate()//instance method to get data
  {
    return "" + month + "/" + day + "/" + year;
  }// end method getDate()

}//end class MyDateClass definition

</B>//Driver program follows
class java1 { //define the controlling class
  public static void main(String[] args){ //define main
    MyDateClass obj = new MyDateClass(); //instantiate obj
    obj.setDate(4,8,37); //store data in instance variables
    //get and display instance variables
    System.out.println( obj.getDate() );
  }//end main
}//end java1 class</PRE></TD>
</TR>
</TABLE>

<P>This abstract data type named <B>MyDateClass </B>has <B>month</B>, <B>day</B>, and <B>year </B>data members (<I>instance variables</I>). </P>
<P>The <I>behavior </I>of the new type is defined by two <I>instance methods</I>. One can be used to store a date in an object of the new type. The other can be used to retrieve a stored date from the object. </P>
<P>The new type could be expanded to incorporate other behaviors by providing additional methods. </P>
<P>Having defined the new type, we can (and do) create instances of the type (objects) and deal with those objects much as we would deal with any other variables created from the primitive data types. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="encapsulation_in_general"></A>Encapsulation</H2>
</FONT><P>The first of the three major characteristics of an object-oriented program is encapsulation. If abstraction is the <I>design</I> or <I>specification </I>of a new type, then encapsulation is its <I>definition </I>and <I>implementation</I>. </P>
<P>A programmer encapsulates the <I>data representation</I> and <I>behavior </I>of an abstract data type into a <B>class</B>, thereby defining its <I>implementation </I>and <I>interface</I>. </P>
<P>According to good object-oriented programming practice, an encapsulated design usually <U>hides its implementation</U> from the class user and <U>reveals only its interface</U>. This is accomplished in different ways with different languages as described below. </P>
<P>Just as most of us don't usually need to care about how the steering mechanism of a car is implemented, a user of a class should not need to care about the details of implementation -- only that it works as advertised. Of course this assumes that the user of the class has access to good documentation describing the class. </P>
<P>For a properly designed class, the class designer should be able to change the implementation -- perhaps changing the date representation to a long integer count of days since January 1, 1970 in the above program -- and the using programs should not be affected by the change. </P>
<P>Various object-oriented programming languages provide the ability to control access to the members of a class. For example, both C++ and Java use the keywords <B>public</B><I>, </I><B>private</B>, and <B>protected </B>to control access to the individual members of a class. To a first approximation, at least, you can probably guess what <B>public</B> and <B>private </B>mean. The <B>protected</B> keyword is used to provide inherited classes with special access privileges to the members of their base classes. (Java has some subtle complexities, related to access within a <I>package</I> which won't be discussed here.) </P>
<P>In general, the <I>interface </I>of a class which is visible to the user of the class consists of the <B>public </B>methods. The class user stores, reads, and modifies values in the data representation by invoking those methods with respect to a specific instance (object) of the class (sometimes referred to as sending a message to the object asking it to change its state). </P>
<P>Normally, if the class is properly designed, (the implementation is hid) the <U>user cannot modify</U> the values contained in the instance variables of the object without going through the prescribed interface (normally you cannot cause your car to change direction without turning the steering wheel). </P>
<P>The class interface in the above example program consists of a <I>set </I>method and a <I>get</I> method. The <I>set </I>method is used to store new data into the instance variables of an object of the class. The <I>get </I>method is used to retrieve or fetch the values stored in the instance variables of an object of the class. </P>
<P>Note however that because of the complexity introduced by the <I>package</I> concept in Java, and because of the desire to keep this program as simple as possible, no attempt was made to <I>hide the implementation</I>. The primary purpose of this program was to provide a <U>first look at classes</U> and it is not a well-designed program from an object-oriented programming viewpoint. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>As an aside, methods whose names begin with <I>set</I> and <I>get</I> have a special significance in Java. In particular, the introspection capability of the Java Beans API considers these names to represent <I>design patterns</I> for manipulating the <I>properties</I> of an object.</TD>
</TR>
</TABLE>

<P>An object-oriented design is <U>not a good design by default</U>. In an attempt to produce good designs, experienced object-oriented programmers generally agree on certain design standards for classes. For example, the data members (instance variables) are usually <B>private</B>. The interface usually consists only of methods and includes few if any data members. </P>
<P>One exception to this general rule is that often data members which are intended to be used as symbolic constants are made public and defined in such a way that their values cannot be modified. </P>
<P>The methods in the interface should control access to, or provide a pathway to, the private instance variables. The interface should be generic in that it is <U>not bound to any particular implementation</U>. Hence, the class author should be able to change the implementation without affecting the using programs so long as the interface doesn't change. In practice, this means that the signatures of the interface methods should not change, and that the arguments should continue to have the same meaning. </P>
<P>So far, we have dealt only with instance variables and instance methods. We also need to understand the concept of class variables and class methods which will be discussed in the next section. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="instance_and_class_variables"></A>Instance and Class Variables</H3>
<H4 ALIGN="CENTER">Instance Variables</H4>
</FONT><P>Instance variables are those data members of a class that are defined such that every individual instance of the class (object) has its own set of variables, totally independent of the variables associated with all other objects of the same or different classes. </P>
<P>In other words, each object has its own memory space where its own set of variables is stored. Because instance variables are bound to an object, they can be accessed only by way of the object to which they are bound. </P>
<P>Assuming that access to an instance variable is not prohibited by access control mechanisms (such as the use of the keyword <B>private</B>), it is usually accessed by joining the name of the object (or the name of a pointer to the object) to the name of the instance variable using the appropriate joining operator. The joining operator for Java is a simple period (sometimes called the dot operator). </P>
<P>The joining operator for C++ depends on whether the instance variable is being accessed using the name of the object or the name of a pointer to the object. When the name of the object is used, the joining operator is a simple period. When the name of a pointer to the object is used, the pointer operator (<B>-&gt</B>) is used. </P>
<P>Other languages may use different methods for accessing the instance variables of an object. </P>
<FONT COLOR="#ff0000"><H4>Class Variables</H4>
</FONT><P>Class variables are those data members of a class that are shared among all objects of the class. It's not too far-fetched to think of them as quasi-global variables whose accessibility is restricted only to objects of a particular class, or to the class itself. In other words, only one copy of a class variable exists in memory and all objects of the class can access that copy. </P>
<P>An important characteristic of class variables is that they can also be accessed without the requirement to instantiate an object of the type. In this case, they are usually accessed using the name of the class joined to the name of the variable using the appropriate joining operator. The joining operator for Java is a simple period. The joining operator for C++ is the <I>scope resolution operator</I> which is two colons with no space in between (<B>::</B>). </P>
<P>In Java and C++, class variables are designated as such using the <I>static</I> keyword. (Designation of a class variable in C++ also involves a requirement to re-declare the variable outside the class definition.) </P>
<P>Also in Java and C++, member variables declared without the use of the <I>static</I> keyword are <I>instance variables</I>. In other words, by default, all member variables of a class are <I>instance variables</I> unless you designate them as <I>class variables</I> using the <I>static</I> keyword. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="instance_and_class"></A>Instance and Class Methods</H3>
</FONT><P>Note the following very important statements: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>The methods of a class have direct access to the member variables of the <U>same</U> class regardless of their access control designation such as <I>public</I>, <I>private</I>, or <I>protected </I>(except that <I>class methods</I> can usually access only <I>class variables</I>).&nbsp; </P>
<P>There is no requirement for the code in a method of the class to use either the name of an object or the name of the class to access the member variables of the same class.</TD>
</TR>
</TABLE>

<P>The methods of a class come in two varieties: <I>instance methods</I> and <I>class methods</I>. As with instance and class variables, those methods designated <I>static</I> are <I>class methods</I> in Java and C++. Methods not designated <I>static</I> are <I>instance methods.</P>
</I><FONT COLOR="#ff0000"><H4>Instance Methods</H4>
</FONT><P>An instance method can only be invoked by way of an object of the class. In that sense, an instance method is bound to an object. However, unlike an instance variable, an object normally doesn't have its own separate copy of an instance method. It would be wasteful of memory resources to provide a separate copy of every instance method for every object of a class. </P>
<P>It is very important to understand that when an instance method is invoked on a particular object, and when the code in that method needs to access an instance variable of the class, it <U>will access the particular copy of the instance variable belonging to the object on which it was invoked</U>. It is this ability to temporarily bind the method to the instance variables of the object on which the method is invoked that causes it to behave as an <I>instance method</I>. </P>
<FONT COLOR="#ff0000"><H4>The <I>this </I>Pointer or Reference</H4>
</FONT><P>Instance methods in Java and C++ (and perhaps other object-oriented languages as well) exhibit another interesting characteristic. In particular, whenever an instance method is invoked, a pointer variable or reference variable named <B>this</B> comes into existence automatically. This reference variable refers to the object on which the method was invoked, and can be used by the code in the method for any purpose that a reference to that object might be needed. </P>
<FONT COLOR="#ff0000"><H4>Class Methods</H4>
</FONT><P>Class methods can only access other class members (class variables or other class methods). They cannot access instance variables or instance methods. </P>
<P>The most important thing about class methods is that they can be accessed using the name of the class without a requirement to instantiate an object of the class. As with class variables, class methods can be accessed by joining the name of the class to the name of the method using the appropriate joining operator. </P>
<FONT COLOR="#ff0000"><H4>Sample Program</H4>
</FONT><P>Much of what we have been discussing can probably be better understood when seen in the context of an actual program. </P>
<P>The following sample program illustrates the use of class and instance variables along with class and instance methods in a Java program. This is not an attempt to teach the Java programming language at this point. Rather, it is simply an attempt to illustrate OOP concepts using an actual Java program as the vehicle. As before, because of the access control complexity caused by the <I>package</I> concept in Java, and the desire to keep this sample program as simple as possible, no attempt was made to <I>hide the implementation</I>. </P>
<P>When compiled and executed, this program will produce the following output on the standard output device. You might want to remember this place so that you can refer to it as you examine the program. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>A - Instance variable contains 5
B - Class variable contains 10
C - Class variable contains 10</PRE></TD>
</TR>
</TABLE>

<P>Before we take a look at the complete program, lets examine some of the<I> interesting code fragments</I> that make up the program. </P>
<P>The first interesting code fragment shows the declaration of two member variables of the class. One is a class variable named <B>classVariable</B> and the other is an instance variable named <B>instanceVariable</B>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp; int instanceVariable;&nbsp;&nbsp;&nbsp;&nbsp; //declare an instance variable
&nbsp; <B>static </B>int classVariable; //declare a class variable</PRE></TD>
</TR>
</TABLE>

<P>These are typical variable-declaration statements in Java and C++ consisting of the name of the type followed by the name of the variable. The important thing to note in the context of this discussion is the use of the <B><I>static </B></I>keyword in the declaration of the class variable. </P>
<P>The next code fragment shows the definitions of two methods (with the bodies of the methods deleted for brevity). One of these methods is a class method named <B>classMethod</B> and the other is an instance method named <B>instanceMethod</B>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp; void <B>instanceMethod(){//define</B> an instance method
&nbsp;&nbsp;&nbsp; //body of method deleted for brevity
&nbsp; }//end instanceMethod()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <B>static </B>void <B>classMethod(){//define</B> a class method
&nbsp;&nbsp;&nbsp; //body of method deleted for brevity
&nbsp; }//end classMethod()</PRE></TD>
</TR>
</TABLE>

<P>Again, these are typical method or member function definitions for Java and C++ consisting of the name of the return type (where <I>void</I> means that nothing is returned) followed by the name of the method, followed by the formal argument list (which happens to be empty in this case). The body of the method is then enclosed within a matching pair of curly braces <B>{ }</B>. </P>
<P>Again, the important thing to note in the context of this discussion is the use of the <B><I>static </B></I>keyword in the definition of the class method. </P>
<P>The next code fragment is a single statement taken from the body of one of the methods. This statement causes output to be displayed on the standard output device. </P>
<P>This single statement incorporates classes, class variables, instance methods, and overloaded operators, and illustrates some of the syntactical complexity that can be encountered in object-oriented programming. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>System.out.println(
  "A - Instance variable contains " + instanceVariable);</PRE></TD>
</TR>
</TABLE>

<P>This is a Java statement. A completely different syntax would be required to achieve the same result in C++. </P>
<P>Note first that this statement has three elements joined with periods. The first element is the word <B>System</B> which is the name of one of the classes in the standard Java class library. As background information, the <B>System</B> class is automatically loaded whenever a Java application is started. </P>
<P>The name of the <B>System</B> class is joined to the word <B>out</B> using a period. The word <B>out </B>is the name of a member variable of the <B>System</B> class. </P>
<P>The member variable named <B>out</B> is a public <I>class </I>variable. This makes it possible to access the variable using the name of the class and the name of the variable joined by the period. </P>
<P>Note that the class variable named <B>out</B> is also joined to the word <B>println</B> using the period as the joining operator. The variable <B>out</B> is not only a <I>class </I>variable, it is also a <I>reference </I>variable (as opposed to a <I>primitive </I>variable) and it contains a reference to an <I>object </I>of the <B>PrintStream</B> class. </P>
<P>The <B>PrintStream</B> class has an<I> instance method</I> named <B>println()</B>. In fact, there are ten overloaded versions of the <B>println()</B> method in the <B>PrintStream</B> class. The behavior of the version used here is to cause its string argument to be displayed on the standard output device. </P>
<P>Now consider the string argument to the <B>println</B> method as shown below: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
 ("A - Instance variable contains " + <B>instanceVariable</B>)</PRE></TD>
</TR>
</TABLE>

<P>In Java (and C++ as well), literal strings are enclosed in quotation marks. You will note that not everything in this argument is enclosed in quotation marks. Note in particular the <I>plus </I>sign near the middle of the argument. </P>
<P>In Java, the plus sign is <I>overloaded </I>so that in addition to being used as an arithmetic addition operator, it is also used to concatenate strings. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>An <B><I>overloaded </B></I>operator exhibits different behavior depending of the types of its operands.</TD>
</TR>
</TABLE>

<P>Furthermore, the behavior of the overloaded <I>plus </I>operator also includes the ability to coerce its right operand into a string representation if it isn't already a string. In this case, the right operand is not a string, but rather is the instance variable named <B>instanceVariable</B>. Thus the behavior of the overloaded <I>plus </I>operator is to first convert the value of <B>instanceVariable</B> to a string representation and than to concatenate it to the left operand. </P>
<P>Some object-oriented languages such as C++ allow the programmer to overload almost all of the operators so as to define the behavior of those operators when used with operands of new abstract data types. However, Java does not provide that capability. In this case, the plus operator is intrinsically overloaded by the system. </P>
<P>Now let's take another look at the same two methods as before, this time preserving the bodies of the methods for further examination. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>

 void <B>instanceMethod(){//define</B> an instance method
   System.out.println(
   "A - Instance variable contains " 
      + <B>instanceVariable</B>);
   System.out.println(
   "B - Class variable contains " 
      + <B>classVariable</B>);
 }//end instanceMethod()

 static void <B>classMethod(){//define</B> a class method
 System.out.println(
 "C - Class variable contains " + <B>classVariable</B>);
 }//end classMethod()</PRE></TD>
</TR>
</TABLE>

<P>Here we see the code in the body of the methods accessing the member variables of the class. Recall that one of the member variables is an instance variable named <B>instanceVariable</B> and the other member variable is a class variable named <B>classVariable</B>. </P>
<P>The instance method named <B>instanceMethod</B> is able to access and display both the instance variable and the class variable while the class method named <B>classMethod</B> is only allowed to access and display the class variable. Class methods cannot access instance variables. </P>
<P>Now consider the contents of the <B>main</B> method as shown below. Both Java and C++ applications (not applets) require a <B>main</B> method or function as the controlling method of the application. In our simple application, we will use code in the <B>main</B> method to instantiate an object and to access both the instance method and the class method. </P>
<P>Recall that in order to access an instance method, it is necessary to access it via an object of the class. The next code fragment is the code in the <B>main </B>method that instantiates an object named <B>obj</B> of the class named <B>Oop01</B>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>//instantiate an object of the class Oop01
Oop01 obj = <B>new </B>Oop01();&nbsp;&nbsp;</PRE></TD>
</TR>
</TABLE>

<P>This is a typical Java statement for instantiating an object and is similar to one form of statement that can be used to instantiate an object in C++. (C++ provides other forms as well.) </P>
<P>This statement uses the <B>new</B> operator to request that the operating system provide memory "from the heap" to store one copy of an object of type <B>Oop01</B>. </P>
<P>If the required memory is successfully allocated, the address of that block of memory will be assigned to the <I>reference variable</I> named <B>obj</B>. If unsuccessful, the Java runtime system will <I>throw an exception.</I> This is a type of exception which can either be ignored, or can be caught and processed by the program. If ignored, it will cause the runtime system to shut down the program. (Exception handling is discussed later in this lesson.) </P>
<P>Both Java and C++ support exception handling, but do so in slightly different ways. </P>
<P>Once we have access to an object of the class (or more correctly access to a reference variable which refers to an object of the class), we can use that reference variable to access the public member variables and to invoke the public methods of the class. This is illustrated in the following code fragment. </P>
<P>The two statements in the following code fragment use the reference variable named <B>obj</B> along with the period to access the instance variable and the instance method of the object. Recall that the instance variables and the instance methods can be accessed <U>only</U> via an object of the class. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
//access instance variable via the object
obj.instanceVariable = 5;
//access instance method via the object
obj.instanceMethod(); </PRE></TD>
</TR>
</TABLE>

<P>Equally important is the fact that the class variable and the class method can be accessed without the requirement to use an object of the class. The two statements in the following code fragment simply use the name of the class to access the class variable and the class method of the class. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>
//access class variable via the class
Oop01.classVariable = 10;
//access class method via the class
Oop01.classMethod();&nbsp;&nbsp;&nbsp;&nbsp; </PRE></TD>
</TR>
</TABLE>

<P>Class variables and class methods can be accessed <U>either</U> via an object of the class, or via the name of the class alone. However, this sample program does not illustrate accessing class variables and methods using an object of the class. </P>
<P>Finally, we put it all together in the Java application shown below. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>

/*File Oop01.java Copyright 1997, R.G.Baldwin
Illustrates instance and class variables along with&nbsp;
instance and class methods.

The output from this program is:

A - Instance variable contains 5
B - Class variable contains 10
C - Class variable contains 10
**********************************************************/

class Oop01{ //define controlling class
  int instanceVariable;   //declare an instance variable
  static int classVariable; //declare a class variable
 
  void instanceMethod(){//define an instance method
   System.out.println(
    "A - Instance variable contains " + instanceVariable);
   System.out.println(
       "B - Class variable contains " + classVariable);
  }//end instanceMethod()
  
  static void classMethod(){//define a class method
   System.out.println(
       "C - Class variable contains " + classVariable);
  }//end classMethod()
  
  public static void main(String[] args){
   //instantiate an object of the class Oop01
   Oop01 obj = new Oop01(); 
   //access instance variable via the object
   obj.instanceVariable = 5;
   //access class variable via the class
   Oop01.classVariable = 10;
   //access instance method via the object
   obj.instanceMethod();  
   //access class method via the class
   Oop01.classMethod();   
  }//end main()
}//end class Oop01</PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="methods_and_messages"></A>Messages</H3>
</FONT><P>Methods are sometimes called member functions (particularly in books on C++). <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>A message is simply the invocation of a method or member function.</TD>
</TR>
</TABLE>

<P>The program "sends a message" to an object telling it to invoke the method and sometimes provides parameters for the method to use. </P>
<P>Someone recently wrote that an object-oriented program consists simply of a bunch of objects laying around sending messages to one another. This might be a slight exaggeration, but is not too far from the truth. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="constructors__destructors__and_garbage_c"></A>Constructors, Destructors, and Garbage Collection</H3>
</FONT><P>The allocation, reclamation, and reuse of dynamic memory from the <I>heap </I>is an important aspect of most object-oriented programs, and some non-object-oriented programs as well. The next few sections discuss how these requirements are met with respect to objects in Java and C++. Other object-oriented language use other techniques to accomplish the same objectives:</P>

<UL>
<LI>to allocate memory when it is needed by the program, </LI>
<LI>to reclaim that memory when it is no longer needed, and </LI>
<LI>to reuse it as appropriate.</LI></UL>

<P>Failure to deal with this important issue results in a condition often referred to as "memory leakage."</P>
<FONT COLOR="#ff0000"><H4>Constructors</H4>
</FONT><P>Both Java and C++ and possibly other object-oriented languages as well, support the notion of a constructor. The following Java code fragment shows a constructor at work. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>//instantiate an object of the class Oop01 in Java
Oop01 obj = new <B>Oop01()</B>;&nbsp;</PRE></TD>
</TR>
</TABLE>

<P>A <I>constructor </I>is a special method of a class that is used to instantiate (and optionally initialize) a new object of the class type. In the above statement, the invocation of the constructor method is highlighted in boldface. Constructors can be <I>overloaded </I>just like other methods in Java and C++. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>Method overloading will be discussed in more detail in a later section on <B>polymorphism</B>. Briefly, method overloading means that two or more methods can share the same name provided that they have different argument lists. When the program is compiled, the compiler determines which version of the method to use in that instance on the basis of the actual parameters being passed to the method.</TD>
</TR>
</TABLE>

<P>In this particular statement, the <B>new</B> operator is used to allocate dynamic memory from the heap, and the constructor is used to construct the object in that memory space. The address of the memory containing the object is returned and assigned to the reference variable named <B>obj</B>. If the memory cannot be allocated, an <I>exception</I> will be thrown. </P>
<P>In Java and C++, if you do not define a constructor when you define a new class, a default constructor that takes no parameters is defined on your behalf. This is often referred to as the <I>default </I>constructor or the <I>noarg</I> constructor. </P>
<P>It is also possible for you to define a constructor for your class which takes no arguments and which performs some special action when it is invoked. Defining a constructor is only slightly different from defining any other method in Java or C++ (it must have the same name as the class, does not have a return type, and must not have a return statement). </P>
<P>Although you are free to cause your constructor to perform just about any action that you want, the intended purpose of a constructor is to perform some form of initialization (open a file, initialize instance variable values, etc.) If you provide such a <I>noarg</I> constructor, it will be invoked in place of the default constructor when you invoke the constructor as shown in the above code fragment with no arguments. The constructor shown above is a Java constructor. The invocation of a constructor in C++ is even simpler. An example is shown below: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ff00">
<PRE>Oop01 obj; //instantiate object of class Oop01 in <B>C++</PRE></B></TD>
</TR>
</TABLE>

<P>C++ provides other formats for invoking the constructor in addition to that shown above. </P>
<P>It is also possible for you to define one or more overloaded versions of the constructor that <U>do</U> take parameters. These are commonly called <I>parameterized constructors</I>. Typically you will include code in the body of the constructor to use the arguments passed as parameters for some sort of initialization, but again, you can write the code to perform just about any action that you want. </P>
<P>The following code fragment shows the important parts of a Java program, similar to the previous one which has been modified to use a parameterized constructor. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>Oop02(int iV, int cV){ //parameterized constructor
  instanceVariable = iV; //initialize the instance variable
  classVariable = cV;    //initialize the class variable
}//end parameterized constructor
  
<B>...</B>    
public static void main(String[] args){
  //instantiate an object of the class Oop02
  Oop02 obj = <B>new Oop02(2,3</B>);</PRE></TD>
</TR>
</TABLE>

<P>This code fragment shows the parameterized constructor method named <B>Oop02</B> and then shows the statement used in the <B>main</B> method to instantiate and initialize an object of the class <B>Oop02</B> named <B>obj</B>. As you can see, the parameterized constructor in Java looks just like a method except that it has <U>no return type or return statement</U>. </P>
<FONT COLOR="#ff0000"><H4>Destructors</H4>
</FONT><P>A destructor is a special method typically used to perform cleanup after an object is no longer needed by the program. C++ supports destructors, but <U>Java does not support destructors</U>. Other object-oriented languages may or may not support destructors. </P>
<P>In C++, you can optionally define a destructor for a class. It looks much like any other method except that it cannot take parameters, does not have a return type, must not have a return statement, cannot be overloaded, and has the same name as the class except that it has a tilde (<B>~</B>) as a prefix to the name. </P>
<P>In C++, if you define a destructor for a class, it will be automatically invoked whenever an object of that class goes out of scope. Typically destructors are used to perform cleanup of some sort, and are often used to return dynamic memory to the operating system when the object goes out of scope and that memory is no longer needed by the program. The code in the destructor can perform other actions as well, such as closing files, etc., or can do just about anything that you want it to do. </P>
<FONT COLOR="#ff0000"><H4>Garbage Collection</H4>
</FONT><P>Java supports another mechanism for returning memory to the operating system when it is no longer needed by an object: <I>garbage collection</I>. The garbage collector is a part of the runtime system that runs in a low-priority thread reclaiming memory that is no longer needed by objects used by the program. An object becomes <I>eligible </I>for garbage collection in Java when there are no longer any reference variables that reference the object. </P>
<P>In Java, you can have one or more reference variables which reference the same object. That object will not become <I>eligible for garbage collection</I> until <U>all</U> of those reference variables go out of scope, are assigned to a different object, or are assigned a value of <B>null</B>. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="inheritance"></A>Inheritance</H2>
</FONT><P>The first major characteristic of an object-oriented program is <B>encapsulation</B> which was discussed above. The second of the three major characteristics is <B>inheritance</B>, with <B>polymorphism </B>occupying the third slot. Now let's take a look at <B>inheritance</B>. </P>
<P>A class can normally inherit the attributes and characteristics of another class (although inheritance can be blocked using different methods in different languages). </P>
<P>The original class is often called the <I>base class</I> or the <I>superclass</I>, and the new class is often called the <I>derived class</I> or the <I>subclass</I>. Inheritance is often referred to as <I>extending</I> the base class or superclass. </P>
<P>Inheritance is <U>hierarchical</U>. In other words, a class may be the subclass of one class and the superclass of another class. </P>
<P>The derived class inherits the data representation and behavior of the base class except where the derived class modifies the behavior by overriding methods. The derived class can also add new data representation and behavior that is unique to its own purpose. </P>
<P>(The teenager building a hotrod may <I>override</I> the old two-barrel carburetor by replacing it with a new four-barrel model, and may also add a blower and other speed-enhancing widgets that were not a part of the original engine design.) </P>
<P>A program can usually instantiate objects of a base class as well as of a class which is derived from the base class. (It is also possible to block instantiation of the base class in some cases by defining it as an <I>abstract base class.) </I>If the base class is an <I>abstract base class</I> -- one that exists only to be derived from -- the program may not instantiate objects of the base class but can instantiate objects of classes derived from the base class. </P>
<P>The Java and C++ inheritance mechanisms allow you build an orderly hierarchy of classes. (In C++, because of <I>multiple inheritance</I>, it is also possible to build hierarchies that are not so orderly.) Java does not support multiple inheritance. </P>
<P>When several of your abstract data types have characteristics in common, you can design their commonalities into a single base class and separate their unique characteristics into unique derived classes. This is one of the purposes of inheritance. </P>
<P>For example, suppose you are building a program dealing with airships. All airships have altitude and range parameters in common. Therefore, you could build a base Airship class containing data and methods having to do with range and altitude. </P>
<P>From this base class, you might derive a Balloon class and an Airplane class. </P>
<P>The Balloon class might add variables and methods dealing with passenger capacity and what makes it go up (helium, hydrogen, or hot air). Objects of the Balloon class would then be able to deal with altitude, range, passenger capacity, and what makes it go up. </P>
<P>The Airplane class might add variables and methods dealing with engine type (jet or propeller) and cargo capacity. Objects of the Airplane class could then deal with altitude, range, engine type, and cargo capacity. </P>
<P>Having created this hierarchy of classes, you could instantiate objects of type Airship, Balloon, or Airplane with the objects of each type having variables and methods to deal with those special characteristics of the flying machine indicated by the name of the class. (Although there isn't any requirement to do so, hopefully your will use descriptive names for your classes.) </P>
<P>You may have noticed that in this hierarchical class structure, inheritance causes the structure to grow in a direction from most general to less general. This is typical. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="single_and_multiple_inheritance"></A>Single and Multiple Inheritance</H3>
</FONT><P>C++, and perhaps other object-oriented languages as well, allow for multiple inheritance. This means that a new class can be derived from more than one base class. This has advantages in some cases, but can lead to difficulties in other cases. </P>
<P>The designers of the Java language chose not to support multiple inheritance. Instead they provided a different mechanism called an <I>interface </I>which can often be used to achieve the same end result as multiple inheritance with fewer potential problems. This topic is much too specific to discuss in detail here. It is mentioned simply to alert you to the fact that an object-oriented language that you choose may, or may not support multiple inheritance, and if not, may provide some alternative mechanism to achieve the same end result. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="the_isa_relationship"></A>The ISA Relationship</H3>
</FONT><P>You will sometimes hear people speak of the <B>ISA </B>relationship when discussing OOP. The source of this terminology is more fundamental than you may at first suspect. </P>
<P>Object-oriented designers often strive to use inheritance to model relationships where a derived class <I>"is a kind of"</I> the base class. For example, a car <I>"is a kind of"</I> vehicle. A programmer <I>"is a kind of"</I> employee which in turn <I>"is a kind of"</I> person. </P>
<P>This relationship is called the <B>ISA </B>relationship. It's that simple. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="polymorphism_in_general"></A>Polymorphism</H2>
</FONT><P>The three required characteristics of an object-oriented language are <B>encapsulation</B>, <B>inheritance</B>, and <B>polymorphism</B>. </P>
<B><P>Polymorphism </B>(from the Greek, meaning "many forms", or something similar) is the quality that allows one name to be used for more than one (hopefully related) but technically different purpose. </P>
<P>The purpose of polymorphism as it applies to OOP is to allow one name to be used to specify a general class of actions. Within a general class of actions, the specific action to apply in any particular instance is determined by the type of data involved. </P>
<P>More generally, the concept of polymorphism is the idea of "one interface, multiple methods". Polymorphism exists when functions or operators are overloaded or overridden to cause them to perform operations not implicitly recognized by the compiler. (Java does not support operator overloading but it does support the overloading and overriding of methods.) </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="overloading_methods_as_a_form_of_polymor"></A>Overloading Methods as a Form of Polymorphism</H3>
</FONT><P>Perhaps the best-known simple example of polymorphism is the ability to replace the three C functions, </P>

<UL>
<TT><LI>abs()</TT> </LI>
<TT><LI>labs()</TT> </LI>
<TT><LI>fabs()</LI></UL>

</TT><P>by a single C++ or Java function called <TT>ABS()(or</TT> whatever name you choose to call it). </P>
<P>C requires three separate functions to return the absolute value of each of the three data types: <B>int</B>, <B>long</B>, and <B>float</B>. With C++ (and with Java), you can overload functions so that the absolute value of any of the three data types can be obtained by calling a function having the same name for every data type. This is accomplished through <I>function or method overloading</I>. Function overloading provides a type of polymorphism often referred to as <I>compile-time polymorphism</I>. (Note that some authors do not consider function overloading to be a true or pure form of polymorphism.) </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="overloading_operators_as_a_form_of_polym"></A>Overloading Operators as a Form of Polymorphism</H3>
</FONT><P>Polymorphism is not necessarily new to Java, C++ and other modern languages. For example some programming languages that have been around for quite a while interpret the plus operator to be an arithmetic operator when applied to numeric data and to be a concatenation operator when applied to string data. (Actually that is the one form of operator overloading that is also supported by Java.) This is clearly an example of polymorphic behavior, and has been around since the early days of programming. However, that form of polymorphic behavior has been <U>intrinsic to the language</U> and could not be modified or controlled by the programmer. </P>
<P>C++ provides the opportunity, and (with one or two exceptions) the responsibility for the programmer to define the behavior of (almost) any operator that may be applied to an object of a new class. We refer to this as <B>operator overloading</B>. One operator (the assignment operator and possibly a few others) has a default behavior when applied to objects of a new class. The default behavior of the assignment operator is to make an identical bitwise copy of the object on the right and store it in the object on the left. Even this default behavior can be, and often is, overloaded to provide different behavior for the assignment operator relative to objects of a new class. </P>
<P>There are about four or five operators that cannot be overloaded in C++. Beyond these, the C++ programmer can define the behavior of any operator when the operator is applied to an object of a new class. (Note however, that the programmer cannot modify the behavior of operators as applied to variables of the intrinsic or primitive types.) </P>
<P>This is an extremely valuable capability when used wisely. For example, in a program that deals extensively with vectors in 3D space, the programmer might choose to overload a subset of the arithmetic operators with respect to objects of a new vector class so as to provide a complete vector algebra for objects of that class. </P>
<P>Each object of the class could represent a vector in 3D space, and the plus sign, for example, could be applied to two such objects to produce a third object which would represent the sum of the two vectors represented by the operands. </P>
<P>Unfortunately, Java does not support operator overloading. There is probably little or nothing that can be accomplished with overloaded operators that cannot also be accomplished with overloaded methods, but in many cases, overloaded operators will provide a much cleaner and more intuitive syntax. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="overriding_methods_as_a_form_of_polymorp"></A>Overriding Methods as a Form of Polymorphism</H3>
</FONT><P>Note that this section discusses the word <I>override </I>as opposed to the word <I>overload</I>. Overriding a method is an entirely different thing from overloading a method. </P>
<P>Previous sections have discussed overloading methods and overloading operators. Polymorphism also exists when a derived class customizes the behavior of methods defined in the base class to meet the special requirements of the derived class. This is known as <I>overriding methods</I> and leads to <I>runtime polymorphism</I>. </P>
<P>Both Java and C++ support the notion of <I>overriding a method</I> in a base class to cause it to behave differently relative to objects of the derived class. In other words, a method named <B>joe</B> that is defined in the base class and is overridden in the derived class would behave differently depending on whether it is invoked on an object of the base class or on an object of the derived class. </P>
<P>Many people find runtime polymorphism to be one of the most difficult concepts of OOP to understand. Hopefully after this explanation, you won't fall in that category. </P>
<P>In both Java and C++, a pointer or reference variable of a base-class type can be used to point to or reference an object of any class derived from that base class. </P>
<P>If an overridden method is invoked using that base-class pointer or reference variable, the system will be able to determine, at runtime, which version of the method to use based on the true type of the object, and not on the type of pointer or reference variable used to invoke the method. </P>
<P>Therefore, it is possible to make selection decisions at runtime among a family of overridden methods as to which method to invoke based on which type of derived object is being pointed to by the base-class pointer when the overridden method is invoked on the base-class pointer. (Note that function overriding in C++ is somewhat more complex than in Java.) </P>
<P>This is illustrated in the following small, but non-trivial Java application. As a baseline, the application first invokes an overridden method named <B>joe()</B> an a base-class reference to a base-class object and then invokes the overridden method named <B>joe()</B> on a derived-class reference to a derived-class object. </P>
<P>In the first case, the base-class version of <B>joe()</B> is actually invoked. In the second case, the derived-class version of <B>joe()</B> is invoked. No surprises here. </P>
<P>Then the application invokes the overridden method named <B>joe()</B> on a base-class reference which actually <U>refers to a derived-class object</U>. When this is done, it is the version of the method defined in the derived class and <U>not</U> the version defined in the base class that is actually invoked. <B>This is the essence of runtime polymorphism.</B><BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Polymorph01.java

Illustrates runtime polymorphism with overridden methods
Assigns a derived class object to a base class reference&nbsp;
and then invokes an overridden method on the base class&nbsp;
reference.&nbsp; As expected, the overridden method in the&nbsp;
derived class is actually executed.

Output from the program is:
&nbsp;&nbsp;
Executing base class version of method joe 1
Executing derived class version of method joe 2
<B>Executing derived class version of method joe 3
</B>**********************************************************/

class Polymorph01{
&nbsp; static public void main(String[] args){
&nbsp;&nbsp;&nbsp; //base class ref to base class object&nbsp;
&nbsp;&nbsp;&nbsp; Base baseRef = new Base();&nbsp;
&nbsp;&nbsp;&nbsp; baseRef.joe(1); //invoke method named joe()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //derived class ref to derived class object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Derived derRef = new Derived();
&nbsp;&nbsp;&nbsp; derRef.joe(2); //invoke method named joe()

&nbsp;&nbsp;&nbsp; //base class ref to derived class object&nbsp;&nbsp;&nbsp;&nbsp;
<B>&nbsp;&nbsp;&nbsp; baseRef = derRef;
</B>&nbsp;&nbsp;&nbsp; //invoke method named joe() on base ref to&nbsp;
&nbsp;&nbsp;&nbsp; // derived object
<B>&nbsp;&nbsp;&nbsp; baseRef.joe(3);
</B>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end main
}//end class Polymorph01

class Base{
&nbsp; void joe(int dataIn){
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Executing base class version of method joe "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + dataIn);
&nbsp; }//end joe()
}//end class Base

class Derived extends Base{
&nbsp; void joe(int dataIn){
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Executing derived class version of method joe "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + dataIn);
&nbsp; }//end joe()
}//end class Derived</PRE></TD>
</TR>
</TABLE>

<P>Inheritance and method overriding are used extensively in almost all Java programming. Even the simplest "Hello World" Java applet requires that the <B>Applet </B>class be extended and the <B>paint()</B> method be overridden. </P>
<P>Although it is possible to write some significant C++ programs without becoming involved in any form of OOP, those C++ programs that make use of commercial class libraries for such tasks as creation of data structures, building GUI interfaces, etc., also make extensive use of inheritance and method overriding. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="compile_time_and_run_time_polymorphism"></A>Compile-Time and Run-Time Polymorphism</H3>
</FONT><P>Many authors recognize two types of polymorphism: </P>

<UL>
<I><LI>compile-time</I> polymorphism </LI>
<I><LI>run-time</I> polymorphism.</LI></UL>

<P>On the other hand, some authors only recognize <I>run-time</I> polymorphism as being the true and pure form of polymorphism. </P>
<P>In C++, the programmer must be concerned about the difference and program accordingly (only <I>virtual </I>functions can be overridden). Generally speaking, in Java, the programmer need not make much of a distinction between the two because all methods can be overridden unless they are declared <B>final</B>. </P>
<P>The implementation of polymorphism in both Java and C++ essentially consists of providing multiple functions or methods with the same name, and calling the correct one at the appropriate time on the basis of the type of data involved.. </P>
<FONT COLOR="#ff0000"><H4>Compile-Time Polymorphism</H4>
</FONT><P>If the construction is such that it is clear at compile time which version of two or more functions having the same name should be called in a specific instance, this is referred to as <I>early binding</I>, <I>static binding</I>, or <I>compile-time polymorphism</I>. </P>
<P>For example, function <I>overloading </I>and <I>operator overloading</I> are forms of compile-time polymorphism because the compiler knows when the program is compiled which of several versions of the same function name should be invoked in each instance. </P>
<FONT COLOR="#ff0000"><H4>Run-Time Polymorphism</H4>
</FONT><P>As shown earlier, it is also possible to <I>override </I>and invoke a method in such a way that it is not known at compile time which version of the function is to be called in a particular instance. That determination cannot be made until the program is actually executed. This is often referred to as <I>late binding</I>, <I>dynamic binding</I>, or <I>run-time polymorphism</I>. </P>

<P><!-prev=Java004e.htm-><!-next=Java004g.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="exception_handling"></A>Exception Handling</H2>
</FONT><P>While <I>exception handling</I> may not be considered by everyone as part and parcel of OOP, Java requires it, C++ supports it, and it can probably be expected that any object-oriented language that is not currently supporting it will do so in the future. Therefore, a section on exception handling is being included here to introduce you to the subject in a general sense. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="introduction_to_exception_handling"></A>Introduction to Exception Handling</H3>
</FONT><P>Stated in simple terms, exception-handling capability makes it possible for you to monitor for exceptional conditions within your program, and to transfer control to special exception-handling code designed by you whenever an exceptional condition is detected. This is accomplished using the keywords: <B>try</B>, <B>throw</B>, <B>throws, catch, </B>and <B>finally</B>. </P>
<P>You <B>try </B>to execute the statements contained within a block surrounded by braces. </P>
<P>If your code (or the runtime system) detects an exceptional condition within that block, your code (or the runtime system) <B>throws </B>an exception object of a specific type. </P>
<P>Your code can then <B>catch </B>and process the exception object using code that you have designed, or your code can pass it up to the next level in the method-invocation hierarchy for handling there. </P>
<P>In Java, you can then optionally execute a block of code designated by <B>finally </B>which is normally used to perform some type of cleanup which is needed <U>whether or not</U> an exception occurs. </P>
<P>As indicated above, you can design your code to detect exceptional conditions and to <B>throw </B>an exception object. There are also situations where an exceptional condition will be detected by the runtime system which automatically <B>throws </B>an exception and attempts to transfer control to special exception-handling code which you write (cases where you don't provide the code to <B>throw </B>the exception object). In this case, you are responsible only for the code in the <B>catch </B>block and optionally, in Java, for the code in the <B>finally </B>block. </P>
<P>Although Java and C++ provide similar exception handling capabilities, the manner in which exception handling is implemented is different between the two languages. Therefore, the remainder of this section will concentrate on exception handling in Java, for those parts of the discussion which need to be language specific. </P>
<P>Our discussion will attempt to briefly touch on following topics, not necessarily in this order: </P>

<UL>
<I><LI>What is</I> an exception? </LI>
<LI>In concept, <I>how do you</I> throw and catch exceptions? </LI>
<I><LI>What do you do</I> with an exception once you have caught it? </LI>
<I><LI>How do you</I> make use of the exception class hierarchy provided by the development environment?</LI></UL>

<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="exception_hierarchy__an_overview"></A>Exception Hierarchy, An Overview</H3>
</FONT><P>According to <U>The Java Tutorial</U> by Campione and Walrath: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=2 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>"An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions."</TD>
</TR>
</TABLE>

<P>When an exceptional condition causes an exception to be <I>thrown </I>in Java, that exception is an object derived, either directly, or indirectly from the class <B>Throwable</B>. In C++, it is also possible to throw exceptions of primitive types such as <B>int</B>. </P>
<P>The runtime system and many different methods in many different classes automatically <B>throw </B>exceptions in Java. Very few exceptions are automatically thrown in C++. Whereas Java requires you to program using exception handling, C++ makes it optional. However, once you begin using proprietary class libraries in C++, the optional nature of exception handling disappears rather quickly. </P>
<P>In both languages, you can define and throw exception objects of your own design (but in Java you must inherit your exception class, either directly, or indirectly from the class<B> Throwable</B>). </P>
<P>The <B>Throwable</B> class in Java has two subclasses: </P>

<UL>
<B><LI>Error</B> </LI>
<B><LI>Exception</LI></UL>

</B><P>Paraphrasing David Flanagan and <U>Java in a Nutshell</U>, an <B>Error</B> indicates that a <U>non-recoverable</U> error has occurred that <U>should not be caught</U>. Errors usually cause the Java interpreter to display a message and exit. </P>
<P>Still paraphrasing Flanagan, an <B>Exception</B> indicates an abnormal condition that <U>must be properly handled</U> to <U>prevent program termination</U>. </P>
<P>Of the many possible exceptions that can be automatically thrown in Java, there is a subset for which catching and processing is optional. The compiler will allow you to simply ignore the exceptions in this subset. If one of the exceptions which you ignore actually occurs, it will be <I>caught</I> by the runtime system, and the program will be terminated. </P>
<P>The remaining exceptions that can automatically be thrown in Java must be <I>recognized </I>by your code in order for your program to compile. </P>
<P>Recognition can consist of either </P>

<UL>
<LI>catching and processing the exception, or </LI>
<LI>passing it up to the next level in the method-invocation hierarchy.</LI></UL>

<P>Within this category, if one of the methods called by your method <I>throws</I> an exception, your method must either <U>catch and process it</U>, or <U>pass it up to the next level</U> in the method-invocation hierarchy. </P>
<P>If your method passes an exception up to the next level in the invocation hierarchy, this must be declared along with the method signature using the <B>throws</B> keyword. </P>
<P>If your code catches and processes an exception, the processing code can be as elaborate or as simple as you want to make it. In fact, simply ignoring it after you catch it will satisfy the compiler and allow your program to compile. This may, or may not be a good idea, depending on the type of the exception. </P>
<P>All exception objects inherit the methods of the <B>Throwable</B> class in Java, as well as the methods of any intermediate classes in the inheritance class hierarchy. Various methods are available to assist you in examining an exception object to extract the diagnostic information contained therein. Sometimes this information can be useful to your code in determining how to deal with the exceptional condition. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="advantages_of_using_exception_handling"></A>Advantages of Using Exception Handling</H3>
</FONT><P>Exception handling provides the following advantages over "traditional" error management techniques: </P>

<UL>
<LI>Separating Error Handling Code from "Regular" Code </LI>
<LI>Propagating Errors Up the Call Stack </LI>
<LI>Grouping Error Types and Error Differentiation</LI></UL>

<FONT COLOR="#ff0000"><H4>Separating Error Handling Code from "Regular" Code</H4>
</FONT><U><P>The Java Tutorial</U> by Campione and Walrath provides a good illustration where they show how a simple program having only about six lines of code gets "bloated" into about 29 lines of very confusing code through use of traditional error management techniques. Not only does the program suffer bloat, the logical flow of the original program gets lost in the clutter of the modified program. </P>
<P>The authors then show how to accomplish the same error management using exception handling. This version contains about seventeen lines of code which is considerably fewer than 29 lines of code. Furthermore, it is orderly and easy to understand. The additional lines of code do <U>not</U> cause the original logic of the program to get lost. </P>
<P>The use of exception handling does not spare you the effort of doing the work of detecting, reporting, and handling errors. What it does do is provide a way to separate the details of what to do when something out-of-the-ordinary happens from the normal logical flow of the program code. </P>
<FONT COLOR="#ff0000"><H4>Propagating Errors Up the Call Stack</H4>
</FONT><P>Sometimes it is desirable to propagate exception handling up the call stack and let the corrective action be taken at a higher level. </P>
<P>For example, you might provide a class with methods which implements a stack data structure. One of the methods of your class might be to <I>pop</I> an element off the stack. </P>
<P>What should the methods in your <I>stack</I> class do if a using program attempts to pop an element off an empty stack.? That decision might best be left to the user of your stack class and you might simply propagate the notification up to the calling method and let that method take the corrective action. </P>
<FONT COLOR="#ff0000"><H4>Grouping Error Types and Error Differentiation</H4>
</FONT><P>The following statements describe certain aspects of exception handling: </P>

<UL>
<LI>Exceptional conditions throw objects. </LI>
<LI>Objects are instances of classes. </LI>
<LI>Classes may be inherited in Java.</LI></UL>

<P>As a result of the above, a natural hierarchy can be created which causes exceptions to be grouped in logical ways. </P>
<P>For example, going back to the stack example, you might create an exception class which applies to all exceptional conditions associated with an object of your stack class. From this, you might inherit other classes which pertain to specific exceptional conditions such a <I>push </I>exceptions, <I>pop </I>exceptions, <I>initialization </I>exceptions, etc. </P>
<P>If your code throws an exception object of one of the specific types, that object can be caught </P>

<UL>
<LI>either by an exception event handler designed to catch on the basis of the <U>group</U> of exceptions, or </LI>
<LI>one designed to catch on the basis of one of the <U>specialized</U> exceptions.</LI></UL>

<P>This capability to handle exceptions on an organized hierarchical basis is very powerful. </P>


<P><!-prev=Java004f.htm-><!-next=Java004h.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="object_oriented_design_guidelines"></A>Intro to Object-Oriented Design</H2>
</FONT><P>Object-oriented design (OOD) is a technology in its own right, often treated as being separate and apart from OOP. In my view, OOP is the implementation of OOD. </P>
<P>Many books have been written describing a variety of methods for accomplishing OOD. This lesson will <U>not</U> attempt to teach OOD in any depth. However, it probably will be useful to explain how some designers make the <U>first pass</U> at identifying the <I>classes</I>, <I>data members</I>, and <I>methods </I>needed to model the problem as an object-oriented design. Once the first pass is made, the process then often turns into an iterative process of testing and refinement. </P>
<P>One common technique is to create a <U>narrative description</U> of the solution to the problem, and then use the <I>nouns </I>and the <I>verbs </I>to help identify the <I>classes</I>, <I>data members</I>, and <I>methods </I>needed in the design. This or a similar methodology is found in many books on the subject. </P>
<P>Consider the following narrative description of the solution to an object-oriented design problem. We will use this description to design a simple object-oriented program. The nouns will give us hints about the <I>classes </I>and the <I>data members</I> that will be needed, and the <I>verbs </I>will give us an idea of the <I>methods </I>that will be needed. </P>
<P>The narrative description follows with the important nouns in <B>boldface </B>and the important verbs in <B><I>italicized boldface</B></I>. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>Design a digital <B>Counter </B>which has three <B>bits</B>.
Provide the ability to <B><I>initialize </B></I>the Counter to 000.
Provide the ability to <B><I>increment </B></I>the Counter by 1.
Provide the ability to <B><I>show </B></I>the contents of the Counter.

For each <B>bit</B>:
Provide the ability to <B><I>set</B></I> the <B>value </B>of the bit to a 0.
Provide the ability to <B><I>get </B></I>the value stored in the bit.
Provide the ability to <B><I>add </B></I>a 1 to the value stored in the&nbsp;
bit and return the <B>carry </B>according to the truth-table&nbsp;
that follows:

The truth-table for addition is:

0 + 0 = 0, c = 0
0 + 1 = 1, c = 0
1 + 0 = 1, c = 0
1 + 1 = 0, c = 1

Provide a <B>test program</B> that will <B><I>instantiate </B></I>a Counter&nbsp;
object and <B><I>exercise </B></I>the Counter by <B><I>incrementing </B></I>it 8&nbsp;
times and <B><I>displaying </B></I>the result.

The output from the test program should be:
000
001
010
011
100
101
110
111
000</PRE></TD>
</TR>
</TABLE>

<P>The program resulting from this design effort follows: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Design01.java Copyright 1997, R.G.Baldwin
The purpose of this file is to illustrate the process of&nbsp;
using a narrative description of a problem to identify&nbsp;
classes, variables, and methods.

**********************************************************/

class <B>Bit</B>{
&nbsp; int <B>value</B>;
&nbsp; void <B><I>set(){//method</B></I> to set the value of the bit to 0
&nbsp;&nbsp;&nbsp; value = 0;
&nbsp; }//end set()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int <B><I>get(){//method</B></I> to get the value stored in the bit
&nbsp;&nbsp;&nbsp; return value;
&nbsp; }//end get()
&nbsp;&nbsp;
&nbsp; //method to implement binary addition&nbsp;&nbsp;
&nbsp; int <B><I>add(int</B></I> inValue){
&nbsp;&nbsp;&nbsp; int <B>carry </B>= 0;
&nbsp;&nbsp;&nbsp; if((value == 0) &amp;&amp; (inValue == 0)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //0+0=0,c=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carry = 0;
&nbsp;&nbsp;&nbsp; }else if((value == 0) &amp;&amp; (inValue == 1)){//0+1=1,c=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carry = 0;
&nbsp;&nbsp;&nbsp; }else if((value == 1) &amp;&amp; (inValue == 0)){//1+0=1,c=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carry = 0;
&nbsp;&nbsp;&nbsp; }else if((value == 1) &amp;&amp; (inValue == 1)){//1+1=0,c=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carry = 1;
&nbsp;&nbsp;&nbsp; }//end if statement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return carry;
&nbsp; }//end add()
}//end class Bit

class <B>Counter</B>{
&nbsp; Bit <B>msb </B>= new Bit();//instantiate three bit objects
&nbsp; Bit <B>mid </B>= new Bit();
&nbsp; Bit <B>lsb </B>= new Bit();

&nbsp; //method to initialize the bit objects to 0
&nbsp; void <B><I>initialize</B></I>(){
&nbsp;&nbsp;&nbsp; msb.set();
&nbsp;&nbsp;&nbsp; mid.set();
&nbsp;&nbsp;&nbsp; lsb.set();&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }//end initialize()

&nbsp; //method to add 1 to lsb and have it ripple up&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; // through all three bits of the counter
&nbsp; void <B><I>increment</B></I>(){
&nbsp;&nbsp;&nbsp; msb.add(mid.add(lsb.add(1)));
&nbsp; }//end increment()

&nbsp; //method to display the value of each bit in the counter
&nbsp; void <B><I>show</B></I>(){
&nbsp;&nbsp;&nbsp; System.out.println("" + msb.get() + mid.get()&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + lsb.get());
&nbsp; }//end show()

}//end class Counter

//controlling class required by Java application
class <B>Design01</B>{
&nbsp; public static void <B><I>main(String</B></I>[] args){
&nbsp;&nbsp;&nbsp; //instantiate a counter object
&nbsp;&nbsp;&nbsp; Counter <B>myCounter </B>= new Counter();
&nbsp;&nbsp;&nbsp; myCounter.initialize();//initialize the counter object
&nbsp;&nbsp;&nbsp; myCounter.show(); //display contents of counter object
&nbsp;&nbsp;&nbsp; //increment and display counter object
&nbsp;&nbsp;&nbsp; for(int cnt = 0; cnt &lt; 8; cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myCounter.increment();//increment it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myCounter.show();//display it
&nbsp;&nbsp;&nbsp; }//end for loop
&nbsp; }//end main()

}//end class Design01</PRE></TD>
</TR>
</TABLE>

<P>As you can see, the program resulting from the design effort included a class named <B>Bit</B> with a data member named <B>value</B> as well as methods to <B><I>set</B> </I>the instance variable, <B><I>ge</I>t</B> the instance variable, and <B><I>add</B> </I>a 1 to the <B>value </B>of the instance variable returning the <B>carry </B>from the binary addition. You should be able to identify these items as nouns or verbs in the narrative description. </P>
<P>Also as you can see, the design resulted in a class named <B>Counter</B> which had three embedded <B>Bit</B> objects as instance variables or data members. This class has a method named <B><I>initialize</B> </I>that is used to initialize the three-bit counter to 000. </P>
<P>This class also has a method named <B><I>increment</B> </I>which adds one to the least-significant bit, adds the carry from the least significant bit to the middle bit, and adds the carry from the middle bit to the most-significant bit. This is the typical ripple pattern for a binary counter. </P>
<P>This class also has a <B><I>show</B> </I>method that displays the values stored in each of the three <B>Bit</B> objects in the order from most-significant to least-significant. </P>
<P>You should also be able to identify nouns and verbs in the narrative description that relate to this class, its data members, and its methods. </P>
<P>This program also contains a class named <B>Design01</B> which is not represented by a noun in the narrative description. This is because all applications in Java require a controlling class, and in this case the controlling class is named <B>Design01</B>. </P>
<P>The controlling class always contains a <B>main</B> method. In this case the <B>main</B> method instantiates a <B>Counter</B> object <B><I>initializes </B></I>it, and <B><I>shows </B></I>it. Then it <I>increments </I>the counter eight times, <I>showing </I>its value each time it is incremented. You should also be able to identify nouns and verbs in the narrative description which relate to the manner in which the <B>main</B> method exercises the <B>Counter</B> object. </P>
<P>It is not likely that you will find a perfect correspondence between nouns, verbs, classes, data members, and methods. However, the correlation should be close enough that you should be able to see how a narrative description can be used for a first-pass estimate as to what the classes, data members, and methods should be. </P>


<P><!-prev=Java004g.htm-><!-next=Java004i.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="ood_oop_versus_traditional_techniques"></A>OOD/OOP Versus Traditional Techniques</H2>
</FONT><P>There seems to be fairly widespread agreement among leading authorities in computer science that OOD/OOP, when properly done, produces software systems that are much more maintainable and extensible than systems designed and programmed according to more traditional, Top-Down Design (TDD), procedural techniques. </P>
<P>The reason isn't too difficult to understand. Traditional design techniques result in tightly-coupled systems where a minor change in one part of the system ripples throughout the system, often requiring major changes in many other parts of the system. OOD, on the other hand, (can) produce systems where the different components of the system have minimal coupling, and the need to make a change in one part of the system will require few, if any, changes in other parts of the system. </P>
<P>At this point we encounter a paradox. If OOD/OOP produces better systems, why isn't it the design technique of choice in the early computer science courses at colleges and universities? Probably most colleges and universities are still teaching TDD and procedural programming in their early courses. This part of this lesson won't provide the answer to that question, but hopefully it will provide information that can be used to seek an answer. </P>
<P>One of the interesting discussions in this area centers around the question of just when is a new programming student able to understand and use the concepts of OOD/OOP? </P>
<P>Obviously if they are going to do much serious programming in Java, they need to be ready for OOP very early since Java doesn't allow the use of global variables and global functions. Further, since most of the functionality of Java resides in the large class library referred to as the API, it is impossible to do much useful programming in Java without doing it in an object-oriented way. </P>
<P>However, while Java does enforce the use of an object-oriented style of programming, it doesn't enforce the quality of the design. It is just as easy to produce a bad design in an object-oriented language as in a traditionally procedural language such as Pascal. </P>
<P>Some college professors, such as myself, advocate an approach where beginning students would be taught OOD as their first design technique, and TDD would be relegated to an appendix in the back of the book. Granted, we are in the minority. We believe that it is easier to learn to do the job "right" initially (using OOD), than to learn how to do it "wrong" initially (using TDD), and then have to break the bad habits acquired from using TDD and replace them with good habits using OOD. Bad habits are hard to break. </P>
<P>In any event, the purpose of the next few sections is an attempt to determine the point in a new student's programming education where the student would be capable of doing OOD/OOP on minimal programs. The approach used is to perform an object-oriented design and implementation on a minimal program, and then to tabulate the specific knowledge that the student would require in order to accomplish that design and implementation.</P>


<P><!-prev=Java004h.htm-><!-next=Java004j.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="minimum_knowledge_requirements_for_ood_o"></A>Minimum Knowledge Requirements for OOD/OOP</H2>
</FONT><P>The purpose of the following material is to establish the minimum knowledge that must have been acquired by a beginning programming student before that student would be capable of designing and implementing a specific minimal object-oriented program in Java. (Other specific programs may require other specific knowledge and other languages may require other specific knowledge.) </P>
<P>A somewhat broader purpose is to provide information that can be used to determine at what point OOD/OOP could be effectively introduced into a beginning programming course, and what topics should be emphasized early in the course in order to accelerate that process. </P>
<P>The program uses the noun/verb methodology to convert the program specification into an object-oriented design. A complete walk-through of that process is given at the end of the lesson. Conclusions regarding the minimal knowledge required and a summary of the design results follow the program specification. The conclusions are followed by a detailed discussion of the analysis that led to the conclusions. </P>


<P><!-prev=Java004i.htm-><!-next=Java004k.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="program_specification_"></A>Program Specification:</H3>
</FONT><P>Write an object-oriented program that simulates a furnace, a thermostat, and a user. </P>
<P>First, the thermostat gets the <I>set point</I> from the user (the user adjusts the thermostat). </P>
<P>Then the thermostat gets the <I>current temperature</I> from the user (the user substitutes for the built-in thermometer in the thermostat). </P>
<P>Then the thermostat tests the <I>current temperature</I> against the <I>set point</I>. If the current temperature is above the set point, the thermostat announces that there is no need to turn the furnace on. If the current temperature is below the set point, it sends a message to the furnace asking it to turn on. </P>
<P>When the furnace is turned on, the furnace announces that it has been turned on (like a pilot light). </P>
<P>The program terminates at this point. </P>


<P><!-prev=Java004j.htm-><!-next=Java004l.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="conclusions_regarding_minimal_knowledge"></A>Conclusions Regarding Minimal Knowledge</H3>
</FONT><P>After reviewing the program that satisfies the previous specification, I have concluded that the student would need to have knowledge of the following topics in order to be able to design and implement the program.</P>
<FONT COLOR="#ff0000"><H4><A NAME="java_particulars"></A>Java Particulars</H4>
</FONT><P>Mechanics of using the Java development environment to create, compile, and run a program. </P>
<P>How comment indicators (// and /* */) are used in Java. </P>
<P>Minimal (possibly memorized) knowledge of the<B> java.io</B> and <B>java.util</B> packages. </P>
<P>Minimal (possibly memorized) knowledge of the use of <B>import </B>statements in Java. </P>
<P>Syntax used to display messages on the screen in Java. </P>
<P>How to get input data from the keyboard. </P>
<P>Every Java application requires a controlling class. </P>
<P>Controlling class requires a <B>main()</B> method with a fixed signature. </P>
<P>Skeleton (possibly memorized) for the controlling class and the skeleton for the <B>main()</B> method. </P>
<P>The <B>main()</B> method controls the flow of a Java application.</P>
<FONT COLOR="#ff0000"><H4><A NAME="programming_basics"></A>Programming Basics</H4>
</FONT><P>Use of primitive types, such as <B>int</B>. </P>
<P>Use of the <I>assignment</I> operator. </P>
<P>Fundamentals of <I>sequence, selection, </I>and <I>loop </I>preferred, but only <I>if/else </I>is required for this particular program<I>.</P>
</I><FONT COLOR="#ff0000"><H4><A NAME="object_oriented_design"></A>Object-Oriented Design</H4>
</FONT><P>OOD knowledge sufficient to use the noun/verb methodology to discover the <I>objects</I>, <I>variables</I>, and <I>methods </I>required in the design (also see Classes and Objects below).</P>
<FONT COLOR="#ff0000"><H4><A NAME="variables"></A>Variables</H4>
</FONT><P>Variables in general. </P>
<P>Java has two kinds of variables: <I>primitive </I>and <I>reference</I>. </P>
<P>Syntax required to declare a variable of either type. </P>
<P>Variable name is an <I>abstraction</I> for a group of bytes in memory that contain a value. </P>
<P>Value stored in the memory represented by a <I>primitive </I>variable can be thought of as the value of the variable. </P>
<P>Value stored in the memory represented by a <I>reference </I>variable is (or represents) the address in memory where an object (see Classes and Objects below) is stored. </P>
<I><P>Address</I> of an object stored in a <I>reference</I> variable is used to gain access to the members of the object. </P>
<FONT COLOR="#ff0000"><H4><A NAME="classes_and_objects"></A>Classes and Objects</H4>
</FONT><P>Objects are instances of classes. </P>
<P>Syntax for instantiating new objects. </P>
<P>Noun/verb design methodology sufficient to discover that this program has three objects: <B>thermostat</B>, <B>furnace</B>, and <B>user</B>. </P>
<P>Sufficient OOD knowledge to discover that the <B>thermostat</B> object <I>uses</I> the <B>furnace</B> and <B>user</B> objects, and how and for what purpose it uses them. </P>
<P>Class definition can contain member variables, member methods, or both. </P>
<P>Syntax required to define methods in a class definition. </P>
<P>Syntax required to declare <I>instance variables</I> in a class definition. </P>
<I><P>Instance variables</I> can be either <I>primitive</I> variables or <I>reference</I> variables. </P>
<I><P>Instance variables</I> of a class are directly accessible to the code in all of the methods (and constructors) that belong to the class. </P>
<P>Syntax of constructors and the optional ability to pass parameters to a constructor. </P>
<FONT COLOR="#ff0000"><H4><A NAME="methods"></A>Methods</H4>
</FONT><P>OOD Noun/Verb methodology sufficient to discover that this design needs the following methods: </P>

<UL>
<LI>void runThermostat() in Thermostat class </LI>
<LI>Thermostat(Furnace, User) constructor in Thermostat class </LI>
<LI>int getSetPoint() in User class </LI>
<LI>int getCurrentTemp() in User class </LI>
<LI>void turnFurnaceOn() in Furnace class </LI>
<LI>int getKeyboardInput() utility method in User class</LI></UL>

<P>Skeleton for a method, including the specification of the return type, or <I>void</I> in the method signature. </P>
<P>Invocation of methods with or without parameters. </P>
<P>What to do with incoming parameters when viewed from inside the method. </P>
<P>Proper use of the <B>return</B> statement in a method. </P>
<P>How to cause one method to call other methods. </P>
<P>Use of local variables in methods. </P>
<P>Incoming parameters to a method are local variables (either <I>primitive</I> or <I>reference</I>) in the method. </P>
<FONT COLOR="#ff0000"><H4><A NAME="messages"></A>Messages</H4>
</FONT><P>Mechanism and syntax for <I>sending a message</I> to an object in Java. </P>
<P>Sending a message to another object can result in the object returning an answer and knowledge of what to do with the answer. </P>


<P><!-prev=Java004k.htm-><!-next=Java004m.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="analysis_and_design_results__summary_"></A>Analysis and Design Results, Summary:</H3>
</FONT><B><P>Classes/objects established from nouns were:</P>

<UL>
</B><LI>Furnace/furnace </LI>
<LI>Thermostat/thermostat </LI>
<LI>User/user</LI></UL>

<B><P>Variables established from nouns were:</P>

<UL>
</B><LI>setPoint </LI>
<LI>currentTemperature </LI>
<LI>embedded links to other objects</LI></UL>

<B><P>Methods established from verb phrases were:</P>

<UL>
</B><LI>void runThermostat() in Thermostat class </LI>
<LI>Thermostat(Furnace, User) constructor in Thermostat class </LI>
<LI>int getSetPoint() in User class </LI>
<LI>int getCurrentTemp() in User class </LI>
<LI>void turnFurnaceOn() in Furnace class </LI>
<LI>int getKeyboardInput() utility method in User class</LI></UL>

<B><P>Implicit actions in methods established from verb phrases were:</P>

<UL>
</B><LI>send getSetPoint msg - runThermostat() </LI>
<LI>send getCurrentTemp msg - runThermostat() </LI>
<LI>test currentTemperature against setPoint - runThermostat() </LI>
<LI>announce no need to turn furnace on - runThermostat() </LI>
<LI>announce furnace turned on - turnFurnaceOn() </LI>
<LI>terminate program - runThermostat()</LI></UL>

<P>. </P>


<P><!-prev=Java004l.htm-><!-next=Java004n.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="discussion"></A>Discussion</H3>
</FONT><P>A previous section stated that the purpose of this lesson is to establish the minimum knowledge that must have been acquired by a beginning programming student before that student would be capable of designing and implementing the minimal object-oriented program specified above using the Java programming language. </P>


<P><!-prev=Java004m.htm-><!-next=Java004o.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="interesting_code_fragments_for_thermosta"></A>Interesting Code Fragments for Thermostat Program</H3>
</FONT><P>This section will discuss code fragments from the program for the purpose of establishing the minimum prior knowledge required of the student to qualify the student to design and write this program. </P>
<P>To begin with, the student would need to know about the two different kinds of comment indicators(// and /* */) used in Java. Javadoc comments can be deferred until later. </P>
<P>The student would need to have minimal knowledge of the concept of <I>objects</I>, <I>variables</I>, <I>message passing</I>, and <I>methods </I>in order to make use of the noun/verb methodology used earlier to discover the objects, variables, and methods required in the design. </P>
<P>All four of these concepts have analogs in the physical world such as</P>

<UL>
<LI>thermostats and furnaces for objects, </LI>
<LI>dial settings and quantities for variables, </LI>
<LI>electrical signals and the spoken word for messages, and </LI>
<LI>electrical switches, motors, heaters, etc., for methods.</LI></UL>

<P>Therefore, it shouldn't be too difficult to introduce these concepts at a very early stage in the educational process and to make the student understand how the programming constructs are often analogs of physical entities. </P>
<P>The required level of knowledge of these concepts will be discussed further along with the code fragments. </P>
<P>As in any programming activity, the student would have to know the mechanics of using the Java development environment in order to be able to enter, compile, and run a program. </P>
<P>The student would have to have minimal knowledge of the <I>java.io</I> and <I>java.util</I> packages in order to accomplish keyboard input. </P>
<P>Along this same line, the student would have to have minimal knowledge of the use of <I>import </I>statements in Java. At this stage in the process, this knowledge could have been simply memorized and understanding of the underlying concepts would not be required (for example, how many Pascal students really understand the underlying concepts for file I/O?). </P>
<P>The student would have to know how to display messages on the screen using statements such as the following:<BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><B>System.out.println("Main</B> method terminating");</PRE></TD>
</TR>
</TABLE>

<P>Again, at this stage, this could simply be memorized knowledge. </P>
<P>The student would have to have access to, and know how to use a method capable of getting integer data input from the keyboard. Unfortunately, this is one of the most difficult concepts in Java to master, and would of necessity be memorized knowledge at this stage. </P>
<P>The student would need to know that every Java application requires a controlling class, and that the controlling class requires a <B>main()</B> method with a fixed signature. Again, the skeleton for the controlling class and the skeleton for the <B>main()</B> method could be memorized, but the student would need to understand the body of the <B>main()</B> method. </P>
<P>The student would need to know that the <B>main()</B> method controls the flow of a Java application. In particular, when the <B>main() </B>method starts, the program starts running, and when the <B>main()</B> method terminates, the program stops running. </P>
<P>The student would need to have minimal knowledge of the concept of variables, and would need to know that Java has two kinds of variables: <I>primitive </I>variables and <I>reference </I>variables. </P>
<P>The student would need to understand that a variable name is an <I>abstraction</I> for a group of several bytes in memory that contain a value. </P>
<P>The student would need to know that the memory to contain the value represented by the variable of either type can be allocated using a statement of the form:<BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>variableType variableName;</PRE></TD>
</TR>
</TABLE>

<P>The student would need to know that the value stored in the memory represented by a <I>primitive </I>variable can be though of as the value of the variable. In other words, the name of a primitive variable evaluates to the value stored in its memory. </P>
<P>The student would need to know that the value stored in the memory represented by a <I>reference </I>variable is (or represents) the address in memory where an object is stored. </P>
<P>Along this line, the student would need to know that the <I>address</I> of an object stored in a <I>reference</I> variable is used to gain access to the object. While this is a rather abstract concept, the party game named <I>scavenger hunt</I> can be used to illustrate the concept, and most students should have no difficulty grasping the concept if it is carefully explained. </P>
<P>(The reason for hedging on <I>address</I> in the above text is that some Java virtual machines use a second level of indirection to refer to an object and the value in the reference is not necessarily the actual address of the object. However, this is all handled automatically, so the student doesn't need to be concerned about it.) </P>
<P>The student would need to know that objects are instances of classes, and that new objects are created (instantiated, caused to occupy memory) using statements of the form:<BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>refVariableName = new ClassName(optional parameters);</PRE></TD>
</TR>
</TABLE>

<P>where ClassName is the class of which this object is an instance. </P>
<P>The way this particular program is written, the student would also need to know that it is allowable (but not necessary) to combine the creation of the reference variable and the instantiation of the object using a combined statement such as the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>Thermostat thermostat = new Thermostat(furnace,user);</PRE></TD>
</TR>
</TABLE>

<P>where <B>Thermostat </B>is the name of a class and <B>thermostat </B>is the name of a reference variable. <B>furnace </B>and <B>user </B>are the optional parameters mentioned above. This statement will cause a new object to come into existence and occupy memory. The <I>reference</I> variable named <B>thermostat</B> will contain (or represent) the address of the new object in memory. </P>
<P>In order to have accomplished the object-oriented design of this program, the student would have discovered that there are three objects: <B>thermostat</B>, <B>furnace</B>, and <B>user</B>. The student would also have discovered that the <B>thermostat</B> object <I>uses</I> the <B>furnace</B> and <B>user</B> objects. </P>
<P>One object <I>uses </I>another object if the first object initiates communication with the other object for any purpose. In this case, the <B>thermostat</B> object <I>uses</I> the <B>user</B> object to get the value of the thermostat set point and the current temperature. It <I>uses</I> the <B>furnace</B> object by telling the <B>furnace</B> to <I>turn itself on</I> if the temperature is below the set point and more heat is needed. </P>
<P>The student would need to have knowledge of the concept of object constructors, and in particular, the ability to pass parameters to an object constructor. As a practical matter, this means that the student would need to have knowledge of the invocation of methods in general and the passing of parameters to those methods. This, in turn, means that the student would need to know what to do with incoming parameters when viewed from inside the method. </P>
<P>Having discovered all this, the student would need to translate that knowledge into the instantiation of the three objects shown in the following code fragment. Note that links or references to the <B>furnace</B> and <B>user</B> objects are passed as parameters to the constructor for the <B>thermostat</B> object to make it possible for the <B>thermostat</B> object to <I>use</I> these two objects as described above. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp;&nbsp;&nbsp; Furnace furnace = <B>new Furnace()</B>;
&nbsp;&nbsp;&nbsp; User user = <B>new User()</B>;
&nbsp;&nbsp;&nbsp; Thermostat thermostat = <B>new Thermostat(furnace,user)</B>;</PRE></TD>
</TR>
</TABLE>

<P>As indicated in the following code fragment, the student would need to have minimal knowledge of message passing, and in particular would need to know that the mechanism for <I>sending a message</I> to an object in Java is to invoke a method on a reference to the object using the period to join the name of the reference and the name of the method. For example, the following statement sends a message to the <B>thermostat</B> object to start it running.<BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp;&nbsp; <B>thermostat.runThermostat()</B>;</PRE></TD>
</TR>
</TABLE>

<P>The following code fragment shows the concepts and statements discussed above in context. A complete program listing is provided at the end of this lesson that shows the individual code fragments, such as this one, in the context of the entire program. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>class Ood05{//controlling class
&nbsp; public static void <B>main(String</B>[] args){
&nbsp;&nbsp;&nbsp; //Instantiate the objects used in the program
&nbsp;&nbsp;&nbsp; Furnace furnace = <B>new Furnace()</B>;
&nbsp;&nbsp;&nbsp; User user = <B>new User()</B>;
&nbsp;&nbsp;&nbsp; Thermostat thermostat = <B>new Thermostat(furnace,user)</B>;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Send a msg to start the thermostat running
&nbsp;&nbsp;&nbsp; <B>thermostat.runThermostat()</B>;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return to here when runThermostat() method terminates
&nbsp;&nbsp;&nbsp; <B>System.out.println("Main</B> method terminating");
&nbsp; }//end main()//terminate the program
}//end class Ood05</PRE></TD>
</TR>
</TABLE>

<P>Now, on to the next code fragment. </P>
<P>As mentioned earlier, the student would need to know something about classes. In particular, the student would need to know that a class definition can contain member variables, member methods, or both. </P>
<P>The distinction between <I>class </I>and <I>instance </I>members would not be important at this point. Also, issues regarding <I>access control</I> would not be important at this point. All the code could be written using <I>package</I> access. </P>
<P>The student would need to know that the skeleton for a minimal class definition is as follows: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><B>class</B> ClassName{//begin class definition
&nbsp; //optional data members
&nbsp; //optional method members
}//end class definition</PRE></TD>
</TR>
</TABLE>

<P>The student would need to know that data members, commonly called <I>instance variables</I>, are declared using statements such as the following: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp; //Instance Variables for data
&nbsp; int setPoint;
&nbsp; int currentTemperature;

&nbsp; //Instance Variables for links to other objects
&nbsp; Furnace furnace;
&nbsp; User user;</PRE></TD>
</TR>
</TABLE>

<P>This implies that the student has some knowledge of the primitive types, such as <B>int</B>. It also implies that the student knows that instance variables can be either <I>primitive</I> variables or <I>reference</I> variables, because the above code fragment contains two of each. </P>
<P>The student would need to know that the use of a <I>parameterized constructor</I> is optional. In this program, a <I>parameterized constructor</I> is required for the <B>Thermostat</B> class, but is not required for the other classes. </P>
<P>The student would need to know the syntax for a <I>parameterized constructor</I> as shown below: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp; <B>Thermostat(Furnace theFurnace, User theUser)</B>{
&nbsp;&nbsp;&nbsp; //Save links to other objects passed in as parameters
&nbsp;&nbsp;&nbsp; furnace = theFurnace;
&nbsp;&nbsp;&nbsp; user = theUser;
&nbsp; }//end constructor</PRE></TD>
</TR>
</TABLE>

<P>This constructor indicates that the student would need to understand the use of the <I>assignment</I> operator, and would need to understand that the <I>instance variables</I> of a class are directly accessible to the code in all of the methods (and constructors) that belong to the class. </P>
<P>The student would also need to know that incoming parameters to a method are essentially local variables (either <I>primitive</I> or <I>reference</I>) in the method and are directly accessible to all of the code in the method. This implies some knowledge of the use of <I>local variables</I>. </P>
<P>The student would need to understand <I>message passing</I> from both the sending and the receiving end. As mentioned earlier, sending a message to an object requires invoking a method of the object on a reference to the object. </P>
<P>The <B>Thermostat</B> class also illustrates message passing from the receiving end as well. The following method is designed to receive and process a method to cause the thermostat object to run. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>

  void <B>runThermostat</B>(){
    //send messages to get set point and 
    // current temperature
    setPoint = <B>user.getSetPoint()</B>;
    currentTemperature = <B>user.getCurrentTemperature()</B>;

    //test currentTemperature against setPoint
    <B>if(currentTemperature</B>  setPoint)//make announcement
      System.out.println("No need to turn furnace on");
    <B>else
</B>      //send msg to furnace to turn itself on
      <B>furnace.turnFurnaceOn()</B>;

    //announce runThermostat terminating
    System.out.println(
                  "Task complete, thermostat terminating");
  }//end runThermostat()</PRE></TD>
</TR>
</TABLE>

<P>Initially we see that the student would need to know the skeleton for a method, including the specification of the return type, or <I>void</I> in the method signature. </P>
<P>The first two statements show that the student will need to understand that sending a message to another object can result in the object sending back an answer. The student will need to know what to do with that answer. The simplest thing is to assign it to a variable as shown above. </P>
<P>Following this, we see that for this program in particular, the student will need to know how to use the <B><I>if/else</B></I> construct. Ideally, the student would know the fundamentals of <I>sequence, selection, </I>and <I>loop</I> before attempting an object-oriented design, even if it is a simple one. </P>
<P>At this point, the student shouldn't have any trouble using the following statement to send a message to the <B>furnace</B> object to tell it to turn itself on to provide some heat: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>furnace.turnFurnaceOn()</B>;</PRE></TD>
</TR>
</TABLE>

<P>This method ends with the <B>runThermostat()</B> method displaying a termination message and returning to the method from which it was called (the method that sent the message to activate it). </P>
<P>The concepts and code fragments discussed above are shown in context in the following code fragment. This code fragment is shown in the context of the entire program later. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>//This is the class from which the thermostat object
// is instantiated.
class <B>Thermostat</B>{
&nbsp; //Instance Variables for data (could use local variables)
&nbsp; int setPoint;
&nbsp; int currentTemperature;
&nbsp; //Instance Variables for links to other objects
&nbsp; Furnace furnace;
&nbsp; User user;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //Parameterized Constructor
&nbsp; <B>Thermostat(Furnace</B> theFurnace, User theUser){
&nbsp;&nbsp;&nbsp; //Save links to other objects passed in as parameters
&nbsp;&nbsp;&nbsp; furnace = theFurnace;
&nbsp;&nbsp;&nbsp; user = theUser;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; void <B>runThermostat</B>(){
&nbsp;&nbsp;&nbsp; //send msg to get setPoint
&nbsp;&nbsp;&nbsp; setPoint = user.getSetPoint();
&nbsp;&nbsp;&nbsp; //send msg to get currentTemperature
&nbsp;&nbsp;&nbsp; currentTemperature = user.getCurrentTemperature();
&nbsp;&nbsp;&nbsp; //test currentTemperature against setPoint
&nbsp;&nbsp;&nbsp; if(currentTemperature  setPoint)//make announcement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("No need to turn furnace on");
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //send msg to furnace to turn itself on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; furnace.turnFurnaceOn();
&nbsp;&nbsp;&nbsp; //announce runThermostat terminating
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Task complete, thermostat terminating");
&nbsp; }//end runThermostat()
}//end class Thermostat</PRE></TD>
</TR>
</TABLE>

<P>That brings us to the <B>Furnace</B> class from which the <B>furnace</B> object is instantiated. This is the simplest class of the three. It has no <I>instance variables</I> and has only one method. </P>
<P>The method named <B>turnFurnaceOn()</B> receives and processes messages to turn the furnace on to produce more heat. In this case, the only processing involved is to display a message indicating that the furnace has been turned on. There is nothing new for the student to be concerned about in this class. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>//Class from which furnace object is instantiated
class <B>Furnace</B>{
&nbsp; //Instance Variables - none
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; void <B>turnFurnaceOn(){//accepts</B> turn-on message
&nbsp;&nbsp;&nbsp; System.out.println("The furnace is on");
&nbsp; }//end turnFurnaceOn()
}//end class Furnace</PRE></TD>
</TR>
</TABLE>

<P>The next class is a class from which the <B>user</B> object is instantiated. The student will need to understand that the <B>user</B> object is an abstraction for the human user of the system. </P>
<P>In particular, the <B>user</B> object receives messages from other objects requesting information about the <I>set point</I> on the thermostat and the <I>current temperature.</I> The object then forwards those messages to the human user, and gets input from the human user by accessing the keyboard. </P>
<P>For example, the method shown below named <B>getSetPoint()</B> accepts messages from other objects requesting information on the <I>set point</I>. The method then </P>

<UL>
<LI>displays a request to the human user on the screen, </LI>
<LI>reads an integer value from the keyboard by calling the method named <B>getKeyboardInput()</B>, and </LI>
<LI>returns that value to the object that sent the message.</LI></UL>

<P>The student will need to know how to properly use the <B>return</B> statement in a method. </P>
<P>The student will also need to know how to call other methods of the same class. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>&nbsp; int <B>getSetPoint(){//accepts</B> get setPoint message
&nbsp;&nbsp;&nbsp; //Get set point data from human user
&nbsp;&nbsp;&nbsp; System.out.println("Enter set point");
&nbsp;&nbsp;&nbsp; <B>return getKeyboardInput();
</B>&nbsp; }//end getSetPoint()</PRE></TD>
</TR>
</TABLE>

<P>The method named <B>getCurrentTemperature()</B> behaves essentially the same as the one discussed above, and doesn't require any new knowledge on the part of the student so I won't discuss it here. </P>
<P>An understanding of the method named <B>getKeyboardInput()</B> in the following code fragment is clearly beyond the reach of the beginning Java student. This method exposes one of the gaping holes in the Java development environment. While the input/output system of Java is extremely flexible, it is also difficult to understand and and difficult to use for simple I/O. </P>
<P>Many intermediate-level Java programmers won't understand how this method works without considerable study. Fortunately, this is one of those standard operations that can simply be cut and pasted into a program to get the job done. </P>
<P>Peter van der Linden has provided an I/O class called <B>EasyIn </B>in his book <U>Just Java 1.1 and Beyond, Third Edition</U> which provides similar code for all the basic I/O operations, and has given the rest of us permission to use that code. The method shown below is a modified version of one of the methods in his <B>EasyIn </B>class. </P>
<P>The following code fragment puts the concepts and methods discussed above in context. This code fragment is shown in the context of the entire program in the next section. <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>//Class from which user object is instantiated. An object
// of this class forms the interface between the program
// and the human user.
class <B>User</B>{
&nbsp; //Instance Variables - none
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; int <B>getSetPoint(){//accepts</B> get setPoint message
&nbsp;&nbsp;&nbsp; //Get set point data from human user
&nbsp;&nbsp;&nbsp; System.out.println("Enter set point");
&nbsp;&nbsp;&nbsp; return getKeyboardInput();
&nbsp; }//end getSetPoint()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; int <B>getCurrentTemperature(){//accepts</B> get temperature msg
&nbsp;&nbsp;&nbsp; //Get current temperature data from human user
&nbsp;&nbsp;&nbsp; System.out.println("Enter current temperature");
&nbsp;&nbsp;&nbsp; return getKeyboardInput();
&nbsp; }//end getCurrentTemperature()
&nbsp; //-----------------------------------------------------//

&nbsp; //This utility method will read an int from the keyboard.
&nbsp; // Based on Peter van der Linden's EasyIn class. See
&nbsp; // "Just Java 1.1 and Beyond, Third Edition"
&nbsp; int <B>getKeyboardInput</B>(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader br = new BufferedReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new InputStreamReader( System.in ));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringTokenizer st = new StringTokenizer(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.readLine());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Integer.parseInt(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException excep) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("IO Exception in readInt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end getKeyboardInput()
}//end class User</PRE></TD>
</TR>
</TABLE>

<P>.</P>


<P><!-prev=Java004n.htm-><!-next=Java004p.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="program_listing_for_thermostat_program"></A>Program Listing for Thermostat Program</H3>
</FONT><P>The following program listing puts the previous discussion and code fragments in the context of the entire program.<BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Ood05.java Copyright 1997, R.G.Baldwin

The purpose of this program is to establish the minimum&nbsp;
knowledge that must have been acquired by a beginning&nbsp;
programming student before that student would be capable&nbsp;
of designing and writing a minimal object-oriented program.

The program uses the noun/verb methodology to convert the&nbsp;
program specification into an object-oriented design.

Program Specification:

Write an object-oriented program that simulates a&nbsp;
furnace, a thermostat, and a user.

First, the thermostat gets the set point from the user.&nbsp;
Then the thermostat gets the current temperature from the&nbsp;
user.&nbsp;

Then the thermostat tests the current temperature against&nbsp;
the set point. If the current temperature is above the&nbsp;
set point, the thermostat announces that there is no need&nbsp;
to turn the furnace on. If the current temperature is&nbsp;
below the set point, it turns the furnace on.&nbsp;

When the furnace is turned on, the furnace announces that&nbsp;
it has been turned on (like a pilot light)

The program terminates at this point.

End program specification


The bulk of the Analysis and Design of this program was
explained earlier in this lesson and won't be repeated
here. The result of that analysis and design effort is
shown below.&nbsp;&nbsp;

<B>Establish classes/objects from nouns:

</B>Furnace/furnace
Thermostat/thermostat
User/user


<B>Establish variables from nouns:

</B>setPoint
currentTemperature
embedded links to other objects


<B>Establish methods from verb phrases:

</B>void runThermostat() in Thermostat class
Thermostat(Furnace, User) constructor in Thermostat class
int getSetPoint() in User class
int getCurrentTemp() in User class
void turnFurnaceOn() in Furnace class
int getKeyboardInput() utility method in User class



<B>Establish implicit actions in methods from verb phrases:

</B>send getSetPoint msg - runThermostat()

send getCurrentTemp msg - runThermostat()
test currentTemperature vs setPoint - runThermostat()
announce no need to... - runThermostat()
announce furnace turned on - turnFurnaceOn()
terminate program - runThermostat()


Tested using JDK 1.1.3 under Win 95.&nbsp; Two sets of output
from the program follow:
&nbsp;&nbsp;
<B>Enter set point
75
Enter current temperature
80
No need to turn furnace on
Task complete, thermostat terminating
Main method terminating&nbsp;&nbsp;
--------------

Enter set point
80
Enter current temperature
75
The furnace is on
Task complete, thermostat terminating
Main method terminating
</B>**********************************************************/

import java.io.*;
import java.util.*;
//=======================================================//
class Ood05{
&nbsp; //All Java applications require a controlling class
&nbsp; // with a main method.
&nbsp; public static void main(String[] args){
&nbsp;&nbsp;&nbsp; //Instantiate the objects used in the program
&nbsp;&nbsp;&nbsp; // Could instantiate anonymously in call to Thermostat
&nbsp;&nbsp;&nbsp; // constructor, but would not illustrate the object
&nbsp;&nbsp;&nbsp; // concept as clearly.
&nbsp;&nbsp;&nbsp; Furnace furnace = new Furnace();
&nbsp;&nbsp;&nbsp; User user = new User();
&nbsp;&nbsp;&nbsp; //Make the Thermostat object aware of the Furnace
&nbsp;&nbsp;&nbsp; // object and the User object when it is instantiated.
&nbsp;&nbsp;&nbsp; Thermostat thermostat = new Thermostat(furnace,user);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Start the thermostat running
&nbsp;&nbsp;&nbsp; thermostat.runThermostat();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //Return to here when runThermostat() method terminates
&nbsp;&nbsp;&nbsp; System.out.println("Main method terminating");
&nbsp; }//end main()
}//end class Ood05
//=======================================================//

//This is the class from which the thermostat object
// is instantiated.
class Thermostat{
&nbsp; //Instance Variables for data (could use local variables)
&nbsp; int setPoint;
&nbsp; int currentTemperature;
&nbsp; //Instance Variables for links to other objects
&nbsp; Furnace furnace;
&nbsp; User user;
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //Parameterized Constructor
&nbsp; Thermostat(Furnace theFurnace, User theUser){
&nbsp;&nbsp;&nbsp; //Save links to other objects passed in as parameters
&nbsp;&nbsp;&nbsp; furnace = theFurnace;
&nbsp;&nbsp;&nbsp; user = theUser;
&nbsp; }//end constructor
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; void runThermostat(){
&nbsp;&nbsp;&nbsp; //send msg to get setPoint
&nbsp;&nbsp;&nbsp; setPoint = user.getSetPoint();
&nbsp;&nbsp;&nbsp; //send msg to get currentTemperature
&nbsp;&nbsp;&nbsp; currentTemperature = user.getCurrentTemperature();
&nbsp;&nbsp;&nbsp; //test currentTemperature against setPoint
&nbsp;&nbsp;&nbsp; if(currentTemperature  setPoint)//make announcement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("No need to turn furnace on");
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //send msg to furnace to turn itself on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; furnace.turnFurnaceOn();
&nbsp;&nbsp;&nbsp; //announce runThermostat terminating
&nbsp;&nbsp;&nbsp; System.out.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Task complete, thermostat terminating");
&nbsp; }//end runThermostat()
}//end class Thermostat
//=======================================================//

//Class from which furnace object is instantiated
class Furnace{
&nbsp; //Instance Variables - none
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; void turnFurnaceOn(){//accepts turn-on message
&nbsp;&nbsp;&nbsp; System.out.println("The furnace is on");
&nbsp; }//end turnFurnaceOn()
}//end class Furnace
//=======================================================//

//Class from which user object is instantiated. An object
// of this class forms the interface between the program
// and the human user.
class User{
&nbsp; //Instance Variables - none
&nbsp;&nbsp;
&nbsp; //Instance Methods
&nbsp;&nbsp;
&nbsp; int getSetPoint(){//accepts get setPoint message
&nbsp;&nbsp;&nbsp; //Get set point data from human user
&nbsp;&nbsp;&nbsp; System.out.println("Enter set point");
&nbsp;&nbsp;&nbsp; return getKeyboardInput();
&nbsp; }//end getSetPoint()
&nbsp; //-----------------------------------------------------//
&nbsp;&nbsp;
&nbsp; int getCurrentTemperature(){//accepts get temperature msg
&nbsp;&nbsp;&nbsp; //Get current temperature data from human user
&nbsp;&nbsp;&nbsp; System.out.println("Enter current temperature");
&nbsp;&nbsp;&nbsp; return getKeyboardInput();
&nbsp; }//end getCurrentTemperature()
&nbsp; //-----------------------------------------------------//

&nbsp; //This utility method will read an int from the keyboard.
&nbsp; // Based on Peter van der Linden's EasyIn class. See
&nbsp; // "Just Java 1.1 and Beyond, Third Edition"
&nbsp; int getKeyboardInput(){
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader br = new BufferedReader(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new InputStreamReader( System.in ));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringTokenizer st = new StringTokenizer(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.readLine());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Integer.parseInt(st.nextToken());
&nbsp;&nbsp;&nbsp; }catch (IOException excep) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("IO Exception in readInt");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }//end catch
&nbsp; }//end getKeyboardInput()
}//end class User
//=======================================================//</PRE></TD>
</TR>
</TABLE>

<P>. </P>


<P><!-prev=Java004o.htm-><!-next=Java004q.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="noun_verb_analysis_and_design"></A>Noun/Verb Analysis and Design</H3>
</FONT><P>This section walks through the noun/verb analysis and design process for this object-oriented program. Note that very little in the way of explanation is provided, so it may make for fairly difficult reading.</P>
<FONT COLOR="#ff0000"><H4>Program Specification:</H4>
</FONT><P>The specification for the program is repeated here for your convenience. </P>
<P>Write an object-oriented program that simulates a furnace, a thermostat, and a user. </P>
<P>First, the thermostat gets the <I>set point</I> from the user (the user adjusts the thermostat). </P>
<P>Then the thermostat gets the <I>current temperature</I> from the user (the user substitutes for the built-in thermometer in the thermostat). </P>
<P>Then the thermostat tests the <I>current temperature</I> against the <I>set point</I>. If the current temperature is above the set point, the thermostat announces that there is no need to turn the furnace on. If the current temperature is below the set point, it sends a message to the furnace asking it to turn on. </P>
<P>When the furnace is turned on, the furnace announces that it has been turned on (like a pilot light). </P>
<P>The program terminates at this point. </P>
<FONT COLOR="#ff0000"><H4>Analysis and Design:</H4>
</FONT><B><P>Extract nouns as candidates for objects and instance variables:</B> </P>
<P>furnace, thermostat, set point, user, current temperature </P>
<P>. </P>
<B><P>Extract verb phrases as candidates for methods and implicit actions within methods:</B> </P>
<P>Write..program,(programmer action) </P>
<P>simulates..furnace..thermostat, (programmer action) </P>
<P>thermostat gets..set point..user (program action) </P>
<P>thermostat gets..current temperature..user (program action) </P>
<P>thermostat tests..current temperature..set point (program action) </P>
<P>thermostat announces..no need.. (program action) </P>
<P>it(thermostat) turns.. furnace on. (program action) </P>
<P>furnace..announces..turned on (program action) </P>
<P>program terminates (program action) </P>
<P>. </P>
<B><P>Establish classes/objects from nouns:</B> </P>
<P>Furnace/furnace, Thermostat/thermostat, User/user </P>
<P>. </P>
<B><P>Establish variables from nouns:</B> </P>
<P>setPoint, currentTemperature, embedded links to other objects </P>
<P>. </P>
<B><P>Establish methods from verb phrases:</B> </P>
<P>void runThermostat() in Thermostat class </P>
<P>Thermostat(Furnace, User) constructor in Thermostat class </P>
<P>int getSetPoint() in User class </P>
<P>int getCurrentTemp() in User class </P>
<P>void turnFurnaceOn() in Furnace class </P>
<P>int getKeyboardInput() utility method in User class </P>
<P>. </P>
<B><P>Establish implicit actions in methods from verb phrases:</B> </P>
<P>send getSetPoint msg - runThermostat() </P>
<P>send getCurrentTemp msg - runThermostat() </P>
<P>test currentTemperature against setPoint - runThermostat() </P>
<P>announce no need to... - runThermostat() </P>
<P>announce furnace turned on - turnFurnaceOn() </P>
<P>terminate program - runThermostat() </P>


<P><!-prev=Java004p.htm-><!-next=Java004r.htm><!-first=Java004.htm-></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review_questions_for_lesson_4"></A>Review</H2>
</FONT><P>Q - Both C++ and Java support the older-style top-down procedural programming approach as a <U>complete solution</U> to a programming problem: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. In Java all programs must be written in an object-oriented style.</FONT> </P>
<P>Q - Describe how object-oriented programming differs from typical top-down procedural programming? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The classic approach to procedural programming often begins with development of the functions and procedures and then progresses to development of the data structures. The result is frequently a very poor model of the problem being solved. The object-oriented programming approach attempts to express computer programs in <U>ways that model how people perceive the world</U>.</FONT> </P>
<P>Q - Describe the object-oriented paradigm as it relates to the solution problems faced by persons working in other crafts. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - People who solve problems in other crafts deal with their problem domains by concentrating on the objects and letting the characteristics of those objects determine the procedures to apply to them. (The characteristic of a nail suggests that you hit it on the head with a hammer, for example.).</FONT> </P>
<P>Q - The terminology of object-oriented programming is part of the everyday language of programmers with no training in object-oriented programming: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Object-oriented programming has developed its own jargon which may differ widely depending on which book you may be reading at the time.</FONT> </P>
<P>Q - List the three characteristics of an object-oriented language. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Encapsulation, inheritance, and polymorphism.</FONT> </P>
<P>Q - Knowledge of the characteristics of new types is built into the Java compiler: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The java compiler knows nothing about the characteristics of a new type until provided a definition of the new type through use of a <B>class</B> definition.</FONT> </P>
<P>Q - What are the two general aspects of a new type that are defined when a Java programmer defines a new type? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Data representation and behavior.</FONT> </P>
<P>Q - In Java, the <B>struct</B> keyword is used to define a new type: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. While the <B>struct</B> keyword can be used to define a new type in C++, only the <B>class</B> keyword can be used to define a new type in Java.</FONT> </P>
<P>Q - An object normally is considered to have _____ and _____. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - State and behavior.</FONT> </P>
<P>Q - The state of an object is defined by what? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The current values of its instance variables or data members.</FONT> </P>
<P>Q - The behavior of an object is defined by what? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The methods of the <B>class </B>from which the object was instantiated.</FONT> </P>
<P>Q - What is the source of the jargon "To instantiate an object?" </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - This jargon derives from the fact that an object is an instance of a class.</FONT> </P>
<P>Q - An object is an _______ of a class. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Instance</FONT> </P>
<P>Q - A programmer encapsulates the data representation and behavior of an abstract data type into a class, thereby defining its implementation and interface: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - An encapsulated design typically hides its implementation from the class user and reveals its interface: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - In accordance with the theory of reusable code, the programmer should always be concerned with the implementation of the data storage mechanism in a class defined by another programmer: True or False? Explain your answer. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. If a class is properly defined, adequately tested, and properly documented, it should be possible for another programmer to make use of the class without concern for the actual data storage mechanism employed by the class definition.</FONT> </P>
<P>Q - What does it mean to "send a message to an object" in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Sending a message to an object in Java means to invoke one of its methods.</FONT> </P>
<P>Q - The interface of a class consists of its private methods: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The private methods of a class are not accessible and therefore cannot serve as the interface.</FONT> </P>
<P>Q - What is usually the purpose of accessor or interface methods of a class? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The normal purpose of accessor or interface methods is to restrict access to the instance variables and to allow them to be manipulated only in a controlled manner.</FONT> </P>
<P>Q - Good programming practice calls for always making the data members or instance variables of a class public: True or False. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Good programming practice usually calls for making the instance variables of a class private and providing public accessor or interface methods which allow for controlled manipulation of those instance variables.</FONT> </P>
<P>Q - The interface methods of a class should always be bound to a particular implementation of the data storage of the class: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. The interface methods should not be bound to a particular implementation of the data storage mechanism. This allows for later improving upon the data storage mechanism without rendering the interface methods invalid.</FONT> </P>
<P>Q - Describe the messaging process in an object-oriented program. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Someone wrote that an object-oriented program consists simply of a bunch of objects laying around sending messages to each other. This might be a slight exaggeration, but is not far from the truth.</FONT> </P>
<P>Q - What are some of the names given to the methods or functions that are embedded inside of a class definition? </P>
<FONT COLOR="#0000ff"><P>A - Instance methods and class methods.</FONT> </P>
<P>Q - In inheritance, what are some of the common names for the class that is inherited from, and what are some of the common names of the new class? </P>
<FONT COLOR="#0000ff"><P>A - Inherited from: base class and super class. New class: derived class and subclass.</FONT> </P>
<P>Q - Can a subclass be further subclassed? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Normally yes although in Java it is possible to prevent further subclassing through use of the <B>final</B> keyword.</FONT> </P>
<P>Q - A derived class inherits the data representation and behavior of the base class and can also add new data representation and behavior: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - What do you call the process of modifying a derived class so that some portion of the behavior of its objects differs from the behavior of objects of the base class (other than simply adding new behavior)? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Implementing runtime polymorphism by overriding methods.</FONT> </P>
<P>Q - You can always instantiate objects of both the base class and the derived class: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. You cannot instantiate objects of the base class if it is an <I>abstract</I> base class.</FONT> </P>
<P>Q - What do you call a base class that exists only to be derived from? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - An abstract base class.</FONT> </P>
<P>Q - Describe one or more uses for inheritance. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - When several of your abstract data types have characteristics in common, you can design their commonalities into a single base class and separate their unique characteristics into unique derived classes.</FONT> </P>
<P>Q - What characteristics existing among several classes might cause you to decide to combine some of those characteristics into a base class? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Common characteristics.</FONT> </P>
<P>Q - The <B>ISA </B>relationship is more closely related to </P>

<UL>
<LI>overloaded operators, </LI>
<LI>inheritance, or </LI>
<LI>overriding functions?</LI></UL>

<FONT SIZE=2 COLOR="#0000ff"><P>A - Inheritance.</FONT> </P>
<P>Q - Both Java and C++ fully support multiple inheritance: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Java does not support multiple inheritance.</FONT> </P>
<P>Q - Polymorphism exists when functions or operators are overloaded or overridden to cause them to perform operations not inherently recognized by the compiler: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - Function overloading is a form of runtime polymorphism: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Function overloading is a form of compile-time polymorphism.</FONT> </P>
<P>Q - Operator overloading is fully supported in both C++ and Java: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. Unfortunately, operator overloading is not supported by Java, at least that is the case with the JDK 1.1 specification.</FONT> </P>
<P>Q - Polymorphic behavior exists only in the most modern languages such as C++ and Java: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. For example, early languages such as BASIC, interpret the plus operator to be an arithmetic operator when applied to numeric data and to be a concatenation operator when applied to string or character data.</FONT> </P>
<P>Q - <I>Overloading a method</I> is the process of modifying the method to cause it to behave differently relative to objects of the base class and the derived class: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. This description applies to <I>overriding</I> a method.</FONT> </P>
<P>Q - <I>Overriding a method</I> is the process of modifying the method to cause it to behave differently relative to objects of the base class and the derived class: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - What are the two kinds of polymorphism recognized by many authors? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Runtime polymorphism and compile-time polymorphism.</FONT> </P>
<P>Q - The implementation of polymorphism essentially consists of providing multiple functions or methods with the same name, and calling the correct one at the appropriate time, True or False. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True</FONT> </P>
<P>Q - If the construction is such that it is clear at compile time which version of two or more methods having the same name should be called in a particular instance, this is referred to as ______________________ <I>polymorphism</I>. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Compile-time polymorphism</FONT> </P>
<P>Q - Name one form of compile-time polymorphism. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Operator overloading</FONT> </P>
<P>Q - In general, overriding methods results in what type of polymorphism? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Runtime polymorphism</FONT> </P>
<P>Q - In general, overriding methods results in what type of binding? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Late binding</FONT> </P>
<P>Q - What is the maximum number of free-standing functions that you are allowed to define in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - None. Java does not support free-standing functions.</FONT> </P>
<P>Q - What are the two categories of methods that can exist in a Java program? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Class methods and instance methods</FONT> </P>
<P>Q - How do you invoke class methods in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Using the name of the class and the name of the method joined by a period</FONT> </P>
<P>Q - How do you invoke instance methods in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Using the name of an object and the name of the method joined by a period</FONT> </P>
<P>Q - What is the maximum number of global variables and objects that you are allowed to declare in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - None. Java does not support global variables or objects.</FONT> </P>
<P>Q - What are the three categories of variables that can exist in a Java program? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Class variables, instance variables, and local variables in methods.</FONT> </P>
<P>Q - How are class variables accessed in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Using the name of the class and the name of the variable joined by a period.</FONT> </P>
<P>Q - How are instance variables accessed in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Using the name of an object and the name of the variable joined by a period.</FONT> </P>
<P>Q - What is the access scope for a local variable in a method in Java? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Local variables in methods can only be accessed within the scope of the method as in C, Pascal, and other languages which support local variables within sub-programs. In some cases in Java, the actual scope of a local variable may be restricted to less than the full scope of the method by declaring it within a brace-enclosed block.</FONT> </P>
<P>Q - Java requires the use of exception handling: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - Explain in general terms the use of the keywords <I>try, throw, </I>and <I>catch</I>. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - These keywords are used to monitor for exceptional conditions within your program, and to transfer control to special exception-handling code whenever an exceptional condition is detected.</FONT> </P>
<P>Q - In general, in both Java and C++, you must write the code which <I>throws</I> all exception objects: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - False. That is pretty much true for C++. However, for Java, there are numerous situations where an exceptional condition will be detected and thrown by the runtime system which can automatically transfer control to special exception-handling code which you write.</FONT> </P>
<P>Q - An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions: True or False? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - True.</FONT> </P>
<P>Q - All exceptions in Java are thrown as objects which must derive either directly or indirectly from a particular class. What is the name of that class? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - When an exceptional condition causes an exception to be <I>thrown </I>in Java, that exception is an object derived, either directly, or indirectly from the class <B>Throwable</B>.</FONT> </P>
<P>Q - There is a large group of exceptional conditions in Java that must be <I>recognized </I>in order for your program to compile. What is meant by <I>recognized </I>in this context? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Recognition can consist of either catching and processing the exception, or passing it up to the next level in the method invocation hierarchy.</FONT> </P>
<P>Q - What is the keyword that is used to pass an exceptional condition up to the next level in the method-invocation hierarchy? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - If your method passes an exception up to the next level in the invocation hierarchy, this must be declared along with the method signature using the <B>throws</B> keyword.</FONT> </P>
<P>Q - List three advantages of using exception handling rather than "traditional" error management techniques. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - Exception handling provides the following advantages over "traditional" error management techniques:</P>

<UL>
<LI>Separating Error Handling Code from "Regular" Code</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Propagating Errors Up the Call Stack</FONT> </LI>
<FONT SIZE=2 COLOR="#0000ff"><LI>Grouping Error Types and Error Differentiation</LI></UL>

</FONT><P>Q - When you use the narrative description of your problem to generate the first-cut object-oriented design, what is suggested by the nouns in your narrative, and what is suggested by the verbs? </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - The nouns suggest the possibility of classes and/or data members of the classes while the verbs suggest methods.</FONT> </P>
<P>Q - Write a Java application that meets the following specifications: <BR>
&nbsp; </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>



/*SampProg01.java from lesson 4
Copyright 1997, R.G.Baldwin
Without looking at the solution which follows, write an 
application that will execute the following main method 
and display a date in month/day/year syntax followed by 
your name.

  public static void main(String[] args){ //define main 
    MyDateClass obj = new MyDateClass(); //instantiate obj
    obj.setDate(4,8,37); //store data in instance var
    //display instance variables
    System.out.println( obj.getDate() ); 
    System.out.println("Dick Baldwin");    
  }//end main
**********************************************************/

import java.util.*;

class MyDateClass { //define new type using keyword class
  int month, day, year; // instance variables of the class
  final double AVOGADRO = 6.23;

  //instance method to store data
  void setDate(int mo, int da, int yr) 
  {
    int[] myArray;
    myArray = new int[25];
    
    month = mo;
    day = da;
    year = yr;
  }//end method setDate()

  String getDate()//instance method to get data
  {
    return "" + month + "/" + day + "/" + year;
  }// end method getDate()

}//end class MyDateClass definition

//Driver program follows
class SampProg01 { //define the controlling class
  public static void main(String[] args){ //define main
    MyDateClass obj = new MyDateClass(); //instantiate obj
    obj.setDate(4,8,37); //store data in instance variables
    //display instance variables
    System.out.println( obj.getDate() ); 
    System.out.println("Dick Baldwin");
 }//end main
}//end SampProg01 class</PRE></TD>
</TR>
</TABLE>
<P><!-prev=Java004q.htm-><!-first=Java004.htm-></P>
<P>-end- <!--end--></P>

Copyright 2000, Richard G. Baldwin.  Reproduction in whole or in part in any form or medium
without express written permission from Richard Baldwin is prohibited. 

</BODY>
</HTML>
