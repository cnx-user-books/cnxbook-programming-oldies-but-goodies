<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">
  <title>... JAVA and DSP by Richard G Baldwin</title>
</head>
  <body link="#0000ff" vlink="#666666" alink="#ff0000" lang="EN-US">
 
<h2>Plotting Large Quantities of Data using Java</h2>
    <p><i>Learn how to use Java to plot millions of multi-channel data values 
	in an easy-to-view format with very little programming effort.</i></p>
<p><b>Published:</b>&nbsp; August 23, 2005<br>
   <b>By <a href="#About_the_author">Richard G. Baldwin</a></b> </p>
     
<p>Java Programming, Notes # 1492</p>
     
<ul>
	<li><a href="#Preface">Preface</a></li>
	<li><a href="#Preview">Preview</a></li>
	<li><a href="#A_Sample_Program">Sample Programs </a></li>
	<li><a href="#Run_the_Program">Run the Programs</a></li>
	<li><a href="#Summary">Summary</a></li>
	<li><a href="#Whats Next">What's Next?</a></li>
	<li><a href="#Complete_Program_Listing">Complete Program Listings</a></li>
</ul>
        
<hr size="3" width="100%" align="center">    
<center>    
<h2> <a name="Preface"></a>Preface</h2>
   </center>
  <p>In one of my earlier lessons entitled
<a href="http://www.developer.com/java/other/article.php/10936_1554511_1">
Plotting Engineering and Scientific Data using Java</a>, I published a 
	generalized 2D plotting class that makes it easy to cause other programs to display 
their outputs in 2D
<a href="http://mathworld.wolfram.com/CartesianCoordinates.html">Cartesian 
coordinates</a>.&nbsp; I have used that plotting class in numerous lessons 
since I published it.&nbsp; Hopefully, some of you have been using 
	it as well.</p>
<p>In another of my earlier lessons entitled 
<a href="http://www.developer.com/java/other/article.php/3508706">Plotting 3D 
Surfaces using Java</a>, I presented and explained a 3D surface plotting class that is also 
very easy to use.&nbsp; I have used that class in several lessons since then, 
and I will be using it in many future lessons as well.</p>
<p><font color="#FF0000"><b>Plotting large quantities of data</b></font></p>
<p>One of the common requirements of engineering, technical, and scientific 
computing is to be able to plot and to examine very large quantities of data.&nbsp; 
This is particularly true in time-series analysis, spectral analysis, and 
digital signal processing <i>(<a href="http://www.dickbaldwin.com/tocdsp.htm">DSP</a>).</i>&nbsp; 
I will present and explain four separate Java classes in this lesson, which make 
it very easy to plot and to examine large quantities of data in Java programs.</p>
<p><font color="#FF0000"><b>How do you use these classes?</b></font></p>
<p>All that's necessary to use these classes to plot large quantities of data is 
to:</p>
<ol>
	<li>Instantiate a plotting object of type <b>PlotALot01</b>, <b>PlotALot02</b>,
	<b>PlotALot03</b> or <b>PlotALot04</b>.</li>
	<li>Feed the data values that need to be plotted to the plotting object as 
	they become available.</li>
	<li>Invoke a method named <b>plotData</b> on the plotting object when all of 
	the data has been fed to the object.</li>
</ol>
<p><font color="#FF0000"><b>It couldn't be easier</b></font></p>
<p>The choice among the four classes listed&nbsp;above depends on whether you need to plot one, two, or three channels of data, and the 
format in which you want to plot the data.&nbsp; The 
class named <b>PlotALot01</b> is used to plot single-channel data.&nbsp; The 
classes named <b>PlotALot02 </b>and<b> PlotALot03</b> are used to plot 
two-channel data in two different formats.&nbsp; The class named <b>PlotALot04</b> 
is used to plot three-channel data.</p>
<p><font color="#FF0000"><b>Will use in subsequent lessons</b></font></p>
<p>These plotting classes will be used in numerous future lessons involving such 
complex topics as adaptive signal processing using Java.</p>
<p><font color="#FF0000"><b>A free plotting class</b></font></p>
<p>If you arrived at this page seeking a free Java class for plotting your data, 
you are in luck.&nbsp; Just copy the source code for the classes in Listing 35 
through Listing 38 near the end of this lesson and feel free to use them as 
described in the comments in the source code.</p>
<p>On the other hand, if you would like to learn how the classes do what they 
do, and perhaps use your programming skills to improve them, keep reading.&nbsp; 
Hopefully, once you have finished the lesson, you will have learned quite a lot 
about plotting large quantities of data using Java.</p>
<p><b><font color="#ff0000">Viewing tip</font></b> </p>
 
<p>You may find it useful to open another copy of this lesson in a separate
 browser window.&nbsp; That will make it easier for you to scroll back and
 forth among the different figures and listings while you are reading about
 them. </p>
 
<p><b><font color="#ff0000">Supplementary material</font></b> </p>
 
<p>I recommend that you also study the other lessons in my extensive collection
 of online Java tutorials.&nbsp; You will find those lessons published at
<a href="http://softwaredev.earthweb.com/java">Gamelan.com</a>.&nbsp; However, 
as of the date of this writing, Gamelan doesn't maintain a consolidated index 
of my Java tutorial lessons, and sometimes they are difficult to locate there.&nbsp; 
You will find a consolidated index at <a
 href="http://www.dickbaldwin.com">www.DickBaldwin.com</a><font
 color="#000000">.</font></p>
<h2 align="center"><a name="Preview">Preview</a></h2>
<p>The four classes that I will present and explain in this lesson are designed 
to make it easy for you to plot and examine large quantities of data.</p>
<p><font color="#FF0000"><b>Sample output for PlotALot01class </b> </font></p>

<p>The first class named <b>PlotALot01</b> is designed for the plotting of 
large quantities of single-channel data.&nbsp; Figure 1 shows an example of the 
plotted output 
from this class when used to plot a <i>small amount</i> of data.</p>






<p>
<div align="center">
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java1492a1.jpg" width="401" height="411"></td>
    </tr>
    <tr>
      <td>
      <img border="0" src="java1492a2.jpg" width="401" height="411"></td>
    </tr>
    <tr>
      <td>
      <b>Figure 1</b></td>
    </tr>
  </tbody>
</table>
</div>
</p>
<p><font color="#FF0000"><b>Usage information</b></font></p>
<p>To use the class named <b>PlotALot01</b> to plot data, you first instantiate 
an object of the class, and then you feed data to it as the data becomes 
available within your program.</p>
<p>When all of the data has been fed to the plotting object, you invoke a 
method named <b>plotData</b> on the object.&nbsp; This causes the object to 
produce one or more pages of plotted data in a stack on the screen.&nbsp; The page 
containing the earliest data is on the top of the stack and the page containing the 
latest data on the bottom of the stack.</p>
<p><font color="#FF0000"><b>Plotting format</b></font></p>
<p>The first data sample is plotted on the left end of the top trace on the top 
page <i>(entitled Page: 0).</i>&nbsp; Successive data values are plotted from 
left to right across the page.&nbsp; When the data for the first trace reaches 
the right end of the trace, the next data sample is plotted at the left end of 
a new trace that is created below the current trace.&nbsp; Hence, the 
chronological order of the data is from left to right, top to bottom.</p>
<p>A horizontal axis is drawn for each trace.&nbsp; Positive data values are 
plotted above the axis and negative values are plotted below the axis.</p>
<p><font color="#FF0000"><b>On to the next page</b></font></p>
<p>When the bottom trace on a page is filled, a new page is created 
automatically.&nbsp; The next data sample is plotted on the left end of the 
top trace on the new page and the process described above is repeated until 
that page also become full.&nbsp; Then a new page is created, etc.</p>
<p><font color="#FF0000"><b>Nearly unlimited plotting capacity</b></font></p>
<p>You can cause the page size to be as large as you want up to the full size of 
the screen on your computer.&nbsp; You can create as many pages as you want and 
you can place as many traces on each page as you want.</p>
<p>Other than the amount of memory that is available to the Java virtual 
machine, <i>(and perhaps some limit on the number of <b>Page</b> objects allowed by the 
operating system),</i> there is almost no limit to the number of pages that can be produced and 
the amount of data that can be plotted.</p>
<p><font color="#FF0000"><b>Millions of data values plotted</b></font></p>
<p>I have successfully plotted two 
million data values in 141 full screen pages on a modest laptop computer with 
no difficulty whatsoever.&nbsp; When I pushed that total up to eight million 
data values in 563 full screen pages, the plotting process slowed down, but I 
was still able to display and examine the plots.&nbsp; The practical limit on my 
computer seems to be somewhere between two million and eight million data 
values.</p>
<p><font color="#FF0000"><b>Two sample pages</b></font></p>
<p>Figure 1 shows two pages that were physically removed from the stack and 
arranged with the page containing the earliest data above the page containing 
the latest data for publication in this lesson.</p>
<p><font color="#FF0000"><b>Two overloaded constructors</b></font></p>
<p>Two overloaded constructors are provided for the class.&nbsp; One constructor 
plots the data using a set of default plotting parameters.&nbsp; This 
constructor is provided for extreme ease of use.&nbsp; The only information that 
you must provide to this constructor is a string that becomes part of the title 
for each page.</p>
<blockquote>
	<p><i>(The pages in Figure 1 were plotted using default plotting 
parameters with a title string of &quot;B&quot;.&nbsp; The amount of data that 
was fed to the plotting object for Figure 1 filled Page 0 and almost filled Page 
1.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Can change default plotting parameters</b></font></p>
<p>I set the values of the default plotting parameters to make the results suitable for use 
in this narrow publication format.&nbsp; If you don't like my choice of default 
plotting parameters, you can change them to values that you find more useful.&nbsp; 
For example, you could cause the default size of the <b>Frame</b> object to fill 
your screen, allowing you to plot quite a lot of data on each page.</p>
<p><font color="#FF0000"><b>Control over the plotting parameters</b></font></p>
<p>The other overloaded constructor takes seven parameters that allow you to 
control all aspects of the plotting format including:</p>
<ul>
	<li>Page title</li>
	<li>Frame width and hence plotted data width</li>
	<li>Frame height, spacing between traces, and hence the number of traces per 
	page</li>
	<li>Spacing between samples, number of traces per page, and hence the number 
	of samples per page</li>
	<li>Width and height of an oval that is used to mark each sample on the plot</li>
</ul>
<p>The plotted sample values are connected by a straight line.&nbsp; Each 
sample is marked with an oval.&nbsp; You can specify the width and the height 
of the oval in pixels.&nbsp; If you set the width and height to zero, the oval 
simply disappears from the plot.</p>
<p><font color="#FF0000"><b>Default plotting parameters in Figure 1</b></font></p>
<p>The plots in Figure 1 were produced using the constructor that applies 
default plotting parameters.&nbsp; For example, the data was plotted using the default 
value of two pixels per sample.&nbsp; Hence the lines connecting the sample 
values in Figure 1 are very short.</p>
<p>The ovals in Figure 1 had a default 
width and height of two pixels each.&nbsp; At this small size, the ovals end up 
looking more like plus characters than ovals.</p>
<p>The overall parameters governing the plot in Figure 1 were:</p>
<pre>Title: B
Frame width: 400
Frame height: 410
Page width: 392
Page height: 383
Trace spacing: 50
Sample spacing: 2
Traces per page: 7
Samples per page: 1372</pre>
<p><font color="#FF0000"><b>Explanation of terms</b></font></p>
<p>Some explanation of the terminology in the above list is probably in order.&nbsp; 
The <i>Frame width</i> and <i>Frame height</i> are the actual width and height 
of the <b>Frame</b> objects shown in Figure 1.</p>
<p>The <i>Page width</i> and <i>Page height</i> are the width and height of a <b>
Canvas</b> object contained in the <b>Frame</b> object, upon which the plotting 
is performed.&nbsp; The width of the <b>Canvas</b> actually controls the number 
of samples that can be plotted in each trace.</p>
<p>The <i>Trace spacing</i> is the number of pixels that separate each of the 
horizontal axes on a page in Figure 1.</p>
<p>The <i>Sample spacing</i> specifies the number of pixels that are dedicated 
to each sample horizontally.&nbsp; In Figure 1, that value is 2.&nbsp; This 
means that every other black pixel in Figure 1 indicates the value of a data 
sample.&nbsp; The pixels in between are fillers.</p>
<p>The <i>Traces per page</i> specifies the number of horizontal axes on each 
page against which the data values are plotted.</p>
<p><i>Samples per page</i> gives the actual number of data values that are 
plotted on each page.&nbsp; This is determined from the values of <i>Traces per 
page, Sample spacing, </i>and <i>Page width.</i></p>
<p><font color="#FF0000"><b>Location of the stack of plots</b></font></p>
<p>There are also two overloaded versions of the method named <b>plotData</b>.&nbsp; 
One version lets you specify the location of the upper left corner of the stack 
of pages relative to the upper left corner of the screen.&nbsp; The other 
version simply places the stack of pages in the upper left corner of the screen by 
default.</p>
<p><font color="#FF0000"><b>Sample output for PlotALot02 class </b></font></p>
<p>The class named <b>PlotALot01</b> is designed for the plotting of large 
quantities of data from a single channel as described above.&nbsp; The classes 
named <b>PlotALot02</b> and <b>PlotALot03</b> are each designed to plot two 
channels of data.&nbsp; These two classes plot the two-channel data in different formats.</p>
<p><font color="#FF0000"><b>Superimposed data</b></font></p>
<p>The class named <b>PlotALot02</b> provides all of the features 
described above for the class named <b>PlotALot01</b>, such as overloaded constructors, 
overloaded <b>plotData</b> methods, etc.&nbsp; In addition, it provides the 
capability to superimpose two sets of data on the same axes with one set being 
plotted in black and the other being plotted in red.&nbsp; This is illustrated 
in Figure 2.</p>






<p>
<div align="center">
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java1492b1.jpg" width="159" height="238"></td>
    </tr>
    <tr>
      <td>
      <img border="0" src="java1492b2.jpg" width="159" height="238"></td>
    </tr>
    <tr>
      <td>
      <b>Figure 2</b></td>
    </tr>
  </tbody>
</table>
</div>
</p>

<p><font color="#FF0000"><b>Same data, different sign</b></font></p>
<p>The plots in Figure 2 were produced by plotting two versions of the same 
data.&nbsp; The algebraic sign of each of the data values was inverted in one 
set of data relative to the other.&nbsp; Thus, the red plot in Figure 2 is an 
upside down version of the black plot.&nbsp; This makes it easy to confirm that 
both plotting processes are behaving the same way.</p>
<p><font color="#FF0000"><b>Plotting parameters were controlled</b></font></p>
<p>The plots in Figure 2 were produced using the version of the constructor that 
allows the user to control the plotting parameters.&nbsp; The overall plotting 
parameters for Figure 2 are shown below:</p>
<p><pre>Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150</pre></p>
<p><font color="#FF0000"><b>Larger ovals</b></font></p>
<p>As you can see, the ovals that were used to mark the sample values in Figure 
2 were larger than in Figure 1.&nbsp; With a height and a width of four pixels, 
each oval turned out to be a circle centered on the sample value.</p>
<p><font color="#FF0000"><b>Horizontal scaling was greater</b></font></p>
<p>Also, the horizontal scaling in Figure 2 was five pixels per sample as 
opposed to two pixels per sample in Figure 1.&nbsp; As a result, the circles 
marking the samples were further apart, and the straight lines connecting the 
circles are often visible.</p>
<p><font color="#FF0000"><b>Sample output for PlotALot03 class </b></font></p>
<p>The classes 
named <b>PlotALot02</b> and <b>PlotALot03</b> are each designed to plot two 
channels of data.&nbsp; These two classes plot the two-channel data in different formats.&nbsp; Whereas <b>PlotALot02</b> superimposes the two sets of 
data on the same horizontal axes using color to provide visual separation, <b>PlotALot03</b> 
plots the two sets of data on alternating horizontal axes as shown in Figure 3.&nbsp; <b>PlotALot03</b> 
also uses color to provide visual separation between the two sets of data.&nbsp; 
One set is plotted on the odd numbered axes in black.&nbsp; The other set is 
plotted on the even numbered axes in red.</p>
<p>The class named <b>PlotALot03</b> 
also provides all of the general capabilities described earlier for the class 
named <b>PlotALot01</b> that are appropriate for a two-channel plotting system.</p>
<div align="center">
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java1492c1.jpg" width="159" height="271"></td>
    </tr>
    <tr>
      <td>
      <img border="0" src="java1492c2.jpg" width="159" height="271"></td>
    </tr>
    <tr>
      <td>
      <b>Figure 3</b></td>
    </tr>
  </tbody>
</table>
</div>
</p>

<p><font color="#FF0000"><b>Same data, two colors</b></font></p>
<p>The two sets of data plotted in Figure 3 consisted of exactly the same 
values.&nbsp; Thus, the plots on the even numbered axes look just like the plots 
on the odd numbered axes except that one plot is red and the other is black.&nbsp; 
Using the same values for each set of data makes it easy to confirm that both 
plotting processes are behaving the same way.</p>
<p><font color="#FF0000"><b>The plotting parameters</b></font></p>
<p>The overall plotting parameters for Figure 3 are shown below:</p>
<p><pre>Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 90</pre></p>
<p>Because <b>PlotALot03</b> 
doesn't superimpose the two sets of data, twice as many pages would be required 
for <b>PlotALot03</b> 
to plot a given amount of data as would be required by <b>PlotALot02</b> for the 
same <b>Page</b> size.</p>
<p> <b>PlotALot03</b> 
will refuse to plot data for a set of plotting parameters that result in an odd 
number of traces on the page.</p>
<p><font color="#FF0000"><b>Sample output for PlotALot04 class</b></font></p>
<p>The class 
named <b>PlotALot04</b> 
plots three sets of data on separate horizontal axes as shown in Figure 4.&nbsp; 
The first set of data is plotted in black.&nbsp; The second set of data is 
plotted in red.&nbsp; The third set of data is plotted in blue.&nbsp; This class 
is particularly useful for displaying the input, output, and error signals 
involved in adaptive signal processing.</p>
<p>The class named <b>PlotALot04</b> 
also provides all of the general capabilities described earlier for the class 
named <b>PlotALot01</b> that are appropriate for a three-channel plotting system.</p>
<div align="center">
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java1492e1.jpg" width="159" height="266"></td>
    </tr>
    <tr>
      <td>
      <img border="0" src="java1492e2.jpg" width="159" height="271"></td>
    </tr>
    <tr>
      <td>
      <b>Figure 4</b></td>
    </tr>
  </tbody>
</table>
</div>
</p>

<p><font color="#FF0000"><b>Same data, three colors</b></font></p>
<p>The three sets of data plotted in Figure 4 consisted of exactly the same 
values.&nbsp; Thus, the plots on the three different axes look just alike except that 
the first plot is black, the second plot is red and the third is blue.&nbsp; 
Using the same values for each set of data makes it easy to confirm that all 
three 
plotting processes are behaving the same way.</p>
<p><font color="#FF0000"><b>The plotting parameters</b></font></p>
<p>The overall plotting parameters for Figure 4 are shown below:</p>
<p><pre>Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 60</pre></p>
<p> <b>PlotALot04</b> will terminate if the number of 
traces per page is not evenly divisible by 3</p>
<h2 align="center"><a name="A_Sample_Program">Sample Programs</a></h2>
<p><font color="#FF0000"><b>The class named 
PlotALot01</b></font></p>
<p>Now that you know where we are heading, it's time to examine these four 
classes in detail.&nbsp; I will begin with the class named <b>PlotALot01</b>.</p>
<p><font color="#FF0000"><b>Purpose of the class</b></font></p>
<p>This class is designed to plot large amounts of data for a single channel.&nbsp; 
The class is particularly useful for plotting time series data.&nbsp; Also, by 
carefully adjusting the plotting parameters, this class can be used to plot 
large quantities of spectral data in a waterfall display with each new spectral 
estimate being plotted immediately below the previous estimate.</p>
<p><font color="#FF0000"><b>Usage information</b></font></p>
<p>The class provides a <b>main</b> method so that the class can be run as an 
application to test itself.&nbsp; The <b>main</b> method also illustrates how to 
use the class.</p>
<p>There are three steps involved in the use of 
this class for plotting large quantities of data:</p>
<ol>
	<li>Instantiate a plotting object of type <b>PlotALot01</b> using one of two 
	overloaded constructors.</li>
	<li>Feed the data that is to be plotted to the plotting object by invoking the
	<b>feedData</b> method once for each data value.</li>
	<li>Invoke one of two overloaded <b>plotData</b> methods on the plotting 
	object once all of the data has been fed to the object.&nbsp; This causes 
	all of the data to be plotted and causes the pages to be stacked in a 
	particular location on the screen with page 0 on the top of the stack.</li>
</ol>
<p><font color="#FF0000"><b>Different plotting objects</b></font></p>
<p>A program that uses this class for plotting can instantiate as many different 
plotting objects as are needed to plot all of the different sets of data that 
need to be plotted independently of one another.</p>
<blockquote>
	<p><i>(For example, a program that uses this class could instantiate one plotting object to 
	plot time series data and a different plotting object to plot spectral data.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Can plot a large number of data values</b></font></p>
<p>Each plotting object can be used to plot as many data values as needed <i>
(unless the program runs out of memory).</i></p>
<blockquote>
	<p><i>(As mentioned earlier, I have successfully plotted two 
million data values in 141 full screen pages on a modest laptop computer with 
no difficulty whatsoever.&nbsp; When I pushed that total up to eight million 
	data values in 563 full screen pages, the plotting process slowed down, but 
	I was still able to display and examine the plots.&nbsp; The practical limit 
	on my computer seems to be somewhere between two million and eight million 
	data values.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Multiple Page objects</b></font></p>
<p>A plotting object of type <b>PlotALot01</b> owns one or more <b>Page</b> 
objects that extend the <b>Frame</b> class.&nbsp; The plotting object can own as 
many <b>Page</b> objects as are necessary to plot all of the data that is fed to 
the plotting object.</p>
<p><font color="#FF0000"><b>A stack of Page objects</b></font></p>
<p>The class produces a graphic output consisting of a stack of <b>Page</b> 
objects on the screen, with the data plotted on a <b>Canvas</b> object contained 
by each <b>Page</b> object.&nbsp; The <b>Page</b> showing the earliest data <i>
(page 0)</i> is on 
the top of the stack and the <b>Page</b> showing the latest data is on the 
bottom of the stack.</p>
<blockquote>
	<p><i>(The <b>Page</b> objects on the top of the stack must be physically 
	moved in order to see the Page objects on the bottom of the stack.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Multiple traces on each Page object</b></font></p>
<p>As shown in Figure 1, each <b>Page</b> object contains one or more horizontal 
axes on which the data is plotted.&nbsp; The earliest data is plotted on the 
axis nearest the top of the <b>Page</b> moving from left to right across the <b>
Page</b>.&nbsp; Positive data values are plotted above the axis and negative 
values are plotted below the axis.</p>
<p>When the right end of an axis is reached, the next data value is plotted on 
the left end of the axis immediately below it.&nbsp; When the right end of the 
last axis on the <b>Page</b> is reached, a new <b>Page</b> object is 
automatically created and the next data value is plotted at the left end of the 
top axis on the new <b>Page</b> 
object.</p>
<p><font color="#FF0000"><b>Two overloaded constructors</b></font></p>
<p>There are two overloaded versions of the constructor 
for the <b>PlotALot01class</b>.&nbsp; One overloaded version accepts several 
incoming parameters allowing the user to control various aspects of the plotting 
format.&nbsp; <i>(An example of the use of this constructor is shown in Figure 5.)</i>&nbsp; A second overloaded version accepts a title string only and sets 
all of the plotting parameters to default values.&nbsp; <i>(An example of the 
use of this constructor is shown in Figure 1.)</i></p>
<blockquote>
	<p><i>(You can easily modify the default values and recompile the class if 
	you prefer different default values.)</i></p>
</blockquote>
<p><font color="#FF0000"><b><a name="Constructor_parameters">Constructor 
parameters</a></b></font></p>
<p>The parameters for the version of the constructor that accepts plotting 
parameters are:</p>
<ul>
	<li><b>String</b> <b>title</b>:&nbsp; Title for the <b>Frame</b> object.&nbsp; This 
	title is concatenated with the page number and the result appears in the 
	banner at the top of the <b>Page</b> as shown in Figure 1.</li>
	<li><b>int frameWidth</b>:&nbsp; The <b>Frame</b> width in pixels.</li>
	<li><b>int frameHeight</b>:&nbsp; The <b>Frame</b> height in pixels.</li>
	<li><b>int traceSpacing</b>:&nbsp; Distance between trace axes in pixels.</li>
	<li><b>int sampSpace</b>:&nbsp; Number of pixels dedicated to each data 
	sample in pixels per sample.&nbsp; <i>(Must be 1 or greater.)</i></li>
	<li><b>int ovalWidth</b>:&nbsp; Width of an oval that is used to mark the 
	sample value on the plot.&nbsp; <i>(See Figure 5 for a good example of the 
	ovals.&nbsp; Set the oval width and height parameters to zero to eliminate 
	the ovals altogether.)</i></li>
	<li><b>int ovalHeight</b>:&nbsp; Height of an oval that is used to mark the 
	sample value on the plot.</li>
</ul>
<p><font color="#FF0000"><b>Two plotting objects for test purposes</b></font></p>
<p>For test purposes, the <b>main</b> method instantiates and feeds two 
independent plotting objects.&nbsp; Plotting parameters are specified for the 
first plotting object and the stack of pages for this plotting object is located 
401 pixels to the right of the upper left corner of the screen.&nbsp; The output 
produced by this plotting object is shown in Figure 5 below.&nbsp; <i>(The two 
pages in the screen shot in Figure 5 were manually relocated for reasons that I 
will explain later.)</i></p>
<div align="center">
<table border="1" cols="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td>
      <img border="0" src="java1492d1.jpg" width="308" height="378"></td>
    </tr>
    <tr>
      <td>
      <b>Figure 5</b></td>
    </tr>
  </tbody>
</table>
</div>
<p>Default plotting parameters are used for the second plotting object and 
the stack of pages is located in the default location at the upper left corner 
of the screen.&nbsp; The output produced by this plotting object was shown 
earlier in Figure 1.</p>
<p><font color="#FF0000"><b>The data to be plotted</b></font></p>
<p>Most of the data that is fed to each plotting object is white random noise produced 
by a random noise generator.&nbsp; However, fifteen of the data values fed to the first plotting 
object are not random.&nbsp; </p>
<p><font color="#FF0000"><b>
<a name="Transition_from_trace_to_trace_on_the_same_page">Transition from trace 
to trace on the same page</a></b></font></p>
<p>Eight of the data values for the first plotting object are set to 0,0,20,20,-20,-20,0,0.&nbsp; 
The result can be seen at the end of the first trace and the beginning of the 
second trace in Page 0 in Figure 5.&nbsp; Note that the last four plotted points 
for the first trace have values of 0,0,20, and 20.&nbsp; Then note that the first four 
plotted points on the second trace have values of -20, -20, 0, and 0.&nbsp; This confirms 
the proper transition from one trace to the next on the same page with no loss 
of data values in the transition.</p>
<p><font color="#FF0000"><b>Transition from page to page</b></font></p>
<p>Seven of the values for the first plotting object are set to values of 0,0,25,-25,25,0,0.&nbsp; 
The result can be seen at the end of the last trace on Page 0 and the beginning 
of the first trace on Page 1 in Figure 5.&nbsp; Note that the last three plotted 
points in the last trace on Page 0 have values of 0, 0, and 25.&nbsp; Then note that the 
first four plotted points in the first trace on Page 1 have values of -25, 25, 0, and 0.&nbsp; 
This confirms the proper transition from one page to the next with no loss of 
data in the transition.</p>
<blockquote>
	<p><i>(The two pages in Figure 5 were manually arranged as shown before 
	capturing the screen shot to emphasize the transition of the data from one 
	page to the next.&nbsp; The large white rectangles in Figure 5 are the result 
	of removing the background clutter in the image caused by icons on the 
	desktop.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Proper locations for AWT Frame under WinXP</b></font></p>
<p>These 
specific values and the locations in the data where they are placed provide 
visible confirmation that the transitions mentioned above are handled 
correctly by the plotting object.&nbsp; These are the correct locations for an AWT 
<b>Frame</b> object for Java running under WinXP.&nbsp; Note however that a <b>Frame</b> may have different 
<b>inset</b> values under other operating 
systems, which may cause these specific locations to be incorrect for that 
operating system.&nbsp; In that case, the values will be plotted but they won't 
necessarily confirm the proper transition.</p>
<p><font color="#FF0000"><b>Information about plotting parameters</b></font></p>
<p>Information about the plotting parameters 
for each plotting object is displayed on the command line screen when this class 
is used for plotting.&nbsp; The values shown below result from the execution of the 
<b>main</b> 
method of the <b>PlotALot01</b> class for test purposes.&nbsp; One of the plotting objects instantiated by 
the <b>main</b> method is entitled &quot;A&quot; and the other is entitled &quot;B&quot;.&nbsp; </p>
<p><pre><a name="Title:_A">Title: A</a>
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150

Title: B
Frame width: 400
Frame height: 410
Page width: 392
Page height: 383
Trace spacing: 50
Sample spacing: 2
Traces per page: 7
Samples per page: 1372</pre></p>
<p>The graphic output produced for the object entitled &quot;A&quot; is shown in 
Figure 5.&nbsp; 
This output was based on plotting format parameters that were passed to the 
constructor.&nbsp; The graphic output produced for the object entitled &quot;B&quot; is 
shown in Figure 1.&nbsp; This output was based on default plotting parameters.</p>
<p><font color="#FF0000"><b>Overloaded plotData method</b></font></p>
<p>There are two overloaded 
versions of the <b>plotData</b> method.&nbsp; One version allows the user to specify the 
location on the screen where the stack of plotted pages will appear.&nbsp; This version 
requires two parameters, which are coordinate values in pixels.&nbsp; The first 
parameter specifies the horizontal coordinate of the upper left corner of the 
stack of pages relative to the upper left corner of the screen.&nbsp; The second 
parameter specifies the vertical coordinate of the upper left corner of the 
stack of pages relative to the upper left corner of the screen.</p>
<blockquote>
	<p><i>(Specifying 
coordinate values of 0,0 causes the stack to be located in the upper left corner 
of the screen.&nbsp; Positive vertical coordinates progress down the screen.)</i></p>
</blockquote>
<p>The other overloaded version of <b>plotData</b> places the stack of pages 
in the upper left corner of the screen by default.</p>
<p><font color="#FF0000"><b>A WindowListener for program termination</b></font></p>
<p>Each page has a 
<b>WindowListener</b> that will terminate the program if the user clicks the close 
button on the <b>Frame</b>.</p>
<p><font color="#FF0000"><b>J2SE 5.0 is required</b></font></p>
<p>The class was tested using J2SE 5.0 and WinXP.&nbsp; J2SE 5.0 is required 
because the class uses generics with an <b>ArrayList</b> object.</p>
<p><font color="#FF0000"><b>Let's see some code!</b></font></p>
<p>I will present and explain this class in fragments.&nbsp; A complete 
listing of the class is provided in Listing 35 near the end of the lesson.</p>
<p><font color="#FF0000"><b>The main method</b></font></p>
<p>As mentioned earlier, this class contains a <b>main</b> method.&nbsp; The <b>
main</b> method is provided so that the class can be run as an application for 
self-test purposes.&nbsp; The <b>main</b> method also illustrates the proper use of the class.</p>
<p>The beginning of the class and the beginning of the <b>main</b> method is 
shown in Listing 1.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class PlotALot01{
  public static void main(String[] args){
    PlotALot01 plotObjectA = 
            new PlotALot01("A",158,237,36,5,4,4);
    PlotALot01 plotObjectB = new PlotALot01("B");<br><br><b><font face="Courier New,Courier">Listing 1</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Instantiate two plotting objects</b></font></p>
<p>Listing 1 instantiates two independent plotting objects.&nbsp; The first 
plotting object, referred to by <b>plotObjectA</b> is instantiated by invoking 
the constructor that accepts plotting parameters.&nbsp; A description of each of 
the constructor parameters was provided <a href="#Constructor_parameters">
earlier</a>.&nbsp; You may find it useful to compare the values shown in Listing 
1 with the <a href="#Title:_A">overall plotting parameters</a> listed earlier to 
confirm how they are related.</p>
<p>The second plotting object, referred to by <b>plotObjectB</b> is instantiated 
by invoking the constructor that accepts only the page title as a parameter and 
uses default values for all of the plotting parameters.&nbsp; You will see those 
default values later in the code.</p>
<p><font color="#FF0000"><b>Feed the plotting object entitled &quot;A&quot;</b></font></p>
<p>Listing 2 contains a <b>for</b> loop that feeds 275 values to the plotting 
object entitled &quot;A&quot;.&nbsp; Most of the code in Listing 2 is required 
to set fifteen specific 
values to test for proper
<a href="#Transition_from_trace_to_trace_on_the_same_page">transitions</a> as 
described earlier.&nbsp; This code is straightforward and shouldn't require 
further explanation.</p>
<blockquote>
	<p><i>(I was able to determine the correct locations for these values by 
	knowing the size of the <b>Frame</b>, <b>inset</b> values for the <b>Frame</b>, 
	the space between traces, the number of pixels dedicated to each sample, 
	etc.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt = 0;cnt &lt; 275;cnt++){
      if(cnt == 147){
        plotObjectA.feedData(0);
      }else if(cnt == 148){
        plotObjectA.feedData(0);
      }else if(cnt == 149){
        plotObjectA.feedData(25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25);
      }else if(cnt == 151){
        plotObjectA.feedData(25);
      }else if(cnt == 152){
        plotObjectA.feedData(0);
      }else if(cnt == 153){
        plotObjectA.feedData(0);
      }else if(cnt == 26){
        plotObjectA.feedData(0);
      }else if(cnt == 27){
        plotObjectA.feedData(0);
      }else if(cnt == 28){
        plotObjectA.feedData(20);
      }else if(cnt == 29){
        plotObjectA.feedData(20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0);
      }else if(cnt == 33){
        plotObjectA.feedData(0);
      }else{
        <b>plotObjectA.feedData(
                       (Math.random() - 0.5)*25);</b>
      }//end else
    }//end for loop<br><br><b><font face="Courier New,Courier">Listing 2</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>White random noise</b></font></p>
<p>The final statement in Listing 2 uses a random number generator to feed white 
random noise to the plotting object for all data values other than the fifteen 
data values specified in the preceding statements.&nbsp; You can see the random 
values plotted and marked by round ovals in Figure 5.</p>
<p><font color="#FF0000"><b>Plot the data</b></font></p>
<p>The statement in Listing 3 invokes the overloaded <b>plotData</b> method to 
cause all of the pages belonging to the plotting object entitled &quot;A&quot; to be 
stacked in a location where the upper left corner of the stack is 401 pixels to 
the right of the upper left corner of the screen.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    plotObjectA.plotData(401,0);<br><br><b><font face="Courier New,Courier">Listing 3</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>As described earlier, page 0 containing the earliest data fed to the plotting 
object is on the top of the stack.&nbsp; Figure 1 shows the two pages belonging 
to this plotting object after they have been manually rearranged to make them 
both visible.</p>
<p><font color="#FF0000"><b>Feed and plot the object entitled &quot;B&quot;</b></font></p>
<p>Listing 4 feeds 2600 random white noise values to the object entitled &quot;B&quot; and 
displays the pages in the default location in the upper left corner of the 
screen.&nbsp; Listing 4 also signals the end of the <b>main</b> method.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt = 0;cnt &lt; 2600;cnt++){
      plotObjectB.feedData(
                       (Math.random() - 0.5)*25);
    }//end for loop
    plotObjectB.plotData();
    
  }//end main<br><br><b><font face="Courier New,Courier">Listing 4</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 4 <i>(plus one of the statements in Listing 1)</i> is much more 
typical of the amount of code required to use this plotting class than was the 
case with Listing 2.</p>
<blockquote>
	<p><i>(Almost all of the code in Listing 2 was required to set the special 
	data values used to test the transitions discussed earlier.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The three steps</b></font></p>
<p>To recap, the three steps required to use this class for plotting nearly 
unlimited amounts of data are:</p>
<ol>
	<li>Instantiate a plotting object of the class named <b>PlotALot01</b>, as 
	in Listing 1.</li>
	<li>Invoke the <b>feedData</b> method once for each data value that is to be 
	plotted, as in Listing 4.</li>
	<li>Invoke the <b>plotData</b> method on the plotting object after all of the data has been 
	fed to the plotting object, as in Listing 3 or Listing 4.</li>
</ol>
<p><font color="#FF0000"><b>Some instance variables</b></font></p>
<p>Continuing with the class definition for the class named <b>PlotALot01</b>, 
Listing 5 shows several instance variables that belong to a plotting object 
instantiated from this class.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();<br><br><b><font face="Courier New,Courier">Listing 5</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The purpose of each of these instance variables is 
indicated by the name of the variable, and in some cases by the comments 
following the variable declaration.&nbsp; In addition, I will have more to say 
about some of these variables later when I discuss the code that uses them.</p>
<blockquote>
	<p><i>(Note the use of generics in the declaration and initialization of the 
	variable named <b>pageLinks</b>.&nbsp; The use of generics dictates that 
	this class requires J2SE 5.0 or later.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>The first overloaded constructor</b></font></p>
<p>As mentioned earlier, there are two overloaded versions of the constructor 
for this class.&nbsp; The overloaded version that begins in Listing 6 accepts 
several incoming parameters allowing the user to control various aspects of the 
plotting format.</p>
<blockquote>
	<p><i>(A different overloaded version, which I will discuss later, accepts a 
	title string only and sets all of the plotting parameters to default 
	values.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  PlotALot01(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor<br><br><b><font face="Courier New,Courier">Listing 6</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 6 shows the signature for this overloaded version of the constructor.&nbsp; 
The comments should make the code self explanatory.</p>
<p><font color="#FF0000"><b>Save the parameter values</b></font></p>
<p>With one exception, the code in Listing 7 simply saves the incoming parameter 
values in instance variables to make those values available to other members of 
the class.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;<br><br><b><font face="Courier New,Courier">Listing 7</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The exception</b></font></p>
<p>The exception has to do with the parameter named <b>sampSpace</b>.&nbsp; This 
parameter is provided by the user in units of pixels per sample, because that 
seems to be the most natural way for a human to specify this plotting parameter.&nbsp; 
However, for computational purposes, it is better to have the value of the 
number of pixels between samples, which is one less than the number of pixels 
per sample.&nbsp; This conversion is made during the saving of this parameter in 
Listing 7.</p>
<p><font color="#FF0000"><b>A temporary Page object</b></font></p>
<p>As you will see later, the <b>Page</b> class consists of a <b>Canvas</b> 
contained in an AWT <b>Frame</b>.&nbsp; Because an AWT <b>Frame</b> takes on the 
look and feel of the operating system under which the program is running, it may 
be constructed differently under different operating systems.&nbsp; Many 
important plotting parameters depend on the size of the <b>Canvas</b>, which 
depends on the values of the <b>insets</b> for the <b>Frame</b> for that 
particular operating system.</p>
<blockquote>
	<p><i>(A good exercise would be for you to convert this class to Swing using 
	a look and feel that is independent of the operating system.)</i></p>
</blockquote>
<p>The code in Listing 8 instantiates a temporary <b>Page </b>object solely for 
the purpose of obtaining information about the width and the height of the <b>
Canvas </b>object.&nbsp; This information is used later to compute a variety of other important 
parameter values.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();<br><br><b><font face="Courier New,Courier">Listing 8</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Display some information</b></font></p>
<p>Listing 9 gets and displays information about the plotting object on the 
command line screen.&nbsp; An <a href="#Title:_A">example</a> of this output was 
shown earlier.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
<b>    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if</b><br><br><b><font face="Courier New,Courier">Listing 9</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Terminate on negative value for sampSpacing</b></font></p>
<p>In addition, Listing 9 tests to confirm that the number of pixels between 
samples is not a negative value.&nbsp; If it is a negative value, Listing 9 
terminates the program immediately after the number of pixels per sample has 
been displayed</p>
<p><font color="#FF0000"><b>Dispose of the temporary Page object</b></font></p>
<p>Once the width and height of the <b>Canvas</b> has been determined, the 
temporary <b>Page</b> object is no longer needed.&nbsp; Listing 10 disposes of 
that object freeing all of the resources dedicated to the object.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    tempPage.dispose();<br><br><b><font face="Courier New,Courier">Listing 10</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Compute and display the remaining plotting 
parameters</b></font></p>

<p>Having determined the width and height of the <b>Canvas</b>, Listing 11 
computes and displays the remaining plotting parameters.&nbsp; The expressions 
used to compute these values are straightforward and shouldn't require further 
explanation.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
<b>    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if</b>
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);<br><br><b><font face="Courier New,Courier">Listing 11</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Terminate on zero traces per page</b></font></p>
<p>In addition, Listing 11 terminates the program if it is determined that the 
number of traces per page is equal to zero.&nbsp; The reason for this should be 
obvious to the reader.&nbsp; If termination does occur, it occurs immediately 
after the number of traces per page has been displayed.</p>
<p><font color="#FF0000"><b>Instantiate first usable Page object</b></font></p>
<p>Listing 12 instantiates the first usable <b>Page</b> object.&nbsp; <i>(Recall 
that a temporary <b>Page</b> object was instantiated and disposed of earlier.)&nbsp;
</i>This <b>Page</b> object will be entitled <i>title Page: 0</i> as indicated 
in Figure 1 and Figure 5.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    pageLinks.add(new Page(title));
  }//end constructor<br><br><b><font face="Courier New,Courier">Listing 12</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Note that a reference to this <b>Page</b> object <i>(and all subsequently instantiated <b>
Page</b> objects)</i> is saved in an object of type <b>ArrayList</b> referred 
to by <b>pageLinks</b>. </p>
<p>Listing 12 also signals the end of this constructor for the <b>PlotALot01</b> 
class.</p>
<p><font color="#FF0000"><b>The other overloaded constructor</b></font></p>
<p>A second overloaded constructor is provided for those who don't want to have 
to think about plotting parameters.&nbsp; This constructor, which is shown in 
its entirety in Listing 13, establishes a set of default plotting parameters.</p>
<blockquote>
	<p><i>(In case you are unfamiliar with the use of the keyword <b>this</b> to 
	cause one constructor to invoke another constructor of the same class, you 
	can learn about that topic in my earlier lesson entitled
	<a href="http://www.developer.com/java/article.php/1440571">The Essence of 
	OOP using Java, The this and super Keywords</a>.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  PlotALot01(String title){
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor<br><br><b><font face="Courier New,Courier">Listing 13</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The default plotting parameter values</b></font></p>
<p>This is where the default plotting parameters are specified as having the 
following values:</p>
<ul>
	<li>frameWidth:&nbsp; 400</li>
	<li>frameHeight:&nbsp; 410</li>
	<li>traceSpacing:&nbsp; 50</li>
	<li>sampSpace:&nbsp; 2</li>
	<li>ovalWidth:&nbsp; 2</li>
	<li>ovalHeight:&nbsp; 2</li>
</ul>
<p>As mentioned earlier, these values were chosen mainly to be compatible with 
this narrow publication format.&nbsp; You should feel free to change the default 
values to a set of values that is more consistent with your needs.&nbsp; For 
example, if you plan to plot and examine very large amounts of data, you might 
want to consider setting the <b>frameWidth</b> and <b>frameHeight</b> to 
completely fill the screen on your computer.&nbsp; Then you can examine large 
amounts of data without the need to skip from one page to the next.</p>
<p><font color="#FF0000"><b>The feedData method</b></font></p>
<p>The <b>feedData</b> method must be invoked on the plotting object once for 
each data value that is to be plotted.&nbsp; This method is shown in its 
entirety in Listing 14.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>
  void feedData(double val){
    if((sampleCounter) == samplesPerPage){
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    pageLinks.get(pageCounter).putData(
                              val,sampleCounter);
    sampleCounter++;
  }//end feedData
<br><b><font face="Courier New,Courier">Listing 14</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Scaling of data to be plotted</b></font></p>
<p>The <b>feedData</b> method receives an incoming data value of type <b>double</b>.&nbsp; 
This is probably a good time to point out that the data must be properly scaled 
for plotting before it is passed to this method.</p>
<p>The incoming <b>double</b> value will later be cast to type <b>int</b>.&nbsp; 
As you should already know, if the <b>double</b> value is too large to fit in 
type <b>int</b>, the value resulting from the cast will be indeterminate.&nbsp; </p>
<p>In reality, however, the cast shouldn't be a problem.&nbsp; I'm unaware of 
any computer monitor whose vertical dimension is greater than a few thousand 
pixels.&nbsp; Regardless of the size of the <b>Page</b> object, a data value 
whose magnitude is greater than a few thousand units will be completely off the 
screen when plotted.&nbsp; Therefore, depending on the resolution of the 
monitor, the maximum magnitudes of the incoming data values should probably have 
been scaled to 1000 or less to be suitable for plotting. </p>
<p><font color="#FF0000"><b>Is the page full?</b></font></p>
<p>Listing 14 first checks to see if the current page is full before attempting 
to plot the new data value.&nbsp; If the page is full, Listing 14 increments the 
page counter, resets the sample counter, and instantiates a new <b>Page</b> 
object.</p>
<p><font color="#FF0000"><b>Save the data value for plotting later</b></font></p>
<p>All of the data values are stored in array objects of type <b>double</b> as 
they are fed to the plotting object.&nbsp; Later, when it is time to display the 
plotted version of the data, an overridden <b>paint</b> method accesses that 
data and produces the plot.</p>
<p><font color="#FF0000"><b>The MyCanvas class, a preview</b></font></p>
<p>Each <b>Page</b> object contains an object of a class named <b>MyCanvas</b>, 
which extends the <b>Canvas</b> class.&nbsp; Each <b>MyCanvas</b> object owns an 
array object in which the <b>double</b> data values to be plotted on that page 
are stored.</p>
<p>The <b>MyCanvas</b> class overrides the <b>paint</b> method to cause it to 
plot the data stored in the array whenever the overridden version of the <b>
paint</b> method is invoked.</p>
<blockquote>
	<p><i>(If you are familiar with graphics in Java, you will already know 
	that the overridden <b>paint</b> method can be invoked for a variety of 
	reasons, such as covering and later uncovering the page.&nbsp; If you are 
	not familiar with graphics in Java, I 
	discuss the overriding of the <b>paint </b>method in numerous earlier 
	lessons including several lessons on
	<a href="http://www.dickbaldwin.com/tocadv.htm">animation</a> in Java.)</i></p>
</blockquote>
<p>I will have much more to say about the class named <b>MyCanvas</b> later.</p>
<p><font color="#FF0000"><b>Invoke the putData method to store the data value</b></font></p>
<p>For now, simply be aware that the <b>feedData</b> method in Listing 14 
invokes the <b>putData</b> method on the current <b>Page</b> object to cause the 
data value to be stored in the array object belonging to the corresponding <b>
MyCanvas</b> object.&nbsp; The current value of the sample counter is also 
passed to the <b>putData</b> method to specify the array element into which the 
data value is to be stored.</p>
<p>Finally, the <b>feedData</b> method increments the sample counter and returns 
to await being invoked to receive the next data sample.</p>
<p><font color="#FF0000"><b>The plotData method</b></font></p>
<p>The <b>plotData</b> method must be invoked once when all of the data has been 
fed to the plotting object by way of the <b>feedData</b> method.&nbsp; The 
purpose of the <b>plotData</b> method is to rearrange the <b>Page</b> objects in 
a stack on the screen with page 0 <i>(containing the earliest data)</i> on the 
top of the stack.</p>
<p>Having rearranged the <b>Page</b> objects, the <b>plotData</b> method causes 
the object on the top of the stack to become visible.&nbsp; This, in turn, 
causes its overridden <b>paint</b> method to be invoked causing the data to be 
plotted as shown in Figure 1 and Figure 5.</p>
<p><font color="#FF0000"><b>Two overloaded versions</b></font></p>
<p>There are two overloaded versions of the <b>plotData</b> method.&nbsp; One 
version allows the user to specify the location on the screen where the stack of 
plotted pages will appear.&nbsp; The other version places the stack in the upper 
left corner of the screen by default.</p>
<p><font color="#FF0000"><b>Specify the location of the stack</b></font></p>
<p>The version of the <b>plotData</b> method that allows the user to specify the 
location begins in Listing 15.&nbsp; This version receives two incoming 
parameters.&nbsp; These parameters specify the coordinates of the upper left corner of the stack 
of <b>Page</b> objects relative to the upper left corner of the screen.&nbsp; 
The first parameter specifies the horizontal coordinate and the second parameter 
specifies the vertical coordinate, with positive vertical values going down the 
screen.</p>
<blockquote>
	<p><i>(Specifying both coordinate values as 0 will cause the stack to appear 
	in the upper left corner of the screen.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Make certain that the last page is visible</b></font></p>
<p>As you will see later, each of the pages are displayed on the screen as they 
are produced.&nbsp; It is possible that this method could be called before the 
operating system has completed the process of making the last page visible.&nbsp; 
The <b>plotData</b> method delays until the last page has become visible on the 
screen.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
<br><b><font face="Courier New,Courier">Listing 15</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>At this point, the pages appear on the screen with the last page on the 
top of the stack.&nbsp; This order needs to be reversed to cause the first page 
to be on the top of the stack.</p>
<p><font color="#FF0000"><b>Make all pages invisible</b></font></p>
<p>The reversal of the order of the pages in the stack is accomplished by first 
making every page invisible, and then making them visible again in reverse 
order.</p>
<p>The code in Listing 16 iterates on the <b>ArrayList</b> object containing 
references to all of the pages.&nbsp; The reference to each <b>Page</b> object 
is obtained from the list, and its <b>visible</b> property value is set to <b>
false</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    
    Page tempPage = null;
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop<br><br><b><font face="Courier New,Courier">Listing 16</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Make the pages visible in reverse order</b></font></p>
<p>The code in Listing 17 iterates on the <b>ArrayList</b> object again, 
accessing the references to the <b>Page</b> objects in reverse order and setting 
the value of the <b>visible</b> property for each <b>Page</b> object to <b>true</b>.&nbsp; 
This results in page 0 <i>(the page with the earliest data)</i> being on the 
top of the stack.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)<br><br><b><font face="Courier New,Courier">Listing 17</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Set the location of the stack</b></font></p>
<p>In addition, the code in Listing 17 sets the <b>location</b> property of each
<b>Page</b> object to the coordinate values received as incoming parameters to 
the <b>plotData</b> method.&nbsp; This causes the stack of <b>Page</b> objects 
to appear in the specified location on the screen.</p>
<p><font color="#FF0000"><b>The other overloaded version of the plotData method</b></font></p>
<p>The other overloaded version of the <b>plotData</b> method is shown in its 
entirety in Listing 18.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void plotData(){
    plotData(0,0);//invoke overloaded version
  }//end plotData()<br><br><b><font face="Courier New,Courier">Listing 18</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>This version receives no incoming parameters.&nbsp; The body of the method 
simply invokes the first overloaded version discussed above, passing 
coordinate values as 0,0 as parameters.&nbsp; As explained earlier, this causes 
the stack of <b>Page</b> objects to appear in the upper left corner of the 
screen.</p>
<p><font color="#FF0000"><b>The Page class</b></font></p>
<p>The <b>Page</b> class is a
<a href="http://www.developer.com/java/other/article.php/3085271">member</a> class of the class named <b>PlotALot01</b>.&nbsp; As such, methods 
belonging to objects of the <b>Page</b> class have direct access to all of the other members 
of the enclosing <b>PlotALot01</b> object, including instance variables belonging to the <b>
PlotALot01</b> object.</p>
<blockquote>
	<p><i>(If you are unfamiliar with member classes, see the lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3085271">The 
	Essence of OOP using Java, Member Classes</a>.)</i></p>
</blockquote>
<p><font color="#FF0000"><b>Potentially many Page objects...</b></font></p>
<p>A <b>PlotALot01</b> object may own as many <b>Page</b> objects as are 
required to plot all of the data values that are fed to it.</p>
<blockquote>
	<p><i>(The reference to each <b>Page</b> object is stored in an <b>ArrayList</b> 
	object belonging to the <b>PlotALot01</b> object.)</i></p>
</blockquote>
<p>The <b>Page</b> class, which extends the <b>Frame</b> class begins, in Listing 
19.&nbsp; The constructor for the <b>Page</b> class also begins in Listing 19.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);<br><br><b><font face="Courier New,Courier">Listing 19</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>Page</b> class begins by declaring two instance variables.&nbsp; The 
instance variable named <b>canvas</b> will hold a reference to an object of the
<b>MyCanvas</b> class upon which the data will actually be plotted.</p>
<p>The other instance variable will hold the value of a sample counter.</p>
<p><font color="#FF0000"><b>The constructor for the Page class</b></font></p>
<p>The constructor that begins in Listing 19 instantiates an object of a member 
class named <b>MyCanvas</b> and stores its reference in the reference variable 
named <b>canvas</b>.&nbsp; Then it adds the <b>MyCanvas</b> object to the <i>
center</i> location of the <b>Page</b> <i><b>(Frame)</b>.</i></p>
<p>Following this, the constructor accesses the variables named <b>frameWidth</b> 
and <b>frameHeight</b> belonging to the enclosing <b>PlotALot01</b> object and 
uses those values to set the size of the <b>Page</b>.</p>
<p>Then the constructor accesses the <b>title</b> and <b>pageCounter</b> 
variables belonging to the enclosing <b>PlotALot01</b> object and uses those 
values to set the title for the <b>Page</b> object.</p>
<p>Finally, the code in Listing 19 causes the <b>Page</b> object to become 
visible on the screen.</p>
<p><font color="#FF0000"><b>An anonymous terminator for the Page class</b></font></p>
<p>Still inside the constructor, Listing 20 instantiates an anonymous class to 
terminate the program when the user clicks on the <b>close</b> button on the <b>
Page</b>.</p>
<blockquote>
	<p><i>(In case you are unfamiliar with anonymous inner classes, see my 
	earlier lesson entitled
	<a href="http://www.developer.com/java/other/article.php/3300881">The 
	Essence of OOP using Java, Anonymous Classes</a>.)</i></p>
</blockquote>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
    }//end constructor<br><br><b><font face="Courier New,Courier">Listing 20</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 20 also signals the end of the constructor for the <b>Page</b> class.</p>
<p><font color="#FF0000"><b>The putData method of the Page class</b></font></p>
<p>This method, which is shown in its entirety in Listing 21, receives a sample 
value of type <b>double</b> and also receives the sample counter associated with 
that data value.&nbsp; It uses the value of the sample counter to store the data 
value in an array object belonging to the <b>MyCanvas</b> object.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    void putData(double sampleValue,
                 int sampleCounter){
      canvas.data[sampleCounter] = sampleValue;
      this.sampleCounter = sampleCounter;
    }//end putData<br><br><b><font face="Courier New,Courier">Listing 21</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>In addition, the <b>putData</b> method saves the sample counter value in an 
instance variable to make it available to the overridden <b>paint</b> method 
later.&nbsp; This value is needed by the <b>paint</b> method so it will know how 
many samples to plot on the final page which probably won't be full.</p>
<p><font color="#FF0000"><b>The MyCanvas class</b></font></p>
<p>The <b>MyCanvas</b> class, which begins in Listing 22, is a member class of 
the <b>Page</b> class.&nbsp; As such, methods belonging to an object of the<b> 
MyCanvas</b> class have direct access to the other members of the enclosing <b>
Page</b> object, including instance variables of the <b>Page</b> object.&nbsp; 
In addition, methods belonging to an object of the <b>MyCanvas</b> class have 
direct access to the other members, including instance variables, of the 
enclosing <b>PlotALot01</b> object.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    class MyCanvas extends Canvas{
      double [] data = 
                      new double[samplesPerPage];<br><br><b><font face="Courier New,Courier">Listing 22</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The class definition begins by creating a new array object of type <b>double</b> 
that will be used to store the data values belonging to the page.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>The overridden <b>paint</b> method of the <b>MyCanvas</b> class begins in 
Listing 23.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      public void paint(Graphics g){
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop<br><br><b><font face="Courier New,Courier">Listing 23</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Draw the horizontal axes</b></font></p>
<p>The code in Listing 23 draws a set of horizontal axes on the <b>MyCanvas</b> 
object, one for each trace that will be plotted on the object.&nbsp; These 
horizontal axes are shown in Figure 1 and Figure 5.</p>
<p><font color="#FF0000"><b>Plot the points</b></font></p>
<p>Listing 24 shows the beginning of the code that is used to plot the data values stored in the array that was created in 
Listing 22.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;<br><br><b><font face="Courier New,Courier">Listing 24</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Listing 24 begins by testing the value of the sample counter to make certain 
that there are some points to be plotted.&nbsp; If so, it enters a <b>for</b> 
loop to plot each data value stored in the array.&nbsp; Because it uses the 
value of the sample counter to terminate the <b>for</b> loop, only those data 
values that have been stored in the array object will be plotted, even if the 
array object isn't full.</p>
<p><font color="#FF0000"><b>A vertical offset</b></font></p>
<p>The data values in the array are to be plotted on one or more 
horizontal axes on the page.&nbsp; Therefore, it is necessary to first determine where on the 
page each data value is to be plotted.&nbsp; The code in Listing 24 uses various 
pieces of information to determine the vertical location of the axis against 
which each data value will be plotted.</p>
<p><font color="#FF0000"><b>Draw an oval</b></font></p>
<p>The code in Listing 25 draws an oval centered on the sample value to mark the 
sample on the plot.&nbsp; It is best if the dimensions of the oval are evenly 
divisible by 2 for centering purposes.&nbsp; Otherwise, the ovals may appear to be a 
little off center.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)data[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);<br><br><b><font face="Courier New,Courier">Listing 25</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Is positive vertical up or down?</b></font></p>
<p>Normally vertical coordinates increase going down the screen in Java 
graphics.&nbsp; However, this isn't what most of us are accustomed to seeing 
when we plot data.&nbsp; 
We prefer to see increasing vertical coordinates going up the page.&nbsp; The 
code in Listing 25 reverses the sign on the data values to cause positive data 
values to be plotted above the axis and negative data values to be plotted below the 
axis.&nbsp; Increasing values go up.&nbsp; Decreasing values go down.</p>
<p><font color="#FF0000"><b>Connect the points with straight lines</b></font></p>
<p>The code in Listing 26 connects the sample values with straight lines.&nbsp; 
Care is taken to avoid drawing a line from the last sample value on one trace 
to the first sample value on the next trace.&nbsp; That would really be ugly.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt]);
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot01<br><br><b><font face="Courier New,Courier">Listing 26</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>End of the PlotALot01 class</b></font></p>
<p>Listing 26 also signals the end of the overridden <b>paint</b> method, the 
end of the <b>MyCanvas</b> class, the end of the <b>Page</b> class, and the end 
of the <b>PlotALot01</b> class.&nbsp; In short, Listing 26 signals the end of the 
class under discussion.</p>
<p><font color="#FF0000"><b>The class named 
PlotALot02</b></font></p>
<p>Much of the code in this class is very similar to the code in 
the class named <b>PlotALot01</b>.&nbsp; Therefore, the discussion of this class 
will be much briefer than the earlier discussion of the class named <b>
PlotALot01</b>.</p>
<p><font color="#FF0000"><b>Designed for two-channel data</b></font></p>
<p>This class is an update to the class named <b>PlotALot01</b>.&nbsp; This 
class is designed to plot large amounts of data for two channels on the same 
axes as shown in Figure 2.&nbsp; One set of data is plotted using the color 
black.&nbsp; The other set of data is plotted using the color red.</p>
<p>As is the case for the class named <b>PlotALot01</b>, this class provides a
<b>main</b> method so that the class can be run as an application to test 
itself.</p>
<p><font color="#FF0000"><b>Three steps to use the class</b></font></p>
<p>As before, there are three steps involved in the use of this class for 
plotting data:</p>
<ol>
	<li>Instantiate a plotting object of type <b>PlotALot02</b>.</li>
	<li>Feed pairs of data values to the plotting object 
	by invoking the <b>feedData</b> method once for each pair of data values.&nbsp; 
	The first value in the pair will be plotted in black.&nbsp; The second value 
	in the pair will be plotted in red.</li>
	<li>Invoke the <b>plotData</b> method on the plotting 
	object after all of the data has been fed to the object.&nbsp; This causes 
	all of the data to be plotted.&nbsp; It also causes the pages to be 
	rearranged placing page 0 on the top of the stack.</li>
</ol>
<p><font color="#FF0000"><b>A stack of Page objects</b></font></p>
<p>The class produces a graphic output consisting of a stack of <b>Page</b> 
objects on the screen.&nbsp; Each Page object contains one or more horizontal 
axes on which the data is plotted as shown in Figure 2.&nbsp; The two data sets are superimposed on 
the same axes with the data from one data set being plotted in black and the 
data from the other data set being plotted in red.</p>
<p><font color="#FF0000"><b>Testing with the main method</b></font></p>
<p>For test purposes, the main method instantiates a single plotting object and 
feeds two data sets to that plotting object.&nbsp; As before, the data that is 
fed to the plotting object is white random noise.&nbsp; One of the data sets is 
the sequence of values obtained from a random number generator.&nbsp; The other 
data set is the same as the first except that the sign of each data values is 
reversed.</p>
<p><font color="#FF0000"><b>Some data is not random</b></font></p>
<p>Also as before, and for the same reason, fifteen of the data values for each 
data set are not random.&nbsp; The non-random data values are the same as 
in the <b>main</b> method for the class named <b>PlotALot01</b>.&nbsp; Figure 2 
illustrates how these fifteen specific values are used to confirm the proper 
transition from the end of one trace to the beginning of the next trace, and 
also to confirm the proper transition from the end of one page to the beginning 
of the next page.</p>
<p><font color="#FF0000"><b>The class named PlotALot02 and the main method</b></font></p>
<p>As before, I will discuss this class in fragments.&nbsp; A complete listing 
of the class is provided in Listing 36 near the end of the lesson.&nbsp; 
However, because much of the code in this class is very 
similar to code that I explained for the class named <b>
PlotALot01</b>, this discussion of the code will be much briefer.&nbsp; I 
will highlight those aspects of this code that are different from the code in <b>
PlotALot01</b>.</p>
<p>The beginning of the class and an abbreviated version of the <b>main</b> 
method is provided in Listing 27.&nbsp; Much of the code has been deleted from 
Listing 27 for brevity.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>public class PlotALot02{
  public static void main(String[] args){
    PlotALot02 plotObjectA = 
            new PlotALot02("A",158,237,36,5,4,4);
    
    for(int cnt = 0;cnt &lt; 275;cnt++){
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = -valBlack;
      //Feed pairs of values to the plotting
      // object by invoking the feedData method
      // once for each pair of data values.
      if(cnt == 147){
        plotObjectA.<b>feedData(0,0)</b>;

      //...code deleted for brevity

      }else{
        plotObjectA.<b>feedData(valBlack,valRed)</b>;
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main<br><br><b><font face="Courier New,Courier">Listing 27</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Two data values are required</b></font></p>
<p>The important thing to note in Listing 27 is that two data values must be 
passed to the <b>feedData</b> method each time it is invoked.&nbsp; This 
consists of one data value from each channel of data being plotted.</p>
<p><font color="#FF0000"><b>The feedData method</b></font></p>
<p>The modified <b>feedData</b> method is shown in its entirety in Listing 28.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>  void feedData(double <b>valBlack</b>,double <b>valRed</b>){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  <b>valBlack,valRed</b>,sampleCounter);
    sampleCounter++;
  }//end feedData<br><br><b><font face="Courier New,Courier">Listing 28</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The most significant things to note about the modified version of the <b>
feedData</b> method are:</p>
<ul>
	<li>The method receives two incoming data values as parameters instead of 
	just one.</li>
	<li>The method passes the two data values, along with the sample counter 
	value to the <b>putData</b> method of the <b>PlotALot02</b> class.&nbsp; 
	Thus, the <b>putData</b> method has also been modified to require two 
	incoming data values.</li>
</ul>
<p><font color="#FF0000"><b>The putData method</b></font></p>
<p>The modified <b>putData</b> method is shown in its entirety in Listing 29.&nbsp; 
This modified version of the method receives a pair of data values and stores 
each of the data values in a different array object belonging to the <b>MyCanvas</b> 
object.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    void putData(double <b>valBlack</b>,double <b>valRed</b>,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = <b>valBlack</b>;
      canvas.redData[sampleCounter] = <b>valRed</b>;
      this.sampleCounter = sampleCounter;
    }//end putData<br><br><b><font face="Courier New,Courier">Listing 29</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>The MyCanvas class</b></font></p>
<p>The modified version of the <b>MyCanvas</b> class begins in Listing 30.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    class MyCanvas extends Canvas{
      double [] <b>blackData</b> = 
                      new double[samplesPerPage];
      double [] <b>redData</b> = 
                      new double[samplesPerPage];<br><br><b><font face="Courier New,Courier">Listing 30</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The class begins by creating two different array objects in which incoming 
data is stored instead of just one array object.&nbsp; These are the objects 
that are populated by the <b>putData</b> method in Listing 29.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>The modified version of the overridden <b>paint</b> method begins in Listing 
31.&nbsp; Most of the code was deleted for brevity from Listing 31 because it is 
very similar to the code in the overridden <b>paint</b> 
method in the class named <b>PlotALot01</b>.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      public void paint(Graphics g){
        //Draw horizontal axes
        //... code deleted for brevity
        
        //Plot the points.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset.
            //...code deleted for brevity

            //Begin by plotting the values from
            // the blackData array object.
            //Draw an oval.
            <b>g.setColor(Color.BLACK);</b>
            //...code deleted for brevity
            
            //Connect the sample values with
            // straight lines.
            //...code deleted for brevity<br><br><b><font face="Courier New,Courier">Listing 31</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Setting the drawing color</b></font></p>
<p>The most significant thing in Listing 31 is the invocation of the <b>setColor</b> 
method of the <b>Graphics</b> class to set the drawing color to black.&nbsp; 
Otherwise, the code is essentially the same as the code in the overridden paint 
method in <b>PlotALot01</b>.&nbsp; The code in Listing 31 draws the black traces 
shown in Figure 2.</p>
<p><font color="#FF0000"><b>New code in the overridden paint method</b></font></p>
<p>The overridden version of the <b>paint</b> method continues in Listing 32.&nbsp; 
The code in Listing 32 is essentially all new code that was created to plot the 
second data set in red.&nbsp; However, the only real difference between this 
code and code that I explained earlier with respect to the class named <b>
PlotALot01</b> is:</p>
<ul>
	<li>The drawing color has been set to red instead of the default color of 
	black.</li>
	<li>The data being plotted is the second set of data.&nbsp; This data is stored in the 
	array object referred to by <b>redData</b>.</li>
</ul>
<p>Otherwise, this code is essentially the same as the code that was used to 
plot the single data set in the overridden paint method in the class named <b>
PlotALot01</b>.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>            //Now plot the data stored in the
            // redData array object.
            <b>g.setColor(Color.RED);</b>
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)<b>redData</b>[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02<br><br><b><font face="Courier New,Courier">Listing 32</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The code in Listing 32 draws the red traces shown in Figure 2.</p>
<p><font color="#FF0000"><b>End of class PlotALot02</b></font></p>
<p>Listing 32 signals the end of the overridden <b>paint</b> method, the <b>
MyCanvas</b> class, the <b>Page</b> class, and the <b>PlotALot02</b> class.</p>
<p><font color="#FF0000"><b>The class named 
PlotALot03</b></font></p>
<p>
I will discuss the class named <b>PlotALot03</b> in fragments.&nbsp; A complete 
listing of the class is provided in Listing 37 near the end of the lesson.<p>
Much of the code in the class named <b>PlotALot03</b> is very 
similar to the code in <b>PlotALot02</b>.&nbsp; Therefore, this discussion will 
be brief, simply highlighting the differences between the two classes.<p>
<font color="#FF0000"><b>Two-channel data on alternating axes</b></font><p>
This class is an update to the class named <b>PlotALot02</b>.&nbsp; This class 
is designed to plot large amounts of data for two channels on alternating 
horizontal axes.&nbsp; One set of data is plotted using the color black.&nbsp; 
The other set of data is plotted using the color red.<p>
<font color="#FF0000"><b>Three steps for using the class</b></font><p>
As before, there are three steps involved in the use of this class for plotting 
two-channel data:<ol>
	<li>Instantiate a plotting object of <b>typePlotALot03</b>.</li>
	<li>Feed pairs of data values to the plotting object 
	by invoking the <b>feedData</b> method once for each pair of data values.&nbsp; 
	The first value in the pair will be plotted in black on one axis.&nbsp; The 
	second value in the pair will be plotted in red on an axis below that one.</li>
	<li>Invoke the <b>plotData</b> method on the plotting object when all of the 
	data has been fed to the object.&nbsp; This causes all of the data to be 
	plotted and also causes the <b>Page</b> objects to be rearranged so that 
	page 0 is on the top of the stack.</li>
	</ol>
	<p>
<font color="#FF0000"><b>A stack of Page objects</b></font><p>
The class produces a graphic output consisting of a stack of <b>Page</b> objects 
on the screen, with the data plotted on a <b>Canvas</b> object contained by the
<b>Page</b> object.<p>
Each <b>Page</b> object contains two or more horizontal axes on which the data 
is plotted.&nbsp; The class will terminate if the number of axes on the page is 
an odd number.<p>
<font color="#FF0000"><b>Alternating axes</b></font><p>
The two data sets are plotted on alternating axes as shown in Figure 3 with the data from one data 
set being plotted in black on one axis and the data from the other data set 
being plotted in red on the axis below that axis.<p>
The earliest data is plotted on the pair of axes nearest the top of the <b>Page</b> 
moving from left to right across the page.&nbsp; Positive data values are 
plotted above the axis and negative values are plotted below the axis.<p>
When the right end of an axis is reached, the next data value is plotted on the 
left end of the second axis below it skipping one axis in the process.&nbsp; 
When the right end of the last pair of axes on the <b>Page</b> is reached, a new
<b>Page</b> object is created and the next pair of data values are plotted at 
the left end of the top pair of axes on that new <b>Page</b>.<p>
<font color="#FF0000"><b>Testing with the main method</b></font><p>
For test purposes, the <b>main</b> method instantiates a single plotting object 
and feeds two data sets to that plotting object.&nbsp; The data that is fed to 
the plotting object is white random noise.&nbsp; One of the data sets is the 
sequence of values obtained from a random number generator.&nbsp; The other data 
set is the same as the first.&nbsp; Thus, the pairs of black and red data sets 
that are plotted should have the same shape making it easy to confirm that the process 
of plotting the two data sets is behaving the same in both cases.<p>
<font color="#FF0000"><b>Some data is not random</b></font><p>
Fifteen of the data values for each data set are not random for the same reasons 
discussed earlier.&nbsp; Figure 3 shows how these specific values confirm proper 
transition from one trace to the next on the same page and confirm the proper 
transition from one page to the next.<p><font color="#FF0000"><b>Modified constructor code</b></font></p>
<p>The first code that I will highlight as being different from the code in the 
class named <b>PlotALot02</b> is shown in Listing 33.&nbsp; This code appears in 
the modified constructor for the <b>PlotALot03</b> class.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>    if((tracesPerPage == 0) || 
                        (tracesPerPage%2 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if

    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/2;<br><br><b><font face="Courier New,Courier">Listing 33</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>The <b>if</b> statement in Listing 33 confirms that the number of traces per 
page is evenly divisible by two.&nbsp; If not, the program terminates.</p>
<p>The last statement in Listing 33 computes the value of <b>samplesPerPage</b> 
taking into account that only half as many samples from each data set can be 
plotted on a page as is the case when the plots of the two data sets are 
superimposed on the same axes in the class named <b>PlotALot02</b>.</p>
<p><font color="#FF0000"><b>The overridden paint method</b></font></p>
<p>Additional code that I will highlight as being different is in the overridden
<b>paint</b> method of the <b>MyCanvas</b> class.&nbsp; This code is shown in 
Listing 34, and the code that is different is highlighted in boldface.</p><p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>      public void paint(Graphics g){
        //Draw horizontal axes
        //...code deleted for brevity
        
        //Plot the points
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Plot values from the blackData 
            // array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on the odd numbered
            // axes on the page.
<b>            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*2*traceSpacing)
                                  - traceSpacing;</b>

            //Draw an oval
            //...code deleted for brevity
            //Connect the sample values with
            // straight lines.
            //...code deleted for brevity
            
            //Plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on the even numbered
            // axes on the page.
<b>            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*2*traceSpacing;</b>
            
            //Draw the ovals
            //...code deleted for brevity
            //Connect the sample values with
            // straight lines
            //...code deleted for brevity

          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02<br><br><b><font face="Courier New,Courier">Listing 34</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><font color="#FF0000"><b>Code was deleted for brevity</b></font></p>
<p>Most of the code in the overridden <b>paint</b> method is the same as the code that 
I discussed earlier and was deleted from Listing 34 for brevity.</p>
<p>The code that is different is the code that computes the vertical offset 
values to locate the black data on the odd numbered axes and to locate the red 
data on the even numbered axes as shown in Figure 3.&nbsp; I will let you work 
through the expressions in Listing 34 on your own and convince yourself that the 
code is correct.</p>
<p><font color="#FF0000"><b>End of class PlotALot03</b></font></p>
<p>Listing 34 signals the end of the overridden <b>paint</b> method, the <b>
MyCanvas</b> class, the <b>Page</b> class, and the <b>PlotALot03</b> class.</p>
<p><font color="#FF0000"><b>The class named 
PlotALot04</b></font></p>
<p>This class is an update to the class named <b>PlotALot03</b>.&nbsp; This 
class is designed to plot large amounts of three-channel data on separate 
horizontal axes.&nbsp; One set of data is plotted using the color black.&nbsp; 
The second set of data is plotted using the color red.&nbsp; The third set of 
data is plotted using the color blue.</p>
<p>The class provides a main method so that the class can be run as an 
application to test itself.&nbsp; </p>
<p><font color="#FF0000"><b>Three steps for using the class</b></font></p>
<p>There are three steps involved in the use of 
this class for plotting data:</p>
<ul>
	<li>Instantiate a plotting object of type <b>PlotALot04</b>.</li>
	<li>Feed triplets of data values to the plotting 
	object by invoking the <b>feedData</b> method once for each triplet of data 
	values.&nbsp; The first value in the triplet will be plotted in black on one 
	axis.&nbsp; The second value in the triplet will be plotted in red on an 
	axis below that axis.&nbsp; The third value in the triplet will be plotted 
	in blue on an axis below that one.</li>
	<li>Invoke the <b>plotData</b> methods on the plotting object when all of 
	the data has been fed to the object.</li>
</ul>
<p><font color="#FF0000"><b>A stack of Page objects</b></font></p>
<p>The class produces a graphic output consisting of a stack of <b>Page</b> 
objects on the screen, with the data plotted on a <b>Canvas</b> object contained 
by the <b>Page</b> object.&nbsp; The Page showing the earliest data is on the 
top of the stack and the <b>Page</b> showing the latest data is on the bottom of 
the stack.</p>
<p>Each Page object contains three or more horizontal axes on which the data is 
plotted.&nbsp; The class will terminate if the number of axes on the page is not 
evenly divisible by 3.</p>
<p>The three data sets are plotted on separate axes as shown in Figure 4 with the data from one data 
set being plotted in black on one axis, the data from the second data set being 
plotted in red on the axis below that axis, and the data from the third data set 
being plotted in blue on the axis below that axis.</p>
<p><font color="#FF0000"><b>Testing with the main method</b></font></p>
<p>For test purposes, the main method instantiates a single plotting object and 
feeds three data sets to that plotting object producing the graphic output shown 
in Figure 4.</p>
<p><font color="#FF0000"><b>Won't discuss the code</b></font></p>
<p>The code in this class is so similar to the code in the class named 
<b>PlotALot03</b> that I'm not going to discuss the code.&nbsp; You will find a 
complete listing of the class in Listing 38 near the end of the lesson.</p>



<h2 align="center"><a name="Run_the_Program">Run the Programs</a></h2>
<p>I encourage you to copy, compile, and run the programs that you will find in 
Listing 35 through Listing 38 below.&nbsp; </p>
<p>Modify the programs and experiment with 
them in order to learn as much as you can about the use of Java for plotting 
large quantities of data.&nbsp; For example, you might want to modify the 
default plotting parameters to a different set of plotting parameters 
that are more to your liking.&nbsp; One possibility is to cause the default <b>Page</b> 
size to fill the entire screen on your computer.</p>
<p>Another good exercise would be for you to convert this class to Swing using a 
look and feel that is independent of the operating system.</p>
<h2 align="center"><a name="Whats Next">What's Next?</a></h2>
<p>I will be using these four classes in a variety of future lessons involving such 
complex topics as adaptive signal processing using Java.</p>
<center>    
<h2> <a name="Summary"></a>Summary</h2>
   </center>
    In this lesson, I presented and explained four self-testing classes for 
plotting large quantities of data.&nbsp; One class plots a nearly unlimited 
amount of single-channel data using multiple traces on multiple pages.<blockquote>
	<p><i>(I have successfully plotted two 
million data values in 141 full screen pages on a modest laptop computer with 
no difficulty whatsoever.&nbsp; When I pushed that total up to eight million 
	data values in 563 full screen pages, the plotting process slowed down, but 
	I was still able to display and examine the plots.&nbsp; The practical limit 
	on my computer seems to be somewhere between two million and eight million 
	data values.)</i></p>
</blockquote>
<p>A 
second class plots a large quantity of two-channel data superimposing the two 
data sets on the same axes with the plot of one data set being colored black and 
the plot of the other data set being colored red.</p>
<p>A third class also plots a large quantity of two-channel data, but with this 
class, the two sets of data are plotted on alternating horizontal axes.&nbsp; 
Again, one set of data is colored black and the other set is colored red.</p>
<p>A fourth class plots a large quantity of three-channel data on separate axes.&nbsp; 
In this case, one set is colored black, the second set is colored red, and the 
third set is colored blue. </p>
<h2 align="center"><a name="Complete_Program_Listing">Complete Program Listings</a></h2>
<p>Complete listings of the four programs that I explained in this lesson are 
provided in Listing 35 through Listing 38 below.</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File PlotALot01.java 
Copyright 2005, R.G.Baldwin
This program is designed to plot large amounts of
time-series data for a single channel.  See
PlotALot02.java for a two-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot01 using one of two overloaded 
   constructors.
2. Feed data that is to be plotted to the 
   plotting object by invoking the feedData 
   method once for each data value.
3. Invoke one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many 
plotting objects as are needed to plot all of the
different time series that need to be plotted.
Each plotting object can be used to plot as many
data values as need be plotted until the program
runs out of available memory.

The plotting object of type PlotALot01 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the data that is 
fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains one or more horizontal 
axes on which the data is plotted.  The earliest 
data is plotted on the axis nearest the top of 
the Page moving from left to right across the 
axis.  Positive data values are plotted above
the axis and negative values are plotted below
the axis.  When the right end of an axis is 
reached, the next data value is plotted on the 
left end of the axis immediately below it.  When 
the right end of the last axis on the Page is 
reached, a new Page object is created and the 
next data value is plotted at the left end of the
top axis on that Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot01
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark the sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark the sample value on the plot.

For test purposes, the main method instantiates 
and feeds two independent plotting objects. 
Plotting parameters are specified for the first 
plotting object. Default plotting parameters are 
accepted for the second plotting object.
 
The data that is fed to each plotting object is 
white random noise. However, for the first
plotting object, fifteen of the data values are 
not random.  Rather, seven of the values are set
to values of 0,0,25,-25,25,0,0 to confirm the 
proper transition from the end of one page to the
beginning of the next page. In addition, eight of
the values are set to 0,0,20,20,-20,-20,0,0 in
order to confirm the proper transition from one 
trace to the next trace on the same page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters for each plotting object is displayed 
on the command line screen when the class is used
for plotting.  The values shown below result from
the execution of the main method of the class for
test purposes. One of the plotting objects 
instantiated by the main method is entitled "A" 
and the other is entitled "B".

Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150

Title: B
Frame width: 400
Frame height: 410
Page width: 392
Page height: 383
Trace spacing: 50
Sample spacing: 2
Traces per page: 7
Samples per page: 1372

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot01{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate two independent plotting
    // objects.  Control plotting parameters for
    // the first object.  Accept default plotting
    // parameters for the second object.
    PlotALot01 plotObjectA = 
            new PlotALot01("A",158,237,36,5,4,4);
    PlotALot01 plotObjectB = new PlotALot01("B");
    
    //Feed the data to the first plotting object.
    for(int cnt = 0;cnt &lt; 275;cnt++){
      //Plot some white random noise in the first
      // object using specified plotting
      // parameters. Note, that fifteen of the
      // following values are not random.  Seven
      // values are set to 0,0,25,-25,25,0,0
      // specifically to confirm the proper
      // transition from the end of one page to
      // the beginning of the next page.  Eight
      // values are set to 0,0,20,20,-20,-20,0,0
      // to confirm the proper transition from
      // one trace to the next trace on the same
      // page.  Note that these are the correct
      // values for an AWT Frame object under
      // WinXP.  However, a Frame may have 
      // different inset values on other
      // operating systems, which may cause these
      // specific values to be incorrect.
      if(cnt == 147){
        plotObjectA.feedData(0);
      }else if(cnt == 148){
        plotObjectA.feedData(0);
      }else if(cnt == 149){
        plotObjectA.feedData(25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25);
      }else if(cnt == 151){
        plotObjectA.feedData(25);
      }else if(cnt == 152){
        plotObjectA.feedData(0);
      }else if(cnt == 153){
        plotObjectA.feedData(0);
      }else if(cnt == 26){
        plotObjectA.feedData(0);
      }else if(cnt == 27){
        plotObjectA.feedData(0);
      }else if(cnt == 28){
        plotObjectA.feedData(20);
      }else if(cnt == 29){
        plotObjectA.feedData(20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0);
      }else if(cnt == 33){
        plotObjectA.feedData(0);
      }else{
        plotObjectA.feedData(
                       (Math.random() - 0.5)*25);
      }//end else
    }//end for loop
    //Cause the data to be plotted.
    plotObjectA.plotData(401,0);
    
    //Plot white random noise in the second
    // plotting object using default plotting
    // parameters.
    //Feed the data to the second plotting
    // object.
    for(int cnt = 0;cnt &lt; 2600;cnt++){
      plotObjectB.feedData(
                       (Math.random() - 0.5)*25);
    }//end for loop
    //Cause the data to be plotted.
    plotObjectB.plotData();
    
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot01(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot01(String title){
    //Invoke the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //Invoke this method for each point to be
  // plotted.
  void feedData(double val){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample value in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample value passes through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                              val,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //Invoke one of the overloaded versions of
  // this method once when all of the data has
  // been fed to the plotting object in order to
  // rearrange the order of the pages with
  // page 0 at the top of the stack on the
  // screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//invoke overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot01 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot01 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a sample value of type
    // double and stores it in an array object
    // belonging to the MyCanvas object.
    void putData(double sampleValue,
                 int sampleCounter){
      canvas.data[sampleCounter] = sampleValue;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] data = 
                      new double[samplesPerPage];
      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset to locate
            // the data on a particular trace.
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;
            //Draw an oval centered on the sample
            // value to mark the sample.  It is 
            // best if the dimensions of the oval
            // are evenly divisable by 2 for 
            // centering purposes.
            //Reverse the sign on sample value to
            // cause positive sample values to go
            // up on the screen
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)data[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt]);
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot01
//=============================================//

<b><font face="Courier New,Courier">Listing 35</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File PlotALot02.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot01.  This program is designed to plot 
large amounts of time-series data for two 
channels on the same axes.  One set of data is 
plotted using the color black.  The other set of 
data is plotted using the color red.  See
PlotALot01.java for a one-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot02 using one of two overloaded 
   constructors.
2. Feed pairs of data values that are to be 
   plotted to the plotting object by invoking the
   feedData method once for each pair of data 
   values.  The first value in the pair will be 
   plotted in black.  The second value in the 
   pair will be plotted in red.
3. Invoke one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different pairs of time series that need to be 
plotted.  Each plotting object can be used to 
plot as many pairs of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot02 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the pairs of data
that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains one or more horizontal 
axes on which the data is plotted.  The two time 
series are superimposed on the same axes with the
data from one time series being plotted in black 
and the data from the other time series being 
plotted in red.

The earliest data is plotted on the axis nearest 
the top of  the Page moving from left to right 
across the horizontal axis.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the axis immediately 
below it.  When the right end of the last axis on
the Page is reached, a new Page object is created
and the next data value is plotted at the left 
end of the top axis on that new Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot02
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds two time series 
to that plotting object.  Plotting parameters are
specified for the plotting object by using the 
overloaded version of the constructor that 
accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other time series is the 
same as the first except that the sign of each 
data values are reversed.  

Fifteen of the data values for each time series 
are not random.  Seven of the values for the 
first time series are setto values of 0,0,25,-25,
25,0,0.  The corresponding seven values for the 
second time series are set to the same values 
with sign reversal.  This is done to confirm the 
proper transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for the first 
time series are set to 0,0,20,20,-20,-20,0,0.  
The corresponding values for the second time 
series are set to the same values with sign 
reversal.  This is done in order to confirm the 
proper transition from one trace to the next 
trace on the same page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot02{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot02 plotObjectA = 
            new PlotALot02("A",158,237,36,5,4,4);
    
    //Feed pairs of data values to the plotting
    // object.
    for(int cnt = 0;cnt &lt; 275;cnt++){
      //Plot some white random noise Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.  Cause the values for the second
      // time series to be the negative of the
      // values for the first time series.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = -valBlack;
      //Feed pairs of values to the plotting
      // object by invoking the feedData method
      // once for each pair of data values.
      if(cnt == 147){
        plotObjectA.feedData(0,0);
      }else if(cnt == 148){
        plotObjectA.feedData(0,0);
      }else if(cnt == 149){
        plotObjectA.feedData(25,-25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25,25);
      }else if(cnt == 151){
        plotObjectA.feedData(25,-25);
      }else if(cnt == 152){
        plotObjectA.feedData(0,0);
      }else if(cnt == 153){
        plotObjectA.feedData(0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,-20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,-20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0);
      }else{
        plotObjectA.feedData(valBlack,valRed);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot02(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot02(String title){
    //Invoke the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //Invoke this method once for each pair of data
  // values to be plotted.
  void feedData(double valBlack,double valRed){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  valBlack,valRed,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //Invoke one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//invoke overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot02 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot02 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a pair of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,double valRed,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset to locate
            // the data on a particular trace.
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;
            //Begin by plotting the values from
            // the blackData array object.
            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisable
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.
            g.setColor(Color.BLACK);
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if
            
            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02
//=============================================//
<br><br><b><font face="Courier New,Courier">Listing 36</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File PlotALot03.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot02.  This program is designed to plot 
large amounts of time-series data for two 
channels on alternating horizontal axes.  One set
of data is plotted using the color black.  The 
other set of data is plotted using the color red.

See PlotALot02 for a class that plots two 
channels of data in black and red superimposed on
the same axes.  See PlotALot01.java for a 
one-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot03 using one of two overloaded 
   constructors.
2. Feed pairs of data values that are to be 
   plotted to the plotting object by invoking the
   feedData method once for each pair of data 
   values.  The first value in the pair will be 
   plotted in black on one axis.  The second 
   value in the pair will be plotted in red on an
   axis below that axis.
3. Invoke one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different pairs of time series that need to be 
plotted.  Each plotting object can be used to 
plot as many pairs of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot03 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the pairs of data
that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains two or more horizontal 
axes on which the data is plotted.  The program 
will terminate if the number of axes on the page 
is an odd number.

The two time series are plotted on alternating 
axes with the data from one time series being 
plotted in black on one axis and the data from 
the other time series being plotted in red on 
the axis below that axis.

The earliest data is plotted on the pair of axes 
nearest the top of the Page moving from left to 
right across the page.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the second axis  
below it skipping one axis in the process.  When 
the right end of the last pair of axes on the 
Page is reached, a new Page object is created and
the next pair of data values are plotted at the 
left end of the top pair of axes on that new Page
object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot03
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds two time series 
to that plotting object.  Plotting parameters are
specified for the plotting object by using the 
overloaded version of the constructor that 
accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other time series is the 
same as the first.  Thus, the pairs of black and 
red time series that are plotted should have the 
same shape making it easy to confirm that the
process of plotting the two time series is
behaving the same in both cases.

Fifteen of the data values for each time series 
are not random.  Seven of the values for each of 
the time series are set to values of 0,0,25,-25,
25,0,0.  This is done to confirm the proper 
transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for each time 
series are set to 0,0,20,20,-20,-20,0,0.  This 
is done in order to confirm the proper transition
from one trace to the next trace on the same 
page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 90

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot03{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot03 plotObjectA = 
            new PlotALot03("A",158,270,36,5,4,4);
    
    //Feed pairs of data values to the plotting
    // object.
    for(int cnt = 0;cnt &lt; 175;cnt++){
      //Plot some white random noise Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.  Cause the values for the second
      // time series to be the same as the
      // values for the first time series.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = valBlack;
      //Feed pairs of values to the plotting
      // object by invoking the feedData method
      // once for each pair of data values.
      if(cnt == 87){
        plotObjectA.feedData(0,0);
      }else if(cnt == 88){
        plotObjectA.feedData(0,0);
      }else if(cnt == 89){
        plotObjectA.feedData(25,25);
      }else if(cnt == 90){
        plotObjectA.feedData(-25,-25);
      }else if(cnt == 91){
        plotObjectA.feedData(25,25);
      }else if(cnt == 92){
        plotObjectA.feedData(0,0);
      }else if(cnt == 93){
        plotObjectA.feedData(0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0);
      }else{
        plotObjectA.feedData(valBlack,valRed);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot03(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if((tracesPerPage == 0) || 
                        (tracesPerPage%2 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/2;
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot03(String title){
    //Invoke the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //Invoke this method once for each pair of data
  // values to be plotted.
  void feedData(double valBlack,double valRed){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  valBlack,valRed,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //Invoke one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//invoke overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot03 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot03 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a pair of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,double valRed,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Begin by plotting the values from
            // the blackData array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on the odd numbered
            // axes on the page.
            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*2*traceSpacing)
                                  - traceSpacing;

            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisable
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.

            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if
            
            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on the even numbered
            // axes on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*2*traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot03
//=============================================//<br><br><b><font face="Courier New,Courier">Listing 37</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
<p>
<table border="1" cols="1" width="400" bgcolor="#ffff00">
  <tbody>
    <tr>
      <td>
      <pre>/*File PlotALot04.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot03.  This program is designed to plot 
large amounts of time-series data for three 
channels on separate horizontal axes.  One set
of data is plotted using the color black.  The 
second set of data is plotted using the color 
red.  The third set of data is plotted using the
color blue.

See PlotALot03 for a class that plots two
channels of data in black and red on alternating
axes.

See PlotALot02 for a class that plots two 
channels of data in black and red superimposed on
the same axes.  

See PlotALot01.java for a one-channel program.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot04 using one of two overloaded 
   constructors.
2. Feed triplets of data values that are to be 
   plotted to the plotting object by invoking the
   feedData method once for each triplet of data 
   values.  The first value in the triplet will 
   be plotted in black on one axis.  The second 
   value in the triplet will be plotted in red on
   an axis below that axis.  The third value in
   the triplet will be plotted in blue on an axis
   below that one.
3. Invoke one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different triplets of data that need to be 
plotted.  Each plotting object can be used to 
plot as many triplts of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot04 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the triplets of 
data that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains three or more 
horizontal axes on which the data is plotted. The
program will terminate if the number of axes on 
the page is not evenly divisable by 3.

The three time series are plotted on separate 
axes with the data from one time series being 
plotted in black on one axis, the data from 
the second time series being plotted in red on 
the axis below that axis, and the data from the
third time series being plotted in blue on the
axis below that axis.

The earliest data is plotted on the three axes 
nearest the top of the Page moving from left to 
right across the page.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the third axis  
below it skipping two axes in the process.  When 
the right end of the last triplet of axes on the 
Page is reached, a new Page object is created and
the next triplet of data values are plotted at 
the left end of the top three axes on that new 
Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot04
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds three time 
series to that plotting object.  Plotting 
parameters are specified for the plotting object 
by using the overloaded version of the 
constructor that accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other two time series are
the same as the first.  Thus, the triplets of 
black, red, and blue time series that are plotted
should have the same shape making it easy to 
confirm that the process of plotting the three 
time series is behaving the same in all three
cases.

Fifteen of the data values for each time series 
are not random.  Seven of the values for each of 
the time series are set to values of 0,0,25,-25,
25,0,0.  This is done to confirm the proper 
transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for each time 
series are set to 0,0,20,20,-20,-20,0,0.  This 
is done in order to confirm the proper transition
from one trace to the next trace on the same 
page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 60

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot04{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot04 plotObjectA = 
            new PlotALot04("A",158,270,36,5,4,4);
    
    //Feed triplets of data values to the 
    // plotting object.
    for(int cnt = 0;cnt &lt; 115;cnt++){
      //Plot some white random noise. Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = valBlack;
      double valBlue = valBlack;
      //Feed triplets of values to the plotting
      // object by invoking the feedData method
      // once for each triplet of data values.
      if(cnt == 57){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 58){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 59){
        plotObjectA.feedData(25,25,25);
      }else if(cnt == 60){
        plotObjectA.feedData(-25,-25,-25);
      }else if(cnt == 61){
        plotObjectA.feedData(25,25,25);
      }else if(cnt == 62){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 63){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,20,20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,20,20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,-20,-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,-20,-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0,0);
      }else{
        plotObjectA.feedData(valBlack,
                             valRed,
                             valBlue);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot04(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if((tracesPerPage == 0) || 
                        (tracesPerPage%3 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/3;
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot04(String title){
    //Invoke the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //Invoke this method once for each triplet of 
  // data values to be plotted.
  void feedData(double valBlack,
                double valRed,
                double valBlue){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                                  valBlack,
                                  valRed,
                                  valBlue,
                                  sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //Invoke one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//invoke overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot04 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot04 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a triplet of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,
                 double valRed,
                 double valBlue,
                 int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      canvas.blueData[sampleCounter] = valBlue;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
      double [] blueData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Begin by plotting the values from
            // the blackData array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on every third axis
            // on the page.
            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*3*traceSpacing)
                                - 2*traceSpacing;

            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisable
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.

            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if

            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on every third axis
            // on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                  this.getWidth())*3*traceSpacing
                                  - traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          

            //Now plot the data stored in the
            // blueData array object.
            g.setColor(Color.BLUE);
            //Compute a vertical offset to locate
            // the blue data on every third axis
            // on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*3*traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blueData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blueData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blueData[cnt]);
            }//end if          
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot04
//=============================================//<br><br><b><font face="Courier New,Courier">Listing 38</font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>&nbsp;</p>
</p>

     
<hr align="center" size="3" width="100%">
<p>Copyright 2005, Richard G. Baldwin.&nbsp; Reproduction in whole or in part in any 
form or medium without express written permission from Richard Baldwin is 
prohibited. </p>
<h4><a name="About_the_author">About the author</a></h4>
<b><a href="mailto:Baldwin@DickBaldwin.com">Richard Baldwin</a></b><i> is a 
college professor (at Austin Community College in Austin, TX) and private 
consultant whose primary focus is a combination of Java, C#, and XML. In 
addition to the many platform and/or language independent benefits of Java and 
C# applications, he believes that a combination of Java, C#, and XML will become 
the primary driving force in the delivery of structured information on the Web.</i>    
<p><i>Richard has participated in numerous consulting projects and he 
frequently provides onsite training at the high-tech companies located in and 
around Austin, Texas.&nbsp; He is the author of Baldwin's Programming
<a href="http://www.dickbaldwin.com">Tutorials</a>, which have gained a 
worldwide following among experienced and aspiring programmers. He has also 
published articles in JavaPro magazine.</i> </p>
<p><i>In addition to his programming expertise, Richard has many years of 
practical experience in Digital Signal Processing (DSP).&nbsp; His first job after he 
earned his Bachelor's degree was doing DSP in the Seismic Research Department of 
Texas Instruments.&nbsp; (TI is still a world leader in DSP.)&nbsp; In the following 
years, he applied his programming and DSP expertise to other interesting areas 
including sonar and underwater acoustics.</i> </p>
<p><i>Richard holds an MSEE degree from Southern Methodist University and has 
many years of experience in the application of computer technology to real-world 
problems.</i> </p>
<p><i><a href="mailto:baldwin@dickbaldwin.com">Baldwin@DickBaldwin.com</a></i>
</p>
<p><b>Keywords</b><br>
Java plot multi-channel Canvas horizontal vertical axis oval overridden paint</p>
<p>-end- </p>
</body>
</html>
